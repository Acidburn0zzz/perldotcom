<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Xplane on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/xplane/</link>
    <description>Recent content in Xplane on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 12 Jul 2004 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/xplane/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Autopilots in Perl</title>
      <link>http://localhost:1313/pub/2004/07/09/xplane.html/</link>
      <pubDate>Mon, 12 Jul 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/07/09/xplane.html/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://www.x-plane.com&#34;&gt;X-Plane&lt;/a&gt; is an ultra-realistic flight simulator used by aviation pioneers like Burt Rutan, who uses it in his &lt;a href=&#34;http://www.popsci.com/popsci/aviation/article/0,12543,463052%2D3,00.html&#34;&gt;simulator&lt;/a&gt; for SpaceShipOne. The latest revision sports a flight model so accurate that the FAA has decided that your time spent in the simulator can count toward a pilot&amp;rsquo;s license.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll learn how to monitor and control our virtual plane, and display our virtual aircraft&amp;rsquo;s status in real-time in a &lt;code&gt;Curses&lt;/code&gt; window. Our display will be data-driven so that adding a single entry to a hash reference is all you need to display a new data element.&lt;/p&gt;

&lt;h3 id=&#34;span-id-software-requirements-software-requirements-span&#34;&gt;&lt;span id=&#34;Software_Requirements&#34;&gt;Software Requirements&lt;/span&gt;&lt;/h3&gt;

&lt;h4 id=&#34;span-id-curses-on-os-x-curses-on-os-x-span&#34;&gt;&lt;span id=&#34;Curses_on_OS_X&#34;&gt;Curses on OS X&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Curses v1.06 seems to have some issues building on the author&amp;rsquo;s machine running OS X 10.3. Replacing &lt;code&gt;Perl_sv_isa&lt;/code&gt; with &lt;code&gt;sv_isa&lt;/code&gt; on line 275 of &lt;code&gt;Curses.c&lt;/code&gt;, along with commenting out &lt;code&gt;#define    C_LONGNAME&lt;/code&gt; and &lt;code&gt;#define C_TOUCHLINE&lt;/code&gt; in &lt;code&gt;c-config.h&lt;/code&gt; lets &lt;code&gt;Curses&lt;/code&gt; compile with enough functionality to run the monitor program.&lt;/p&gt;

&lt;h4 id=&#34;span-id-configuring-the-sim-configuring-the-sim-span&#34;&gt;&lt;span id=&#34;Configuring_the_Sim&#34;&gt;Configuring the Sim&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Throughout this article, we assume that you&amp;rsquo;re using X-Plane version 7.41 or higher (the demo version has all the functionality we need), and you&amp;rsquo;re flying the standard Boeing 777. This has retractable landing gears and brakes, two features we&amp;rsquo;ll eventually control from inside the monitor program, &lt;a href=&#34;http://localhost:1313/media/_pub_2004_07_09_xplane/X-Plane.pl&#34;&gt;&lt;em&gt;X-Plane.pl&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Once you&amp;rsquo;re settled in your airplane&amp;rsquo;s cockpit, choose the Settings menu at the top of the screen and choose Data Input &amp;amp; Output under that menu. A window should open to the default tab, Data Set. This is where we tell the simulator which channels of data to transmit over the network where our monitor can listen for them.&lt;/p&gt;

&lt;p&gt;Currently, &lt;em&gt;X-Plane.pl&lt;/em&gt; displays gear up/down status, throttle percentage, latitude and longitude, pitch and roll, and the simulation frame rate. To enable these channels for display, click the checkboxes just to the right of rows 12, 23, 18, 16, and 0 (respectively).&lt;/p&gt;

&lt;p&gt;If you like, you can also click the checkboxes on the far right of each column to display the channel data on the plane&amp;rsquo;s windshield, as well. This is handy for debugging, especially if you&amp;rsquo;re attempting to monitor new data and don&amp;rsquo;t know what the values look like. Also, the channel numbers seem to change version to version, and if you&amp;rsquo;re using a version other than 7.41, you may need to change the code to correspond to the simulator.&lt;/p&gt;

&lt;p&gt;Finally, the simulator has to be told where to send the monitoring packets. Choose the Inet2 tab, and click on the checkbox next to IP address of data receiver. Fill in the left-hand box with the IP address of the machine you&amp;rsquo;re running &lt;em&gt;X-Plane.pl&lt;/em&gt; on, and fill in the right-hand box with 49999, the UDP port on which &lt;em&gt;X-Plane.pl&lt;/em&gt; listens.&lt;/p&gt;

&lt;p&gt;Incidentally, even though the monitor program acts as an instruction console, you don&amp;rsquo;t need to turn on the Instructor Console option listed here. It may be necessary, should you want to deal with more advanced communication such as triggering system failures, but for current purposes all we need to configure is the data receiver.&lt;/p&gt;

&lt;p&gt;By default, &lt;em&gt;X-Plane.pl&lt;/em&gt; listens to packets sent to 127.0.0.1 over port 49999, and sends packets to the same host on port 49000. Passing command-line parameters to &lt;em&gt;X-Plane.pl&lt;/em&gt; can override these settings, but the documentation for the simulator seems to indicate that it&amp;rsquo;s hardcoded to listen on port 49000 for its commands, so be warned if you try to change this particular default.&lt;/p&gt;

&lt;h3 id=&#34;span-id-running-the-monitor-running-the-monitor-span&#34;&gt;&lt;span id=&#34;Running_the_monitor&#34;&gt;Running the Monitor&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Communicating at the UDP layer is a different, and much simpler, world than dealing with a full TCP/IP packet. The main differences here are that we don&amp;rsquo;t get any acknowledgement that a UDP packet is sent, and can&amp;rsquo;t even guarantee that the packet was sent at all. The practical upshot of this is that we can start and stop &lt;em&gt;X-Plane.pl&lt;/em&gt; at any time, without the need for fancy socket tear-down protocols, and we don&amp;rsquo;t need to stop the simulator every time we change &lt;em&gt;X-Plane.pl&lt;/em&gt;&amp;rsquo;s code.&lt;/p&gt;

&lt;p&gt;Once we&amp;rsquo;ve started the simulator and &lt;em&gt;X-Plane.pl&lt;/em&gt; it should start displaying the plane&amp;rsquo;s position (longitude/latitude), orientation (pitch/roll), speed, and current throttle settings. If it doesn&amp;rsquo;t, switch back to the simulator window and make sure the cockpit is being displayed. The gear display mimics an indicator lamp, with &lt;code&gt;[#]&lt;/code&gt; representing a lit lamp, and &lt;code&gt;[ ]&lt;/code&gt; being a dark lamp.&lt;/p&gt;

&lt;p&gt;The simulator will only send out UDP packets when the cockpit is being displayed, and if you&amp;rsquo;re running in demo mode, it decides to interrupt your flight six minutes in with two dialog boxes that effectively stop packet transmission. If it&amp;rsquo;s still displaying the cockpit, make sure that the simulator is transmitting data to the right port on the right machine, and if all else fails, watch the network with a utility such as &lt;code&gt;tcpdump&lt;/code&gt; to make sure UDP packets are being sent out. Press the &lt;code&gt;G&lt;/code&gt; key to raise and lower the gear and the &lt;code&gt;I&lt;/code&gt; and &lt;code&gt;K&lt;/code&gt; keys to advance and retard the throttles, even on the runway. Note that the gear indicator lamp on the monitor will change before the gear handle does. Also, if running the simulator on the same machine as the monitor, you may need to bring the window with the simulator to the foreground before changes are registered.&lt;/p&gt;

&lt;p&gt;By the way, the Boeing 777 is equipped with thrust reversers, so negative throttle settings actually make sense. Also, the flight profile dictates running the engines up to 110% of rated power on takeoff, so throttle settings beyond 100% are also legitimate.&lt;/p&gt;

&lt;h3 id=&#34;span-id-talking-to-x-plane-talking-to-x-plane-span&#34;&gt;&lt;span id=&#34;Talking_to_X-Plane&#34;&gt;Talking to X-Plane&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Communicating with the simulator is done entirely via UDP packets. While the simulator can send and receive various types of packets, we&amp;rsquo;ll focus on one type of packet in particular, the &lt;code&gt;DATA&lt;/code&gt; packet. The simulator communicates using packets like that described in Figure 1. The first 4 bytes of the header are the ASCII characters naming the type of packet, and the actual data is surrounded by a zero byte on both ends.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2004_07_09_xplane/Figure_1.jpg&#34; width=&#34;311&#34; height=&#34;104&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In between the zero bytes, we get one 36-byte chunk for every channel the simulator sends out. Each 36-byte chunk is broken down into two sections. The first section is a four-byte index corresponding to the channel number on the &amp;ldquo;Data Set&amp;rdquo; screen, and the rest of the chunk contains eight four-byte elements.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2004_07_09_xplane/Figure_2.jpg&#34; width=&#34;401&#34; height=&#34;248&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The actual data types of the individual elements has changed from version to version, but 7.41 seems to have settled on one layout for inbound, and a different one for outbound. When transmitting data, the simulator sends all elements as floating-point types, but receives a mixture of floating-point and long integers.&lt;/p&gt;

&lt;h4 id=&#34;span-id-sending-data-sending-data-span&#34;&gt;&lt;span id=&#34;Sending_data&#34;&gt;Sending Data&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Handling the mixture of data types is largely the job of the core data structure in &lt;em&gt;X-Plane.pl&lt;/em&gt;, the &lt;code&gt;$DATA_packet&lt;/code&gt; hash reference. Starting on line 92, this data structure encapsulates everything we want to know about the simulator packet.&lt;/p&gt;

&lt;p&gt;Given that there are currently 113 channels of data that the simulator can send out, and that the author is lazy, we&amp;rsquo;re not going to type in all 113 channels&amp;rsquo; worth of data. Instead, we&amp;rsquo;ll store just the channels we want to display in what computer scientists call a &amp;ldquo;sparse array,&amp;rdquo; but Perl programmers call it a &amp;ldquo;hash reference.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;One useful feature the monitoring program doesn&amp;rsquo;t have is controlling the brakes. In the simulator, brakes can be applied with a variable pressure, but for our purposes they only have two settings: &amp;ldquo;Screeching halt&amp;rdquo; and &amp;ldquo;Let it roll.&amp;rdquo; The first order of business is to find out what channel brakes are displayed on.&lt;/p&gt;

&lt;p&gt;Going back to the &amp;ldquo;Data Set&amp;rdquo; tab in the simulator, we look for &amp;ldquo;brakes&amp;rdquo; on the list. In version 7.41 they&amp;rsquo;re on channel 12, &amp;ldquo;gear/brakes.&amp;rdquo; Conveniently enough, we&amp;rsquo;re already displaying the gear setting, so it shouldn&amp;rsquo;t be much work to add brakes to the list.&lt;/p&gt;

&lt;p&gt;Now that we know what channel brakes are on, we need to know where in the channel they&amp;rsquo;re stored. After all, we have eight elements to look through. So, click on the checkbox on the far right of row 12 to display that channel&amp;rsquo;s contents on the windshield and close the window.&lt;/p&gt;

&lt;p&gt;At the upper right-hand corner we should see the channel contents being displayed. We&amp;rsquo;re mostly curious about the &lt;code&gt;wbrak&lt;/code&gt; setting, which is element number 1 (counting from zero, of course.) The simulator also tells us that it&amp;rsquo;s of &lt;code&gt;part&lt;/code&gt; type, which means that it&amp;rsquo;s a floating point value.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll first need to display the brake setting. We do this at line 112, duplicating the block for the gear status and creating the following entry, which specifies that element 1 of channel 12 is a floating-point number representing brakes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    1 =&amp;gt; { type =&amp;gt; &#39;f&#39;, label =&amp;gt; &#39;Brakes&#39;,
           label_x =&amp;gt; 0, label_y =&amp;gt; 4,
           x =&amp;gt; 7, y =&amp;gt; 4 },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Restart the monitor program, and you should have a new entry for &amp;ldquo;Brakes&amp;rdquo; followed by a 0 or 1. Clicking on the &amp;ldquo;BRAKES&amp;rdquo; light in the cockpit should toggle the value. Once you&amp;rsquo;ve verified that the new brake display works, it&amp;rsquo;s time to add the code that actually sets/releases the brakes. On line 270, insert the code that transmits the new brake status to the simulator, that looks roughly like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  elsif($ch eq &#39;b&#39;) {
    transmit_DATA(
          $socket,
          12,
          -999,
          $DATA_buffer-&amp;gt;{12}{1} ? 0 : 1,
          (-999) x 6);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since the gear and brakes are on the same channel, we have to tell the simulator to ignore the gear while letting us set the brake value, so we use the placeholder value of -999. The old brake value is saved in &lt;code&gt;$DATA_buffer-&lt;/code&gt;{12}{1}&amp;gt;, so we set the opposite of whatever was there before.&lt;/p&gt;

&lt;p&gt;Rerun the monitor program, and pressing &amp;ldquo;b&amp;rdquo; should clear and set the &amp;ldquo;brake&amp;rdquo; light on the simulator&amp;rsquo;s indicator panel. When the light is out, the aircraft should naturally start rolling, and the simulated light on the &lt;code&gt;Curses&lt;/code&gt; window should go out.&lt;/p&gt;

&lt;p&gt;Of course, not all types of variable are as simple to deal with as the brakes and gears. The throttle settings should give you an idea of how to work with more advanced data types, and of course you&amp;rsquo;re not restricted to a &lt;code&gt;Curses&lt;/code&gt; display. It just happens that &lt;code&gt;Curses&lt;/code&gt; is fairly convenient and low-bandwidth, but nothing is preventing you from transplanting the code into a &lt;code&gt;GTK&lt;/code&gt; event loop.&lt;/p&gt;

&lt;p&gt;While you can change values in every channel, the simulator may not react to those changes. For instance, you can&amp;rsquo;t change the latitude and longitude of the plane and expect it to teleport to the new location.&lt;/p&gt;

&lt;p&gt;The values for latitude and longitude are actually computed from the values in channel 19, the X, Y and Z coordinates. Changing these will actually affect the plane&amp;rsquo;s position in space. However, there doesn&amp;rsquo;t appear to be a simple reference that will describe what values are considered read-only.&lt;/p&gt;

&lt;p&gt;The official UDP documentation doesn&amp;rsquo;t contain this, and the only UDP FAQ on the &amp;lsquo;net for X-Plane appears not to have been updated since version 6. Of course, some of the channels make no sense on certain aircraft. For instance, the Cessna 172 (which the author has several hours&amp;rsquo; experience in) doesn&amp;rsquo;t have retractable gear.&lt;/p&gt;

&lt;h4 id=&#34;span-id-receiving-data-receiving-data-span&#34;&gt;&lt;span id=&#34;Receiving_data&#34;&gt;Receiving Data&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Receiving data is also done through the &lt;code&gt;$DATA_packet&lt;/code&gt; sparse array. In this case, the element type is just used for display purposes, as the channel is transmitted in floating point, and not the mixed format. The entry for &amp;ldquo;True Speed&amp;rdquo;, which is displayed in miles per hour, looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 104 2 =&amp;gt; {
 105   0 =&amp;gt; { type =&amp;gt; &#39;mph&#39;, label =&amp;gt; &#39;True Speed&#39;,
 106          label_x =&amp;gt; 0, label_y =&amp;gt; 1,
 107          x =&amp;gt; 12, y =&amp;gt; 1 },
 108 },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When time comes to walk the &lt;code&gt;DATA&lt;/code&gt; packet, this entry tells us to see if we&amp;rsquo;ve received data channel 2 (line 104). If we have, look at element 0, and display the element at (12,1) in the window (line 107.) Since the type is &amp;ldquo;mph&amp;rdquo; (line 105), we know that we have to format that specially.&lt;/p&gt;

&lt;p&gt;Special types like &amp;ldquo;mph&amp;rdquo; and &amp;ldquo;deg&amp;rdquo; are stored in another hash reference, back on lines 81-85. When the time comes to display the actual data, we look into this hash reference to pull out the format string to use when &lt;code&gt;sprintf()&lt;/code&gt;&amp;lsquo;ing the data. The &lt;code&gt;len&lt;/code&gt; hash key gets used as well at this time, to create a mask of space characters that we use to erase the old value completely before displaying the new value.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  81 my $typedef = {
  82   deg =&amp;gt; { format =&amp;gt; &amp;quot;%+03.3f&amp;quot;, len =&amp;gt; 8 },
  83   mph =&amp;gt; { format =&amp;gt; &amp;quot;%03.3f&amp;quot;, len =&amp;gt; 7 },
  84   pct =&amp;gt; { format =&amp;gt; &amp;quot;%+01.3f&amp;quot;, len =&amp;gt; 6 },
  85 };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A special type &lt;code&gt;bool&lt;/code&gt; is used for indicator lamps (since indicator lamps are either on or off), but is handled specially. The pseudo-types &lt;code&gt;l&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; aren&amp;rsquo;t represented here, but are used when we need to return data to the simulator. While the simulator sends out only floating-point numbers, it receives a mixture of floating-point and integer values, and the mixture changes on a per-channel basis.&lt;/p&gt;

&lt;p&gt;Instead of making the programmer create the format strings that we&amp;rsquo;ll use later on to &lt;code&gt;pack()&lt;/code&gt; and &lt;code&gt;unpack()&lt;/code&gt; packets, we pre-compute them in the function &lt;code&gt;create_pack_strings()&lt;/code&gt;. Since the individual elements may occur anywhere in the eight-element array, we may need to skip over elements, and that&amp;rsquo;s done with liberal use of &lt;code&gt;x4&lt;/code&gt; in the format, which tells &lt;code&gt;pack()&lt;/code&gt; and &lt;code&gt;unpack()&lt;/code&gt; to ignore 4 bytes&amp;rsquo; worth of data.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 164 sub create_pack_strings {
 165   for my $row (values %$DATA_packet) {
 166     $row-&amp;gt;{unpack} = &#39;x4&#39;;
 167     $row-&amp;gt;{pack} = &#39;l&#39;;
 168     for my $j (0..DATA_max_element) {
 169       if(exists $row-&amp;gt;{$j}) {
 170         my $col = $row-&amp;gt;{$j};
 171         $row-&amp;gt;{pack} .=
 172           (grep { $col-&amp;gt;{type} eq $_ } @float_formats) ? &#39;f&#39; : &#39;l&#39;;
 173         $row-&amp;gt;{unpack} .= &#39;f&#39;;
 174       }
 175       else {
 176         $row-&amp;gt;{pack} .= &#39;f&#39;;
 177         $row-&amp;gt;{unpack} .= &#39;x4&#39;;
 ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Starting at line 164, &lt;code&gt;create_pack_strings()&lt;/code&gt; handles this tedious job for us, by walking the two-dimensional hash reference &lt;code&gt;$DATA_packet&lt;/code&gt;. Line 166 starts the unpack() string with &lt;code&gt;x4&lt;/code&gt;, which tells the &lt;code&gt;unpack()&lt;/code&gt; function to skip over the index long in the packet. We have to unpack the index beforehand in order to know how to deal with the data, so we just ignore that.&lt;/p&gt;

&lt;p&gt;Line 167 starts the &lt;code&gt;pack()&lt;/code&gt; string with a long, &lt;code&gt;l&lt;/code&gt; for the inbound index. Lines 168 onward create the individual elements. The &lt;code&gt;unpack()&lt;/code&gt; strings are &lt;code&gt;f&lt;/code&gt; if the element is in use, &lt;code&gt;x4&lt;/code&gt; if it&amp;rsquo;s not. This means that the format strings only extract the data we need, which makes it easier later on when time comes to actually call &lt;code&gt;unpack()&lt;/code&gt; on the actual data.&lt;/p&gt;

&lt;p&gt;Lines 171-2 and 176 create the &lt;code&gt;pack()&lt;/code&gt; format string, using &lt;code&gt;f&lt;/code&gt; for floating-point formats and &lt;code&gt;l&lt;/code&gt; for integer types. Since there&amp;rsquo;s no special way to tell the simulator what elements we&amp;rsquo;re updating, we have to send back every element. Unused elements are filled with a sentinel value of -999 to say &amp;ldquo;Do not update this value.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;In the end, we&amp;rsquo;ve added &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt; hash keys to every channel in our &lt;code&gt;$DATA_packet&lt;/code&gt; structure. Unpacking a channel structure with this format returns to us only the data we&amp;rsquo;re interested in, and skips over unused elements so we don&amp;rsquo;t have to account for empty elements in the array that &lt;code&gt;pack()&lt;/code&gt; returns to us.&lt;/p&gt;

&lt;p&gt;Likewise, the &lt;code&gt;pack&lt;/code&gt; hash key gives us a string to create an entire channel&amp;rsquo;s worth of data, with the proper data types. This is important, even in what should be a simple channel like the gear and brake display. While gears get set to an integer 1 or 0, brakes have to be set to a float from 0 through 1, to account for variable pressure.&lt;/p&gt;

&lt;h4 id=&#34;span-id-pulling-apart-the-packet-pulling-apart-the-packet-span&#34;&gt;&lt;span id=&#34;Pulling_apart_the_packet&#34;&gt;Pulling Apart the Packet&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;All of the heavy lifting gets done in the &lt;code&gt;receive_DATA()&lt;/code&gt; function, from lines 193-234. This function accepts the message sent over the UDP port and breaks it into individual channel-sized packets. The adventure starts on line 196, after clearing a small internal buffer we use to record the last packet received.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  196   for (my $i = 0;
  197        $i &amp;lt; (length($message)-&amp;amp;DATA_header_size-1) / DATA_element_size;
  198        $i++) {
  199    my $channel = substr($message,
  200                         $i * DATA_element_size + DATA_header_size,
  201                         DATA_element_size);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Line 197 computes the number of channels this particular message contains (we&amp;rsquo;re doing this on-the-fly in case you want to change the channel selection while the simulator is running.) The &lt;code&gt;substr()&lt;/code&gt; call breaks the message into chunks of &lt;code&gt;DATA_element_size&lt;/code&gt; bytes, and gives us back a channel&amp;rsquo;s worth of data.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  203    my $index = unpack &amp;quot;l&amp;quot;, $channel;
  204    next unless exists $DATA_packet-&amp;gt;{$index};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we extract the index (the first byte) of the channel so that we can unpack the data appropriately. If we don&amp;rsquo;t know anything about this channel (i.e., if it isn&amp;rsquo;t present in the &lt;code&gt;$DATA_packet&lt;/code&gt; hashref), we reject it and move on. This makes us somewhat immune to changes in format.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  206    my $row = $DATA_packet-&amp;gt;{$index};
  207    my @element = unpack $row-&amp;gt;{unpack}, $channel;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we get back the elements we&amp;rsquo;re interested in here by &lt;code&gt;unpack&lt;/code&gt;ing with the format string that got calculated in &lt;code&gt;create_pack_strings()&lt;/code&gt;. The format string skips the index and unpacks just the elements we wanted. So, now we walk our proffered hash and extract the individual elements:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  208     my $ctr = 0;
  209     for my $j (0..DATA_max_element) {
  210       next unless exists $row-&amp;gt;{$j};
  211       my $col = $row-&amp;gt;{$j};
  212       $DATA_buffer-&amp;gt;{$index}{$j} = $element[$ctr];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Line 208 initializes a counter so that we can keep track of which element we&amp;rsquo;ve extracted. Line 209 loops through each possible element in order, so we take into account the possibility that we haven&amp;rsquo;t used a data element.&lt;/p&gt;

&lt;p&gt;Lines 210-212 skip unused elements in the sparse array, and saves the content in &lt;code&gt;$DATA_buffer&lt;/code&gt;, so we can have keys like &lt;code&gt;g&lt;/code&gt; toggle the gear setting, rather than having one key to raise the gear and one key to lower them.&lt;/p&gt;

&lt;p&gt;Finally, we display each element based on its type. Boolean types are displayed as either &lt;code&gt;[#]&lt;/code&gt; or &lt;code&gt;[ ]&lt;/code&gt; depending upon whether the element is a floating one or zero. They&amp;rsquo;re still written out as an integer, but displayed as floating.&lt;/p&gt;

&lt;p&gt;Types such as &lt;code&gt;deg&lt;/code&gt; and &lt;code&gt;mph&lt;/code&gt; with a registered format are handled specially. We first wipe out the old data completely by overwriting with spaces. This prevents a potential issue with the old value being &amp;ldquo;3.14159&amp;rdquo;, and the new value being &amp;ldquo;2.7&amp;rdquo;. If we didn&amp;rsquo;t overwrite the old value, it would be displayed as &amp;ldquo;2.74159&amp;rdquo;, with the extra digits remaining from the old display.&lt;/p&gt;

&lt;p&gt;If we&amp;rsquo;ve not been told what to do with this (which is the case with Frame Rate), simply print the value and go onward.&lt;/p&gt;

&lt;h3 id=&#34;span-id-data-driven-design-data-driven-design-span&#34;&gt;&lt;span id=&#34;Data-Driven_design&#34;&gt;Data-Driven Design&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In the current monitor program, each channel in a &lt;code&gt;DATA&lt;/code&gt; packet corresponds to a set of fields onscreen. Instead of creating a function to display the onscreen labels and another one to extract the information from the packets, we&amp;rsquo;ve elected to combine the label information with the channel and field, in one easy-to-use format.&lt;/p&gt;

&lt;p&gt;Since the number of channels and their layout varies between versions of the simulator, we&amp;rsquo;ve chosen to represent the channels in a two-tiered hash reference. The outer tier represents a channel, and the inner tier represents the fields inside that channel.&lt;/p&gt;

&lt;p&gt;This means that if a channel changes index number (as the pitch and roll channel did from version 7.1 to 7.4), we simply update the channel number in the hashref rather than cutting out a block of code and repositioning it in an array, making maintenance easier.&lt;/p&gt;

&lt;p&gt;Since this data likely won&amp;rsquo;t change over the lifetime of the program, we&amp;rsquo;ll store it in a global hash reference, &lt;code&gt;$DATA_packet&lt;/code&gt; starting at line 92. We can reference a given element in an arbitrary channel with the code fragment &lt;code&gt;$DATA_packet-&lt;/code&gt;{$channel}{$element}&amp;gt;, but the code usually ends up iterating by channel and by element.&lt;/p&gt;

&lt;p&gt;The sample for the gear display starts at line 109, and the entire channel/element reference looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  109  12 =&amp;gt; {
  110    0 =&amp;gt; { type =&amp;gt; &#39;bool&#39;, label =&amp;gt; &#39;Gear&#39;,
  111           label_x =&amp;gt; 0, label_y =&amp;gt; 3,
  112           x =&amp;gt; 6, y =&amp;gt; 3 },
  113  },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the only element in channel 12, and sits at element 0. Boolean types are displayed with &lt;code&gt;[#]&lt;/code&gt; and &lt;code&gt;[ ]&lt;/code&gt; representing indicator lamps, and it specifies the screen coordinates of the label (&lt;code&gt;label_x&lt;/code&gt; and &lt;code&gt;label_y&lt;/code&gt;) and where the actual indicator goes (&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;After &lt;code&gt;Curses&lt;/code&gt; initializes, the &lt;code&gt;setup_display()&lt;/code&gt; function iterates over this two-tiered hash and draws the label strings that won&amp;rsquo;t change. Lines 148-156 take care of this, and show how to iterate over the data structure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  148 sub setup_display {
  149   for my $channel (values %$DATA_packet) {
  150     for my $element (values %$channel) {
  151       $win-&amp;gt;addstr($element-&amp;gt;{label_y},
  152                    $element-&amp;gt;{label_x},
  153                    $element-&amp;gt;{label}) if $element-&amp;gt;{label};
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that &lt;code&gt;$win-&lt;/code&gt;addstr()&amp;gt; takes the Y coordinate followed by the X coordinate, in accordance with long-standing tradition. Later on, we&amp;rsquo;ll use the &lt;code&gt;type&lt;/code&gt; hash key to tell us how to display this data, but that&amp;rsquo;s handled when we receive a message.&lt;/p&gt;

&lt;h3 id=&#34;span-id-initialization-and-shutdown-initialization-and-shutdown-span&#34;&gt;&lt;span id=&#34;Initialization_and_Shutdown&#34;&gt;Initialization and Shutdown&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;We start by handling the usual command-line options on lines 24-32, including a &lt;code&gt;-h&lt;/code&gt; option to display usage. &lt;code&gt;-x&lt;/code&gt; sets the X-Plane IP address to something other than the default of &amp;ldquo;127.0.0.1,&amp;rdquo; &lt;code&gt;-r&lt;/code&gt; changes the port the monitor listens on from 49999 to something else.&lt;/p&gt;

&lt;p&gt;Incidentally, the listening port cannot be 49000, as that&amp;rsquo;s where the simulator listens for its commands. &lt;code&gt;-t&lt;/code&gt; tells the monitor to transmit on a different port than 49000, although the simulator is documented to listen to only port 49000. &lt;code&gt;-d&lt;/code&gt; is there in case this gets run with earlier versions than 7.4, where the packet format varied depending upon the operating system the simulator was running on.&lt;/p&gt;

&lt;p&gt;After command-line configuration is processed and defaults overridden, we create the UDP sockets, on lines 48-65. Instead of the usual TCP protocol, we open UDP ports as that&amp;rsquo;s what the simulator communicates with. If we did this after initializing &lt;code&gt;Curses&lt;/code&gt;, our error text would be eaten by the terminal, so we place this first.&lt;/p&gt;

&lt;h4 id=&#34;span-id-startup-and-shutdown-of-curses-startup-and-shutdown-of-curses-span&#34;&gt;&lt;span id=&#34;Startup_and_shutdown_of_Curses&#34;&gt;Startup and Shutdown of Curses&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The Curses startup proceeds fairly normally starting on line 314, with the call to &lt;code&gt;noecho()&lt;/code&gt; and &lt;code&gt;cbreak()&lt;/code&gt; stopping the terminal from echoing key presses and suppressing carriage returns. &lt;code&gt;$win-&amp;gt;timeout(1);&lt;/code&gt; lets us read key presses without blocking, so we can display packets as they come in real-time without having to wait for key presses.&lt;/p&gt;

&lt;h4 id=&#34;span-id-displaying-text-displaying-text-span&#34;&gt;&lt;span id=&#34;Displaying_text&#34;&gt;Displaying Text&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Since Curses implementations vary widely in functionality, we limit ourselves to making &lt;code&gt;addstr()&lt;/code&gt; and &lt;code&gt;getch()&lt;/code&gt; calls to ensure maximum compatibility across platforms. Inside &lt;code&gt;setup_display()&lt;/code&gt; we draw the static labels such as &amp;ldquo;Gear&amp;rdquo; and &amp;ldquo;Pitch,&amp;rdquo; and do the job of displaying the actual values inside &lt;code&gt;receive_DATA()&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-main-loop-the-main-loop-span&#34;&gt;&lt;span id=&#34;The_main_loop&#34;&gt;The Main Loop&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;This makes the main loop on lines 301-311 pretty straightforward. We poll the keyboard, and display the latest data packet if there isn&amp;rsquo;t one. Otherwise, check to see if the user pressed &amp;ldquo;q&amp;rdquo;, in which case we quit. UDP sockets don&amp;rsquo;t require any special tear down, so all that&amp;rsquo;s left is to call &lt;code&gt;endwin();&lt;/code&gt;. If the user pressed a command key, create an appropriate packet and send that out.&lt;/p&gt;

&lt;p&gt;With just the &lt;code&gt;DATA&lt;/code&gt; packet, you can create your own customized cockpit display, even take this sample source and turn it into a &lt;code&gt;Gtk&lt;/code&gt; application that lets you monitor your plane graphically. The &lt;code&gt;VEHA&lt;/code&gt; packet type adds even more possibilities. You could read a friend&amp;rsquo;s virtual location and add his plane as traffic in your virtual world.&lt;/p&gt;

&lt;p&gt;Even better, scrape HTML from a flight-tracker service and add real traffic to your virtual world! The &lt;code&gt;FAIL&lt;/code&gt; and &lt;code&gt;RECO&lt;/code&gt; packet types can cause simulated system failures, so you can create your own in-flight emergencies in Perl! You can even go all the way, and use the &lt;code&gt;SNAP&lt;/code&gt; packet type to completely override X-Plane&amp;rsquo;s flight model, telling X-Plane how you think the aircraft should fly.&lt;/p&gt;

&lt;p&gt;Hopefully now that I&amp;rsquo;ve demystified some of X-Plane&amp;rsquo;s internal workings you&amp;rsquo;ll be inspired to create your own tools, maybe even design and build your own fly-by-wire plane, all in Perl.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

