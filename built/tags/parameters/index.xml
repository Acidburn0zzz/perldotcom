<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Parameters on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/parameters/</link>
    <description>Recent content in Parameters on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 16 Mar 2010 06:00:01 -0800</lastBuildDate>
    <atom:link href="/tags/parameters/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Idioms, or How to Write Perlish Perl</title>
      <link>http://localhost:1313/pub/2010/03/idioms-or-how-to-write-perlish-perl.html/</link>
      <pubDate>Tue, 16 Mar 2010 06:00:01 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2010/03/idioms-or-how-to-write-perlish-perl.html/</guid>
      <description>

&lt;p&gt;Any language—programming or natural—develops &lt;em&gt;idioms&lt;/em&gt;, or common patterns of expression. The earth revolves, but we speak of the sun rising or setting. We talk of clever hacks and nasty hacks and slinging code. We ping each other on IRC to discuss spaghetti code, and we factor and refactor away the artifacts of copy pasta.&lt;/p&gt;

&lt;p&gt;As you learn Perl 5 in more detail, you will begin to see and understand common idioms. They&amp;rsquo;re not quite language features—you don&amp;rsquo;t &lt;em&gt;have&lt;/em&gt; to use them—and they&amp;rsquo;re not quite large enough that you can encapsulate them away behind functions and methods. They&amp;rsquo;re something more than habits. They&amp;rsquo;re mannerisms. They&amp;rsquo;re our shared jargon of code. They&amp;rsquo;re ways of writing Perl with a Perlish accent.&lt;/p&gt;

&lt;h4 id=&#34;the-object-as-self&#34;&gt;&lt;strong&gt;The Object as &lt;code&gt;$self&lt;/code&gt;&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://learnperl.scratchcomputing.com/tutorials/objects/&#34;&gt;Perl 5&amp;rsquo;s object system&lt;/a&gt; treats the invocant of a method as a mundane parameter. The invocant of a class method (a string containing the name of the class) is that method&amp;rsquo;s first parameter. The invocant of an object or instance method, the object itself, is that method&amp;rsquo;s first parameter. You are free to use or ignore it as you see fit.&lt;/p&gt;

&lt;p&gt;Idiomatic Perl 5 uses &lt;code&gt;$class&lt;/code&gt; as the name of the class method and &lt;code&gt;$self&lt;/code&gt; for the name of the object invocant. This is a convention not enforced by the language itself, but it is a convention strong enough that useful extensions such as &lt;a href=&#34;https://metacpan.org/pod/MooseX::Method::Signatures&#34;&gt;MooseX::Method::Signatures&lt;/a&gt; assume you will use &lt;code&gt;$self&lt;/code&gt; as the name of the invocant by default.&lt;/p&gt;

&lt;p&gt;This is true even if you use &lt;a href=&#34;http://moose.perl.org/&#34;&gt;Moose&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;named-parameters&#34;&gt;&lt;strong&gt;Named Parameters&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;Without a module such as &lt;a href=&#34;https://metacpan.org/pod/signatures&#34;&gt;signatures&lt;/a&gt; or &lt;a href=&#34;https://metacpan.org/pod/MooseX::MultiMethods&#34;&gt;MooseX::Multimethods&lt;/a&gt;, Perl 5&amp;rsquo;s argument passing mechanism is simple: all arguments flatten into a single list accessible through &lt;code&gt;@_&lt;/code&gt; (function_parameters). While this simplicity is occasionally too simple—named parameters can be very useful at times—it does not preclude the use of idioms to provide named parameters.&lt;/p&gt;

&lt;p&gt;The list context evaluation and assignment of &lt;code&gt;@_&lt;/code&gt; allows you to unpack named parameters pairwise. Even though this function call is equivalent to passing a comma-separated or &lt;code&gt;qw//&lt;/code&gt;-created list, arranging the arguments as if they were true pairs of keys and values makes the caller-side look like the function supports named parameters:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    make_ice_cream_sundae(
        whipped_cream =&amp;gt; 1,
        sprinkles     =&amp;gt; 1,
        banana        =&amp;gt; 0,
        ice_cream     =&amp;gt; &#39;mint chocolate chip&#39;,
    );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The callee side can unpack these parameters into a hash and treate the hash as if it were a single argument:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub make_ice_cream_sundae
    {
        my %args = @_;

        my $ice_cream = get_ice_cream( $args{ice_cream}) );
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://books.google.com/books?id=yMMRnPQ7CSMC&#34;&gt;Perl Best Practices&lt;/a&gt; suggests passing a hash reference instead. This has one benefit of performing hash construction checking on the caller side, where it&amp;rsquo;s most likely you&amp;rsquo;ll make mistakes and another benefit of minimizing copying and memory use. The former benefit is compelling, if somewhat less common in practice.&lt;/p&gt;

&lt;p&gt;This technique works well with &lt;a href=&#34;https://perldoc.perl.org/functions/import.html&#34;&gt;import()&lt;/a&gt;; you can process as many parameters as you like before slurping the remainder into a hash:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub import
    {
        my ($class, %args)  = @_;
        my $calling_package = caller();

        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note how this idiom falls naturally out of list assignment; that makes this idiom Perlish.&lt;/p&gt;

&lt;h4 id=&#34;the-schwartzian-transform&#34;&gt;&lt;strong&gt;The Schwartzian Transform&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;People new to Perl sometimes overlook the importance of lists and list processing as a fundamental component of expression evaluation (footnote: People explaining its importance in this fashion do not help). Put more simply, the ability for Perl programmers to chain expressions which evaluate to variable-length lists gives them countless ways to manipulate data effectively.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;Schwartzian transform&lt;/em&gt; is an elegant demonstration of that principle as an idiom handily borrowed from the Lisp family of languages. (&lt;a href=&#34;http://groups.google.com/group/comp.unix.shell/browse_frm/thread/31da%0A970cebb30c6d?hl=en&amp;amp;pli=1&#34;&gt;Randal Schwartz&amp;rsquo;s initial posting of the Schwartzian transform&lt;/a&gt; mentions &amp;ldquo;Speak[ing] with a lisp in Perl.&amp;ldquo;)&lt;/p&gt;

&lt;p&gt;Suppose you have a Perl hash which associates the names of your co-workers with their phone extensions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use 5.010;

    my %extensions =
    (
        1004 =&amp;gt; &#39;Jerryd&#39;,
        1005 =&amp;gt; &#39;Rudy&#39;,
        1006 =&amp;gt; &#39;Juwan&#39;,
        1007 =&amp;gt; &#39;Brandon&#39;,
        1010 =&amp;gt; &#39;Joel&#39;,
        1012 =&amp;gt; &#39;LaMarcus&#39;,
        1021 =&amp;gt; &#39;Marcus&#39;,
        1024 =&amp;gt; &#39;Andre&#39;,
        1023 =&amp;gt; &#39;Martell&#39;,
        1052 =&amp;gt; &#39;Greg&#39;,
        1088 =&amp;gt; &#39;Nic&#39;,
    );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Suppose you want to print a list of extensions and co-workers sorted by their names, not their extensions. In other words, you need to sort a hash by its keys. Sorting the values of the hash in string order is easy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @sorted_names = sort values %extensions;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; but that loses the association of names with extensions. The beauty of the Schwartzian transform is that it solves this problem almost trivially. All you have to do is transform the data before and after sorting it to preserve the necessary information. This is most obvious when explained in multiple steps. First, convert the hash into a list of data structures which contain the vital information in sortable fashion. In this case, converting the hash pairs into two-element anonymous arrays will help:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @pairs = map { [ $_, $extensions{$_} ] } keys %extensions;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reversing the hash &lt;em&gt;in place&lt;/em&gt; would work if no one had the same name. In this case, that is no problem, but defensive coding anticipates data changes.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sort&lt;/code&gt; gets the list of anonymous arrays and can compare the second elements (the names) with a stringwise comparison:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @sorted_pairs = sort { $a-&amp;gt;[1] cmp $b-&amp;gt;[1] } @pairs;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Given &lt;code&gt;@sorted_pairs&lt;/code&gt;, a second &lt;code&gt;map&lt;/code&gt; operation can convert the data structure to a more usable form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @formatted_exts = map { &amp;quot;$_-&amp;gt;[1], ext. $_-&amp;gt;[0]&amp;quot; } @sorted_pairs;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; and now you can print the whole thing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    say for @formatted_exts;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, this uses several temporary variables (with admittedly bad names). It&amp;rsquo;s a worthwhile technique and good to understand, but the real magic is in the combination:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    say for
        map  { &amp;quot; $_-&amp;gt;[1], ext. $_-&amp;gt;[0]&amp;quot;          }
        sort {   $a-&amp;gt;[1] cmp   $b-&amp;gt;[1]           }
        map  { [ $_      =&amp;gt;    $extensions{$_} ] }
            keys %extensions;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Read the expression from right to left, in the order of evaluation. For each key in the extensions hash, make a two-item anonymous array containing the key and the value from the hash. Sort that list of anonymous arrays by their second elements, the values from the hash. Create a nicely formatted string of output from those sorted arrays.&lt;/p&gt;

&lt;p&gt;The Schwartzian transform is this pipeline of &lt;code&gt;map&lt;/code&gt;-&lt;code&gt;sort&lt;/code&gt;-&lt;code&gt;map&lt;/code&gt; where you transform a data structure into another form easier for sorting and then transform it back into your preferred form for modification.&lt;/p&gt;

&lt;p&gt;In this case the transformation is relatively simple. Consider the case where calculating the right value to sort is expensive in time or memory, such as calculating a cryptographic hash for a large file. In that case, the Schwartzian transform is also useful because you can perform those expensive operations once (in the rightmost &lt;code&gt;map&lt;/code&gt;), compare them repeatedly from a de-facto cache in the &lt;code&gt;sort&lt;/code&gt;, and then remove them in the leftmost &lt;code&gt;map&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The original example in the comp.lang.perl.misc shows an effective use of the transform, and a good programming technique in general. When the data you have isn&amp;rsquo;t in the optimal form for what you want to do with it, first transform it into that optimal form, then manipulate it.&lt;/p&gt;

&lt;p&gt;Phrased that way, the technique is so obvious as to seem trivial&amp;hellip; but what is an idiom but a brilliant idea made vulgar by its ubiquity?&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

