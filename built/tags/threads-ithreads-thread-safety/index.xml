<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Threads Ithreads Thread Safety on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/threads-ithreads-thread-safety/</link>
    <description>Recent content in Threads Ithreads Thread Safety on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 11 Jun 2002 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/threads-ithreads-thread-safety/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Where Wizards Fear To Tread</title>
      <link>http://localhost:1313/pub/2002/06/11/threads.html/</link>
      <pubDate>Tue, 11 Jun 2002 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2002/06/11/threads.html/</guid>
      <description>

&lt;p&gt;One of the big new features in perl 5.8 is that we now have real working threads available to us through the threads pragma.&lt;/p&gt;

&lt;p&gt;However, for us module authors who already have to support our modules on different versions of perl and different platforms, we now have to deal with another case: threads! This article will show you how threads relate to modules, how we can take old modules and make them thread-safe, and round off with a new module that alters perl&amp;rsquo;s behavior of the &amp;ldquo;current working directory&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;To run the examples I have shown here, you need perl 5.8 RC1 or later compiled with threads. On Unix, you can use &lt;code&gt;Configure -Duseithreads -Dusethreads&lt;/code&gt;; On Win32, the default build will always have threading enabled.&lt;/p&gt;

&lt;h3 id=&#34;span-id-how-do-threads-relate-to-modules-how-do-threads-relate-to-modules-span&#34;&gt;&lt;span id=&#34;how_do_threads_relate_to_modules&#34;&gt;How do threads relate to modules?&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Threading in Perl is based on the notion of explicit shared data. That is, only data that is explicitly requested to be shared will be shared between threads. This is controlled by the &lt;code&gt;threads::shared&lt;/code&gt; pragma and the &amp;ldquo;&lt;code&gt;: shared&lt;/code&gt;&amp;rdquo; attribute. Witness how it works:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     use threads;
     my $var = 1;
     threads-&amp;gt;create(sub { $var++ })-&amp;gt;join();
     print $var;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you are accustomed to threading in most other languages, (Java/C) you would expect $var to contain a 2 and the result of this script to be &amp;ldquo;2&amp;rdquo;. However since Perl does not share data between threads, $var is copied in the thread and only incremented in the thread. The original value in the main thread is not changed, so the output is &amp;ldquo;1&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;However if we add in &lt;code&gt;threads::shared&lt;/code&gt; and a &lt;code&gt;: shared&lt;/code&gt; attribute we get the desired result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     use threads;
     use threads::shared;
     my $var : shared = 1;
     threads-&amp;gt;create(sub { $var++ })-&amp;gt;join();
     print $var
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the result will be &amp;ldquo;2&amp;rdquo;, since we declared $var to be a shared variable. Perl will then act on the same variable and provide automatic locking to keep the variable out of trouble.&lt;/p&gt;

&lt;p&gt;This makes it quite a bit simpler for us module developers to make sure our modules are thread-safe. Essentially, all pure Perl modules are thread-safe because any global state data, which is usually what gives you thread-safety problems, is by default local to each thread.&lt;/p&gt;

&lt;h4 id=&#34;span-id-definition-of-threadsafe-levels-definition-of-thread-safe-levels-span&#34;&gt;&lt;span id=&#34;definition_of_threadsafe_levels&#34;&gt;Definition of thread-safe levels&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;To define what we mean by thread-safety, here are some terms adapted from the Solaris thread-safety levels.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_thread%2dsafe&#34;&gt;thread-safe&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This module can safely be used from multiple threads. The effect of calling into a safe module is that the results are valid even when called by multiple threads. However, thread-safe modules can still have global consequences; for example, sending or reading data from a socket affects all threads that are working with that socket. The application has the responsibility to act sane with regards to threads. If one thread creates a file with the name &lt;em&gt;file.tmp&lt;/em&gt; then another file which tries to create it will fail; this is not the fault of the module.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_thread%2dfriendly&#34;&gt;thread-friendly&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Thread-friendly modules are thread-safe modules that know about and provide special functions for working with threads or utilize threads by themselves. A typical example of this is the core &lt;code&gt;threads::queue&lt;/code&gt; module. One could also imagine a thread-friendly module with a cache to declare that cache to be shared between threads to make hits more likely and save memory.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_thread%2dunsafe&#34;&gt;thread-unsafe&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This module can not safely be used from different threads; it is up to the application to synchronize access to the library and make sure it works with it the way it is specified. Typical examples here are XS modules that utilize external unsafe libraries that might only allow one thread to execute them.&lt;/p&gt;

&lt;p&gt;Since Perl only shares when asked to, most pure Perl code probably falls into the thread-safe category, that doesn&amp;rsquo;t mean you should trust it until you have review the source code or they have been marked with thread-safe by the author. Typical problems include using alarm(), mucking around with signals, working with relative paths and depending on &lt;code&gt;%ENV&lt;/code&gt;. However remember that ALL XS modules that don&amp;rsquo;t state anything fall into the definitive thread-unsafe category.&lt;/p&gt;

&lt;h3 id=&#34;span-id-why-should-i-bother-making-my-module-threadsafe-or-threadfriendly-why-should-i-bother-making-my-module-thread-safe-or-thread-friendly-span&#34;&gt;&lt;span id=&#34;why_should_i_bother_making_my_module_threadsafe_or_threadfriendly&#34;&gt;Why should I bother making my module thread-safe or thread-friendly?&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Well, it usually isn&amp;rsquo;t much work and it will make the users of this modules that want to use it in a threaded environment very happy. What? Threaded Perl environments aren&amp;rsquo;t that common you say? Wait until Apache 2.0 and mod_perl 2.0 becomes available. One big change is that Apache 2.0 can run in threaded mode and then mod_perl will have to be run in threaded mode; this can be a huge performance gain on some operating systems. So if you want your modules to work with mod_perl 2.0, taking a look at thread-safety levels is a good thing to do.&lt;/p&gt;

&lt;h3 id=&#34;span-id-so-what-do-i-do-to-make-my-module-threadfriendly-so-what-do-i-do-to-make-my-module-thread-friendly-span&#34;&gt;&lt;span id=&#34;so_what_do_i_do_to_make_my_module_threadfriendly&#34;&gt;So what do I do to make my module thread-friendly?&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;A good example of a module that needed a little modification to work with threads is Michael Schwern&amp;rsquo;s most excellent &lt;code&gt;Test::Simple&lt;/code&gt; suite (&lt;code&gt;Test::Simple&lt;/code&gt;, &lt;code&gt;Test::More&lt;/code&gt; and &lt;code&gt;Test::Builder&lt;/code&gt;). Surprisingly, we had to change very little to fix it.&lt;/p&gt;

&lt;p&gt;The problem was simply that the test numbering was not shared between threads.&lt;/p&gt;

&lt;p&gt;For example&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     use threads;
     use Test::Simple tests =&amp;gt; 3;
     ok(1);
     threads-&amp;gt;create(sub { ok(1) })-&amp;gt;join();
     ok(1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that will return&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     1..3
     ok 1
     ok 2
     ok 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Does it look similar to the problem we had earlier? Indeed it does, seems like somewhere there is a variable that needs to shared.&lt;/p&gt;

&lt;p&gt;Now reading the documentation of &lt;code&gt;Test::Simple&lt;/code&gt; we find out that all magic is really done inside &lt;code&gt;Test::Builder&lt;/code&gt;, opening up &lt;em&gt;Builder.pm&lt;/em&gt; we quickly find the following lines of code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     my @Test_Results = ();
     my @Test_Details = ();
     my $Curr_Test = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we would be tempted to add &lt;code&gt;use threads::shared&lt;/code&gt; and &lt;code&gt;:shared&lt;/code&gt; attribute.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     use threads::shared;
     my @Test_Results : shared = ();
     my @Test_Details : shared = ();
     my $Curr_Test : shared = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However &lt;code&gt;Test::Builder&lt;/code&gt; needs to work back to Perl 5.4.4! Attributes were only added in 5.6.0 and the above code would be a syntax error in earlier Perls. And even if someone were using 5.6.0, &lt;code&gt;threads::shared&lt;/code&gt; would not be available for them.&lt;/p&gt;

&lt;p&gt;The solution is to use the runtime function &lt;code&gt;share()&lt;/code&gt; exported by &lt;code&gt;threads::shared&lt;/code&gt;, but we only want to do it for 5.8.0 and when threads have been enabled. So, let&amp;rsquo;s wrap it in a &lt;code&gt;BEGIN&lt;/code&gt; block and an &lt;code&gt;if&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     BEGIN{
         if($] &amp;gt;= 5.008 &amp;amp;&amp;amp; exists($INC{&#39;threads.pm&#39;})) {
             require threads::shared;
             import threads::shared qw(share);
             share($Curr_Test);
             share(@Test_Details)
             share(@Test_Results);
         }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, if 5.8.0 or higher and threads has been loaded, we do the runtime equivalent of &lt;code&gt;use threads::shared qw(share);&lt;/code&gt; and call &lt;code&gt;share()&lt;/code&gt; on the variables we want to be shared.&lt;/p&gt;

&lt;p&gt;Now lets find out some examples of where &lt;code&gt;$Curr_Test&lt;/code&gt; is used. We find &lt;code&gt;sub ok {}&lt;/code&gt; in &lt;code&gt;Test::Builder&lt;/code&gt;; I won&amp;rsquo;t include it here, but only a smaller version which contains:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     sub ok {
         my($self, $test, $name) = @_;
         $Curr_Test++;
         $Test_Results[$Curr_Test-1] = 1 unless($test);
     }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, this looks like it should work right? We have shared $Curr_Test and &lt;code&gt;@Test_Results&lt;/code&gt;. Of course, things aren&amp;rsquo;t that easy; they never are. Even if the variables are shared, two threads could enter &lt;code&gt;ok()&lt;/code&gt; at the same time. Remember that not even the statement &lt;code&gt;$CurrTest++&lt;/code&gt; is an atomic operation, it is just a shortcut for writing &lt;code&gt;$CurrTest = $CurrTest + 1&lt;/code&gt;. So let&amp;rsquo;s say two threads do that at the same time.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     Thread 1: add 1 + $Curr_Test
     Thread 2: add 1 + $Curr_Test
     Thread 2: Assign result to $Curr_Test
     Thread 1: Assign result to $Curr_Test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The effect would be that $Curr_Test would only be increased by one, not two! Remember that a switch between two threads could happen at &lt;strong&gt;ANY&lt;/strong&gt; time, and if you are on a multiple CPU machine they can run at exactly the same time! Never trust thread inertia.&lt;/p&gt;

&lt;p&gt;So how do we solve it? We use the &lt;code&gt;lock()&lt;/code&gt; keyword. &lt;code&gt;lock()&lt;/code&gt; takes a shared variable and locks it for the rest of the scope, but it is only an advisory lock so we need to find every place that $Curr_Test is used and modified and it is expected not to change. The &lt;code&gt;ok()&lt;/code&gt; becomes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     sub ok {
         my($self, $test, $name) = @_;
         lock($Curr_Test);
         $Curr_Test++;
         $Test_Results[$Curr_Test-1] = 1 unless($test);
     }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So are we ready? Well, &lt;code&gt;lock()&lt;/code&gt; was only added in Perl 5.5 so we need to add an else to the BEGIN clause to define a lock function if we aren&amp;rsquo;t running with threads. The end result would be.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     my @Test_Results = ();
     my @Test_Details = ();
     my $Curr_Test = 0;
     BEGIN{
         if($] &amp;gt;= 5.008 &amp;amp;&amp;amp; exists($INC{&#39;threads.pm&#39;})) {
             require threads::shared;
             import threads::shared qw(share);
             share($Curr_Test);
             share(@Test_Details)
             share(@Test_Results);
         } else {
             *lock = sub(*) {};
         }
     }
     sub ok {
         my($self, $test, $name) = @_;
         lock($Curr_Test);
         $Curr_Test++;
         $Test_Results[$Curr_Test-1] = 1 unless($test);
     }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, this is very like the code that has been added to &lt;code&gt;Test::Builder&lt;/code&gt; to make it work nice with threads. The only thing not correct is &lt;code&gt;ok()&lt;/code&gt; as I cut it down to what was relevant. There were roughly 5 places where &lt;code&gt;lock()&lt;/code&gt; had to be added. Now the test code would print&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     1..3
     ok 1
     ok 2
     ok 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which is exactly what the end user would expect. All in all this is a rather small change for this 1291 line module, we change roughly 15 lines in a non intrusive way, the documentation and testcase code makes up most of the patch. The full patch is at &lt;a href=&#34;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2002-06/msg00816.html&#34;&gt;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2002-06/msg00816.html&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-altering-perls-behavior-to-be-threadsafe-ex-threads-cwd-altering-perls-behavior-to-be-thread-safe-ex-threads-cwd-span&#34;&gt;&lt;span id=&#34;altering_perls_behavior_to_be_threadsafe,_ex::threads::cwd&#34;&gt;Altering Perls behavior to be thread-safe, ex::threads::cwd&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Somethings change when you use threads; some things that you or a module might do are not like what they used to be. Most of the changes will be due to the way your operating system treats processes that use threads. Each process has typically a set of attributes, which include the current working directory, the environment table, the signal subsystem and the pid. Since threads are multiple paths of execution inside a single process, the operating system treats it as a single process and you have a single set of these attributes.&lt;/p&gt;

&lt;p&gt;Yep. That&amp;rsquo;s right - if you change the current working directory in one thread, it will also change in all the other threads! Whoops, better start using absolute paths everywhere, and all the code that uses your module might use relative paths. Aaargh&amp;hellip;&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t worry, this is a solvable problem. In fact, it&amp;rsquo;s solvable by a module.&lt;/p&gt;

&lt;p&gt;Perl allows us to override functions using the &lt;code&gt;CORE::GLOBAL&lt;/code&gt; namespace. This will let us override the functions that deal with paths and set the &lt;code&gt;cwd&lt;/code&gt; correctly before issuing the command. So let&amp;rsquo;s start off&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     package ex::threads::safecwd;

     use 5.008;
     use strict;
     use warnings;
     use threads::shared;
     our $VERSION = &#39;0.01&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nothing weird here right? Now, when changing and dealing with the current working directory one often uses the &lt;code&gt;Cwd&lt;/code&gt; module, so let us make the cwd module safe first. How do we do that?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  1) use Cwd;
  2) our $cwd = cwd;  #our per thread cwd, init on startup from cwd
  3) our $cwd_mutex : shared; # the variable we use to sync
  4) our $Cwd_cwd = \&amp;amp;Cwd::cwd;
  5) *Cwd::cwd = *my_cwd;     
     sub my_cwd {
  6)     lock($cwd_mutex);
  7)     CORE::chdir($cwd);
  8)     $Cwd_cwd-&amp;gt;(@_);
     }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What&amp;rsquo;s going on here? Let&amp;rsquo;s analyze it line by line:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;We include &lt;code&gt;Cwd&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;We declare a variable and assign to it the cwd we start in. This variable will not be shared between threads and will contain the cwd of this thread.&lt;/li&gt;
&lt;li&gt;We declare a variable we will be using to lock for synchronizing work.&lt;/li&gt;
&lt;li&gt;Here we take a reference to the &lt;code&gt;&amp;amp;Cwd::cwd&lt;/code&gt; and store in &lt;code&gt;$Cwd_cwd&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Now we hijack &lt;code&gt;Cwd::cwd&lt;/code&gt; and assign to it our own &lt;code&gt;my_cwd&lt;/code&gt; so whenever someone calls &lt;code&gt;Cwd::cwd&lt;/code&gt;, it will call &lt;code&gt;my_cwd&lt;/code&gt; instead.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;my_cwd&lt;/code&gt; starts of by locking $cwd_mutex so no one else will muck. around with the cwd.&lt;/li&gt;
&lt;li&gt;After that we call &lt;code&gt;CORE::chdir()&lt;/code&gt; to actually set the cwd to what this thread is expecting it to be.&lt;/li&gt;
&lt;li&gt;And we round off by calling the original &lt;code&gt;Cwd::cwd&lt;/code&gt; that we stored in step 4 with any parameters that we were handed to us.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In effect we have hijacked &lt;code&gt;Cwd::cwd&lt;/code&gt; and wrapped it around with a lock and a &lt;code&gt;chdir&lt;/code&gt; so it will report the correct thing!&lt;/p&gt;

&lt;p&gt;Now that &lt;code&gt;cwd()&lt;/code&gt; is fixed, we need a way to actually change the directory. To do this, we install our own global &lt;code&gt;chdir&lt;/code&gt;, simply like this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     *CORE::GLOBAL::chdir = sub {
         lock($cwd_mutex);
         CORE::chdir($_[0]) || return undef;
         $cwd = $Cwd_cwd-&amp;gt;();
     };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, whenever someone calls &lt;code&gt;chdir()&lt;/code&gt; our &lt;code&gt;chdir&lt;/code&gt; will be called instead, and in it we start by locking the variable controlling access, then we try to chdir to the directory to see if it is possible, otherwise we do what the real chdir would do, return undef. If it succeeds, we assign the new value to our per thread &lt;code&gt;$cwd&lt;/code&gt; by calling the original &lt;code&gt;Cwd::cwd()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The above code is actually enough to allow the following to work:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     use threads
     use ex::threads::safecwd;
     use Cwd;
     chdir(&amp;quot;/tmp&amp;quot;);
     threads-&amp;gt;create(sub { chdir(&amp;quot;/usr&amp;quot;) } )-&amp;gt;join();
     print cwd() eq &#39;/tmp&#39; ? &amp;quot;ok&amp;quot; : &amp;quot;nok&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since the &lt;code&gt;chdir(&amp;quot;/usr&amp;quot;);&lt;/code&gt; inside the thread will not affect the other thread&amp;rsquo;s &lt;code&gt;$cwd&lt;/code&gt; variable, so when &lt;code&gt;cwd&lt;/code&gt; is called, we will lock down the thread, &lt;code&gt;chdir()&lt;/code&gt; to the location the thread &lt;code&gt;$cwd&lt;/code&gt; contains and perform a &lt;code&gt;cwd()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;While this is useful, we need to get along and provide some more functions to extend the functionality of this module.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     *CORE::GLOBAL::mkdir = sub {
         lock($cwd_mutex);
         CORE::chdir($cwd);
         if(@_ &amp;gt; 1) {
             CORE::mkdir($_[0], $_[1]);
         } else {
             CORE::mkdir($_[0]);
         }
     };

     *CORE::GLOBAL::rmdir = sub {
         lock($cwd_mutex);
         CORE::chdir($cwd);
         CORE::rmdir($_[0]);
     };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above snippet does essentially the same thing for both &lt;code&gt;mkdir&lt;/code&gt; and &lt;code&gt;rmdir&lt;/code&gt;. We lock the $cwd_mutex to synchronize access, then we &lt;code&gt;chdir&lt;/code&gt; to &lt;code&gt;$cwd&lt;/code&gt; and finally perform the action. Worth noticing here is the check we need to do for &lt;code&gt;mkdir&lt;/code&gt; to be sure the prototype behavior for it is correct.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s move on with &lt;code&gt;opendir&lt;/code&gt;, &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;readlink&lt;/code&gt;, &lt;code&gt;readpipe&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt;, &lt;code&gt;rmdir&lt;/code&gt;, &lt;code&gt;stat&lt;/code&gt;, &lt;code&gt;symlink&lt;/code&gt;, &lt;code&gt;system&lt;/code&gt; and &lt;code&gt;unlink&lt;/code&gt;. None of these are really any different from the above with the big exception of &lt;code&gt;open&lt;/code&gt;. &lt;code&gt;open&lt;/code&gt; has a weird bit of special case since it can take both a HANDLE and an empty scalar for autovification of an anonymous handle.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     *CORE::GLOBAL::open = sub (*;$@) {
         lock($cwd_mutex);
         CORE::chdir($cwd);
         if(defined($_[0])) {
             use Symbol qw();
             my $handle = Symbol::qualify($_[0],(caller)[0]);
             no strict &#39;refs&#39;;
             if(@_ == 1) {
                 return CORE::open($handle);
             } elsif(@_ == 2) {
               return CORE::open($handle, $_[1]);
             } else {
               return CORE::open($handle, $_[1], @_[2..$#_]);
             }
         }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Starting off with the usual lock and &lt;code&gt;chdir()&lt;/code&gt; we then need to check if the first value is defined. If it is, we have to qualify it to the callers namespace. This is what would happen if a user does &lt;code&gt;open FOO, &amp;quot;+&amp;gt;foo.txt&amp;quot;&lt;/code&gt;. If the user instead does &lt;code&gt;open main::FOO, &amp;quot;+&amp;gt;foo.txt&amp;quot;&lt;/code&gt;, then Symbol::qualify notices that the handle is already qualified and returns it unmodified. Now since &lt;code&gt;$_[0]&lt;/code&gt; is a readonly alias we cannot assign it over so we need to create a temporary variable and then proceed as usual.&lt;/p&gt;

&lt;p&gt;Now if the user used the new style &lt;code&gt;open my $foo, &amp;quot;+&amp;gt;foo.txt&amp;quot;&lt;/code&gt;, we need to treat it differently. The following code will do the trick and complete the function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     else {
             if(@_ == 1) {
                 return CORE::open($_[0]);
             } elsif(@_ == 2) {
                 return CORE::open($_[0], $_[1]);
             } else {
                 return CORE::open($_[0], $_[1], @_[2..$#_]);
             }
         }
     };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wonder why we couldn&amp;rsquo;t just assign &lt;code&gt;$_[0]&lt;/code&gt; to &lt;code&gt;$handle&lt;/code&gt; and unify the code path? You see, &lt;code&gt;$_[0]&lt;/code&gt; is an alias to the &lt;code&gt;$foo&lt;/code&gt; in &lt;code&gt;open my $foo, &amp;quot;+&amp;gt;foo.txt&amp;quot;&lt;/code&gt; so &lt;code&gt;CORE::open&lt;/code&gt; will correctly work.&lt;/p&gt;

&lt;p&gt;However, if we do &lt;code&gt;$handle = $_[0]&lt;/code&gt; we take a copy of the undefined variable and &lt;code&gt;CORE::open&lt;/code&gt; won&amp;rsquo;t do what I mean.&lt;/p&gt;

&lt;p&gt;So now we have a module that allows the you to safely use relative paths in most of the cases and vastly improves your ability to port code to a threaded environment. The price we pay for this is speed, since every time you do an operation involving a directory you are serializing your program. Typically, you never do those kinds of operations in a hot path anyway. You might do work on your file in a hot path, but as soon as we have gotten the filehandle no more locking is done.&lt;/p&gt;

&lt;p&gt;A couple of problems remain. Performance-wise, there is one big problem with &lt;code&gt;system()&lt;/code&gt;, since we don&amp;rsquo;t get control back until the &lt;code&gt;CORE::system()&lt;/code&gt; returns, so all path operations will hang waiting for that. To solve that we would need to revert to XS and do some magic with regard to the system call. We also haven&amp;rsquo;t been able to override the file test operators (&lt;code&gt;-x&lt;/code&gt; and friends), nor can we do anything about &lt;code&gt;qx {}&lt;/code&gt;. Solving that problem requires working up and down the optree using &lt;code&gt;B::Generate&lt;/code&gt; and &lt;code&gt;B::Utils&lt;/code&gt;. Perhaps a future version of the module will attempt that together with a custom op to do the locking.&lt;/p&gt;

&lt;h3 id=&#34;span-id-conclusion-conclusion-span&#34;&gt;&lt;span id=&#34;conclusion&#34;&gt;Conclusion&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Threads in Perl are simple and straight forward, as long as we stay in pure Perl land everything behaves just about how we would expect it to. Converting your modules should be a simple matter of programming without any big wizardly things to be done. The important thing to remember is to think about how your module could possibly take advantage of threads to make it easier to use for the programmer.&lt;/p&gt;

&lt;p&gt;Moving over to XS land is altogether different; stay put for the next article that will take us through the pitfalls of converting various kinds of XS modules to thread-safe and thread-friendly levels.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

