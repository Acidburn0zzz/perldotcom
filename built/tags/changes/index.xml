<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Changes on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/changes/</link>
    <description>Recent content in Changes on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 27 Mar 2017 08:47:28 +0000</lastBuildDate>
    <atom:link href="/tags/changes/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Track Module Changes While You Sleep</title>
      <link>http://localhost:1313/article/let-perlmodules-net-do-the-work/</link>
      <pubDate>Mon, 27 Mar 2017 08:47:28 +0000</pubDate>
      
      <guid>http://localhost:1313/article/let-perlmodules-net-do-the-work/</guid>
      <description>&lt;p&gt;I created &lt;a href=&#34;https://metacpan.org/pod/Module::Extract::Use&#34;&gt;Module::Extract::Use&lt;/a&gt; as a simple tool to list the modules a program uses, and I recently added some features to make it easier to create some input I could give to &lt;a href=&#34;https://www.perlmodules.net&#34;&gt;Perlmodules.net&lt;/a&gt; to create a feed of changes for those modules.&lt;/p&gt;

&lt;p&gt;Much of my day-to-day work involves helping people turn legacy stuff into something testable, distributable, and installable (I find that special sort of drudgery quite interesting because every mess is different).  Jonathan Yu worked with my &lt;a href=&#34;https://metacpan.org/pod/Module::Extract::Use&#34;&gt;Module::Extract::Use&lt;/a&gt; to create the example program &lt;i&gt;examples/extract_modules&lt;/i&gt; which I extended a bit. Here are some examples using the script on itself. The first example is for human inspection:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# print a verbose text listing
$ extract_modules extract_modules
Modules required by examples/extract_modules:
 - Getopt::Std (first released with Perl 5)
 - Module::CoreList (first released with Perl 5.008009)
 - Pod::Usage (first released with Perl 5.006)
 - strict (first released with Perl 5)
 - warnings (first released with Perl 5.006)
5 module(s) in core, 0 external module(s)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I added some options to create an undecorated list of one module per line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# print a succint list, one module per line
$ extract_modules -l extract_modules
Getopt::Std
Module::CoreList
Pod::Usage
open
strict
warnings
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And since I like that &lt;code&gt;xargs -0&lt;/code&gt; allows me to represent several lines as a single string with null octets as separators, I added a switch for that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# print a succinct list, modules separated by null bytes
# you might like this with xargs -0
$ extract_modules -l -0 extract_modules
Getopt::StdModule::CoreListPod::Usageopenstrictwarnings
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While I&amp;rsquo;m in there, I might as well add JSON output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# print the modules list as JSON
$ extract_modules -j extract_modules
[
  &amp;quot;Getopt::Std&amp;quot;,
  &amp;quot;Module::CoreList&amp;quot;,
  &amp;quot;Pod::Usage&amp;quot;,
  &amp;quot;open&amp;quot;,
  &amp;quot;strict&amp;quot;,
  &amp;quot;warnings&amp;quot;
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want XML, tough. Well, I&amp;rsquo;ll accept patches, actually, but maybe you could write a JSON-to-XML converter and chain some programs. Remember that Perl is a glue language!&lt;/p&gt;

&lt;p&gt;Note that this program can only detect explicitly declared namespaces in static &lt;code&gt;use&lt;/code&gt; and &lt;code&gt;require&lt;/code&gt; statements. You don&amp;rsquo;t see the &lt;a href=&#34;https://metacpan.org/pod/Module::Extract::Use&#34;&gt;Module::Extract::Use&lt;/a&gt; in the output because this program uses it implicitly. That&amp;rsquo;s a rare situation that doesn&amp;rsquo;t bother me that much, and it&amp;rsquo;s something that I try to refactor out of code when I can.&lt;/p&gt;

&lt;p&gt;One of my immediate uses is to install all of the dependencies from a standalone program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ extract_modules -l -0 some_program | xargs -0 cpan
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is much better than what I use to do: keep trying to run the program until it doesn&amp;rsquo;t complain about missing dependencies. Sometimes that will still happen will implicit dependencies, but as I said, it&amp;rsquo;s rare. From there, I can also use this list to construct the text I need to put into a &lt;em&gt;Makefile.PL&lt;/em&gt;. I&amp;rsquo;ve considered writing a program for that, but I don&amp;rsquo;t think it would save me that much time. I usually want to look at the list, so the no-look automation isn&amp;rsquo;t as compelling.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s another thing I like to do with these module lists. Alexander Karelas created the website &lt;a href=&#34;https://www.perlmodules.net&#34;&gt;PerlModules.net&lt;/a&gt; to create feeds of changes to sets of modules. He was kind enough to support my &lt;em&gt;Learning Perl 6&lt;/em&gt; Kickstarter campaign by sponsoring this article on PerlTricks.&lt;/p&gt;

&lt;p&gt;From a list of modules, he figures out which distribution they are in and diff all of those &lt;em&gt;Changes&lt;/em&gt; files so he can present all of those diffs to you. You (and most people) probably don&amp;rsquo;t pay attention to all the changes. Perhaps you look at the &lt;em&gt;Changes&lt;/em&gt; for one of the main modules. You might ignore those other changes because it&amp;rsquo;s a bunch of work to go through all the distributions.&lt;/p&gt;

&lt;p&gt;You create a feed that specifies the modules that you want to track. For each new release, he diffs the Changes file and adds that diff to your feed. If you like, you could have one feed per application. When the module changes, you&amp;rsquo;ll see an entry in your feed and can read the diff without tracking down the module.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/perlmodules-net/personal-feeds.png&#34; alt=&#34;Personal Feeds&#34; /&gt;&lt;/p&gt;

&lt;p&gt;To get the list of modules I want to track, I can use &lt;code&gt;extract_modules&lt;/code&gt; with its &lt;code&gt;-l&lt;/code&gt; switch to make a one-namespace-per-line list of the dependencies. Here I use &lt;code&gt;extract_modules&lt;/code&gt; on all of the modules in a project:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find lib -name &amp;quot;*.pm&amp;quot; -print0 | xargs -0 extract_modules -l
Archive::Extract
Archive::Tar
Archive::Zip
... # long list elided
YAML::XS
base
parent
strict
subs
vars
warnings
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I can paste this list directly into the &lt;a href=&#34;https://www.perlmodules.net&#34;&gt;PerlModules.net&lt;/a&gt; feed creator (or the motivated can automate this if they want to create many, many feeds).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/perlmodules-net/upload-list.png&#34; alt=&#34;Upload List&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Once I&amp;rsquo;ve created the feed, I can view it in a variety of ways. Although I could visit the website to see what&amp;rsquo;s changed or get email when there&amp;rsquo;s a change. I prefer the RSS feed though. With that feed, a motivated Perler effectively has a way to programmatically get a list of the changes by fetching and parsing that feed.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/perlmodules-net/changes-list.png&#34; alt=&#34;Changes List&#34; /&gt;&lt;/p&gt;

&lt;p&gt;But, now comes the hard part: Making good &lt;em&gt;Changes&lt;/em&gt; files in our distributions. That&amp;rsquo;s something I&amp;rsquo;ll save for a different PerlTricks article.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

