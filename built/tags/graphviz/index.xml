<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Graphviz on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/graphviz/</link>
    <description>Recent content in Graphviz on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 15 Dec 2005 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/graphviz/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Logic Programming with Perl and Prolog</title>
      <link>http://localhost:1313/pub/2005/12/15/perl_prolog.html/</link>
      <pubDate>Thu, 15 Dec 2005 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2005/12/15/perl_prolog.html/</guid>
      <description>

&lt;p&gt;Computing languages can be addictive; developers sometimes blame themselves for perceived inadequacies, making apologies for them. That is the case, at least, when one defends his or her language of choice against the criticism of another language&amp;rsquo;s devotee. Regardless, many programmers prefer one language, and typically ground that preference in a respect for that language&amp;rsquo;s strengths.&lt;/p&gt;

&lt;p&gt;Perl has many strengths, but two most often cited are its adaptability and propensity to work as a &amp;ldquo;glue&amp;rdquo; between applications and/or data. However, Perl isn&amp;rsquo;t the only advantageous language: programmers have used C or even assembly to gain speed for years, and intelligent use of SQL allows the keen coder to offload difficult data manipulations onto a database, for example. Prolog is an often overlooked gem that, when combined with the flexibility of Perl, affords the coder powerful ways to address logical relationships and rules. In this article, I hope to provide a glimpse of the benefits that embedded Prolog offers to Perl programmers. Moreover, I hope that my example implementation demonstrates the ease with which one can address complex logical relationships.&lt;/p&gt;

&lt;h4 id=&#34;a-bit-about-prolog&#34;&gt;A Bit About Prolog&lt;/h4&gt;

&lt;p&gt;For the sake of demonstration, I would like to frame a simple problem and solution that illustrate the individual strengths of Perl and Prolog, respectively. However, while I anticipate that the average reader will be familiar with the former, he or she may not be as familiar with the latter. &lt;a href=&#34;http://en.wikipedia.org/wiki/Prolog&#34;&gt;Prolog&lt;/a&gt; is a logic programming language often used in AI work, based upon predicate calculus and first developed in 1972. There are several excellent, free versions of Prolog available today, including &lt;a href=&#34;http://gnu-prolog.inria.fr&#34;&gt;GNU Prolog&lt;/a&gt; and the popular &lt;a href=&#34;http://www.swi-prolog.org&#34;&gt;SWI Prolog&lt;/a&gt;. For the Prolog initiate, I recommend checking out some of the free Prolog tutorials, either those linked from Wikipedia or from &lt;a href=&#34;http://oopweb.com/Prolog/Files/Prolog.html&#34;&gt;OOPWeb&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Prolog and Perl aren&amp;rsquo;t exactly strangers, however. There are several excellent Perl modules available to allow the coder to access the power of Prolog quite easily, including the &lt;a href=&#34;https://metacpan.org/pod/Language::Prolog::SWI&#34;&gt;SWI&lt;/a&gt; module developed by Robert Barta, the &lt;a href=&#34;https://metacpan.org/pod/Language::Prolog::Interpreter&#34;&gt;Interpreter&lt;/a&gt; module by Lee Goddard, the &lt;a href=&#34;https://metacpan.org/pod/Language::Prolog::Yaswi&#34;&gt;Yaswi&lt;/a&gt; modules developed by Salvador Fandino Garcia, and the &lt;a href=&#34;https://metacpan.org/pod/AI::Prolog&#34;&gt;AI::Prolog&lt;/a&gt; module written by Curtis &amp;ldquo;Ovid&amp;rdquo; Poe. Poe has also recently provided a rather nice &lt;a href=&#34;http://users.easystreet.com/ovid/presentations/logic&#34;&gt;introduction to Prolog-in-Perl&lt;/a&gt; in an online-accessible format.&lt;/p&gt;

&lt;h4 id=&#34;the-problem&#34;&gt;The Problem&lt;/h4&gt;

&lt;p&gt;There are many advantages to using Prolog within Perl. In the general sense, each language has its own advantages, and can thus complement the other. Suppose that I am building a testing harness or a logic-based query engine for a web application, where neither language easily provides all of the features I need. In cases such as these, I could use Prolog to provide the logic &amp;ldquo;muscle,&amp;rdquo; and Perl to &amp;ldquo;glue&amp;rdquo; things together with its flexibility and varied, readily available modules on CPAN.&lt;/p&gt;

&lt;p&gt;In my simple demonstration, I am going to posit the requirement that I take genealogical information built by another application and test relationships based upon a set of rules. In this case, the rules are defined in a Prolog file (an interesting intersection here is that both Perl and Prolog typically use the suffix &lt;em&gt;.pl&lt;/em&gt;), while the genealogical information is contained in a &lt;a href=&#34;http://www.graphviz.org/Documentation.php&#34;&gt;Dot&lt;/a&gt; file readable by Graphviz. As such, I am going to make certain assumptions about the format of the data. Next, I am going to assume that I will have a query (web-based, or from yet another application) that will allow users to identify relationships (such as brothers, cousins, etc.).&lt;/p&gt;

&lt;p&gt;Here are my Prolog rules:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;is_father(Person)        :- is_parent(Person, _),
                            is_male(Person).
is_father(Person, Child) :- is_parent(Person, Child),
                            is_male(Person).

is_mother(Person)        :- is_parent(Person, _),
                            is_female(Person).
is_mother(Person, Child) :- is_parent(Person, Child),
                            is_female(Person).

ancestor(Ancestor, Person) :- is_parent(Ancestor, Person).
ancestor(Ancestor, Person) :- is_parent(Ancestor, Child),
                              ancestor(Child, Person).

is_sibling(Person, Sibling) :- is_parent(X, Person),
                               is_parent(X, Sibling).

is_cousin(Person, Cousin) :- is_parent(X, Person),
                             is_parent(Y, Cousin),
                             is_sibling(X, Y).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One advantage to separating my logic is that I can troubleshoot it before I even write the Perl code, loading the rules into a Prolog interpreter or IDE such as &lt;a href=&#34;http://xgp.sourceforge.net&#34;&gt;XGP&lt;/a&gt; (for Macintosh users) and testing them. However, AI::Prolog conveniently provides its own solution: by typing &lt;code&gt;aiprolog&lt;/code&gt; at the command line, I can access a Prolog shell, load in my file, and run some tests.&lt;/p&gt;

&lt;p&gt;At this point, however, I am mostly interested in accessing these rules from Perl. While there are several options for accessing Prolog from within Perl, the &lt;code&gt;AI::Prolog&lt;/code&gt; module is perhaps the easiest with which to start. Moreover, it is quite simple to use, the rules used to build the Prolog database being fed in when creating the &lt;code&gt;AI::Prolog&lt;/code&gt; object. The ability to hand the object constructor a filehandle is not currently supported, but would indeed be a nice improvement. While there are other ways to accomplish the task of reading in the data, such as calling the Prolog command &lt;code&gt;consult&lt;/code&gt;, I will read in the Prolog file (&lt;a href=&#34;http://localhost:1313/media/_pub_2005_12_15_perl_prolog/ancestry.pl&#34;&gt;&lt;em&gt;ancestry.pl&lt;/em&gt;&lt;/a&gt;) and provide a string representation of the contents.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open( PROLOGFILE, &#39;ancestry.pl&#39; ) or die &amp;quot;$! \n&amp;quot;;
local $/;
my $prologRules = &amp;lt;PROLOGFILE&amp;gt;;
close( PROLOGFILE );

my $prologDB = AI::Prolog-&amp;gt;new( $prologRules );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that I have loaded my Prolog database, I need to feed it some more information. I need to take my data, in Dot format, and translate it into something that my Prolog interpreter will understand. There are some modules out there that may be helpful, such as &lt;a href=&#34;http://localhost:1313/pub/2004/09/23/fsms.html&#34;&gt;DFA::Simple&lt;/a&gt;, but since I can assume that my data will look a certain way&amp;ndash;having written it from my other application&amp;ndash;I will build my own simple parser. First, I am going to take a look at the data.&lt;/p&gt;

&lt;p&gt;The visualization program created the diagram in Figure 1 from the code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;digraph family_tree {
   { jill [ color = pink ]
     rob  [ color = blue ] } -&amp;gt; { ann [ color = pink ]
                                  joe [ color = blue ] } ;

   { sue [ color = pink ] 
     dan [ color = blue ] } -&amp;gt; { sara [ color = pink ]
                                 mike [ color = blue ] } ;

   { nan [ color = pink ]
     tom [ color = blue ] } -&amp;gt; sue ;

   { nan
     jim [ color = blue ] } -&amp;gt; rob ;

   { kate  [ color = pink ]
     steve [ color = blue ] } -&amp;gt; dan ;

   { lucy  [ color = pink ]
     chris [ color = blue ] } -&amp;gt; jill ;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_12_15_perl_prolog/family_tree.gif&#34; alt=&#34;a family tree&#34; width=&#34;500&#34; height=&#34;192&#34; /&gt;
&lt;em&gt;Figure 1. A family tree from the sample data&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;There are a few peculiarities worth mentioning here. First, it may seem that the all-lower-case names are a bit strange, but I am already preparing for the convention that data in Prolog is typically lower-case. Also, I inserted an extra space before the semicolons in an effort to make matching them easier. While both of these conventions are easy to code around, they seems to create extra questions when illustrating a point. Therefore, assume that the above Dot snippet illustrates the range of possible formats in the example. While the &amp;ldquo;real-world examples&amp;rdquo; may provide a richer set of possibilities, the fact that applications with defined behavior generated this data will limit the edge cases.&lt;/p&gt;

&lt;p&gt;Returning to the data, it will be easiest to parse the Dot data using a simple state machine. Previously, I had defined some constants to represent states:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use constant { modInit   =&amp;gt; 0,
               modTag    =&amp;gt; 1,
               modValue  =&amp;gt; 2 };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basically, I assume that anything on the left-hand side of the &lt;code&gt;=&lt;/code&gt; is a parent and anything on the right is a child. Additionally, modifiers (in this case only color) begin with a left square-bracket and males have the &lt;code&gt;blue&lt;/code&gt; modifier, whereas females are &lt;code&gt;pink&lt;/code&gt;. I know that I have completed a parent-child relationship &amp;ldquo;block&amp;rdquo; when I hit the semicolon. Past these stipulations, if it isn&amp;rsquo;t a character I know that I can safely ignore, then it must be a noun.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub parse_dotFile {
   ##----------------------------------------
   ##  Examine data a word at a time
   ##----------------------------------------
   my @dotData = split( /\s+/, shift() );

   my ( $familyBlock, $personName, @prologQry ) = ();
   my $personModPosition                        = modInit;
   my $relationship                             = &#39;parent&#39;;

   for ( my $idx = 3; $idx &amp;lt; @dotData; $idx++ ) {
      chomp( $dotData[$idx] );

      SWITCH: {

         ## ignore
         if ( $dotData[ $idx ] =~ /[{}=\]]/ ) {
            last SWITCH; }

         ## begin adding attributes
         if ( $dotData[ $idx ] eq &#39;[&#39; ) {
            $personModPosition = modTag;
            last SWITCH; }

         ## switch from parents to children
         if ( $dotData[ $idx ] eq &#39;-&amp;gt;&#39; ) {
            $relationship = &#39;child&#39;;
            last SWITCH; }

         ## end of this block
         if ( $dotData[ $idx ] =~ /\;/ ) {
           ##-----------------------------------------
           ##  Generate is_parent rules for Prolog
           ##-----------------------------------------
            foreach my $parentInBlock ( @{ $familyBlock-&amp;gt;{ parent } } ) {
               foreach my $childInBlock ( @{ $familyBlock-&amp;gt;{ child } } ) {
                  push( @prologQry,
                      &amp;quot;is_parent(${parentInBlock}, ${childInBlock})&amp;quot; );
               }
            }
            $familyBlock = ();
            $relationship = &#39;parent&#39;;
            last SWITCH; }

         ## I have a noun, need to set something
         else {

            ## I have a modifier tag, next is the value
            if ( $personModPosition == modTag ) {
               $personModPosition = modValue;
               last SWITCH;

            } elsif ( $personModPosition == modValue ) {
                 ##--------------------------------------
                 ##  Set modifier value and reset
                 ##  We currently assume it is color
                 ##--------------------------------------
               if ( $dotData[ $idx ] eq &#39;blue&#39; ) {

                  push( @prologQry, &amp;quot;is_male(${personName})&amp;quot; );
               } else {
                  push( @prologQry, &amp;quot;is_female(${personName})&amp;quot; );
               }
               $personModPosition = modInit;
               $personName        = ();
               last SWITCH;
            } else {
                 ##--------------------------------------
                 ##  Grab the name and id as parent or child
                 ##--------------------------------------
               $personName = $dotData[ $idx ];
               push( @{ $familyBlock-&amp;gt;{ $relationship } }, $personName );
            }
         }
      }
   }

   return( \@prologQry );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rather than simply pushing my new rules into the Prolog interpreter directly, I return an array that contains the full ruleset. I am doing this so that I can easily dump it to a file for troubleshooting purposes. I can simply write the rules to a file, and consult this file in a Prolog shell.&lt;/p&gt;

&lt;p&gt;With a subroutine to parse my Dot file into Prolog rules, I can now push those rules into the interpreter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   ##-------------------------------------------
   ##  Read in Dot file containing relations
   ##  and feed it into the Prolog instance
   ##-------------------------------------------
   open( DOTFILE, &#39;family_tree.dot&#39; ) or die &amp;quot;$! \n&amp;quot;;
   my $parsedDigraph = parse_dotFile( &amp;lt;DOTFILE&amp;gt; );
   close( DOTFILE );

   foreach ( @$parsedDigraph ) {
      $prologDB-&amp;gt;do(&amp;quot;assert($_).&amp;quot;);
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I can easily query my Prolog database using the query method in &lt;code&gt;AI::Prolog&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   ##-------------------------------------------
   ##  Run the query
   ##-------------------------------------------
   $prologDB-&amp;gt;query( &amp;quot;is_cousin(joe, sara).&amp;quot; );
   while (my $results = $prologDB-&amp;gt;results) { print &amp;quot;@$results\n&amp;quot;; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;what-next&#34;&gt;What Next?&lt;/h3&gt;

&lt;p&gt;Even though this is a trivial example, I think that it provides an idea of the powerful ways in which Perl can be supplemented with Prolog. Just within the context of evaluating genealogical data (a mainstay of Prolog tutorials and examples), it seems that a Perl/Prolog application that uses genealogical data from open source genealogical software or websites would be a killer application. The possibilities seem endless: rules based upon Google maps, mining information from online auctions or news services, or even harvesting information for that new test harness are all tremendous opportunities for the marriage of Perl and Prolog.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Parsing iCal Data</title>
      <link>http://localhost:1313/pub/2005/08/18/ical_dot.html/</link>
      <pubDate>Thu, 18 Aug 2005 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2005/08/18/ical_dot.html/</guid>
      <description>

&lt;p&gt;One of the attributes of a killer application is that it does something cool: it allows you to view or organize information in new and interesting ways, saves you time, or helps you win that auction bid. Yet one of the fundamental aggravations of applications in general is that they don&amp;rsquo;t always work well together; typically, you cannot send your data to mixed-and-matched applications unless they were explicitly designed to allow this. One of the great strengths of a language such as Perl is its ability to overcome these differences and act as &amp;ldquo;glue.&amp;rdquo; As long as you can figure out what the incoming data looks like, and how the outgoing data should look, it is very simple to share data between previously incompatible applications. By simply building a parser between the applications and creating input files for the target application from the former&amp;rsquo;s data, you extend the usefulness of your tools. In a sense, you can create killer applications out of various mundane tools on your system.&lt;/p&gt;

&lt;p&gt;A somewhat trivial example of this sort of creation is an application that converts iCalendar data into a directed graph, readable by an application such as GraphViz. This example seems so trivial that you might ask yourself why you would wish to do such a thing. The answer is perhaps equally trivial: aside from the challenge factor, the ability to convert data could provide an alternative (or complement) to Gantt charts in project documentation, map relationships between events, etc. Moreover, by providing a simple way to allow disparate applications to interoperate, you can cumulatively build suites of applications, hopefully allowing for unforeseen advantages in the future.&lt;/p&gt;

&lt;p&gt;Returning to the example, say you would like to take an iCal calendar (Figure 1) and turn it into an interesting visualization (Figure 2). How would you do this? Such an ability to convert formats is one step in constructing that killer application.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_08_18_ical_dot/ical_screen.gif&#34; alt=&#34;an iCal calendar&#34; width=&#34;500&#34; height=&#34;366&#34; /&gt;
&lt;em&gt;Figure 1. An iCal calendar&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_08_18_ical_dot/ical_dot.gif&#34; alt=&#34;an alternate visualization&#34; width=&#34;500&#34; height=&#34;254&#34; /&gt;
&lt;em&gt;Figure 2. An alternate visualization of the calendar data&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;reading-the-icalendar-format&#34;&gt;Reading the iCalendar Format&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://www.ietf.org/rfc/rfc2446.txt&#34;&gt;RFC 2446&lt;/a&gt; defines the iCalendar format, which Apple&amp;rsquo;s iCal application uses. Each iCalendar file represents an individual calendar and contains at least one block of event data in key:value tuples, starting with a &lt;code&gt;BEGIN:VEVENT&lt;/code&gt; tuple and ending with &lt;code&gt;END:VEVENT&lt;/code&gt;. Here is an example (with indentation added for readability) of a small iCalendar file containing two events:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BEGIN:VCALENDAR
        CALSCALE:GREGORIAN
        PRODID:-//Apple Computer\, Inc//iCal 2.0//EN
        VERSION:2.0
        BEGIN:VEVENT
                LOCATION:San Francisco
                DTSTAMP:20050618T151130Z
                UID:BDF17182-CA21-4752-8D4F-40A4FE47C90D
                SEQUENCE:8
                URL;VALUE=URI:http://developer.apple.com/wwdc/
                DTSTART;VALUE=DATE:20050606
                SUMMARY:Apple WWDC
                DTEND;VALUE=DATE:20050612
                DESCRIPTION:Lots of sessions.
        END:VEVENT
        BEGIN:VEVENT
                DURATION:PT1H
                LOCATION:Home
                DTSTAMP:20050618T151543Z
                UID:5F88A0EC-AD21-428E-AAAD-005F1B1AB72E
                SEQUENCE:6
                DTSTART;TZID=America/Chicago:20050615T180000
                SUMMARY:Set up File Server
                DESCRIPTION:Music server for the kids.
        END:VEVENT
END:VCALENDAR
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are several possible approaches to parsing the above data in Perl, but perhaps the easiest one is to create a hash of events, modeled after the iCalendar structure. With this approach, a single calendar becomes a hash of hashes with a key:value pair for each event, where the key is the event ID and the value is a hash containing the event data. While it would be just as easy to &lt;em&gt;store&lt;/em&gt; the data as an array of hashes, the ability to pull an event by its ID allows greater flexibility and power to &lt;em&gt;manipulate&lt;/em&gt; the data. The data for a single event might look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Calendar-&amp;gt;EventUID = { &#39;UID&#39;         =&amp;gt; EventUID,
                       &#39;LOCATION&#39;    =&amp;gt; EventLocation,
                       &#39;START&#39;       =&amp;gt; EventStart,
                       &#39;END&#39;         =&amp;gt; EventEnd,
                       &#39;DURATION&#39;    =&amp;gt; EventDuration,
                       &#39;DTSTAMP&#39;     =&amp;gt; EventDatestamp,
                       &#39;SEQUENCE&#39;    =&amp;gt; EventSequence,
                       &#39;SUMMARY&#39;     =&amp;gt; EventSummary,
                       &#39;DESCRIPTION&#39; =&amp;gt; EventDescription,
                       &#39;URL&#39;         =&amp;gt; EventURL };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that these keys represent only a subset of all possibilities as defined in RFC 2246. Each event may not contain all of the above keys. For example, the first event in my example does not contain &lt;code&gt;DURATION&lt;/code&gt;. Further, certain keys (such as &lt;code&gt;SEQUENCE&lt;/code&gt;) may be irrelevant for your purposes.&lt;/p&gt;

&lt;p&gt;With the data structure designed, what&amp;rsquo;s the right way to convert iCalendar data into such a structure? Realizing the mantra of Perl, that there is more than one way to do things, perhaps the easiest approach is to match key names, starting a new event block when the parser sees &lt;code&gt;BEGIN:VEVENT&lt;/code&gt; and ending it when &lt;code&gt;END:VEVENT&lt;/code&gt; appears. Given the large number of possible keys, it may be easiest to use switch-like behavior. Here is an example of how to do this, splitting a key:value on the colon character (as the semicolon precedes any modifiers to the data):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SWITCH: {
        if ( $_ =~ /BEGIN:VEVENT/ ) {
                ##-----------------------------------------
                ## We have a new event, so start fresh.
                ##-----------------------------------------
                $eventHash = {};
                last SWITCH; }


        if ( $_ =~ /END:VEVENT/ ) {
                ##-----------------------------------------
                ## We hit the event end, so store it.
                ##-----------------------------------------
                $calHash-&amp;gt;{$eventHash-&amp;gt;{&#39;UID&#39;}} = 
                {
                     &#39;UID&#39;         =&amp;gt; $eventHash-&amp;gt;{&#39;UID&#39;},
                     &#39;LOCATION&#39;    =&amp;gt; $eventHash-&amp;gt;{&#39;LOCATION&#39;},
                      #...The rest of our keys...
                     &#39;URL&#39;         =&amp;gt; $eventHash-&amp;gt;{&#39;URL&#39;} 
                };
                last SWITCH; }


          ## we will split the key:value pair into an array 
             and grab the value (1st element)
        if ( $_ =~ /^UID/ ) {
                $eventHash-&amp;gt;{&#39;UID&#39;} = ( split ( /:/, $_ ) )[1];
                last SWITCH; }


        if ( $_ =~ /^LOCATION/ ) {
                $eventHash-&amp;gt;{&#39;LOCATION&#39;} = ( split ( /:/, $_ ) )[1];
                last SWITCH; }

...The rest of our key matches...

        if ( $_ =~ /^URL/ ) {
                $eventHash-&amp;gt;{&#39;DESCRIPTION&#39;} = ( split ( /:/, $_ ) )[1];
                last SWITCH; }

} # end switch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While this example does a good job of showing how to fill the data structure, it does a poor job of leveraging the power of Perl. More extensive use of regular expressions, the use of one of the Parse modules in CPAN, or even a bit of recursive programming could make this code more elegant and perhaps even a bit faster. However, these tactics may also make the code a bit harder to read&amp;ndash;which is not always bad, unless you are attempting to explain concepts in an article. For further ideas, Toedor Zlatanov has written an article on &lt;a href=&#34;http://www-106.ibm.com/developerworks/linux/library/l-perl-parsing/&#34;&gt;using Perl parsing modules&lt;/a&gt; as well as a real mind-bender on &lt;a href=&#34;http://www-128.ibm.com/developerworks/linux/library/l-road4.html&#34;&gt;using a functional programming approach in Perl&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;the-dot-specification&#34;&gt;The Dot Specification&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://www.graphviz.org/Documentation/dotguide.pdf&#34;&gt;Dot&lt;/a&gt; (PDF) is a diagramming, or directed, graph language created by Emden Gansner, Eleftherios Koutsofios, and Stephen North at Bell Labs. There are several implementations of Dot, including &lt;a href=&#34;http://www.graphviz.org&#34;&gt;GraphViz&lt;/a&gt;, &lt;a href=&#34;http://www.graphviz.org/webdot/&#34;&gt;WebDot&lt;/a&gt;, and &lt;a href=&#34;http://www.research.att.com/~john/Grappa/&#34;&gt;Grappa&lt;/a&gt;. Interestingly, &lt;a href=&#34;http://www.omnigroup.com/applications/omnigraffle/&#34;&gt;OmniGraffle&lt;/a&gt;, a powerful diagramming tool for Macintosh computers, can read simple Dot files.&lt;/p&gt;

&lt;h3 id=&#34;creating-dot-files&#34;&gt;Creating Dot Files&lt;/h3&gt;

&lt;p&gt;The basic syntax of Dot is that there are objects or things that you describe by adding data within digraph &lt;code&gt;{}&lt;/code&gt; braces. You denote relationships between objects with the &lt;code&gt;-&amp;gt;&lt;/code&gt; combination of characters. With this code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;digraph my_first_graph {
  object1 -&amp;gt; object2;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;your Dot-driven application (such as GraphViz) will display an image something like Figure 3.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_08_18_ical_dot/firstgraph.gif&#34; alt=&#34;a simple graph&#34; width=&#34;103&#34; height=&#34;159&#34; /&gt;
&lt;em&gt;Figure 3. A simple graph&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The specification describes additional complexity in terms of sub-objects/structures, alternate shapes (the default is an oval), ranking, and more. One additional item worth noting is that Dot recognizes comments in C- and Java-style formats (&lt;code&gt;//&lt;/code&gt; and &lt;code&gt;/*&lt;/code&gt;). To help troubleshoot problems (and for good coding practice), I suggest that your parser insert comments into the Dot input file.&lt;/p&gt;

&lt;p&gt;Consider how you might create a Dot file from the data parsed earlier. If you pass to the function that handles the writing of the Dot file the reference to the filehandle of your Dot input file (the output of your conversion) along with the reference to your parsed data structure, then you might generate your Dot file along these lines:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##------------------------------
  ## Name our Dot graph 
  ##------------------------------
  if ( $raw-&amp;gt;{&#39;CALNAME&#39;} ) {
      print { $$file } &#39;digraph &amp;quot;&#39;. $raw-&amp;gt;{&#39;CALNAME&#39;} .&amp;quot;\&amp;quot; {\n\n&amp;quot;;
   } elsif ( $$raw{&#39;CALID&#39;} ) {
      print { $$file } &#39;digraph &amp;quot;&#39;. $raw-&amp;gt;{&#39;CALID&#39;} .&amp;quot;\&amp;quot; {\n\n&amp;quot;;
   } else {
      print { $$file } &amp;quot;digraph unnamed {\n\n&amp;quot;;
   }


   ##-----------------------------------------
   ## Some optional rendering info
   ##-----------------------------------------
   print { $$file } &#39;   size     = &amp;quot;10,7&amp;quot;;&#39;. &amp;quot;\n&amp;quot;.
                    &#39;   compound = true;&#39;  . &amp;quot;\n&amp;quot;.
                    &#39;   ratio    = fill;&#39;  . &amp;quot;\n&amp;quot;.
                    &#39;   rankdir  = LR;&#39;    . &amp;quot;\n\n&amp;quot;;


   ##-----------------------------------------
   ## Generate our Dot data
   ##   we will wrap most data in double-quotes 
   ##   since most Dot interpreters don&#39;t like spaces, 
   ##   something allowed in iCal data
   ##-----------------------------------------
   foreach $key ( keys %$raw ) {
      if ( ref( $raw-&amp;gt;{$key} ) eq &#39;HASH&#39; ) {
         my $block = $raw-&amp;gt;{$key};

           ##------------------------------
           ## graphViz doesn&#39;t like - in names
           ##------------------------------
         $block-&amp;gt;{&#39;UID&#39;} =~ s/-/_/g;

           ##------------------------------
           ## produce list of all unique tasks
           ##------------------------------
         push( @{ $tasks-&amp;gt;{$block-&amp;gt;{&#39;SUMMARY&#39;}} }, &#39;&amp;quot;&#39;. $block-&amp;gt;{&#39;UID&#39;} .&#39;&amp;quot;&#39; );

           ##------------------------------
           ## build record
           ##------------------------------
         my $eventBlock = &#39;&amp;quot;&#39;. $block-&amp;gt;{&#39;UID&#39;} .
                          &#39;&amp;quot; [ shape = record, label = &amp;quot;&#39;. $block-&amp;gt;{&#39;SUMMARY&#39;} .
                           &#39; | &amp;lt;START&amp;gt; Start | &amp;lt;END&amp;gt; End &#39;;

         if ( $block-&amp;gt;{&#39;DESCRIPTION&#39;} ) {
            $eventBlock .= &#39; | &#39;. $block-&amp;gt;{&#39;DESCRIPTION&#39;};
         }
         $eventBlock .= &#39;&amp;quot;];&#39;;

         print { $$file } &#39;   &#39;. $eventBlock .&amp;quot;\n\n&amp;quot;;


            ##------------------------------
            ## build relations based upon time
            ##------------------------------
         push( @timeLine,    &#39;&amp;quot;&#39;. $block-&amp;gt;{&#39;START&#39;} .&#39;&amp;quot;&#39; );
         print { $$file } &#39;   &amp;quot;&#39;. $block-&amp;gt;{&#39;UID&#39;} .&#39;&amp;quot;:START  
            -&amp;gt; &amp;quot;&#39;. $block-&amp;gt;{&#39;START&#39;} .&amp;quot;\&amp;quot;\;\n\n&amp;quot;;

         if ( $$block{&#39;END&#39;} ) {
            push( @timeLine,    &#39;&amp;quot;&#39;. $block-&amp;gt;{&#39;END&#39;} .&#39;&amp;quot;&#39; );
            print { $$file } &#39;   &amp;quot;&#39;. $block-&amp;gt;{&#39;UID&#39;} .&#39;&amp;quot;:END    
               -&amp;gt; &amp;quot;&#39;. $block-&amp;gt;{&#39;END&#39;} .&amp;quot;\&amp;quot;\;\n\n&amp;quot;;
         }

         print { $$file } &amp;quot;\n\n&amp;quot;;

}

      ##------------------------------
      ## tie non-unique tasks
      ##------------------------------
    print { $$file } &#39;   // Create tasks relationships&#39;. &amp;quot;\n\n&amp;quot;;
    foreach ( keys %$tasks ) {
       if ( @{ $tasks-&amp;gt;{$_} } &amp;gt; 1 ) {
          print { $$file } &#39;   &#39;. join( &#39; -&amp;gt; &#39;, @{ $tasks-&amp;gt;{$_} } ) .&amp;quot;\;\n\n&amp;quot;;
       }
    }
    print { $$file } &amp;quot;\n\n&amp;quot;;


      ##------------------------------
      ## Render our timeline
      ##------------------------------
    print { $$file } &#39;   // Create timeline relationships&#39;. &amp;quot;\n\n&amp;quot;;
    print { $$file } &#39;   &#39;. join( &#39; -&amp;gt; &#39;, sort( @timeLine )) .&amp;quot;\;\n\n&amp;quot;;


      ##------------------------------
      ## Close off dot file
      ##------------------------------
    print { $$file } &amp;quot;}\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code will produce the following Dot file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;digraph unnamed {
   size     = &amp;quot;10,7&amp;quot;;
   compound = true;
   ratio    = fill;
   rankdir  = LR;

   &amp;quot;5F88A0EC_AD21_428E_AAAD_005F1B1AB72E&amp;quot; [ shape = record, 
      label = &amp;quot;Set up File Server | &amp;lt;START&amp;gt; Start | 
      &amp;lt;END&amp;gt; End  | Music server for the kids.&amp;quot;];

   &amp;quot;5F88A0EC_AD21_428E_AAAD_005F1B1AB72E&amp;quot;:START  -&amp;gt; &amp;quot;20050615T180000&amp;quot;;

   &amp;quot;BDF17182_CA21_4752_8D4F_40A4FE47C90D&amp;quot; [ shape = record, label = &amp;quot;WWDC | 
      &amp;lt;START&amp;gt; Start | &amp;lt;END&amp;gt; End  | Lots of sessions.&amp;quot;];

   &amp;quot;BDF17182_CA21_4752_8D4F_40A4FE47C90D&amp;quot;:START  -&amp;gt; &amp;quot;20050606&amp;quot;;

   &amp;quot;BDF17182_CA21_4752_8D4F_40A4FE47C90D&amp;quot;:END    -&amp;gt; &amp;quot;20050612&amp;quot;;

   // Create tasks relationships

   // Create timeline relationships

   &amp;quot;20050606&amp;quot; -&amp;gt; &amp;quot;20050612&amp;quot; -&amp;gt; &amp;quot;20050615T180000&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that this code uses the record shape, holding individual segments within the larger object. This is slightly more complicated than the default oval that Dot uses.&lt;/p&gt;

&lt;h3 id=&#34;where-to-go-from-here&#34;&gt;Where to Go from Here&lt;/h3&gt;

&lt;p&gt;If you are using Apple&amp;rsquo;s iCal application, note that the location and naming scheme of iCalendar files changed between the 1.x and 2.x releases. Previously, iCalendar files went in the &lt;em&gt;~/Library/Calendars/&lt;/em&gt; directory and had names of the form &lt;em&gt;&amp;lt;calendar name&amp;gt;.ics&lt;/em&gt;. Thus, a calendar named Work would have a file &lt;em&gt;Work.ics&lt;/em&gt;. However, the 2.x release keeps iCalendar information in the &lt;em&gt;~/Library/Application Support/iCal/Sources/&amp;lt;calendar name&amp;gt;/&lt;/em&gt; directory as &lt;em&gt;sources.ics&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Other applications that implement the iCalendar specification, such as Mozilla&amp;rsquo;s Calendar extension for Mozilla/Firefox/Thunderbird, may follow a different convention. On a Mac, Firefox stores .ics files in the &lt;em&gt;~/Library/Application Support/FireFox/Profiles/&amp;lt;profile&amp;gt;/Calendar/&lt;/em&gt; directory, where &lt;em&gt;&amp;lt;profile&amp;gt;&lt;/em&gt; is the profile specified in the Firefox &lt;em&gt;profile.ini&lt;/em&gt; file. Again, other systems will likely store this information in different locations.&lt;/p&gt;

&lt;p&gt;While on the topic of different implementations, bear in mind that, while the key:value specifications are consistent (as long as the application conforms to RFC 2246), the actual .ics file may look slightly different. For example, Firefox lays out that first event from the previous example as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BEGIN:VEVENT
UID
 :b9794c88-1dd1-11b2-bb51-8a92011a78e8
SUMMARY
 :Apple WWDC
DESCRIPTION
 :Lots of sessions
LOCATION
 :San Francisco
URL
 :http://developer.apple.com/wwdc
STATUS
 :TENTATIVE
CLASS
 :PRIVATE
DTSTART
 ;VALUE=DATE
 :20050606
DTEND
 ;VALUE=DATE
 :20050612
DTSTAMP
 :20050618T191731Z
END:VEVENT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, the key:value tuples (plus any data modifiers such as &lt;code&gt;VALUE=DATE&lt;/code&gt;) almost always split up across lines. In this case, it would be best to handle this difference when reading in the .ics file, so that the rest of the script can expect data in a generic format. One way to do this is to copy the array representing the .ics file using a finite-state machine. Another method would be to walk the array and join array elements under certain conditions, such as if the first non-white-space character of the current element begins with a colon or semicolon character, or is simply non-alphabetic.&lt;/p&gt;

&lt;p&gt;Hopefully, this article will spur you to create a bridge between two of your favorite applications. Good luck, and please remember to share your contributions with the community.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

