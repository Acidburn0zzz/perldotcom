<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Quiz on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/quiz/</link>
    <description>Recent content in Quiz on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 28 May 2004 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/quiz/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Return of Quiz of the Week</title>
      <link>http://localhost:1313/pub/2004/05/28/testing.html/</link>
      <pubDate>Fri, 28 May 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/05/28/testing.html/</guid>
      <description>

&lt;p&gt;Recently, Perl trainer and former &lt;em&gt;perl.com&lt;/em&gt; editor Mark-Jason Dominus revived his &lt;a href=&#34;http://perl.plover.com/qotw/&#34;&gt;Quiz of the Week&lt;/a&gt; mailing list; every week, subscribers are sent a Perl task of either &amp;ldquo;regular&amp;rdquo; or &amp;ldquo;expert&amp;rdquo; level. There are no prizes, but the submitted solutions are collated, discussed, and analyzed. In a way, the prize is the knowledge you gain from looking at various different techniques and approaches to the same problem. Each week, we&amp;rsquo;re going to bring you the analysis from the previous week and the question for you to think about the current week; if you want to join in and submit some solutions, see the Quiz of the Week page above.&lt;/p&gt;

&lt;h3 id=&#34;this-week-s-quiz&#34;&gt;This Week&amp;rsquo;s Quiz&lt;/h3&gt;

&lt;p&gt;The regular quiz this week was submitted by Marco Baringer:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;When I was in elementary school I wasted many an hour playing Hangman with my friends.&lt;/p&gt;

&lt;p&gt;The goal of the game is to guess a word with a certain (limited) number of wrong guesses. If we fail the &amp;ldquo;man&amp;rdquo; gets &amp;ldquo;hanged&amp;rdquo;; if we succeed he is set free. (We&amp;rsquo;re not going to discuss the lesson&amp;rsquo;s of life or the justice this game teaches to the 8 year olds who play it regularly).&lt;/p&gt;

&lt;p&gt;The game starts out with one person (not the player) choosing a &amp;ldquo;mystery&amp;rdquo; word at random and telling the player how many letters the mystery word contains. The player then guesses letters, one at a time, and the mystery word&amp;rsquo;s letters are filled in until a) the entire word is filled in, or b) the maximum number of wrong guesses are reached and the the player loses (man is hanged).&lt;/p&gt;

&lt;p&gt;Write a Perl program that lets the user play Hangman. The program should take the following arguments:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The dictionary file to use&lt;/li&gt;
&lt;li&gt;The maximum number of wrong guesses to give the player&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The program must then chose a mystery word from the dictionary file and print out as many underscores (&amp;rdquo;_&amp;rdquo;) as there are letters in the mystery word. The program will then read letters from the user one at a time. After each guess the program must print the word with properly guessed letters filled in. If the word has been guessed (all the letters making up the word have been guessed) then the program must print &amp;ldquo;LIFE!&amp;rdquo; and exit. If the word is not guessed before the maximum number of guesses is reached then the program must print &amp;ldquo;DEATH!&amp;rdquo; and exit.&lt;/p&gt;

&lt;p&gt;Some additional requirements:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The dictionary file will contain one word per line and use only 7-bit ASCII characters. It may contain randomly generated words. The dictionary will contain only words longer than 1 character. The size of the dictionary may be very large.&lt;/li&gt;
&lt;li&gt;The dictionary file used for the test (or the program for generating it) will be made available along with the write-up.&lt;/li&gt;
&lt;li&gt;If a letter appears more than once in the mystery word, all occurrences of that letter must be filled in. So, if the word is &amp;lsquo;bokonon&amp;rsquo; and the player guesses &amp;lsquo;o&amp;rsquo; the output must be &amp;lsquo;&lt;code&gt;_o_o_o_&lt;/code&gt;&amp;rsquo;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;The concensus on the discussion list seems to be that minor alterations and improvements to the user interface are OK, and that the expert quiz will be to write a program that efficiently implements the other side of the interface: to play the game of Hangman against the server.&lt;/p&gt;

&lt;p&gt;And now, onto the discussion of last week&amp;rsquo;s quiz&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;last-week-s-regular-quiz&#34;&gt;Last Week&amp;rsquo;s Regular Quiz&lt;/h3&gt;

&lt;p&gt;Geoffrey Rommel sent the following question:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The usual way to look for a character string in files in Unix is to use grep. For instance, let&amp;rsquo;s say you want to search for the word &amp;lsquo;summary&amp;rsquo; without regard to case in all files in a certain directory. You might say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grep -i summary *
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But if there is a very large number of files in your directory, you will get something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ksh: /usr/bin/grep: arg list too long
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, you could just issue multiple commands, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grep -i summary [A-B]*
grep -i summary [C-E]*
etc.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; but that&amp;rsquo;s so tedious.&lt;/p&gt;

&lt;p&gt;Write a Perl program that allows you to search all files in such a directory with one command.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;And Geoffrey&amp;rsquo;s solution:&lt;/p&gt;

&lt;p&gt;This quiz was suggested to me by a directory on one of my servers where all of our executable scripts are stored. This directory now has over 4,200 scripts and has gotten too big to search.&lt;/p&gt;

&lt;p&gt;The solution shown here works for my purposes, but I do not wish to depreciate the ingenious solutions found on the discussion list. I will try to evaluate and discuss them in a separate message.&lt;/p&gt;

&lt;p&gt;As MJD mentioned, Perl regex matching is clearly superior to the alternatives. Since the original purpose was to search a directory of scripts, the search is not case-sensitive; that option could be added easily enough. We search only files (-f) in the specified directory, not in lower directories. I also test for &amp;ldquo;text&amp;rdquo; files (-T) because my Telnet client gets hopelessly confused if you start displaying non-ASCII characters.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/perl
# The bin directory is too large to search all at once, so this does
# it in pieces.
($PAT, $DIR) = @ARGV[0,1];
$DIR ||= &amp;quot;&amp;quot;;
die &amp;quot;Syntax:  q16 pattern directory\n&amp;quot; unless $PAT;

open(LS, &amp;quot;ls -1 $DIR |&amp;quot;) or die &amp;quot;Could not ls: $!&amp;quot;;

@list = ();
while (&amp;lt;LS&amp;gt;) {
   chomp;
   push @list , (($DIR eq &amp;quot;&amp;quot;) ? $_ : &amp;quot;$DIR/$_&amp;quot;);
   if (@list &amp;gt;= 800) {
      greptext($PAT, @list);
      @list = ();
   }
}
greptext($PAT, @list);

close LS;
exit;

sub greptext {
 my ($pattern, @files) = @_;

 foreach $fname (@files) {
    next unless -f $fname &amp;amp;&amp;amp; -T _;
    open FI, $fname;
    while (&amp;lt;FI&amp;gt;) {
       chomp;
       print &amp;quot;$fname [$.]: $_\n&amp;quot; if m/$pattern/oi;
    }
    close FI;
 }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For what it&amp;rsquo;s worth, here is my take on the solutions offered for the week&amp;rsquo;s quiz. This quiz was a humbling reminder that we should specify our requirements exactly. Although I deliberately left some of the design open, I apparently did not make the requirements clear. Three of the submissions failed on the very task they were intended to solve&amp;ndash;namely, running through all files in a large directory of files. Instead of specifying a directory name, you had to specify a list of file names on the command line, which of course resulted in the dreaded &amp;ldquo;arg list too long&amp;rdquo; message. As someone pointed out, this is really a shell limitation, but there it is. (For the record, I am running MP-RAS, an svr4 variant, with the Korn shell.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;           1   2   3   4   5   F    CPU                                         
brent      1   1   1   1   1   1  65.01                                         
dunham     1   1   1   0   2   2   2.92                                         
fish       1   1   1   0   2   2   3.32                                         
mjd        0   0   0   0   2   2     --                                         
rommel     1   1   1   1   2   0   2.66                                         
scott      1   0   1   1   2   2     --                                         
sims       0   0   0   0   2   2     --                                         
wett       0   0   0   0   2   0     --  

1. Did it work when there was a named pipe in the directory?                    
2. Did it work as desired on the large directory?                               
3. Did it work when only a directory name was specified?                        
4. Did it work (as ls does) when no directory name was specified?               
5. Aesthetics of output (error messages, line numbers, etc.)                    
F. Flexibility of program                                                       
CPU: to search large directory; in seconds as reported by timex                 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tests 1-2 were requirements. Tests 3-4 were nice to have. Peter Scott&amp;rsquo;s program worked nicely on a small directory but produced unexpected output on the large directory: it seemed to be executing some scripts rather than searching them, so I deemed it to have failed. Brent Royal-Gordon&amp;rsquo;s script got a lower score for aesthetics because it produced a number of lines saying &amp;ldquo;UX:grep: ERROR: Cannot open &amp;ndash;&amp;ldquo;.&lt;/p&gt;

&lt;p&gt;I was particularly impressed with the flexibility of many of the scripts; my own submission, although the fastest, was also the least flexible. I am quite in agreement with James Wetterau&amp;rsquo;s defense of minimalism. A program like this would not even be necessary if the shell allowed us to pass 4,200 arguments. Since it doesn&amp;rsquo;t, however, we must do some of the work ourselves.&lt;/p&gt;

&lt;h3 id=&#34;last-week-s-expert-quiz&#34;&gt;Last Week&amp;rsquo;s Expert Quiz&lt;/h3&gt;

&lt;p&gt;This was sent by Shlomi Fish:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You will write a Perl program that schedules the semester of courses at Haifa University. &lt;code&gt;@courses&lt;/code&gt; is an array of course names, such as &amp;ldquo;Advanced Basket Weaving&amp;rdquo;. &lt;code&gt;@slots&lt;/code&gt; is an array of time slots at which times can be scheduled, such as &amp;ldquo;Monday mornings&amp;rdquo; or &amp;ldquo;Tuesdays and Thursdays from 1:00 to 2:30&amp;rdquo;. (Time slots are guaranteed not to overlap.)&lt;/p&gt;

&lt;p&gt;You are also given a schedule that says when each course meets. &lt;code&gt;$schedule[$n][$m]&lt;/code&gt; is true if course &lt;code&gt;$n&lt;/code&gt; meets during time slot &lt;code&gt;$m&lt;/code&gt;, and false if not.&lt;/p&gt;

&lt;p&gt;Your job is to write a function, &amp;lsquo;&lt;code&gt;allocate_minimal_rooms&lt;/code&gt;&amp;rsquo;, to allocate classrooms to courses. Each course must occupy the same room during every one of its time slots. Two courses cannot occupy the same room at the same time. Your function should produce a schedule that allocates as few rooms as possible.&lt;/p&gt;

&lt;p&gt;The &amp;lsquo;&lt;code&gt;allocate_minimal_rooms&lt;/code&gt;&amp;rsquo; function will get three arguments:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The number of courses&lt;/li&gt;
&lt;li&gt;The number of different time slots&lt;/li&gt;
&lt;li&gt;A reference to the &lt;code&gt;@schedule&lt;/code&gt; array&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;It should return a reference to an array, say &lt;code&gt;$room&lt;/code&gt;, which indicates the schedule. &lt;code&gt;$room-&amp;gt;[$n]&lt;/code&gt; will be the number of the room in which course &lt;code&gt;$n&lt;/code&gt; will meet during all of its time slots. If courses &lt;code&gt;$n&lt;/code&gt; and &lt;code&gt;$m&lt;/code&gt; meet at the same time, then &lt;code&gt;$room-&amp;gt;[$n]&lt;/code&gt; must be different from &lt;code&gt;$room-&amp;gt;[$m]&lt;/code&gt;, because the two courses cannot use the same room at the same time.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Well, this quiz generated several solutions from several people.&lt;/p&gt;

&lt;p&gt;MJD sent a &lt;a href=&#34;http://article.gmane.org/gmane.comp.lang.perl.qotw.discuss/1661&#34;&gt;test suite&lt;/a&gt;, and I sent a &lt;a href=&#34;http://article.gmane.org/gmane.comp.lang.perl.qotw.discuss/1662&#34;&gt;test suite of my own&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Roger Burton West sent an &lt;a href=&#34;http://perl.plover.com/~alias/list.cgi?1:mss:1599&#34;&gt;exhaustive search solution&lt;/a&gt;; Ronald J. Kimball also sent an exhaustive search one, &lt;a href=&#34;http://perl.plover.com/~alias/list.cgi?1:mmn:1600&#34;&gt;this time&lt;/a&gt; using string operations to represent the schedule array.&lt;/p&gt;

&lt;p&gt;Christian Duhl identified that the problem was NP-Complete, transformed it to a graph coloring problem, and solved it using &lt;a href=&#34;http://article.gmane.org/gmane.comp.lang.perl.qotw.discuss/1666&#34;&gt;this&lt;/a&gt;. I sent my own solution. &lt;a href=&#34;http://perl.plover.com/~alias/list.cgi?1:mmn:1603&#34;&gt;This one&lt;/a&gt; uses intermediate truth tables between courses and rooms.&lt;/p&gt;

&lt;p&gt;Finally, Mark Jason Dominus posted &lt;a href=&#34;http://perl.plover.com/~alias/list.cgi?1:mmn:1604&#34;&gt;his solution&lt;/a&gt;, which also used recursion as well as string operations.&lt;/p&gt;

&lt;p&gt;My solution is smarter than the brute-force method, but still recursive and may explode for certain schedules.&lt;/p&gt;

&lt;p&gt;It works by assigning a room to a course, and then finding a course that requires a different room. It then assigns another room to this course. The algorithm maintains a truth table of which courses can be allocated to specific rooms. Once a room was allocated to a class, all of the classes that share time-slots with this class are marked as being unable to use the room. If all the rooms that were allocated so far are unusable by a certain class, then it is allocated a new room.&lt;/p&gt;

&lt;p&gt;If the algorithm reaches a place where a room can be allocated to any of several classes, it recurses with each possibility.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

