<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ping on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/ping/</link>
    <description>Recent content in Ping on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 06 Jul 2015 12:27:10 +0000</lastBuildDate>
    <atom:link href="/tags/ping/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Host discovery with broadcast and echo</title>
      <link>http://localhost:1313/article/180/2015/7/6/Host-discovery-with-broadcast-and-echo/</link>
      <pubDate>Mon, 06 Jul 2015 12:27:10 +0000</pubDate>
      
      <guid>http://localhost:1313/article/180/2015/7/6/Host-discovery-with-broadcast-and-echo/</guid>
      <description>

&lt;p&gt;Network host discovery is the attempt to elicit the addresses of the hosts connected to a network. Last week I &lt;a href=&#34;http://perltricks.com/article/179/2015/7/1/Basic-network-hacking-with-Perl&#34;&gt;wrote&lt;/a&gt; about a unicast approach with Perl that enumerated through every address in the network subnet, messaging each address in turn to see if any hosts respond. This week I&amp;rsquo;ve been working on an alternative approach using broadcast and echo.&lt;/p&gt;

&lt;h3 id=&#34;icmp-and-echo&#34;&gt;ICMP and echo&lt;/h3&gt;

&lt;p&gt;Internet Control Message Protocol (ICMP) is a networking protocol used by networking devices to coordinate with each other. ICMP messages contain a type and a code which have predefined &lt;a href=&#34;https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol#Control_messages&#34;&gt;meanings&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;An ICMP message of type 8 means echo request and hosts are expected to respond with an ICMP message of type 0 (echo reply). To discover hosts on a network, I can send an echo request to the network and capture the IP address of any echo replies received. Instead of cycling through every possible IP address in the subnet, I can send the echo request to the broadcast IP: &lt;code&gt;255.255.255.255&lt;/code&gt; and the message will automatically be sent to every host on the network.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re running a modern Linux, you can test this out at the command line using &lt;code&gt;ping&lt;/code&gt; (other versions may work without the &amp;ldquo;-b&amp;rdquo; switch):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ ping &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;b &lt;span style=&#34;color:#ae81ff&#34;&gt;255.255.255.255&lt;/span&gt;
WARNING: pinging broadcast address
PING &lt;span style=&#34;color:#ae81ff&#34;&gt;255.255.255.255&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;255.255.255.255&lt;/span&gt;) &lt;span style=&#34;color:#ae81ff&#34;&gt;56&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;84&lt;/span&gt;) bytes of data&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;
&lt;span style=&#34;color:#ae81ff&#34;&gt;64&lt;/span&gt; bytes from &lt;span style=&#34;color:#ae81ff&#34;&gt;192.168.1.4&lt;/span&gt;: icmp_seq&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; ttl&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;64&lt;/span&gt; time&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;92.9&lt;/span&gt; ms
&lt;span style=&#34;color:#ae81ff&#34;&gt;64&lt;/span&gt; bytes from &lt;span style=&#34;color:#ae81ff&#34;&gt;192.168.1.4&lt;/span&gt;: icmp_seq&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; ttl&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;64&lt;/span&gt; time&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2.04&lt;/span&gt; ms
&lt;span style=&#34;color:#ae81ff&#34;&gt;64&lt;/span&gt; bytes from &lt;span style=&#34;color:#ae81ff&#34;&gt;192.168.1.4&lt;/span&gt;: icmp_seq&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; ttl&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;64&lt;/span&gt; time&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;136&lt;/span&gt; ms
&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here you see one other host on my network is responding at the address &lt;code&gt;192.168.1.4&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;implementing-echo-in-perl&#34;&gt;Implementing echo in Perl&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s possible to implement ping using nothing but core Perl modules. That is, if Perl is installed, this &lt;a href=&#34;https://github.com/dnmfarrell/Penetration-Testing-With-Perl/blob/master/livehost_echo&#34;&gt;script&lt;/a&gt; should work:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#!/usr/bin/perl&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; strict;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; warnings;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Socket;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Net::Ping;

&lt;span style=&#34;color:#75715e&#34;&gt;# the checksum must be correct else hosts will ignore the request&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $msg_checksum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Net::Ping&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;checksum(pack(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;C2 n3&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;));
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $msg &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pack(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;C2 n3&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, $msg_checksum, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);

socket(&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $socket, AF_INET, SOCK_RAW, getprotobyname(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;icmp&amp;#39;&lt;/span&gt;));
setsockopt($socket, SOL_SOCKET, SO_BROADCAST, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
send($socket, $msg, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, sockaddr_in(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, inet_aton(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;255.255.255.255&amp;#39;&lt;/span&gt;)));
bind($socket,sockaddr_in(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,inet_aton(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)));

&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
{
  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $addr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; recv($socket, &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $data, &lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; ($tmp, $tos, $len, $id, $offset, $tt, $proto, $checksum,
    $src_ip, $dest_ip, $options) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; unpack(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;CCnnnCCnNNa*&amp;#39;&lt;/span&gt;, $data);

  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ($dest_ip &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4294967295&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;# destination != 255.255.255.255&lt;/span&gt;
  {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; ($port, $peer) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sockaddr_in($addr);
    printf &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%s bytes from %s\n&amp;#34;&lt;/span&gt;, length($data), inet_ntoa($peer);
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This script starts by importing the &lt;code&gt;Socket&lt;/code&gt; and &lt;code&gt;Net::Ping&lt;/code&gt; modules - both part of the Perl core distribution. It uses the &lt;code&gt;checksum&lt;/code&gt; function from &lt;code&gt;Net::Ping&lt;/code&gt; to calculate the message checksum. The checksum is important because if it is incorrect, hosts will not reply. The script packs the code, the type, checksum and offset into &lt;code&gt;$msg&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The script then creates a broadcast socket, and sends the message to the broadcast address (&lt;code&gt;255.255.255.255&lt;/code&gt;). The socket is then bound to the network address, and the script enters a while loop attempting to read data from the socket using &lt;code&gt;recv&lt;/code&gt;. Any received data is unpacked and the packet address saved in &lt;code&gt;$addr&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The source and destination IP fields in the unpacked message are stored as 32 bit integers, so the script ignores packets whose destination matches the integer of the broadcast address, as this message was sent by the script. After that the script decodes the packet address and prints the results.&lt;/p&gt;

&lt;p&gt;Running this script on my network, I can see the same host as was returned by &lt;code&gt;ping&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ sudo &lt;span style=&#34;color:#f92672&#34;&gt;./&lt;/span&gt;livehost_echo                                 
&lt;span style=&#34;color:#ae81ff&#34;&gt;28&lt;/span&gt; bytes from &lt;span style=&#34;color:#ae81ff&#34;&gt;192.168.1.4&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;fingerprinting-hosts&#34;&gt;Fingerprinting hosts&lt;/h3&gt;

&lt;p&gt;The primary issue with this technique is it can only discover hosts that respond to broadcast requests, and many do not. For example Chromebooks, smart phones and Linux machines usually don&amp;rsquo;t reply (OSX machines and many versions of Windows do though). This can be an advantage though: because the response rate to broadcast is different to unicast, the echo script can be used in conjunction with unicast to fingerprint hosts. If a machine responds to a unicast message but not a broadcast, we learn something about the identity of that host. For example if I use the &lt;a href=&#34;https://github.com/dnmfarrell/Penetration-Testing-With-Perl/blob/master/livehost_scanner&#34;&gt;livehost_scanner&lt;/a&gt; script on my home network:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;sudo $&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;(&lt;/span&gt;which perl) livehost_scanner                                                                                                                  
Gateway IP: &lt;span style=&#34;color:#ae81ff&#34;&gt;192.168.1.1&lt;/span&gt;
Starting scan
&lt;span style=&#34;color:#ae81ff&#34;&gt;192.168.1.1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;d:7f:81:31:c2
&lt;span style=&#34;color:#ae81ff&#34;&gt;192.168.1.2&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;c:c5:d4:47:0a:13 (this machine)
&lt;span style=&#34;color:#ae81ff&#34;&gt;192.168.1.7&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;38&lt;/span&gt;:e7:d8:00:9a:d5
&lt;span style=&#34;color:#ae81ff&#34;&gt;192.168.1.4&lt;/span&gt; e0:ac:cb:5e:d5:da
&lt;span style=&#34;color:#ae81ff&#34;&gt;192.168.1.10&lt;/span&gt; cc:3d:82:60:4b:95&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I can see that there 2 other livehosts (excluding the router) which show up, but didn&amp;rsquo;t respond to an echo request. The echo script could be adapted to send other types of ICMP messages such as timestamp and subnet mask which can be used to further &lt;a href=&#34;http://www.sans.org/security-resources/idfaq/icmp_misuse.php&#34;&gt;identify&lt;/a&gt; a host.&lt;/p&gt;

&lt;h3 id=&#34;further-thoughts&#34;&gt;Further thoughts&lt;/h3&gt;

&lt;p&gt;The echo script uses the broadcast technique which only works on IPv4 networks. IPv6 networks support multicast instead, but that would require changes to the script. Interestingly the number of potential addresses in a single IPv6 subnet, (I think) renders the unicast technique redundant.&lt;/p&gt;

&lt;p&gt;Another other problem with the echo script is that because it opens a raw socket, it requires root privileges to run. The &lt;code&gt;ping&lt;/code&gt; utility on the other hand is installed with setuserid permissions and runs as root regardless of the user&amp;rsquo;s own privileges.&lt;/p&gt;

&lt;h3 id=&#34;useful-resources&#34;&gt;Useful resources&lt;/h3&gt;

&lt;p&gt;In preparing this script I learned a lot about sockets and network programming. Lincoln Stein&amp;rsquo;s &lt;a href=&#34;http://www.amazon.com/Network-Programming-Perl-Lincoln-Stein/dp/0201615711/ref=la_B000APT5P6_1_1&#34;&gt;Network Programming with Perl&lt;/a&gt; was an invaluable resource for understanding sockets and the arcane invocations to use with them. If you&amp;rsquo;re considering working with sockets, the &lt;a href=&#34;https://metacpan.org/pod/IO::Socket&#34;&gt;IO::Socket&lt;/a&gt; module has a cleaner interface than the &lt;a href=&#34;https://metacpan.org/pod/Socket&#34;&gt;Socket&lt;/a&gt; module (and is also part of core). The source code for the excellent &lt;a href=&#34;https://metacpan.org/pod/NetPacket&#34;&gt;NetPacket&lt;/a&gt; distribution was useful in understanding how to parse packets.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

