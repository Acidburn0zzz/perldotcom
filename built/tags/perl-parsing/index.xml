<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Perl Parsing on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/perl-parsing/</link>
    <description>Recent content in Perl Parsing on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 27 Oct 2019 12:07:00 +0000</lastBuildDate>
    <atom:link href="/tags/perl-parsing/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>My Perl Wishlist: Invariant Sigils (Part 1)</title>
      <link>http://localhost:1313/article/my-perl-wishlist-invariant-sigils-part-1/</link>
      <pubDate>Sun, 27 Oct 2019 12:07:00 +0000</pubDate>
      
      <guid>http://localhost:1313/article/my-perl-wishlist-invariant-sigils-part-1/</guid>
      <description>

&lt;p&gt;Pop quiz!  Q: What was my mistake in this line?&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;is %HASH{answer}, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;forty-two&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;%HASH properly filled&amp;#39;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A: I had the answer right, but I messed up the sigil on &lt;code&gt;HASH&lt;/code&gt;.  It
should be:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;is $HASH{answer}, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;forty-two&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;%HASH properly filled&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;#  ^ $, not %&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Unfortunately, on Perl v5.20+, both statements work the same way!  I
didn&amp;rsquo;t catch the problem until I shipped this code and
&lt;a href=&#34;http://matrix.cpantesters.org/?dist=vars-i+1.08-TRIAL&#34;&gt;cpantesters&lt;/a&gt;
showed me my mistake.  It was an easy fix, but it reminded me that Perl&amp;rsquo;s
&lt;a href=&#34;http://modernperlbooks.com/books/modern_perl/chapter_03.html#variablenamesandsigils&#34;&gt;variant sigils&lt;/a&gt;
can trip up programmers at any level.  If I could change one thing about
Perl 5, I would change to invariant sigils.&lt;/p&gt;

&lt;h2 id=&#34;the-current-situation&#34;&gt;The current situation&lt;/h2&gt;

&lt;p&gt;In Perl, the sigil tells you
&lt;a href=&#34;https://perldoc.perl.org/perlintro.html#Perl-variable-types&#34;&gt;how many things to expect&lt;/a&gt;.
Scalars such as &lt;code&gt;$foo&lt;/code&gt; are single values.  Any single value in an array
&lt;code&gt;@foo&lt;/code&gt; or hash &lt;code&gt;%foo&lt;/code&gt;, since it is only one thing,
&lt;a href=&#34;https://perldoc.perl.org/perldata.html#Variable-names&#34;&gt;also uses &lt;code&gt;$&lt;/code&gt;&lt;/a&gt;,
so &lt;code&gt;$foo&lt;/code&gt;, &lt;code&gt;@foo&lt;/code&gt;, and &lt;code&gt;%foo&lt;/code&gt; could all refer to different pieces of the
same variable &amp;mdash; or to different variables.
This technique of &amp;ldquo;variant sigils&amp;rdquo; works, but confuses
new Perl users and tripped up yours truly.  To know what you
are accessing in an array or hash, you have to look at both the sigil
and the brackets.  As a reminder:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Sigil&lt;/th&gt;
&lt;th&gt;No brackets&lt;/th&gt;
&lt;th&gt;&lt;code&gt;[ ]&lt;/code&gt; (array access)&lt;/th&gt;
&lt;th&gt;&lt;code&gt;{ }&lt;/code&gt; (hash access)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;$z&lt;/code&gt;: a scalar, i.e., a single value&lt;/td&gt;
&lt;td&gt;&lt;code&gt;$z[0]&lt;/code&gt;: the first element of array &lt;code&gt;@z&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;$z{0}&lt;/code&gt;: the value in hash &lt;code&gt;%z&lt;/code&gt; at key &lt;code&gt;&amp;quot;0&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@z&lt;/code&gt;: An array, i.e., a list of value(s)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@z[0, 1]&lt;/code&gt;: the list &lt;code&gt;($z[0], $z[1])&lt;/code&gt; of two elements from &lt;code&gt;@z&lt;/code&gt; (an &amp;ldquo;array slice&amp;rdquo;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@z{0, &amp;quot;foo&amp;quot;}&lt;/code&gt;: the list &lt;code&gt;($z{0}, $z{foo})&lt;/code&gt; of two elements from hash &lt;code&gt;%z&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%z&lt;/code&gt;: A hash, i.e., a list of key/value pair(s)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%z[0, 1]&lt;/code&gt;: the list &lt;code&gt;(0, $z[0], 1, $z[1])&lt;/code&gt; of keys and two values from array &lt;code&gt;@z&lt;/code&gt; (a &amp;ldquo;hash slice&amp;rdquo;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%z{0, &amp;quot;foo&amp;quot;}&lt;/code&gt;: the list &lt;code&gt;(&amp;quot;0&amp;quot;, $z{0}, &amp;quot;foo&amp;quot;, $z{foo})&lt;/code&gt; of keys and values from hash &lt;code&gt;%z&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;make-the-sigils-part-of-the-name&#34;&gt;Make the sigils part of the name&lt;/h2&gt;

&lt;p&gt;To save myself from repeating my errors, I&amp;rsquo;d like the sigil to be part of a
variable&amp;rsquo;s name.  This is not a new idea; scalars work this way in Perl, bash,
and &lt;a href=&#34;https://docs.perl6.org/language/101-basics#sigil_and_identifier&#34;&gt;Raku&lt;/a&gt;
(&lt;a href=&#34;https://github.com/perl6/problem-solving/blob/master/solutions/language/Path-to-Raku.md&#34;&gt;formerly Perl 6&lt;/a&gt;).
That would make the above table look like:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Sigil&lt;/th&gt;
&lt;th&gt;No brackets&lt;/th&gt;
&lt;th&gt;&lt;code&gt;[ ]&lt;/code&gt; (array access)&lt;/th&gt;
&lt;th&gt;&lt;code&gt;{ }&lt;/code&gt; (hash access)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;$z&lt;/code&gt;: a scalar, i.e., a single value&lt;/td&gt;
&lt;td&gt;&lt;code&gt;$z[0]&lt;/code&gt;: N/A&lt;/td&gt;
&lt;td&gt;&lt;code&gt;$z{0}&lt;/code&gt;: N/A&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@z&lt;/code&gt;: An array, i.e., a list of value(s)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@z[0]&lt;/code&gt;: the first element of &lt;code&gt;@z&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@z{0}&lt;/code&gt;: N/A&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%z&lt;/code&gt;: A hash, i.e., a list of key/value pair(s)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%z[0]&lt;/code&gt;: N/A&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%z{0}&lt;/code&gt;: the value in hash &lt;code&gt;%z&lt;/code&gt; at key &lt;code&gt;0&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Simpler!  Any reference to &lt;code&gt;@z&lt;/code&gt; would always be doing &lt;em&gt;something&lt;/em&gt; with
the array named &lt;code&gt;@z&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;but-what-about-slices&#34;&gt;But what about slices?&lt;/h2&gt;

&lt;p&gt;Slices such as &lt;code&gt;@z[0,1]&lt;/code&gt; and &lt;code&gt;%z{qw(hello there)}&lt;/code&gt; return multiple
values from an array or hash.  If sigils &lt;code&gt;@&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt; are no longer
available for slicing, we need an alternative.
The Perl family currently provides two models: postfix dereferencing
(&amp;ldquo;postderef&amp;rdquo;) syntax and postfix adverbs.&lt;/p&gt;

&lt;p&gt;Perl v5.20+ support
&lt;a href=&#34;https://www.effectiveperlprogramming.com/2014/09/use-postfix-dereferencing/&#34;&gt;postderef&lt;/a&gt;,
which gives us one option.  Postderef separates the name from the slice:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Valid Perl v5.20+&lt;/span&gt;
$hashref&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{a};      &lt;span style=&#34;color:#75715e&#34;&gt;# Scalar, element at index &amp;#34;a&amp;#34; of the hash pointed to by $hashref&lt;/span&gt;
$hashref&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;@{a};     &lt;span style=&#34;color:#75715e&#34;&gt;# List including the &amp;#34;a&amp;#34; element of the hash pointed to by $hashref&lt;/span&gt;
$hashref&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;%{a};     &lt;span style=&#34;color:#75715e&#34;&gt;# List including the key &amp;#34;a&amp;#34; and the &amp;#34;a&amp;#34; element of the hash pointed to by $hashref&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The type of slice comes after the reference, instead of as a sigil
before the reference.  With non-references, that idea would give us slice
syntax such as &lt;code&gt;@array@[1,2,3]&lt;/code&gt; or &lt;code&gt;%hash%{a}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Raku gives us another option: &amp;ldquo;adverbs&amp;rdquo; such as
&lt;a href=&#34;https://docs.perl6.org/language/subscripts#:kv&#34;&gt;&lt;code&gt;:kv&lt;/code&gt;&lt;/a&gt;.  For example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl6&#34; data-lang=&#34;perl6&#34;&gt;# Valid Raku
%hash{&amp;#34;a&amp;#34;}          # Single value, element at index &amp;#34;a&amp;#34; of %hash
%hash{&amp;#34;a&amp;#34;}:v;       # The same --- just the value
%hash{&amp;#34;a&amp;#34;}:kv;      # The list including key &amp;#34;a&amp;#34; and the value of the &amp;#34;a&amp;#34; element of %hash&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The adverb (e.g., &lt;code&gt;:kv&lt;/code&gt;) goes in postfix position, immediately
after the brackets or braces.  Following this model,
slices would look like &lt;code&gt;@array[1,2,3]:l&lt;/code&gt; or &lt;code&gt;%hash{a}:kv&lt;/code&gt;.  (For clarity,
I propose &lt;code&gt;:l&lt;/code&gt;, as in &lt;strong&gt;l&lt;/strong&gt;ist, instead of Raku&amp;rsquo;s &lt;code&gt;:v&lt;/code&gt;.  Raku&amp;rsquo;s &lt;code&gt;:v&lt;/code&gt; can return
a scalar or a list.)&lt;/p&gt;

&lt;p&gt;So, the choices I see are (postderef-inspired / Raku-inspired):&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;What you want&lt;/th&gt;
&lt;th&gt;No subscript&lt;/th&gt;
&lt;th&gt;&lt;code&gt;[ ]&lt;/code&gt; access&lt;/th&gt;
&lt;th&gt;&lt;code&gt;{ }&lt;/code&gt; access&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Scalar&lt;/td&gt;
&lt;td&gt;&lt;code&gt;$z&lt;/code&gt;: a scalar, i.e., a single value&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@z[0]&lt;/code&gt;: a single value from an array&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%z{0}&lt;/code&gt;: the value in hash &lt;code&gt;%z&lt;/code&gt; at key &lt;code&gt;&amp;quot;0&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;List of values&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@z&lt;/code&gt;: an array, i.e., a list of value(s)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@z@[0, 1]&lt;/code&gt; / &lt;code&gt;@z[0, 1]:l&lt;/code&gt;: the list currently written &lt;code&gt;($z[0], $z[1])&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%z@{0, &amp;quot;foo&amp;quot;}&lt;/code&gt; / &lt;code&gt;%z{0, &amp;quot;foo&amp;quot;}:l&lt;/code&gt;: the list currently written &lt;code&gt;($z{0}, $z{foo})&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;List of key/value pairs&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%z&lt;/code&gt;: a hash, i.e., a list of key/value pair(s)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@z%[0, 1]&lt;/code&gt; / &lt;code&gt;@z[0, 1]:kv&lt;/code&gt;: the list currently written &lt;code&gt;(0, $z[0], 1, $z[1])&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%z%{0, &amp;quot;foo&amp;quot;}&lt;/code&gt; / &lt;code&gt;%z{0, &amp;quot;foo&amp;quot;}:kv&lt;/code&gt;: the list currently written &lt;code&gt;(&amp;quot;0&amp;quot;, $z{0}, &amp;quot;foo&amp;quot;, $z{foo})&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;you-can-t-always-get-what-you-want&#34;&gt;You can&amp;rsquo;t always get what you want&lt;/h2&gt;

&lt;p&gt;I prefer the adverb syntax.  It is easy to read, and it draws on
all the expertise that has gone into the design of Raku.
However, my preference has to be implementable.
I&amp;rsquo;m not convinced that it is without major surgery.&lt;/p&gt;

&lt;p&gt;The Perl parser decides how to interpret what is inside the brackets
depending on the context provided by the slice.
The parser interprets the &lt;code&gt;...&lt;/code&gt; in &lt;code&gt;@foo[...]&lt;/code&gt; as
a list (&lt;a href=&#34;https://github.com/Perl/perl5/blob/c58ad1f93e9ad7834d3735683462c07119aa87f5/perly.y#L1143-L1148&#34;&gt;ref&lt;/a&gt;).
In &lt;code&gt;$foo[...]&lt;/code&gt;, the parser sees the &lt;code&gt;...&lt;/code&gt; as a scalar expression
(&lt;a href=&#34;https://github.com/Perl/perl5/blob/c58ad1f93e9ad7834d3735683462c07119aa87f5/perly.y#L958-L960&#34;&gt;ref&lt;/a&gt;).
For any slice syntax, the Perl parser needs to know the desired
type of result while parsing the subscript expression.  The adverb form,
unfortunately, leaves the parser guessing until after the subscript
is parsed.&lt;/p&gt;

&lt;p&gt;You can, in fact, hack the Perl parser to save the subscript
until it sees a postfix adverb.  The parser can then apply the correct
context.  I wrote a
&lt;a href=&#34;https://github.com/Perl/perl5/compare/9786385e68f7f14df6f4dd0f04d2c72c0d9a2511...cxw42:3cd904788536b445c9c3abe9b469e1b569942051&#34;&gt;proof-of-concept&lt;/a&gt;
for &lt;code&gt;@arr[expr]:v&lt;/code&gt;.  It doesn&amp;rsquo;t execute any code, but it does parse
a postfix-adverb slice without crashing!  However, while writing that code,
I ran across a surprise: new syntax isn&amp;rsquo;t tied to a &lt;code&gt;use v5.xx&lt;/code&gt;
directive.&lt;/p&gt;

&lt;p&gt;It turns out the Perl parser lets code written against any Perl version
use the latest syntax.  Both of the following command lines work on Perl v5.30:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ perl -Mstrict -Mwarnings -E &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;my $z; $z-&amp;gt;@* = 10..20&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#                           ^ -E: use all the latest features
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;$ perl -Mstrict -Mwarnings -e &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;my $z; $z-&amp;gt;@* = 10..20&amp;#39;&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;# (!!!)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;#                           ^ -e: not the latest features&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The second command line does not &lt;code&gt;use v5.30&lt;/code&gt;, so you can&amp;rsquo;t use &lt;code&gt;say&lt;/code&gt;
(introduced in v5.10).  However, you can use postderef (from v5.20)!&lt;/p&gt;

&lt;p&gt;Because the parser lets old programs use new syntax, any proposed addition
to Perl&amp;rsquo;s syntax has to be meaningless in all previous Perl versions.
A postfix adverb fails this test.  For example, the following is a valid
Perl program:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;kv&lt;/span&gt; { &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;kv&amp;#34;&lt;/span&gt; }
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @arr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; ? @arr[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]:kv;
        &lt;span style=&#34;color:#75715e&#34;&gt;# ^^^^^^^^^^^^ valid Perl 5 syntax, but not a slice :(&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\n&amp;#34;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;My preferred slice syntax could change the meaning of existing programs,
so it looks like I can&amp;rsquo;t get my first choice.&lt;/p&gt;

&lt;h2 id=&#34;next-steps&#34;&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;This is not the end of the story!  In Part 2, I will dig deeper into
Perl&amp;rsquo;s parser and tokenizer.  I will share some surprises I discovered
while investigating postderef.  I will then describe a possible path
to invariant sigils and the simplicity they can provide.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>More Advancements in Perl Programming</title>
      <link>http://localhost:1313/pub/2006/01/26/more_advanced_perl.html/</link>
      <pubDate>Thu, 26 Jan 2006 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2006/01/26/more_advanced_perl.html/</guid>
      <description>

&lt;p&gt;Around Easter last year, I finished writing the second edition of &lt;a href=&#34;http://www.oreilly.com/catalog/advperl2/&#34;&gt;Advanced Perl Programming&lt;/a&gt;, a task that had been four years in the making. The aim of this new edition was to reflect the way that Perl programming had changed since the first edition. Much of what Sriram wrote in the original edition was still true, but to be honest, not too much of it was useful anymore&amp;ndash;the Perl world has changed dramatically since the original publication.&lt;/p&gt;

&lt;p&gt;The first edition was very much about how to do things yourself; it operated at a very low level by current Perl standards. With the explosion of CPAN modules in the interim, &amp;ldquo;advanced Perl programming&amp;rdquo; now consists of plugging all of the existing components together in the right order, rather than necessarily writing the components from scratch. So the nature of the book had to change a lot.&lt;/p&gt;

&lt;p&gt;However, CPAN is still expanding, and the Perl world continues to change; &lt;em&gt;Advanced Perl Programming&lt;/em&gt; can never be a finished book, but only a snapshot in time. On top of all that, I&amp;rsquo;ve been learning more, too, and discovering more tricks to get work done smarter and faster. Even during the writing of the book, some of the best practices changed and new modules were developed.&lt;/p&gt;

&lt;p&gt;The book is still, I believe, an excellent resource for learning how to master Perl programming, but here, if you like, I want to add to that resource. I&amp;rsquo;ll try to say something about the developments that have happened in each chapter of the book.&lt;/p&gt;

&lt;h3 id=&#34;advanced-perl&#34;&gt;Advanced Perl&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;m actually very happy with this chapter. The only thing I left out of the first chapter which may have been useful there is a section on &lt;code&gt;tie&lt;/code&gt;; but this is covered strongly in &lt;em&gt;Programming Perl&lt;/em&gt; anyway.&lt;/p&gt;

&lt;p&gt;On the other hand, although it&amp;rsquo;s not particularly advanced, one of the things I wish I&amp;rsquo;d written about in the book was best practices for creating object-oriented modules. My fellow O&amp;rsquo;Reilly author Damian Conway has already written two books about these topics, so, again, I didn&amp;rsquo;t get too stressed out about having to leave those sections out. That said, the two modules I would recommend for building OO classes don&amp;rsquo;t appear to get a mention in &lt;em&gt;Perl Best Practices&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;First, we all know it&amp;rsquo;s a brilliant idea to create accessors for our data members in a class; however, it&amp;rsquo;s also a pain in the neck to create them yourself. There seem to be hundreds of CPAN modules that automate the process for you, but the easiest is the &lt;a href=&#34;https://metacpan.org/pod/Class::Accessor&#34;&gt;&lt;code&gt;Class::Accessor&lt;/code&gt;&lt;/a&gt; module. With this module, you declare which accessors you want, and it will automatically create them. As a useful bonus, it creates a default &lt;code&gt;new()&lt;/code&gt; method for you if you don&amp;rsquo;t want to write one of those, either.&lt;/p&gt;

&lt;p&gt;Instead of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package MyClass;

sub new { bless { %{@_} }, shift; }

sub name {
    my $self = shift;
    if (@_) { $self-&amp;gt;{name} = shift; }
    $self-&amp;gt;{name}
}

sub address {
    my $self = shift;
    if (@_) { $self-&amp;gt;{address} = shift; }
    $self-&amp;gt;{address}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you can now say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package MyClass;
use base qw(Class::Accessor);

MyClass-&amp;gt;mk_accessors(qw( name address ));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Class::Accessor&lt;/code&gt; also contains methods for making read-only accessors and for creating separate read and write accessors, and everything is nicely overrideable. Additionally, there are subclasses that extend &lt;code&gt;Class::Accessor&lt;/code&gt; in various ways: &lt;a href=&#34;https://metacpan.org/pod/Class::Accessor::Fast&#34;&gt;&lt;code&gt;Class::Accessor::Fast&lt;/code&gt;&lt;/a&gt; trades off a bit of the extensibility for an extra speed boost, &lt;a href=&#34;https://metacpan.org/pod/Class::Accessor::Chained&#34;&gt;&lt;code&gt;Class::Accessor::Chained&lt;/code&gt;&lt;/a&gt; returns the object when called with parameters, and &lt;a href=&#34;https://metacpan.org/pod/Class::Accessor::Assert&#34;&gt;&lt;code&gt;Class::Accessor::Assert&lt;/code&gt;&lt;/a&gt; does rudimentary type checking on the parameter values. There are many, many modules on the CPAN that do this sort of thing, but this one is, in my opinion, the most flexible and simple.&lt;/p&gt;

&lt;p&gt;Speaking of flexibility, one way to encourage flexibility in your modules and applications is to make them pluggable&amp;ndash;that is, to allow other pieces of code to respond to actions that you define. &lt;a href=&#34;https://metacpan.org/pod/Module::Pluggable&#34;&gt;&lt;code&gt;Module::Pluggable&lt;/code&gt;&lt;/a&gt; is a simple but powerful little module that searches for installed modules in a given namespace. Here&amp;rsquo;s an example of its use in &lt;a href=&#34;https://metacpan.org/pod/Email::FolderType&#34;&gt;&lt;code&gt;Email::FolderType&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Module::Pluggable 
    search_path =&amp;gt; &amp;quot;Email::FolderType&amp;quot;, 
    require     =&amp;gt; 1, 
    sub_name    =&amp;gt; &#39;matchers&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This looks for all modules underneath the &lt;code&gt;Email::FolderType::&lt;/code&gt; namespace, &lt;code&gt;require&lt;/code&gt;s them, and assembles a list of their classes into the &lt;code&gt;matchers&lt;/code&gt; method. The module later determines the type of an email folder by passing it to each of the recognizers and seeing which of them handles it, with the moral equivalent of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub folder_type {
    my ($self, $folder) = @_;
    for my $class ($self-&amp;gt;matchers) {
        return $class if $class-&amp;gt;match($folder);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This means you don&amp;rsquo;t need to know, when you&amp;rsquo;re writing the code, what folder types you support; you can start off with no recognizers and add them later. If a new type of email folder comes along, the user can install a third-party module from CPAN that deals with it, and &lt;code&gt;Email::FolderType&lt;/code&gt; requires no additional coding to add support for it.&lt;/p&gt;

&lt;h3 id=&#34;parsing&#34;&gt;Parsing&lt;/h3&gt;

&lt;p&gt;Perhaps the biggest change of heart I had between writing a chapter and its publication was in the parsing chapter. That chapter had very little about parsing HTML, and what it did have was not very friendly. Since then, Gisle Aas and Sean Burke&amp;rsquo;s &lt;a href=&#34;https://metacpan.org/pod/HTML::TreeBuilder&#34;&gt;&lt;code&gt;HTML::TreeBuilder&lt;/code&gt;&lt;/a&gt; and the corresponding &lt;a href=&#34;https://metacpan.org/pod/XML::TreeBuilder&#34;&gt;&lt;code&gt;XML::TreeBuilder&lt;/code&gt;&lt;/a&gt; have established themselves as much simpler and more flexible ways to navigate HTML and XML documents.&lt;/p&gt;

&lt;p&gt;The basic concept in &lt;code&gt;HTML::TreeBuilder&lt;/code&gt; is the HTML element, represented as an object of the &lt;code&gt;HTML::Element&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$a = HTML::Element-&amp;gt;new(&#39;a&#39;, href =&amp;gt; &#39;http://www.perl.com/&#39;);
$html = $a-&amp;gt;as_HTML;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This creates a new element that is an anchor tag, with an &lt;code&gt;href&lt;/code&gt; attribute. The HTML equivalent in &lt;code&gt;$html&lt;/code&gt; would be &lt;code&gt;&amp;lt;a href=&amp;quot;http://www.perl.com&amp;quot;/&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now you can add some content to that tag:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$a-&amp;gt;push_content(&amp;quot;The Perl Homepage&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This time, the object represents &lt;code&gt;&amp;lt;a href=&amp;quot;http://www.perl.com&amp;quot;&amp;gt; The Perl Homepage &amp;lt;/a&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can ask this element for its tag, its attributes, its content, and so on:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$tag = $a-&amp;gt;tag;
$link = $a-&amp;gt;attr(&amp;quot;href&amp;quot;);
@content = $a-&amp;gt;content_list; # More HTML::Element nodes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, when you are parsing HTML, you won&amp;rsquo;t be creating those elements manually. Instead, you&amp;rsquo;ll be navigating a tree of them, built out of your HTML document. The top-level module &lt;code&gt;HTML::TreeBuilder&lt;/code&gt; does this for you:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use HTML::TreeBuilder;
my $tree = HTML::TreeBuilder-&amp;gt;new();
$tree-&amp;gt;parse_file(&amp;quot;index.html&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now &lt;code&gt;$tree&lt;/code&gt; is a &lt;code&gt;HTML::Element&lt;/code&gt; object representing the &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; tag and all its contents. You can extract all of the links with the &lt;code&gt;extract_links()&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (@{ $tree-&amp;gt;extract_links() || [] }) {
     my($link, $element, $attr, $tag) = @$_;
     print &amp;quot;Found link to $link in $tag\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although the real workhorse of this module is the &lt;code&gt;look_down()&lt;/code&gt; method, which helps you pull elements out of the tree by their tags or attributes. For instance, in a search engine indexer, indexing HTML files, I have the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for my $tag ($tree-&amp;gt;look_down(&amp;quot;_tag&amp;quot;,&amp;quot;meta&amp;quot;)) {
    next unless $tag-&amp;gt;attr(&amp;quot;name&amp;quot;);
    $hash{$tag-&amp;gt;attr(&amp;quot;name&amp;quot;)} .= $tag-&amp;gt;attr(&amp;quot;content&amp;quot;). &amp;quot; &amp;quot;;
}

$hash{title} .= $_-&amp;gt;as_text.&amp;quot; &amp;quot; for $tree-&amp;gt;look_down(&amp;quot;_tag&amp;quot;,&amp;quot;title&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This finds all &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; tags and puts their attributes as name-value pairs in a hash; then it puts all the text inside of &lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; tags together into another hash element. Similarly, you can look for tags by attribute value, spit out sub-trees as HTML or as text, and much more, besides. For reaching into HTML text and pulling out just the bits you need, I haven&amp;rsquo;t found anything better.&lt;/p&gt;

&lt;p&gt;On the XML side of things, &lt;a href=&#34;https://metacpan.org/pod/XML::Twig&#34;&gt;&lt;code&gt;XML::Twig&lt;/code&gt;&lt;/a&gt; has emerged as the usual &amp;ldquo;middle layer,&amp;rdquo; when &lt;a href=&#34;https://metacpan.org/pod/XML::Simple&#34;&gt;&lt;code&gt;XML::Simple&lt;/code&gt;&lt;/a&gt; is too simple and &lt;a href=&#34;https://metacpan.org/pod/XML::Parser&#34;&gt;&lt;code&gt;XML::Parser&lt;/code&gt;&lt;/a&gt; is, well, too much like hard work.&lt;/p&gt;

&lt;h3 id=&#34;templating&#34;&gt;Templating&lt;/h3&gt;

&lt;p&gt;There&amp;rsquo;s not much to say about templating, although in retrospect, I would have spent more of the paper expended on &lt;a href=&#34;https://metacpan.org/pod/HTML::Mason&#34;&gt;&lt;code&gt;HTML::Mason&lt;/code&gt;&lt;/a&gt; talking about the &lt;a href=&#34;http://www.template-toolkit.org/&#34;&gt;Template Toolkit&lt;/a&gt; instead. Not that there&amp;rsquo;s anything wrong with &lt;code&gt;HTML::Mason&lt;/code&gt;, but the world seems to be moving away from templates that include code in a specific language (say, Perl&amp;rsquo;s) towards separate templating little languages, like &lt;a href=&#34;https://metacpan.org/pod/Template::TAL&#34;&gt;TAL&lt;/a&gt; and Template Toolkit.&lt;/p&gt;

&lt;p&gt;The only thing to report is that Template Toolkit finally received a bit of attention from its maintainer a couple of months ago, but the long-awaited Template Toolkit 3 is looking as far away as, well, Perl 6.&lt;/p&gt;

&lt;h3 id=&#34;natural-language-processing&#34;&gt;Natural Language Processing&lt;/h3&gt;

&lt;p&gt;Who would have thought that the big news of 2005 would be that Yahoo is relevant again? Not only are they coming up with interesting new search technologies such as Y!Q, but they&amp;rsquo;re releasing a lot of the guts behind what they&amp;rsquo;re doing as public APIs. One of those that is particularly relevant for NLP is the &lt;a href=&#34;http://developer.yahoo.net/search/content/V1/termExtraction.html&#34;&gt;Term Extraction web service&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This takes a chunk of text and pulls out the distinctive terms and phrases. Think of this as a step beyond something like &lt;a href=&#34;https://metacpan.org/pod/Lingua::EN::Keywords&#34;&gt;&lt;code&gt;Lingua::EN::Keywords&lt;/code&gt;&lt;/a&gt;, with the firepower of Yahoo behind it. To access the API, simply send a HTTP &lt;code&gt;POST&lt;/code&gt; request to a given URL:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use LWP::UserAgent;
use XML::Twig;
my $uri  = &amp;quot;http://api.search.yahoo.com/ContentAnalysisService/V1/termExtraction&amp;quot;;
my $ua   = LWP::UserAgent-&amp;gt;new();
my $resp = $ua-&amp;gt;post($uri, {
    appid   =&amp;gt; &amp;quot;PerlYahooExtractor&amp;quot;,
    context =&amp;gt; &amp;lt;&amp;lt;EOF
Two Scottish towns have seen the highest increase in house prices in the
UK this year, according to new figures. 
Alexandria in West Dunbartonshire and Coatbridge in North Lanarkshire
both saw an average 35% rise in 2005. 
EOF
});
if ($resp-&amp;gt;is_success) { 
    my $xmlt = XML::Twig-&amp;gt;new( index =&amp;gt; [ &amp;quot;Result&amp;quot; ]);
    $xmlt-&amp;gt;parse($resp-&amp;gt;content);
    for my $result (@{ $xmlt-&amp;gt;index(&amp;quot;Result&amp;quot;) || []}) {
        print $result-&amp;gt;text;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This produces:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;north lanarkshire
scottish towns
west dunbartonshire
house prices
coatbridge
dunbartonshire
alexandria
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once I had informed the London Perl Mongers of this amazing discovery, Simon Wistow immediately bundled it up into a Perl module called &lt;a href=&#34;https://metacpan.org/pod/Lingua::EN::Keywords::Yahoo&#34;&gt;&lt;code&gt;Lingua::EN::Keywords::Yahoo&lt;/code&gt;&lt;/a&gt;, coming soon to a CPAN mirror near you.&lt;/p&gt;

&lt;h3 id=&#34;unicode&#34;&gt;Unicode&lt;/h3&gt;

&lt;p&gt;The best news about Unicode over the last year is that you should not have noticed any major changes. By now, the core Unicode support in Perl just works, and most of the CPAN modules that deal with external data have been updated to work with Unicode.&lt;/p&gt;

&lt;p&gt;If you don&amp;rsquo;t see or hear anything about Unicode, that&amp;rsquo;s a good thing: it means it&amp;rsquo;s all working properly.&lt;/p&gt;

&lt;h3 id=&#34;poe&#34;&gt;POE&lt;/h3&gt;

&lt;p&gt;The chapter on POE was a great introduction to how POE works and some of the things that you can do with it, but it focused on using POE for networking applications and for daemons. This is only half the story. Recently a lot of interest has centered on using POE for graphical and command-line applications: Randal Schwartz takes over from the RSS aggregator at the end of the chapter by integrating it with a graphical interface in &amp;ldquo;&lt;a href=&#34;http://www.stonehenge.com/merlyn/PerlJournal/col11.html&#34;&gt;Graphical interaction with POE and Tk&lt;/a&gt;.&amp;rdquo; Here, I want to consider command-line applications.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://metacpan.org/pod/Term::Visual&#34;&gt;&lt;code&gt;Term::Visual&lt;/code&gt;&lt;/a&gt; module is a POE component for creating applications with a split-screen interface; at the bottom of the interface, you type your input, and the output appears above a status line. The module handles all of the history, status bar updates, and everything else for you. Here&amp;rsquo;s an application that uses &lt;a href=&#34;https://metacpan.org/pod/Chatbot::Eliza&#34;&gt;&lt;code&gt;Chatbot::Eliza&lt;/code&gt;&lt;/a&gt; to provide therapeutic session with everyone&amp;rsquo;s favorite digital psychiatrist.&lt;/p&gt;

&lt;p&gt;First, set up the chatbot and create a new &lt;code&gt;Term::Visual&lt;/code&gt; object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/perl -w
use POE;
use POSIX qw(strftime);
use Term::Visual;
use Chatbot::Eliza;
my $eliza = Chatbot::Eliza-&amp;gt;new();
my $vt    = Term::Visual-&amp;gt;new( Alias =&amp;gt; &amp;quot;interface&amp;quot; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now create the window, which will have space on its status bar for a clock:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $window_id = $vt-&amp;gt;create_window(
   Status =&amp;gt; { 0 =&amp;gt; { format =&amp;gt; &amp;quot;[%8.8s]&amp;quot;, fields =&amp;gt; [&amp;quot;time&amp;quot;] } },
   Title =&amp;gt; &amp;quot;Eliza&amp;quot; 
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You also need a &lt;a href=&#34;https://metacpan.org/pod/POE::Session&#34;&gt;&lt;code&gt;POE::Session&lt;/code&gt;&lt;/a&gt;, which will do all the work. It will have three states; the first is the &lt;code&gt;_start&lt;/code&gt; state, to tell &lt;code&gt;Term::Visual&lt;/code&gt; what to do with any input it gets from the keyboard and to update the clock:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;POE::Session-&amp;gt;create
(inline_states =&amp;gt;
  { _start          =&amp;gt; sub {
        $_[KERNEL]-&amp;gt;post( interface =&amp;gt; send_me_input =&amp;gt; &amp;quot;got_term_input&amp;quot; );
        $_[KERNEL]-&amp;gt;yield( &amp;quot;update_time&amp;quot; );
    },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Updating the clock is simply a matter of setting the &lt;code&gt;time&lt;/code&gt; field declared earlier to the current time, and scheduling another update at the top of the next minute:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    update_time     =&amp;gt; sub {
        $vt-&amp;gt;set_status_field( $window_id,
                               time =&amp;gt; strftime(&amp;quot;%I:%M %p&amp;quot;, localtime) );
        $_[KERNEL]-&amp;gt;alarm( update_time =&amp;gt; int(time() / 60) * 60 + 60 );
    },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, you need to handle the input from the user. Do that in a separate subroutine to make things a big clearer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    got_term_input  =&amp;gt; \&amp;amp;handle_term_input,
  }
);

$poe_kernel-&amp;gt;run();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When &lt;code&gt;Term::Visual&lt;/code&gt; gets a line of text from the user, it passes it to the state declared in the &lt;code&gt;_start&lt;/code&gt; state. The code takes that text, prints it to the terminal as an echo, and then passes it through Eliza:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub handle_term_input {
  my ($heap, $input) = @_[HEAP, ARG0];
  if ($input =~ m{^/quit}i) {
    $vt-&amp;gt;delete_window($window_id); 
    exit;
  }

  $vt-&amp;gt;print($window_id, &amp;quot;&amp;gt; $input&amp;quot;);
  $vt-&amp;gt;print($window_id, $eliza-&amp;gt;transform($input));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In just a few lines of code you have a familiar interface, similar to many IRC or MUD clients, with POE hiding all of the event handling away.&lt;/p&gt;

&lt;h3 id=&#34;testing&#34;&gt;Testing&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Advanced Perl Programming&lt;/em&gt; showed how to write tests so that we all can be more sure that our code is doing what it should. How do you know your tests are doing enough? Enter Paul Johnson&amp;rsquo;s &lt;a href=&#34;https://metacpan.org/pod/Devel::Cover&#34;&gt;&lt;code&gt;Devel::Cover&lt;/code&gt;&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Devel::Cover&lt;/code&gt; makes a record of each time a Perl operation or statement is executed, and then compares this against the statements in your code. So when you&amp;rsquo;re running your tests, you can see which of the code paths in your module get exercised and which don&amp;rsquo;t; if you have big branches of code that never get tested, maybe you should write more tests for them!&lt;/p&gt;

&lt;p&gt;To use it on an uninstalled module:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cover -delete
$ HARNESS_PERL_SWITCHES=-MDevel::Cover make test
$ cover
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will give you a textual summary of code coverage; &lt;code&gt;cover -report html&lt;/code&gt; produces a colorized, navigable hypertext summary, useful for showing to bosses.&lt;/p&gt;

&lt;p&gt;This ensures that your code works&amp;ndash;or at least, that it does what your tests specify. The next step is to ensure that your code is actually of relatively decent quality. Because &amp;ldquo;quality&amp;rdquo; is a subjective metric when it comes to the art of programming, Perl folk have introduced the objective of &amp;ldquo;Kwalitee&amp;rdquo; instead, which may or may not have any bearing on quality.&lt;/p&gt;

&lt;p&gt;All modules on CPAN have their Kwalitee measured as part of the &lt;a href=&#34;http://cpants.dev.zsi.at/&#34;&gt;CPANTS&lt;/a&gt; (CPAN Testing Service) website. One way to test for and increase your Kwalitee is to use the &lt;a href=&#34;https://metacpan.org/pod/Module::Build::Kwalitee&#34;&gt;&lt;code&gt;Module::Build::Kwalitee&lt;/code&gt;&lt;/a&gt; module; this copies some boilerplate tests into your distribution that ensure that you have adequate and syntactically correct documentation, that you &lt;code&gt;use strict&lt;/code&gt; and &lt;code&gt;warnings&lt;/code&gt;, and so on.&lt;/p&gt;

&lt;p&gt;All of this ought to go a fair way to improving the Kwalitee of your code, if not its actual quality!&lt;/p&gt;

&lt;h3 id=&#34;inline&#34;&gt;Inline&lt;/h3&gt;

&lt;p&gt;One of the things that has come over into Perl 5 from Perl 6 development is the concept of the Native Call Interface (NCI). This hasn&amp;rsquo;t fully been developed yet, but chromatic (yes, the editor of this very site) has been working on it.&lt;/p&gt;

&lt;p&gt;The idea is that, instead of having something like Inline or XS that creates a &amp;ldquo;buffer&amp;rdquo; between Perl and C libraries, you just call those libraries directly. At the moment, you need to compile any XS module against the library you&amp;rsquo;re using. This is particularly awkward for folk on cut-down operating systems that do not ship a compiler, such as Palm OS or Windows.&lt;/p&gt;

&lt;p&gt;The strength of NCI is that it doesn&amp;rsquo;t require a compiler; instead, it uses the operating system&amp;rsquo;s normal means of making calls into libraries. (Hence &amp;ldquo;Native Call.&amp;rdquo;) It uses Perl&amp;rsquo;s &lt;code&gt;DynaLoader&lt;/code&gt; to find libraries, load them, and then find the address of symbols inside of the library. Then it calls a generic &amp;ldquo;thunk&amp;rdquo; function to turn the symbol&amp;rsquo;s address into a call. For instance:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $lib = P5NCI::Library-&amp;gt;new( library =&amp;gt; &#39;nci_test&#39;, package =&amp;gt; &#39;NCI&#39; );
$lib-&amp;gt;install_function( &#39;double_int&#39;, &#39;ii&#39; );

my $two = NCI::double_int( 1 );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These lines find the &lt;code&gt;nci_test&lt;/code&gt; shared library and get ready to put its functions into the &lt;code&gt;NCI&lt;/code&gt; namespace. It then installs the function &lt;code&gt;double_int&lt;/code&gt;, which is of signature &lt;code&gt;int double_int(int)&lt;/code&gt; (hence &lt;code&gt;ii&lt;/code&gt;). Once this is done, you can call the function from Perl. It&amp;rsquo;s not much trickier than Inline, but without the intermediate step of compilation.&lt;/p&gt;

&lt;p&gt;NCI isn&amp;rsquo;t quite there yet, and it only supports very simple function signatures. However, because of its portability, it&amp;rsquo;s definitely the one to watch for Perl-C interfaces in the future.&lt;/p&gt;

&lt;h3 id=&#34;everything-else&#34;&gt;Everything Else&lt;/h3&gt;

&lt;p&gt;The last chapter is &amp;ldquo;Fun with Perl.&amp;rdquo; Now, much has happened in the world of Perl fun, but much has happened all over Perl. There were many other things I wanted to write about, as well: CPAN best practices for date/time handling and email handling, Perl 6 and Pugs, the very latest web application frameworks such as Catalyst and Jifty, and so on. But all these would fill another book&amp;ndash;and if I ever finished that, it too would require an update like this one. So I hope this is enough for you to be getting on with!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Analyzing HTML with Perl</title>
      <link>http://localhost:1313/pub/2006/01/19/analyzing_html.html/</link>
      <pubDate>Thu, 19 Jan 2006 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2006/01/19/analyzing_html.html/</guid>
      <description>

&lt;p&gt;Routine work is all around us every day, no matter if you like it or not. For a teacher on computing subjects, grading assignments can be such work. Certain computing assignments aim at practicing operating skills rather than creativity, especially in elementary courses. Grading this kind of assignment is time-consuming and repetitive, if not tedious.&lt;/p&gt;

&lt;p&gt;In a business information system course that I taught, one lesson was about writing web pages. As the course was the first computing subject for the students, we used &lt;a href=&#34;http://www.nvu.com/&#34;&gt;Nvu&lt;/a&gt;, a WYSIWYG web page editor, rather than coding the HTML. One class assignment required writing three or more inter-linked web pages containing a list of HTML elements.&lt;/p&gt;

&lt;p&gt;Write three or more web pages having the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Italicized text (2 points)&lt;/li&gt;
&lt;li&gt;Bolded text (2 points)&lt;/li&gt;
&lt;li&gt;Three different colors of text (5 points)&lt;/li&gt;
&lt;li&gt;Three different sizes of text (5 points)&lt;/li&gt;
&lt;li&gt;Linked graphics with border (5 points)&lt;/li&gt;
&lt;li&gt;Linked graphics without border (5 points)&lt;/li&gt;
&lt;li&gt;Non-linked graphics with border (3 points)&lt;/li&gt;
&lt;li&gt;Non-linked graphics without border (2 points)&lt;/li&gt;
&lt;li&gt;Three external links (5 points)&lt;/li&gt;
&lt;li&gt;One horizontal line&amp;ndash;not full width of page (5 points)&lt;/li&gt;
&lt;li&gt;Three internal links to other pages (10 points)&lt;/li&gt;
&lt;li&gt;Two tables (10 points)&lt;/li&gt;
&lt;li&gt;One bulleted list (5 points)&lt;/li&gt;
&lt;li&gt;One numerical list (5 points)&lt;/li&gt;
&lt;li&gt;Non-default text color (5 points)&lt;/li&gt;
&lt;li&gt;Non-default link color (2 points)&lt;/li&gt;
&lt;li&gt;Non-default active link color (2 points)&lt;/li&gt;
&lt;li&gt;Non-default visited link color (2 points)&lt;/li&gt;
&lt;li&gt;Non-default background color (5 points)&lt;/li&gt;
&lt;li&gt;A background image (5 points)&lt;/li&gt;
&lt;li&gt;Pleasant appearance in the pages (10 points)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Beginning to grade the students&amp;rsquo; work, I found it monotonous and error-prone. Because the HTML elements could be in any of the pages, I had to jump to every page and count the HTML elements in question. I also needed to do it for each element in the requirement. While some occurrences were easy to spot in the rendered pages in a browser, others required close examination of the HTML code. For example, a student wrote a horizontal line (&lt;code&gt;&amp;lt;hr&amp;gt;&lt;/code&gt; element) extending 98 percent of the width of the window, which was difficult to differentiate visually from a full-width horizontal line. Some other students just liked to use black and dark gray as two different colors in different parts of the pages. In addition to locating the elements, awarding and totaling marks were also error-prone.&lt;/p&gt;

&lt;p&gt;I felt a little regret on the flexibility in the requirement. If I had fixed the file names of the pages and assigned the HTML elements to individual pages, grading could have been easier. Rather than continuing the work with regret, I wrote a Perl program to grade the assignments. The program essentially parses the web pages, awards marks according to the requirements, writes basic comments, and calculates the total score.&lt;/p&gt;

&lt;h3 id=&#34;processing-html-with-perl&#34;&gt;Processing HTML with Perl&lt;/h3&gt;

&lt;p&gt;Perl&amp;rsquo;s regular expressions have excellent text processing capability and there are handy modules for parsing web pages. The module &lt;a href=&#34;https://metacpan.org/pod/HTML::TreeBuilder&#34;&gt;&lt;code&gt;HTML::TreeBuilder&lt;/code&gt;&lt;/a&gt; provides a HTML parser that builds a tree structure of the elements in a web page. It is easy to create a tree and build its content from a HTML file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$tree = HTML::TreeBuilder-&amp;gt;new;
$tree-&amp;gt;parse_file($file_name);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nodes in the tree are &lt;a href=&#34;https://metacpan.org/pod/HTML::Element&#34;&gt;&lt;code&gt;HTML::Element&lt;/code&gt;&lt;/a&gt; objects. There are plenty of methods with which to access and manipulate elements in the tree. When you finish using the tree, destroy it and free the memory it occupied:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$tree-&amp;gt;delete;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The module &lt;code&gt;HTML::Element&lt;/code&gt; represents HTML elements in tree structures created by &lt;code&gt;HTML::TreeBuilder&lt;/code&gt;. It has a huge number of methods for accessing and manipulating the element and searching for descendants down the tree or ancestors up the tree. The method &lt;code&gt;find()&lt;/code&gt; retrieves all descending elements with one or more specified tag names. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@elements = $element-&amp;gt;find(&#39;a&#39;, &#39;img&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;stores all &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; elements at or under &lt;code&gt;$element&lt;/code&gt; to the array &lt;code&gt;@elements&lt;/code&gt;. The method &lt;code&gt;look_down()&lt;/code&gt; is a more powerful version of &lt;code&gt;find()&lt;/code&gt;. It selects descending elements by three kinds of criteria: exactly specifying an attribute&amp;rsquo;s value or a tag name, matching an attribute&amp;rsquo;s value or tag name by a regular expression, and applying a subroutine that returns true on examining desired elements. Here are some examples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@anchors = $element-&amp;gt;look_down(&#39;_tag&#39; =&amp;gt; &#39;a&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;retrieves all &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; elements at or under &lt;code&gt;$element&lt;/code&gt; and stores them to the array &lt;code&gt;@anchors&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@colors = $element-&amp;gt;look_down(&#39;style&#39; =&amp;gt; qr/color/);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;selects all elements at or under &lt;code&gt;$element&lt;/code&gt; having a &lt;code&gt;style&lt;/code&gt; attribute value that contains &lt;code&gt;color&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@largeimages = $element-&amp;gt;look_down(
    sub {
         $_[0]-&amp;gt;tag() eq &#39;img&#39;          and
        ($_[0]-&amp;gt;attr(&#39;width&#39;) &amp;gt; 100 or
         $_[0]-&amp;gt;attr(&#39;height&#39;)  &amp;gt; 100)
    }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;locates at or under &lt;code&gt;$element&lt;/code&gt; all images (&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; elements) with widths or heights larger than 100 pixels. Note that this code will produce a warning message on encountering an &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; element that has no &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;height&lt;/code&gt; attribute.&lt;/p&gt;

&lt;p&gt;You can also mix the three kinds of criteria into one invocation of &lt;code&gt;look_down&lt;/code&gt;. The last example could also be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@largeimages = $element-&amp;gt;look_down(
    &#39;_tag&#39;   =&amp;gt; &#39;img&#39;,
    &#39;width&#39;  =&amp;gt; qr//,
    &#39;height&#39; =&amp;gt; qr//,
    sub { $_[0]-&amp;gt;attr(&#39;width&#39;)  &amp;gt; 100 or
          $_[0]-&amp;gt;attr(&#39;height&#39;) &amp;gt; 100 }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code also caters for any missing &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;height&lt;/code&gt; attribute in an &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; element. The parameters &lt;code&gt;&#39;width&#39; =&amp;gt; qr//&lt;/code&gt; and &lt;code&gt;&#39;height&#39; =&amp;gt; qr//&lt;/code&gt; guarantee selection of only those &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; elements that have both &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;height&lt;/code&gt; attributes. The code block checks these for the attribute values, when invoked.&lt;/p&gt;

&lt;p&gt;The method &lt;code&gt;look_up()&lt;/code&gt; looks for ancestors from an element by the same kinds of criteria of &lt;code&gt;look_down()&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;processing-multiple-files&#34;&gt;Processing Multiple Files&lt;/h3&gt;

&lt;p&gt;These methods provide great HTML parsing capability to grade the web page assignments. The grading program first builds the tree structures from the HTML files and stores them in an array &lt;code&gt;@trees&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my @trees;
foreach (@files) {
    print &amp;quot;  building tree for $_ ...\n&amp;quot; if $options{v};
    my $tree = HTML::TreeBuilder-&amp;gt;new;
    $tree-&amp;gt;parse_file($_);
    push( @trees, $tree );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The subroutine &lt;code&gt;doitem()&lt;/code&gt; iterates through the array of trees, applying a pass-in code block to look for particular HTML elements in each tree and accumulating the results of calling the code block. To provide detailed information and facilitate debugging during development, it calls the convenience subroutine &lt;code&gt;printd()&lt;/code&gt; to display the HTML elements found with their corresponding file name when the verbose command line switch (&lt;code&gt;-v&lt;/code&gt;) is set. Essentially, the code invokes this subroutine once for each kind of element in the requirement.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub doitem {
    my $func = shift;
    my $num  = 0;
    foreach my $i ( 0 .. $#files ) {
        my @elements = $func-&amp;gt;( $files[$i], $trees[$i] );
        printd $files[$i], @elements;
        $num += @elements;
    }
    return $num;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code block passed into &lt;code&gt;doitem&lt;/code&gt; is a subroutine that takes two parameters of a file name and its corresponding HTML tree and returns an array of selected elements in the tree. The following code block retrieves all HTML elements in italic, including the &lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt; elements (for example, &lt;code&gt;&amp;lt;i&amp;gt;text&amp;lt;/i&amp;gt;&lt;/code&gt;) and elements with a &lt;code&gt;font-style&lt;/code&gt; of &lt;code&gt;italic&lt;/code&gt; (for example, &lt;code&gt;&amp;lt;span STYLE=&amp;quot;font-style: italic&amp;quot;&amp;gt;text&amp;lt;/span&amp;gt;&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$n = doitem sub {
    my ( $file, $tree ) = @_;
    return ( $tree-&amp;gt;find(&amp;quot;i&amp;quot;),
        $tree-&amp;gt;look_down( &amp;quot;style&amp;quot; =&amp;gt; qr/font-style *: *italic/ ) );
    };

marking &amp;quot;Italicized text (2 points): &amp;quot;
  . ( ( $n &amp;gt; 0 ) ? &amp;quot;good. 2&amp;quot; : &amp;quot;no italic text. 0&amp;quot;
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Two points are available for any italic text in the pages. The &lt;code&gt;marking&lt;/code&gt; subroutine records grading in a string. At the end of the program, examining the string helps to calculate the total points.&lt;/p&gt;

&lt;p&gt;Other requirements are marked in the same manner, though some selection code is more involved. A regular expression helps to select elements with non-default colors.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $pattern = qr/(^|[^-])color *: *rgb\( *[0-9]*, *[0-9]*, *[0-9]*\)/;
return $tree-&amp;gt;look_down(
    &amp;quot;style&amp;quot; =&amp;gt; $pattern,
    sub { $_[0]-&amp;gt;as_trimmed_text ne &amp;quot;&amp;quot; }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nvu applies colors to text by the &lt;code&gt;color&lt;/code&gt; style in the form of &lt;code&gt;rgb(R,G,B)&lt;/code&gt; (for example, &lt;code&gt;&amp;lt;span STYLE=&amp;quot;color: rgb(0, 0, 255);&amp;quot;&amp;gt;text&amp;lt;/span&amp;gt;&lt;/code&gt;). The above code is slightly stricter than the italic code, as it also requires an element to contain some text. The method &lt;code&gt;as_trimmed_text()&lt;/code&gt; of &lt;code&gt;HTML::Element&lt;/code&gt; returns the textual content of an element with any leading and trailing spaces removed.&lt;/p&gt;

&lt;p&gt;Nested invocations of &lt;code&gt;look_down()&lt;/code&gt; locate linked graphics with a border. This selects any link (an &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; element) that encloses an image (an &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; element) that has a border.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return $tree-&amp;gt;look_down(
    &amp;quot;_tag&amp;quot; =&amp;gt; &amp;quot;a&amp;quot;,
    sub {
       $_[0]-&amp;gt;look_down( &amp;quot;_tag&amp;quot; =&amp;gt; &amp;quot;img&amp;quot;, sub { hasBorder( $_[0] ) } );
    }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finding non-linked graphics is more interesting, as it involves both the methods &lt;code&gt;look_down()&lt;/code&gt; and &lt;code&gt;look_up()&lt;/code&gt;. It should only find images (&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; elements) that do not have a parent link (a &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; element) up the tree.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return $tree-&amp;gt;look_down(
    &amp;quot;_tag&amp;quot; =&amp;gt; &amp;quot;img&amp;quot;,
    sub { !$_[0]-&amp;gt;look_up( &amp;quot;_tag&amp;quot; =&amp;gt; &amp;quot;a&amp;quot; ) and hasBorder( $_[0] ); }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Checking valid internal links requires passing &lt;code&gt;look_down()&lt;/code&gt; a code block that excludes common external links by checking the &lt;code&gt;href&lt;/code&gt; value against protocol names, and verifies the existence of the file linked in the web page.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use File::Basename;
$n = doitem sub {
    my ( $file, $tree ) = @_;
    return $tree-&amp;gt;look_down(
        &amp;quot;_tag&amp;quot; =&amp;gt; &amp;quot;a&amp;quot;,
        &amp;quot;href&amp;quot; =&amp;gt; qr//,
        sub {
            !( $_[0]-&amp;gt;attr(&amp;quot;href&amp;quot;) =~ /^ *(http:|https:|ftp:|mailto:)/)
            and -e dirname($file) . &amp;quot;/&amp;quot; . decodeURL( $_[0]-&amp;gt;attr(&amp;quot;href&amp;quot;) );
        }
    );
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nvu changes a page&amp;rsquo;s text color by specifying the color components in the style of the &lt;code&gt;body&lt;/code&gt; tag, like &lt;code&gt;&amp;lt;body style=&amp;quot;color: rgb(0, 0, 255);&amp;quot;&amp;gt;&lt;/code&gt;. A regular expression matches the style pattern and retrieves the three color components. Any non-zero color component denotes a non-default text color in a page.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $pattern = qr/(?:^|[^-])color *: *rgb\(( *[0-9]*),( *[0-9]*),( *[0-9]*)\)/;
return $tree-&amp;gt;look_down(
    &amp;quot;_tag&amp;quot;  =&amp;gt; &amp;quot;body&amp;quot;,
    &amp;quot;style&amp;quot; =&amp;gt; qr//,
    sub {
        $_[0]-&amp;gt;attr(&amp;quot;style&amp;quot;) =~ $pattern and
        ( $1 != 0 or $2 != 0 or $3 != 0 );
    }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With proper use of the methods &lt;code&gt;look_down()&lt;/code&gt;, &lt;code&gt;look_up()&lt;/code&gt;, and &lt;code&gt;as_trimmed_text()&lt;/code&gt;, the code can locate and mark the existence of various required elements and any broken elements (images, internal links, or background images).&lt;/p&gt;

&lt;h3 id=&#34;finishing-up&#34;&gt;Finishing Up&lt;/h3&gt;

&lt;p&gt;The final requirement of the assignment is a pleasant look of the rendered pages. Unfortunately, &lt;code&gt;HTML::TreeBuilder&lt;/code&gt; and its related modules do not analyze and quantify the visual appearance of a web page. Neither does any module that I know. OK, I would award marks for the appearance myself but still want Perl to help in the process&amp;ndash;the program sets the default score and comment, and allows overriding them in flexible way. By using alternative regular expressions, I can accept the default, override the score only, or override both the score and comment.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $input = &amp;quot;&amp;quot;;
do {
    print &amp;quot;$str1 [$str2]: &amp;quot;;
    $input = &amp;lt;STDIN&amp;gt;;
    $input =~ s/(^\s+|\s+$)//g;
} until ( $input =~ /(.*\.\s+\d+$|^\s*$|^\d+$)/ );

$input = $str2 if $input eq &amp;quot;&amp;quot;;
if ( $input =~ /^\d+$/ ) {
    $n = $input;
    if ( $n == 10 ) {
        $input = &amp;quot;good looking, nice content. $n&amp;quot;;
    }
    else {
        ( $input = $str2 ) =~ s/(\.\s*)\d+\s*$/$1$n/;
    }
}
marking &amp;quot;$str1 $input&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, the code examines the marking text string containing comments and scores for each requirement to calculate the total score of the assignment. Each line in that string is in a fixed format (for example, &lt;code&gt;&amp;quot;Italicized text (2 points): good. 0&amp;quot;&lt;/code&gt;). Again, regular expressions retrieve and accumulate the maximum and awarded points.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my ( $total, $score ) = ( 0, 0 );
while ( $marktext =~ /.*?\((\d+)\s+points\).*?\.\s+(\d+)/g )
{
    $total += $1;
    $score += $2;
}
marking &amp;quot;Total ($total points): $score&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Depending on the command-line switches, the program may start a browser to show the first page so that I can look at the pages&amp;rsquo; appearance. It can also optionally write the grading comments and score to a text file which can be feedback for the student.&lt;/p&gt;

&lt;p&gt;I can simply run the program in the directory containing the HTML files, or specify the set of HTML files in the command-line arguments. In the best case, I just let it grade the requirements and press &lt;code&gt;Enter&lt;/code&gt; to accept the default marking for the appearance, and then jot down the total score and email the grading text file to the student.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;I did not evaluate the time saved by the program against its developing effort. Anyway, the program makes the grading process more accurate and less prone to error, and it is more fun to spend time writing a Perl program and getting familiar with useful modules.&lt;/p&gt;

&lt;p&gt;In fact, there are many other modules that could have been used in the program to provide even more automation. Had I read Wasserman&amp;rsquo;s article &amp;ldquo;&lt;a href=&#34;http://localhost:1313/pub/2005/04/21/win32ole.html&#34;&gt;Automating Windows Applications with Win32::OLE&lt;/a&gt;,&amp;rdquo; the program would record the final score to an Excel file automatically. In addition, networking modules such as &lt;a href=&#34;https://metacpan.org/pod/Mail::Internet&#34;&gt;&lt;code&gt;Mail::Internet&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://metacpan.org/pod/Mail::Mailer&#34;&gt;&lt;code&gt;Mail::Mailer&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&#34;https://metacpan.org/pod/Mail::Folder&#34;&gt;&lt;code&gt;Mail::Folder&lt;/code&gt;&lt;/a&gt; could retrieve the assignment files from emails and send the feedback files to the students directly from the program.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

