<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Geoff Broadwell on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/geoff-broadwell/</link>
    <description>Recent content in Geoff Broadwell on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 29 Dec 2004 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/geoff-broadwell/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Building a 3D Engine in Perl, Part 2</title>
      <link>http://localhost:1313/pub/2004/12/29/3d_engine.html/</link>
      <pubDate>Wed, 29 Dec 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/12/29/3d_engine.html/</guid>
      <description>

&lt;p&gt;This article is the second in a &lt;a href=&#34;http://localhost:1313/authors/geoff-broadwell&#34;&gt;series&lt;/a&gt; aimed at building a full 3D engine in Perl. The first article, &lt;a href=&#34;http://localhost:1313/pub/2004/12/01/3d_engine.html&#34;&gt;Building a 3D Engine in Perl&lt;/a&gt;, covered basic program structure, opening an OpenGL window using SDL, basic projection and viewing setup, simple object rendering, object transformations, and depth ordering using the OpenGL depth buffer.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: see also the rest of the series, &lt;a href=&#34;http://localhost:1313/pub/2005/02/17/3d_engine.html&#34;&gt;lighting and movement&lt;/a&gt;, and &lt;a href=&#34;http://localhost:1313/pub/2005/08/04/3d_engine.html&#34;&gt;profiling your application&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This time, I&amp;rsquo;ll discuss rotating and animating the view, SDL event and keyboard handling, and compensating for frame rate variations. As a bonus, I&amp;rsquo;ll demonstrate some real-world refactoring, including a conversion from procedural to (weakly) object-oriented code. Before I start, however, there were a couple of issues discovered since the first article went live:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;In the first article, I wrote &amp;ldquo;orthogonal projection.&amp;rdquo; This should be &amp;ldquo;orthographic projection,&amp;rdquo; which reminds me again that no matter how many times you proofread, you can still miss the bug&amp;ndash;in code or in prose. Unfortunately, prose is a bit harder to write tests for.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Todd Ross discovered a problem with SDL on FreeBSD 5.3, which caused the code to die immediately with &amp;ldquo;Bad system call (core dumped).&amp;rdquo; A short while later, he reported the workaround. He set his &lt;code&gt;LD_PRELOAD&lt;/code&gt; environment variable with a little magic, and everything worked fine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setenv LD_PRELOAD /usr/lib/libc_r.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;His research method is a good one to follow if you should encounter a similar problem. He installed another SDL_Perl application, in this case Frozen Bubble. Once he was sure it worked, he checked the code in the launcher script and found the magic shown above. A quick test confirmed that this worked for his code as well.&lt;/p&gt;

&lt;p&gt;Frozen Bubble is a 2D application, so if it works fine but your OpenGL programs don&amp;rsquo;t, check to make sure that OpenGL works at all. Unix variants should supply the &lt;code&gt;glxinfo&lt;/code&gt; and &lt;code&gt;glxgears&lt;/code&gt; programs. Use &lt;code&gt;glxinfo&lt;/code&gt; to gather details on your OpenGL driver; it serves as both a sanity check and a good addition to bug reports. &lt;code&gt;glxgears&lt;/code&gt; does a simple animated rendering of meshing gears. This tells you whether OpenGL works correctly (at least for basic stuff) and what performance your OpenGL driver and hardware can provide. Both programs work under X on Apple&amp;rsquo;s OS X 10.3 as well.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Keep your comments, questions, and bug reports coming! I&amp;rsquo;d like to recognize your contribution in the next article, but if you&amp;rsquo;d rather remain anonymous, that&amp;rsquo;s fine too.&lt;/p&gt;

&lt;p&gt;Without further ado, let&amp;rsquo;s start. If you want try the code at each stage without all the typing, &lt;a href=&#34;http://localhost:1313/media/_pub_2004_12_29_3d_engine/perl_opengl_2_examples.tar.gz&#34;&gt;download the example source code&lt;/a&gt;. It includes a &lt;em&gt;README.steps&lt;/em&gt; file that should help you follow along more easily.&lt;/p&gt;

&lt;h3 id=&#34;moving-the-viewpoint&#34;&gt;Moving the Viewpoint&lt;/h3&gt;

&lt;p&gt;At the end of the last article, our scene had a set of axis lines roughly in the center of the screen, with a big white cube behind them and a rotated flat yellow box to the right:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub draw_view
{
    draw_axes();

    glColor(1, 1, 1);
    glPushMatrix;
    glTranslate( 0, 0, -4);
    glScale( 2, 2, 2);
    draw_cube();
    glPopMatrix;

    glColor(1, 1, 0);
    glPushMatrix;
    glTranslate( 4, 0, 0);
    glRotate( 40, 0, 0, 1);
    glScale(.2, 1, 2);
    draw_cube();
    glPopMatrix;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s move that white cube to the right by changing the first &lt;code&gt;glTranslate&lt;/code&gt; call as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;glTranslate( 12, 0, -4);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the right side of the window cuts off the white box. If I wanted to fix that while maintaining the relative positions of all the objects, there are a few possible changes I could make:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Use a wider projection (FOV) angle to see more of the scene at once. Unfortunately, it&amp;rsquo;s already at 90 degrees, which is fairly wide. The perspective effect is already very strong; much wider, and the rendering will look too distorted.&lt;/li&gt;
&lt;li&gt;Individually move all objects in the scene the same distance to the left. This would certainly work, but is a lot of effort, especially when there are many objects in the scene.&lt;/li&gt;
&lt;li&gt;Move the viewpoint right to recenter the view. This is my preference.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I want to move the viewpoint to the right, a positive X direction, so I add +6 to the X component of the viewing translation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub set_view_3d
{
    glTranslate(6, -2, -10);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the scene is even &lt;em&gt;farther&lt;/em&gt; to the right. The problem is that OpenGL combines the transformations used to modify the view (&lt;em&gt;viewing&lt;/em&gt; transformations) with those used to transform objects in the scene (&lt;em&gt;modeling&lt;/em&gt; transformations) in the &lt;em&gt;modelview&lt;/em&gt; matrix. OpenGL has no way to know whether I intend any given modelview transformation to alter the view or the objects in the scene; it treats all of them as altering the objects. By translating +6 X, I effectively moved every object 6 units to the right, rather than moving my viewpoint right as intended.&lt;/p&gt;

&lt;p&gt;I hinted at the solution before: moving the viewpoint right is equivalent to moving all objects in the scene to the left. The solution to this problem is to reverse the sign of the translation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub set_view_3d
{
    glTranslate(-6, -2, -10);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This puts the viewpoint at (6, 2, 10) where I wanted it, roughly recentering the scene. Now you can see why the viewing translation from the first article moved the viewpoint to a point slightly above (+Y) and some distance closer to the user (+Z) than the origin. I simply reversed the signs of the viewpoint coordinates I wanted, (0, 2, 10).&lt;/p&gt;

&lt;p&gt;The scene is now centered, but with this static view, it&amp;rsquo;s difficult to tell the true location and relative sizes of the objects in the scene. Perhaps I can rotate the view a bit to see this. I&amp;rsquo;ll rotate it 90 degrees counterclockwise (positive rotation) around the Y axis:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub set_view_3d
{
    glTranslate(-6, -2, -10);
    glRotate(90, 0, 1, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well, that certainly rotated things, but it&amp;rsquo;s still hard to see where the objects really are. Why did the scene end up all over on the left like that and with the axis lines in front?&lt;/p&gt;

&lt;h3 id=&#34;animating-the-view&#34;&gt;Animating the View&lt;/h3&gt;

&lt;p&gt;To understand what&amp;rsquo;s really going on with an odd transformation, it helps me to turn it into a short animation. I start the animation with a very small transformation and keep increasing it until well past the intended level. This way, I can see the effect of both smaller and larger changes.&lt;/p&gt;

&lt;p&gt;To do this, I need a few more frames in the animation. I can do this by changing the last line in &lt;code&gt;draw_frame&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$done = 1 if $frame == 10;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I also want the rotation to animate with each frame:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub set_view_3d
{
    glTranslate(-6, -2, -10);
    glRotate(18 * $frame, 0, 1, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This chops the rotation into 18 degree increments, starting at frame 1 with an 18 degree rotation and ending at frame 10 with a 180 degree rotation.&lt;/p&gt;

&lt;p&gt;Running this program shows what is happening. The scene rotates counterclockwise around its origin, the intersection point of the axis lines. I wanted to rotate the viewpoint, but I rotated the objects instead. Just reversing the sign won&amp;rsquo;t do the trick. That will rotate the scene the other direction (clockwise), but it won&amp;rsquo;t rotate around the viewpoint&amp;ndash;it will still rotate around the scene origin.&lt;/p&gt;

&lt;p&gt;In the first article, I described how to visualize a series of transforms by thinking about transforming the local coordinate system of the objects in a series of steps. Looking at the code above, you can see that it first translates the scene origin away and then rotates around that new origin. To rotate around the viewpoint, I need to rotate first and then translate the scene away:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub set_view_3d
{
    glRotate(18 * $frame, 0, 1, 0);
    glTranslate(-6, -2, -10);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This now rotates around the viewpoint, but because it rotates 180 degrees starting from dead ahead, the scene ends up behind the viewpoint. To start the view so that the scene is on one side and then rotates to be on the other, I simply offset the angle:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub set_view_3d
{
    glRotate(-90 + 18 * $frame, 0, 1, 0);
    glTranslate(-6, -2, -10);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At frame 1, the rotation angle is -90 + 18 * 1 = -72 degrees. At frame 10, the angle is -90 + 18 * 10 = 90 degrees. Perfect.&lt;/p&gt;

&lt;h4 id=&#34;stop-and-turn-around&#34;&gt;Stop and Turn Around&lt;/h4&gt;

&lt;p&gt;There&amp;rsquo;s only one little problem: it&amp;rsquo;s going the wrong way! I wanted to do a counterclockwise rotation of the view, but that should make the scene appear to rotate &lt;em&gt;clockwise&lt;/em&gt; around the viewpoint. Imagine standing in front of a landmark, taking a picture. Looking through the viewfinder, you might notice that the landmark is a bit left of center. To center it, turn slightly left (counterclockwise as seen from above, or around +Y in the default OpenGL coordinate system). This would make the landmark appear to move clockwise around you (again as seen from above), moving it from the left side of the viewfinder to the center.&lt;/p&gt;

&lt;p&gt;In this case, reverse the angle&amp;rsquo;s sign:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub set_view_3d
{
    glRotate(90 - 18 * $frame, 0, 1, 0);
    glTranslate(-6, -2, -10);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, every transformation of the view is equivalent to the opposite transformation of every object in the scene. You must reverse the sign of the coordinates in a translation, reverse the sign of the angle in a rotation, or take the inverse of the factors in a scaling (shrinking the viewer to half size makes everything appear twice as big). As we saw before, you must reverse the order of rotation and translation as well.&lt;/p&gt;

&lt;p&gt;Scaling is a special case. Inverting the factors works, but you must still do the scaling after the translation to achieve the expected effect, rather than following the rule for rotation and translation and reversing the transformation order completely. The reason is that scaling before the translation scales the translation also. Scaling by (2, 2, 2) would double the size of all of the objects in the scene, but it would also put them twice as far away, making them appear the same size. I&amp;rsquo;ll skip the code for this and leave it as an exercise for the reader. Go ahead, have fun.&lt;/p&gt;

&lt;p&gt;If you decide to give view scaling a try, remember that all distances will change. This affects some non-obvious things such as the third and fourth arguments to &lt;code&gt;gluPerspective&lt;/code&gt; (the distance to the nearest and farthest objects OpenGL will render).&lt;/p&gt;

&lt;h3 id=&#34;smoothing-it-out&#34;&gt;Smoothing It Out&lt;/h3&gt;

&lt;p&gt;After watching these animations for a while, the jerkiness really begins to bother me, and because I doubled the number of animation frames, it takes twice as long to finish a run. Both of these problems relate to the second-long sleep at the end of &lt;code&gt;draw_frame&lt;/code&gt;. I should be able to fix them by shortening the sleep to half a second:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sleep .5;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chances are, that doesn&amp;rsquo;t yield quite the respected result. On my system, there&amp;rsquo;s a blur for a fraction of a second, and the whole run is done. Unfortunately, the builtin Perl &lt;code&gt;sleep&lt;/code&gt; function only handles integer seconds, so .5 truncates to 0 and the &lt;code&gt;sleep&lt;/code&gt; returns almost instantly.&lt;/p&gt;

&lt;p&gt;Luckily, SDL provides a millisecond-resolution delay function, &lt;code&gt;SDL::Delay&lt;/code&gt;. To use it, I add another subroutine to handle the delay, translating between seconds and milliseconds:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub delay
{
    my $seconds = shift;

    SDL::Delay($seconds * 1000);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, changing the &lt;code&gt;sleep&lt;/code&gt; call to &lt;code&gt;delay&lt;/code&gt; fixes it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;delay(.5);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The movement is faster and it only takes five seconds to complete the entire animation again, but this code still wastes the available performance of the system. I want the animation to be as smooth as the system allows, while keeping the rotation speed (and total time) constant. To implement this, I need to give the code a sense of time. First, I add another global to keep the current time:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my ($time);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point, my editor likely just sprayed his screen with whatever he&amp;rsquo;s drinking and coughed &amp;ldquo;Another global?!?&amp;rdquo; I&amp;rsquo;ll address that later in this article during the refactoring.&lt;/p&gt;

&lt;p&gt;To update the time, I need a couple more functions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub update_time
{
    $time = now();
}

sub now
{
    return SDL::GetTicks() / 1000;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;now&lt;/code&gt; calls SDL&amp;rsquo;s &lt;code&gt;GetTicks&lt;/code&gt; function, which returns the time since SDL initialization in milliseconds. It converts the result back to seconds for convenience elsewhere. &lt;code&gt;update_time&lt;/code&gt; uses &lt;code&gt;now&lt;/code&gt; to keep the global &lt;code&gt;$time&lt;/code&gt; up to date.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;main_loop&lt;/code&gt; uses this to update the time before rendering the frame:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub main_loop
{
    while (not $done) {
        $frame++;
        update_time();
        do_frame();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because this version won&amp;rsquo;t artificially slow the animation, I make two changes to &lt;code&gt;draw_frame&lt;/code&gt;. I remove the &lt;code&gt;delay&lt;/code&gt; call and change the animation end test to check whether the time has reached five seconds, instead of whether frame ten has been drawn.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub draw_frame
{
    set_projection_3d();
    set_view_3d();
    draw_view();

    print &#39;.&#39;;
    $done = 1 if $time &amp;gt;= 5;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, &lt;code&gt;set_view_3d&lt;/code&gt; must base its animation on the current time instead of the current frame. Our current rotation speed is 18 degrees per frame. With 2 frames per second, that comes to 36 degrees per second:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub set_view_3d
{
    glRotate(90 - 36 * $time, 0, 1, 0);
    glTranslate(-6, -2, -10);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This version should appear much smoother. On my system, the dots printed for each frame scroll up the terminal window. If you run this program multiple times, you&amp;rsquo;ll notice the number of frames (and hence dots) varies. Small variations in timing from numerous sources cause a frame now and then to take more or less time. Over the course of a run, this adds up to being able to complete a few frames more or less before hitting the five second deadline. Visually, the rotation speed should appear nearly constant because it calculates the current angle from the current time, whatever that may be, rather than the frame number.&lt;/p&gt;

&lt;h3 id=&#34;refactoring-for-fun-and-clarity&#34;&gt;Refactoring for Fun and Clarity&lt;/h3&gt;

&lt;p&gt;Now that the animation is smooth, I&amp;rsquo;m almost ready to add some manual control using SDL events. That&amp;rsquo;s a big topic and involves a lot of code. It&amp;rsquo;s always a good idea before a big change to step back, take a look at the exisiting code, and see if it needs a clean up.&lt;/p&gt;

&lt;p&gt;The basic procedure is as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Find one obvious bit of ugliness.&lt;/li&gt;
&lt;li&gt;Make a small atomic change to clean it up.&lt;/li&gt;
&lt;li&gt;Test to make sure everything still works.&lt;/li&gt;
&lt;li&gt;Lather, rinse, repeat until satisfied.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Unfortunately, it&amp;rsquo;s occasionally necessary to make one part of the code a little uglier while cleaning up something else. The trick is eventually to clean up the freshly uglified piece.&lt;/p&gt;

&lt;h4 id=&#34;refactoring-the-view&#34;&gt;Refactoring the View&lt;/h4&gt;

&lt;p&gt;And on that note, let&amp;rsquo;s add another global! I don&amp;rsquo;t like the hardcoding of &lt;code&gt;set_view_3d&lt;/code&gt;. I&amp;rsquo;d like to convert that into a data structure of some kind, so I define a view object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my ($view);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This needs an update routine, so here&amp;rsquo;s a simple one:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub update_view
{
    $view = {
        position    =&amp;gt; [6, 2, 10],
        orientation =&amp;gt; [-90 + 36 * $time, 0, 1, 0],
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is simply the position and orientation of the virtual viewer (before the sign reversal needed by the viewing transformations). I need to call this in the main loop, just before calling &lt;code&gt;do_frame&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub main_loop
{
    while (not $done) {
        $frame++;
        update_time();
        update_view();
        do_frame();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point, running the program should show that nothing much changed because I haven&amp;rsquo;t actually changed the viewing code&amp;ndash;the new code runs in parallel with the old code. Using the new code requires replacement of &lt;code&gt;set_view_3d&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub set_view_3d
{
    my ($angle, @axis) = @{$view-&amp;gt;{orientation}};
    my ($x, $y, $z)    = @{$view-&amp;gt;{position}};

    glRotate(-$angle, @axis);
    glTranslate(-$x, -$y, -$z);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running the program should again show that nothing visually changed, indicating a successful refactoring. At this point, you may wonder what this has gained; there&amp;rsquo;s a new global and a dozen or so more lines of code. The new code has several benefits:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The concepts of animating the view parameters and setting the current view in OpenGL are now separate, as they should be.&lt;/li&gt;
&lt;li&gt;Hoisting the &lt;code&gt;update_view&lt;/code&gt; call up to &lt;code&gt;main_loop&lt;/code&gt; next to the &lt;code&gt;update_time&lt;/code&gt; call begins to collect all updates together, cleaning up the overall design.&lt;/li&gt;
&lt;li&gt;The new code hints at further refactoring opportunities.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In fact, I can see several problem places to refactor next, along with some reasons to fix them:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The mess of globals, since I just added one.&lt;/li&gt;
&lt;li&gt;Updating &lt;code&gt;$done&lt;/code&gt; in &lt;code&gt;draw_view&lt;/code&gt; (mixing updates and OpenGL work again) to continue collecting all updates together.&lt;/li&gt;
&lt;li&gt;Pervasive hardcoding in &lt;code&gt;draw_view&lt;/code&gt;, for all the same reasons I refactored &lt;code&gt;set_view_3d&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;the-great-global-smashing&#34;&gt;The Great Global Smashing&lt;/h4&gt;

&lt;p&gt;The globals situation is out of hand, so now seems a good time to fix that and check off the first item of the new &amp;ldquo;pending refactoring&amp;rdquo; list. First, I need to decide how to address the problem.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the current globals list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my ($done, $frame);
my ($conf, $sdl_app);
my ($time);
my ($view);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this mess, I see several different concepts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Configuration: &lt;code&gt;$conf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Resource object: &lt;code&gt;$sdl_app&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Engine state: &lt;code&gt;$done&lt;/code&gt;, &lt;code&gt;$frame&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Simulated world: &lt;code&gt;$time&lt;/code&gt;, &lt;code&gt;$view&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I&amp;rsquo;ll create from these groupings a single engine object laid out like so (variables show where the data from the old globals goes):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    conf     =&amp;gt; $conf,
    resource =&amp;gt; {
        sdl_app =&amp;gt; $sdl_app,
    },
    state    =&amp;gt; {
        done    =&amp;gt; $done,
        frame   =&amp;gt; $frame,
    },
    world    =&amp;gt; {
        time    =&amp;gt; $time,
        view    =&amp;gt; $view,
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a fairly radical change from the current code, so to be safe, I&amp;rsquo;ll do it in several small pieces, testing after each version that everything still works.&lt;/p&gt;

&lt;p&gt;The first step is to add a constructor for my object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub new
{
    my $class = shift;
    my $self  = bless {}, $class;

    return $self;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is pretty much the garden variety trivial constructor in Perl 5. It blesses a hash reference into the specified class and then returns it. I also need to change my &lt;code&gt;START&lt;/code&gt; code to use this new constructor to create an object and call &lt;code&gt;main&lt;/code&gt; as a method on it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;START: __PACKAGE__-&amp;gt;new-&amp;gt;main;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This snippet constructs a new object, using the current package as the class name, and immediately calls the &lt;code&gt;main&lt;/code&gt; method on the returned object. &lt;code&gt;main&lt;/code&gt; doesn&amp;rsquo;t have any parameters, so calling it as a method won&amp;rsquo;t affect it (there are no existing parameters that would be shifted right by a new invocant parameter). I never store the object in a variable as a form of self-imposed stricture. Because the object only exists as the invocant of &lt;code&gt;main&lt;/code&gt;, I must convert every routine that accesses the information in the object to a method and change all calls to those routines as well.&lt;/p&gt;

&lt;h5 id=&#34;let-it-flow&#34;&gt;Let It Flow&lt;/h5&gt;

&lt;p&gt;Testing at this point shows all still works, so the next change is to make &lt;code&gt;main&lt;/code&gt; flow the object reference through to its children by calling them as methods:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub main
{
    my $self = shift;

    $self-&amp;gt;init;
    $self-&amp;gt;main_loop;
    $self-&amp;gt;cleanup;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Testing this shows that, again, all is fine, as expected. &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;main_loop&lt;/code&gt; are changed in the obvious fashion (&lt;code&gt;cleanup&lt;/code&gt; doesn&amp;rsquo;t do much, so it doesn&amp;rsquo;t need to change now):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub init
{
    my $self = shift;

    $| = 1;

    $self-&amp;gt;init_conf;
    $self-&amp;gt;init_window;
}

sub main_loop
{
    my $self = shift;

    while (not $done) {
        $frame++;
        $self-&amp;gt;update_time;
        $self-&amp;gt;update_view;
        $self-&amp;gt;do_frame;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that I have not changed the references to &lt;code&gt;$done&lt;/code&gt; and &lt;code&gt;$frame&lt;/code&gt; in &lt;code&gt;main&lt;/code&gt;. It&amp;rsquo;s important to make only a single conceptual change at a time during refactoring, to minimize the chance of making an error and not being able to figure out which change caused the problem. I&amp;rsquo;ll return to these references in a bit. Testing this version shows that all is well, so I continue:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub do_frame
{
    my $self = shift;

    $self-&amp;gt;prep_frame;
    $self-&amp;gt;draw_frame;
    $self-&amp;gt;end_frame;
}

sub draw_frame
{
    my $self = shift;

    $self-&amp;gt;set_projection_3d;
    $self-&amp;gt;set_view_3d;
    $self-&amp;gt;draw_view;

    print &#39;.&#39;;
    $done = 1 if $time &amp;gt;= 5;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, for this pass, I ignore &lt;code&gt;$done&lt;/code&gt; and &lt;code&gt;$time&lt;/code&gt; in &lt;code&gt;draw_frame&lt;/code&gt;. At this point, I&amp;rsquo;ve pretty much exhausted all of the changes that amount to simply turning subroutine calls into method calls and the code still works as advertised.&lt;/p&gt;

&lt;h5 id=&#34;replacing-the-globals&#34;&gt;Replacing the Globals&lt;/h5&gt;

&lt;p&gt;With this working, I start into more interesting territory. It&amp;rsquo;s time to move the globals into their proper place in the object. First up are the state variables &lt;code&gt;$done&lt;/code&gt; and &lt;code&gt;$frame&lt;/code&gt; in &lt;code&gt;main_loop&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub main_loop
{
    my $self = shift;

    while (not $self-&amp;gt;{state}{done}) {
        $self-&amp;gt;{state}{frame}++;
        $self-&amp;gt;update_time;
        $self-&amp;gt;update_view;
        $self-&amp;gt;do_frame;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the last line of &lt;code&gt;draw_frame&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$self-&amp;gt;{state}{done} = 1 if $time &amp;gt;= 5;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As they are no longer globals, I remove their declarations as well. I will have to come back to &lt;code&gt;draw_frame&lt;/code&gt; again when cleaning up &lt;code&gt;$time&lt;/code&gt;. One change per pass&amp;ndash;it&amp;rsquo;s very easy to follow a long chain of related changes before doing a test run and find out you made a mistake. Somewhere. Argh. In this case, I resist the urge to keep changing the code and do another test run immediately to find that indeed all still works.&lt;/p&gt;

&lt;p&gt;Next up is the world attribute &lt;code&gt;$view&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub update_view
{
    my $self = shift;

    $self-&amp;gt;{world}{view} = {
        position    =&amp;gt; [6, 2, 10],
        orientation =&amp;gt; [-90 + 36 * $time, 0, 1, 0],
    };
}

sub set_view_3d
{
    my $self = shift;

    my $view           = $self-&amp;gt;{world}{view};
    my ($angle, @axis) = @{$view-&amp;gt;{orientation}};
    my ($x, $y, $z)    = @{$view-&amp;gt;{position}};

    glRotate(-$angle, @axis);
    glTranslate(-$x, -$y, -$z);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In &lt;code&gt;set_view_3d&lt;/code&gt;, it seemed clearest to make a lexical &lt;code&gt;$view&lt;/code&gt; loaded from the object. This allowed me to leave the rest of the function clean and unchanged. Testing after the above changes and removing the global declaration for &lt;code&gt;$view&lt;/code&gt; shows that all is good.&lt;/p&gt;

&lt;p&gt;Next up are &lt;code&gt;$conf&lt;/code&gt; and the resource object &lt;code&gt;$sdl_app&lt;/code&gt;, following much the same pattern as before:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub init_conf
{
    my $self = shift;

    $self-&amp;gt;{conf} = {
        title  =&amp;gt; &#39;Camel 3D&#39;,
        width  =&amp;gt; 400,
        height =&amp;gt; 400,
        fovy   =&amp;gt; 90,
    };
}

sub init_window
{
    my $self = shift;

    my $title = $self-&amp;gt;{conf}{title};
    my $w     = $self-&amp;gt;{conf}{width};
    my $h     = $self-&amp;gt;{conf}{height};

    $self-&amp;gt;{resource}{sdl_app}
        = SDL::App-&amp;gt;new(-title  =&amp;gt; $title,
                        -width  =&amp;gt; $w,
                        -height =&amp;gt; $h,
                        -gl     =&amp;gt; 1,
                       );
    SDL::ShowCursor(0);
}

sub set_projection_3d
{
    my $self   = shift;

    my $fovy   = $self-&amp;gt;{conf}{fovy};
    my $w      = $self-&amp;gt;{conf}{width};
    my $h      = $self-&amp;gt;{conf}{height};
    my $aspect = $w / $h;

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity;
    gluPerspective($fovy, $aspect, 1, 1000);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity;
}

sub end_frame
{
    my $self = shift;

    $self-&amp;gt;{resource}{sdl_app}-&amp;gt;sync;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first time I did this, it broke. I had forgotten to make the changes to &lt;code&gt;set_projection_3d&lt;/code&gt;. Thanks to &lt;code&gt;use strict&lt;/code&gt;, the error was obvious, and a quick fix later, everything worked again.&lt;/p&gt;

&lt;p&gt;Last but not least, it&amp;rsquo;s time to fix the remaining world attribute &lt;code&gt;$time&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub update_time
{
    my $self = shift;

    $self-&amp;gt;{world}{time} = now();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In &lt;code&gt;update_view&lt;/code&gt;, I continue with my tactic of creating lexicals and leaving the remaining code alone:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $time = $self-&amp;gt;{world}{time};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, the last line of &lt;code&gt;draw_frame&lt;/code&gt; changes again:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$self-&amp;gt;{state}{done} = 1
    if $self-&amp;gt;{world}{time} &amp;gt;= 5;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first test run of the completed refactoring uncovered a typo that gave an obscure warning. Thankfully, I only had to check the few changed lines since the last test, and the typo was easily found. With things working again, The Great Global Smashing is complete. The once completely procedural program is now on its way to claiming object orientation. (Boy will I be happy to switch to Perl 6 OO syntax! Perl 6 OO keeps the visual clarity of pure procedural code while gaining several powerful benefits not available in Perl 5. I could fake the clearer syntax with judicious use of source filtering, but that&amp;rsquo;s another article.)&lt;/p&gt;

&lt;p&gt;This seems to me like enough refactoring for now, so it&amp;rsquo;s back to the main thrust of development: keyboard control.&lt;/p&gt;

&lt;h3 id=&#34;the-big-event&#34;&gt;The Big Event&lt;/h3&gt;

&lt;p&gt;Keyboard handling is a special case of SDL event handling, and not an entirely trivial case at that. I&amp;rsquo;ll start with the basic structure for processing SDL events and handle a much simpler event first. To access SDL events, I need to load the &lt;code&gt;SDL::Event&lt;/code&gt; module:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use SDL::Event;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Like &lt;code&gt;SDL::App&lt;/code&gt;, the code needs to keep track of an &lt;code&gt;SDL::Event&lt;/code&gt; resource object to access the event queue. In addition, I need to keep track of which routine I&amp;rsquo;ll use to process each event type. This is a new kind of data, so I add a new branch to the engine object for various lookup tables. To set up both of these, I add a new initialization function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub init_event_processing
{
    my $self = shift;

    $self-&amp;gt;{resource}{sdl_event} = SDL::Event-&amp;gt;new;
    $self-&amp;gt;{lookup}{event_processor} = {
        &amp;amp;SDL_QUIT    =&amp;gt; \&amp;amp;process_quit,
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SDL event types are constants in the general SDL constant convention (UPPERCASE with a leading &lt;code&gt;SDL_&lt;/code&gt; marker). The event type for quit events is &lt;code&gt;SDL_QUIT&lt;/code&gt;, which I associate with the &lt;code&gt;process_quit&lt;/code&gt; routine using a subroutine reference.&lt;/p&gt;

&lt;p&gt;A new line at the end of &lt;code&gt;init&lt;/code&gt; calls the initialization routine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$self-&amp;gt;init_event_processing;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Every time through, the main loop should process events before updating the view (after I add keyboard control, the view should update using the latest user input). The contents of the loop in &lt;code&gt;main_loop&lt;/code&gt; are now as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$self-&amp;gt;{state}{frame}++;
$self-&amp;gt;update_time;
$self-&amp;gt;do_events;
$self-&amp;gt;update_view;
$self-&amp;gt;do_frame;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;do_events&lt;/code&gt; is very simple at this stage, just calling &lt;code&gt;process_events&lt;/code&gt; to, er, process pending SDL events:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub do_events
{
    my $self = shift;

    my $queue = $self-&amp;gt;process_events;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;the-event-processing-loop&#34;&gt;The Event Processing Loop&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;process_events&lt;/code&gt; is where all the magic happens:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub process_events
{
    my $self = shift;

    my $event  = $self-&amp;gt;{resource}{sdl_event};
    my $lookup = $self-&amp;gt;{lookup}{event_processor};
    my ($process, $command, @queue);

    $event-&amp;gt;pump;
    while (not $self-&amp;gt;{state}{done} and $event-&amp;gt;poll) {
        $process = $lookup-&amp;gt;{$event-&amp;gt;type} or next;
        $command = $self-&amp;gt;$process($event);
        push @queue, $command if $command;
    }

    return \@queue;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first couple of lines provide shorter names for the previously stored &lt;code&gt;SDL::Event&lt;/code&gt; object and event processor lookup table. The rest of the variables respectively store:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A reference to the processing routine for the current event&lt;/li&gt;
&lt;li&gt;The internal command to convert the event into&lt;/li&gt;
&lt;li&gt;The queue of commands collected from incoming events&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The core of the code starts by telling the &lt;code&gt;SDL::Event&lt;/code&gt; object to gather any pending operating system events in preparation for the processing loop, using the &lt;code&gt;pump&lt;/code&gt; method. The processing loop checks to make sure that a previous event has not flagged the &lt;code&gt;done&lt;/code&gt; state, which helps to improve responsiveness to quit events. Assuming that this has not happened, the loop requests the next SDL event using &lt;code&gt;SDL::Event::poll&lt;/code&gt;. &lt;code&gt;poll&lt;/code&gt; returns a false value when there are no events ready for pickup, thereby exiting the loop.&lt;/p&gt;

&lt;p&gt;The first line inside the loop uses the event type to look up the proper event processing routine. If there is none, I use &lt;code&gt;next&lt;/code&gt; to loop again and check the next event. Otherwise, the next line calls the processing routine as a dynamically chosen method to handle the event. If the processing routine determines that the event requires additional work, it should return a command packet to be queued. If the event should be ignored, the processor should simply return a false value.&lt;/p&gt;

&lt;p&gt;The last line within the loop adds the command packet (if any) to the queue awaiting further processing. Once the loop processes all available SDL events, &lt;code&gt;process_events&lt;/code&gt; returns the queue so that &lt;code&gt;do_events&lt;/code&gt; can perform the next stage of processing.&lt;/p&gt;

&lt;p&gt;It may seem confusing that each time through the loop the code reuses the same &lt;code&gt;$event&lt;/code&gt;. You might expect &lt;code&gt;SDL::Event::poll&lt;/code&gt; to return the next waiting event (and perhaps &lt;code&gt;undef&lt;/code&gt; when none remain). Instead, the SDL API specifies that &lt;code&gt;poll&lt;/code&gt; copies the data from the next entry in the event queue into the event object, returning a true or false status indicating whether this operation succeeded. As with some of the OpenGL quirks, SDL_Perl copies this odd interface directly, easing the transition for programmers used to the C API.&lt;/p&gt;

&lt;p&gt;A consequence of this interface decision is that the event processing routine must make a copy of any data from the SDL event object needed for later. The call to &lt;code&gt;SDL::Event::poll&lt;/code&gt; in the next iteration of the processing loop will overwrite any data left in the SDL event object, so simply storing the object reference won&amp;rsquo;t work.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;process_quit&lt;/code&gt; routine doesn&amp;rsquo;t need to save any data; it only matters that an &lt;code&gt;SDL_QUIT&lt;/code&gt; event occurred:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub process_quit
{
    my $self = shift;

    $self-&amp;gt;{state}{done} = 1;
    return &#39;quit&#39;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;process_quit&lt;/code&gt; first sets the &lt;code&gt;done&lt;/code&gt; state flag, which causes the loop in &lt;code&gt;process_events&lt;/code&gt; to exit early and, more importantly, exits &lt;code&gt;main_loop&lt;/code&gt;. It returns the simplest type of command packet, a string indicating the &lt;code&gt;quit&lt;/code&gt; command. At this point, there&amp;rsquo;s no code to process this command further, but this keeps things parallel with the keyboard version I&amp;rsquo;ll show next.&lt;/p&gt;

&lt;p&gt;What does all this buy us? For starters, we can now (finally) quit the program using the window manager before the animation runs its course. On my system, that means clicking the &amp;lsquo;X&amp;rsquo; on the window&amp;rsquo;s title bar. Still, that&amp;rsquo;s not the same as having a quit key (which I find much more convenient).&lt;/p&gt;

&lt;h3 id=&#34;key-binding&#34;&gt;Key Binding&lt;/h3&gt;

&lt;p&gt;To add a quit key, I first need to decide &lt;em&gt;which&lt;/em&gt; key should quit the program. I&amp;rsquo;d choose the Escape key because that makes mnemonic sense to me, but everyone has their favorite, so I&amp;rsquo;ll allow that to be a configuration setting. To do this, I extend the configuration hash with a new &lt;code&gt;bind&lt;/code&gt; section:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub init_conf
{
    my $self = shift;

    $self-&amp;gt;{conf} = {
        title  =&amp;gt; &#39;Camel 3D&#39;,
        width  =&amp;gt; 400,
        height =&amp;gt; 400,
        fovy   =&amp;gt; 90,
        bind   =&amp;gt; {
            escape =&amp;gt; &#39;quit&#39;,
        }
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now anyone who wants to choose a different quit key can simply change the keyboard bindings hash. In fact, several keys could be associated with the same command, so that either the Escape key or &amp;lsquo;q&amp;rsquo; would exit the program. The hash value corresponding to each specified key is the command packet issued when the user presses that key. This one matches the command packet I&amp;rsquo;d chosen for the window manager quit message earlier.&lt;/p&gt;

&lt;p&gt;Next, I need to process keypress events, which have the event type &lt;code&gt;SDL_KEYDOWN&lt;/code&gt;. I add another entry to the &lt;code&gt;event_processor&lt;/code&gt; hash:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub init_event_processing
{
    my $self = shift;

    $self-&amp;gt;{resource}{sdl_event} = SDL::Event-&amp;gt;new;
    $self-&amp;gt;{lookup}{event_processor} = {
        &amp;amp;SDL_QUIT    =&amp;gt; \&amp;amp;process_quit,
        &amp;amp;SDL_KEYDOWN =&amp;gt; \&amp;amp;process_key,
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and define the key processor as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub process_key
{
    my $self = shift;

    my $event   = shift;
    my $symbol  = $event-&amp;gt;key_sym;
    my $name    = SDL::GetKeyName($symbol);
    my $command = $self-&amp;gt;{conf}{bind}{$name} || &#39;&#39;;

    return $command;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;process_key&lt;/code&gt; starts by extracting the key symbol from the SDL event. Key symbols are rather opaque for our purposes, so I request the key name matching the extracted key symbol using &lt;code&gt;SDL::GetKeyName&lt;/code&gt;. This produces a friendly key name that I look up in the key bindings hash to find the appropriate command packet. If there is none, no matter; that key isn&amp;rsquo;t bound yet so it yields an empty command packet. &lt;code&gt;process_key&lt;/code&gt; then returns the command packet to add to the queue for further processing.&lt;/p&gt;

&lt;h4 id=&#34;handling-command-packets&#34;&gt;Handling Command Packets&lt;/h4&gt;

&lt;p&gt;At this point, the code converts a press of the Escape key into a quit command packet, but &lt;code&gt;do_events&lt;/code&gt; ignores that packet because it does not process the command queue it receives from &lt;code&gt;process_events&lt;/code&gt;. To make something happen, I first need to associate each known command with an action routine. I create a new lookup hash for this association, initialized in &lt;code&gt;init_command_actions&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub init_command_actions
{
    my $self = shift;

    $self-&amp;gt;{lookup}{command_action} = {
        quit      =&amp;gt; \&amp;amp;action_quit,
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As usual, I call this at the end of &lt;code&gt;init&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$self-&amp;gt;init_command_actions;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s now time to fill out &lt;code&gt;do_events&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub do_events
{
    my $self   = shift;

    my $queue  = $self-&amp;gt;process_events;
    my $lookup = $self-&amp;gt;{lookup}{command_action};
    my ($command, $action);

    while (not $self-&amp;gt;{state}{done} and @$queue) {
        $command = shift @$queue;
        $action  = $lookup-&amp;gt;{$command} or next;
        $self-&amp;gt;$action($command);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is similar in form to &lt;code&gt;process_events&lt;/code&gt;. Instead of processing events from SDL&amp;rsquo;s internal queue to create a queue of command packets, it processes queued command packets into actions to perform. The loop starts as usual by checking that the &lt;code&gt;done&lt;/code&gt; is not true and that there are still commands pending in the queue.&lt;/p&gt;

&lt;p&gt;Within the loop, it shifts the next command off the front of the queue. The next line determines the action routine associated with the command. If it cannot find one, it uses &lt;code&gt;next&lt;/code&gt; to skip to the next command. Otherwise, it calls the action routine as a dynamically chosen method with the command packet as a parameter. This allows a single action routine to process several similar commands while still being able to tell the difference between them. I&amp;rsquo;ll need this later for processing movement keys.&lt;/p&gt;

&lt;p&gt;For all of that, &lt;code&gt;action_quit&lt;/code&gt; is very simple; it just flags &lt;code&gt;done&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub action_quit
{
    my $self = shift;

    $self-&amp;gt;{state}{done} = 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point, the Escape key really will quit the program early, and the window manager quit still works as well.&lt;/p&gt;

&lt;p&gt;Now that the user can quit whenever desired, I can finally remove the incongruous end of &lt;code&gt;draw_frame&lt;/code&gt;. It&amp;rsquo;s no longer necessary to force the program to end after five seconds, and the dots printed each frame have outlived their usefulness. The routine now looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub draw_frame
{
    my $self = shift;

    $self-&amp;gt;set_projection_3d;
    $self-&amp;gt;set_view_3d;
    $self-&amp;gt;draw_view;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, if you wait long enough after the objects disappear on the right, the view rotates all the way around, and the scene appears again on the left. This version of the routine is much cleaner and incidently closes the next open refactoring issue (changing engine state within a drawing routine) for free.&lt;/p&gt;

&lt;h3 id=&#34;controlling-the-view&#34;&gt;Controlling the View&lt;/h3&gt;

&lt;p&gt;Now that the code can handle keypress events, it&amp;rsquo;s time to control the view using the keyboard.&lt;/p&gt;

&lt;p&gt;Instead of having the view completely recalculated every frame, I&amp;rsquo;d rather have each keypress modify the existing view state. To specify the initial state, I add another initialization routine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub init_view
{
    my $self = shift;

    $self-&amp;gt;{world}{view} = {
        position    =&amp;gt; [6, 2, 10],
        orientation =&amp;gt; [0, 0, 1, 0],
        d_yaw       =&amp;gt; 0,
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The new entry, &lt;code&gt;d_yaw&lt;/code&gt;, tells &lt;code&gt;update_view&lt;/code&gt; if there is a pending change (aka delta, hence the leading &lt;code&gt;d_&lt;/code&gt;) in facing. The code so far can only handle yaw (left and right rotation), so that&amp;rsquo;s the only delta key needed right now.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;init&lt;/code&gt; calls this routine as usual in its new last line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$self-&amp;gt;init_view;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;update_view&lt;/code&gt; applies the yaw delta to the view orientation, then zeroes out &lt;code&gt;d_yaw&lt;/code&gt; so that it won&amp;rsquo;t continue to affect the rotation in succeeding frames (without the user pressing the rotation keys again):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub update_view
{
    my $self   = shift;

    my $view   = $self-&amp;gt;{world}{view};

    $view-&amp;gt;{orientation}[0] += $view-&amp;gt;{d_yaw};
    $view-&amp;gt;{d_yaw}           = 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A command action assigned to the &lt;code&gt;yaw_left&lt;/code&gt; and &lt;code&gt;yaw_right&lt;/code&gt; commands updates &lt;code&gt;d_yaw&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub init_command_actions
{
    my $self = shift;

    $self-&amp;gt;{lookup}{command_action} = {
        quit      =&amp;gt; \&amp;amp;action_quit,
        yaw_left  =&amp;gt; \&amp;amp;action_move,
        yaw_right =&amp;gt; \&amp;amp;action_move,
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To assign keys for these commands, I update the &lt;code&gt;bind&lt;/code&gt; hash in &lt;code&gt;init_conf&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bind   =&amp;gt; {
    escape =&amp;gt; &#39;quit&#39;,
    left   =&amp;gt; &#39;yaw_left&#39;,
    right  =&amp;gt; &#39;yaw_right&#39;,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The big change is the new command action routine &lt;code&gt;action_move&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub action_move
{
    my $self = shift;

    my $command     = shift;
    my $view        = $self-&amp;gt;{world}{view};
    my $speed_yaw   = 10;
    my %move_update = (
        yaw_left  =&amp;gt; [d_yaw =&amp;gt;  $speed_yaw],
        yaw_right =&amp;gt; [d_yaw =&amp;gt; -$speed_yaw],
    );
    my $update = $move_update{$command} or return;

    $view-&amp;gt;{$update-&amp;gt;[0]} += $update-&amp;gt;[1];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;action_move&lt;/code&gt; starts by grabbing the command parameter and current view. It then sets the basic rotation speed, measured in degrees per key press. Next, the &lt;code&gt;%move_update&lt;/code&gt; hash defines the view update associated with each known command. If it knows the command, it retrieves the corresponding update. If not, &lt;code&gt;action_move&lt;/code&gt; returns.&lt;/p&gt;

&lt;p&gt;The last line interprets the update. The view key specified by the first element of the update array is incremented by the amount specified by the second element. In other words, receiving a &lt;code&gt;yaw_left&lt;/code&gt; command causes the routine to add &lt;code&gt;$speed_yaw&lt;/code&gt; to &lt;code&gt;$view-&amp;gt;{d_yaw}&lt;/code&gt;; a &lt;code&gt;yaw_right&lt;/code&gt; command adds &lt;code&gt;-$speed_yaw&lt;/code&gt; to &lt;code&gt;$view-&amp;gt;{d_yaw}&lt;/code&gt;, effectively turning the view the opposite direction.&lt;/p&gt;

&lt;p&gt;With these changes in place, the program starts up looking directly at the scene as it appeared near the beginning of this article. Each press of the left or right arrow keys turns the view ten degrees in the appropriate direction (remember that the scene appears to turn the opposite direction around the view). Holding the keys down does nothing; only a change from unpressed to pressed does anything, and it only rotates the view one increment. This, as they say, is suboptimal.&lt;/p&gt;

&lt;h4 id=&#34;angular-velocity&#34;&gt;Angular Velocity&lt;/h4&gt;

&lt;p&gt;In order to solve this, the code has to change from working purely in terms of angular &lt;em&gt;position&lt;/em&gt; to working in terms of angular &lt;em&gt;velocity&lt;/em&gt;. Pressing a key should start the view rotating at a constant speed, and it should stay that way until the key is released.&lt;/p&gt;

&lt;p&gt;Velocity goes hand in hand with time. In particular, for each frame, &lt;code&gt;update_view&lt;/code&gt; needs to know how much time has passed since the last frame to determine the change in angle matching the rotation speed. To compute this time delta, the first change is to make sure the code always has a valid world time by initializing it at program start:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub init_time
{
    my $self             = shift;

    $self-&amp;gt;{world}{time} = now();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, this requires another line at the end of &lt;code&gt;init&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$self-&amp;gt;init_time;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this in place, I can change &lt;code&gt;update_time&lt;/code&gt; to record the time delta for each frame:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub update_time
{
    my $self = shift;

    my $now  = now();

    $self-&amp;gt;{world}{d_time} = $now - $self-&amp;gt;{world}{time};
    $self-&amp;gt;{world}{time}   = $now;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;ve made a few changes that shouldn&amp;rsquo;t affect the behavior of the program, and I&amp;rsquo;m about to make several more that definitely will change the behavior, so now is a good time for a quick sanity test. All is fine, so it&amp;rsquo;s time to contemplate the design for the remaining code.&lt;/p&gt;

&lt;h5 id=&#34;continuing-commands&#34;&gt;Continuing Commands&lt;/h5&gt;

&lt;p&gt;There are really two classes of keyboard commands that I want to handle:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Single-shots like &lt;code&gt;quit&lt;/code&gt;, &lt;code&gt;drop_object&lt;/code&gt;, and &lt;code&gt;pull_pin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Continuing commands like &lt;code&gt;yaw_left&lt;/code&gt; and &lt;code&gt;scream_head_off&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To differentiate them, I borrow an existing game convention and use a leading &lt;code&gt;+&lt;/code&gt; to indicate a continuing command. This changes the bind mapping in &lt;code&gt;init_conf&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bind   =&amp;gt; {
    escape =&amp;gt; &#39;quit&#39;,
    left   =&amp;gt; &#39;+yaw_left&#39;,
    right  =&amp;gt; &#39;+yaw_right&#39;,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the &lt;code&gt;command_action&lt;/code&gt; lookup:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub init_command_actions
{
    my $self = shift;

    $self-&amp;gt;{lookup}{command_action} = {
          quit       =&amp;gt; \&amp;amp;action_quit,
        &#39;+yaw_left&#39;  =&amp;gt; \&amp;amp;action_move,
        &#39;+yaw_right&#39; =&amp;gt; \&amp;amp;action_move,
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To process the key release events, I need to assign an event processor for the &lt;code&gt;SDL_KEYUP&lt;/code&gt; event. I&amp;rsquo;ll reuse the existing &lt;code&gt;process_key&lt;/code&gt; routine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub init_event_processing
{
    my $self = shift;

    $self-&amp;gt;{resource}{sdl_event} = SDL::Event-&amp;gt;new;
    $self-&amp;gt;{lookup}{event_processor} = {
        &amp;amp;SDL_QUIT    =&amp;gt; \&amp;amp;process_quit,
        &amp;amp;SDL_KEYUP   =&amp;gt; \&amp;amp;process_key,
        &amp;amp;SDL_KEYDOWN =&amp;gt; \&amp;amp;process_key,
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;process_key&lt;/code&gt; needs some training to be able to differentiate the two types of events:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub process_key
{
    my $self    = shift;

    my $event   = shift;
    my $symbol  = $event-&amp;gt;key_sym;
    my $name    = SDL::GetKeyName($symbol);
    my $command = $self-&amp;gt;{conf}{bind}{$name} || &#39;&#39;;
    my $down    = $event-&amp;gt;type == SDL_KEYDOWN;

    if ($command =~ /^\+/) {
        return [$command, $down];
    }
    else {
        return $down ? $command : &#39;&#39;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The new code (everything after the &lt;code&gt;my $command&lt;/code&gt; line) first sets &lt;code&gt;$down&lt;/code&gt; to true if the key is being pressed or to false if the key is being released. The remaining changes replace the old &lt;code&gt;return $command&lt;/code&gt; line. For continuing commands (those that start with a &lt;code&gt;+&lt;/code&gt;), there&amp;rsquo;s a new class of command packet, containing both the &lt;code&gt;$command&lt;/code&gt; and the &lt;code&gt;$down&lt;/code&gt; boolean to indicate whether the command should begin or end. Single-shot commands (those without a leading &lt;code&gt;+&lt;/code&gt;), send a simple command packet only for keypresses; they ignore key releases.&lt;/p&gt;

&lt;p&gt;To handle the new class of command packets, I update &lt;code&gt;do_events&lt;/code&gt; as well:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub do_events
{
    my $self   = shift;

    my $queue  = $self-&amp;gt;process_events;
    my $lookup = $self-&amp;gt;{lookup}{command_action};
    my ($command, $action);

    while (not $self-&amp;gt;{state}{done} and @$queue) {
        my @args;
        $command          = shift @$queue;
        ($command, @args) = @$command if ref $command;

        $action = $lookup-&amp;gt;{$command} or next;
        $self-&amp;gt;$action($command, @args);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only new code is inside the loop. It starts off by assuming that the command packet is a simple one, with no arguments. If the command turns out to be a reference instead of a string, it unpacks it into a command string and some arguments. The &lt;code&gt;$action&lt;/code&gt; lookup remains unchanged, but the last line changes slightly to add &lt;code&gt;@args&lt;/code&gt; to the parameters of the action routine. If there are no arguments, this has no effect, so a single-shot action routine such as &lt;code&gt;action_quit&lt;/code&gt; can remain unchanged.&lt;/p&gt;

&lt;h5 id=&#34;view-meet-velocity&#34;&gt;View, Meet Velocity&lt;/h5&gt;

&lt;p&gt;The view needs to keep track of the current yaw velocity and the velocity delta when the user presses or releases a key; I initialize them to 0 in &lt;code&gt;init_view&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub init_view
{
    my $self = shift;

    $self-&amp;gt;{world}{view} = {
        position    =&amp;gt; [6, 2, 10],
        orientation =&amp;gt; [0, 0, 1, 0],
        d_yaw       =&amp;gt; 0,
        v_yaw       =&amp;gt; 0,
        dv_yaw      =&amp;gt; 0,
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;update_view&lt;/code&gt; needs a few more lines to handle the new variables:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub update_view
{
    my $self   = shift;

    my $view   = $self-&amp;gt;{world}{view};
    my $d_time = $self-&amp;gt;{world}{d_time};

    $view-&amp;gt;{orientation}[0] += $view-&amp;gt;{d_yaw};
    $view-&amp;gt;{d_yaw}           = 0;

    $view-&amp;gt;{v_yaw}          += $view-&amp;gt;{dv_yaw};
    $view-&amp;gt;{dv_yaw}          = 0;
    $view-&amp;gt;{orientation}[0] += $view-&amp;gt;{v_yaw} * $d_time;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After adding any velocity delta to the current yaw velocity, this method multiples the total yaw velocity by the time delta for this frame to determine the change in orientation. This is accumulated with the current orientation and any other facing change for this frame.&lt;/p&gt;

&lt;p&gt;Finally, I update &lt;code&gt;action_move&lt;/code&gt; to handle the new semantics:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub action_move
{
    my $self = shift;

    my ($command, $down) = @_;
    my $sign             = $down ? 1 : -1;
    my $view             = $self-&amp;gt;{world}{view};
    my $speed_yaw        = 36;
    my %move_update      = (
        &#39;+yaw_left&#39;  =&amp;gt; [dv_yaw =&amp;gt;  $speed_yaw],
        &#39;+yaw_right&#39; =&amp;gt; [dv_yaw =&amp;gt; -$speed_yaw],
    );
    my $update = $move_update{$command} or return;

    $view-&amp;gt;{$update-&amp;gt;[0]} += $update-&amp;gt;[1] * $sign;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;$sign&lt;/code&gt; variable converts the &lt;code&gt;$down&lt;/code&gt; parameter from &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;0&lt;/sub&gt; to +1/-1. I changed the last line of the routine to multiply the delta by this sign before updating the value. Adding a negated value is the same as subtracting the original value; this means that pressing a key requires adding the update, and releasing it will subtract it back out.&lt;/p&gt;

&lt;p&gt;To make sure the new yaw commands update velocity, I also fixed up the &lt;code&gt;%move_update&lt;/code&gt; hash to update &lt;code&gt;dv_yaw&lt;/code&gt; instead of &lt;code&gt;d_yaw&lt;/code&gt; and used the &lt;code&gt;+&lt;/code&gt; versions of the command names. Finally, to bring back the old rotation rate, I set &lt;code&gt;$speed_yaw&lt;/code&gt; to 36 degrees per second.&lt;/p&gt;

&lt;p&gt;This version responds the way most people expect. Holding down a key turns the proper direction until the key is released. What about when the user presses multiple keys at once? This is why I was careful always to accumulate updates and deltas by using &lt;code&gt;+=&lt;/code&gt; instead of plain old &lt;code&gt;=&lt;/code&gt;. If the user holds both the right and left arrow keys down at the same time, the view remains motionless because they&amp;rsquo;ve added in equal and opposite values to &lt;code&gt;dv_yaw&lt;/code&gt;. If the user releases just one of the keys, the view rotates in the proper direction for the key that is still held down because the opposing update has now been subtracted back out. Press the released key back down while still holding the other, and the rotation stops again as expected.&lt;/p&gt;

&lt;p&gt;Of course, there&amp;rsquo;s no requirement that the speeds for yawing left and right must be the same. In fact, for an airplane or spaceship simulation, the game engine might set these differently to represent damage to the control surfaces or maneuvering thrusters. It may even be part of the gameplay to hold both direction keys down at the same time to compensate partially for this damage, perhaps tapping one key while holding the other steady.&lt;/p&gt;

&lt;p&gt;One thing that &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; magically work is making sure that if several keys map to the same command, pressing them all won&amp;rsquo;t make the command take effect several times over. As it stands, the user could map five keys to the same movement command and move five times as fast. You might try fixing this on your own as a quick puzzle; I&amp;rsquo;ll try to address it in a later installment.&lt;/p&gt;

&lt;h5 id=&#34;eyes-in-the-back-of-your-head&#34;&gt;Eyes in the Back of Your Head&lt;/h5&gt;

&lt;p&gt;You might be curious why I left &lt;code&gt;d_yaw&lt;/code&gt; hanging around, since nothing uses it now. I could use it in the above-mentioned space simulation to simulate a thruster stuck on&amp;ndash;continuously trying to veer the ship off course. In a first-person game, it allows one of my favorite commands, &lt;code&gt;+look_behind&lt;/code&gt;. Holding down the appropriate key rotates the view 180 degrees. Releasing the key snaps the view back forward. To implement this, I need to add another entry to the &lt;code&gt;bind&lt;/code&gt; hash:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bind   =&amp;gt; {
    escape =&amp;gt; &#39;quit&#39;,
    left   =&amp;gt; &#39;+yaw_left&#39;,
    right  =&amp;gt; &#39;+yaw_right&#39;,
    tab    =&amp;gt; &#39;+look_behind&#39;,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then another &lt;code&gt;command_action&lt;/code&gt; entry:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub init_command_actions
{
    my $self = shift;

    $self-&amp;gt;{lookup}{command_action} = {
          quit         =&amp;gt; \&amp;amp;action_quit,
        &#39;+yaw_left&#39;    =&amp;gt; \&amp;amp;action_move,
        &#39;+yaw_right&#39;   =&amp;gt; \&amp;amp;action_move,
        &#39;+look_behind&#39; =&amp;gt; \&amp;amp;action_move,
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Last but not least, another entry in &lt;code&gt;%move_update&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my %move_update      = (
    &#39;+yaw_left&#39;    =&amp;gt; [dv_yaw =&amp;gt;  $speed_yaw],
    &#39;+yaw_right&#39;   =&amp;gt; [dv_yaw =&amp;gt; -$speed_yaw],
    &#39;+look_behind&#39; =&amp;gt; [d_yaw  =&amp;gt;  180       ],
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it: a whopping three lines, all of which were entries in lookup hashes.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;That&amp;rsquo;s it for this article; it&amp;rsquo;s already quite long. I started where I left off in the last article. From there, I talked about translation and rotation of the view; millisecond resolution SDL time; animation from jerky beginnings to smooth movement; basic SDL event and keyboard handling; single-shot and continuing commands; and a whole lot of refactoring.&lt;/p&gt;

&lt;p&gt;Next time, I&amp;rsquo;ll talk about moving the &lt;em&gt;position&lt;/em&gt; of the viewpoint, clean up &lt;code&gt;draw_view&lt;/code&gt;, and spend some more time on the OpenGL side of things with the basics of lighting and materials. In the meantime, I&amp;rsquo;ve covered quite a lot in this article, so go forth and experiment!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building a 3D Engine in Perl</title>
      <link>http://localhost:1313/pub/2004/12/01/3d_engine.html/</link>
      <pubDate>Wed, 01 Dec 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/12/01/3d_engine.html/</guid>
      <description>

&lt;p&gt;This article is the first in a series aimed at building a full 3D engine. It could be the underlying technology for a video game, the visualization system for a scientific application, the walkthrough program for an architectural design suite, or whatever.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: see also the rest of the series, &lt;a href=&#34;http://localhost:1313/pub/2004/12/29/3d_engine.html&#34;&gt;events and keyboard handling&lt;/a&gt;, &lt;a href=&#34;http://localhost:1313/pub/2005/02/17/3d_engine.html&#34;&gt;lighting and movement&lt;/a&gt;, and &lt;a href=&#34;http://localhost:1313/pub/2005/08/04/3d_engine.html&#34;&gt;profiling your application&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;First, I&amp;rsquo;ll set some goals and ground rules to help guide the design. I&amp;rsquo;m all for agile programming, but even the most agile development process needs some basic goals at the outset:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;I&amp;rsquo;m not going to make little demos. Early on, the engine won&amp;rsquo;t have much functionality, but it should always be a good foundation for future growth.&lt;/li&gt;
&lt;li&gt;The engine must be portable across architectures and operating systems. I will use OpenGL for 3D rendering and SDL for general, operating system interaction, such as input handling and window creation. The engine itself should contain almost no OS-specific code.&lt;/li&gt;
&lt;li&gt;The engine should be operational at every step of the way, from the very beginning. I will flesh it out over time, and there may be some complex concepts that take some time to work through, but at the very least, every article should end with the whole engine working again.&lt;/li&gt;
&lt;li&gt;I&amp;rsquo;ll leave out most error checking to save space and make the central concepts more clear. For the same reasons, there is no included test library. In your own engine, you will want to have both!&lt;/li&gt;
&lt;li&gt;Don&amp;rsquo;t be afraid to experiment. The best way to learn this stuff is to play with it. Start with what&amp;rsquo;s in the articles and add to it. Any time you spend now will repay itself many times over later, because it&amp;rsquo;s easier to understand advanced topics when you have a solid understanding of the earlier topics.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As a final note before we begin, some versions of SDL_Perl have bugs that will affect the engine. If I know of any issues to watch out for, I&amp;rsquo;ll let you know; conversely, if you find any bugs, let me know, and I&amp;rsquo;ll include a note in a following article.&lt;/p&gt;

&lt;h3 id=&#34;span-id-getting-started-getting-started-span&#34;&gt;&lt;span id=&#34;Getting Started&#34;&gt;Getting Started&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The first step is to rough out a simple structure and make a runnable program right off. Bear with me; there&amp;rsquo;s a fair bit of code here for what it does, but that will simplify things later on. Here&amp;rsquo;s my starting point:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/perl

use strict;
use warnings;

my ($done, $frame);

START: main();

sub main
{
    init();
    main_loop();
    cleanup();
}

sub init
{
    $| = 1;
}

sub main_loop
{
    while (not $done) {
        $frame++;
        do_frame();
    }
}

sub do_frame
{
    print &#39;.&#39;;
    sleep 1;
    $done = 1 if $frame == 5;
}

sub cleanup
{
    print &amp;quot;\nDone.\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first few lines are the usual strict boilerplate, especially important since I&amp;rsquo;m working without a net (a test library). Then I declare a couple of state variables (a &amp;ldquo;done&amp;rdquo; flag and a frame counter), and jump to the main program.&lt;/p&gt;

&lt;p&gt;The main program is pretty simple &amp;ndash; initialize, run the main loop for a while, and then clean up. It&amp;rsquo;s typical of how I structure a potentially complex program. The top-level routines should be very simple, clear, and self-documenting. Each conceptual piece is a separate routine, wherein reside all the gritty bits that actually do the real work. I&amp;rsquo;ve seen huge programs (hundreds of thousands of lines) where the main procedures started with several hundred lines of initialization before finally branching to the &amp;ldquo;real&amp;rdquo; main body at the end. That style is hard to debug, hard to profile, and just plain hard to understand. I avoid it religiously.&lt;/p&gt;

&lt;p&gt;Back to the program at hand. &lt;code&gt;init&lt;/code&gt; sets autoflush on &lt;code&gt;STDOUT&lt;/code&gt; so that partial lines print immediately, which I use later in &lt;code&gt;do_frame&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;main_loop&lt;/code&gt; simply loops until &lt;code&gt;$done&lt;/code&gt; is true, producing one finished animation frame per loop. Each loop increments the frame counter and calls the actual routine that does the work, &lt;code&gt;do_frame&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;do_frame&lt;/code&gt; prints a single dot to indicate a frame has begun, and sleeps for a second. When it wakes up, it checks if five frames have completed, flagging &lt;code&gt;$done&lt;/code&gt; if so.&lt;/p&gt;

&lt;p&gt;With &lt;code&gt;$done&lt;/code&gt; set, &lt;code&gt;main_loop&lt;/code&gt; ends and control returns to &lt;code&gt;main&lt;/code&gt;, which calls the final &lt;code&gt;cleanup&lt;/code&gt;. &lt;code&gt;cleanup&lt;/code&gt; just notifies the user of a clean exit and ends.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s a fair amount of code to print two lines of text (over the course of five seconds) and exit; it doesn&amp;rsquo;t even open a rendering window! I&amp;rsquo;ll do that next.&lt;/p&gt;

&lt;h3 id=&#34;span-id-creating-a-window-creating-a-window-span&#34;&gt;&lt;span id=&#34;Creating a Window&#34;&gt;Creating a Window&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;First, I need to pull in the SDL and OpenGL libraries:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use SDL::App;
use SDL::OpenGL; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and add a couple more state variables (a config hash and an &lt;code&gt;SDL::App&lt;/code&gt; object):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my ($conf, $sdl_app); 
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-initialization-initialization-span&#34;&gt;&lt;span id=&#34;Initialization&#34;&gt;Initialization&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;I&amp;rsquo;m going to do two new types of initialization, so I create routines for them and call them from &lt;code&gt;init&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub init
{
    $| = 1;
    init_conf();
    init_window();
}

sub init_conf
{
    $conf = {
        title  =&amp;gt; &#39;Camel 3D&#39;,
        width  =&amp;gt; 400,
        height =&amp;gt; 400,
    };
}

sub init_window
{
    my ($title, $w, $h) = @$conf{qw( title width height )};

    $sdl_app = SDL::App-&amp;gt;new(-title  =&amp;gt; $title,
                             -width  =&amp;gt; $w,
                             -height =&amp;gt; $h,
                             -gl     =&amp;gt; 1,
                            );
    SDL::ShowCursor(0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point, &lt;code&gt;init_conf&lt;/code&gt; just defines some configuration properties used immediately in &lt;code&gt;init_window&lt;/code&gt;, which contains the first real SDL meat.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;init_window&lt;/code&gt; performs two important actions. First, it asks &lt;code&gt;SDL::App&lt;/code&gt; to create a new window, with the appropriate title, width, and height. The &lt;em&gt;-gl&lt;/em&gt; option tells &lt;code&gt;SDL::App&lt;/code&gt; to attach an OpenGL 3D-rendering context to this window instead of the default 2D-rendering context. Second, it hides the mouse cursor (while it&amp;rsquo;s within the new window&amp;rsquo;s border) using &lt;code&gt;SDL::ShowCursor(0)&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-three-phases-of-drawing-three-phases-of-drawing-span&#34;&gt;&lt;span id=&#34;Three Phases of Drawing&#34;&gt;Three Phases of Drawing&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Now that I have a nice new window, I&amp;rsquo;d like &lt;code&gt;do_frame&lt;/code&gt; to do something with it. I&amp;rsquo;ll start by breaking the rendering into three phases: prepare, draw, and finish.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub do_frame
{
    prep_frame();
    draw_frame();
    end_frame();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For now, &lt;code&gt;draw_frame&lt;/code&gt; contains exactly what &lt;code&gt;do_frame&lt;/code&gt; used to contain:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub draw_frame
{
    print &#39;.&#39;;
    sleep 1;
    $done = 1 if $frame == 5;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The new code is in &lt;code&gt;prep_frame&lt;/code&gt; and &lt;code&gt;end_frame&lt;/code&gt;; let&amp;rsquo;s look at &lt;code&gt;prep_frame&lt;/code&gt; first:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub prep_frame
{
    glClear(GL_COLOR_BUFFER_BIT);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the first actual OpenGL call. Before I explain the details, it&amp;rsquo;s worth pointing out the OpenGL naming conventions. OpenGL&amp;rsquo;s design allows it to work with programming languages that have no concept of namespaces or packages. In order to work around this, all OpenGL routine names look like &lt;code&gt;glFooBar&lt;/code&gt; (CamelCase, no underscores, &lt;code&gt;gl&lt;/code&gt; prepended), and all OpenGL constant names look like &lt;code&gt;GL_FOO_BAR&lt;/code&gt; (UPPERCASE, underscores between words, &lt;code&gt;GL_&lt;/code&gt; prepended). In older languages, this prevents the OpenGL names from colliding with names used in other libraries. In the Perl world, this isn&amp;rsquo;t an issue for object-oriented modules. Because OpenGL is not object-oriented, SDL_Perl takes advantage of this convention and simply imports all of the names into the current package when you write &lt;code&gt;use SDL::OpenGL&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note: If you read OpenGL code written in C, you may notice a short string of characters appended to the routine names, such as &lt;code&gt;3fv&lt;/code&gt;. This convention differentiates variants that have different numbers of parameters or whose parameters are different types. In Perl, values know their own type and a function&amp;rsquo;s parameters can vary in number, so this is unnecessary. The Perl bindings simply drop these extra characters and &lt;code&gt;SDL::OpenGL&lt;/code&gt; do the right thing for you.&lt;/p&gt;

&lt;p&gt;The OpenGL call in &lt;code&gt;prep_frame&lt;/code&gt; clears the rendering area to black by calling &lt;code&gt;glClear&lt;/code&gt; &amp;ndash; the general OpenGL &amp;ldquo;clear a buffer&amp;rdquo; routine &amp;ndash; with a constant that indicates it should clear the &lt;em&gt;color buffer&lt;/em&gt;. As the name indicates, the color buffer stores the color for each pixel and is what the user sees. Several other OpenGL buffers exist; I&amp;rsquo;ll describe those later.&lt;/p&gt;

&lt;p&gt;The alert reader may wonder why the code clears the color buffer to black as opposed to white or some other color. OpenGL relies heavily on the concept of &lt;em&gt;current state&lt;/em&gt;. Many OpenGL routines do not actually request any rendering, instead altering one or more variables in the current state so that the next rendering command will perform its action differently. When a program prepares to use OpenGL, which &lt;code&gt;SDL::App::new&lt;/code&gt; does for us, the current state is set to (mostly) reasonable defaults. One of these state variables is the color to use when clearing the color buffer. Its default is black, which I haven&amp;rsquo;t bothered to override.&lt;/p&gt;

&lt;p&gt;The remaining routine is &lt;code&gt;end_frame&lt;/code&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub end_frame
{
    $sdl_app-&amp;gt;sync;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This asks the SDL::App object to synchronize the window contents with those held in OpenGL&amp;rsquo;s color buffer, so that the user can see the rendered image. In this case, it&amp;rsquo;s a black window for five seconds.&lt;/p&gt;

&lt;h3 id=&#34;span-id-something-to-see-something-to-see-span&#34;&gt;&lt;span id=&#34;Something to See&#34;&gt;Something to See&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s time to draw something in that window. To do so, I need to do three things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Choose a projection, so that OpenGL knows how I want to look at the scene.&lt;/li&gt;
&lt;li&gt;Set the view, so OpenGL knows from which direction to view the scene (the &lt;em&gt;viewpoint&lt;/em&gt;) and in which direction I wish to look.&lt;/li&gt;
&lt;li&gt;Define an object in the scene, placed where the viewpoint can see it.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To start, I need another config setting, so I&amp;rsquo;ll add another line to the &lt;code&gt;$conf&lt;/code&gt; hash in &lt;code&gt;init_conf&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        fovy   =&amp;gt; 90,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, for my three new functions, I add three new calls at the top of &lt;code&gt;draw_frame&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub draw_frame
{
    set_projection_3d();
    set_view_3d();
    draw_view();
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-choose-a-projection-choose-a-projection-span&#34;&gt;&lt;span id=&#34;Choose a Projection&#34;&gt;Choose a Projection&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;set_projection_3d&lt;/code&gt; is as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub set_projection_3d
{
    my ($fovy, $w, $h) = @$conf{qw( fovy width height )};
    my $aspect = $w / $h;

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity;
    gluPerspective($fovy, $aspect, 1, 1000);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the first place you can see an indication of the hard part of 3D graphics simmering below the surface &amp;ndash; math, and lots of it. 3D-rendering code often includes a fairly hefty load of linear algebra (matrix math, for those blocking out their high school and college years) and trigonometry. Thankfully, OpenGL does a lot of that math under the covers. I&amp;rsquo;ve also defined a fairly simple projection and view, so this hides a lot of the complexity for now (aside from some of the OpenGL function names).&lt;/p&gt;

&lt;p&gt;The first section of the routine defines the viewing projection. In the simplest case, that means choosing whether to use an &lt;em&gt;orthogonal&lt;/em&gt; projection or a &lt;em&gt;perspective&lt;/em&gt; projection. Orthogonal projections have no foreshortening. They commonly appear in architectural and engineering drawings, because parts that are the same size also appear the same size, no matter where they are in the scene.&lt;/p&gt;

&lt;p&gt;Perspective projections are what we see in the real world with our own eyes or with a camera; distant objects appear smaller than near objects. It&amp;rsquo;s also what you learn in a perspective drawing art class, in which the first assignment is commonly train tracks going off to the horizon. Tracks farther from the viewer appear closer together as does the spacing between the ties. To replicate the real world, I&amp;rsquo;ve chosen a perspective projection.&lt;/p&gt;

&lt;p&gt;In OpenGL, you not only have to decide between an orthogonal or perspective projection, you have to define its basic dimensions. In other words, how much can you see? For a perspective projection, you define the vertical &lt;em&gt;field of view&lt;/em&gt; (FOV), the &lt;em&gt;aspect ratio&lt;/em&gt; of the view, and the distance to the nearest and farthest things visible.&lt;/p&gt;

&lt;p&gt;The vertical FOV (&lt;code&gt;$fovy&lt;/code&gt; in the code) defines the angle from the viewpoint to the lowest and highest visible parts of the scene. If you imagine drawing what someone would see if she were standing with her eyes at the viewpoint, this represents her vertical peripheral vision. If you imagine a camera instead, this depends on the focal length of the lens. A telephoto lens has a very small FOV because the angle from the camera to the top and bottom visible objects is very small. Conversely, a wide-angle lens has a large FOV, and the FOV for a fisheye lens is even larger, approaching 180 degrees.&lt;/p&gt;

&lt;p&gt;The aspect ratio comes directly from the dimensions of the drawing area (width/height). This allows OpenGL to compensate for the stretching effect of a non-square window. In this case, the drawing area is square, so the aspect ratio is 1.&lt;/p&gt;

&lt;p&gt;After calculating the window&amp;rsquo;s aspect ratio, I tell OpenGL that I want to modify the projection and to start from a blank slate, using &lt;code&gt;glMatrixMode(GL_PROJECTION)&lt;/code&gt; and &lt;code&gt;glLoadIdentity&lt;/code&gt;. I then call &lt;code&gt;gluPerspective&lt;/code&gt; to define the desired perspective. You probably noticed that &lt;code&gt;gluPerspective&lt;/code&gt; begins with &lt;code&gt;glu&lt;/code&gt; instead of &lt;code&gt;gl&lt;/code&gt;, like all of the other calls we&amp;rsquo;ve seen. This is because I&amp;rsquo;m using one of the GLU (OpenGL Utility) routines to cover up some complexity in the equivalent raw OpenGL sequence.&lt;/p&gt;

&lt;p&gt;Finally, I switch back to model/view mode, and once again start with a blank slate, using &lt;code&gt;glMatrixMode(GL_MODELVIEW)&lt;/code&gt; and &lt;code&gt;glLoadIdentity&lt;/code&gt;. You may wonder why I don&amp;rsquo;t include this in the next routine instead of doing it here. I like to make sure routines that change a commonly used OpenGL state, simply as a side effect of their main purpose, return that state to the way they found it, especially if there is no net performance effect to doing so. In this case, I switch temporarily to projection mode and then switch back to the default model/view mode.&lt;/p&gt;

&lt;h4 id=&#34;span-id-set-the-view-set-the-view-span&#34;&gt;&lt;span id=&#34;Set the View&#34;&gt;Set the View&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The next step is to move the viewpoint to somewhere we can see the scene:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub set_view_3d
{
    # Move the viewpoint so we can see the origin
    glTranslate(0, -2, -10);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;m going to skip the detailed explanation for now, but in short the &lt;code&gt;glTranslate&lt;/code&gt; call leaves the viewpoint a few units away from (and above) the origin of the scene, where I&amp;rsquo;ll place my objects. I keep the default viewing direction, because it happens to point right where I want it to.&lt;/p&gt;

&lt;h4 id=&#34;span-id-define-an-object-define-an-object-span&#34;&gt;&lt;span id=&#34;Define an Object&#34;&gt;Define an Object&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;I&amp;rsquo;m going to start with a pretty simple scene &amp;ndash; just one object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub draw_view
{
    draw_axes();
}

sub draw_axes
{
    # Lines from origin along positive axes, for orientation
    # X axis = red, Y axis = green, Z axis = blue
    glBegin(GL_LINES);
    glColor(1, 0, 0);
    glVertex(0, 0, 0);
    glVertex(1, 0, 0);

    glColor(0, 1, 0);
    glVertex(0, 0, 0);
    glVertex(0, 1, 0);

    glColor(0, 0, 1);
    glVertex(0, 0, 0);
    glVertex(0, 0, 1);
    glEnd;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The lone object is itself quite simple, just three short lines extending from the origin along the X, Y, and Z axes. (I&amp;rsquo;m using &amp;ldquo;line&amp;rdquo; in the OpenGL sense, as a line segment, not the infinite line of rigorous mathematics.)&lt;/p&gt;

&lt;p&gt;In OpenGL, when you want to define something to render, you must notify OpenGL when you begin and end the definition; these are the &lt;code&gt;glBegin&lt;/code&gt; and &lt;code&gt;glEnd&lt;/code&gt; calls. In addition, you must tell OpenGL what type of &lt;em&gt;primitive&lt;/em&gt; you will use to create your object. There are several types of primitives, including points, lines, and triangles. In addition, each primitive type has variants based on how several primitives in a sequence connect (independently, connected in a strip, and so on). In this case, I use &lt;code&gt;GL_LINES&lt;/code&gt;, indicating independently placed line segments.&lt;/p&gt;

&lt;p&gt;I want each line to be a different color to make it easier to tell which is which. To set the current drawing color, I call &lt;code&gt;glColor&lt;/code&gt; with an RGB (Red, Green, Blue) triplet. In OpenGL, each color component can range from 0 (none) to 1 (full). Therefore, (1, 0, 0) indicates pure red, (0, 1, 0) is pure green, and so on. A medium gray is (.5, .5, .5). For further mnemonic value, I assign the colors so that the RGB triplets match the coordinates of the endpoints of the lines &amp;ndash; red for the X axis, green for Y, and blue for Z.&lt;/p&gt;

&lt;p&gt;For each line, after defining the color, I define the endpoints of the line using &lt;code&gt;glVertex&lt;/code&gt;. Each line begins at the origin and extends one unit along the appropriate axis. In other words, this sequence defines a red line from (0, 0, 0) to (1, 0, 0):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    glColor(1, 0, 0);
    glVertex(0, 0, 0);
    glVertex(1, 0, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With these routines in place, we finally have something to look at! As you can see, the X axis points to the right, the Y axis points up, and the Z axis points out of the screen toward the viewer (with OpenGL foreshortening it). Note the delay before the object first appears; that&amp;rsquo;s because the sleep at the end of &lt;code&gt;draw_frame&lt;/code&gt; creates a pause before &lt;code&gt;end_frame&lt;/code&gt; syncs the screen with the drawing area.&lt;/p&gt;

&lt;h3 id=&#34;span-id-moving-boxes-around-moving-boxes-around-span&#34;&gt;&lt;span id=&#34;Moving Boxes Around&#34;&gt;Moving Boxes Around&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Next, let&amp;rsquo;s try a box. Anyone who&amp;rsquo;s played a First Person Shooter game knows that their worlds have a surplus of boxes (a.k.a. &amp;ldquo;crates,&amp;rdquo; &amp;ldquo;storage containers,&amp;rdquo; and so on �- oddly, for &lt;em&gt;storage&lt;/em&gt; containers, the larger they are, the less they seem to contain). I&amp;rsquo;ll start with a simple cube and add another call for it to the end of &lt;code&gt;draw_view&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub draw_view
{
    draw_axes();
    draw_cube();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-defining-the-cube-defining-the-cube-span&#34;&gt;&lt;span id=&#34;Defining the Cube&#34;&gt;Defining the Cube&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Here&amp;rsquo;s the code that actually draws the cube:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub draw_cube
{
    # A simple cube
    my @indices = qw( 4 5 6 7   1 2 6 5   0 1 5 4
                      0 3 2 1   0 4 7 3   2 3 7 6 );
    my @vertices = ([-1, -1, -1], [ 1, -1, -1],
                    [ 1,  1, -1], [-1,  1, -1],
                    [-1, -1,  1], [ 1, -1,  1],
                    [ 1,  1,  1], [-1,  1,  1]);

    glBegin(GL_QUADS);
    foreach my $face (0 .. 5) {
        foreach my $vertex (0 .. 3) {
            my $index  = $indices[4 * $face + $vertex];
            my $coords = $vertices[$index];
            glVertex(@$coords);
        }
    }
    glEnd;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That looks pretty hairy, but it&amp;rsquo;s actually not bad. The &lt;code&gt;@vertices&lt;/code&gt; array contains the coordinates for a cube two units on a side, centered at the origin, with its sides aligned with the X, Y, and Z axes. The &lt;code&gt;@indices&lt;/code&gt; array defines which four vertices belong to each of the six faces of the cube and in what order to send them to OpenGL. The order is very important; I&amp;rsquo;ve arranged it so that, as seen from the outside, the vertices of each face draw in counterclockwise order. Using a consistent order helps OpenGL to determine the front and back side of each polygon; I&amp;rsquo;ve chosen to use the default counterclockwise order.&lt;/p&gt;

&lt;p&gt;After defining those arrays, I mark the beginning of a series of independent quadrilateral primitives using &lt;code&gt;glBegin(GL_QUADS)&lt;/code&gt;. I then iterate through each vertex of each face, finding the correct set of coordinates and sending them to OpenGL using &lt;code&gt;glVertex&lt;/code&gt;. Finally, I mark the end of this series of primitives using &lt;code&gt;glEnd&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Colloquial Perl purists will no doubt wonder why I have chosen C-style loops (with the attendant index math, yuck), rather than making &lt;code&gt;@indices&lt;/code&gt; an array of arrays. Mostly I&amp;rsquo;m just showing that it&amp;rsquo;s not too hard to deal with this type of input data. When the engine reads object descriptions from files, rather than hand-coded routines, the natural output of the file parser may be flattened. It&amp;rsquo;s often easier to do a little index math than to force the parser to output more structured data (and possibly more efficient too, but that&amp;rsquo;s a clear call for benchmarking).&lt;/p&gt;

&lt;p&gt;The result is one blue cube. Why blue? Since I never specified a new color to use, OpenGL went back to the current state and looked up the current drawing color. The last line in the axes was drawn in blue and that&amp;rsquo;s still the current color. Hence one blue cube.&lt;/p&gt;

&lt;h4 id=&#34;span-id-two-colored-boxes-two-colored-boxes-span&#34;&gt;&lt;span id=&#34;Two Colored Boxes&#34;&gt;Two Colored Boxes&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Let&amp;rsquo;s fix that. At the same time, we can move the new cube out of the way of the axes so we can see them again. Heck, I&amp;rsquo;ll go all out and have two cubes &amp;ndash; one to the left of the axis lines, and one to the right. The nice thing is that because I&amp;rsquo;m just drawing more of something I&amp;rsquo;ve already described, I just need to change &lt;code&gt;draw_view&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub draw_view
{
    draw_axes();

    glColor(1, 1, 1);
    glTranslate(-2, 0, 0);
    draw_cube();

    glColor(1, 1, 0);
    glTranslate( 2, 0, 0);
    draw_cube();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I set the current color to white using &lt;code&gt;glColor(1, 1, 1)&lt;/code&gt; before drawing the first cube, and to yellow using &lt;code&gt;glColor(1, 1, 0)&lt;/code&gt; before drawing the second cube. The &lt;code&gt;glTranslate&lt;/code&gt; calls should place the first cube two units to the left (along the negative X axis) and the second cube two units to the right (along the positive X axis).&lt;/p&gt;

&lt;h4 id=&#34;span-id-cumulative-transformations-cumulative-transformations-span&#34;&gt;&lt;span id=&#34;Cumulative Transformations&#34;&gt;Cumulative Transformations&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Unfortunately, no dice. The white cube is two units to the left, but the yellow cube is right on top of the axis lines again, not two units to the right as intended. This happened because &lt;code&gt;glTranslate&lt;/code&gt; calls (and the other transformation calls I&amp;rsquo;ll show later) are cumulative. Unlike routines such as &lt;code&gt;glColor&lt;/code&gt; that simply set the current state, most transformation calls instead modify the current state in a certain way. Because of this, the first cube starts at (-2, 0, 0), and the second starts at (-2, 0, 0) + (2, 0, 0) = (0, 0, 0) &amp;ndash; right back at the origin again.&lt;/p&gt;

&lt;p&gt;The solution to this problem requires peeking under the covers a little bit. OpenGL transformation calls really just set up a special matrix representing the effect that the requested transformation has on coordinates. OpenGL then multiplies the current matrix by this new transformation matrix and replaces the current matrix with the results of the multiplication.&lt;/p&gt;

&lt;p&gt;What I need to fix this problem is some way to save the current matrix before performing a transformation, and then restore it after I&amp;rsquo;m done with it. Thankfully, OpenGL actually maintains a stack of matrices of each type. I just need to push a copy of the current matrix onto the stack before drawing the white cube, and pop that copy off again afterwards to get back to the state before I did my translation. I&amp;rsquo;m going to do this for both cubes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub draw_view
{
    draw_axes();

    glColor(1, 1, 1);
    glPushMatrix;
    glTranslate(-2, 0, 0);
    draw_cube();
    glPopMatrix;

    glColor(1, 1, 0);
    glPushMatrix;
    glTranslate( 2, 0, 0);
    draw_cube();
    glPopMatrix;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s a bit better. The yellow cube now has its origin at (2, 0, 0), just as intended.&lt;/p&gt;

&lt;h3 id=&#34;span-id-other-transformations-other-transformations-span&#34;&gt;&lt;span id=&#34;Other Transformations&#34;&gt;Other Transformations&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Earlier I referred to other transformation calls; let&amp;rsquo;s take a look at a few of them. First, I&amp;rsquo;ll scale the boxes (change their size). I&amp;rsquo;m going to scale the left (white) box uniformly &amp;ndash; in other words, scaling each of its dimensions by the same amount. To show the difference, I&amp;rsquo;ll scale the right (yellow) box non-uniformly, with each dimension scaled differently. Here&amp;rsquo;s the new &lt;code&gt;draw_view&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub draw_view
{
    draw_axes();

    glColor(1, 1, 1);
    glPushMatrix;
    glTranslate(-4, 0, 0);
    glScale( 2, 2, 2);
    draw_cube();
    glPopMatrix;

    glColor(1, 1, 0);
    glPushMatrix;
    glTranslate( 4, 0, 0);
    glScale(.2, 1, 2);
    draw_cube();
    glPopMatrix;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the white box, I just doubled each dimension; the parameters to &lt;code&gt;glScale&lt;/code&gt; are X, Y, and Z multipliers. For the yellow box, I shrunk the X dimension by a factor of 5 (multiplied by .2), left Y alone, and doubled the Z dimension. The boxes are now big enough that I&amp;rsquo;ve also pushed them farther apart, hence the updated values for &lt;code&gt;glTranslate&lt;/code&gt; that place them four units on either side of the scene origin.&lt;/p&gt;

&lt;h4 id=&#34;span-id-watch-the-rotation-watch-the-rotation-span&#34;&gt;&lt;span id=&#34;Watch the Rotation&#34;&gt;Watch the Rotation&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;I&amp;rsquo;ve done translation and scaling; next up is rotation. To save space here, I&amp;rsquo;ll demonstrate on the yellow cube alone. Here&amp;rsquo;s the new code snippet:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    glColor(1, 1, 0);
    glPushMatrix;
    glRotate( 40, 0, 0, 1);
    glTranslate( 4, 0, 0);
    glScale(.2, 1, 2);
    draw_cube();
    glPopMatrix;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The parameters to &lt;code&gt;glRotate&lt;/code&gt; are the number of degrees to rotate and the axis around which to do the rotation. In this case, I chose to rotate 40 degrees around the Z axis (0, 0, 1). The direction of rotation follows the general pattern in OpenGL &amp;ndash; a positive value means counterclockwise when looking down the rotation axis toward the origin.&lt;/p&gt;

&lt;h4 id=&#34;span-id-order-of-transforms-order-of-transforms-span&#34;&gt;&lt;span id=&#34;Order of Transforms&#34;&gt;Order of Transforms&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;This produces a flying yellow box in the upper-right quadrant. Remember when I said that each new transformation is cumulative? The order matters. To understand why, I like to imagine each transformation as moving, rotating, or scaling the coordinate system in which I draw my objects. In this case, by rotating first, I certainly rotated the box, but I really rotated the entire coordinate system in which I defined the box. This meant the &lt;code&gt;glTranslate&lt;/code&gt; call that immediately follows the rotation translated out along a rotated X axis, 40 degrees above the scene&amp;rsquo;s X axis, to be precise.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll move the rotation after the other two transformations to fix that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    glTranslate( 4, 0, 0);
    glScale(.2, 1, 2);
    glRotate( 40, 0, 0, 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the box isn&amp;rsquo;t flying, but it does appear squashed in an odd way. The problem here is that because the nifty, non-uniform scaling happens before the rotation, I&amp;rsquo;m now trying to rotate through a space where the dimensions are different sizes. Putting the rotation in the middle fixes it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    glTranslate( 4, 0, 0);
    glRotate( 40, 0, 0, 1);
    glScale(.2, 1, 2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you compare this rendering from this version with the program with no &lt;code&gt;glRotate&lt;/code&gt; call, you should see that it does the right thing now.&lt;/p&gt;

&lt;h3 id=&#34;span-id-whoa-deep-whoa-deep-span&#34;&gt;&lt;span id=&#34;Whoa, Deep!&#34;&gt;Whoa, Deep!&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The last item I wanted to bring up is what to do when something near the back draws after something near the front. To see what I mean, I&amp;rsquo;ll move the white box so that instead of being four units to the left of the scene origin, it is four units behind it (along the negative Z axis). That merely involves changing the white box&amp;rsquo;s &lt;code&gt;glTranslate&lt;/code&gt; call from this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    glTranslate(-4, 0, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    glTranslate( 0, 0, -4);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, even though the white box should appear behind the axis lines, it instead appears in front because OpenGL drew it after the axis lines. By default, OpenGL assumes you intended to do this (it is more efficient to make this assumption), but I didn&amp;rsquo;t. To fix this, I need to tell OpenGL to pay attention to the depth of the various objects in the scene and not to overwrite near objects with far ones.&lt;/p&gt;

&lt;p&gt;To do this, I need to enable OpenGL&amp;rsquo;s &lt;em&gt;depth buffer&lt;/em&gt;. This is similar to the color buffer, which stores the color of every pixel drawn. Instead of storing the color, however, it stores the depth (distance from the viewpoint along the viewing direction) of every pixel. Just like the color buffer, I need to clear the depth buffer each frame. Instead of clearing it to black, OpenGL clears it to the maximum depth value, so that any later rendering within the visible scene will be closer.&lt;/p&gt;

&lt;p&gt;I also need to tell OpenGL that it should perform a test each time it wants to draw a pixel, comparing the depth of the new pixel with what&amp;rsquo;s already in the depth buffer. If the new pixel is farther from the viewer than the pixel it is about to replace, it&amp;rsquo;s safe to ignore the new pixel and to leave alone the old color. Here&amp;rsquo;s the updated &lt;code&gt;prep_frame&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub prep_frame
{
    glClear(GL_COLOR_BUFFER_BIT |
            GL_DEPTH_BUFFER_BIT );

    glEnable(GL_DEPTH_TEST);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this version, I tell &lt;code&gt;glClear&lt;/code&gt; to clear both the color buffer and the depth buffer. You can now see why the constant names end with &lt;code&gt;_BIT&lt;/code&gt;; they are, in fact, bit masks. The reason for this odd interface is purely efficiency &amp;ndash; some OpenGL implementations can very rapidly clear all requested buffers simultaneously, and making the request for all needed buffers in just one call allows this optimization. As for the choice of bit mask rather than a list of constants, SDL_Perl reflects the underlying C interface, so that people comfortable with that can more easily cross over to using OpenGL under Perl.&lt;/p&gt;

&lt;p&gt;The second routine I call, &lt;code&gt;glEnable&lt;/code&gt;, is actually one of the most commonly used OpenGL routines, despite the fact that this is the first we&amp;rsquo;ve seen of it. Much of the OpenGL current state is a set of flags that tell OpenGL when to do (or not do) certain things. &lt;code&gt;glEnable&lt;/code&gt; and the corresponding &lt;code&gt;glDisable&lt;/code&gt; set these flags as desired. In this case, I turn on the flag that tells OpenGL to perform the depth test, throwing away pixels drawn in the wrong order.&lt;/p&gt;

&lt;p&gt;With these changes, we can now once again see the axis lines, this time in front of the white box where they belong.&lt;/p&gt;

&lt;h3 id=&#34;span-id-conclusion-conclusion-span&#34;&gt;&lt;span id=&#34;Conclusion&#34;&gt;Conclusion&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The final results may look simple, but we&amp;rsquo;ve come a long way. I started with some basic boilerplate and a simple main loop. I didn&amp;rsquo;t even load SDL or OpenGL or open a window. By the end, I&amp;rsquo;d added a window to draw on; projection and viewing setup; multiple objects of different types, built using different OpenGL primitives, drawn in different colors, and transformed several different ways; and correct handling of out-of-order drawing.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s a lot for now, but we&amp;rsquo;re just starting. Next time I&amp;rsquo;ll cover moving the viewpoint, SDL keyboard handling, and compensating for frame rate variations. I&amp;rsquo;ll build on the &lt;a href=&#34;http://localhost:1313/media/_pub_2004_12_01_3d_engine/perl_opengl_examples.tar.gz&#34;&gt;example source code&lt;/a&gt; built in this article, so feel free to download it and use it for your own applications.&lt;/p&gt;

&lt;p&gt;In the meantime, if you&amp;rsquo;d like to learn more visit the &lt;a href=&#34;http://www.opengl.org/&#34;&gt;OpenGL&lt;/a&gt; and &lt;a href=&#34;http://www.libsdl.org/&#34;&gt;SDL&lt;/a&gt; websites; each contains (and links to) mountains of information.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

