<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Books and Magazines on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/books-and-magazines/</link>
    <description>Recent content in Books and Magazines on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 27 Feb 2003 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/books-and-magazines/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Genomic Perl</title>
      <link>http://localhost:1313/pub/2003/02/27/review.html/</link>
      <pubDate>Thu, 27 Feb 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/02/27/review.html/</guid>
      <description>&lt;p&gt;This is a book I have been looking forward to for a long time. Back when James Tisdall had just finished his &lt;a href=&#34;http://www.oreilly.com/catalog/begperlbio/&#34;&gt;Beginning Perl for Bioinformatics&lt;/a&gt;, I asked him to write an article about &lt;a href=&#34;http://localhost:1313/pub/2002/01/02/bioinf.html&#34;&gt;how to get into bioinf&lt;/a&gt; from a Perl programmer&amp;rsquo;s perspective. With bioinformatics being a recently booming sphere and many scientists finding themselves in need of computer programmers to help them process their data, I thought it would be good if there was more information for programmers about the genomic side of things.&lt;/p&gt;

&lt;p&gt;Rex Dwyer has produced a book, &lt;a href=&#34;http://books.cambridge.org/052180177X.htm&#34;&gt;Genomic Perl&lt;/a&gt;, which bridges the gap. As well as teaching basic Perl programming techniques to biologists, it introduces many useful genetic concepts to those already familiar with programming. Of course, as a programmer and not a biologist, I&amp;rsquo;m by no means qualified to assess the quality of that side of the book, but I certainly learned a lot from it.&lt;/p&gt;

&lt;p&gt;The first chapter, for instance, taught the basics of DNA transcription and translation, the basics of Perl string handling, and tied the two concepts together with an example of transcription in Perl. This is typical of the format of the book - each chapter introduces a genetic principle and a related problem, a Perl principle which can be used to solve the problem, and a program illustrates both. It&amp;rsquo;s a well thought-out approach which deftly caters for both sides of the audience.&lt;/p&gt;

&lt;p&gt;However, it should be stressed that the book is a substitute neither for a good introductory book on Perl nor a good textbook on genetics; and indeed, I think it will turn out to be better for programmers who need an over-arching idea of some of the problems involved with bioinformatics than for biologists who need to turn out working code. For instance, when it states that a hash is the most convenient data structure for looking up amino acids by their codons, it doesn&amp;rsquo;t say why, or even what a hash is. On the other hand, amino acids and codons are both explained in detail.&lt;/p&gt;

&lt;p&gt;The book covers a wide range of biological areas - from the structure of DNA to building predictive models of species, exploring the available databases of genetic sequences including readers of the GenBank database and an implementation of the BLAST algorithm, phylology, protein databases, DNA sequence assembly and prediction, restriction mapping, and a lot more besides. In all, it&amp;rsquo;s a good overview of the common areas in which biologists need computer programs.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s a significant but non-threatening amount of math in there, particularly in dealing with probabilities of mutation and determining whether or not events are significant, but I was particularly encouraged to see discussion of algorithmic running time; as the author is primarily a computer science professor and secondarily a bioinformaticists, this should not be too surprising. However, a significant number of bioinformaticists tend to produce code which works&amp;hellip; eventually. Stopping to say &amp;ldquo;well, this is order n-to-the-6 and we can probably do better than that&amp;rdquo; is most welcome.&lt;/p&gt;

&lt;p&gt;Onto the code itself. The first thing any reader will notice about the book is that the code isn&amp;rsquo;t monospaced. Instead, the code is &amp;ldquo;ground&amp;rdquo;, pretty-printed, as in days of old. This means you&amp;rsquo;ll see code snippets like:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;next unless&lt;/strong&gt; $succReadSite; &lt;em&gt;## dummy sinks have no successor&lt;/em&gt;
&lt;strong&gt;my&lt;/strong&gt; $succContigSite = $classNames-&amp;gt;find($succReadSite);&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now, I have to admit I really like this, but others may find it difficult to read, and those who know slightly less Perl may find it confusing - the distinction between &amp;ldquo; and &amp;rdquo; (that&amp;rsquo;s two single quotes and a double quote) can be quite subtle, and if you&amp;rsquo;re going to grind Perl code, regular expressions really, really ought to be monospaced. &amp;ldquo;&lt;span style=&#34;font-family:sans-serif&#34;&gt;$elem =~ /^[(^\[(]*)(\(.*\))?$/;&lt;/span&gt;&amp;rdquo; is just plain awkward.&lt;/p&gt;

&lt;p&gt;The code is more idiomatic than much bioinformatic code that I&amp;rsquo;ve seen, but still feels a little unPerlish; good use is made of references, callbacks and object oriented programming, but three-argument &lt;code&gt;for&lt;/code&gt; is used more widely than the fluent Perl programmer would have it, and things like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    main();
    sub main {
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;worry me somewhat. But it works, it&amp;rsquo;s efficient, and it&amp;rsquo;s certainly enough to get the point across.&lt;/p&gt;

&lt;p&gt;The appendices were enlightening and well thought-out: the first turns an earlier example, RNA structure folding, into a practical problem of drawing diagrams of folded RNA for publication; the other two tackle matters of how to make some of the algorithms in the text more efficient.&lt;/p&gt;

&lt;p&gt;All in all, I came away from this book not just with more knowledge about genetics and biology - indeed, some of what I learned has been directly applicable to some work I have - but also with an understanding of some of the complexity of the problems geneticists face. It fully satisfies its goals, expressed in the preface: teaching computer scientists the biological underpinnings of bioinformatics, providing real, working code for biologists without boring the programmers, and providing an elementary handling of the statistical considerations of the subject matter. While it will end up being more used by programmers getting into the field, it&amp;rsquo;s still useful for the biologists already there, particularly when combined with something like James Tisdall&amp;rsquo;s book or &lt;a href=&#34;http://www.oreilly.com/catalog/lperl3&#34;&gt;Learning Perl&lt;/a&gt;. But for the programmer like me, interested in what biologists do and how we can help them do it, it&amp;rsquo;s by far the clearest introduction available, and I would heartily recommend it.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Embedding Perl in HTML with Mason</title>
      <link>http://localhost:1313/pub/2003/01/30/review.html/</link>
      <pubDate>Thu, 30 Jan 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/01/30/review.html/</guid>
      <description>&lt;p&gt;&lt;em&gt;Disclaimer&lt;/em&gt;: As you know, each month I try to review a recently published Perl book, and I aim to cover all the majors as they come out. The book that&amp;rsquo;s fallen onto my desk for review this month is Dave Rolsky and Ken Williams&amp;rsquo; &lt;a href=&#34;http://www.oreilly.com/catalog/perlhtmlmason&#34;&gt;Embedding Perl in HTML with Mason&lt;/a&gt; &amp;ldquo;What is this,&amp;rdquo; you&amp;rsquo;re thinking, &amp;ldquo;an O&amp;rsquo;Reilly site doing a review of an O&amp;rsquo;Reilly book? Scandalous!&amp;rdquo; Well, I hope that you&amp;rsquo;ve taken a look at my other reviews and have satisfied yourself that I try to be as impartial as I can when reviewing. As far as I&amp;rsquo;m concerned, this is a Perl site first and an O&amp;rsquo;Reilly site second.&lt;/p&gt;

&lt;p&gt;With that disclaimer out of the way, onto the book! There are plenty of ways of achieving the Perl-in-HTML goal, as this book correctly points out: the &lt;a href=&#34;http://www.template-toolkit.org/&#34;&gt;Template Toolkit&lt;/a&gt;, the venerable &lt;a href=&#34;http://perl.apache.org/embperl/&#34;&gt;embperl&lt;/a&gt;, and so on. My personal favorite, however, is &lt;a href=&#34;http://www.masonhq.com/&#34;&gt;&lt;code&gt;HTML::Mason&lt;/code&gt;&lt;/a&gt;, and so I&amp;rsquo;ve been looking forward to this book for a long time. That also means, however, that I&amp;rsquo;ve had high expectations of it; Rolsky and Williams&amp;rsquo; effort has lived up to many of them but let me down in a few areas.&lt;/p&gt;

&lt;p&gt;The first chapter does a good job of setting the scene - it describes a little of what Mason looks like, talks about some of the alternatives to Mason, and shows how to install the module and test it. While the first description is precisely what is needed, and the test process is well-documented, I feel more could have been made of the comparison to other techniques - tools such as PHP and Template Toolkit are described, but they&amp;rsquo;re not compared to Mason, so it&amp;rsquo;s hard to see their relative strengths and weaknesses. Similarly, the installation process for Mason is quite detailed, and brushing it off with &amp;ldquo;&lt;code&gt;perl Makefile.PL; make; make install&lt;/code&gt;&amp;rdquo; doesn&amp;rsquo;t do it justice - an example of the output would make readers feel more comfortable.&lt;/p&gt;

&lt;p&gt;The book then goes on to introduce the main syntax of Mason components. This is a useful section and I learned a lot about various ways Mason tags are interpreted, but I felt it would have been better structured with more examples building on top of one another; that said, the chapter did declare itself to be an introduction to Mason syntax and semantics, and as that, it succeeded - however, I think it would have been a better tutorial if both semantics and syntax were covered.&lt;/p&gt;

&lt;p&gt;The short chapter on autohandlers and dhandlers was a sermon from the clouds. I&amp;rsquo;ve long known that these things existed and were powerful, but until reading chapter 3, I didn&amp;rsquo;t quite know how they should be used. The section on the Mason API again unfortunately suffers from a lack of examples; but on the other hand, the book builds up to a full example in chapter 8. The &amp;ldquo;advanced features&amp;rdquo; chapter was a complete goldmine of information. Like many of these early chapters, it contains a lot of concentrated goodness in not many pages, and it will take me several more readings to pick out and understand more of the ideas.&lt;/p&gt;

&lt;p&gt;Chapter 6, another short (10 page) chapter on the &amp;ldquo;lexer compiler, resolver and interpreter objects&amp;rdquo; seems to be included for completeness or for hard-core Mason hackers - it could be skipped or moved to an appendix with no loss of flow or coverage.&lt;/p&gt;

&lt;p&gt;As I&amp;rsquo;ve mentioned, chapter 8 is where it all comes together: a full, real-life application (the &lt;a href=&#34;http://apprentice.perl.org/&#34;&gt;Perl Apprenticeship site&lt;/a&gt; - an interesting resource in its own right!) is put together before your very eyes. As this is a real live site, areas such as creating user accounts and handling access control have to be covered. If you&amp;rsquo;re doing anything at all with Mason, then I&amp;rsquo;d urge you to buy this book if only for this chapter - once you&amp;rsquo;ve worked through it, you&amp;rsquo;ll have a much clearer idea of how a Mason site fits together.&lt;/p&gt;

&lt;p&gt;Later chapters cover mixing Mason and CGI, another brief (8 page) chapter on design, and another gold mine chapter of recipes. Chapters like this and the advanced topics chapter are the reason you buy books on open source projects: sure, there may be free documentation&amp;rsquo;s there - and the Mason documentation is pretty thorough - but it doesn&amp;rsquo;t directly tell you how to do what you want to do. The documentation doesn&amp;rsquo;t often cover the situations you find yourself in when you&amp;rsquo;re actually developing with the tool in question; I&amp;rsquo;m happy to say that this book does.&lt;/p&gt;

&lt;p&gt;Appendices cover the Mason API, (which is odd, given chapter 4 covers that &amp;hellip;) the Mason-object model, using Mason with your favorite text editor (a surprisingly useful set of information!) and information about Bricolage, a Mason-based context management system; useful as yet another set of ideas for what Mason can do.&lt;/p&gt;

&lt;p&gt;On an aesthetic note, kudos to O&amp;rsquo;Reilly for restoring the spine coloring - now my bookshelf can be color-coded again; now bring back Garamond!&lt;/p&gt;

&lt;p&gt;If I&amp;rsquo;ve sounded at all negative in this review, then it&amp;rsquo;s probably because I&amp;rsquo;ve been expecting this book for a while and have had high hopes for it. That said, my overall impression of this book is that it&amp;rsquo;s a little thin - short chapters and few worked examples leave one wanting more. On the other hand, the full example in chapter 8 is worth its weight in gold, and when combined with the advanced concept and cookbook chapters, I&amp;rsquo;d give this book a qualified thumbs-up for anyone doing any Mason work.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

