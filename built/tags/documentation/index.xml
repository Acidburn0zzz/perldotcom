<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Documentation on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/documentation/</link>
    <description>Recent content in Documentation on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 26 Feb 2015 13:42:57 +0000</lastBuildDate>
    <atom:link href="/tags/documentation/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Hello perldoc, productivity booster</title>
      <link>http://localhost:1313/article/155/2015/2/26/Hello-perldoc--productivity-booster/</link>
      <pubDate>Thu, 26 Feb 2015 13:42:57 +0000</pubDate>
      
      <guid>http://localhost:1313/article/155/2015/2/26/Hello-perldoc--productivity-booster/</guid>
      <description>

&lt;p&gt;Imagine this scenario: you&amp;rsquo;re using the DateTime module but you can&amp;rsquo;t remember the exact name of a function it provides. What do you do? You could open your browser, go to &lt;a href=&#34;https://metacpan.org/&#34;&gt;MetaCPAN&lt;/a&gt;, search for DateTime and look up the answer in the module&amp;rsquo;s documentation. A faster way would be to switch to the command line, and type &lt;code&gt;perldoc DateTime&lt;/code&gt; to display the module&amp;rsquo;s documentation right there in the terminal.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;perldoc&lt;/code&gt; is a command line program for reading Perl documentation. It comes with Perl, so if you&amp;rsquo;ve got Perl installed, perldoc should be available too. Using perldoc is easy: as you&amp;rsquo;ve already seen, to view the documentation of a module you&amp;rsquo;ve installed, at the command line type:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ perldoc Module::Name&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;perldoc will search for the module and if it finds it, display the module&amp;rsquo;s documentation (written in Pod). Using perldoc you can learn more about any aspect of Perl almost instantly. Want to know more about Pod? Try &lt;code&gt;perldoc pod&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;dial-f-for-functions&#34;&gt;Dial -f for functions&lt;/h3&gt;

&lt;p&gt;Perl has a huge number of built-in functions, about 224 depending on the Perl version. Who can remember exactly how they all work? I know I can&amp;rsquo;t. To lookup a Perl function, use perldoc with the &lt;code&gt;-f&lt;/code&gt; switch. For instance to look up the documentation on the &lt;code&gt;rindex&lt;/code&gt; function:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ perldoc &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;f rindex&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which will display:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rindex STR,SUBSTR,POSITION
rindex STR,SUBSTR
      Works just like index() except that it returns the position of the
      last occurrence of SUBSTR in STR. If POSITION is specified,
      returns the last occurrence beginning at or before that position.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aha! This is all well and good, but what do you do if you can&amp;rsquo;t remember the function name? Well you could use &lt;a href=&#34;https://metacpan.org/pod/B::Keywords&#34;&gt;B::Keywords&lt;/a&gt;, but another way would be to check out &lt;code&gt;perlfunc&lt;/code&gt; the Perl documentation on built-in functions. To read it, with perldoc just type:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ perldoc perlfunc&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;predefined-variables&#34;&gt;Predefined Variables&lt;/h3&gt;

&lt;p&gt;As with functions, Perl has a large number of predefined variables that do everything from storing the program name to tracking the state of the regex engine. They&amp;rsquo;re really useful, but often have obscure names like &lt;code&gt;$^O&lt;/code&gt; (the OS name). So if you find yourself needing to check whether you&amp;rsquo;re looking at a list separator (&lt;code&gt;$&amp;quot;&lt;/code&gt;) or an output separator (&lt;code&gt;$/&lt;/code&gt;), just use perldoc with the &lt;code&gt;-v&lt;/code&gt; switch:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ perldoc &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;v $/&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Because some predefined variables have weird names, you may need to quote them on the command line for perldoc to work:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ perldoc &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;v &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;$&amp;#34;&amp;#39;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The predefined variables documentation is known as &lt;code&gt;perlvar&lt;/code&gt;. It&amp;rsquo;s well worth a read through at least once (&lt;code&gt;perldoc perlvar&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&#34;searching-the-documentation&#34;&gt;Searching the documentation&lt;/h3&gt;

&lt;p&gt;Perl has a lot of great documentation, but it can be hard to remember the names of all of the entries. If you ever want to browse the table of contents, use &lt;code&gt;perl&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ perldoc perl&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Many people recommend perltoc for this, but for finding relevant entries, I think the perl entry is easier to browse than perltoc.&lt;/p&gt;

&lt;p&gt;Perl also has an extensive FAQ, (another entry that&amp;rsquo;s worth a read through). It has loads of answers to common queries. As usual you can read it with &lt;code&gt;perldoc faq&lt;/code&gt;, but you can also search it using the &lt;code&gt;-q&lt;/code&gt; switch. Want to know if there are any good IDEs for Perl? (a common newbie question):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ perl &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;q ide&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Is there an IDE or Windows Perl Editor?
 Perl programs are just plain text, so any editor will do.

 If you&#39;re on Unix, you already have an IDE--Unix itself. The Unix
 philosophy is the philosophy of several small tools that each do one thing
 and do it well. It&#39;s like a carpenter&#39;s toolbox.

 If you want an IDE, check the following (in alphabetical order, not order
 of preference):

 Eclipse


     The Eclipse Perl Integration Project integrates Perl editing/debugging
     with Eclipse.

 Komodo


     ActiveState&#39;s cross-platform (as of October 2004, that&#39;s Windows,
     Linux, and Solaris), multi-language IDE has Perl support, including a
     regular expression debugger and remote debugging.
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;finding-module-install-locations&#34;&gt;Finding module install locations&lt;/h3&gt;

&lt;p&gt;perldoc isn&amp;rsquo;t just about documentation. If you need to find out where a module is installed, using the &lt;code&gt;-l&lt;/code&gt; switch, perldoc will return the filepath of the module:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ perldoc &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;l Test::More&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you get the path, you can open it in an editor directly:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ vi $&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;(&lt;/span&gt;perldoc &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;l Test::More)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;One trick here: some modules don&amp;rsquo;t have any POD in them, for those modules, use &lt;code&gt;-lm&lt;/code&gt; to still return the path.&lt;/p&gt;

&lt;h3 id=&#34;read-module-source-code-in-perldoc&#34;&gt;Read module source code in perldoc&lt;/h3&gt;

&lt;p&gt;Finally, perldoc can also display module source code. Just use the &lt;code&gt;-m&lt;/code&gt; switch:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ perldoc &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;m Test::More&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;wrap-up&#34;&gt;Wrap up&lt;/h3&gt;

&lt;p&gt;This article has covered the most common features, but perldoc has a bunch of other capabilities that you can read about at the command line with &lt;code&gt;man perldoc&lt;/code&gt;. The Perl documentation is also &lt;a href=&#34;http://perldoc.perl.org/&#34;&gt;online&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Keep in mind that as you get more proficient with perldoc, you&amp;rsquo;ll need the online resources less and less. Get in the habit of switching to the command line, looking up something in perldoc and flipping right back to programming - it&amp;rsquo;s a productivity win.&lt;/p&gt;

&lt;h3 id=&#34;perldoc-cheatsheet&#34;&gt;perldoc cheatsheet&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;perldoc [option]

Module Options                               
--------------                               
         Module documentation     
-l       Module filepath          
-lm      Module filepath (alt.)   
-m       Module source


Search Options
--------------
-f     Get a built-in function definition
-v     Get a variable definition
-q      Search the faq for a keyword


Commonly Used Entries
---------------------
perl         Language overview, list of all other entries
perltoc      Table of contents
perlfunc     Built-in functions documentation
perlvar      Predefined variables documentation
perlref      References documentation
perlre       Regex documentation
faq          The Perl FAQ

Help
----
man perldoc     List of all perldoc options
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Perl distributions, modules, packages explained</title>
      <link>http://localhost:1313/article/96/2014/6/13/Perl-distributions--modules--packages-explained/</link>
      <pubDate>Fri, 13 Jun 2014 12:26:00 +0000</pubDate>
      
      <guid>http://localhost:1313/article/96/2014/6/13/Perl-distributions--modules--packages-explained/</guid>
      <description>

&lt;p&gt;&lt;em&gt;It can be confusing for new Perl programmers to understand the terminology used to describe Perl distributions and their accompanying files. This article explains the core concepts.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;package-module-distribution&#34;&gt;Package, Module, Distribution&lt;/h3&gt;

&lt;p&gt;A Perl package is just a section of code defined in a .pm file, like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;package&lt;/span&gt; Data::Connector;

&lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;connect&lt;/span&gt; {
    &lt;span style=&#34;color:#75715e&#34;&gt;# do something&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
}
&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The start of the package begins with the &amp;ldquo;package&amp;rdquo; declaration. A package is a lot like a class, except that it can denote a collection of subroutines and variables, and not necessarily be instantiated as an object. Usually a .pm file will have one package declaration per file, but you can have multiple packages in a .pm file, similar to Java and C# where you can have multiple classes in a single file.&lt;/p&gt;

&lt;p&gt;A module is a .pm file (&amp;ldquo;pm&amp;rdquo; means Perl Module). When you import a module with &amp;ldquo;require&amp;rdquo; or &amp;ldquo;use&amp;rdquo;, you are literally referencing the file name and not the package(s) contained in the file. For example to import the &amp;ldquo;Data::Connector&amp;rdquo; package defined above, we could save it in a file called &amp;ldquo;Whatever.pm&amp;rdquo; and later reference it in a script like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Whatever;

&lt;span style=&#34;color:#75715e&#34;&gt;# call connect subroutine declared in Data::Connector package&lt;/span&gt;
Data::Connector::connect();&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;All .pm files must end with a &amp;ldquo;true&amp;rdquo; value per Perl&amp;rsquo;s requirements, so most authors either place &amp;ldquo;1;&amp;rdquo; or &amp;ldquo;__PACKAGE__;&amp;rdquo; as the last line of the .pm file. In Perl a true value is any value that is not: null, zero or a zero-length string.&lt;/p&gt;

&lt;p&gt;A distribution is a collection of files that usually includes a Perl module and several other files. There is no strict standard as to which files must be included in a distribution, however for the distribution to be indexed on CPAN and install-able by the CPAN command line client, the distribution needs to include some core files. Distributions have versions - so a Perl module on CPAN will have one distribution for every version of the module. These are the main files and directories you&amp;rsquo;ll encounter in distributions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;README - a brief description of how to install the distribution, sometimes includes a license and examples of how to use the module(s).&lt;/li&gt;
&lt;li&gt;LICENSE - the license for the code - a non-commercial license like the GPL, artistic, BSD etc are common.&lt;/li&gt;
&lt;li&gt;META.yml/ META.json - files that contain the metadata describing the distribution: the author, license, version, pre-requisite modules for use etc. They are auto-generated as part of the distribution build process and can be ignored.&lt;/li&gt;
&lt;li&gt;Makefile.PL and or Build.PL - these are Perl files that are used to install the module(s) in the distribution. Worth looking at when you&amp;rsquo;re having installation issues.&lt;/li&gt;
&lt;li&gt;MANIFEST - a list of the files included in the distribution.&lt;/li&gt;
&lt;li&gt;lib - a directory containing Perl modules - usually the core code of the distribution.&lt;/li&gt;
&lt;li&gt;t - the test files directory. These are run when the module is installed. If you have failing tests on installation, it can be helpful to review the test files in the t/ directory to find out the specifics of the test.&lt;/li&gt;
&lt;li&gt;bin - if the distribution contains an app, (Perl script) it will be in here. Often the app uses modules contained in the lib directory.&lt;/li&gt;
&lt;li&gt;Changes - a list of changes from distribution version to version.&lt;/li&gt;
&lt;li&gt;xt - the extended test files directory, usually used for author tests that you don&amp;rsquo;t need to run.&lt;/li&gt;
&lt;li&gt;eg - a directory of example Perl scripts, using the module(s) contained in the distribution.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These are the typical directories and files found in a Perl distribution but as there is no fixed standard, distribution authors are free to include and exclude the files they wish. For a good example, check out the files provided by David Golden in a distribution of the the popular &lt;a href=&#34;https://metacpan.org/source/DAGOLDEN/HTTP-Tiny-0.043&#34;&gt;HTTP::Tiny&lt;/a&gt; module.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Once you get to grips with Perl packages, modules and distributions it&amp;rsquo;s far easier to start hacking on Perl modules that don&amp;rsquo;t work the way you want them to. For example, in the case of a module that won&amp;rsquo;t install, you can download the distribution from CPAN (at the command line &amp;ldquo;cpan -g Module::Name&amp;rdquo;), untar it, and patch the failing tests, or examine the source code in the lib directory and resolve a bug or two. Before long you&amp;rsquo;ll be releasing your own distributions to CPAN!&lt;/p&gt;

&lt;p&gt;Enjoyed this article? Help us out and &lt;a href=&#34;https://twitter.com/intent/tweet?original_referer=http%3A%2F%2Fperltricks.com%2Farticle%2F96%2F2014%2F6%2F13%2FPerl-distributions-modules-packages-explained&amp;amp;text=Perl+distributions%2C+modules%2C+packages+explained&amp;amp;tw_p=tweetbutton&amp;amp;url=http%3A%2F%2Fperltricks.com%2Farticle%2F96%2F2014%2F6%2F13%2FPerl-distributions-modules-packages-explained&amp;amp;via=perltricks&#34;&gt;tweet&lt;/a&gt; about it!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Installing Perl modules with C library dependencies</title>
      <link>http://localhost:1313/article/19/2013/4/15/Installing-Perl-modules-with-C-library-dependencies/</link>
      <pubDate>Mon, 15 Apr 2013 18:37:26 +0000</pubDate>
      
      <guid>http://localhost:1313/article/19/2013/4/15/Installing-Perl-modules-with-C-library-dependencies/</guid>
      <description>

&lt;p&gt;Some Perl modules have specific C library dependencies that need to be met or else they won&amp;rsquo;t install. These issues can be tricky to solve as CPAN is not able to automatically install or report on non-Perl dependencies and Google isn&amp;rsquo;t good at returning useful results for these types of issues (&lt;a href=&#34;https://metacpan.org/pod/Net::SSLeay&#34;&gt;Net::SSLeay&lt;/a&gt; is a common example of a tricky module to install). Usually you will only find out about missing dependencies when trying to install the module, as the install will fail. What you need to do at this point is &lt;strong&gt;identify&lt;/strong&gt; and &lt;strong&gt;install&lt;/strong&gt; the missing C libraries.&lt;/p&gt;

&lt;h3 id=&#34;identifying-c-library-dependencies&#34;&gt;Identifying C Library dependencies&lt;/h3&gt;

&lt;p&gt;Here are some places to check for dependencies:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Install error message&lt;/strong&gt; - scan the command line output from the failed install: often Perl developers will write specific error messages that indicate the missing C library.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Module documentation&lt;/strong&gt; - check the main POD page for the module on &lt;a href=&#34;https://metacpan.org/&#34;&gt;metacpan&lt;/a&gt; it may indicate which C libraries are required.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Distribution files&lt;/strong&gt; - check the README and INSTALL files that come with the distribution for the module you are trying to install. If available they will be in the root directory of the tarball. You can browse these files online at &lt;a href=&#34;https://metacpan.org/&#34;&gt;metacpan&lt;/a&gt; by searching for the module, then clicking the &amp;lsquo;browse&amp;rsquo; link on the module&amp;rsquo;s main page.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Search your package manager&lt;/strong&gt; - look at the technologies and keywords associated with the module. For example &lt;a href=&#34;https://metacpan.org/pod/Net::SSLeay&#34;&gt;Net::SSLeay&lt;/a&gt; probably has something to do with SSL, so search for Perl-related SSL packages (example below).&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;installing-c-library-dependencies&#34;&gt;Installing C library dependencies&lt;/h3&gt;

&lt;p&gt;Once you have identified the missing C libraries, you need to install them. If you are on Linux, this can be done using a package manager and searching for and installing the package containing the C library:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# yum package manager&lt;/span&gt;
$ sudo yum search ssl
&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
sudo yum install openssl&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;perl&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;x86_64 perl&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;Net&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;SSLeay&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;x86_64 perl&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;Crypt&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;SSLeay&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;x86_64&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you are not on Linux, try downloading the library directly from the C library&amp;rsquo;s homepage - these are easy to find via Google and usually have specific Windows / OSX distributions.&lt;/p&gt;

&lt;p&gt;Once you have installed the requisite libraries, try installing the Perl module again with CPAN.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Check your module POD using perldoc</title>
      <link>http://localhost:1313/article/9/2013/4/1/Check-your-module-POD-using-perldoc/</link>
      <pubDate>Mon, 01 Apr 2013 22:45:35 +0000</pubDate>
      
      <guid>http://localhost:1313/article/9/2013/4/1/Check-your-module-POD-using-perldoc/</guid>
      <description>&lt;p&gt;Perl ships with a command-line program called perldoc that makes it easier to search and read Perl&amp;rsquo;s vast documentation in the POD markup language. If perldoc is called with the -F flag, it will display the POD markup of an input file - this can be useful when your are developing a new Perl distribution and want to check the appearance of the POD in your module before it appears on CPAN for all to see.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Pass a local file to perldoc&lt;/span&gt;

perldoc &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;F ProxyManager&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pm&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This will then display the POD markup:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;ProxyManager(&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;)                                            

NAME
       Net::OpenVPN::ProxyManager &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; connect to proxy servers using OpenVPN&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;

SYNOPSIS
       &lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Net::OpenVPN::ProxyManager;
       &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $pm &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Net::OpenVPN::ProxyManager&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;;

       &lt;span style=&#34;color:#75715e&#34;&gt;# Create a config object to capture proxy server details&lt;/span&gt;
       &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $config_object &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; $pm&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;create_config({remote &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;100.120.3.34 53&amp;#39;&lt;/span&gt;, proto &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;udp&amp;#39;&lt;/span&gt;});

       &lt;span style=&#34;color:#75715e&#34;&gt;# Launch OpenVPN and connect to the proxy&lt;/span&gt;
       $pm&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;connect($config_object);
       &lt;span style=&#34;color:#75715e&#34;&gt;# do some stuff&lt;/span&gt;

       &lt;span style=&#34;color:#75715e&#34;&gt;# Disconnect from the proxy server&lt;/span&gt;
       $pm&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;disconnect();

DESCRIPTION
       Net::OpenVPN::ProxyManager is an object oriented module that provides methods to simplify the management of proxy connections that support OpenVPN&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;

This is a base generic class, see Net::OpenVPN::ProxyManager::HMA &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; additional methods to interact with hidemyass&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;com proxy servers&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;

METHODS
   &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;
       The constructor accepts an anonymous hash &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; two optional parameters: config_path &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; warning_flag&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt; config_path is the path that ProxyManager&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pm will &lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; to create the config file when the create_config method is called&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt; By default config_path is set to &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/tmp/openvpn-config.conf&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How We Wrote the Template Toolkit Book ...</title>
      <link>http://localhost:1313/pub/2004/01/30/ttbook.html/</link>
      <pubDate>Fri, 30 Jan 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/01/30/ttbook.html/</guid>
      <description>

&lt;p&gt;There are a number of tools available for writing books. Many people would immediately reach for their favorite word processor, but having written one book using Microsoft Word I&amp;rsquo;m very unlikely to repeat the experience. Darren Chamberlain, Andy Wardley, and I are all Perl hackers, so when we got together to write &lt;a href=&#34;http://www.oreilly.com/catalog/perltt/index.html?CMP=IL7015&#34;&gt;Perl Template Toolkit&lt;/a&gt;, it didn&amp;rsquo;t take us long to agree that we wanted to write it using POD (Plain Old Documentation).&lt;/p&gt;

&lt;p&gt;Of course, any chosen format has its pros and cons. With POD we had all the advantages of working with plain text files and all of the existing POD tools were available to convert our text into various other formats, but there were also some disadvantages. These largely stem from the way that books (especially technical books) are written. Authors rarely write the chapters in the order in which they are published in the finished book. In fact, it&amp;rsquo;s very common for the chapters to rearranged a few times before the book is published.&lt;/p&gt;

&lt;p&gt;Now this poses a problem with internal references. It&amp;rsquo;s all very well saying &amp;ldquo;see chapter Six for further details&amp;rdquo;, but when the book is rearranged and Chapter Six becomes Chapter Four, all of these references are broken. Most word processors will allow you to insert these references as &amp;ldquo;tags&amp;rdquo; that get expanded (correctly) as the document is printed. POD and emacs doesn&amp;rsquo;t support this functionality.&lt;/p&gt;

&lt;p&gt;Another common problem with technical books is the discrepancy between the code listings in the book and the code that actually got run to produce the output shown. It&amp;rsquo;s easily done. You create an example program and cut-and-paste the code into the document. You then find a subtle bug in the code and fix it in the version that you&amp;rsquo;re running but forget to fix it in the book. What would be really useful would be if you could just use tags saying &amp;ldquo;insert this program file here&amp;rdquo; and even &amp;ldquo;insert the output of running the program here&amp;rdquo;. That&amp;rsquo;s functionality that no word processor offers.&lt;/p&gt;

&lt;p&gt;Of course, these shortcomings would be simple to solve if you had a powerful templating system at the ready. Luckily Andy, Darren, and I had the Template Toolkit (TT) handy.&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-book-templates-the-book-templates-span&#34;&gt;&lt;span id=&#34;The_Book_Templates&#34;&gt;The Book Templates&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;We produced a series of templates that controlled the book&amp;rsquo;s structure and a Perl program that pulled together each chapter into a single POD file. This program was very similar to the &lt;code&gt;tpage&lt;/code&gt; program that comes with TT, but was specialized for our requirements.&lt;/p&gt;

&lt;h4 id=&#34;span-id-separating-code-from-code-separating-code-from-code-span&#34;&gt;&lt;span id=&#34;Separating_code_from_code&#34;&gt;Separating Code from Code&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;There was one problem we had to address very early on with our book templates. This was the problem of listing TT code within a TT template. We needed a way to distinguish the template directives we were using to produce the book from the template directives we were demonstrating &lt;em&gt;in the book&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Of course TT provides a simple way to achieve this. You can define the characters that TT uses to recognize template directives. By default it looks for &lt;code&gt;[% ... %]&lt;/code&gt;, but there are a number of predefined groups of tags that you can turn on using the &lt;code&gt;TAGS&lt;/code&gt; directive. All of our book templates started with the line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  [% TAGS star %]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When it sees this directive, the TT parser starts to look for template directives that are delimited with &lt;code&gt;[* ... *]&lt;/code&gt;. The default delimiters (&lt;code&gt;[% ... %]&lt;/code&gt;) are treated as plain text and passed through unaltered. Therefore, by using this directive we can use &lt;code&gt;[% ... %]&lt;/code&gt; in our example code and &lt;code&gt;[* ... *]&lt;/code&gt; for the template directives that we wanted TT to process.&lt;/p&gt;

&lt;p&gt;Of course, the page where we introduced the &lt;code&gt;TAGS&lt;/code&gt; directive and gave examples of its usage was still a little complex.&lt;/p&gt;

&lt;p&gt;In the rest of this article, I&amp;rsquo;ll go back to using the &lt;code&gt;[% ... %]&lt;/code&gt; style of tags.&lt;/p&gt;

&lt;h4 id=&#34;span-id-useful-blocks-and-macros-useful-blocks-and-macros-span&#34;&gt;&lt;span id=&#34;Useful_blocks_and_macros&#34;&gt;Useful Blocks and Macros&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;We defined a number of useful blocks and macros that expanded to useful phrases that would be used throughout the book. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  [% TT = &#39;Template Toolkit&#39;;

     versions = {
       stable = &#39;2.10&#39;
       developer = &#39;2.10a&#39;
     } %]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first of these must have saved each of us many hours of typing time and the second gave us an easy way to keep the text up-to-date if Andy released a new version of TT while we were writing the book. A template using these variables might look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  The current stable version of the [% TT %] is [% stable %]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-keeping-track-of-chapters-keeping-track-of-chapters-span&#34;&gt;&lt;span id=&#34;Keeping_track_of_chapters&#34;&gt;Keeping Track of Chapters&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;We used a slightly more complex set of variables and macros to solve the problem of keeping chapter references consistent. First we defined an array that contained details of the chapters (in the current order):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Chapters = [
    {  name  = &#39;intro&#39;
       title = &amp;quot;Introduction to the Template Toolkit&amp;quot;
    }
    {  name  = &#39;web&#39;
       title = &amp;quot;A Simple Web Site&amp;quot;
    }
    {  name  = &#39;language&#39;
       title = &amp;quot;The Template Language&amp;quot;
    }
    {  name  = &#39;directives&#39;
       title = &amp;quot;Template Directives&amp;quot;
    }
    {  name  = &#39;filters&#39;
       title = &amp;quot;Filters&amp;quot;
    }
    {  name  = &#39;plugins&#39;
       title = &amp;quot;Plugins&amp;quot;
    }
    ... etc ...
   ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each entry in this array is a hash with two keys. The name is the name of the directory in our source tree that contains that chapter&amp;rsquo;s files and the title is the human-readable name of the chapter.&lt;/p&gt;

&lt;p&gt;The next step is to convert this into a hash so that we can look up the details of a chapter when given its symbolic name.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    FOREACH c = Chapters;
      c.number = loop.count;
      Chapter.${c.name} = c;
    END;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that we are adding a new key to the hash that describes a chapter. We use the &lt;code&gt;loop.count&lt;/code&gt; variable to set the chapter number. This means that we can reorder our original &lt;code&gt;Chapters&lt;/code&gt; array and the chapter numbers in the &lt;code&gt;Chapter&lt;/code&gt; hash will always remain accurate.&lt;/p&gt;

&lt;p&gt;Using this hash, it&amp;rsquo;s now simple to create a macro that lets us reference chapters. It looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  MACRO chref(id) BLOCK;
    THROW chapter &amp;quot;invalid chapter id: $id&amp;quot;
      UNLESS (c = Chapter.$id);
    seen = global.chapter.$id;
    global.chapter.$id = 1;
    seen ? &amp;quot;Chapter $c.number&amp;quot;
         : &amp;quot;Chapter $c.number, I&amp;lt;$c.title&amp;gt;&amp;quot;;
  END;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The macro takes one argument, which is the id of the chapter (this is the unique name from the original array). If this chapter doesn&amp;rsquo;t exist in the &lt;code&gt;Chapter&lt;/code&gt; hash then the macro throws an error. If the chapter exists in the hash then the macro displays a reference to the chapter. Notice that we remember when we have seen a particular chapter (using &lt;code&gt;global.chapter.$id&lt;/code&gt;) &amp;ndash; this is because O&amp;rsquo;Reilly&amp;rsquo;s style guide says that a chapter is referenced differently the first time it is mentioned in another chapter. The first time, it is referenced as &amp;ldquo;Chapter 2, &lt;em&gt;A Simple Web Site&lt;/em&gt;&amp;rdquo;, and on subsequent references it is simply called &amp;ldquo;Chapter 2. &amp;ldquo;&lt;/p&gt;

&lt;p&gt;So with this mechanism in place, we can have templates that say things like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Plugins are covered in more detail in [% chref(plugins) %].
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And TT will convert that to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Plugins are covered in more detail in Chapter 6, I&amp;lt;Plugins&amp;gt;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And if we subsequently reorder the book again, the chapter number will be replaced with the new correct number.&lt;/p&gt;

&lt;h4 id=&#34;span-id-running-example-code-running-example-code-span&#34;&gt;&lt;span id=&#34;Running_example_code&#34;&gt;Running Example Code&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The other problem I mentioned above is that of ensuring that sample code and its output remain in step. The solution to this problem is a great example of the power of TT.&lt;/p&gt;

&lt;p&gt;The macro that inserts an example piece of code looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  MACRO example(file, title) BLOCK;
    global.example = global.example + 1;
    INCLUDE example
      title = title or &amp;quot;F&amp;lt;$file&amp;gt;&amp;quot;
      id    = &amp;quot;$chapter.id/example/$file&amp;quot;
      file  = &amp;quot;example/$file&amp;quot;
      n     = global.example;
    global.exref.$file = global.example;
  END;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The macro takes two arguments, the name of the file containing the example code and (optionally) a title for the example. If the title is omitted then the filename is used in its place. All of the examples in a particular chapter are numbered sequentially and the &lt;code&gt;global.example&lt;/code&gt; variable holds the last used value, which we increment. The macro then works out the path of the example file (the structure of our directory tree is very strict) and &lt;code&gt;INCLUDE&lt;/code&gt;s a template called &lt;code&gt;example&lt;/code&gt;, passing it various information about the example file. After processing the example, we store the number that is associated with this example by storing it in the hash &lt;code&gt;global.exref.$file&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;example&lt;/code&gt; template looks like this:&lt;/p&gt;

&lt;p&gt;[% IF publishing -%] =begin example [% title %]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      Z&amp;lt;[% id %]&amp;gt;[% INSERT $file FILTER indent(4) +%]

  =end
  [% ELSE -%]
  B&amp;lt;Example [% n %]: [% title %]&amp;gt;

  [% INSERT $file FILTER indent(4) +%]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[% END -%]&lt;/p&gt;

&lt;p&gt;This template looks at a global flag called &lt;code&gt;publishing&lt;/code&gt;, which determines if we are processing this file for submission to O&amp;rsquo;Reilly or just for our own internal use. The &lt;code&gt;Z&amp;lt; ... &amp;gt;&lt;/code&gt; POD escape is an O&amp;rsquo;Reilly extension used to identify the destination of a link anchor (we&amp;rsquo;ll see the link itself later on). Having worked out how to label the example, the template simply inserts it and indents it by four spaces.&lt;/p&gt;

&lt;p&gt;This template is used within our chapter template by adding code like &lt;code&gt;[% example(&#39;xpath&#39;, &#39;Processing XML with XPath&#39;) %]&lt;/code&gt; to your document. That will be expanded to something like, &amp;ldquo;Example 2: Processing XML with Xpath,&amp;rdquo; followed by the source of the example file, &lt;code&gt;xpath&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;All of that gets the example code into that document. We now have to do two other things. We need to be able to reference the code from the text of the chapter (&amp;lsquo;As example 3 demonstrates&amp;hellip;&amp;rsquo;), and we also need to include the results of running the code.&lt;/p&gt;

&lt;p&gt;For the first of these there is a macro called &lt;code&gt;exref&lt;/code&gt;, which is shown below:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  MACRO exref(file) BLOCK;
    # may be a forward reference to next example
    SET n = global.example + 1
      UNLESS (n = global.exref.$file);
    INCLUDE exref
      id    = &amp;quot;$chapter.id/example/$file&amp;quot;;
  END;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works in conjunction with another template, also called &lt;code&gt;exref&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  [% IF publishing -%]
  A&amp;lt;[% id %]&amp;gt;
  [%- ELSE -%]
  example [% n %]
  [%- END -%]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The clever thing about this is that you can use it &lt;em&gt;before&lt;/em&gt; you have included the example code. So you can do things like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  This is demonstrated in [% exref(&#39;xpath&#39;) %].

  [% example(&#39;xpath&#39;, &#39;Processing XML with XPath&#39;) %]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As long as you only look at a maximum of one example ahead, it still works. Notice that the &lt;code&gt;A&amp;lt; ... &amp;gt;&lt;/code&gt; POD escape is another O&amp;rsquo;Reilly extension that marks a link anchor. So within the O&amp;rsquo;Reilly publishing system it&amp;rsquo;s the &lt;code&gt;A&amp;lt;foo&amp;gt;&lt;/code&gt; and the associated &lt;code&gt;Z&amp;lt;foo&amp;gt;&lt;/code&gt; that make the link between the reference and the actual example code.&lt;/p&gt;

&lt;p&gt;The final thing we need is to be able to run the example code and insert the output into the document. For this we defined a macro called &lt;code&gt;output&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  MACRO output(file) BLOCK;
    n = global.example;
    &amp;quot;B&amp;lt;Output of example $n:&amp;gt;\n\n&amp;quot;;
    INCLUDE &amp;quot;example/$file&amp;quot; FILTER indent(4);
  END;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is pretty simple. The macro is passed the name of the example file. It assumes that this is the most recent example included in the document so it gets the example number from &lt;code&gt;global.example&lt;/code&gt;. It then displays a header and &lt;code&gt;INCLUDE&lt;/code&gt;s the file. Notice that the major difference between &lt;code&gt;example&lt;/code&gt; and &lt;code&gt;output&lt;/code&gt; is that &lt;code&gt;example&lt;/code&gt; uses &lt;code&gt;INSERT&lt;/code&gt; to just insert the file&amp;rsquo;s contents, whereas &lt;code&gt;output&lt;/code&gt; uses &lt;code&gt;INCLUDE&lt;/code&gt;, which loads the file and processes it.&lt;/p&gt;

&lt;p&gt;With all of these macros and templates, we can now have example code in our document and be sure that the output we show really reflects the output that you would get by running that code. So we can put something like this in the document:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  The use of GET and SET is demonstrated in [% exref(&#39;get_set&#39;) %].

  [% example(&#39;get_set&#39;, &#39;GET and SET&#39;) %]

  [% output(&#39;get_set&#39;) %]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that will be expanded to the following.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  The use of GET and SET is demonstrated in example 1.

  B&amp;lt;Example 1: GET and SET&amp;gt;

      [% SET foo = &#39;bar -%]
      The variable foo is set to &amp;quot;[% GET foo %]&amp;quot;.

  B&amp;lt;Output of example 1:

      The variable foo is set to &amp;quot;bar&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As another bonus, all of the example code is neatly packaged away in individual files that can easily be made into a tarball for distribution from the book&amp;rsquo;s web site.&lt;/p&gt;

&lt;h4 id=&#34;span-id-other-templates-blocks-and-macros-other-templates-blocks-and-macros-span&#34;&gt;&lt;span id=&#34;Other_templates,_blocks_and_macros&#34;&gt;Other Templates, Blocks, and Macros&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Once we started creating these timesaving templates, we found a huge numbers of areas where we could make our lives easier. We had macros that inserted references to other books in a standard manner, macros for inserting figures and screenshots, as well as templates that ensured that all our chapters had the same standard structure and warned us if any of the necessary sections were missing. I&amp;rsquo;m convinced that the TT templates we wrote for the project saved us all a tremendous amount of time that would have otherwise been spent organizing and reorganizing the work of the three authors. I would really recommend a similar approach to other authors.&lt;/p&gt;

&lt;p&gt;The Template Toolkit is often seen as a tool for building web sites, but we have successfully demonstrated one more non-Web area where the Template Toolkit excels.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

