<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Utf8 on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/utf8/</link>
    <description>Recent content in Utf8 on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 29 Jan 2020 20:11:44 +0000</lastBuildDate>
    <atom:link href="/tags/utf8/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>JSON, Unicode, and Perl … Oh My!</title>
      <link>http://localhost:1313/article/json-unicode-and-perl-oh-my-/</link>
      <pubDate>Wed, 29 Jan 2020 20:11:44 +0000</pubDate>
      
      <guid>http://localhost:1313/article/json-unicode-and-perl-oh-my-/</guid>
      <description>

&lt;p&gt;Consider the following code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Mojo::JSON;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Cpanel::JSON::XS;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Data::Dumper;
$Data::Dumper::Useqq &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $e_acute &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\xc3\xa9&amp;#34;&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $json &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Mojo::JSON::encode_json([$e_acute]);
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $decoded &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Cpanel::JSON::XS&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;()&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;decode($json)&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;];
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; Dumper( $json, $decoded );&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You might think this a reasonable enough round-trip, just using two
different JSON libraries, &lt;a href=&#34;https://metacpan.org/pod/Mojo::JSON&#34;&gt;Mojo::JSON&lt;/a&gt;
and &lt;a href=&#34;https://metacpan.org/pod/Cpanel::JSON::XS&#34;&gt;Cpanel::JSON::XS&lt;/a&gt;.
In fact, though, when you run
this you’ll see that $decode in the above is &lt;code&gt;&amp;quot;\x{c3}\x{83}\x{c2}\x{a9}&amp;quot;&lt;/code&gt;,
not just the &lt;code&gt;&amp;quot;\xc3\xa9&amp;quot;&lt;/code&gt; that we started with.&lt;/p&gt;

&lt;p&gt;Now invert the encoder/decoder modules:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Mojo::JSON;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Cpanel::JSON::XS;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Data::Dumper;
$Data::Dumper::Useqq &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $e_acute &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\xc3\xa9&amp;#34;&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $json &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Cpanel::JSON::XS&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;()&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;encode([$e_acute]);
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $decoded &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Mojo::JSON::decode_json($json)&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;];
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; Dumper( $json, $decoded );&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now $decode is just &lt;code&gt;&amp;quot;\x{e9}&amp;quot;&lt;/code&gt;. What’s going on here?&lt;/p&gt;

&lt;h2 id=&#34;what-s-in-a-string&#34;&gt;What’s in a string?&lt;/h2&gt;

&lt;p&gt;To appreciate the above, we first have to grapple with what Perl strings
&lt;em&gt;are&lt;/em&gt;, fundamentally. Unlike C strings, Perl strings aren’t mere arrays
of bytes … but unlike, say, Python 3 strings, Perl strings aren’t arrays of
Unicode characters, either. Perl strings, rather, are arrays of “code
points” in an undefined character set.&lt;/p&gt;

&lt;p&gt;In particular, unlike Python, JavaScript, and many other popular high-level
programming languages, Perl strings do not differentiate between “binary”
and “text”. For example, if Perl reads
bytes 0xff, 0xfe, 0xfd, and 0xfc off of a binary filehandle, the string
that Perl creates from those 4 bytes is understood to contain not 4 &lt;em&gt;bytes&lt;/em&gt;,
but 4 &lt;em&gt;code points&lt;/em&gt;, without reference to any particular character set,
stored in an abstract, internal-use encoding.
(The Perl interpreter may, in fact, use 4 bytes to store the string, but that
would be an implementation detail, of no concern to interpreted Perl code.)&lt;/p&gt;

&lt;p&gt;This point must be stressed: Perl _does not care_—and does not &lt;em&gt;want&lt;/em&gt; to
care—whether a given string’s code points represent bytes or characters.
(More will be said on this later.)&lt;/p&gt;

&lt;h2 id=&#34;back-to-json&#34;&gt;Back to JSON&lt;/h2&gt;

&lt;p&gt;In our examples above we compared round-tripping using different libraries
for the encode and decode. Let’s dig further by comparing just the
encoded JSON:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Mojo::JSON;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Cpanel::JSON::XS;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Data::Dumper;
$Data::Dumper::Useqq &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $e_acute &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\xc3\xa9&amp;#34;&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $mojo_json &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Mojo::JSON::encode_json([$e_acute]);
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $cp_json &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Cpanel::JSON::XS&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;()&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;encode([$e_acute]);
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; Dumper( $mojo_json, $cp_json );&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This will print:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$VAR1 = &amp;quot;[\&amp;quot;\303\203\302\251\&amp;quot;]&amp;quot;;
$VAR2 = &amp;quot;[\&amp;quot;\x{c3}\x{a9}\&amp;quot;]&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Note that &lt;a href=&#34;https://metacpan.org/pod/Data::Dumper&#34;&gt;Data::Dumper&lt;/a&gt;
outputs one string using octal escapes
and the other using hex. This reflects another Perl interpreter
implementation detail which, for now, is of no concern.)&lt;/p&gt;

&lt;p&gt;Our input string contains two code points, 0xc3 and 0xa9. Recall that
there is no specific character set associated with those code points; they’re
just numbers. JSON, though, is purely Unicode—and the
latest standard mandates UTF-8 encoding specifically. So we need to translate
our “no-character-set” code points to UTF-8 in order to encode to JSON. But
how to do this?&lt;/p&gt;

&lt;p&gt;We can’t, strictly speaking. It would be like trying
to convert 5 “currency units” to U.S. dollars: we need to know the actual
source currency (Bitcoin? Euros?) to get an answer. Likewise, in Perl, to
express our stored “code points” in UTF-8 we need to know what &lt;em&gt;characters&lt;/em&gt;
those code points represent. For example, your Perl string might store code
point 142 … but which character is that? Perl doesn’t know, and Perl doesn’t
care. Without a defined character set, a code point is just a number.&lt;/p&gt;

&lt;p&gt;To work around this problem, our JSON libraries make reasonable—though
not necessarily correct—assumptions about what the string’s code points
represent.&lt;/p&gt;

&lt;p&gt;Mojo::JSON assumes that our 2 original code points are Unicode. That means
Mojo::JSON thinks we gave it the characters U+00C3 (Ã) and
U+00A9 (©). The reason for the “expansion” from 2 code points to 4 in the
encoded JSON is that
Mojo::JSON encodes our code points as UTF-8: U+00C3 becomes Perl
code points 0303 (0xc3) and 0203 (0x83), and U+00A9 becomes 0302 (0xc2) and
0251 (0xa9).&lt;/p&gt;

&lt;p&gt;Cpanel::JSON::XS makes a different assumption that suits a different
interpretation: This encoder assumes that our 2 original code points
represent whatever bytes of the characters that should go into the eventual
JSON. Unlike with Mojo::JSON, there is no assumption about a desired encoding,
which allows the caller full control over the encoding.&lt;/p&gt;

&lt;p&gt;(This flexibility allows the encoder’s caller to choose, e.g., UTF-16 rather
than UTF-8 for the encoded JSON. That made more sense prior to the latest
JSON specification, which mandates UTF-8 outside closed systems.)&lt;/p&gt;

&lt;p&gt;The same difference in behavior applies to our two decoder functions. They,
too, face an “unsolvable” problem, the reverse of that for encoding. And
their solutions mirror the encoders’.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Mojo::JSON;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Data::Dumper;
$Data::Dumper::Useqq &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $from_mojo &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[\&amp;#34;\303\203\302\251\&amp;#34;]&amp;#34;&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $from_cp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[\&amp;#34;\x{c3}\x{a9}\&amp;#34;]&amp;#34;&lt;/span&gt;;

$from_mojo &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Mojo::JSON::decode_json($from_mojo)&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;];
$from_cp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Mojo::JSON::decode_json($from_cp)&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;];
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; Dumper( $from_mojo, $from_cp );&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This will print:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$VAR1 = &amp;quot;\x{c3}\x{a9}&amp;quot;;
$VAR2 = &amp;quot;\x{e9}&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Recall that Mojo::JSON’s encoder interprets its input as Unicode and that
its output code points represent bytes of UTF-8.
Above you’ll see that its decoder does the inverse: it interprets its
input as bytes of UTF-8 and outputs code points understood to be Unicode.
This means the number of code points output will be smaller than the number
input if the input contains any code points above 127 (0x7f), which UTF-8
represents as multiple bytes.&lt;/p&gt;

&lt;p&gt;As for Cpanel::JSON::XS:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Mojo::JSON;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Data::Dumper;
$Data::Dumper::Useqq &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $from_mojo &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[\&amp;#34;\303\203\302\251\&amp;#34;]&amp;#34;&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $from_cp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[\&amp;#34;\x{c3}\x{a9}\&amp;#34;]&amp;#34;&lt;/span&gt;;

$from_mojo &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Cpanel::JSON::XS&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;()&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;decode($from_mojo)&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;];
$from_cp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Cpanel::JSON::XS&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;()&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;decode($from_cp)&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;];
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; Dumper( $from_mojo, $from_cp );&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This gives:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$VAR1 = &amp;quot;\x{c3}\x{83}\x{c2}\x{a9}&amp;quot;;
$VAR2 = &amp;quot;\x{c3}\x{a9}&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;decode()&lt;/code&gt; method, like &lt;code&gt;encode()&lt;/code&gt;, assumes that the caller will
handle encoding manually and so simply copies code points.&lt;/p&gt;

&lt;h2 id=&#34;aside-assumptions-of-utf-8&#34;&gt;Aside: Assumptions of UTF-8&lt;/h2&gt;

&lt;p&gt;Mojo::JSON’s behavior of encoding to UTF-8 has precedent: Perl itself!&lt;/p&gt;

&lt;p&gt;You may have run into something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; perl -e&#39;print &amp;quot;\x{100}&amp;quot;&#39;
Wide character in print at -e line 1.
Ā
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For code points 0-255 Perl just outputs the code point as an octet, but
when asked to output a code point that exceeds 255, obviously that doesn’t
work. In this case, Perl assumes you want UTF-8 but throws the “wide
character” warning to tip you off to the fact that you missed something—in
this case, you neglected to encode code point 256 to bytes.&lt;/p&gt;

&lt;h2 id=&#34;abusing-the-system&#34;&gt;Abusing the System&lt;/h2&gt;

&lt;p&gt;Cpanel::JSON::XS’s &lt;code&gt;encode()&lt;/code&gt; allows for a nonstandard use of JSON:
literal binary data. Consider the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;perl -MCpanel::JSON::XS -e&#39;print Cpanel::JSON::XS-&amp;gt;new()-&amp;gt;encode([&amp;quot;\xff&amp;quot;])&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;… will output 5 bytes: &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;&amp;quot;&lt;/code&gt;, 0xff, &lt;code&gt;&amp;quot;&lt;/code&gt;, and &lt;code&gt;]&lt;/code&gt;. This is invalid JSON
because no Unicode encoding (let alone UTF-8) ever encodes a character to
a single 0xff byte. Only special decoders that understand this “literal
binary” JSON variant will parse this as intended. That reliance on a custom
mode of operation undercuts JSON’s usefulness as a widely-supported
standard—which may seem fine at first but
can easily bite if your application grows in scope.&lt;/p&gt;

&lt;p&gt;Applications that need to serialize strings with arbitrary octets (i.e.,
binary) should apply a secondary encoding (e.g., Base64) to strings prior
to JSON encoding. Or, better yet, prefer a binary-friendly encoding like
&lt;a href=&#34;https://cbor.io&#34;&gt;CBOR&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;about-that-flag-behind-the-curtain&#34;&gt;About That Flag Behind the Curtain …&lt;/h2&gt;

&lt;p&gt;If you run the output from our two encoder methods through
&lt;a href=&#34;https://metacpan.org/pod/Devel::Peek&#34;&gt;Devel::Peek&lt;/a&gt;, you’ll
see something like this for Mojo::JSON’s output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SV = PV(0x7fdc27802f30) at 0x7fdc27e59c58
  REFCNT = 1
  FLAGS = (POK,pPOK)
  PV = 0x7fdc28826350 &amp;quot;[\&amp;quot;\303\203\302\251\&amp;quot;]&amp;quot;\0
  CUR = 8
  LEN = 34
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;… and this for Cpanel::JSON::XS:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SV = PV(0x7fc0cd004d30) at 0x7fc0cd016228
  REFCNT = 1
  FLAGS = (POK,pPOK,UTF8)
  PV = 0x7fc0cce2ef60 &amp;quot;[\&amp;quot;\303\203\302\251\&amp;quot;]&amp;quot;\0 [UTF8 &amp;quot;[&amp;quot;\x{c3}\x{a9}&amp;quot;]&amp;quot;]
  CUR = 8
  LEN = 34
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note the &lt;code&gt;UTF8&lt;/code&gt; flag in the latter. This tells us that Perl’s
internal storage of the string’s code points uses UTF-8 encoding. This
difference is why, as we saw earlier, Data::Dumper encodes Mojo::JSON’s output
using
octal escapes but Cpanel::JSON::XS’s using hex: Data::Dumper recognizes the
UTF8 flag and renders its output based on it.&lt;/p&gt;

&lt;p&gt;As &lt;a href=&#34;https://perldoc.perl.org/perlunifaq.html#What-is-%22the-UTF8-flag%22%3f&#34;&gt;perldoc perlunifaq&lt;/a&gt; makes clear, though, the UTF8 flag is &lt;strong&gt;not&lt;/strong&gt; meant for
consumption by Perl code. Perl applications should regard strings as
simple sequences of code points, without regard for how the
Perl interpreter may store those strings in memory.&lt;/p&gt;

&lt;p&gt;That being said,
in limited contexts it &lt;em&gt;may&lt;/em&gt; work to imitate the distinction between string
types in languages like Python and JavaScript by regarding
UTF8-flagged strings as “character strings” and non-UTF8-flagged strings as
“byte strings”—indeed, &lt;a href=&#34;https://metacpan.org/pod/Sereal::Encoder&#34;&gt;multiple&lt;/a&gt;
&lt;a href=&#34;https://metacpan.org/pod/CBOR::XS&#34;&gt;serializers&lt;/a&gt;
&lt;a href=&#34;https://metacpan.org/pod/CBOR::Free&#34;&gt;on&lt;/a&gt;
&lt;a href=&#34;https://metacpan.org/pod/CBOR::PP&#34;&gt;CPAN&lt;/a&gt;, including two of my own,
do exactly this. This isn’t
a supported model, though, for using Perl strings, and any code that
depends on it may behave differently in different Perl versions. Caveat
emptor!&lt;/p&gt;

&lt;h2 id=&#34;making-peace&#34;&gt;Making Peace&lt;/h2&gt;

&lt;p&gt;JSON and Perl are odd bedfellows. Perl’s lack of distinct number and string
types, for example, can yield JSON that uses the wrong type for one
value or the other. Perl’s lack of native booleans produces a similar effect.&lt;/p&gt;

&lt;p&gt;The encoding problems discussed above, though, are especially nefarious
because accommodating them requires a good understanding of all of the above.
Most developers can accommodate something like &lt;code&gt;{&amp;quot;age&amp;quot;: &amp;quot;9&amp;quot;}&lt;/code&gt; easily enough
because typecasting from &lt;code&gt;&amp;quot;9&amp;quot;&lt;/code&gt; (string) to &lt;code&gt;9&lt;/code&gt; (number) is commonplace. But
how many would see &lt;code&gt;&amp;quot;Ã©&amp;quot;&lt;/code&gt; and think, “ah! I simply have to treat those
characters’ code points as bytes then decode those bytes as UTF-8!” Some
would, to be sure—perhaps even many—but likely fewer than can easily coerce
&lt;code&gt;&amp;quot;9&amp;quot;&lt;/code&gt; to &lt;code&gt;9&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Binary-friendly encodings like &lt;a href=&#34;http://cbor.io&#34;&gt;CBOR&lt;/a&gt;
mitigate against this problem because whatever decodes the Perl-sourced
data can more easily recognize the need to decode from binary. Anyone
who doesn’t know about bytes and encodings will quickly learn! Fundamentally,
though, even CBOR doesn’t really fit Perl’s “pure code points” string model
very well because CBOR distinguishes strongly between binary and text strings,
which Perl does not.&lt;/p&gt;

&lt;p&gt;At the end of the day, Perl’s data model, for all of the conveniences that it
affords us, makes communication with many other languages a challenge. The
best we can do is to anticipate these problems and deal with them as they arise.&lt;/p&gt;

&lt;h2 id=&#34;epilogue-json-alternatives&#34;&gt;Epilogue: JSON Alternatives&lt;/h2&gt;

&lt;p&gt;JSON’s inability to store arbitrary octet strings is, in my experience,
its biggest liability,
but there are other reasons why I often prefer to avoid JSON:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Its inability to store comments and proscription against trailing commas
make it an awkward choice for human-maintained data structures.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Its &lt;code&gt;\uXXXX&lt;/code&gt; escapes support only characters within Unicode’s
&lt;abbr title=&#34;Basic Multilingual Plane&#34;&gt;BMP&lt;/abbr&gt;; to store emoji or other
non-BMP characters you either have to encode to UTF-8 directly or indicate
a UTF-16 surrogate pair (&lt;a href=&#34;https://en.wikipedia.org/wiki/UTF-16#U+010000_to_U+10FFFF&#34;&gt;What does that mean?&lt;/a&gt;) in &lt;code&gt;\uXXXX&lt;/code&gt; escapes.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It’s inefficient compared with binary formats.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/toml-lang/toml&#34;&gt;TOML&lt;/a&gt; is a nice serialization format
for human-maintained data structures. It’s line-delimited and—of course!—allows
comments, and any Unicode code point can be expressed in simple hexadecimal.
TOML is fairly new, and its specification is still in flux; nevertheless,
it already undergirds a number of high-profile
software projects like Rust’s &lt;a href=&#34;https://doc.rust-lang.org/cargo/&#34;&gt;Cargo&lt;/a&gt;
package manager and &lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;—which powers this site! CPAN
&lt;a href=&#34;https://metacpan.org/pod/TOML::Tiny&#34;&gt;hosts&lt;/a&gt;
&lt;a href=&#34;https://metacpan.org/pod/TOML::Parser&#34;&gt;several&lt;/a&gt;
&lt;a href=&#34;https://metacpan.org/pod/TOML&#34;&gt;implementations&lt;/a&gt; of this serialization.&lt;/p&gt;

&lt;p&gt;The aforementioned &lt;a href=&#34;https://cbor.io&#34;&gt;CBOR&lt;/a&gt; improves upon JSON’s efficiency and
also allows for storage of binary strings. Whereas JSON encoders must
stringify numbers and escape all strings, CBOR stores numbers “literally”
and prefixes strings with their length, which obviates the need to escape those
strings. These dramatically simplify both encoding and decoding. As with
TOML and YAML, CPAN hosts &lt;a href=&#34;https://metacpan.org/pod/CBOR::XS&#34;&gt;multiple&lt;/a&gt;
&lt;a href=&#34;https://metacpan.org/pod/CBOR::Free&#34;&gt;CBOR&lt;/a&gt;
&lt;a href=&#34;https://metacpan.org/pod/CBOR::PP&#34;&gt;implementations&lt;/a&gt;.
(Full disclosure: Two of these are of my own authorship.)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Sereal/Sereal&#34;&gt;Sereal&lt;/a&gt; is another great JSON substitute
that confers most of CBOR’s benefits and can even serialize more
“Perl-specific” items like regular expressions. This makes it ideal
for Perl-to-Perl IPC. The reference implementation is CPAN’s
&lt;a href=&#34;https://metacpan.org/pod/Sereal&#34;&gt;Sereal&lt;/a&gt; distribution.
Sereal isn’t as well-supported as CBOR outside Perl,
though, so if you need to communicate with non-Perl code, Sereal may
not work as well for you.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://yaml.org/&#34;&gt;YAML&lt;/a&gt; is another format that humans can maintain easily.
Unlike TOML, YAML supports binary strings; in fact, it’s flexible enough
to replace Data::Dumper in many cases. CPAN includes
a &lt;a href=&#34;https://metacpan.org/pod/YAML::XS&#34;&gt;number&lt;/a&gt;
&lt;a href=&#34;https://metacpan.org/pod/YAML::PP&#34;&gt;of&lt;/a&gt;
&lt;a href=&#34;https://metacpan.org/pod/YAML::Old&#34;&gt;libraries&lt;/a&gt; that implement YAML.&lt;/p&gt;

&lt;p&gt;Thank you for reading!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>XS utility routines that are good to know</title>
      <link>http://localhost:1313/article/xs-utility-routines-that-are-good-to-know/</link>
      <pubDate>Mon, 30 Apr 2018 20:34:45 +0000</pubDate>
      
      <guid>http://localhost:1313/article/xs-utility-routines-that-are-good-to-know/</guid>
      <description>

&lt;p&gt;In the previous &lt;a href=&#34;http://localhost:1313/article/writing-your-own-xs-functions/&#34;&gt;tutorial&lt;/a&gt;, we learned how to write our own functions in XS, how to process multiple arguments, and return different values, including &lt;code&gt;undef&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In this tutorial I&amp;rsquo;m going to cover some useful routines for common cases you&amp;rsquo;ll encounter when programming in XS. One that you&amp;rsquo;ve already seen is &lt;code&gt;SvOK&lt;/code&gt; which can tell you if a scalar is defined or not. Here are the new areas I&amp;rsquo;ll discuss:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Scheduling XS code to run at startup&lt;/li&gt;
&lt;li&gt;Handling tied variables&lt;/li&gt;
&lt;li&gt;Unicode tools&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When writing XS code, these are things you&amp;rsquo;ll often want to be aware of, and know how to handle.&lt;/p&gt;

&lt;h3 id=&#34;module-code&#34;&gt;Module Code&lt;/h3&gt;

&lt;p&gt;As before, we&amp;rsquo;ll define the module code to load our XS. This is all that&amp;rsquo;s required:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package XS::Tutorial::Three;
require XSLoader;

XSLoader::load();
1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That should be saved as &lt;code&gt;lib/XS/Tutorial/Three.pm&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;xs-code&#34;&gt;XS Code&lt;/h3&gt;

&lt;p&gt;The top of the XS file will look similar to the previous chapter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define PERL_NO_GET_CONTEXT // we&#39;ll define thread context if necessary (faster)
#include &amp;quot;EXTERN.h&amp;quot;         // globals/constant import locations
#include &amp;quot;perl.h&amp;quot;           // Perl symbols, structures and constants definition
#include &amp;quot;XSUB.h&amp;quot;           // xsubpp functions and macros

MODULE = XS::Tutorial::Three  PACKAGE = XS::Tutorial::Three
PROTOTYPES: ENABLE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remember to append any XS code after the &lt;code&gt;PROTOTYPES&lt;/code&gt; line. This should be saved as &lt;code&gt;lib/XS/Tutorial/Three.xs&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;scheduling-xs-code-to-run-at-startup&#34;&gt;Scheduling XS code to run at startup&lt;/h3&gt;

&lt;p&gt;Sometimes you&amp;rsquo;ll need to run some code before your XS functions can work. For example, &lt;a href=&#34;https://github.com/openvenues/libpostal&#34;&gt;libpostal&lt;/a&gt; has startup routines which populate data structures that must be called before the library can be used.&lt;/p&gt;

&lt;p&gt;You could code this in a &amp;ldquo;lazy&amp;rdquo; way, that is, inside the XS function, check to see if the init code has been run, and if not, run it before executing the rest of the function code.&lt;/p&gt;

&lt;p&gt;However XS offers another way to do it by using the &lt;code&gt;BOOT&lt;/code&gt; keyword. Any C code included below the keyword, will be executed during the startup process:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BOOT:
printf(&amp;quot;We&#39;re starting up!\n&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The boot section is terminated by the first empty line after the keyword.&lt;/p&gt;

&lt;h3 id=&#34;handling-tied-variables&#34;&gt;Handling tied variables&lt;/h3&gt;

&lt;p&gt;Tied variables are special variables that execute custom code when they are interacted with. But you never use them, so why worry about them? The
thing is if you&amp;rsquo;re writing code to be used by others, you can&amp;rsquo;t be sure that a caller won&amp;rsquo;t pass a tied variable to one of your XS functions. And unlike
regular Perl, XS does &lt;strong&gt;not&lt;/strong&gt; execute tied code automatically.&lt;/p&gt;

&lt;p&gt;XS does provide &lt;a href=&#34;https://perldoc.perl.org/perlapi.html#Magical-Functions&#34;&gt;functions&lt;/a&gt; for working with tied variables though. One you&amp;rsquo;ll see in a lot of XS code is &lt;code&gt;SvGETMAGIC&lt;/code&gt;. Imagine your function is passed a tied variable; it&amp;rsquo;s value will be undefined in XS, until you call &lt;code&gt;mg_get&lt;/code&gt; (&amp;ldquo;magic get&amp;rdquo;) on it, which calls &lt;code&gt;FETCH&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Unfortunately, &lt;code&gt;mg_get&lt;/code&gt; can only be called on tied scalars so you don&amp;rsquo;t want to call it on a regular scalar. That&amp;rsquo;s where &lt;code&gt;SvGETMAGIC&lt;/code&gt; comes in: if the scalar is
tied, it will call &lt;code&gt;mg_get&lt;/code&gt;, if not, nothing will happen.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s how you might use it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SV*
get_tied_value(SV *foo)

PPCODE:
  /* call FETCH() if it&#39;s a tied variable to populate the sv */
  SvGETMAGIC(foo);
  PUSHs(sv_2mortal(foo));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code declares an XS function called &lt;code&gt;get_tied_value&lt;/code&gt;, which accepts a scalar variable, and calls &lt;code&gt;SvGETMAGIC&lt;/code&gt; on it, returning the value, by pushing it onto the stack.&lt;/p&gt;

&lt;h4 id=&#34;magic&#34;&gt;Magic?&lt;/h4&gt;

&lt;p&gt;You might be wondering why functions dealing with tied variables are named &amp;ldquo;magic&amp;rdquo; or &amp;ldquo;mg&amp;rdquo;. The reason is that tied behavior for each variable is implemented via a pointer to a &lt;a href=&#34;https://perldoc.perl.org/perlguts.html#Magic-Virtual-Tables&#34;&gt;magic virtual table&lt;/a&gt; which is a structure containing function pointers to the tied behavior.&lt;/p&gt;

&lt;p&gt;Often the Perl C API will provide &lt;code&gt;mg&lt;/code&gt; (&amp;ldquo;magic&amp;rdquo;) and &lt;code&gt;nomg&lt;/code&gt; (&amp;ldquo;non magic&amp;rdquo;) variants of functions, so you can decide if you want to trigger the tied behavior.&lt;/p&gt;

&lt;h3 id=&#34;utf-8-tools&#34;&gt;UTF-8 tools&lt;/h3&gt;

&lt;p&gt;Perl has loads of tools for managing UTF-8 encoded text, but with XS you&amp;rsquo;re working in C, which does not. Start thinking about basic types like &lt;code&gt;char&lt;/code&gt;
and common assumptions in C code, and you&amp;rsquo;ll realize that multibyte characters can wreak havoc unless you handle them correctly.&lt;/p&gt;

&lt;p&gt;Fortunately, the Perl C API does provide &lt;a href=&#34;https://perldoc.perl.org/perlapi.html#Unicode-Support&#34;&gt;functions&lt;/a&gt; for managing UTF-8 data that
can help. Here are a couple of examples.&lt;/p&gt;

&lt;p&gt;Perl scalars have a UTF-8 flag, which is turned on when the scalar contains decoded UTF-8 data. We can detect it with &lt;code&gt;SvUTF8&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SV*
is_utf8(SV *foo)
PPCODE:
  /* if the UTF-8 flag is set return 1 &amp;quot;true&amp;quot; */
  if (SvUTF8(foo)) {
    PUSHs(sv_2mortal(newSViv(1)));
  }
  /* else return undef &amp;quot;false&amp;quot; */
  else {
    PUSHs(sv_newmortal());
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This declares an XS function called &lt;code&gt;is_utf8&lt;/code&gt; which accepts a scalar and returns true if the UTF-8 flag is set, or false if it isn&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;Imagine you have some C code that only works with ASCII text, that is, single byte characters. You can detect incoming scalars that have the UTF-8 flag turned on
with &lt;code&gt;SvUTF8&lt;/code&gt;, but what do you do about ones that have the flag?&lt;/p&gt;

&lt;p&gt;You could &lt;code&gt;croak&lt;/code&gt; immediately, throwing an exception. Or you could try to &lt;em&gt;downgrade&lt;/em&gt; the scalar to be non UTF-8 as the string may be marked as UTF-8 but only contain ASCII compatible characters (decimal values 0-127).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SV*
is_downgradeable(SV *foo)
PPCODE:
  /* if the UTF-8 flag is set and the scalar is not downgrade-able return
     undef */
  if (SvUTF8(foo) &amp;amp;&amp;amp; !sv_utf8_downgrade(foo, TRUE)) {
    PUSHs(sv_newmortal());
  }
  /* else return 1 */
  else {
    PUSHs(sv_2mortal(newSViv(1)));
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function returns false if the scalar contains data that is not downgrade-able to ASCII, otherwise it returns true. It does that by using the &lt;code&gt;sv_utf8_downgrade&lt;/code&gt; function, which accepts the scalar and a boolean value indicating if it&amp;rsquo;s ok to fail. As the second argument is &lt;code&gt;TRUE&lt;/code&gt;, the function simply returns false if the scalar is not downgrade-able (otherwise it would &lt;code&gt;croak&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Parts &lt;a href=&#34;http://localhost:1313/article/getting-started-with-xs/&#34;&gt;one&lt;/a&gt; and &lt;a href=&#34;http://localhost:1313/article/writing-your-own-xs-functions/&#34;&gt;two&lt;/a&gt; in this series contain the background information necessary to understand this one&lt;/li&gt;
&lt;li&gt;This series is also on CPAN (&lt;a href=&#34;https://metacpan.org/pod/XS::Tutorial&#34;&gt;XS::Tutorial&lt;/a&gt;) complete with all the code&lt;/li&gt;
&lt;li&gt;The &lt;a href=&#34;https://perldoc.perl.org/perlxs.html#The-BOOT%3a-Keyword&#34;&gt;BOOT&lt;/a&gt; keyword&lt;/li&gt;
&lt;li&gt;Tied variable &lt;a href=&#34;https://perldoc.perl.org/perlapi.html#Magical-Functions&#34;&gt;functions&lt;/a&gt; and the &lt;a href=&#34;https://perldoc.perl.org/perlguts.html#Magic-Virtual-Tables&#34;&gt;magic virtual table&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://perldoc.perl.org/perlapi.html#Unicode-Support&#34;&gt;Perl UTF-8 functions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
Cover image &amp;copy; &lt;a href=&#34;https://pixabay.com/en/plumbing-pipe-wrench-plumber-840835/&#34;&gt;Steve Buissinne&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building a UTF-8 encoder in Perl</title>
      <link>http://localhost:1313/article/building-a-utf-8-encoder-in-perl/</link>
      <pubDate>Tue, 02 Aug 2016 08:47:57 +0000</pubDate>
      
      <guid>http://localhost:1313/article/building-a-utf-8-encoder-in-perl/</guid>
      <description>

&lt;p&gt;This week I wrote a UTF-8 encoder/decoder. Perl already comes with UTF-8 encoding features built-in, so this wasn&amp;rsquo;t necessary, but sometimes it&amp;rsquo;s nice to understand how things work. The UTF-8 scheme is defined in &lt;a href=&#34;https://tools.ietf.org/html/rfc3629&#34;&gt;RFC 3629&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;what-does-a-utf-8-encoder-do&#34;&gt;What does a UTF-8 encoder do?&lt;/h3&gt;

&lt;p&gt;UTF-8 is a scheme for encoding &lt;a href=&#34;https://en.wikipedia.org/wiki/Unicode&#34;&gt;Unicode&lt;/a&gt; sequences of codepoints as bytes/octets. A codepoint is just a number, that identifies the Unicode entry (such as 0x24 which is a dollar sign).&lt;/p&gt;

&lt;p&gt;Unicode defines codepoints in the range 0x0000..0x10FFFF, so the encoder must take a codepoint and convert it to bytes according to the UTF-8 scheme, which looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Char. number range  |     UTF-8 bytes/octets sequence
   (hexadecimal)    |              (binary)
--------------------+------------------------------------
0000 0000-0000 007F | 0xxxxxxx
0000 0080-0000 07FF | 110xxxxx 10xxxxxx
0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This has some interesting properties. First of all, codepoints in the range 0x00..0x7F (0-127) will have the same bytes as with ASCII encoding, which is convenient. Second it&amp;rsquo;s a &lt;em&gt;variable width&lt;/em&gt; encoding, which means that a single codepoint can be 1-4 bytes long.&lt;/p&gt;

&lt;p&gt;Decoding is simply the process in reverse: converting a sequence of bytes back into a codepoint.&lt;/p&gt;

&lt;h3 id=&#34;encoding-utf-8&#34;&gt;Encoding UTF-8&lt;/h3&gt;

&lt;p&gt;To encode UTF-8, I need to convert a codepoint (which is just a number), into a sequence of bytes. As there are four different byte sequences defined in the UTF-8 table, there are four scenarios to handle:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;codepoint_to_bytes&lt;/span&gt; {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $codepoint &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; shift;

  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ($codepoint &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x80&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; pack &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;C&amp;#39;&lt;/span&gt;, $codepoint;
  }
  &lt;span style=&#34;color:#66d9ef&#34;&gt;elsif&lt;/span&gt; ($codepoint &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x800&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; pack &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;CC&amp;#39;&lt;/span&gt;,
           $codepoint &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b11000000&lt;/span&gt;,
           $codepoint       &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b00111111&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b10000000&lt;/span&gt;;
  }
  &lt;span style=&#34;color:#66d9ef&#34;&gt;elsif&lt;/span&gt; ($codepoint &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x10000&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; pack &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;CCC&amp;#39;&lt;/span&gt;,
           $codepoint &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b11100000&lt;/span&gt;,
           $codepoint &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b00111111&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b10000000&lt;/span&gt;,
           $codepoint       &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b00111111&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b10000000&lt;/span&gt;;
  }
  &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; pack &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;CCCC&amp;#39;&lt;/span&gt;,
           $codepoint &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b11110000&lt;/span&gt;,
           $codepoint &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b00111111&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b10000000&lt;/span&gt;,
           $codepoint &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b00111111&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b10000000&lt;/span&gt;,
           $codepoint       &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b00111111&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b10000000&lt;/span&gt;;
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first is the easiest: if the codepoint is between 0x00 and 0x7F, no transformation is required, so I just &lt;a href=&#34;https://perldoc.perl.org/functions/pack.html&#34;&gt;pack&lt;/a&gt; the codepoint as-is. The byte value of a character is the same as the codepoint (e.g. &lt;code&gt;&#39;U&#39; == 56 == 0x38 == 00111000&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;For the second scenario I have to populate the bitmask &lt;code&gt;110xxxxx 10xxxxxx&lt;/code&gt; with the codepoint, which means I need to return two bytes. This is how I do it:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;For the first byte, bitshift the codepoint 6 places to the right (as the second byte will get those 6 bits).&lt;/li&gt;
&lt;li&gt;Use bitwise OR to set the two most significant bits to one (&lt;code&gt;xxxxxxxx | 11000000 == 11xxxxxx&lt;/code&gt;). I&amp;rsquo;m using Perl&amp;rsquo;s inline binary notation (&lt;code&gt;0b...&lt;/code&gt;) which makes it easy to compare the binary numbers with the bitmask.&lt;/li&gt;
&lt;li&gt;For the second byte use bitwise AND to set the two most significant bits to zero (&lt;code&gt;xxxxxxxx &amp;amp; 00111111 == 00xxxxxx&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;Use bitwise OR to set the most significant bit to 1 (&lt;code&gt;xxxxxxxx | 10000000 == 1xxxxxxx&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;Use &lt;a href=&#34;https://perldoc.perl.org/functions/pack.html&#34;&gt;pack&lt;/a&gt; to combine the bytes into a scalar and return it.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The process for three byte and four byte encoding follows the same approach, with the rules updated according to the UTF-8 scheme.&lt;/p&gt;

&lt;p&gt;If I wanted to get UTF-8 encoded bytes for the &lt;a href=&#34;http://www.fileformat.info/info/unicode/char/1f4fa/fontsupport.htm&#34;&gt;Television&lt;/a&gt; codepoint (U+1F4FA) I could use the code like so:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $bytes &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; codepoint_to_bytes(&lt;span style=&#34;color:#ae81ff&#34;&gt;0x1F4FA&lt;/span&gt;);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;decoding-utf-8&#34;&gt;Decoding UTF-8&lt;/h3&gt;

&lt;p&gt;To decode UTF-8 bytes, we need to reverse the encoding process to get back to the original Unicode codepoint number. The decoder must check how many bytes it received, extract the appropriate bits and add them together.&lt;/p&gt;

&lt;p&gt;Perl tries &amp;ldquo;to make the easy things easy, and the hard things possible&amp;rdquo; as the saying goes, but sometimes it makes easy things harder than they are in simpler languages like C. Binary data is one such area: Perl needs to be told to turn off its character features before you can safely work with the data.&lt;/p&gt;

&lt;p&gt;There are two ways to do that. The old, discouraged way is to use the &lt;a href=&#34;https://metacpan.org/pod/bytes&#34;&gt;bytes pragma&lt;/a&gt;. The newer way is to use the &lt;a href=&#34;https://metacpan.org/pod/Encode#SYNOPSIS&#34;&gt;Encode&lt;/a&gt; module to encode the scalar as bytes and remove its UTF-8 flag. After that, Perl&amp;rsquo;s functions will treat the scalar as a sequence of bytes instead of characters:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Encode &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;encode&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bytes_to_codepoint&lt;/span&gt; {
  &lt;span style=&#34;color:#75715e&#34;&gt;# treat the scalar as bytes/octets&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $input    &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; encode(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;UTF-8&amp;#39;&lt;/span&gt;, shift);

  &lt;span style=&#34;color:#75715e&#34;&gt;# length returns number of bytes&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $len      &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; length $input;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $template &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;C&amp;#39;&lt;/span&gt; x $len;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @bytes    &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; unpack $template, $input;

  &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the subroutine &lt;code&gt;bytes_to_codepoint&lt;/code&gt; I use &lt;code&gt;encode()&lt;/code&gt; to populate &lt;code&gt;$input&lt;/code&gt; with the bytes passed to it. Next I use the &lt;code&gt;length&lt;/code&gt; function to return the number of bytes in &lt;code&gt;$input&lt;/code&gt; - this is different from its usual behavior which returns the number of characters; this is the effect of using &lt;code&gt;encode()&lt;/code&gt; to convert the scalar to bytes. Finally I use &lt;a href=&#34;https://perldoc.perl.org/functions/unpack.html&#34;&gt;unpack&lt;/a&gt; to extract the bytes from &lt;code&gt;$input&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now I know the number of bytes passed to &lt;code&gt;bytes_to_codepoint&lt;/code&gt;, it&amp;rsquo;s just a matter of reversing the binary operations from the encoding process:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ($len &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; $bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;];
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;elsif&lt;/span&gt; ($len &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (($bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b00011111&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
          ($bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b00111111&lt;/span&gt;);
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;elsif&lt;/span&gt; ($len &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;) {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (($bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b00001111&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
         (($bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b00111111&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
         ( $bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b00111111&lt;/span&gt;);
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (($bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b00000111&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
         (($bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b00111111&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
         (($bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b00111111&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
          ($bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b00111111&lt;/span&gt;);
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If there is just one byte, I return it as-is because the codepoint number is the same as the byte value. As with encoding, it gets interesting with two bytes:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Remove the bitmask from the first byte with bitwise AND. Remember bitwise AND returns any bits as zero which are zero in the right operand (&lt;code&gt;xxxxxxxx &amp;amp; 00011111 == 000xxxxx&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;Bit shift the resulting number 6 places to the left to get the original value. So &lt;code&gt;00000010&lt;/code&gt; would become &lt;code&gt;10000000&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Remove the bitmask from the second byte with bitwise AND (&lt;code&gt;xxxxxxxx &amp;amp; 00111111 == 00xxxxxx&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;Add the numbers together.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The same logic applies to three byte and four byte sequences, I just update the bitwise operations to match the UTF-8 scheme. The final code looks like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Encode &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;encode&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bytes_to_codepoint&lt;/span&gt; {
  &lt;span style=&#34;color:#75715e&#34;&gt;# treat the scalar as bytes/octets&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $input    &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; encode(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;UTF-8&amp;#39;&lt;/span&gt;, shift);

  &lt;span style=&#34;color:#75715e&#34;&gt;# length returns number of bytes&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $len      &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; length $input;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $template &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;C&amp;#39;&lt;/span&gt; x $len;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @bytes    &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; unpack $template, $input;

  &lt;span style=&#34;color:#75715e&#34;&gt;# reverse encoding&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ($len &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; $bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;];
  }
  &lt;span style=&#34;color:#66d9ef&#34;&gt;elsif&lt;/span&gt; ($len &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (($bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b00011111&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
            ($bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b00111111&lt;/span&gt;);
  }
  &lt;span style=&#34;color:#66d9ef&#34;&gt;elsif&lt;/span&gt; ($len &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (($bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b00001111&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
           (($bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b00111111&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
           ( $bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b00111111&lt;/span&gt;);
  }
  &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (($bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b00000111&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
           (($bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b00111111&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
           (($bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b00111111&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;
            ($bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b00111111&lt;/span&gt;);
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let&amp;rsquo;s say I wanted to get the codepoint for the &lt;a href=&#34;http://www.fileformat.info/info/unicode/char/1f5fc/index.htm&#34;&gt;Tokyo Tower&lt;/a&gt; I can call the code like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; utf8;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $codepoint &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bytes_to_codepoint(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;🗼&amp;#39;&lt;/span&gt;);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;notes&#34;&gt;Notes&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;This is a naive implementation - it doesn&amp;rsquo;t handle UTF-16 reserved characters (U+D800..U+DFFF), noncharacters and only encodes/decodes one codepoint at a time.&lt;/li&gt;
&lt;li&gt;Take a look at &lt;a href=&#34;https://metacpan.org/pod/Unicode::UTF8&#34;&gt;Unicode::UTF8&lt;/a&gt; if you need a fast UTF-8 encoder and don&amp;rsquo;t want to use Perl&amp;rsquo;s builtin tools.&lt;/li&gt;
&lt;li&gt;UTF-8 is by far the most popular Unicode encoding. It was created by Ken Thompson and Rob Pike in &lt;a href=&#34;http://doc.cat-v.org/bell_labs/utf-8_history&#34;&gt;just a few days&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Building your own UTF-8 encoder? Check out Markus Kuhn&amp;rsquo;s &lt;a href=&#34;https://www.cl.cam.ac.uk/~mgk25/ucs/examples/UTF-8-test.txt&#34;&gt;decoder test file&lt;/a&gt; which contains several difficult or edge case tests for UTF-8 decoding. Markus also wrote a comprehensive &lt;a href=&#34;https://www.cl.cam.ac.uk/~mgk25/unicode.html&#34;&gt;UTF-8 and Unicode FAQ for Unix/Linux&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

