<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Refactoring on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/refactoring/</link>
    <description>Recent content in Refactoring on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 25 Aug 2005 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/refactoring/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Perl Needs Better Tools</title>
      <link>http://localhost:1313/pub/2005/08/25/tools.html/</link>
      <pubDate>Thu, 25 Aug 2005 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2005/08/25/tools.html/</guid>
      <description>

&lt;p&gt;Perl is in danger of becoming a fading language&amp;ndash;new programmers are learning Java and Python in college, and companies like Google hardly use Perl at all. If you are afraid that Perl may be in danger of becoming irrelevant for medium-to-large projects, then read on.&lt;/p&gt;

&lt;h3 id=&#34;the-scary-part&#34;&gt;The Scary Part&lt;/h3&gt;

&lt;p&gt;I have discussed the future of Perl with managers from companies that currently use it and find that they worry about the future of Perl. One company I spoke with here in San Francisco is rewriting their core application in Java. Another company worries they will not be able to find new Perl programmers down the road. Yet another uses Perl for major projects, but suffers from difficulty in refactoring their extensive code base.&lt;/p&gt;

&lt;p&gt;There are many reasons why companies care about the future of Perl. I offer a part of a solution: better tools for Perl can be a major part of keeping Perl relevant and effective as the primary language for medium and large projects.&lt;/p&gt;

&lt;p&gt;When measuring the effectiveness of a development environment (people, language, tools, processes, etc.), a key measure is how expensive and painful it is to make changes to existing code. Once a project or system has grown to thousands of lines of code in dozens (or hundreds) of modules, the cost of making changes can escalate to the point where the team is afraid to make any significant change. Excellent tools are one of the ways to avoid this unhappy situation, or at least reduce its impact. Other factors are excellent processes and, of course, excellent people.&lt;/p&gt;

&lt;h3 id=&#34;21st-century-integrated-development-environments-for-perl&#34;&gt;21st-Century Integrated Development Environments for Perl&lt;/h3&gt;

&lt;p&gt;I propose that more, high-quality development tools will help keep Perl relevant and alive in medium and large project environments. My focus in this article is on IDEs, or Integrated Development Environments, and primarily those with a graphical interface.&lt;/p&gt;

&lt;p&gt;An IDE is an integrated set of tools for programming, combining a source code editor with a variety of other tools into a single package. Common features of modern IDEs include refactoring support, version control, real-time syntax checking, and auto-completion of code while typing.&lt;/p&gt;

&lt;p&gt;I want to make it clear right at the outset that a team of highly skilled Perl programmers, using only tools that have been around for years (such as &lt;code&gt;emacs&lt;/code&gt;, &lt;code&gt;vi&lt;/code&gt;, &lt;code&gt;cvs&lt;/code&gt;, and &lt;code&gt;make&lt;/code&gt;) can and do build large, sophisticated, and successful projects. I am not worried about those programmers. I am worried about the larger population of programmers with one to five years of experience, and those who have not yet begun to program: the next generation of Perl programmers.&lt;/p&gt;

&lt;p&gt;Great tools will not make a bad programmer into a good programmer, but they will certainly make a good programmer better. Unfortunately, the tools for Perl are years behind what is available for other languages, particularly Java.&lt;/p&gt;

&lt;p&gt;One powerful example is the lack of graphical IDEs for Perl with excellent support for refactoring. Several IDEs for Java have extensive refactoring support. Only one for Perl, the &lt;a href=&#34;http://e-p-i-c.sf.net/&#34;&gt;EPIC plugin for Eclipse&lt;/a&gt;, supports even a single refactoring action.&lt;/p&gt;

&lt;p&gt;For an example of how good IDEs have inspired at least one Perl developer, see &lt;a href=&#34;http://localhost:1313/authors/adam-kennedy&#34;&gt;Adam Kennedy&lt;/a&gt;&amp;rsquo;s &lt;a href=&#34;http://localhost:1313/pub/2005/06/09/ppi.html&#34;&gt;Perl.com article on his new PPI module&lt;/a&gt; and &lt;a href=&#34;https://metacpan.org/pod/Devel::Refactor&#34;&gt;Scott Sotka&amp;rsquo;s Devel::Refactor module&lt;/a&gt; (used in EPIC).&lt;/p&gt;

&lt;p&gt;I acknowledge that a graphical IDE is not the be-all of good tools. Just as some writers reject word processors in favor of typewriters or hand-written manuscripts, some programmers reject graphical IDEs and would refuse a job that required them to use one. Not everyone has (nor should have) the same tool set, and there are things a pencil can do that &lt;code&gt;vi&lt;/code&gt; and &lt;code&gt;emacs&lt;/code&gt; will never do. That said, IDEs have wide use in businesses doing larger projects, and for many programmers and teams they provide major increases in productivity.&lt;/p&gt;

&lt;p&gt;Another important point is that while this article discusses over a dozen specific tools or features, having all the tools in a single package produces the biggest value. An IDE that provides all of these features in a single package that people can easily install, easily extend, and easily maintain across an entire development team has far more value than the sum of its parts.&lt;/p&gt;

&lt;p&gt;There is a big win when the features provided by an IDE immediately upon installation include all or almost all of the tools and features discussed here and where the features &amp;ldquo;know&amp;rdquo; about each other. For example, it is good if you enter the name of a non-existent subroutine and the real-time syntax checker catches this. It is much better if the code-assist feature then pops up a context menu offering to create a stub for the subroutine or to correct the name to that of an existing similar subroutine or method from another class that is available to the current file. (This is standard behavior for some Java IDEs.)&lt;/p&gt;

&lt;h3 id=&#34;what-would-a-21st-century-perl-tool-set-contain&#34;&gt;What Would a 21st-Century Perl Tool Set Contain?&lt;/h3&gt;

&lt;p&gt;Perl needs a few great IDEs&amp;ndash;not just one, but more than one so that people have a diverse set to choose from. Perl deserves and needs a few great IDEs that lead the pack and set the standard for IDEs in other languages.&lt;/p&gt;

&lt;p&gt;I am well aware that the dynamic nature of Perl makes it harder to have a program that can read and understand a Perl program, especially a large and complex one, but the difficulty in comprehending a Perl program makes the value of such a tool all the greater, and I have faith that the Perl community can overcome some of the built-in challenges of Perl. Indeed, it is among the greatest strengths of Perl that Perl users can adapt the language to their needs.&lt;/p&gt;

&lt;p&gt;A great Perl IDE will contain at least the following, plus other features I haven&amp;rsquo;t thought of. (And, of course, there must be many of those!)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A &lt;a href=&#34;#Syntax-coloring_text_editor&#34;&gt;syntax-coloring text editor.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#Syntax-checking&#34;&gt;Real-time syntax-checking&lt;/a&gt; to catch and display syntax errors as you type.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#Version_control_integration&#34;&gt;Version control integration&lt;/a&gt; to check out and compare code using CVS, Subversion, etc.&lt;/li&gt;
&lt;li&gt;A &lt;a href=&#34;#Code-assist&#34;&gt;code-assist editor&lt;/a&gt;, to provide a list of methods when you type in an object reference, for example.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#refactoring_support&#34;&gt;Excellent refactoring support&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;A &lt;a href=&#34;#Tree_view_of_source&#34;&gt;tree view of source files and resources&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#support_for_unit_tests&#34;&gt;Support for creating and running unit tests&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#Language-specific_help&#34;&gt;Language-specific help&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#Debugger&#34;&gt;Real-time display of debugging results&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#Automatic_reformatting&#34;&gt;Automatic code reformatting&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Seamless &lt;a href=&#34;#handling_of_multiple_languages&#34;&gt;handling of multiple languages&lt;/a&gt; (such as Perl and C, Perl and Java, Perl and PHP, or Perl and Python).&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#Automated_build_and_test&#34;&gt;Automated build and test support&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Most of the screen shot examples in this article use the EPIC Perl IDE. At present, it has the largest amount of the features on my list (although it certainly doesn&amp;rsquo;t have all of them).&lt;/p&gt;

&lt;h4 id=&#34;span-id-syntax-coloring-text-editor-syntax-coloring-text-editor-span&#34;&gt;&lt;span id=&#34;Syntax-coloring_text_editor&#34;&gt;Syntax-Coloring Text Editor&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Most of you have probably seen this. It is available under &lt;code&gt;vim&lt;/code&gt;, &lt;code&gt;emacs&lt;/code&gt;, BBEdit, and TextPad. Just about every decent text editor will colorize source code so that keywords, operators, variables, etc., each have their own color, making it easier to spot syntax errors such as forgetting to close a quote pair.&lt;/p&gt;

&lt;h4 id=&#34;span-id-syntax-checking-real-time-syntax-checking-span&#34;&gt;&lt;span id=&#34;Syntax-checking&#34;&gt;Real-Time Syntax Checking&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_08_25_tools/syntax_check.gif&#34; alt=&#34;real-time syntax check example&#34; width=&#34;309&#34; height=&#34;135&#34; /&gt;
&lt;em&gt;Figure 1. Real-time syntax checking&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The IDE in Figure 1 shows that line 4 has an error because of the missing &lt;code&gt;)&lt;/code&gt; and that line 5 has an error because there is no declaration of &lt;code&gt;$naame&lt;/code&gt; (and &lt;code&gt;use strict&lt;/code&gt; is in effect).&lt;/p&gt;

&lt;p&gt;A key point here is that the IDE shows these errors right away, before you save and compile the code. (In this example, the EPIC IDE lets you specify how often to run the syntax check, from 0.01 to 10.00 seconds of idle time, or only on demand.)&lt;/p&gt;

&lt;p&gt;As nice as this is, it would be even better if the IDE also offered ways to fix the problem, for example, offering to change &lt;code&gt;$naame&lt;/code&gt; to &lt;code&gt;$name&lt;/code&gt;. Figure 2 shows an IDE that does exactly that; unfortunately, for Java, not Perl.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_08_25_tools/syntax_help.gif&#34; alt=&#34;syntax help from the IDE&#34; width=&#34;427&#34; height=&#34;150&#34; /&gt;
&lt;em&gt;Figure 2. Syntax help from the IDE&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;It would be great if Perl IDEs offered this kind of help.&lt;/p&gt;

&lt;h4 id=&#34;span-id-version-control-integration-version-control-integration-span&#34;&gt;&lt;span id=&#34;Version_control_integration&#34;&gt;Version Control Integration&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;All non-insane large projects use version control software. The most common version control software systems are probably CVS, Perforce, Subversion, and Visual SourceSafe. Figure 3 shows an IDE comparing the local version of a file to an older version from the CVS repository.&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2005_08_25_tools/cvs_compare.gif&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_08_25_tools/cvs_compare_sm.gif&#34; alt=&#34;Figure 3&#34; width=&#34;220&#34; height=&#34;143&#34; /&gt;&lt;/a&gt;&lt;br /&gt;
Figure 3. Comparing a local file to an older version in CVS--click image for full-size screen shot&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;CVS integration is available in many modern code editors, including &lt;code&gt;emacs&lt;/code&gt;, &lt;code&gt;vim&lt;/code&gt;, and BBEdit, as well as graphical IDEs such as Eclipse and Komodo Pro. Subversion integration is available as a plugin for Eclipse; Komodo Pro supports Perforce and Subversion.&lt;/p&gt;

&lt;h4 id=&#34;span-id-code-assist-a-code-assist-editor-span&#34;&gt;&lt;span id=&#34;Code-assist&#34;&gt;A Code-Assist Editor&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Suppose that you have just typed in an object reference and want to call a method on the object, but you are not sure what the method name is. Wouldn&amp;rsquo;t it be nice if the editor popped up a menu listing all of the methods available for that object? It might look something like Figure 4.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_08_25_tools/auto_completion.gif&#34; alt=&#34;automatic code completion&#34; width=&#34;399&#34; height=&#34;335&#34; /&gt;
&lt;em&gt;Figure 4. Automatic code completion&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;In this example, the IDE is able to figure out which class the object &lt;code&gt;$q&lt;/code&gt; is an instance of and lists the names of the available methods. If you type a &lt;code&gt;p&lt;/code&gt;, then the list shows only the method names beginning with &lt;code&gt;p&lt;/code&gt;. If you type &lt;code&gt;pa&lt;/code&gt;, then the list shows only the &lt;code&gt;param()&lt;/code&gt; and &lt;code&gt;parse_params()&lt;/code&gt; methods.&lt;/p&gt;

&lt;h4 id=&#34;span-id-refactoring-support-excellent-refactoring-support-span&#34;&gt;&lt;span id=&#34;refactoring_support&#34;&gt;Excellent Refactoring Support&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The easier it is to do refactoring, the more often people will do it. The following list contains the most common refactorings. Your personal list will probably be a little different. All of these are things you can do &amp;ldquo;manually,&amp;rdquo; but the idea is to make them into one or two-click operations so that you will do them much more often. (For a extensive list of refactoring operations, see &lt;a href=&#34;http://www.refactoring.com/catalog/&#34;&gt;Martin Fowler&amp;rsquo;s alphabetical list of refactorings&lt;/a&gt;.)&lt;/p&gt;

&lt;h5 id=&#34;span-id-extract-subroutinemethod-extract-subroutine-method-span&#34;&gt;&lt;span id=&#34;Extract_SubroutineMethod&#34;&gt;Extract Subroutine/Method&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;The IDE should create a new subroutine using the selected code and replace the selected code with a call to the new subroutine, with the proper parameters. Here&amp;rsquo;s an example of using the Extract Subroutine refactoring from Eclipse/EPIC (which uses the &lt;a href=&#34;https://metacpan.org/pod/Devel::Refactor&#34;&gt;Devel::Refactor&lt;/a&gt; module).&lt;/p&gt;

&lt;p&gt;First, you select a chunk of code to turn into a new subroutine, and then select Extract Subroutine from a context menu. You then get the a dialog box asking for the name of the new subroutine (shown in Figure 5).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_08_25_tools/extract_subroutine_before.gif&#34; alt=&#34;code before Extract Subroutine refactoring&#34; width=&#34;500&#34; height=&#34;329&#34; /&gt;
&lt;em&gt;Figure 5. Code before Extract Subroutine refactoring&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The IDE replaces the selected code with a call to the new subroutine, making reasonable guesses about the parameters and return values (Figure 6). You may need to clean up the result manually.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_08_25_tools/extract_subroutine_after.gif&#34; alt=&#34;code after Extract Subroutine refactoring&#34; width=&#34;500&#34; height=&#34;45&#34; /&gt;
&lt;em&gt;Figure 6. Code after Extract Subroutine&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Figure 7 shows the new subroutine created by the IDE. In this case, it needs no changes, but sometimes you will need to adjust the parameters and/or return value(s).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_08_25_tools/extract_subroutine_newsub.gif&#34; alt=&#34;the new subroutine created by Extract Subroutine&#34; width=&#34;314&#34; height=&#34;241&#34; /&gt;
&lt;em&gt;Figure 7. The new subroutine created by Extract Subroutine&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Ideally, the editor should prompt you to replace similar chunks of code with calls to the new subroutine.&lt;/p&gt;

&lt;h5 id=&#34;span-id-rename-subroutinemethod-rename-subroutine-method-span&#34;&gt;&lt;span id=&#34;Rename_SubroutineMethod&#34;&gt;Rename Subroutine/Method&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;The IDE should find all the calls to the subroutine throughout your project and offer to change them for you. You should be able to see a preview of all of the places a change could occur, and to accept or reject each one on a case-by-case basis. The action should be undoable.&lt;/p&gt;

&lt;h5 id=&#34;span-id-rename-variable-rename-variable-span&#34;&gt;&lt;span id=&#34;Rename_Variable&#34;&gt;Rename Variable&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;Like Rename Subroutine, this feature should find all occurrences throughout the project and offer to make the changes for you.&lt;/p&gt;

&lt;h5 id=&#34;span-id-change-subroutinemethod-signature-change-subroutine-method-signature-span&#34;&gt;&lt;span id=&#34;Change_SubroutineMethod_signature&#34;&gt;Change Subroutine/Method Signature&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;The IDE should be able to make reasonable guesses about whether each subroutine or method call is supplying the proper parameters. Partly this is to enable the &lt;a href=&#34;?page=2#Syntax-checking&#34;&gt;real-time syntax checking mentioned above&lt;/a&gt;, and partly this is to enable you to select a subroutine declaration and tell the IDE you want to refactor it by adding or removing a parameter. The IDE should then prompt you for the change(s) you want to make, do its best to find all of the existing calls to the subroutine, and offer to correct the subroutine calls to supply the new parameters.&lt;/p&gt;

&lt;p&gt;Obviously, this is an especially tricky thing to do in Perl, where subroutines fish their parameters out of &lt;code&gt;@_&lt;/code&gt;. So the IDE would have to look carefully at how the code uses &lt;code&gt;shift&lt;/code&gt;, &lt;code&gt;@_&lt;/code&gt;, and &lt;code&gt;$_[]&lt;/code&gt; in order to have a reasonable guess about the parameters the subroutine is expecting. In many common cases, though, a Perl IDE could make a reasonable guess about the parameters, such as in the following two examples, so that if you added or removed one, it could immediately prompt you about making corrections throughout the project:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub doSomething {
    my $gender = shift;
    my $age    = shift;
    # Not too terribly hard to guess that $gender and $age are params
}

sub anotherThing {
    my ($speed,$direction) = @_;
    # No magic needed to guess $speed and $direction are params.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;span-id-move-subroutinemethod-to-different-move-subroutine-method-span&#34;&gt;&lt;span id=&#34;Move_SubroutineMethod_to_different&#34;&gt;Move Subroutine/Method&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;This refactoring operation should give you a list or dialog box to choose the destination file in your project. The IDE should allow you to preview all of the changes that it would make to accomplish the move, which will include updating a call to the subroutine/method to use the proper class. At a minimum, the IDE should show you or list all of the calls to the subroutine so you can make the appropriate changes yourself. Ideally, the IDE should make a guess about possible destinations; for example, if &lt;code&gt;$self&lt;/code&gt; is a parameter to the method being moved, then the IDE might try assuming the method is an object (instance) method and initially only list destination classes that inherit from the source class, or from which the source class inherits.&lt;/p&gt;

&lt;h5 id=&#34;span-id-change-package-name-change-a-package-name-span&#34;&gt;&lt;span id=&#34;Change_package_name&#34;&gt;Change a Package Name&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;As with Rename Subroutine and Rename Variable, when changing a package name, the IDE should offer to update all existing references throughout your project.&lt;/p&gt;

&lt;h4 id=&#34;span-id-tree-view-of-source-tree-view-and-navigation-of-source-files-and-resources-span&#34;&gt;&lt;span id=&#34;Tree_view_of_source&#34;&gt;Tree View and Navigation of Source Files and Resources&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Another useful feature of good IDEs is being able to view all of the code for a project, or multiple projects, in a tree format, where you can &amp;ldquo;fold&amp;rdquo; and &amp;ldquo;unfold&amp;rdquo; the contents of folders. All of the modern graphical IDEs support this, even with multiple projects in different languages.&lt;/p&gt;

&lt;p&gt;Being able to view your project in this manner gives you both a high-level overview and the ability to drill down into specific files, and to mix levels of detail by having some folders show their contents and some not.&lt;/p&gt;

&lt;p&gt;For example, Figure 8 shows a partial screen shot from ActiveState&amp;rsquo;s Komodo IDE.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_08_25_tools/komodo_code_tree.gif&#34; alt=&#34;tree view of code in Komodo&#34; width=&#34;204&#34; height=&#34;318&#34; /&gt;
&lt;em&gt;Figure 8. Tree view of code in Komodo&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-support-for-unit-tests-support-for-creating-and-running-unit-tests-span&#34;&gt;&lt;span id=&#34;support_for_unit_tests&#34;&gt;Support for Creating and Running Unit Tests&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Anyone who has installed Perl modules from CPAN has seen unit tests&amp;ndash;these are the various, often copious, tests that run when you execute the &lt;code&gt;make test&lt;/code&gt; part of the installation process. The vast majority of CPAN modules include a suite of tests, often using the &lt;a href=&#34;https://metacpan.org/pod/Test::Harness&#34;&gt;Test::Harness&lt;/a&gt; and/or &lt;a href=&#34;https://metacpan.org/pod/Test::More&#34;&gt;Test::More&lt;/a&gt; modules. A good IDE will make it very easy to both create and run unit tests as you develop your project.&lt;/p&gt;

&lt;p&gt;The most basic form of support for unit tests in an IDE is simply to make it easy to execute arbitrary scripts from within the IDE. Create a &lt;em&gt;test.pl&lt;/em&gt; for your project and keep adding tests to it or to a &lt;em&gt;t/&lt;/em&gt; subdirectory as you develop, and keep running the script as you make changes. All modern IDEs provide at least this minimal capability.&lt;/p&gt;

&lt;p&gt;A more sophisticated level of support for unit tests might resemble the Java IDE feature for tests written in JUnit, where you can select an existing class file (a &lt;em&gt;.pm&lt;/em&gt; file in Perl) and ask the IDE to create a set of stub tests for every subroutine in the file. (See &lt;a href=&#34;http://www.junit.org/&#34;&gt;JUnit&lt;/a&gt; and the Perl module &lt;code&gt;Test::Unit&lt;/code&gt; for more on unit tests.) Furthermore, the IDE should support running a set of tests and giving simple visual feedback on what passed/failed. The standard approach in the JUnit world is to show either a &amp;ldquo;green bar&amp;rdquo; (all passed) or &amp;ldquo;red bar&amp;rdquo; (something failed) and then allow you to see details on failures. Other nice-to-have features include calculating code-coverage, providing statistical summaries of tests, etc.&lt;/p&gt;

&lt;p&gt;Figure 9 shows a successful run of a Java test suite with Eclipse.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_08_25_tools/unit_tests_success.gif&#34; alt=&#34;JUnit test run, success&#34; width=&#34;339&#34; height=&#34;199&#34; /&gt;
&lt;em&gt;Figure 9. A successful JUnit test run&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Figure 10 shows the same test run, this time with a failure.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_08_25_tools/unit_tests_failure.gif&#34; alt=&#34;JUnit test run, with a failure.&#34; width=&#34;339&#34; height=&#34;222&#34; /&gt;
&lt;em&gt;Figure 10. A JUnit test run with a failure&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A stack trace of the failure message appears in another part of the window (cropped out here to save space). If you double-click on the test that failed (&lt;code&gt;testInflate&lt;/code&gt;), the IDE will open the file (&lt;code&gt;BalloonTest&lt;/code&gt;, in this case) and navigate to the test function.&lt;/p&gt;

&lt;p&gt;The central idea is that the IDE should make it as painless as possible to add and modify and run tests, so you will do more of it during development.&lt;/p&gt;

&lt;h4 id=&#34;span-id-language-specific-help-language-specific-help-span&#34;&gt;&lt;span id=&#34;Language-specific_help&#34;&gt;Language-Specific Help&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;This is a fairly straightforward idea&amp;ndash;the IDE should be able to find and display the appropriate documentation for any keyword in your code, so if you highlight &lt;code&gt;push&lt;/code&gt; and ask for help, you should see the &lt;code&gt;push&lt;/code&gt; entry from the Perl documentation. If you highlight a method or subroutine or other symbol name from an imported module, the IDE should display the module&amp;rsquo;s documentation for the selected item. Of course, this requires that the documentation be available in a consistent, machine-readable form, which is only sometimes true.&lt;/p&gt;

&lt;h4 id=&#34;span-id-debugger-debugger-with-real-time-display-of-results-span&#34;&gt;&lt;span id=&#34;Debugger&#34;&gt;Debugger with Real-Time Display of Results&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;All modern IDEs offer support for running your code under a debugger, usually with visual display of what&amp;rsquo;s going on, including the state of variables. The &lt;a href=&#34;http://aspn.activestate.com/ASPN/docs/Komodo/3.1/komodo-doc-debugperl.html#debugperl_top&#34;&gt;Komodo IDE supports debugging Perl that is running either locally or remotely&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Typical support for debugging in an IDE includes the ability to set breakpoints, monitor the state of variables, etc. Basically, the IDE should provide support for all of the features of the debugger itself. Graphical IDEs should provide a visual display of what is going on.&lt;/p&gt;

&lt;h4 id=&#34;span-id-automatic-reformatting-automatic-code-reformatting-span&#34;&gt;&lt;span id=&#34;Automatic_reformatting&#34;&gt;Automatic Code Reformatting&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;This means automatically or on-demand re-indenting and other reformatting of code. For example, when you cut and paste a chunk of code, the IDE should support reformatting the chunk to match the indentation of its new location. If you change the number of spaces or tabs for each level of indentation, or your convention for the placement of curly braces, then the IDE should support adjusting an entire file or all files in your project.&lt;/p&gt;

&lt;h4 id=&#34;span-id-handling-of-multiple-languages-seamless-handling-of-multiple-languages-span&#34;&gt;&lt;span id=&#34;handling_of_multiple_languages&#34;&gt;Seamless Handling of Multiple Languages&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Many large software projects involve multiple languages. This is almost universally true in the case of web applications, where the user interface typically uses HTML, CSS, and JavaScript, and the back end uses one or more of Perl, PHP, Java, Python, Ruby, etc. It is very helpful to have development tools that seamlessly integrate work done in all of the languages. This is becoming quite common. For example, both Komodo and Eclipse support multiple languages.&lt;/p&gt;

&lt;h4 id=&#34;span-id-automated-build-and-test-automated-building-and-testing-span&#34;&gt;&lt;span id=&#34;Automated_build_and_test&#34;&gt;Automated Building and Testing&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;This feature can be very basic by making it easy to run an arbitrary script from within the IDE and to see its output. This could be as simple as having the IDE configured to have a one-click way of running the traditional Perl module build-and-test commands:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl Makefile.PL
$ make
$ make test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A more advanced version of this feature might involve having the IDE create stub code to test all of the subroutines in an existing file, or to run all of the scripts in a specified directory under &lt;code&gt;Test::Harness&lt;/code&gt;, or to run a set of tests using &lt;a href=&#34;https://metacpan.org/pod/Test::Unit::TestRunner&#34;&gt;Test::Unit::TestRunner&lt;/a&gt; or &lt;a href=&#34;https://metacpan.org/pod/Test::Unit::TkTestRunner&#34;&gt;Test::Unit::TkTestRunner&lt;/a&gt;. (The latter provides a GUI testing framework.)&lt;/p&gt;

&lt;h3 id=&#34;conclusion-and-recommendations&#34;&gt;Conclusion and Recommendations&lt;/h3&gt;

&lt;p&gt;While there are many tools for helping Perl development, the current state of the Perl toolbox is still years behind those of other languages&amp;ndash;perhaps three to five years behind, when compared to Java tools. While there are several tools for Java that have all the features described above, virtually none for Perl have all of them. On the other hand, things are looking up; they are better now than a year ago. It&amp;rsquo;s possible to close that gap in a year or two.&lt;/p&gt;

&lt;p&gt;A couple of obvious areas where improvements could be somewhat easy are adding more features to EPIC and Komodo. EPIC is open source, so there is potentially a wider pool of talent that could contribute. On the other hand, Komodo has a company with money behind it, so people actually get paid to improve it. Hopefully both tools will get better with time.&lt;/p&gt;

&lt;p&gt;Another interesting possibility is the development of new IDEs or adding to existing ones by using &lt;a href=&#34;http://localhost:1313/pub/2005/06/09/ppi.html&#34;&gt;Adam Kennedy&amp;rsquo;s PPI module&lt;/a&gt;, which provides the ability to parse Perl documents into a reasonable abstract syntax tree and to manipulate the elements and re-compose the document. There is a &lt;a href=&#34;https://metacpan.org/pod/Text::Editor::Vip&#34;&gt;new Perl editor project, VIP, that is in the design stages&lt;/a&gt; and is intended to be &amp;ldquo;pluggable&amp;rdquo; and to have special features to support pair programming.&lt;/p&gt;

&lt;p&gt;Finally, I&amp;rsquo;ve gathered a couple of lists of links for related material. The first list below consist of IDEs and graphical editors for Perl, and the second list consists of various related articles and websites. I hope this is all inspirational and helpful.&lt;/p&gt;

&lt;h3 id=&#34;current-ides-for-perl&#34;&gt;Current IDEs for Perl&lt;/h3&gt;

&lt;p&gt;The listed IDEs support Perl. The list is undoubtedly incomplete, but should form a good starting point for anyone wishing to look into this further.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.latenightsw.com/affrus/&#34;&gt;Affrus&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Perl only, Mac OS X only. Closed source (and hence not extensible by users). Primarily designed for CGI and standalone scripts. Free demo available. $99 to purchase. (See the &lt;a href=&#34;http://localhost:1313/pub/2004/05/14/affrus.html&#34;&gt;Perl.com review of Affrus&lt;/a&gt; to learn more.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://e-p-i-c.sf.net/&#34;&gt;Eclipse/EPIC&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;EPIC is a plugin for the &lt;a href=&#34;http://www.eclipse.org/&#34;&gt;Eclipse platform&lt;/a&gt;. Eclipse is open-source and cross platform (Windows/Mac/Linux/Solaris, etc.). Once you have Eclipse installed, &lt;a href=&#34;http://e-p-i-c.sf.net/updates&#34;&gt;install the EPIC plugin from within the Eclipse application&lt;/a&gt; using the &lt;a href=&#34;http://e-p-i-c.sf.net/updates/&#34;&gt;EPIC update URL&lt;/a&gt;. Eclipse supports Java, and with plugins, C/C++, COBOL, Perl, PHP, UML2, Python, Ruby, XML, and more. There is a large and active community around Eclipse.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Emacs is the mother of all text-editor/development-environment/adventure-game/all-in-one tools. Expert programmers use it widely and there are numerous enhancements for working with particular languages, including, of course, Perl. &lt;a href=&#34;http://www.emacswiki.org/cgi-bin/wiki/CPerlMode&#34;&gt;Emacs, with CPerlMode&lt;/a&gt;, is a richly featured IDE for Perl, albeit a non-GUI IDE (which, for some people, makes it even better). &lt;a href=&#34;http://groups.yahoo.com/group/extremeperl/files/&#34;&gt;A set of extensions for CPerlMode are available&lt;/a&gt; but you need to join the Yahoo Extreme Perl group to get to them.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.activestate.com/Products/Komodo/&#34;&gt;Komodo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This runs on Linux, Solaris, and Windows. Free demo; $29.95 for personal and student use, $295 for commercial use. It supports Perl, PHP, Python, Tcl, and XSLT.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.elora.hostings.com/SOFTWARE/page/&#34;&gt;PAGE&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;PAGE runs only on Windows (9x/ME/NT/2000/XP). It is a Rapid Application Development tool for Perl and comes in three versions: Free, Standard ($10), and Enterprise ($50). PAGE provides a several &amp;ldquo;wizards&amp;rdquo; for creating scripts, modules (packages), web forms, and even database applications.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.enginsite.com/Perl.htm&#34;&gt;Perl Editor&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This closed source program runs only on Windows (9x/NT/2000/XP). It has a GUI code profiler, and the Pro version has a regular expression tester and built-in web server (for CGI testing, etc.). Perl Editor claims to have the best debugger on the market. It also comes with GUI tools for managing MySQL databases. $69.95 to purchase.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.vim.org&#34;&gt;&lt;code&gt;vim&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The well-known descendent of &lt;code&gt;vi&lt;/code&gt; is a powerful and flexible text editor with many plugins and extensions. Have a look at the &lt;a href=&#34;https://www.vim.org&#34;&gt;&lt;code&gt;vim&lt;/code&gt; scripts&lt;/a&gt;; for example, &lt;a href=&#34;https://www.vim.org/scripts/script.php?script_id=556&#34;&gt;Perl-Support&lt;/a&gt; and &lt;a href=&#34;https://github.com/vim-scripts/ExecPerl&#34;&gt;ExecPerl&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.helpconsulting.net/visiperl/&#34;&gt;visiPerl&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This is a closed source application that runs on Win9x/NT/2000. It handles Perl and HTML and has code templates, being designed for website building. visiPerl includes a built-in web server for testing and an FTP client for code deployment. There is a free demo, or you can purchase it for $59.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;related-topics&#34;&gt;Related Topics&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.artima.com/intv/testdriven.html&#34;&gt;A conversation about Test-Driven Development&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;&lt;a href=&#34;http://www.petdance.com/perl/automated-testing/&#34;&gt;Automated Testing With Perl&lt;/a&gt;,&amp;rdquo; Andy Lester&amp;rsquo;s presentation on doing automated testing in Perl&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.extremeperl.org/bk/home&#34;&gt;Extreme Perl book&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://groups.yahoo.com/group/extremeperl/&#34;&gt;Extreme Perl mailing list&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jera.com/techinfo/xpfaq.html&#34;&gt;eXtreme Programming FAQ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://agilemanifesto.org/&#34;&gt;Manifesto for Agile Software Development&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;&lt;a href=&#34;http://localhost:1313/pub/2005/06/09/ppi.html&#34;&gt;Parse Perl Independently&lt;/a&gt;,&amp;rdquo; an article about Adam Kennedy&amp;rsquo;s PPI module&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.testdriven.com/&#34;&gt;testdriven.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.junit.org/&#34;&gt;JUnit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Jon Udell&amp;rsquo;s article on &amp;ldquo;&lt;a href=&#34;http://weblog.infoworld.com/udell/2005/05/23.html#a1236&#34;&gt;Tools for Dynamic Languages&lt;/a&gt;&amp;ldquo;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.refactoring.com/&#34;&gt;Refactoring home page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.xprogramming.com/&#34;&gt;XProgramming.com&lt;/a&gt;: Resources for and about Agile Software Development&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Porting Test::Builder to Perl 6</title>
      <link>http://localhost:1313/pub/2005/07/28/test_builder_p6.html/</link>
      <pubDate>Thu, 28 Jul 2005 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2005/07/28/test_builder_p6.html/</guid>
      <description>

&lt;p&gt;Perl 6 development now proceeds in two directions. The first is from the bottom up, with the creation and evolution of &lt;a href=&#34;http://www.parrotcode.org/&#34;&gt;Parrot&lt;/a&gt; and underlying code, including the Parrot Grammar Engine. The goal there is to build the structure Perl 6 will need. The second direction is from the top down, with the &lt;a href=&#34;http://www.pugscode.org/&#34;&gt;Pugs&lt;/a&gt; project implementing Perl 6 initially separate from Parrot, though recent additions allow an embedded Parrot to run the parsed code and to emit valid Parrot PIR code.&lt;/p&gt;

&lt;p&gt;Both projects are important and both help the design of Perl 6 and its implementation. Parrot is valuable in that it demonstrates a solid foundation for Perl 6 (and other similar languages); a far better foundation than the internals of Perl 5 have become. Pugs is important because it allows people to use Perl 6 productively now, with more features every day.&lt;/p&gt;

&lt;h3 id=&#34;motivation-and-design&#34;&gt;Motivation and Design&lt;/h3&gt;

&lt;p&gt;Perl culture values testing very highly. Several years ago, at the suggestion of Michael Schwern, I extracted the code that would become &lt;a href=&#34;https://metacpan.org/pod/Test::Builder&#34;&gt;Test::Builder&lt;/a&gt; from &lt;a href=&#34;https://metacpan.org/pod/Test::More&#34;&gt;Test::More&lt;/a&gt; and unified &lt;a href=&#34;https://metacpan.org/pod/Test::Simple&#34;&gt;Test::Simple&lt;/a&gt; and Test::More to share that back end. Now dozens of other testing modules, built upon Test::Builder, work together seamlessly.&lt;/p&gt;

&lt;p&gt;Pugs culture also values testing. However, there was no corresponding Test::Builder for Perl 6 yet&amp;ndash;there was only a single &lt;a href=&#34;http://svn.openfoundry.org/pugs/ext/Test/lib/Test.pm&#34;&gt;&lt;em&gt;Test.pm&lt;/em&gt;&lt;/a&gt; module that did most of what the early version of Test::More did in Perl 5.&lt;/p&gt;

&lt;p&gt;Schwern and I have discussed updates and refactorings of Test::Builder for the past couple of years. We made some mistakes in the initial design. As Perl 6 offers the chance to clean up Perl 5, so does a port of Test::Builder to Perl 6 offer the chance to clean up some of the design decisions we would make differently now.&lt;/p&gt;

&lt;p&gt;Internally, Test::Builder provides a few testing and reporting functions and keeps track of some test information. Most importantly, it contains a plan consisting of the number of tests expected to run. It also holds a list of details of every test it has seen. The testing and reporting functions add information to this list of test details. Finally, the module contains functions to report the test details in the standard &lt;a href=&#34;https://metacpan.org/pod/TAP::Base&#34;&gt;TAP&lt;/a&gt; format, so that tools such as &lt;a href=&#34;https://metacpan.org/pod/Test::Harness&#34;&gt;Test::Harness&lt;/a&gt; can interpret the results correctly.&lt;/p&gt;

&lt;p&gt;Test::Builder needs to do all of these things, but there are several ways to design the module&amp;rsquo;s internals. Some ways are better than others.&lt;/p&gt;

&lt;p&gt;The original Perl 5 version mashed all of this behavior together into one object-oriented module. To allow the use of multiple testing modules without confusing the count or the test details, &lt;code&gt;Test::Builder::new()&lt;/code&gt; always returns a singleton. All test modules call the constructor to receive the singleton object and call the test reporting methods to add details of the tests they handle.&lt;/p&gt;

&lt;p&gt;This works, but it&amp;rsquo;s a little inelegant. In particular, modules that test test modules have to go to a lot of trouble to work around the design. A more flexible design would make things like &lt;a href=&#34;https://metacpan.org/pod/Test::Builder::Tester&#34;&gt;Test::Builder::Tester&lt;/a&gt; much easier to write.&lt;/p&gt;

&lt;p&gt;The biggest change that Schwern and I have discussed is to separate the varying responsibilities into separate modules. The &lt;a href=&#34;http://svn.openfoundry.org/pugs/ext/Test-Builder/lib/Test/Builder.pm&#34;&gt;new Test::Builder object in Perl 6&lt;/a&gt; itself contains a &lt;a href=&#34;http://svn.openfoundry.org/pugs/ext/Test-Builder/lib/Test/Builder/TestPlan.pm&#34;&gt;Test::Builder::TestPlan&lt;/a&gt; object that represents the plan (the number of tests to run), a &lt;a href=&#34;http://svn.openfoundry.org/pugs/ext/Test-Builder/lib/Test/Builder/Output.pm&#34;&gt;Test::Builder::Output&lt;/a&gt; object that contains the filehandles to which to write TAP and diagnostic output, and an array of tests&amp;rsquo; results (all &lt;a href=&#34;http://svn.openfoundry.org/pugs/ext/Test-Builder/lib/Test/Builder/Test.pm&#34;&gt;Test::Builder::Test&lt;/a&gt; instances).&lt;/p&gt;

&lt;p&gt;The default constructor, &lt;code&gt;new()&lt;/code&gt;, still returns a singleton by default. However, modules that use Test::Builder can create their own objects, which perform the Test::Builder::TestPlan or Test::Builder::Output roles and pass them to the constructor to override the default objects created internally for the singleton. If a test module really needs a separate Test::Builder object, the alternate &lt;code&gt;create()&lt;/code&gt; method creates a new object that no other module will share.&lt;/p&gt;

&lt;p&gt;This strategy allows the Perl 6 version of &lt;a href=&#34;http://svn.openfoundry.org/pugs/ext/Test-Builder/lib/Test/Builder/Tester.pm&#34;&gt;Test::Builder::Tester&lt;/a&gt; to create its own Test::Builder object that reports tests as normal and then creates the shared singleton with output going to filehandles it can read instead of &lt;code&gt;STDOUT&lt;/code&gt; and &lt;code&gt;STDERR&lt;/code&gt;. The design appears to be sound; it took less than two hours to go from the idea of T::B::T to a fully working implementation&amp;ndash;counting a break to eat ice cream.&lt;/p&gt;

&lt;h3 id=&#34;first-attempts&#34;&gt;First Attempts&lt;/h3&gt;

&lt;p&gt;Translating Perl 5 OO code into Perl 6 OO code was mostly straightforward, despite my never having written any runnable Perl 6 OO code. (Also, Pugs was not far enough along that objects worked.)&lt;/p&gt;

&lt;h4 id=&#34;what-went-right&#34;&gt;What Went Right&lt;/h4&gt;

&lt;p&gt;One nice revelation is that opaque objects are actually easier to work with than blessed references. Even better, Perl 6&amp;rsquo;s improved function signatures reduce the necessity to write lots of boring boilerplate code.&lt;/p&gt;

&lt;p&gt;Breaking Test::Builder into separate pieces gave the opportunity for several other refactorings. One of my favorite is &amp;ldquo;Replace Condititional with Polymorphism&amp;rdquo;. There are four different types of tests that have different reporting styles: &lt;code&gt;pass&lt;/code&gt;, &lt;code&gt;fail&lt;/code&gt;, &lt;code&gt;SKIP&lt;/code&gt;, and &lt;code&gt;TODO&lt;/code&gt;. It made sense to create separate classes for each of those, giving each the responsibility and knowledge to produce the correct TAP output. Thus I wrote Test::Builder::Test, a façade factory class with a very smart constructor that creates and returns the correct test object based on the given arguments. When Test::Builder receives one of these test objects, it asks it to return the TAP string, passes that message to its contained Test::Builder::TestOutput object, and stores the test object in the list of run tests.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://conferences.oreillynet.com/os2005/&#34;&gt;&lt;img src=&#34;http://conferences.oreillynet.com/images/os2005/banners/468x60.gif&#34; alt=&#34;O&amp;#39;Reilly Open Source Convention 2005.&#34; width=&#34;468&#34; height=&#34;60&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;what-went-wrong&#34;&gt;What Went Wrong&lt;/h4&gt;

&lt;p&gt;Writing the base for all (or at least many) possible test modules is tricky. In this case, it was trebly so. Not only was this the first bit of practical OO Perl 6 code I&amp;rsquo;d written, but I had no way to test it, either by hand (how I tested the Perl 5 version, before Schwern and I worked out a way to write automated tests for it), or with automated tests. Pugs didn&amp;rsquo;t even have object support when I wrote this, though checking in this code pushed OO support higher on the schedule.&lt;/p&gt;

&lt;h5 id=&#34;infinite-loops-in-construction&#34;&gt;Infinite Loops in Construction&lt;/h5&gt;

&lt;p&gt;Originally, I thought all test classes would inherit from Test::Builder::Test. As Damian Conway pointed out, my technique created an infinite loop. (He suggested that &amp;ldquo;Don&amp;rsquo;t make a façade factory class an ancestor of the instantiable classes&amp;rdquo; is a design mistake akin to &amp;ldquo;Don&amp;rsquo;t get involved in a land war in Asia&amp;rdquo; and mumbled something else about battles of wits and Sicilians.) The code looked something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  class Test::Builder::Test
  {
      my Test::Builder::Test $:singleton is rw;

      has Bool $.passed;
      has Int  $.number;
      has Str  $.diagnostic;
      has Str  $.description;

      method new (Test::Builder::Test $class, *@args)
      {
          return $:singleton if $:singleton;
          $:singleton = $class.create( @args );
          return $:singleton;
      }

      method create(
          $number, 
          $passed       =  1,
          ?$skip        =  0,
          ?$todo        =  0,
          ?$reason      = &#39;&#39;,
          ?$description = &#39;&#39;,
      )
      {
          return Test::Builder::Test::TODO.new(
              description =&amp;gt; $description, reason =&amp;gt; $reason, passed =&amp;gt; $passed,
          ) if $todo;

          return Test::Builder::Test::Skip.new(
              description =&amp;gt; $description, reason =&amp;gt; $reason, passed =&amp;gt; 1,
          ) if $skip;

          return Test::Builder::Test::Pass.new(
              description =&amp;gt; $description, passed =&amp;gt; 1,
          ) if $passed;

          return Test::Builder::Test::TODO.new(
              description =&amp;gt; $description, passed =&amp;gt; 0,
          ) if $todo;
      }
  }

  class Test::Builder::Test::Pass is Test::Builder::Test {}
  class Test::Builder::Test::Fail is Test::Builder::Test {}
  class Test::Builder::Test::Skip is Test::Builder::Test { ... }
  class Test::Builder::Test::TODO is Test::Builder::Test { ... }

  # ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Why is this a singleton? I have no idea; I typed that code into the &lt;em&gt;wrong&lt;/em&gt; module and continued writing code a few minutes later, thinking that I knew what I was doing. The infinite loop stands out in my mind very clearly now. Because all of the concrete test classes inherit from Test::Builder::Test, they inherit its &lt;code&gt;new()&lt;/code&gt; method; none of them override it. Thus, they&amp;rsquo;ll all call &lt;code&gt;create()&lt;/code&gt; again (and none of them override &lt;em&gt;that&lt;/em&gt; either).&lt;/p&gt;

&lt;h5 id=&#34;confusing-initialization&#34;&gt;Confusing Initialization&lt;/h5&gt;

&lt;p&gt;I also struggled with the various bits and pieces of creating and building objects in Perl 6. There are a lot of hooks and overrides available, making the object system very flexible. However, without any experience or examples or guidance, choosing between &lt;code&gt;new()&lt;/code&gt;, &lt;code&gt;BUILD()&lt;/code&gt;, and &lt;code&gt;BUILDALL()&lt;/code&gt; is difficult.&lt;/p&gt;

&lt;p&gt;I realized I had no idea how to handle the singleton in Test::Builder. At least, when I realized that (for now) Test::Builder could remain a singleton, I didn&amp;rsquo;t know how or where to create it.&lt;/p&gt;

&lt;p&gt;I finally settled on putting it in &lt;code&gt;new()&lt;/code&gt;, with code much like that in the broken version of Test::Builder::Test previously. &lt;code&gt;new()&lt;/code&gt; eventually allocates space for, creates, and returns an opaque object. &lt;code&gt;BUILD()&lt;/code&gt; initializes it. This led me to write code something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  class Test::Builder;

  # ...

  has Test::Builder::Output   $.output;
  has Test::Builder::TestPlan $.plan;

  has @:results;

  submethod BUILD ( Test::Builder::Output ?$output, ?$TestPlan )
  {
      $.plan   = $TestPlan if $TestPlan;
      $.output = $output ?? $output :: Test::Builder::Output.new();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s a difference here because most uses of Test::Builder set the test plan explicitly later, after receiving the Test::Builder object. I added a &lt;code&gt;plan()&lt;/code&gt; method, too:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  method plan ( $self:, Str ?$explanation, Int ?$num )
  {
      die &amp;quot;Plan already set!&amp;quot; if $self.plan;

      if ($num)
      {
          $self.plan = Test::Builder::TestPlan.new( expect =&amp;gt; $num );
      }
      elsif $explanation ~~ &#39;no_plan&#39;
      {
          $self.plan = Test::Builder::NullPlan.new();
      }
      else
      {
          die &amp;quot;Unknown plan&amp;quot;;
      }

      $self.output.write( $self.plan.header() );
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are some stylistic errors in the previous code. First, when declaring an invocant, there&amp;rsquo;s a colon but no comma. Second, &lt;code&gt;fail&lt;/code&gt; is much better than &lt;code&gt;die&lt;/code&gt; (an assertion Damian made that I take on faith, having researched more serious issues instead). Third, the parenthesization of the cases in the &lt;code&gt;if&lt;/code&gt; statement is inconsistent.&lt;/p&gt;

&lt;h3 id=&#34;final-ha-version&#34;&gt;Final (Ha!) Version&lt;/h3&gt;

&lt;p&gt;Shortly after I checked in the example code, Stevan Little began work on a test suite (using &lt;em&gt;Test.pm&lt;/em&gt;). I knew that Pugs didn&amp;rsquo;t support many of the necessary language constructs, but this allowed Pugs hackers to identify necessary features and me to identify legitimate bugs and mistakes in the code. (It&amp;rsquo;s tricky to bootstrap test-driven development.)&lt;/p&gt;

&lt;p&gt;After filling out the test suite, fixing all of the known bugs in my code, talking other Pugs hackers into adding features I needed, and implementing those I couldn&amp;rsquo;t pawn off on others, Test::Builder works completely in Pugs right now. There is one remaining nice feature: splatty args in method calls. But I&amp;rsquo;m ready to port &lt;em&gt;Test.pm&lt;/em&gt; to the new back end and then write many, many more useful testing modules&amp;ndash;starting with a port of Mark Fowler&amp;rsquo;s Test::Builder::Tester written the night before this article went public!&lt;/p&gt;

&lt;p&gt;The singleton creation in &lt;code&gt;Test::Builder&lt;/code&gt; now looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  class Test::Builder-0.2.0;

  use Test::Builder::Test;
  use Test::Builder::Output;
  use Test::Builder::TestPlan;

  my  Test::Builder           $:singleton;
  has Test::Builder::Output   $.output handles &#39;diag&#39;;
  has Test::Builder::TestPlan $.testplan;
  has                         @:results;

  method new ( Test::Builder $Class: ?$plan, ?$output )
  {
      return $:singleton //= $Class.SUPER::new(
          testplan =&amp;gt; $plan, output =&amp;gt; $output
      );
  }

  method create ( Test::Builder $Class: ?$plan, ?$output )
  {
      return $Class.new( testplan =&amp;gt; $plan, output =&amp;gt; $output );
  }

  submethod BUILD
  (
      Test::Builder::TestPlan ?$.testplan,
      Test::Builder::Output   ?$.output = Test::Builder::Output.new()
  )
  {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Those test modules that want to use the default &lt;code&gt;$Test&lt;/code&gt; object directly can call &lt;code&gt;Test::Builder::new()&lt;/code&gt; to return the singleton, creating it if necessary. Test modules that need different output or plan objects should call &lt;code&gt;Test::Builder::create()&lt;/code&gt;. (The test suite actually does this.)&lt;/p&gt;

&lt;p&gt;Having removed the &lt;code&gt;Test::Builder&lt;/code&gt; code from &lt;code&gt;Test::Builder::Test&lt;/code&gt;, I revised the latter, as well:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  class Test::Builder::Test-0.2.0
  {
      method new (
          $number,     
          ?$passed      = 1,
          ?$skip        = 0,
          ?$todo        = 0,
          ?$reason      = &#39;&#39;, 
          ?$description = &#39;&#39;,
      )
      {
          return ::Test::Builder::Test::TODO.new(
              description =&amp;gt; $description, passed =&amp;gt; $passed, reason =&amp;gt; $reason
          ) if $todo;

          return ::Test::Builder::Test::Skip.new(
              description =&amp;gt; $description, passed =&amp;gt;       1, reason =&amp;gt; $reason
          ) if $skip;

          return ::Test::Builder::Test::Pass.new(
              description =&amp;gt; $description, passed =&amp;gt;       1,
          ) if $passed;

          return ::Test::Builder::Test::Fail.new(
              description =&amp;gt; $description, passed =&amp;gt;       0,
          );
      }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it. I moved the object attributes into roles. &lt;code&gt;Test::Builder::Test::Base&lt;/code&gt; is the basis for all tests, encapsulating all of the attributes that tests share and providing the important methods:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  role Test::Builder::Test::Base
  {
      has Bool $.passed;
      has Int  $.number;
      has Str  $.diagnostic;
      has Str  $.description;

      submethod BUILD (
          $.description,
          $.passed,
          ?$.number     =     0,
          ?$.diagnostic = &#39;???&#39;,
      ) {}

      method status returns Hash
      {
          return
          {
              passed      =&amp;gt; $.passed,
              description =&amp;gt; $.description,
          };
      }

      method report returns Str
      {
          my $ok          = $.passed ?? &#39;ok&#39; :: &#39;not ok&#39;;
          my $description = &amp;quot;- $.description&amp;quot;;
          return join( &#39; &#39;, $ok, $.number, $description );
      }

  }

  class Test::Builder::Test::Pass does Test::Builder::Test::Base {}
  class Test::Builder::Test::Fail does Test::Builder::Test::Base {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Test::Builder::Test::WithReason&lt;/code&gt; forms the basis for &lt;code&gt;TODO&lt;/code&gt; and &lt;code&gt;SKIP&lt;/code&gt; tests, adding the reason why the developer marked the test as either:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  role Test::Builder::Test::WithReason does Test::Builder::Test::Base
  {
      has Str $.reason;

      submethod BUILD ( $.reason ) {}

      method status returns Hash ( $self: )
      {
          my $status        = $self.SUPER::status();
          $status{&amp;quot;reason&amp;quot;} = $.reason;
          return $status;
      }
  }

  class Test::Builder::Test::Skip does Test::Builder::Test::WithReason { ... }
  class Test::Builder::Test::TODO does Test::Builder::Test::WithReason { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;what-s-hard&#34;&gt;What&amp;rsquo;s Hard&lt;/h4&gt;

&lt;p&gt;The two greatest difficulties I encountered in this porting effort were in mapping my design to the new Perl 6 way of thinking and in working around Pugs bugs and unsupported features. The former is interesting; it may suggest places where other people will run into difficulties.&lt;/p&gt;

&lt;p&gt;One of the trickiest parts of Perl 6&amp;rsquo;s OO model to understand is the interaction of the &lt;code&gt;new()&lt;/code&gt;, &lt;code&gt;BUILD()&lt;/code&gt;, and &lt;code&gt;BUILDALL()&lt;/code&gt; methods. Perl 5 provides very little in the way of object support beyond &lt;code&gt;bless&lt;/code&gt;. Though having finer-grained control over object creation, initialization, and initializer dispatch will be very useful, remembering the purposes of each method is very important, lest you override the wrong one and end up with an infinite loop or partially initialized object.&lt;/p&gt;

&lt;p&gt;From rereading the design documents, experimenting, picking the brains of other @Larry members, and thinking hard, my rules are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Leave &lt;code&gt;new()&lt;/code&gt; alone.&lt;/p&gt;

&lt;p&gt;This method creates the opaque object. Override it when you don&amp;rsquo;t want to return a new object of this class every time. Don&amp;rsquo;t do initialization here. Don&amp;rsquo;t forget to call &lt;code&gt;SUPER::new()&lt;/code&gt; if you actually want an object.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Override &lt;code&gt;BUILD()&lt;/code&gt; to add initialize attributes for objects of &lt;em&gt;this&lt;/em&gt; class.&lt;/p&gt;

&lt;p&gt;Think of this as an initializer, not a constructor.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Override &lt;code&gt;BUILDALL()&lt;/code&gt; when you want to change the order of initialization.&lt;/p&gt;

&lt;p&gt;I haven&amp;rsquo;t needed this yet and don&amp;rsquo;t expect to.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pugs-wise, find a good Haskell tutorial, find a really fast machine that can run GHC 6.4, and look for lambdacamel mentors on &lt;em&gt;#pugs&lt;/em&gt;. (My productivity increased when Autrijus told me about Haskell&amp;rsquo;s &lt;code&gt;trace&lt;/code&gt; function. He called it a refreshing desert in the oasis of referential transparency.)&lt;/p&gt;

&lt;h4 id=&#34;what-s-easy&#34;&gt;What&amp;rsquo;s Easy&lt;/h4&gt;

&lt;p&gt;Was this exercise valuable? Absolutely! It reinforced my belief that Perl 6 is not only Perlish, but that it&amp;rsquo;s a fantastic revolution of Perl 5 in several ways:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The object system is much better. Attributes and accessors require almost no syntax, and that only in their declarations. Using attributes feels Perlish, even if it&amp;rsquo;s not manipulating hash keys.&lt;/li&gt;
&lt;li&gt;Function signatures eliminate a lot of code. My initializers do a lot of work, but they don&amp;rsquo;t take much code. Some even have empty method bodies. This is a big win, except for the poor souls who had to implement the underlying binding code in Pugs. (That took a while.)&lt;/li&gt;
&lt;li&gt;Roles are fantastic. Sure, I believed in them already, but being able to use them without the hacks required in Perl 5 was even better.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;final-thoughts&#34;&gt;Final Thoughts&lt;/h4&gt;

&lt;p&gt;Schwern and I did put a lot of thought into the Perl 5 redesign we never really did, and my code here really benefits from the lessons I learned from the previous version. Still, even though I wrote code to a moving project that didn&amp;rsquo;t yet support all of the features I wanted, it was a great exercise. &lt;code&gt;Test::Builder&lt;/code&gt; is simpler, shorter, cleaner, and more flexible; it&amp;rsquo;s ready for everything the Perl 6 QA group can throw at it.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Test::Builder&lt;/code&gt; isn&amp;rsquo;t the only Perl 5 module being ported to Perl 6. Other modules include ports of HTTP::Server::Simple, Net::IRC, LWP, and &lt;code&gt;CGI&lt;/code&gt;. There are even ports underway for Catalyst and Maypole.&lt;/p&gt;

&lt;p&gt;Perl 6 isn&amp;rsquo;t ready yet, but it&amp;rsquo;s closer every day. Now&amp;rsquo;s a great time to port some of your code to see how Perl 6 is still Perlish, but a revolutionary step in refreshing new directions.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;chromatic is the author of &lt;a href=&#34;http://onyxneon.com/books/modern_perl/&#34;&gt;Modern Perl&lt;/a&gt;. In his spare time, he has been working on &lt;a href=&#34;http://trendshare.org/how-to-invest/&#34;&gt;helping novices understand stocks and investing&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Independently Parsing Perl</title>
      <link>http://localhost:1313/pub/2005/06/09/ppi.html/</link>
      <pubDate>Thu, 09 Jun 2005 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2005/06/09/ppi.html/</guid>
      <description>

&lt;p&gt;A few years into my programming career, I found myself involved in a somewhat unusual web project for an enormous global IT company. Due to some odd platform issues, we could write the intranet half of the project &lt;em&gt;only&lt;/em&gt; in Perl and the almost-identical public internet half &lt;em&gt;only&lt;/em&gt; in Java.&lt;/p&gt;

&lt;p&gt;In my efforts to pick up enough Java to help my Perl code interoperate with the code from the Java guys, I stumbled on a relatively new editor with the rather expansive name of JetBrains IntelliJ IDEA.&lt;/p&gt;

&lt;p&gt;What a joy! It quite simply made learning Java an absolute pleasure, with comprehensive tab completion, light and simple API docs, easy exploration of the mountain of Java classes, and unobtrusive indicators showing me my mistakes and offering to fix them. In short, it had lots of brains and a fast, clean user interface.&lt;/p&gt;

&lt;h3 id=&#34;where-is-intelliperl&#34;&gt;Where Is IntelliPerl?&lt;/h3&gt;

&lt;p&gt;Although I only needed it heavily for a few months, it&amp;rsquo;s been my gold standard ever since, and my definition of what a &amp;ldquo;great&amp;rdquo; editor should be. I install every new Perl editor and IDE I come across in the hope that Perl might one day get an editor half as good as what Java has had for years.&lt;/p&gt;

&lt;p&gt;These great editors are spreading. Java is now up to one and a half (Eclipse is nearly great but still seems not quite &amp;ldquo;effortless&amp;rdquo; enough about what it does). Dreamweaver gave HTML people their great editor years ago, and I&amp;rsquo;ve heard that Python may now have something that qualifies.&lt;/p&gt;

&lt;p&gt;Interestingly, these great editors seem to share one major thing in common.&lt;/p&gt;

&lt;h3 id=&#34;how-to-build-a-great-editor&#34;&gt;How to Build a Great Editor&lt;/h3&gt;

&lt;p&gt;Rather than relying on the language&amp;rsquo;s parser to examine code, great editors seem to implement special parsers of their own. These parsers treat a file less like code and more like a generic document (that just also happens to be code).&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s a key distinction, and one that provides two critical capabilities.&lt;/p&gt;

&lt;p&gt;First, it creates a &amp;ldquo;round-trip&amp;rdquo; capability, parsing a file into an internal model and back out again without moving a single white space character out of place. Even if parts of a file are broken or badly formatted, you can still change other parts of the file and save it correctly without it changing anything you don&amp;rsquo;t alter.&lt;/p&gt;

&lt;p&gt;Second, it makes the parser extremely safe and error-tolerant. Any code open in an editor is there for a reason&amp;ndash;generally because it isn&amp;rsquo;t finished yet, is broken, or needs changing. A document parser can hit a problem, flag it, stumble for a character or so until it finds something it recognizes, and then continue on.&lt;/p&gt;

&lt;p&gt;Parsing as code is an entirely different task, and one often unsuited to these type of faults.&lt;/p&gt;

&lt;p&gt;For example, take the following.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print &amp;quot;Hello World!\n&amp;quot;;

}

MyModule-&amp;gt;foobar;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For an editor using Perl itself to understand this code, it&amp;rsquo;s game over once it hits the naked closing brace, because the code is invalid. Without knowledge of what is below the brace, you lose all of the intelligence that needs the parser: syntax highlighting, module checking, helpful tips, the lot.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s just simply not a reasonable way to build an editor, where a file can be both unfinished and have dozens of bugs.&lt;/p&gt;

&lt;h3 id=&#34;building-a-document-parser-for-perl&#34;&gt;Building a Document Parser for Perl&lt;/h3&gt;

&lt;p&gt;Even without an editor to put it in (yet), a document parser for Perl would be extraordinarily useful for all sorts of tasks. At the time, though, all I really wanted was a really accurate HTML syntax highlighter.&lt;/p&gt;

&lt;p&gt;Some time in early 2002, I was bored one afternoon and had a first stab at the problem. The result was pretty predictable, given patterns I&amp;rsquo;ve seen in others trying the same thing. It was A) based on regular expressions, and B) useless for anything even remotely interesting.&lt;/p&gt;

&lt;p&gt;Between then and the start of The Perl Foundation grant in December 2004, I&amp;rsquo;ve spent a day or so a month on the problem, rewriting and throwing away code. I&amp;rsquo;ve junked two tokenizers, one lexer, an analysis package, three syntax highlighters, an obfuscation package, a quote engine, and half of the classes in the current object tree.&lt;/p&gt;

&lt;p&gt;Now, finally, &lt;a href=&#34;https://metacpan.org/pod/PPI&#34;&gt;PPI&lt;/a&gt; is complete, bar some minor features and testing. It is 100 percent round-trip safe, and it&amp;rsquo;s been stress tested against the 38,000 (non-Acme) modules in CPAN, handling all but 28 of the most broken and bizarre.&lt;/p&gt;

&lt;h3 id=&#34;what-does-it-do&#34;&gt;What Does It Do?&lt;/h3&gt;

&lt;p&gt;PPI should be the basis for any task where you need to parse, analyze or manipulate Perl, and it finally provides a platform for doing these tasks to their full potential. This covers a huge range of possible tasks; far too many to cover in any depth here.&lt;/p&gt;

&lt;p&gt;For this article, I want to demonstrate how PPI can improve existing tools that currently only do a very basic job, when there is the potential for so much more.&lt;/p&gt;

&lt;p&gt;One of these is part of the PAR application-packaging module. When PAR bundles a module into the internal include directory, it tries to reduce the size of the modules by stripping out POD. Of course, what would be better would be to strip out &lt;em&gt;everything&lt;/em&gt; that is excess and cut PAR file sizes even more.&lt;/p&gt;

&lt;p&gt;This is a form of compression, but given the potential confusion in using something like &amp;ldquo;Compress::Perl&amp;rdquo; as a name, I&amp;rsquo;m picking my own term. I hereby anoint the term &amp;ldquo;Squish&amp;rdquo;. A squished module occupies as little space as possible, having had redundant characters removed. It will be extremely small, although it might look a little &amp;ldquo;squished&amp;rdquo; to look at :)&lt;/p&gt;

&lt;h3 id=&#34;perl-squish&#34;&gt;Perl::Squish&lt;/h3&gt;

&lt;p&gt;Rather than showing you the final project, I prefer to show the process of squishing a single module.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Where is File::Spec on our system?
use Class::Inspector;
my $filename = Class::Inspector-&amp;gt;resolved_filename( &#39;File::Spec&#39; );

# Load File::Spec as a document
use PPI;
my $Document = PPI::Document-&amp;gt;new( $filename );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Everything you do with PPI starts and finishes with &lt;a href=&#34;https://metacpan.org/pod/PPI::Document&#34;&gt;PPI::Document&lt;/a&gt; objects. If you find yourself using the lexer directly, you are probably doing something wrong.&lt;/p&gt;

&lt;p&gt;Where can I start cutting out the fat? For starters, many core modules have an &lt;code&gt;__END__&lt;/code&gt; section.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Get the (one and only) __END__ section
my $End = $Document-&amp;gt;find_first( &#39;Statement::End&#39; );

# Delete it from the document
$End-&amp;gt;delete if $End;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PPI provides a set of search methods that you can use on any element that has children. &lt;code&gt;find_first&lt;/code&gt; is a safe guess, because there can only be one &lt;code&gt;__END__&lt;/code&gt; section. The search methods actually take &lt;code&gt;&amp;amp;wanted&lt;/code&gt; functions like &lt;a href=&#34;https://metacpan.org/pod/File::Find&#34;&gt;File::Find&lt;/a&gt;, so &lt;code&gt;&#39;Statement::End&#39;&lt;/code&gt; is really syntactic sugar for:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub wanted {
    my ($Document, $Element) = @_;
    $Element-&amp;gt;isa(&#39;PPI::Statement::End&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, there&amp;rsquo;s a faster way to do the same thing. The &lt;code&gt;prune&lt;/code&gt; method finds and immediately deletes all elements that match a particular condition.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Delete all comments and POD
$Document-&amp;gt;prune( &#39;Token::Pod&#39; );
$Document-&amp;gt;prune( &#39;Token::Comment&#39; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For a more serious example, here&amp;rsquo;s how to strip the non-compulsory braces from &lt;code&gt;-&amp;gt;method()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Remove useless braces
$Document-&amp;gt;prune( sub {
    my $Braces = $_[1];
    $Braces-&amp;gt;isa(&#39;PPI::Structure::List&#39;)      or return &#39;&#39;;
    $Braces-&amp;gt;children == 0                    or return &#39;&#39;;
    my $Method = $Braces-&amp;gt;sprevious_sibling   or return &#39;&#39;;
    $Method-&amp;gt;isa(&#39;PPI::Token::Word&#39;)          or return &#39;&#39;;
    $Method-&amp;gt;content !~ /:/                   or return &#39;&#39;;
    my $Operator = $Method-&amp;gt;sprevious_sibling or return &#39;&#39;;
    $Operator-&amp;gt;isa(&#39;PPI::Token::Operator&#39;)    or return &#39;&#39;;
    $Operator-&amp;gt;content eq &#39;-&amp;gt;&#39;                or return &#39;&#39;;
    return 1;
    } );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s a little bit wordy, but is relatively straightforward to write. Just add conditions and discard as you go. You can get other elements, calculate anything or call sub-searches.&lt;/p&gt;

&lt;p&gt;When you have finished, be sure to save the file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Save the file
$Document-&amp;gt;save( &amp;quot;$filename.squish&amp;quot; );
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;wrapping-it-all-up&#34;&gt;Wrapping It All Up&lt;/h3&gt;

&lt;p&gt;All you need to do now is is wrap it all up in some typical module boilerplate.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package Perl::Squish;

use strict;
use PPI;

our $VERSION = &#39;0.01&#39;;

# Squish a file in place
# Perl::Squish-&amp;gt;file( $filename )
sub file {
    my ($class, $file) = @_;
    my $Document = PPI::Document-&amp;gt;new( $file ) or return undef;
    $class-&amp;gt;document( $Document ) or return undef;
    $Document-&amp;gt;save( $file );
}

# Squish a document object
# Perl::Squish-&amp;gt;document( $Document );
sub document {
    my ($squish, $Document) = @_;

    # Remove the stuff we did earlier
    $Document-&amp;gt;prune(&#39;Statement::End&#39;);
    $Document-&amp;gt;prune(&#39;Token::Comment&#39;);
    $Document-&amp;gt;prune(&#39;Token::Pod&#39;);

    $Document-&amp;gt;prune( sub {
        my $Braces = $_[1];
        $Braces-&amp;gt;isa(&#39;PPI::Structure::List&#39;)      or return &#39;&#39;;
        $Braces-&amp;gt;elements == 0                    or return &#39;&#39;;
        my $Method = $Braces-&amp;gt;sprevious_sibling   or return &#39;&#39;;
        $Method-&amp;gt;isa(&#39;PPI::Token::Word&#39;)          or return &#39;&#39;;
        $Method-&amp;gt;content !~ /:/                   or return &#39;&#39;;
        my $Operator = $Method-&amp;gt;sprevious_sibling or return &#39;&#39;;
        $Operator-&amp;gt;isa(&#39;PPI::Token::Operator&#39;)    or return &#39;&#39;;
        $Operator-&amp;gt;content eq &#39;-&amp;gt;&#39;                or return &#39;&#39;;
        return 1;
        } );

    # Let&#39;s also do some whitespace cleanup
    my @whitespace = $Document-&amp;gt;find(&#39;Token::Whitespace&#39;);
    foreach ( @whitespace ) {
        $_-&amp;gt;{content} = $_-&amp;gt;{content} =~ /\n/ ? &amp;quot;\n&amp;quot; : &amp;quot; &amp;quot;;
    }

    1;
}

1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, the last step is to wrap it all up as a proper module. You can see the finished product prettied up with PPI&amp;rsquo;s syntax highlighter at &lt;a href=&#34;http://ali.as/CPAN/Squish.html&#34;&gt;CPAN::Squish&lt;/a&gt;. I&amp;rsquo;ve added a few additional small features to the basic code described above, but you get the idea. See also &lt;a href=&#34;https://metacpan.org/pod/Perl::Squish&#34;&gt;Perl::Squish&lt;/a&gt; for more details.&lt;/p&gt;

&lt;p&gt;In 15 minutes, I&amp;rsquo;ve knocked together a pretty simple module that dramatically improves on what you could do &lt;em&gt;without&lt;/em&gt; something like PPI. Now imagine the hard things it makes possible.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A Refactoring Example</title>
      <link>http://localhost:1313/pub/2003/10/09/refactoring.html/</link>
      <pubDate>Thu, 09 Oct 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/10/09/refactoring.html/</guid>
      <description>

&lt;p&gt;About a year ago, a person asked the &lt;a href=&#34;http://www.technofile.org/technofile/depts/mlists/fwp.html&#34;&gt;Fun With Perl&lt;/a&gt; mailing list about some code they had written to do database queries. It&amp;rsquo;s important to note that this person was posting from an .it address; why will become apparent later. The code was reading records in from a text file and then doing a series of queries based on that information. They wanted to make it faster.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s his code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($riga=&amp;lt;INPUT&amp;gt;){
$nump++;
chop($riga);
$pagina[$nump] = $riga;

$sth= $dbh-&amp;gt;prepare(&amp;quot;SELECT count(*) FROM lognew WHERE
pageid=&#39;$pagina[$nump]&#39; and data&amp;gt;=&#39;$startdate&#39;&amp;quot;);
$sth-&amp;gt;execute;
$totalvisit[$nump] = $sth-&amp;gt;fetchrow_array();

$sth = $dbh-&amp;gt;prepare(&amp;quot;SELECT count(*) FROM lognew WHERE
(pageid=&#39;$pagina[$nump]&#39; and data=&#39;$dataoggi&#39;)&amp;quot;);
$sth-&amp;gt;execute;
$totalvisittoday[$nump] = $sth-&amp;gt;fetchrow_array();

 $sth = $dbh-&amp;gt;prepare(&amp;quot;SELECT count(*) FROM lognew WHERE
(pageid=&#39;$pagina[$nump]&#39; and data=&#39;$dataieri&#39;)&amp;quot;);
$sth-&amp;gt;execute;
$totalyvisit[$nump] = $sth-&amp;gt;fetchrow_array();

 $sth= $dbh-&amp;gt;prepare(&amp;quot;SELECT count(*) FROM lognew WHERE
(pageid=&#39;$pagina[$nump]&#39; and data&amp;lt;=&#39;$fine30gg&#39; and data&amp;gt;=&#39;$inizio30gg&#39;)&amp;quot;);
$sth-&amp;gt;execute;
$totalmvisit[$nump] = $sth-&amp;gt;fetchrow_array();

 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I decided that rather than try to read through this code and figure out what it&amp;rsquo;s doing and how to make it faster, I&amp;rsquo;d clean it up first. Clean it up &lt;strong&gt;before&lt;/strong&gt; you figure out how it works? Yes, using a technique called &lt;em&gt;Refactoring&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;refactoring&#34;&gt;Refactoring?&lt;/h3&gt;

&lt;p&gt;In his book, Martin Fowler defines Refactoring as &lt;em&gt;&amp;ldquo;the process of changing a software system in such a way that it does not alter the external behavior of the code yet improves its internal structure.&amp;rdquo;&lt;/em&gt; In other words, you clean up your code but don&amp;rsquo;t change what it does.&lt;/p&gt;

&lt;p&gt;Refactoring can be as simple as changing this code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$exclamation = &#39;I like &#39;.$pastry.&#39;!&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$exclamation = &amp;quot;I like $pastry!&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Still does the same thing, but it&amp;rsquo;s easier to read.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s important to note that I don&amp;rsquo;t need to know anything about the contents of &lt;code&gt;$pastry&lt;/code&gt; or how &lt;code&gt;$exclamation&lt;/code&gt; is used. The change is completely self-contained and does not affect surrounding code or change what it does. This is Refactoring.&lt;/p&gt;

&lt;p&gt;On the principle of &amp;ldquo;show me don&amp;rsquo;t tell me,&amp;rdquo; rather than talk about it, we&amp;rsquo;ll dive right into refactoring our bit of code.&lt;/p&gt;

&lt;h3 id=&#34;fix-the-indentation&#34;&gt;Fix the Indentation&lt;/h3&gt;

&lt;p&gt;Your first impulse when faced with a hunk of code slammed against the left margin is to indent it. This is our first refactoring.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($riga=&amp;lt;INPUT&amp;gt;){
    $nump++;
    chop($riga);
    $pagina[$nump] = $riga;

    $sth= $dbh-&amp;gt;prepare(&amp;quot;SELECT count(*) FROM lognew WHERE
                         pageid=&#39;$pagina[$nump]&#39; and data&amp;gt;=&#39;$startdate&#39;&amp;quot;);
    $sth-&amp;gt;execute;
    $totalvisit[$nump] = $sth-&amp;gt;fetchrow_array();

    $sth = $dbh-&amp;gt;prepare(&amp;quot;SELECT count(*) FROM lognew WHERE
                          (pageid=&#39;$pagina[$nump]&#39; and data=&#39;$dataoggi&#39;)&amp;quot;);
    $sth-&amp;gt;execute;
    $totalvisittoday[$nump] = $sth-&amp;gt;fetchrow_array();

    $sth = $dbh-&amp;gt;prepare(&amp;quot;SELECT count(*) FROM lognew WHERE
                          (pageid=&#39;$pagina[$nump]&#39; and data=&#39;$dataieri&#39;)&amp;quot;);
    $sth-&amp;gt;execute;
    $totalyvisit[$nump] = $sth-&amp;gt;fetchrow_array();

    $sth= $dbh-&amp;gt;prepare(&amp;quot;SELECT count(*) FROM lognew WHERE
                         (pageid=&#39;$pagina[$nump]&#39; and data&amp;lt;=&#39;$fine30gg&#39; 
                         and data&amp;gt;=&#39;$inizio30gg&#39;)&amp;quot;);
    $sth-&amp;gt;execute;
    $totalmvisit[$nump] = $sth-&amp;gt;fetchrow_array();
}

close (INPUT);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Already it looks better. We can see that we&amp;rsquo;re iterating over a file, performing some SELECTs on each line and shoving the results into a bunch of arrays.&lt;/p&gt;

&lt;h3 id=&#34;a-single-simple-change&#34;&gt;A Single, Simple Change&lt;/h3&gt;

&lt;p&gt;One of the most important principles of Refactoring is that you work in small steps. This re-indentation is a single step. And part of this single step includes running the test suite, logging the change, and checking it into CVS.&lt;/p&gt;

&lt;p&gt;Checking into CVS after something this simple? Yes. Many programmers ask the question, &amp;ldquo;When should I check in?&amp;rdquo; When you&amp;rsquo;re refactoring it&amp;rsquo;s simple: check in when you&amp;rsquo;ve done one refactoring and have tested that it works. Our re-indentation is one thing; we test that it works and check it in.&lt;/p&gt;

&lt;p&gt;This may seem excessive, but it prevents us from entangling two unrelated changes together. By doing one change at a time we know that any new bugs were introduced by that one change. Also, you will often decide in the middle of a refactoring that it&amp;rsquo;s not such a good idea. When you&amp;rsquo;ve checked in at every one you can simply rollback to the last version rather than having to undo it by hand. Convenient, and you&amp;rsquo;re sure no stray bits of your aborted change are hanging around.&lt;/p&gt;

&lt;p&gt;So our procedure for doing a proper refactoring is:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Make one logical change to the code.&lt;/li&gt;
&lt;li&gt;Make sure it passes tests.&lt;/li&gt;
&lt;li&gt;Log and check in.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;big-refactorings-from-small&#34;&gt;Big Refactorings from Small&lt;/h3&gt;

&lt;p&gt;The goal of this refactoring is to make the code go faster. One of the simplest ways to do achieve that is to pull necessary code out of the loop. Preparing four new statements in every iteration of the loop seems really unnecessary. We&amp;rsquo;d like to pull those &lt;code&gt;prepare()&lt;/code&gt; statements out of the loop. This is a refactoring. To achieve this larger refactoring, a series of smaller refactorings must be done.&lt;/p&gt;

&lt;h3 id=&#34;use-bind-variables&#34;&gt;Use Bind Variables&lt;/h3&gt;

&lt;p&gt;Each time through the loop, a new set of SQL statements is created based on the line read in. But they&amp;rsquo;re all basically the same, just the data is changing. If we could pull that data out of the statement we&amp;rsquo;d be closer to our goal of pulling the &lt;code&gt;prepare()&lt;/code&gt;s out of the loop.&lt;/p&gt;

&lt;p&gt;So my next refactoring pulls variables out of the SQL statements and replaces them with placeholders. Then the data is bound to the statement using bind variables. This means we&amp;rsquo;re now &lt;code&gt;prepare()&lt;/code&gt;ing the same statements every time through the loop.&lt;/p&gt;

&lt;p&gt;Before refactoring:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$sth= $dbh-&amp;gt;prepare(&amp;quot;SELECT count(*) FROM lognew WHERE
                     pageid=&#39;$pagina[$nump]&#39; and data&amp;gt;=&#39;$startdate&#39;&amp;quot;);
$sth-&amp;gt;execute;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After refactoring:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$sth= $dbh-&amp;gt;prepare(&#39;SELECT count(*) FROM lognew WHERE 
                     pageid=? and data&amp;gt;=?&#39;);
$sth-&amp;gt;execute($pagina[$nump], $startdate);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bind variables also protect against a naughty user from trying to slip some extra SQL into your program via the data you read in. As a side-effect of our code cleanup, we&amp;rsquo;ve closed a potential security hole.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($riga=&amp;lt;INPUT&amp;gt;){
    $nump++;
    chop($riga);
    $pagina[$nump] = $riga;

    $sth= $dbh-&amp;gt;prepare(&#39;SELECT count(*) FROM lognew WHERE 
                         pageid=? and data&amp;gt;=?&#39;);
    $sth-&amp;gt;execute($pagina[$nump], $startdate);
    $totalvisit[$nump] = $sth-&amp;gt;fetchrow_array();

    $sth = $dbh-&amp;gt;prepare(&#39;SELECT count(*) FROM lognew WHERE
                          (pageid=? and data=?)&#39;);
    $sth-&amp;gt;execute($pagina[$nump], $dataoggi);
    $totalvisittoday[$nump] = $sth-&amp;gt;fetchrow_array();

    $sth = $dbh-&amp;gt;prepare(&#39;SELECT count(*) FROM lognew WHERE
                          (pageid=? and data=?)&#39;);
    $sth-&amp;gt;execute($pagina[$nump], $dataieri);
    $totalyvisit[$nump] = $sth-&amp;gt;fetchrow_array();

    $sth= $dbh-&amp;gt;prepare(&#39;SELECT count(*) FROM lognew WHERE
                         (pageid=? and data&amp;lt;=? and data&amp;gt;=?)&#39;);
    $sth-&amp;gt;execute($pagina[$nump], $fine30gg, $inizio30gg);
    $totalmvisit[$nump] = $sth-&amp;gt;fetchrow_array();
}

close (INPUT);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test. Log. Check in.&lt;/p&gt;

&lt;h3 id=&#34;split-a-poorly-reused-variable&#34;&gt;Split a Poorly Reused Variable&lt;/h3&gt;

&lt;p&gt;The next stumbling block to pulling the &lt;code&gt;prepare()&lt;/code&gt; statements out of the loop is that they all use the same variable, &lt;code&gt;$sth&lt;/code&gt;. We&amp;rsquo;ll have to change it so they all use different variables. While we&amp;rsquo;re at it, we&amp;rsquo;ll name those statement handles something more descriptive of what the statement does. Since at this point we haven&amp;rsquo;t figured out what the statements do, we can base the name on the array it gets assigned to.&lt;/p&gt;

&lt;p&gt;While we&amp;rsquo;re at it, throw in some &lt;code&gt;my()&lt;/code&gt; declarations to limit the scope of these variables to just the loop.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($riga=&amp;lt;INPUT&amp;gt;){
    $nump++;
    chop($riga);
    $pagina[$nump] = $riga;

    my $totalvisit_sth = $dbh-&amp;gt;prepare(&#39;SELECT count(*) FROM lognew WHERE 
                                        pageid=? and data&amp;gt;=?&#39;);
    $totalvisit_sth-&amp;gt;execute($pagina[$nump], $startdate);
    $totalvisit[$nump] = $totalvisit_sth-&amp;gt;fetchrow_array();

    my $totalvisittoday_sth = $dbh-&amp;gt;prepare(&#39;SELECT count(*) FROM lognew WHERE
                                             (pageid=? and data=?)&#39;);
    $totalvisittoday_sth-&amp;gt;execute($pagina[$nump], $dataoggi);
    $totalvisittoday[$nump] = $totalvisittoday_sth-&amp;gt;fetchrow_array();

    my $totalyvisit_sth = $dbh-&amp;gt;prepare(&#39;SELECT count(*) FROM lognew WHERE
                                         (pageid=? and data=?)&#39;);
    $totalyvisit_sth-&amp;gt;execute($pagina[$nump], $dataieri);
    $totalyvisit[$nump] = $totalyvisit_sth-&amp;gt;fetchrow_array();

    my $totalmvisit_sth= $dbh-&amp;gt;prepare(&#39;SELECT count(*) FROM lognew WHERE
                                        (pageid=? and data&amp;lt;=? and data&amp;gt;=?)&#39;);
    $totalmvisit_sth-&amp;gt;execute($pagina[$nump], $fine30gg, $inizio30gg);
    $totalmvisit[$nump] = $totalmvisit_sth-&amp;gt;fetchrow_array();
}

close (INPUT);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test. Log. Check in.&lt;/p&gt;

&lt;h3 id=&#34;getting-better-all-the-time&#34;&gt;Getting Better All the Time&lt;/h3&gt;

&lt;p&gt;The new names are better, but they&amp;rsquo;re not great. This is ok. Naming is something people often get hung up on. One can spend hours wracking their brains thinking of the perfect name for a variable or a function. If you can think of a better one than what&amp;rsquo;s there right now, use it. The beauty of Refactoring is you an always improve upon it later.&lt;/p&gt;

&lt;p&gt;This is an important lesson of Refactoring. Voltare said, &amp;ldquo;the best is the enemy of the good&amp;rdquo;. We often get so wound up trying to make code &lt;em&gt;great&lt;/em&gt; that we fail to improve it at all. In refactoring, it&amp;rsquo;s not so important to make your code great in one leap, just a little better all the time (it&amp;rsquo;s a little known fact John Lennon was into Refactoring.) These small improvements will build up into a clean piece of code, with less bugs, more surely than a large-scale code cleanup would.&lt;/p&gt;

&lt;h3 id=&#34;pull-code-out-of-the-loop&#34;&gt;Pull Code Out of the Loop&lt;/h3&gt;

&lt;p&gt;Now it&amp;rsquo;s a simple cut and paste to pull the four &lt;code&gt;prepare()&lt;/code&gt; statements out of the loop.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $totalvisit_sth = $dbh-&amp;gt;prepare(&#39;SELECT count(*) FROM lognew WHERE 
                                    pageid=? and data&amp;gt;=?&#39;);

my $totalvisittoday_sth = $dbh-&amp;gt;prepare(&#39;SELECT count(*) FROM lognew WHERE
                                         (pageid=? and data=?)&#39;);

my $totalyvisit_sth = $dbh-&amp;gt;prepare(&#39;SELECT count(*) FROM lognew WHERE
                                     (pageid=? and data=?)&#39;);

my $totalmvisit_sth = $dbh-&amp;gt;prepare(&#39;SELECT count(*) FROM lognew WHERE
                                     (pageid=? and data&amp;lt;=? and data&amp;gt;=?)&#39;);

open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($riga=&amp;lt;INPUT&amp;gt;){
    $nump++;
    chop($riga);
    $pagina[$nump] = $riga;

    $totalvisit_sth-&amp;gt;execute($pagina[$nump], $startdate);
    $totalvisit[$nump] = $totalvisit_sth-&amp;gt;fetchrow_array();

    $totalvisittoday_sth-&amp;gt;execute($pagina[$nump], $dataoggi);
    $totalvisittoday[$nump] = $totalvisittoday_sth-&amp;gt;fetchrow_array();

    $totalyvisit_sth-&amp;gt;execute($pagina[$nump], $dataieri);
    $totalyvisit[$nump] = $totalyvisit_sth-&amp;gt;fetchrow_array();

    $totalmvisit_sth-&amp;gt;execute($pagina[$nump], $fine30gg, $inizio30gg);
    $totalmvisit[$nump] = $totalmvisit_sth-&amp;gt;fetchrow_array();
}

close (INPUT);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Already the code is looking better. With the SQL separated, the inner workings of the loop are much less daunting.&lt;/p&gt;

&lt;p&gt;Test. Log. Check in.&lt;/p&gt;

&lt;h3 id=&#34;a-place-to-stop&#34;&gt;A Place to Stop&lt;/h3&gt;

&lt;p&gt;Remember our goal, to make this code run faster. By pulling the &lt;code&gt;prepare()&lt;/code&gt; statements outside the loop we&amp;rsquo;ve likely achieved this goal. Additionally, it still does exactly what it did before even though we still don&amp;rsquo;t fully understand what that is. If this were a real project, you&amp;rsquo;d do some benchmarking to see if the code is fast enough and move on to another task.&lt;/p&gt;

&lt;p&gt;Since this is an example, I&amp;rsquo;ll continue with more refactorings with the goal of clarifying the code further and figuring out what it does.&lt;/p&gt;

&lt;p&gt;Keep in mind that after every refactoring the code still does &lt;em&gt;exactly what it did before&lt;/em&gt;. This means we can stop choose to stop after any refactoring. If a more pressing task suddenly pops up we can pause our refactoring work and attend to that feeling confident we didn&amp;rsquo;t leave any broken code lying around.&lt;/p&gt;

&lt;h3 id=&#34;reformat-sql-for-better-readability&#34;&gt;Reformat SQL for Better Readability&lt;/h3&gt;

&lt;p&gt;In order to make sense of the code, we have to make sense of the SQL. The simplest way to better understand the SQL is to put it into a clearer format.&lt;/p&gt;

&lt;p&gt;The three major parts of an SQL SELECT statement are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The rows (ie. &lt;code&gt;SELECT count(*)&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;The table (ie. &lt;code&gt;FROM lognew&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;The predicate (ie. &lt;code&gt;WHERE pageid = ...&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I&amp;rsquo;ve chosen a new format that highlights these parts.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve also removed some unnecessary parenthesis because they just serve to clutter things up rather than disambiguate an expression.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve also decided to change the quoting style from single quotes to a here-doc. It would have also been okay to use &lt;code&gt;q{}&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $totalvisit_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*)
FROM   lognew 
WHERE  pageid =  ? AND 
       data   &amp;gt;= ?
SQL

my $totalvisittoday_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid = ? AND 
       data   = ?
SQL

my $totalyvisit_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid = ? AND 
       data   = ?
SQL

my $totalmvisit_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid =  ? AND
       data   &amp;lt;= ? AND 
       data   &amp;gt;= ?
SQL

open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($riga=&amp;lt;INPUT&amp;gt;){
    $nump++;
    chop($riga);
    $pagina[$nump] = $riga;

    $totalvisit_sth-&amp;gt;execute($pagina[$nump], $startdate);
    $totalvisit[$nump] = $totalvisit_sth-&amp;gt;fetchrow_array();

    $totalvisittoday_sth-&amp;gt;execute($pagina[$nump], $dataoggi);
    $totalvisittoday[$nump] = $totalvisittoday_sth-&amp;gt;fetchrow_array();

    $totalyvisit_sth-&amp;gt;execute($pagina[$nump], $dataieri);
    $totalyvisit[$nump] = $totalyvisit_sth-&amp;gt;fetchrow_array();

    $totalmvisit_sth-&amp;gt;execute($pagina[$nump], $fine30gg, $inizio30gg);
    $totalmvisit[$nump] = $totalmvisit_sth-&amp;gt;fetchrow_array();
}

close (INPUT);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test. Log. Check in.&lt;/p&gt;

&lt;h3 id=&#34;remove-redundancy&#34;&gt;Remove Redundancy&lt;/h3&gt;

&lt;p&gt;With the SQL in a more readable format, some commonalities become clear.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;All the statements are doing a &lt;code&gt;count(*)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;They&amp;rsquo;re all using the &lt;code&gt;lognew&lt;/code&gt; table&lt;/li&gt;
&lt;li&gt;They&amp;rsquo;re all looking for a certain &lt;code&gt;pageid&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In fact, &lt;code&gt;$totalvisittoday_sth&lt;/code&gt; and &lt;code&gt;$totalyvisit_sth&lt;/code&gt; are exactly the same! Let&amp;rsquo;s eliminate one of them, doesn&amp;rsquo;t matter which, we&amp;rsquo;re going to rename them in a moment anyway. &lt;code&gt;$totalyvisit_sth&lt;/code&gt; goes away, making sure to change all references to it to &lt;code&gt;$totalvisittoday_sth&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $totalvisit_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*)
FROM   lognew 
WHERE  pageid =  ? AND 
       data   &amp;gt;= ?
SQL

my $totalvisittoday_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid = ? AND 
       data   = ?
SQL

my $totalmvisit_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid =  ? AND
       data   &amp;lt;= ? AND 
       data   &amp;gt;= ?
SQL

open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($riga=&amp;lt;INPUT&amp;gt;){
    $nump++;
    chop($riga);
    $pagina[$nump] = $riga;

    $totalvisit_sth-&amp;gt;execute($pagina[$nump], $startdate);
    $totalvisit[$nump] = $totalvisit_sth-&amp;gt;fetchrow_array();

    $totalvisittoday_sth-&amp;gt;execute($pagina[$nump], $dataoggi);
    $totalvisittoday[$nump] = $totalvisittoday_sth-&amp;gt;fetchrow_array();

    $totalvisittoday_sth-&amp;gt;execute($pagina[$nump], $dataieri);
    $totalyvisit[$nump] = $totalvisittoday_sth-&amp;gt;fetchrow_array();

    $totalmvisit_sth-&amp;gt;execute($pagina[$nump], $fine30gg, $inizio30gg);
    $totalmvisit[$nump] = $totalmvisit_sth-&amp;gt;fetchrow_array();
}

close (INPUT);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test. Log. Check in.&lt;/p&gt;

&lt;h3 id=&#34;fix-conflicting-styles&#34;&gt;Fix Conflicting Styles&lt;/h3&gt;

&lt;p&gt;Now the only difference between the statements is the choice of &lt;code&gt;data&lt;/code&gt; ranges.&lt;/p&gt;

&lt;p&gt;Using the variables are passed into each statement we can make some more deductions. Let&amp;rsquo;s have a look&amp;hellip;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$startdate&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$dataoggi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$dataieri&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$fine30gg, $inizio30gg&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;One of these things is not like the other.&lt;/em&gt; What&amp;rsquo;s &lt;code&gt;$startdate&lt;/code&gt; doing there? Everything else is talking about &amp;lsquo;data&amp;rsquo;. What&amp;rsquo;s &amp;lsquo;ieri&amp;rsquo;? &amp;lsquo;oggi&amp;rsquo;? Remember, the programmer who submitted this code is Italian. Maybe the names are in Italian. Grabbing an &lt;a href=&#34;http://dictionaries.travlang.com/ItalianEnglish/&#34;&gt;Italian-English dictionary&lt;/a&gt; we find out that &amp;lsquo;data&amp;rsquo; is Italian for &amp;lsquo;date&amp;rsquo;! Now it makes sense, this code was probably originally written in English, then worked on by an Italian (or vice-versa).&lt;/p&gt;

&lt;p&gt;This code has committed a cardinal stylistic sin. It uses two different languages for naming variables. Not just different languages, languages which have different meanings for the same words. Taken out of context, we can&amp;rsquo;t know if &lt;code&gt;$data&lt;/code&gt; represents a hunk of facts or &amp;ldquo;Thursday.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Since the styles conflict, one of them has to go. Since I don&amp;rsquo;t speak Italian, I&amp;rsquo;m going to translate it into English.&lt;/p&gt;

&lt;p&gt;Pulling out our Italian-to-English dictionary&amp;hellip;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;riga&amp;rdquo; is &amp;ldquo;line&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;pagina&amp;rdquo; is &amp;ldquo;page&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;nump&amp;rdquo; is probably short for &amp;ldquo;numero pagina&amp;rdquo; which is &amp;ldquo;page number&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;data&amp;rdquo; is &amp;ldquo;date&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;oggi&amp;rdquo; is &amp;ldquo;today&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;ieri&amp;rdquo; is &amp;ldquo;yesterday&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;inizio&amp;rdquo; is &amp;ldquo;start&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;fine&amp;rdquo; is &amp;ldquo;end&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;gg&amp;rdquo; is probably short for &amp;ldquo;giorni&amp;rdquo; which is &amp;ldquo;days&amp;rdquo;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;fine30gg&amp;rdquo; would then be &amp;ldquo;the end of 30 days&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;inizio30gg&amp;rdquo; would be &amp;ldquo;the beginning of 30 days&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It would be a straightforward matter of a bunch of search-and-replaces in any good editor but for one snag, the SQL column &amp;lsquo;data.&amp;rsquo; We&amp;rsquo;d like to change this to its English &amp;lsquo;date&amp;rsquo;, but databases are very global with possibly lots of other programs using it. So we can&amp;rsquo;t change the column name without breaking other code. While in a well-organized programming shop you might have the ability to find all the code which uses your database, we won&amp;rsquo;t assume we have that luxury here. For the moment then, we&amp;rsquo;ll leave that be and deal with it in a separate refactoring.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $totalvisit_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*)
FROM   lognew 
WHERE  pageid =  ? AND 
       data   &amp;gt;= ?
SQL

my $totalvisittoday_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid = ? AND 
       data   = ?
SQL

my $totalmvisit_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid =  ? AND
       data   &amp;lt;= ? AND 
       data   &amp;gt;= ?
SQL

open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($line=&amp;lt;INPUT&amp;gt;){
    $page_num++;
    chop($line);
    $pages[$page_num] = $line;

    $totalvisit_sth-&amp;gt;execute($pages[$page_num], $start_date);
    $totalvisit[$page_num] = $totalvisit_sth-&amp;gt;fetchrow_array();

    $totalvisittoday_sth-&amp;gt;execute($pages[$page_num], $today);
    $totalvisittoday[$page_num] = $totalvisittoday_sth-&amp;gt;fetchrow_array();

    $totalvisittoday_sth-&amp;gt;execute($pages[$page_num], $yesterday);
    $totalyvisit[$page_num] = $totalvisittoday_sth-&amp;gt;fetchrow_array();

    $totalmvisit_sth-&amp;gt;execute($pages[$page_num], $end_of_30_days,
                                                 $start_of_30_days);
    $totalmvisit[$page_num] = $totalmvisit_sth-&amp;gt;fetchrow_array();
}

close (INPUT);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test. Log. Check in.&lt;/p&gt;

&lt;h3 id=&#34;better-names&#34;&gt;Better Names&lt;/h3&gt;

&lt;p&gt;With decent variable names in place, the purpose of the program becomes &lt;strong&gt;much&lt;/strong&gt; clearer. This is a program to calculate the number of visits to a page for various date ranges. Based on this new information we can give the statement handles and the arrays they put data into better names.&lt;/p&gt;

&lt;p&gt;Looking at the SQL we see we&amp;rsquo;ve got:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;One to get all the visits up to a single day.&lt;/li&gt;
&lt;li&gt;One to get the visits for a certain date.&lt;/li&gt;
&lt;li&gt;One to get the visits for a range of dates.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A good set of new names would be:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;daily&lt;/li&gt;
&lt;li&gt;up to&lt;/li&gt;
&lt;li&gt;range&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Also, Total Visits is too long. We could shorten that to just Visits, or even shorter to Hits.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $hits_upto_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*)
FROM   lognew 
WHERE  pageid =  ? AND 
       data   &amp;gt;= ?
SQL

my $hits_daily_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid = ? AND 
       data   = ?
SQL

my $hits_range_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid =  ? AND
       data   &amp;lt;= ? AND 
       data   &amp;gt;= ?
SQL

open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($line=&amp;lt;INPUT&amp;gt;){
    $page_num++;
    chop($line);
    $pages[$page_num] = $line;

    $hits_upto_sth-&amp;gt;execute($pages[$page_num], $start_date);
    $totalvisit[$page_num] = $hits_upto_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($pages[$page_num], $today);
    $totalvisittoday[$page_num] = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($pages[$page_num], $yesterday);
    $totalyvisit[$page_num] = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_range_sth-&amp;gt;execute($pages[$page_num], $end_of_30_days,
                                                $start_of_30_days);
    $totalmvisit[$page_num] = $hits_range_sth-&amp;gt;fetchrow_array();
}

close (INPUT);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test. Log. Check in.&lt;/p&gt;

&lt;h3 id=&#34;changing-global-variable-names&#34;&gt;Changing Global Variable Names&lt;/h3&gt;

&lt;p&gt;The array names need work, too. Currently, they&amp;rsquo;re rather ambiguous. &lt;code&gt;@totalyvisit&lt;/code&gt;, what does the &lt;em&gt;y&lt;/em&gt; mean? Looking at each variable name and the variables that got passed to &lt;code&gt;execute()&lt;/code&gt; to produce it&amp;hellip;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@totalvisit&lt;/code&gt; comes up to a &lt;code&gt;$start_date&lt;/code&gt;. So that can be &lt;code&gt;@hits_upto&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@totalvisittoday&lt;/code&gt; comes from &lt;code&gt;$today&lt;/code&gt; and is pretty obvious. &lt;code&gt;@hits_today&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@totalyvisit&lt;/code&gt; comes from &lt;code&gt;$yesterday&lt;/code&gt; so &amp;lsquo;y&amp;rsquo; must be for &amp;lsquo;yesterday&amp;rsquo;. &lt;code&gt;@hits_yesterday&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@totalmvisit&lt;/code&gt; comes from the range produced by the $start_of_30_days and the $end_of_30_days. So &amp;rsquo;m&amp;rsquo; must be &amp;lsquo;month&amp;rsquo;. &lt;code&gt;@hits_monthly&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- --&gt;

&lt;pre&gt;&lt;code&gt;my $hits_upto_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*)
FROM   lognew 
WHERE  pageid =  ? AND 
       data   &amp;gt;= ?
SQL

my $hits_daily_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid = ? AND 
       data   = ?
SQL

my $hits_range_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid =  ? AND
       data   &amp;lt;= ? AND 
       data   &amp;gt;= ?
SQL

open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($line=&amp;lt;INPUT&amp;gt;){
    $page_num++;
    chop($line);
    $pages[$page_num] = $line;

    $hits_upto_sth-&amp;gt;execute($pages[$page_num], $start_date);
    $hits_upto[$page_num] = $hits_upto_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($pages[$page_num], $today);
    $hits_today[$page_num] = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($pages[$page_num], $yesterday);
    $hits_yesterday[$page_num] = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_range_sth-&amp;gt;execute($pages[$page_num], $end_of_30_days,
                                                $start_of_30_days);
    $hits_monthly[$page_num] = $hits_range_sth-&amp;gt;fetchrow_array();
}

close (INPUT);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test&amp;hellip; uh-oh, test failed!&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s something &lt;strong&gt;very&lt;/strong&gt; different about this change compared to the others. The variables we changed were &lt;em&gt;not&lt;/em&gt; declared in our little code block. Likely they&amp;rsquo;re used in other parts of the code, such as our test which caused it to break.&lt;/p&gt;

&lt;p&gt;In the Real World, we would be sure to &lt;strong&gt;replace all occurrences of the variable&lt;/strong&gt;. The simplest way to do this is to use your editor to perform a search and replace rather than doing it by your all too fallible hands. If it could be used over a set of files, grepping through those files for all occurrences of it and changing those as well would be necessary.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# If you don&#39;t have rgrep, grep -r does the same thing.
rgrep &#39;[@$]totalvisit&#39; /path/to/your/project
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I do this so often that I&amp;rsquo;ve taken to calling grep -r, &amp;lsquo;Refactoring Grep&amp;rsquo;. Other languages who&amp;rsquo;s syntax is &amp;ndash; ummm &amp;ndash; not as inspired as Perl&amp;rsquo;s, such as Java, C++ and Python, have tools for doing this sort of thing automatically. Because of the complexity of Perl&amp;rsquo;s syntax, we still have to do it mostly by hand, though there are some efforts underway to rectify this.&lt;/p&gt;

&lt;p&gt;Changing the array names in our test as well we get them to pass.&lt;/p&gt;

&lt;p&gt;Log. Check in.&lt;/p&gt;

&lt;h3 id=&#34;improve-overly-generic-names&#34;&gt;Improve Overly Generic Names&lt;/h3&gt;

&lt;p&gt;Continuing with our variable name improvements, we&amp;rsquo;re left with the last few unimproved names. Let&amp;rsquo;s start with &lt;code&gt;$line&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Since we can see clearly that &lt;code&gt;$line = &amp;lt;INPUT&amp;gt;&lt;/code&gt;, calling the variable &amp;lsquo;line&amp;rsquo; tells us nothing new. A better name might be what each line contains. Looking at how the line is used we see &lt;code&gt;$pages[$page_num] = $line&lt;/code&gt; and how that is then used in the SQL. It&amp;rsquo;s a page id.&lt;/p&gt;

&lt;p&gt;But it doesn&amp;rsquo;t make much sense to put a page id into an array called &lt;code&gt;@pages&lt;/code&gt;. It doesn&amp;rsquo;t contain pages, it contains &lt;code&gt;@page_ids&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;What about &lt;code&gt;$page_num&lt;/code&gt;? It doesn&amp;rsquo;t contain a page number, it contains the line number of the file we&amp;rsquo;re reading in. Or more conventionally, an &lt;code&gt;$index&lt;/code&gt; or &lt;code&gt;$idx&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $hits_upto_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*)
FROM   lognew 
WHERE  pageid =  ? AND 
       data   &amp;gt;= ?
SQL

my $hits_daily_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid = ? AND 
       data   = ?
SQL

my $hits_range_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid =  ? AND
       data   &amp;lt;= ? AND 
       data   &amp;gt;= ?
SQL

open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($page_id=&amp;lt;INPUT&amp;gt;){
    $idx++;
    chop($page_id);
    $page_ids[$idx] = $page_id;

    $hits_upto_sth-&amp;gt;execute($page_ids[$idx], $start_date);
    $hits_upto[$idx] = $hits_upto_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($page_ids[$idx], $today);
    $hits_today[$idx] = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($page_ids[$idx], $yesterday);
    $hits_yesterday[$idx] = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_range_sth-&amp;gt;execute($page_ids[$idx], $end_of_30_days,
                                                   $start_of_30_days);
    $hits_monthly[$idx] = $hits_range_sth-&amp;gt;fetchrow_array();
}

close (INPUT);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test. Log. Check in.&lt;/p&gt;

&lt;h3 id=&#34;fixing-odd-interfaces&#34;&gt;Fixing Odd Interfaces&lt;/h3&gt;

&lt;p&gt;What&amp;rsquo;s wrong with this picture?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$hits_range_sth-&amp;gt;execute($page_ids[$idx], $end_of_30_days,
                                               $start_of_30_days);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Isn&amp;rsquo;t it a little odd to specify a date range with the end first? Sure is. It also guarantees someone is going to get it backwards. Reverse it. Don&amp;rsquo;t forget the SQL, too.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $hits_upto_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*)
FROM   lognew 
WHERE  pageid =  ? AND 
       data   &amp;gt;= ?
SQL

my $hits_daily_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid = ? AND 
       data   = ?
SQL

my $hits_range_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid =  ? AND
       data   &amp;gt;= ? AND
       data   &amp;lt;= ? 
SQL

open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($page_id=&amp;lt;INPUT&amp;gt;){
    $idx++;
    chop($page_id);
    $page_ids[$idx] = $page_id;

    $hits_upto_sth-&amp;gt;execute($page_ids[$idx], $start_date);
    $hits_upto[$idx] = $hits_upto_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($page_ids[$idx], $today);
    $hits_today[$idx] = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($page_ids[$idx], $yesterday);
    $hits_yesterday[$idx] = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_range_sth-&amp;gt;execute($page_ids[$idx], $start_of_30_days,
                                                   $end_of_30_days);
    $hits_monthly[$idx] = $hits_range_sth-&amp;gt;fetchrow_array();
}

close (INPUT);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test. Log. Check in.&lt;/p&gt;

&lt;h3 id=&#34;s-chop-chomp&#34;&gt;s/chop/chomp/&lt;/h3&gt;

&lt;p&gt;Now that we&amp;rsquo;ve stared at the code for a while, you might have noticed the use of &lt;code&gt;chop()&lt;/code&gt;. Using &lt;code&gt;chop()&lt;/code&gt; to strip a newline is asking for portability problems, so let&amp;rsquo;s fix it by using &lt;code&gt;chomp()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Technically this &lt;em&gt;isn&amp;rsquo;t&lt;/em&gt; a refactoring since we altered the behavior of the code by fixing the bug. But using &lt;code&gt;chop()&lt;/code&gt; where you meant &lt;code&gt;chomp()&lt;/code&gt; is such a common mistake we&amp;rsquo;ll make it an honorary refactoring.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $hits_upto_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*)
FROM   lognew 
WHERE  pageid =  ? AND 
       data   &amp;gt;= ?
SQL

my $hits_daily_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid = ? AND 
       data   = ?
SQL

my $hits_range_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid =  ? AND
       data   &amp;gt;= ? AND
       data   &amp;lt;= ? 
SQL

open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($page_id=&amp;lt;INPUT&amp;gt;){
    $idx++;
    chomp($page_id);
    $page_ids[$idx] = $page_id;

    $hits_upto_sth-&amp;gt;execute($page_ids[$idx], $start_date);
    $hits_upto[$idx] = $hits_upto_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($page_ids[$idx], $today);
    $hits_today[$idx] = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($page_ids[$idx], $yesterday);
    $hits_yesterday[$idx] = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_range_sth-&amp;gt;execute($page_ids[$idx], $start_of_30_days,
                                                   $end_of_30_days,);
    $hits_monthly[$idx] = $hits_range_sth-&amp;gt;fetchrow_array();
}

close (INPUT);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test. Log. Check in.&lt;/p&gt;

&lt;h3 id=&#34;collect-related-variables-into-hashes&#34;&gt;Collect Related Variables into Hashes&lt;/h3&gt;

&lt;p&gt;The common prefix &lt;code&gt;hits_&lt;/code&gt; is a dead giveaway that much of the data in this code is related. Related variables should be grouped together into a single structure, probably a hash to make the relation obvious and allow them to be passed around to subroutines more easily. Its easier to move around one hash than four arrays.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve decided to collect together all the &lt;code&gt;@hit_&lt;/code&gt; arrays into a single hash &lt;code&gt;%hits&lt;/code&gt; since they&amp;rsquo;ll probably be used together parts of the program. If this code snippet represents a function it means I can return one hash reference rather than four array refs. It also makes future expansion easier, rather than returning an additional array it simply becomes another key in the hash.&lt;/p&gt;

&lt;p&gt;Before.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$hits{upto}[$idx] = $hits_upto_sth-&amp;gt;fetchrow_array();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$hits_upto[$idx]  = $hits_upto_sth-&amp;gt;fetchrow_array();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s interesting to note what a small, natural change this is. Circumstantial evidence that this is a good refactoring.&lt;/p&gt;

&lt;p&gt;As before, since these arrays are global data, we must be sure to change them everywhere. This includes the tests.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $hits_upto_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*)
FROM   lognew 
WHERE  pageid =  ? AND 
       data   &amp;gt;= ?
SQL

my $hits_daily_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid = ? AND 
       data   = ?
SQL

my $hits_range_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid =  ? AND
       data   &amp;gt;= ? AND
       data   &amp;lt;= ? 
SQL

open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($page_id=&amp;lt;INPUT&amp;gt;){
    $idx++;
    chomp($page_id);
    $page_ids[$idx] = $page_id;

    $hits_upto_sth-&amp;gt;execute($page_ids[$idx], $start_date);
    $hits{upto}[$idx] = $hits_upto_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($page_ids[$idx], $today);
    $hits{today}[$idx] = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($page_ids[$idx], $yesterday);
    $hits{yesterday}[$idx] = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_range_sth-&amp;gt;execute($page_ids[$idx], $start_of_30_days,
                                                   $end_of_30_days,);
    $hits{monthly}[$idx] = $hits_range_sth-&amp;gt;fetchrow_array();
}

close (INPUT);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test. Log. Check in.&lt;/p&gt;

&lt;h3 id=&#34;when-not-to-refactor&#34;&gt;When Not to Refactor&lt;/h3&gt;

&lt;p&gt;The statement handles are also related, but I&amp;rsquo;m not going to collect them together into a hash. The statement handles are short-lived lexicals, they&amp;rsquo;re never likely to be passed around. Their short scope and grouping within the code makes their relationship obvious. The design would not be improved by the refactoring.&lt;/p&gt;

&lt;p&gt;Refactoring is not a set of rules to be slavishly followed, it&amp;rsquo;s a collection of tools. And like any other tool you must carefully consider when and when not to use it. Since collecting the statement handles together doesn&amp;rsquo;t improve the design, I won&amp;rsquo;t do it.&lt;/p&gt;

&lt;h3 id=&#34;eliminate-unnecessary-longhand&#34;&gt;Eliminate Unnecessary Longhand&lt;/h3&gt;

&lt;p&gt;Boy, we sure use &lt;code&gt;$page_ids[$idx]&lt;/code&gt; a lot. It&amp;rsquo;s the current page ID. But don&amp;rsquo;t we have a variable for that?&lt;/p&gt;

&lt;p&gt;Replace all the unnecessary array accesses and just use the more concise and descriptive &lt;code&gt;$page_id&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $hits_upto_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*)
FROM   lognew 
WHERE  pageid =  ? AND 
       data   &amp;gt;= ?
SQL

my $hits_daily_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid = ? AND 
       data   = ?
SQL

my $hits_range_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid =  ? AND
       data   &amp;gt;= ? AND
       data   &amp;lt;= ? 
SQL

open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($page_id=&amp;lt;INPUT&amp;gt;){
    $idx++;
    chomp($page_id);
    $page_ids[$idx] = $page_id;

    $hits_upto_sth-&amp;gt;execute($page_id, $start_date);
    $hits{upto}[$idx] = $hits_upto_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($page_id, $today);
    $hits{today}[$idx] = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($page_id, $yesterday);
    $hits{yesterday}[$idx] = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_range_sth-&amp;gt;execute($page_id, $start_of_30_days,
                                       $end_of_30_days,);
    $hits{monthly}[$idx] = $hits_range_sth-&amp;gt;fetchrow_array();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test. Log. Check in.&lt;/p&gt;

&lt;h3 id=&#34;rearrange-data-structures-to-fit-their-use&#34;&gt;Rearrange Data Structures to Fit Their Use&lt;/h3&gt;

&lt;p&gt;Currently, &lt;code&gt;%hits&lt;/code&gt; is accessed by the order the page ID was read out of the file. Well, that doesn&amp;rsquo;t seem very useful at all. Its purpose seems to be for listing the page counts in exactly the same order as you read them in. Even then you need to iterate through &lt;code&gt;@page_ids&lt;/code&gt; simultaneously because no where in &lt;code&gt;%hits&lt;/code&gt; is the page ID stored.&lt;/p&gt;

&lt;p&gt;Consider a common operation, looking up the hit counts for a given page ID. You have to iterate through the whole list of page IDs to do it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foreach my $idx (0..$#page_ids) {
    if( $page_ids[$idx] eq $our_page_id ) {
        print &amp;quot;Hits for $our_page_id today: $hits{today}[$idx]\n&amp;quot;;
        last;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cumbersome. A much better layout would be a hash keyed on the page ID.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$hits{upto}{$page_id} = $hits_upto_sth-&amp;gt;fetchrow_array();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can directly access the data for a given page ID. If necessary, we can still list the hits in the same order they were read in by iterating through &lt;code&gt;@page_ids&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $hits_upto_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*)
FROM   lognew 
WHERE  pageid =  ? AND 
       data   &amp;gt;= ?
SQL

my $hits_daily_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid = ? AND 
       data   = ?
SQL

my $hits_range_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid =  ? AND
       data   &amp;gt;= ? AND
       data   &amp;lt;= ? 
SQL

open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($page_id=&amp;lt;INPUT&amp;gt;){
    $idx++;
    chomp($page_id);
    $page_ids[$idx] = $page_id;

    $hits_upto_sth-&amp;gt;execute($page_id, $start_date);
    $hits{upto}{$page_id} = $hits_upto_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($page_id, $today);
    $hits{today}{$page_id} = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($page_id, $yesterday);
    $hits{yesterday}{$page_id} = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_range_sth-&amp;gt;execute($page_id, $start_of_30_days,
                                       $end_of_30_days,);
    $hits{monthly}{$page_id} = $hits_range_sth-&amp;gt;fetchrow_array();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test. Log. Check in.&lt;/p&gt;

&lt;h3 id=&#34;eliminate-unnecessary-variables&#34;&gt;Eliminate Unnecessary Variables&lt;/h3&gt;

&lt;p&gt;Now that &lt;code&gt;%hits&lt;/code&gt; is no longer ordered by how it was read in, &lt;code&gt;$idx&lt;/code&gt; isn&amp;rsquo;t used much anymore. It&amp;rsquo;s only used to stick &lt;code&gt;$page_id&lt;/code&gt; onto the end of &lt;code&gt;@page_ids&lt;/code&gt;, but we can do that with &lt;code&gt;push&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This is minor but little things build up to cause big messes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $hits_upto_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*)
FROM   lognew 
WHERE  pageid =  ? AND 
       data   &amp;gt;= ?
SQL

my $hits_daily_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid = ? AND 
       data   = ?
SQL

my $hits_range_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid =  ? AND
       data   &amp;gt;= ? AND
       data   &amp;lt;= ? 
SQL

open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($page_id=&amp;lt;INPUT&amp;gt;){
    chomp($page_id);
    push @page_ids, $page_id;

    $hits_upto_sth-&amp;gt;execute($page_id, $start_date);
    $hits{upto}{$page_id} = $hits_upto_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($page_id, $today);
    $hits{today}{$page_id} = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($page_id, $yesterday);
    $hits{yesterday}{$page_id} = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_range_sth-&amp;gt;execute($page_id, $start_of_30_days,
                                       $end_of_30_days,);
    $hits{monthly}{$page_id} = $hits_range_sth-&amp;gt;fetchrow_array();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test. Log. Check in.&lt;/p&gt;

&lt;h3 id=&#34;pull-logical-chunks-out-into-functions&#34;&gt;Pull Logical Chunks Out into Functions&lt;/h3&gt;

&lt;p&gt;Our final refactoring is one of the most common and most useful.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s assume that we need to generate page counts somewhere else in the code. Rather than repeat the code to do this, we want to put it in a subroutine so it can be reused. One subroutine for each statement.&lt;/p&gt;

&lt;p&gt;In order to do this, start by identifying the code that would go into the routine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$hits_upto_sth-&amp;gt;execute($page_id, $start_date);
$hits{upto}{$page_id} = $hits_upto_sth-&amp;gt;fetchrow_array();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then wrap a subroutine around it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub hits_upto {
    $hits_upto_sth-&amp;gt;execute($page_id, $start_date);
    $hits{upto}{$page_id} = $hits_upto_sth-&amp;gt;fetchrow_array();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now look at all the variables used.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$hits_upto_sth&lt;/code&gt; is a global (well, file-scoped lexical) and is defined entirely outside the function. We can keep using it in our subroutine in the same way we are now.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$hits{upto}{$page_id}&lt;/code&gt; is receiving the result of the calculation. It contains the return value. So it goes outside the function to receive the return value. Where its assignment was, we put a &lt;code&gt;return&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub hits_upto {
    $hits_upto_sth-&amp;gt;execute($page_id, $start_date);
    return $hits_upto_sth-&amp;gt;fetchrow_array();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$page_id&lt;/code&gt; and &lt;code&gt;$start_date&lt;/code&gt; vary from call to call. These are our function arguments.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub hits_upto {
    my($page_id, $start_date) = @_;
    $hits_upto_sth-&amp;gt;execute($page_id, $start_date);
    return $hits_upto_sth-&amp;gt;fetchrow_array();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, rename things in a more generic manner. This is a subroutine for calculating the number of hits up to a certain date. Instead of &lt;code&gt;$start_date&lt;/code&gt; which was specific to one calculation, we&amp;rsquo;d call it &lt;code&gt;$date&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub hits_upto {
    my($page_id, $date) = @_;
    $hits_upto_sth-&amp;gt;execute($page_id, $date);
    return $hits_upto_sth-&amp;gt;fetchrow_array();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that&amp;rsquo;s our new subroutine, does the same thing as the original code. Then it&amp;rsquo;s a simple matter to use it in the code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $hits{upto}{$page_id} = hits_upto($page_id, $start_date);


my $hits_upto_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*)
FROM   lognew 
WHERE  pageid =  ? AND 
       data   &amp;gt;= ?
SQL

my $hits_daily_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid = ? AND 
       data   = ?
SQL

my $hits_range_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid =  ? AND
       data   &amp;gt;= ? AND
       data   &amp;lt;= ? 
SQL

open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($page_id=&amp;lt;INPUT&amp;gt;){
    chomp($page_id);
    push @page_ids, $page_id;

    $hits{upto}{$page_id}      = hits_upto($page_id, $start_date);
    $hits{today}{$page_id}     = hits_daily($page_id, $today);
    $hits{yesterday}{$page_id} = hits_daily($page_id, $yesterday);
    $hits{monthly}{$page_id}   = hits_range($page_id, $start_of_30_days,
                                                        $end_of_30_days,);
}

sub hits_upto {
    my($page_id, $date) = @_;
    $hits_upto_sth-&amp;gt;execute($page_id, $date);
    return scalar $hits_upto_sth-&amp;gt;fetchrow_array();
}

sub hits_daily {
    my($page_id, $date) = @_;
    $hits_daily_sth-&amp;gt;execute($page_id, $date);
    return scalar $hits_daily_sth-&amp;gt;fetchrow_array();
}

sub hits_range {
    my($page_id, $start, $end) = @_;
    $hits_range_sth-&amp;gt;execute($page_id, $start, $end);
    return scalar $hits_range_sth-&amp;gt;fetchrow_array();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test. Log. Check in.&lt;/p&gt;

&lt;h3 id=&#34;undo&#34;&gt;Undo.&lt;/h3&gt;

&lt;p&gt;Some may balk at putting that small of a snippet of code into a subroutine like that. There are definite performance concerns about adding four subroutine calls to a loop. But I&amp;rsquo;m not worried about that at all.&lt;/p&gt;

&lt;p&gt;One of the beauties of Refactoring is that it&amp;rsquo;s reversible. Refactorings don&amp;rsquo;t change how the program works. We can reverse any of these refactorings and the code will work exactly the same. If a refactoring turns out to be a bad idea, undo it. Logging each refactoring in version control makes the job even easier.&lt;/p&gt;

&lt;p&gt;So if it turns out moving the executes into their own functions causes a performance problem the change can easily be undone.&lt;/p&gt;

&lt;h3 id=&#34;done&#34;&gt;Done?&lt;/h3&gt;

&lt;p&gt;At this point, things are looking pretty nice. The code is well structured, readable, and efficient. The variables are sensibly named. The data is organized in a fairly flexible manner.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s good enough. This is not to say that there&amp;rsquo;s not more that could be done, but we don&amp;rsquo;t need to. And Refactoring is about doing as much redesign as you need instead of what you might need.&lt;/p&gt;

&lt;h3 id=&#34;refactoring-and-the-swiss-army-knife&#34;&gt;Refactoring and the Swiss Army Knife&lt;/h3&gt;

&lt;p&gt;As programmers we have a tendency towards over-design. We like to design our code to deal with any possible situation that might arise, since it was hard to change the design later. This is known as Big Design Up Front (BDUF). It&amp;rsquo;s like one of those &lt;a href=&#34;http://www.victorinox.com/newsite/en/produkte/neu/inhalt2.cfm?pid=1-6795-XLT&#34;&gt;enormous Swiss Army Knives with 50 functions&lt;/a&gt;. Most of the time all you need is &lt;a href=&#34;http://www.victorinox.com/newsite/en/produkte/neu/inhalt2.cfm?pid=2-2363&#34;&gt;a knife with something to open your beer with and then maybe pick your teeth afterwards&lt;/a&gt; but you never know. So you over-engineer because it&amp;rsquo;s hard to improve it later. If it never gets used then a lot of effort has been wasted.&lt;/p&gt;

&lt;p&gt;Refactoring turns design on its ear. Now you can continually evolve your design as needed. There&amp;rsquo;s no longer a need to write for every possible situation up front so you can focus on just what you need right now. If you need more flexibility later, you can add that flexibility through refactoring. It&amp;rsquo;s like having a Swiss Army knife that you can add tools to as you need them.&lt;/p&gt;

&lt;h3 id=&#34;further-reference&#34;&gt;Further Reference&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://groups.google.com/groups?th=11b4e3caaafb9849&amp;amp;seekm=20021005063711.GE15102%40ool-18b93024.dyn.optonline.net#link1&#34;&gt;The original thread on Fun With Perl&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The &lt;a href=&#34;http://www.c2.com/cgi/wiki?WelcomeVisitors&#34;&gt;Portland Pattern Repository&lt;/a&gt; answers the question &amp;ndash; &lt;a href=&#34;http://www.c2.com/cgi/wiki?WhatIsRefactoring&#34;&gt;WhatIsRefactoring?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.com/exec/obidos/tg/detail/-/0201485672&#34;&gt;The Refactoring Book&lt;/a&gt; by &lt;a href=&#34;http://www.martinfowler.com&#34;&gt;Martin Fowler&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>

