<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Whois on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/whois/</link>
    <description>Recent content in Whois on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 19 Sep 2019 11:00:07 +0000</lastBuildDate>
    <atom:link href="/tags/whois/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Creating IP address tools from scratch</title>
      <link>http://localhost:1313/article/creating-ip-address-tools-from-scratch/</link>
      <pubDate>Thu, 19 Sep 2019 11:00:07 +0000</pubDate>
      
      <guid>http://localhost:1313/article/creating-ip-address-tools-from-scratch/</guid>
      <description>

&lt;p&gt;Recently I&amp;rsquo;ve been researching how the Internet is organized, and working with &lt;a href=&#34;https://en.wikipedia.org/wiki/WHOIS&#34;&gt;whois&lt;/a&gt; data. I&amp;rsquo;ve been creating simple tools that process IP addresses without any help from CPAN. At work we tend to use &lt;a href=&#34;https://metacpan.org/pod/Net::IP::XS&#34;&gt;Net::IP::XS&lt;/a&gt; for these tasks, but sometimes it&amp;rsquo;s fun to figure out how things work under the hood.&lt;/p&gt;

&lt;h2 id=&#34;converting-to-decimal&#34;&gt;Converting to decimal&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;m sure you&amp;rsquo;re familiar with the IPv4 address &lt;a href=&#34;https://en.wikipedia.org/wiki/IPv4#Addressing&#34;&gt;format&lt;/a&gt;; the &amp;ldquo;dotted quad&amp;rdquo; consists of four numbers between 0 and 255 separated by periods. Your home wifi network probably starts at 192.168.0.0. The format is just another way of representing a 32-bit integer; here are the numbers and their equivalent in binary:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     192      168        0        0
11000000 10101000 00000000 00000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To figure out the value of the address in decimal, you need to read all 32 bits in one go:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;11000000101010000000000000000000
                      3232235520
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I find it useful to convert IPv4 addresses to decimals for storing them in a database; it&amp;rsquo;s much faster to search integers than text. So how would we do that in Perl? Here&amp;rsquo;s one way:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#!/usr/bin/perl&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $ipv4 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;192.168.0.0&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @bytes &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; split &lt;span style=&#34;color:#e6db74&#34;&gt;/\./&lt;/span&gt;, $ipv4;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $decimal &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; unpack &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;N&amp;#39;&lt;/span&gt;, pack &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;CCCC&amp;#39;&lt;/span&gt;, @bytes; &lt;span style=&#34;color:#75715e&#34;&gt;# 3232235520&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This code splits the IPv4 string &lt;code&gt;192.168.0.0&lt;/code&gt; into an array of 4 numbers (192,168,0,0). I use &lt;a href=&#34;https://perldoc.perl.org/functions/pack.html&#34;&gt;pack&lt;/a&gt; to convert each number from Perl&amp;rsquo;s representation into an unsigned 8-bit integer (the &amp;ldquo;C&amp;rdquo; is for char, the C language type). Then I use &lt;a href=&#34;https://perldoc.perl.org/functions/unpack.html&#34;&gt;unpack&lt;/a&gt; to read all 32 bits at once (the &amp;ldquo;N&amp;rdquo; is for an unsigned long in Network order - i.e. big endian).&lt;/p&gt;

&lt;p&gt;Using &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt; is convenient, but it&amp;rsquo;s not the fastest way to convert those numbers into a single 32-bit integer. We can accomplish the same feat with multiplication and exponentiation:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $decimal &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; $bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;24&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; $bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; $bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; $bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;];&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This multiplies each number by 2 raised to the appropriate power (&lt;code&gt;**&lt;/code&gt; is Perl&amp;rsquo;s exponentiation operator): 192 must be multiplied by 2^24 as we want it to be moved 24 bits to the left, 168 should be multiplied by 2^16 and so on. Alternatively I could use bit-shifting to do the same thing:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $decimal &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ($bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;24&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; ($bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; ($bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; $bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;];&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Using exponents or bit-shifting are both over 3x faster than my pack-unpack routine. That isn&amp;rsquo;t unusual: aside from avoiding subroutine calls, compilers are optimized for base 2 operations.&lt;/p&gt;

&lt;p&gt;You might be wondering how this would work for an &lt;a href=&#34;https://en.wikipedia.org/wiki/IPv6#Addressing&#34;&gt;IPv6&lt;/a&gt; address. In principle the steps are the same, but it&amp;rsquo;s more complicated: IPv6 addresses are 128-bit integers, which is larger than Perl can natively handle. IPv6 addresses also have more involved representation &lt;a href=&#34;https://en.wikipedia.org/wiki/IPv6_address#Representation&#34;&gt;rules&lt;/a&gt;. I&amp;rsquo;ll tackle IPv6 in a future article.&lt;/p&gt;

&lt;h2 id=&#34;changing-decimal-back-to-dotted-quad&#34;&gt;Changing decimal back to dotted quad&lt;/h2&gt;

&lt;p&gt;To get back from a decimal number to an IPv4 address, just reverse the process:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#!/usr/bin/perl&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $decimal &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3232235776&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @bytes &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; unpack &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;CCCC&amp;#39;&lt;/span&gt;, pack &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;N&amp;#39;&lt;/span&gt;, $decimal;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $ipv4 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; join &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.&amp;#39;&lt;/span&gt;, @bytes; &lt;span style=&#34;color:#75715e&#34;&gt;# 192.168.1.0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here I&amp;rsquo;ve used the pack-unpack routine again. I&amp;rsquo;m not sure if there&amp;rsquo;s a exponent/bit-shift solution that&amp;rsquo;s faster. I could right shift the decimal 24 bits to get 192, then left shift 192 24 bits and subtract it from the decimal, then shift the decimal 16 bits right and so on. But that seems like a lot of work.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Edit&lt;/strong&gt;: Dave Cross posted a &lt;a href=&#34;https://www.reddit.com/r/perl/comments/d6kncb/creating_ip_address_tools_from_scratch/f0vas6d?utm_source=share&amp;amp;utm_medium=web2x&#34;&gt;solution&lt;/a&gt; using bitmaps.&lt;/p&gt;

&lt;h2 id=&#34;extracting-a-range-from-cidr-notation&#34;&gt;Extracting a range from CIDR notation&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing&#34;&gt;CIDR&lt;/a&gt; notation is shorthand way of describing a range of contiguous IP addresses belonging to a network. For instance your home network is commonly administered on &lt;code&gt;192.168.0.0/16&lt;/code&gt;. This can be read as &amp;ldquo;the network begins at 192.168.0.0 and the network mask is 16 bits long&amp;rdquo;. In other words the network begins at &lt;code&gt;192.168.0.0&lt;/code&gt; and ends at &lt;code&gt;192.168.255.255&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;CIDR is powerful though because the network mask doesn&amp;rsquo;t have to be a factor of 8; it&amp;rsquo;s harder to read &lt;code&gt;105.201.192.0/19&lt;/code&gt; and know where the network ends. And that&amp;rsquo;s where Perl can help:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#!/usr/bin/perl&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; ($start_ipv4, $prefixlen) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; split &lt;span style=&#34;color:#e6db74&#34;&gt;/\//&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;105.201.192.0/19&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @bytes &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; split &lt;span style=&#34;color:#e6db74&#34;&gt;/\./&lt;/span&gt;, $start_ipv4;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $start_decimal &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; $bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;24&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; $bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; $bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; $bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;];
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $bits_remaining &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; $prefixlen;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $end_decimal &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; $start_decimal &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt; $bits_remaining &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @bytes &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; unpack &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;CCCC&amp;#39;&lt;/span&gt;, pack &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;N&amp;#39;&lt;/span&gt;, $end_decimal;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $end_ipv4 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; join &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.&amp;#39;&lt;/span&gt;, @bytes; &lt;span style=&#34;color:#75715e&#34;&gt;# 105.201.223.255&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This code starts by splitting the network &lt;code&gt;105.201.192.0/19&lt;/code&gt; into its starting IPv4 address and the network mask prefix length. I then use the same routine as before to obtain the decimal starting address. To figure out the last network address, I can use exponentiation again: 2 to the power of the remaining bits, minus 1 tells me how much larger the end address is than the start. To get the dotted quad I use pack-unpack to read the end decimal back into 4 bytes, and join them together again.&lt;/p&gt;

&lt;h2 id=&#34;a-quick-note-on-scripting&#34;&gt;A quick note on scripting&lt;/h2&gt;

&lt;p&gt;All of my code examples so far have used fixed variables to keep things simple. But I don&amp;rsquo;t actually write scripts like this. Text streams are the lingua franca of Unix systems; so it&amp;rsquo;s much more useful to write scripts that read streams of text and print streams of text. Then you can pipe data in and out of the script, chaining programs together to get the transformation you need. Here&amp;rsquo;s an example if what I&amp;rsquo;m talking about:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#!/usr/bin/perl&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;lt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @columns &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; split &lt;span style=&#34;color:#e6db74&#34;&gt;/\t/&lt;/span&gt;;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; ($start_ipv4, $prefixlen) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; split &lt;span style=&#34;color:#e6db74&#34;&gt;/\//&lt;/span&gt;, $columns[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;];
  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @bytes &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; split &lt;span style=&#34;color:#e6db74&#34;&gt;/\./&lt;/span&gt;, $start_ipv4;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $start_decimal &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; $bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;24&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; $bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; $bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; $bytes[&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;];
  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $bits_remaining &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; $prefixlen;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $end_decimal &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; $start_decimal &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt; $bits_remaining &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;

  &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; ($start_decimal &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; $end_decimal) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @bytes &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; unpack &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;CCCC&amp;#39;&lt;/span&gt;, pack &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;N&amp;#39;&lt;/span&gt;, $start_decimal;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $ipv4 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; join &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.&amp;#39;&lt;/span&gt;, @bytes;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; join &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\t&amp;#34;&lt;/span&gt;, $ipv4, @columns;
    $start_decimal&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This script enumerates all the IP addresses in a network. I use the &lt;a href=&#34;https://www.masteringperl.org/2014/10/the-double-diamond-a-more-secure/&#34;&gt;double diamond&lt;/a&gt; operator to read input from STDIN or treat its arguments like filenames automatically opening and streaming them. I expect tab-separated columns of text, and that the first column contains the CIDR to enumerate. It performs the conversion and prints the answer along with the original input in tab-separated form.&lt;/p&gt;

&lt;p&gt;I can run it by piping input:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ echo &#39;129.232.156.16/29&#39; | enum-ips
129.232.156.16  129.232.156.16/29
129.232.156.17  129.232.156.16/29
129.232.156.18  129.232.156.16/29
129.232.156.19  129.232.156.16/29
129.232.156.20  129.232.156.16/29
129.232.156.21  129.232.156.16/29
129.232.156.22  129.232.156.16/29
129.232.156.23  129.232.156.16/29
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or pass it filenames to read from:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ enum-ips cidrs-1.txt cidrs-2.txt | head
102.32.0.0  102.32.0.0/15
102.32.0.1  102.32.0.0/15
102.32.0.2  102.32.0.0/15
102.32.0.3  102.32.0.0/15
102.32.0.4  102.32.0.0/15
102.32.0.5  102.32.0.0/15
102.32.0.6  102.32.0.0/15
102.32.0.7  102.32.0.0/15
102.32.0.8  102.32.0.0/15
102.32.0.9  102.32.0.0/15
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;representing-a-range-in-cidr-notation&#34;&gt;Representing a range in CIDR notation&lt;/h2&gt;

&lt;p&gt;CIDR notation is compact and convenient; but the &lt;a href=&#34;https://www.ripe.net/manage-ips-and-asns/db/support/documentation/ripe-database-documentation/rpsl-object-types/4-2-descriptions-of-primary-objects/4-2-4-description-of-the-inetnum-object&#34;&gt;inetnum whois object&lt;/a&gt; defines each netblock by its starting and ending IPv4 address, like this: &amp;ldquo;197.232.80.0 - 197.232.83.255&amp;rdquo;. So I wrote a script to convert that string back into a CIDR:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#!/usr/bin/perl&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;lt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @columns &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; split &lt;span style=&#34;color:#e6db74&#34;&gt;/\t/&lt;/span&gt;;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; ($start_ipv4, $end_ipv4) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; split &lt;span style=&#34;color:#e6db74&#34;&gt;/\s+-\s+/&lt;/span&gt;, $columns[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;];
  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $start_decimal &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; unpack &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;N&amp;#39;&lt;/span&gt;, pack &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;CCCC&amp;#39;&lt;/span&gt;, split &lt;span style=&#34;color:#e6db74&#34;&gt;/\./&lt;/span&gt;, $start_ipv4;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $end_decimal   &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; unpack &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;N&amp;#39;&lt;/span&gt;, pack &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;CCCC&amp;#39;&lt;/span&gt;, split &lt;span style=&#34;color:#e6db74&#34;&gt;/\./&lt;/span&gt;, $end_ipv4;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $prefixlen     &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; length sprintf &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%0b&amp;#34;&lt;/span&gt;, $end_decimal &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; $start_decimal;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; join &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\t&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;$start_ipv4/$prefixlen&amp;#34;&lt;/span&gt;, @columns;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The script reads input one line at a time. It splits the string up into the starting and ending IPv4 addresses, and uses that same pack-unpack routine to convert each to its decimal. It then calculates the prefix length by finding the difference between the start and end addresses, stringifying it to binary with &lt;a href=&#34;https://perldoc.perl.org/functions/sprintf.html&#34;&gt;sprintf&lt;/a&gt; and subtracting the number of bits from 32 (because IPv4 addresses are 32-bit integers).&lt;/p&gt;

&lt;p&gt;The trouble with the prefix length calculation is it uses stringification - sticking with numbers should be faster if there was a way to do it. Let&amp;rsquo;s recap what we know:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;We can calculate the maximum (unsigned) 32-bit integer value using a base of 2: 2&lt;sup&gt;32&lt;/sup&gt; - 1&lt;/li&gt;
&lt;li&gt;IPv4 addresses are just another way of representing unsigned 32-bit integers&lt;/li&gt;
&lt;li&gt;With an input like &lt;code&gt;197.232.80.0 - 197.232.83.255&lt;/code&gt; we can calculate the difference between the two values (1023)&lt;/li&gt;
&lt;li&gt;We know the base is 2 and the result is 1023; we just don&amp;rsquo;t know what the exponent is: 2&lt;sup&gt;x&lt;/sup&gt; - 1 = 1023&lt;/li&gt;
&lt;li&gt;To solve for &lt;code&gt;x&lt;/code&gt;, we can use the logarithm function which is the inverse of exponentiation&lt;/li&gt;
&lt;li&gt;The solution is: x = log&lt;sub&gt;2&lt;/sub&gt; ⋅ (1023 + 1)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Here&amp;rsquo;s the Perl solution:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $prefixlen &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; int(log(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; $end_decimal &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; $start_decimal) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; log(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;));&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It uses the &lt;a href=&#34;https://perldoc.perl.org/functions/log.html&#34;&gt;log&lt;/a&gt; function which uses the natural logarithm base &lt;em&gt;e&lt;/em&gt; (like the &lt;code&gt;ln&lt;/code&gt; button on a calculator), so it must be divided by &lt;code&gt;log(2)&lt;/code&gt; to act like log&lt;sub&gt;2&lt;/sub&gt;. Benchmarking this I was surprised to find that the &lt;code&gt;log&lt;/code&gt; solution is only a few percent faster than using &lt;code&gt;sprintf&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Edit&lt;/strong&gt;: Dan Book posted an IP address to decimal &lt;a href=&#34;https://www.reddit.com/r/perl/comments/d6kncb/creating_ip_address_tools_from_scratch/f0u1flu?utm_source=share&amp;amp;utm_medium=web2x&#34;&gt;solution&lt;/a&gt; that uses &lt;a href=&#34;https://metacpan.org/pod/Socket&#34;&gt;Socket&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Monitoring my phone&#39;s internet activity with DD-WRT and Perl</title>
      <link>http://localhost:1313/article/monitoring-my-phone-s-internet-activity-with-netflows-and-perl/</link>
      <pubDate>Thu, 26 Oct 2017 19:56:37 +0000</pubDate>
      
      <guid>http://localhost:1313/article/monitoring-my-phone-s-internet-activity-with-netflows-and-perl/</guid>
      <description>

&lt;p&gt;I&amp;rsquo;ve had a cracked phone screen for years, but recently as the glass started falling out, I decided it was time to upgrade. I bought a Samsung &lt;a href=&#34;https://www.samsung.com/us/explore/galaxy-s8/&#34;&gt;Galaxy S8&lt;/a&gt;, and was surprised to see &amp;ldquo;Unusual traffic from your computer network&amp;rdquo; &lt;a href=&#34;https://support.google.com/websearch/answer/86640?hl=en&#34;&gt;messages&lt;/a&gt; when searching via Google. This peaked my curiosity, so I decided to monitor the phone&amp;rsquo;s Internet traffic to see &lt;em&gt;who&lt;/em&gt; it was communicating with.&lt;/p&gt;

&lt;h3 id=&#34;router-setup&#34;&gt;Router Setup&lt;/h3&gt;

&lt;p&gt;I run &lt;a href=&#34;http://www.dd-wrt.com/site/index&#34;&gt;DD-WRT&lt;/a&gt; Linux on my home WiFi router. DD-WRT can run an &lt;a href=&#34;https://www.dd-wrt.com/wiki/index.php/Network_traffic_analysis_with_netflow_and_ntop&#34;&gt;Rflow service&lt;/a&gt; where it posts &lt;a href=&#34;https://en.wikipedia.org/wiki/NetFlow&#34;&gt;NetFlow&lt;/a&gt; traffic data to another computer on the network via UDP. I enabled the service, and configured it to post to my laptop&amp;rsquo;s IP address and the default port, 2055.&lt;/p&gt;

&lt;h3 id=&#34;monitoring&#34;&gt;Monitoring&lt;/h3&gt;

&lt;p&gt;I installed &lt;a href=&#34;https://www.ntop.org/&#34;&gt;ntop&lt;/a&gt; and setup a virtual interface pointing at the UDP socket, and lo! it quickly started displaying the NetFlow data. The problem was I couldn&amp;rsquo;t figure out how to filter out data that wasn&amp;rsquo;t from my phone (the various pcap filter expressions I tried did not work). Also it irked me to rely on a software program to do something as simple as parsing data from a UDP socket.&lt;/p&gt;

&lt;p&gt;Luckily I speak &lt;a href=&#34;https://en.wikipedia.org/wiki/Perl&#34;&gt;chainsaw&lt;/a&gt;, and whipped up this script to do the job:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#!/usr/bin/env perl&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; IO::Socket::INET;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Data::Netflow;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $sock &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; IO::Socket::INET&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;(
  LocalPort &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2055&lt;/span&gt;,
  Proto     &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;udp&amp;#39;&lt;/span&gt;
);

open &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $logfile, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;gt;&amp;gt;&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;galaxy-s8.log&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; die $!;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; ($sender, $datagram);
&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; ($sender &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; $sock&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;recv($datagram, &lt;span style=&#34;color:#ae81ff&#34;&gt;0xFFFF&lt;/span&gt;))
{
  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; ($sender_port, $sender_addr) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; unpack_sockaddr_in($sender);
  $sender_addr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; inet_ntoa($sender_addr);
  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; ($headers, $records) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Data::Netflow::decode($datagram, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) ;

  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $r (@$records) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ($r&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{SrcAddr} &lt;span style=&#34;color:#f92672&#34;&gt;eq&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;192.168.1.139&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; $r&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{DstAddr} &lt;span style=&#34;color:#f92672&#34;&gt;ne&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;192.168.1.1&amp;#39;&lt;/span&gt;) {
      printf $logfile &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%s,%d,%d,%d,%d\n&amp;#34;&lt;/span&gt;, $r&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{DstAddr}, $r&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{DstPort}, $r&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{Packets}, $r&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{Octets}, time;
    }
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The script opens a UDP socket on port 2055 and reads datagrams from it. It uses &lt;a href=&#34;https://metacpan.org/pod/Data::Netflow&#34;&gt;Data::Netflow&lt;/a&gt; to parse the datagrams from the socket. The &lt;code&gt;decode&lt;/code&gt; function accepts a datagram and returns a hashref of header data, and an arrayref of NetFlow &lt;a href=&#34;https://en.wikipedia.org/wiki/NetFlow#NetFlow_Record&#34;&gt;records&lt;/a&gt;. Each record is a hashref and strangely by default its keys are stringified numbers (&amp;ldquo;1&amp;rdquo; through &amp;ldquo;20&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;However if the second argument passed to &lt;code&gt;decode&lt;/code&gt; is true, then the record hashrefs use field names instead of numbers. Each record contains data like the source and destination IP addresses and ports, the number of packets sent, total number of bytes in the packets and so on. If the record&amp;rsquo;s source IP address match my phone&amp;rsquo;s network address, the script prints the pertinent information to a logfile.&lt;/p&gt;

&lt;p&gt;I disabled mobile data on my phone, and ran this script for 24 hours.&lt;/p&gt;

&lt;h3 id=&#34;results&#34;&gt;Results&lt;/h3&gt;

&lt;p&gt;I used &lt;a href=&#34;https://metacpan.org/pod/Net::Whois::IP&#34;&gt;Net::Whois::IP&lt;/a&gt; to lookup the organization for each IP address. Here&amp;rsquo;s the top ten Organizations by the number of packets sent:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Fastly (SKYCA-3) =&amp;gt; 1243
OPENX TECHNOLOGIES, INC. (OPENX) =&amp;gt; 989
Saferoute Incorporated (SAFER-1) =&amp;gt; 553
Servers.com, Inc. (SERVE-105) =&amp;gt; 13
Integral Ad Science, Inc. (ASML-5) =&amp;gt; 36
Facebook =&amp;gt; 724
Google LLC (GOOGL-2) =&amp;gt; 794
Amazon.com, Inc. (AMAZO-4) =&amp;gt; 2000
Search Guide Inc (SG-63) =&amp;gt; 140
Chaos Computer Club e.V =&amp;gt; 224
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And by the number of bytes sent:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Amazon Technologies Inc. (AT-88-Z) =&amp;gt; 1218193
Amazon.com, Inc. (AMAZO-48) =&amp;gt; 9230
Google LLC (GOGL) =&amp;gt; 40239218
VLAN927 =&amp;gt; 2005
ADFORM-NET =&amp;gt; 3041
ANS Communications, Inc (ANS) =&amp;gt; 1880
Wal-Mart Stores, Inc. (WALMAR) =&amp;gt; 1573
INAP-NYM-QUANTCAST-26423 =&amp;gt; 4822
Web.com, Inc. (WEBCO-24) =&amp;gt; 4232
CERFnet (CERF) =&amp;gt; 361
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It seems to me to be mostly web browsing / marketing data. The &lt;a href=&#34;https://www.ccc.de/en/club&#34;&gt;Chaos Computer Club&lt;/a&gt; entry is from using &lt;a href=&#34;https://guardianproject.info/apps/orfox/&#34;&gt;Orfox&lt;/a&gt; (a Tor browser). Although honestly, if something malicious was using AWS, I&amp;rsquo;m not sure how I could tell. Perhaps looking at the distribution and frequency of packets sent and correlating it with a journal of my phone activity might be a way to identify suspicious traffic.&lt;/p&gt;

&lt;p&gt;In the meantime, Google has stopped warning me about unusual activity, and I haven&amp;rsquo;t cracked the screen yet, so I suppose I&amp;rsquo;ll keep using this phone for now.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.dd-wrt.com/site/index&#34;&gt;DD-WRT&lt;/a&gt; is a Linux distribution for routers&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Data::Netflow&#34;&gt;Data::Netflow&lt;/a&gt; is a Perl module that can encode/decode Netflow data versions 5 and 9 (DD-WRT produces version 5).&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Net::Whois::IP&#34;&gt;Net::Whois::IP&lt;/a&gt; is a Perl module for running &lt;a href=&#34;https://en.wikipedia.org/wiki/WHOIS&#34;&gt;WHOIS&lt;/a&gt; queries, it parses the response into a Perl data structure although it doesn&amp;rsquo;t normalize the keys.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

