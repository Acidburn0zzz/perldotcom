<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Poe on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/poe/</link>
    <description>Recent content in Poe on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 26 Jan 2006 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/poe/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>More Advancements in Perl Programming</title>
      <link>http://localhost:1313/pub/2006/01/26/more_advanced_perl.html/</link>
      <pubDate>Thu, 26 Jan 2006 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2006/01/26/more_advanced_perl.html/</guid>
      <description>

&lt;p&gt;Around Easter last year, I finished writing the second edition of &lt;a href=&#34;http://www.oreilly.com/catalog/advperl2/&#34;&gt;Advanced Perl Programming&lt;/a&gt;, a task that had been four years in the making. The aim of this new edition was to reflect the way that Perl programming had changed since the first edition. Much of what Sriram wrote in the original edition was still true, but to be honest, not too much of it was useful anymore&amp;ndash;the Perl world has changed dramatically since the original publication.&lt;/p&gt;

&lt;p&gt;The first edition was very much about how to do things yourself; it operated at a very low level by current Perl standards. With the explosion of CPAN modules in the interim, &amp;ldquo;advanced Perl programming&amp;rdquo; now consists of plugging all of the existing components together in the right order, rather than necessarily writing the components from scratch. So the nature of the book had to change a lot.&lt;/p&gt;

&lt;p&gt;However, CPAN is still expanding, and the Perl world continues to change; &lt;em&gt;Advanced Perl Programming&lt;/em&gt; can never be a finished book, but only a snapshot in time. On top of all that, I&amp;rsquo;ve been learning more, too, and discovering more tricks to get work done smarter and faster. Even during the writing of the book, some of the best practices changed and new modules were developed.&lt;/p&gt;

&lt;p&gt;The book is still, I believe, an excellent resource for learning how to master Perl programming, but here, if you like, I want to add to that resource. I&amp;rsquo;ll try to say something about the developments that have happened in each chapter of the book.&lt;/p&gt;

&lt;h3 id=&#34;advanced-perl&#34;&gt;Advanced Perl&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;m actually very happy with this chapter. The only thing I left out of the first chapter which may have been useful there is a section on &lt;code&gt;tie&lt;/code&gt;; but this is covered strongly in &lt;em&gt;Programming Perl&lt;/em&gt; anyway.&lt;/p&gt;

&lt;p&gt;On the other hand, although it&amp;rsquo;s not particularly advanced, one of the things I wish I&amp;rsquo;d written about in the book was best practices for creating object-oriented modules. My fellow O&amp;rsquo;Reilly author Damian Conway has already written two books about these topics, so, again, I didn&amp;rsquo;t get too stressed out about having to leave those sections out. That said, the two modules I would recommend for building OO classes don&amp;rsquo;t appear to get a mention in &lt;em&gt;Perl Best Practices&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;First, we all know it&amp;rsquo;s a brilliant idea to create accessors for our data members in a class; however, it&amp;rsquo;s also a pain in the neck to create them yourself. There seem to be hundreds of CPAN modules that automate the process for you, but the easiest is the &lt;a href=&#34;https://metacpan.org/pod/Class::Accessor&#34;&gt;&lt;code&gt;Class::Accessor&lt;/code&gt;&lt;/a&gt; module. With this module, you declare which accessors you want, and it will automatically create them. As a useful bonus, it creates a default &lt;code&gt;new()&lt;/code&gt; method for you if you don&amp;rsquo;t want to write one of those, either.&lt;/p&gt;

&lt;p&gt;Instead of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package MyClass;

sub new { bless { %{@_} }, shift; }

sub name {
    my $self = shift;
    if (@_) { $self-&amp;gt;{name} = shift; }
    $self-&amp;gt;{name}
}

sub address {
    my $self = shift;
    if (@_) { $self-&amp;gt;{address} = shift; }
    $self-&amp;gt;{address}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you can now say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package MyClass;
use base qw(Class::Accessor);

MyClass-&amp;gt;mk_accessors(qw( name address ));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Class::Accessor&lt;/code&gt; also contains methods for making read-only accessors and for creating separate read and write accessors, and everything is nicely overrideable. Additionally, there are subclasses that extend &lt;code&gt;Class::Accessor&lt;/code&gt; in various ways: &lt;a href=&#34;https://metacpan.org/pod/Class::Accessor::Fast&#34;&gt;&lt;code&gt;Class::Accessor::Fast&lt;/code&gt;&lt;/a&gt; trades off a bit of the extensibility for an extra speed boost, &lt;a href=&#34;https://metacpan.org/pod/Class::Accessor::Chained&#34;&gt;&lt;code&gt;Class::Accessor::Chained&lt;/code&gt;&lt;/a&gt; returns the object when called with parameters, and &lt;a href=&#34;https://metacpan.org/pod/Class::Accessor::Assert&#34;&gt;&lt;code&gt;Class::Accessor::Assert&lt;/code&gt;&lt;/a&gt; does rudimentary type checking on the parameter values. There are many, many modules on the CPAN that do this sort of thing, but this one is, in my opinion, the most flexible and simple.&lt;/p&gt;

&lt;p&gt;Speaking of flexibility, one way to encourage flexibility in your modules and applications is to make them pluggable&amp;ndash;that is, to allow other pieces of code to respond to actions that you define. &lt;a href=&#34;https://metacpan.org/pod/Module::Pluggable&#34;&gt;&lt;code&gt;Module::Pluggable&lt;/code&gt;&lt;/a&gt; is a simple but powerful little module that searches for installed modules in a given namespace. Here&amp;rsquo;s an example of its use in &lt;a href=&#34;https://metacpan.org/pod/Email::FolderType&#34;&gt;&lt;code&gt;Email::FolderType&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Module::Pluggable 
    search_path =&amp;gt; &amp;quot;Email::FolderType&amp;quot;, 
    require     =&amp;gt; 1, 
    sub_name    =&amp;gt; &#39;matchers&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This looks for all modules underneath the &lt;code&gt;Email::FolderType::&lt;/code&gt; namespace, &lt;code&gt;require&lt;/code&gt;s them, and assembles a list of their classes into the &lt;code&gt;matchers&lt;/code&gt; method. The module later determines the type of an email folder by passing it to each of the recognizers and seeing which of them handles it, with the moral equivalent of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub folder_type {
    my ($self, $folder) = @_;
    for my $class ($self-&amp;gt;matchers) {
        return $class if $class-&amp;gt;match($folder);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This means you don&amp;rsquo;t need to know, when you&amp;rsquo;re writing the code, what folder types you support; you can start off with no recognizers and add them later. If a new type of email folder comes along, the user can install a third-party module from CPAN that deals with it, and &lt;code&gt;Email::FolderType&lt;/code&gt; requires no additional coding to add support for it.&lt;/p&gt;

&lt;h3 id=&#34;parsing&#34;&gt;Parsing&lt;/h3&gt;

&lt;p&gt;Perhaps the biggest change of heart I had between writing a chapter and its publication was in the parsing chapter. That chapter had very little about parsing HTML, and what it did have was not very friendly. Since then, Gisle Aas and Sean Burke&amp;rsquo;s &lt;a href=&#34;https://metacpan.org/pod/HTML::TreeBuilder&#34;&gt;&lt;code&gt;HTML::TreeBuilder&lt;/code&gt;&lt;/a&gt; and the corresponding &lt;a href=&#34;https://metacpan.org/pod/XML::TreeBuilder&#34;&gt;&lt;code&gt;XML::TreeBuilder&lt;/code&gt;&lt;/a&gt; have established themselves as much simpler and more flexible ways to navigate HTML and XML documents.&lt;/p&gt;

&lt;p&gt;The basic concept in &lt;code&gt;HTML::TreeBuilder&lt;/code&gt; is the HTML element, represented as an object of the &lt;code&gt;HTML::Element&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$a = HTML::Element-&amp;gt;new(&#39;a&#39;, href =&amp;gt; &#39;http://www.perl.com/&#39;);
$html = $a-&amp;gt;as_HTML;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This creates a new element that is an anchor tag, with an &lt;code&gt;href&lt;/code&gt; attribute. The HTML equivalent in &lt;code&gt;$html&lt;/code&gt; would be &lt;code&gt;&amp;lt;a href=&amp;quot;http://www.perl.com&amp;quot;/&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now you can add some content to that tag:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$a-&amp;gt;push_content(&amp;quot;The Perl Homepage&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This time, the object represents &lt;code&gt;&amp;lt;a href=&amp;quot;http://www.perl.com&amp;quot;&amp;gt; The Perl Homepage &amp;lt;/a&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can ask this element for its tag, its attributes, its content, and so on:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$tag = $a-&amp;gt;tag;
$link = $a-&amp;gt;attr(&amp;quot;href&amp;quot;);
@content = $a-&amp;gt;content_list; # More HTML::Element nodes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, when you are parsing HTML, you won&amp;rsquo;t be creating those elements manually. Instead, you&amp;rsquo;ll be navigating a tree of them, built out of your HTML document. The top-level module &lt;code&gt;HTML::TreeBuilder&lt;/code&gt; does this for you:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use HTML::TreeBuilder;
my $tree = HTML::TreeBuilder-&amp;gt;new();
$tree-&amp;gt;parse_file(&amp;quot;index.html&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now &lt;code&gt;$tree&lt;/code&gt; is a &lt;code&gt;HTML::Element&lt;/code&gt; object representing the &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; tag and all its contents. You can extract all of the links with the &lt;code&gt;extract_links()&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (@{ $tree-&amp;gt;extract_links() || [] }) {
     my($link, $element, $attr, $tag) = @$_;
     print &amp;quot;Found link to $link in $tag\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although the real workhorse of this module is the &lt;code&gt;look_down()&lt;/code&gt; method, which helps you pull elements out of the tree by their tags or attributes. For instance, in a search engine indexer, indexing HTML files, I have the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for my $tag ($tree-&amp;gt;look_down(&amp;quot;_tag&amp;quot;,&amp;quot;meta&amp;quot;)) {
    next unless $tag-&amp;gt;attr(&amp;quot;name&amp;quot;);
    $hash{$tag-&amp;gt;attr(&amp;quot;name&amp;quot;)} .= $tag-&amp;gt;attr(&amp;quot;content&amp;quot;). &amp;quot; &amp;quot;;
}

$hash{title} .= $_-&amp;gt;as_text.&amp;quot; &amp;quot; for $tree-&amp;gt;look_down(&amp;quot;_tag&amp;quot;,&amp;quot;title&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This finds all &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; tags and puts their attributes as name-value pairs in a hash; then it puts all the text inside of &lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; tags together into another hash element. Similarly, you can look for tags by attribute value, spit out sub-trees as HTML or as text, and much more, besides. For reaching into HTML text and pulling out just the bits you need, I haven&amp;rsquo;t found anything better.&lt;/p&gt;

&lt;p&gt;On the XML side of things, &lt;a href=&#34;https://metacpan.org/pod/XML::Twig&#34;&gt;&lt;code&gt;XML::Twig&lt;/code&gt;&lt;/a&gt; has emerged as the usual &amp;ldquo;middle layer,&amp;rdquo; when &lt;a href=&#34;https://metacpan.org/pod/XML::Simple&#34;&gt;&lt;code&gt;XML::Simple&lt;/code&gt;&lt;/a&gt; is too simple and &lt;a href=&#34;https://metacpan.org/pod/XML::Parser&#34;&gt;&lt;code&gt;XML::Parser&lt;/code&gt;&lt;/a&gt; is, well, too much like hard work.&lt;/p&gt;

&lt;h3 id=&#34;templating&#34;&gt;Templating&lt;/h3&gt;

&lt;p&gt;There&amp;rsquo;s not much to say about templating, although in retrospect, I would have spent more of the paper expended on &lt;a href=&#34;https://metacpan.org/pod/HTML::Mason&#34;&gt;&lt;code&gt;HTML::Mason&lt;/code&gt;&lt;/a&gt; talking about the &lt;a href=&#34;http://www.template-toolkit.org/&#34;&gt;Template Toolkit&lt;/a&gt; instead. Not that there&amp;rsquo;s anything wrong with &lt;code&gt;HTML::Mason&lt;/code&gt;, but the world seems to be moving away from templates that include code in a specific language (say, Perl&amp;rsquo;s) towards separate templating little languages, like &lt;a href=&#34;https://metacpan.org/pod/Template::TAL&#34;&gt;TAL&lt;/a&gt; and Template Toolkit.&lt;/p&gt;

&lt;p&gt;The only thing to report is that Template Toolkit finally received a bit of attention from its maintainer a couple of months ago, but the long-awaited Template Toolkit 3 is looking as far away as, well, Perl 6.&lt;/p&gt;

&lt;h3 id=&#34;natural-language-processing&#34;&gt;Natural Language Processing&lt;/h3&gt;

&lt;p&gt;Who would have thought that the big news of 2005 would be that Yahoo is relevant again? Not only are they coming up with interesting new search technologies such as Y!Q, but they&amp;rsquo;re releasing a lot of the guts behind what they&amp;rsquo;re doing as public APIs. One of those that is particularly relevant for NLP is the &lt;a href=&#34;http://developer.yahoo.net/search/content/V1/termExtraction.html&#34;&gt;Term Extraction web service&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This takes a chunk of text and pulls out the distinctive terms and phrases. Think of this as a step beyond something like &lt;a href=&#34;https://metacpan.org/pod/Lingua::EN::Keywords&#34;&gt;&lt;code&gt;Lingua::EN::Keywords&lt;/code&gt;&lt;/a&gt;, with the firepower of Yahoo behind it. To access the API, simply send a HTTP &lt;code&gt;POST&lt;/code&gt; request to a given URL:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use LWP::UserAgent;
use XML::Twig;
my $uri  = &amp;quot;http://api.search.yahoo.com/ContentAnalysisService/V1/termExtraction&amp;quot;;
my $ua   = LWP::UserAgent-&amp;gt;new();
my $resp = $ua-&amp;gt;post($uri, {
    appid   =&amp;gt; &amp;quot;PerlYahooExtractor&amp;quot;,
    context =&amp;gt; &amp;lt;&amp;lt;EOF
Two Scottish towns have seen the highest increase in house prices in the
UK this year, according to new figures. 
Alexandria in West Dunbartonshire and Coatbridge in North Lanarkshire
both saw an average 35% rise in 2005. 
EOF
});
if ($resp-&amp;gt;is_success) { 
    my $xmlt = XML::Twig-&amp;gt;new( index =&amp;gt; [ &amp;quot;Result&amp;quot; ]);
    $xmlt-&amp;gt;parse($resp-&amp;gt;content);
    for my $result (@{ $xmlt-&amp;gt;index(&amp;quot;Result&amp;quot;) || []}) {
        print $result-&amp;gt;text;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This produces:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;north lanarkshire
scottish towns
west dunbartonshire
house prices
coatbridge
dunbartonshire
alexandria
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once I had informed the London Perl Mongers of this amazing discovery, Simon Wistow immediately bundled it up into a Perl module called &lt;a href=&#34;https://metacpan.org/pod/Lingua::EN::Keywords::Yahoo&#34;&gt;&lt;code&gt;Lingua::EN::Keywords::Yahoo&lt;/code&gt;&lt;/a&gt;, coming soon to a CPAN mirror near you.&lt;/p&gt;

&lt;h3 id=&#34;unicode&#34;&gt;Unicode&lt;/h3&gt;

&lt;p&gt;The best news about Unicode over the last year is that you should not have noticed any major changes. By now, the core Unicode support in Perl just works, and most of the CPAN modules that deal with external data have been updated to work with Unicode.&lt;/p&gt;

&lt;p&gt;If you don&amp;rsquo;t see or hear anything about Unicode, that&amp;rsquo;s a good thing: it means it&amp;rsquo;s all working properly.&lt;/p&gt;

&lt;h3 id=&#34;poe&#34;&gt;POE&lt;/h3&gt;

&lt;p&gt;The chapter on POE was a great introduction to how POE works and some of the things that you can do with it, but it focused on using POE for networking applications and for daemons. This is only half the story. Recently a lot of interest has centered on using POE for graphical and command-line applications: Randal Schwartz takes over from the RSS aggregator at the end of the chapter by integrating it with a graphical interface in &amp;ldquo;&lt;a href=&#34;http://www.stonehenge.com/merlyn/PerlJournal/col11.html&#34;&gt;Graphical interaction with POE and Tk&lt;/a&gt;.&amp;rdquo; Here, I want to consider command-line applications.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://metacpan.org/pod/Term::Visual&#34;&gt;&lt;code&gt;Term::Visual&lt;/code&gt;&lt;/a&gt; module is a POE component for creating applications with a split-screen interface; at the bottom of the interface, you type your input, and the output appears above a status line. The module handles all of the history, status bar updates, and everything else for you. Here&amp;rsquo;s an application that uses &lt;a href=&#34;https://metacpan.org/pod/Chatbot::Eliza&#34;&gt;&lt;code&gt;Chatbot::Eliza&lt;/code&gt;&lt;/a&gt; to provide therapeutic session with everyone&amp;rsquo;s favorite digital psychiatrist.&lt;/p&gt;

&lt;p&gt;First, set up the chatbot and create a new &lt;code&gt;Term::Visual&lt;/code&gt; object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/perl -w
use POE;
use POSIX qw(strftime);
use Term::Visual;
use Chatbot::Eliza;
my $eliza = Chatbot::Eliza-&amp;gt;new();
my $vt    = Term::Visual-&amp;gt;new( Alias =&amp;gt; &amp;quot;interface&amp;quot; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now create the window, which will have space on its status bar for a clock:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $window_id = $vt-&amp;gt;create_window(
   Status =&amp;gt; { 0 =&amp;gt; { format =&amp;gt; &amp;quot;[%8.8s]&amp;quot;, fields =&amp;gt; [&amp;quot;time&amp;quot;] } },
   Title =&amp;gt; &amp;quot;Eliza&amp;quot; 
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You also need a &lt;a href=&#34;https://metacpan.org/pod/POE::Session&#34;&gt;&lt;code&gt;POE::Session&lt;/code&gt;&lt;/a&gt;, which will do all the work. It will have three states; the first is the &lt;code&gt;_start&lt;/code&gt; state, to tell &lt;code&gt;Term::Visual&lt;/code&gt; what to do with any input it gets from the keyboard and to update the clock:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;POE::Session-&amp;gt;create
(inline_states =&amp;gt;
  { _start          =&amp;gt; sub {
        $_[KERNEL]-&amp;gt;post( interface =&amp;gt; send_me_input =&amp;gt; &amp;quot;got_term_input&amp;quot; );
        $_[KERNEL]-&amp;gt;yield( &amp;quot;update_time&amp;quot; );
    },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Updating the clock is simply a matter of setting the &lt;code&gt;time&lt;/code&gt; field declared earlier to the current time, and scheduling another update at the top of the next minute:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    update_time     =&amp;gt; sub {
        $vt-&amp;gt;set_status_field( $window_id,
                               time =&amp;gt; strftime(&amp;quot;%I:%M %p&amp;quot;, localtime) );
        $_[KERNEL]-&amp;gt;alarm( update_time =&amp;gt; int(time() / 60) * 60 + 60 );
    },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, you need to handle the input from the user. Do that in a separate subroutine to make things a big clearer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    got_term_input  =&amp;gt; \&amp;amp;handle_term_input,
  }
);

$poe_kernel-&amp;gt;run();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When &lt;code&gt;Term::Visual&lt;/code&gt; gets a line of text from the user, it passes it to the state declared in the &lt;code&gt;_start&lt;/code&gt; state. The code takes that text, prints it to the terminal as an echo, and then passes it through Eliza:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub handle_term_input {
  my ($heap, $input) = @_[HEAP, ARG0];
  if ($input =~ m{^/quit}i) {
    $vt-&amp;gt;delete_window($window_id); 
    exit;
  }

  $vt-&amp;gt;print($window_id, &amp;quot;&amp;gt; $input&amp;quot;);
  $vt-&amp;gt;print($window_id, $eliza-&amp;gt;transform($input));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In just a few lines of code you have a familiar interface, similar to many IRC or MUD clients, with POE hiding all of the event handling away.&lt;/p&gt;

&lt;h3 id=&#34;testing&#34;&gt;Testing&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Advanced Perl Programming&lt;/em&gt; showed how to write tests so that we all can be more sure that our code is doing what it should. How do you know your tests are doing enough? Enter Paul Johnson&amp;rsquo;s &lt;a href=&#34;https://metacpan.org/pod/Devel::Cover&#34;&gt;&lt;code&gt;Devel::Cover&lt;/code&gt;&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Devel::Cover&lt;/code&gt; makes a record of each time a Perl operation or statement is executed, and then compares this against the statements in your code. So when you&amp;rsquo;re running your tests, you can see which of the code paths in your module get exercised and which don&amp;rsquo;t; if you have big branches of code that never get tested, maybe you should write more tests for them!&lt;/p&gt;

&lt;p&gt;To use it on an uninstalled module:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cover -delete
$ HARNESS_PERL_SWITCHES=-MDevel::Cover make test
$ cover
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will give you a textual summary of code coverage; &lt;code&gt;cover -report html&lt;/code&gt; produces a colorized, navigable hypertext summary, useful for showing to bosses.&lt;/p&gt;

&lt;p&gt;This ensures that your code works&amp;ndash;or at least, that it does what your tests specify. The next step is to ensure that your code is actually of relatively decent quality. Because &amp;ldquo;quality&amp;rdquo; is a subjective metric when it comes to the art of programming, Perl folk have introduced the objective of &amp;ldquo;Kwalitee&amp;rdquo; instead, which may or may not have any bearing on quality.&lt;/p&gt;

&lt;p&gt;All modules on CPAN have their Kwalitee measured as part of the &lt;a href=&#34;http://cpants.dev.zsi.at/&#34;&gt;CPANTS&lt;/a&gt; (CPAN Testing Service) website. One way to test for and increase your Kwalitee is to use the &lt;a href=&#34;https://metacpan.org/pod/Module::Build::Kwalitee&#34;&gt;&lt;code&gt;Module::Build::Kwalitee&lt;/code&gt;&lt;/a&gt; module; this copies some boilerplate tests into your distribution that ensure that you have adequate and syntactically correct documentation, that you &lt;code&gt;use strict&lt;/code&gt; and &lt;code&gt;warnings&lt;/code&gt;, and so on.&lt;/p&gt;

&lt;p&gt;All of this ought to go a fair way to improving the Kwalitee of your code, if not its actual quality!&lt;/p&gt;

&lt;h3 id=&#34;inline&#34;&gt;Inline&lt;/h3&gt;

&lt;p&gt;One of the things that has come over into Perl 5 from Perl 6 development is the concept of the Native Call Interface (NCI). This hasn&amp;rsquo;t fully been developed yet, but chromatic (yes, the editor of this very site) has been working on it.&lt;/p&gt;

&lt;p&gt;The idea is that, instead of having something like Inline or XS that creates a &amp;ldquo;buffer&amp;rdquo; between Perl and C libraries, you just call those libraries directly. At the moment, you need to compile any XS module against the library you&amp;rsquo;re using. This is particularly awkward for folk on cut-down operating systems that do not ship a compiler, such as Palm OS or Windows.&lt;/p&gt;

&lt;p&gt;The strength of NCI is that it doesn&amp;rsquo;t require a compiler; instead, it uses the operating system&amp;rsquo;s normal means of making calls into libraries. (Hence &amp;ldquo;Native Call.&amp;rdquo;) It uses Perl&amp;rsquo;s &lt;code&gt;DynaLoader&lt;/code&gt; to find libraries, load them, and then find the address of symbols inside of the library. Then it calls a generic &amp;ldquo;thunk&amp;rdquo; function to turn the symbol&amp;rsquo;s address into a call. For instance:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $lib = P5NCI::Library-&amp;gt;new( library =&amp;gt; &#39;nci_test&#39;, package =&amp;gt; &#39;NCI&#39; );
$lib-&amp;gt;install_function( &#39;double_int&#39;, &#39;ii&#39; );

my $two = NCI::double_int( 1 );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These lines find the &lt;code&gt;nci_test&lt;/code&gt; shared library and get ready to put its functions into the &lt;code&gt;NCI&lt;/code&gt; namespace. It then installs the function &lt;code&gt;double_int&lt;/code&gt;, which is of signature &lt;code&gt;int double_int(int)&lt;/code&gt; (hence &lt;code&gt;ii&lt;/code&gt;). Once this is done, you can call the function from Perl. It&amp;rsquo;s not much trickier than Inline, but without the intermediate step of compilation.&lt;/p&gt;

&lt;p&gt;NCI isn&amp;rsquo;t quite there yet, and it only supports very simple function signatures. However, because of its portability, it&amp;rsquo;s definitely the one to watch for Perl-C interfaces in the future.&lt;/p&gt;

&lt;h3 id=&#34;everything-else&#34;&gt;Everything Else&lt;/h3&gt;

&lt;p&gt;The last chapter is &amp;ldquo;Fun with Perl.&amp;rdquo; Now, much has happened in the world of Perl fun, but much has happened all over Perl. There were many other things I wanted to write about, as well: CPAN best practices for date/time handling and email handling, Perl 6 and Pugs, the very latest web application frameworks such as Catalyst and Jifty, and so on. But all these would fill another book&amp;ndash;and if I ever finished that, it too would require an update like this one. So I hope this is enough for you to be getting on with!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building Applications with POE</title>
      <link>http://localhost:1313/pub/2004/07/22/poe.html/</link>
      <pubDate>Fri, 23 Jul 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/07/22/poe.html/</guid>
      <description>

&lt;p&gt;Earlier, we talked about the &lt;a href=&#34;http://www.perl.com/pub/2004/07/02/poeintro.html&#34;&gt;fundamental principles&lt;/a&gt; of application design with POE. Now it&amp;rsquo;s time to put my money where my mouth is and build some actual working code.&lt;/p&gt;

&lt;p&gt;To make life a bit easier, let&amp;rsquo;s lay out a very simple problem. Let&amp;rsquo;s say we would like accept and parse data that resembles CGI query strings. This data will be key value pairs in which the key and value are separated by &lt;code&gt;=&lt;/code&gt;&amp;rsquo;s and the pairs themselves are delimited by &lt;code&gt;&amp;amp;&lt;/code&gt;. An example string we&amp;rsquo;ll use throughout this article is as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  foo=bar&amp;amp;baz=1&amp;amp;bat=2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By the time we&amp;rsquo;re done, we will have a working Filter and Component to handle this incoming data.&lt;/p&gt;

&lt;h3 id=&#34;step-1-a-filter&#34;&gt;Step 1: A Filter&lt;/h3&gt;

&lt;p&gt;The first step is building a simple filter to parse this incoming data. As we discussed earlier, filters are much easier to deal with because they are unaware of their environment and the POE context in which they are run. Our filter is made even easier since we are just parsing incoming data and not generating an outgoing datastream.&lt;/p&gt;

&lt;p&gt;First off, we need the basics of any good module.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  package POE::Filter::SimpleQueryString;

  use warnings;
  use strict;

  use Carp qw(carp croak);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we need a constructor.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  sub new { 
    my $class = shift;
    my $self = bless {}, $class;
    return $self;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is about the simplest constructor possible. This very simple filter requires no parameters to operate. It is perfectly reasonable, however, to demand parameters of filter users. For instance, if the filter could &lt;code&gt;rot13&lt;/code&gt; the incoming data before parsing, and a parameter could turn that feature on.&lt;/p&gt;

&lt;h4 id=&#34;get&#34;&gt;get()&lt;/h4&gt;

&lt;p&gt;Now we need the ability to parse data. We will be using the newer and much simpler &lt;code&gt;get&lt;/code&gt;/&lt;code&gt;put&lt;/code&gt; version of the Filter API. This version of the standard POE Filter API requires &lt;code&gt;get()&lt;/code&gt; and &lt;code&gt;put()&lt;/code&gt; methods with the ability to transform multiple record sets per invocation.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;get()&lt;/code&gt;&amp;rsquo;s job is transform raw data into cooked record sets. The example string above (&lt;code&gt;foo=bar&amp;amp;baz=1&amp;amp;bat=2&lt;/code&gt;) will become a hash:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $VAR1 = {
    &#39;foo&#39; =&amp;gt; &#39;bar&#39;,
    &#39;baz  =&amp;gt; &#39;1&#39;,
    &#39;bat  =&amp;gt; &#39;2&#39;,
  };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A POE Filter is just a normal Perl object with a defined interface.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  sub get {
    my $self = shift;
    my $buffer = shift;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The buffer can and probably will contain multiple records. The size of the buffer is determined by the POE Driver being used and the operating system in question. &lt;code&gt;$buffer&lt;/code&gt; will always be an array reference. While it is generally sensible to test &lt;code&gt;$buffer&lt;/code&gt; to make sure it conforms to the standard interface, for the purpose of this exercise, we will just trust POE.&lt;/p&gt;

&lt;p&gt;In our super-easy format, an individual record is terminated by a &lt;code&gt;\n&lt;/code&gt;. Key value pairs are delimited by &lt;code&gt;&amp;amp;&lt;/code&gt; and key and value themselves are separated by an &lt;code&gt;=&lt;/code&gt;. Note that we aren&amp;rsquo;t dealing with issues like character escaping or data taint. Production quality code will need to deal with these issues.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @chunks; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each parsed line makes up a chunk of data. We want to represent each record as a distinct entity to the user.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    foreach my $record (@$buffer) { 
      $record =~ s/\x0d\x0a$//;
      my @pairs = split(/&amp;amp;/, $record);

      my %chunk;
      foreach my $pair (@pairs) {
        my ($key, $value) = split(/=/, $pair, 2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So what happens if there is more than one instance of a given key in a record? Simple. We make an array reference. The user will need to inspect the value of each key to determine if they have more than one value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        if(defined $chunk{$key}) {
          if(ref $chunk{$key} eq &#39;ARRAY&#39;) {
            push @{ $chunk{$key} }, $value;
          } else {
            $chunk{$key} = [ $chunk{$key}, $value ],
          }
        } else {
          $chunk{$key} = $value;
        }
      }
      push @chunks, \%chunk;
    }
    return \@chunks;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;put&#34;&gt;put()&lt;/h4&gt;

&lt;p&gt;We now have a simple query-string-like data parser. This is fine for read-only servers but it makes sense to allow our users to send data back and forth in the same format. To allow for that, we need a &lt;code&gt;put()&lt;/code&gt; method. &lt;code&gt;put()&lt;/code&gt;&amp;rsquo;s job is take the cooked form of our records and translate it to the raw form. In this case we will be taking a hash reference that looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $VAR1 = {
    &#39;foo&#39; =&amp;gt; &#39;bar&#39;,
    &#39;baz&#39; =&amp;gt; &#39;1&#39;,
    &#39;bat&#39; =&amp;gt; &#39;2&#39;,
  };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And transforming it into:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  foo=bar&amp;amp;baz=1&amp;amp;bat=2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So that whatever Wheel our user has chosen can put the data onto the wire. Like &lt;code&gt;get()&lt;/code&gt;, &lt;code&gt;put()&lt;/code&gt; is a normal method call on a normal perl object.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  sub put { 
    my $self = shift;
    my $records = shift;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Like &lt;code&gt;get()&lt;/code&gt;, the data to act on is passed in as a parameter to the method call. It is always an array reference of records to translate.&lt;/p&gt;

&lt;p&gt;Basically, our &lt;code&gt;put()&lt;/code&gt; method performs an exact reversal of the &lt;code&gt;get()&lt;/code&gt; algorithm. Take each key/value pair and concatenate them with an &lt;code&gt;=&lt;/code&gt;. Each pair is then joined with a &lt;code&gt;&amp;amp;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The only real error condition we are checking for is the presence of non-array data. Since we haven&amp;rsquo;t defined behavior for this condition, we warn the user about the data and skip it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @raw;
    foreach my $record (@$records) {
      my @chunks;
      foreach my $key (sort keys %$record) {
        if(ref $record-&amp;gt;{$key}) {
          if(ref $record-&amp;gt;{$key} eq &#39;ARRAY&#39;) {
            foreach my $value ( @{ $record-&amp;gt;{$key} } ) {
              push @chunks, $key.&amp;quot;=&amp;quot;.$value;
            }
          } else {
            carp __PACKAGE__.&amp;quot; cannot handle data of type 
            &amp;quot;.ref $record-&amp;gt;{$key};
          }
        } else {
          push @chunks, $key.&amp;quot;=&amp;quot;.$record-&amp;gt;{$key};
        }
      }
      push @raw, join(&#39;&amp;amp;&#39;,@chunks).&amp;quot;\x0d\x0a&amp;quot;;
    }
    return \@raw;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The raw data is returned to the caller as an array reference of data chunks. The caller has the responsibility of putting the data on the wire in the appropriate fashion.&lt;/p&gt;

&lt;h3 id=&#34;step-2-a-wheel&#34;&gt;Step 2: A Wheel&lt;/h3&gt;

&lt;p&gt;Chances are that our users want to send data in one of the standard UNIX methods &amp;ndash; sockets, pipes, and so on. Lucky for us, POE already has Wheels to deal with just about any methodology of data transfer you can imagine. Let&amp;rsquo;s work with a method that should work just about anywhere, TCP sockets. &lt;code&gt;POE::Wheel::SocketFactory&lt;/code&gt; provides the functionality we need. First, we need a session to plug the wheel into. (Remember that wheels &lt;strong&gt;mutate&lt;/strong&gt; sessions to provide new functionality.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  POE::Session-&amp;gt;create(
    inline_states =&amp;gt; {
      _start      =&amp;gt; \&amp;amp;start,
      factory_success =&amp;gt; \&amp;amp;factory_success,

      client_input  =&amp;gt; \&amp;amp;client_input,
      client_error  =&amp;gt; \&amp;amp;client_error,

      fatal_error   =&amp;gt; sub { die &amp;quot;A fatal error occurred&amp;quot; },
      _stop       =&amp;gt; sub {},
    },
  );

  POE::Kernel-&amp;gt;run();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This session will be our controller for the wheels we need to perform socket operations. Each wheel-based event provides a unique identifier so it is possible to handle more than one client per session.&lt;/p&gt;

&lt;p&gt;When the session starts up, we spin up the SocketFactory wheel. With the Reuse flag on, SocketFactory will continuously listen on the specified port and address, handing us events for each client. The unique id passed to the SuccessEvent identifies each client.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  sub start {
    $_[HEAP]-&amp;gt;{factory} = POE::Wheel::SocketFactory-&amp;gt;new(
      BindAddress   =&amp;gt; &#39;127.0.0.1&#39;,
      BindPort    =&amp;gt; &#39;31337&#39;,
      SuccessEvent  =&amp;gt; &#39;factory_success&#39;,
      FailureEvent  =&amp;gt; &#39;fatal_error&#39;,
      SocketProtocol  =&amp;gt; &#39;tcp&#39;,
      Reuse       =&amp;gt; &#39;on&#39;,
    );
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When a client makes a connection, the SocketFactory lets us know. It is our job to figure out what to do with the filehandle SocketFactory built for us. In this case, we want read/write functionality using the filter we built above. &lt;code&gt;POE::Wheel::ReadWrite&lt;/code&gt; provides this functionality, including the ability to plug in our filter.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  sub factory_success {
    my( $handle, $wheel_id ) = @_[ARG0, ARG1];
    $_[HEAP]-&amp;gt;{clients}-&amp;gt;{ $wheel_id }  =
      POE::Wheel::ReadWrite-&amp;gt;new(
        Handle    =&amp;gt; $handle,
        Driver    =&amp;gt; POE::Driver::SysRW-&amp;gt;new(),
        Filter    =&amp;gt; POE::Filter::SimpleQueryString-&amp;gt;new(),
        InputEvent  =&amp;gt; &#39;client_input&#39;,
      );
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the data path is set up. We have the ability for programs to connect to a port and provide data in our simple format. What to do with the data though? Let&amp;rsquo;s simply print it out and echo it back to the client.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  sub client_input {
    my ($input, $wheel_id) = @_[ARG0, ARG1];

    use Data::Dumper;
    print Dumper $input;

    $_[HEAP]-&amp;gt;{clients}-&amp;gt;{ $wheel_id }-&amp;gt;put( $input );
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Data::Dumper&lt;/code&gt; handles printing out the structure for us. The &lt;code&gt;put()&lt;/code&gt; call puts the structure back out onto the wire. If our algorithms are correct, we should get the same data back that we put in.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  sungo@cthulu% telnet localhost 31337
  Trying 127.0.0.1...
  Connected to localhost.
  Escape character is &#39;^]&#39;.
  foo=bar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The server prints out:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  sungo@cthulu% perl -Ilib examples/server.pl
  $VAR1 = { 
    &#39;foo&#39; =&amp;gt; &#39;bar&#39;
  };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then echoes back to us:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  foo=bar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;re in business.&lt;/p&gt;

&lt;h3 id=&#34;step-3-a-component&#34;&gt;Step 3: A Component&lt;/h3&gt;

&lt;p&gt;Man, that was a lot of code to get a simple TCP server up and running. Surely this can be simplified. Again, POE itself comes to the rescue. POE ships with a component specifically designed to simplify TCP server creation. We can replace all that code above with a simple call to the component&amp;rsquo;s constructor.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  POE::Component::Server::TCP-&amp;gt;new(
    Address =&amp;gt; &#39;127.0.0.1&#39;,
    Port  =&amp;gt; &#39;31337&#39;,

    ClientFilter =&amp;gt; &amp;quot;POE::Filter::SimpleQueryString&amp;quot;,
    ClientInput =&amp;gt; sub {
      my $input = $_[ARG0];
      use Data::Dumper;
      print Dumper $input;

      $_[HEAP]-&amp;gt;{client}-&amp;gt;put($input);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we&amp;rsquo;re done. The downside is that &lt;code&gt;Server::TCP&lt;/code&gt; doesn&amp;rsquo;t allow for argument passing to the filter&amp;rsquo;s constructor and we lose the flexibility of doing things by hand. For a lot of problems, however, this component does the trick quite nicely.&lt;/p&gt;

&lt;p&gt;We can make this even easier for our users by making our own component. For the purpose of this example, we&amp;rsquo;re going to wrap the smaller code above instead of the larger wheel based example. There is no reason why you couldn&amp;rsquo;t use the wheel-based code in your component, however.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  package POE::Component::SimpleQueryString;

  use warnings;
  use strict;

  use POE;
  use POE::Component::Server::TCP;

  use POE::Filter::SimpleQueryString;

  use Carp qw(croak carp);

  sub new {
    my $class = shift;
    my %args = @_;

    my $addr = delete $args{ListenAddr} || croak &amp;quot;ListenAddr required&amp;quot;;
    my $port = delete $args{ListenPort} || croak &amp;quot;ListenPort required&amp;quot;;
    my $input_event = delete $args{InputEvent} || 
      croak &amp;quot;InputEvent required&amp;quot;;

    my $server = POE::Component::Server::TCP-&amp;gt;new(
            Address =&amp;gt; $addr,
            Port =&amp;gt; $port,

            ClientInput =&amp;gt; $input_event,
            ClientFilter =&amp;gt; &amp;quot;POE::Filter::SimpleQueryString&amp;quot;,
           );

    return $server;
  }

  1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now our users can just load up the component like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  POE::Component::SimpleQueryString-&amp;gt;new(
    ListenAddr =&amp;gt; &#39;127.0.0.1&#39;,
    ListenPort =&amp;gt; &#39;31337&#39;,
    InputEvent =&amp;gt; sub {
      my $input = $_[ARG0];
      use Data::Dumper;
      print Dumper $input;

      $_[HEAP]-&amp;gt;{client}-&amp;gt;put($input);       
    },
  );
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;We have seen how to build POE filters and components and combine them with wheels and custom code to create flexible and maintainable programs. The code examples provided above may be &lt;a href=&#34;http://localhost:1313/media/_pub_2004_07_22_poe/poe_examples.tar.gz&#34;&gt;downloaded&lt;/a&gt; under the BSD License.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Application Design with POE</title>
      <link>http://localhost:1313/pub/2004/07/02/poeintro.html/</link>
      <pubDate>Fri, 02 Jul 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/07/02/poeintro.html/</guid>
      <description>

&lt;p&gt;Day in and day out, I write large applications in perl. I&amp;rsquo;m cursed I tell you. While large scale, long-running applications in pure perl may sound fairly easy to write, they are not. Perl, beyond a certain size and complexity, gets really difficult to manage if one is not extremely careful. The proper choice of an application framework helps to minimize this difficulty. For many applications, apache and mod_perl make a lot of sense. This is an excellent choice for user interface applications and data display systems. However, HTML and the WWW simply don&amp;rsquo;t make sense for many forms of long-running applications, particularly network based servers. Apache certainly isn&amp;rsquo;t the right choice for syslog monitoring or edge host traffic analysis.&lt;/p&gt;

&lt;p&gt;My framework of choice is POE. POE is a single-threaded, event driven, cooperative multitasking environment for perl. Basically, POE is an application framework in which a single threaded perl process waits for events to occur so it can act accordingly. This event loop comprises the core of a POE process.&lt;/p&gt;

&lt;p&gt;If all POE offered was an event loop, there would not be much to talk about though. Nor would POE be particularly special. Several event loop modules already exist on CPAN. Event, Coro, IO::Events, and IO::Poll all offer similar functionality. However, any worthwhile application demands more than a simple set of actions.&lt;/p&gt;

&lt;h3 id=&#34;span-id-sessions-sessions-span&#34;&gt;&lt;span id=&#34;SESSIONS&#34;&gt;SESSIONS&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;POE programs begin with a &amp;lsquo;session&amp;rsquo;. Each session represents a cooperatively multi-tasked state machine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    POE::Session-&amp;gt;create(
        inline_states =&amp;gt; {
            _start =&amp;gt; \&amp;amp;start,
            _stop =&amp;gt; \&amp;amp;stop,

            do_something =&amp;gt; \&amp;amp;do_something,
        },
        heap =&amp;gt; {
            &#39;some&#39; =&amp;gt; &#39;data&#39;,
        },
    );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sessions are slightly analogous to threads in that they have a unique runtime context and a semi-private data store (called the &amp;ldquo;heap&amp;rdquo;). Each session operates independently from other sessions, receiving time-slices from the POE kernel. It is important to remember that, despite the similarity to threads, all POE sessions run in the same single-threaded process.&lt;/p&gt;

&lt;p&gt;Sessions provide very simple, easy to understand building blocks on which to build more complex applications. POE provides a way to give sessions names, called &lt;em&gt;aliases&lt;/em&gt;, which uniquely address the session from outside the session itself. &lt;code&gt;$poe_kernel-&amp;gt;alias_set($alias)&lt;/code&gt; sets an alias for the current session. Any POE session in the process can then send events to that session using the named identifier.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if($door_bell) {
        $poe_kernel-&amp;gt;post( $alias =&amp;gt; &#39;pizza&#39; );
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remote addressing provides the ability to have a service-like model inside an application. Different sessions provide different services to the application. One session may provide DNS resolution while another provides data storage. Using commonly known names, perhaps stored in a config file, the central application becomes much smaller and easier to manage.&lt;/p&gt;

&lt;h3 id=&#34;span-id-components-components-span&#34;&gt;&lt;span id=&#34;COMPONENTS&#34;&gt;COMPONENTS&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;POE components provide an abstract api to service-like POE sessions. Rather than duplicating the session construction call and the accompanying subroutines every time you find a new use for your sessions, it is a better idea to roll all that code into a perl module.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package POE::Component::MyService;

    sub create {
        POE::Session-&amp;gt;create(
            # ...
        );
    }

    sub start {
        $poe_kernel-&amp;gt;alias_set(__PACKAGE__);
    }


    ####


    #!/usr/bin/perl
    use POE;
    use POE::Component::MyService;

    POE::Component::MyService-&amp;gt;create();
    POE::Kernel-&amp;gt;run();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The POE community has created a standard namespace of &lt;code&gt;POE::Component&lt;/code&gt; for these modules. Typically they have a constructor called &lt;code&gt;create()&lt;/code&gt; or &lt;code&gt;spawn()&lt;/code&gt; and provide a service to the POE application via a session. Apart from these few simple rules, components are free to do whatever is necessary to fulfill their purpose. &lt;code&gt;POE::Component::Server::Syslog&lt;/code&gt;, for instance, spawns a UDP listener and provides syslog data via callbacks. &lt;code&gt;POE::Component::RSS&lt;/code&gt; accepts RSS content via an alias and calls specially named events to deliver data. &lt;code&gt;POE::Component::IRC&lt;/code&gt; follows a similar model.&lt;/p&gt;

&lt;h3 id=&#34;span-id-wheels-wheels-span&#34;&gt;&lt;span id=&#34;WHEELS&#34;&gt;WHEELS&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;For some tasks, a full session is unnecessary. Sometimes, it makes more sense to alter the abilities of an existing session to provide the desired functionality. POE has a special namespace called &lt;code&gt;POE::Wheel&lt;/code&gt; for modules which mutate or alter the abilities of the current session to provide some new functionality.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package POE::Wheel::MyFunction;

    sub new {
        # ...
    }

    ####

    #!/usr/bin/perl
    use POE;
    use POE::Wheel::MyFunction;

    POE::Session-&amp;gt;create(
        #...
        foo =&amp;gt; \&amp;amp;foo,
    );

    POE::Kernel-&amp;gt;run();

    sub start {
        POE::Wheel::MyFunction-&amp;gt;new(
            FooState =&amp;gt; &#39;foo&#39;
        );
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where components often use subroutine callbacks in the same way as &lt;code&gt;POE::Session&lt;/code&gt;, wheels use local event names to provide functionality. Internally, they create wrappers around calls to these events which build the context necessary for a POE event to occur.&lt;/p&gt;

&lt;p&gt;Wheels are much more complex to create, for good reason. Wheels share their entire operating context with the user&amp;rsquo;s session but share very little of the niceties. Wheels do not have their own heap and cannot create aliases for themselves. In many ways, they are like a parasite clinging to the side of the user&amp;rsquo;s code. As long as they don&amp;rsquo;t get in the way and they provide a useful function, they are allowed to exist.&lt;/p&gt;

&lt;p&gt;The development overhead is made up for, however, by the loss of internal POE overhead. Sessions require a certain amount of maintenance to keep running. POE checks sessions to see if they still have work to do, if there are timers or alarms outstanding for them, if they should be garbage collected, etc etc. The more sessions that exist in a system, the more that overhead grows. This overhead is especially noticeable in time sensitive applications. Wheels have none of this overhead. They piggyback on top of the user&amp;rsquo;s session so, apart from any events they may trigger as part of their normal operation, there is no inherent internal POE overhead in using a wheel.&lt;/p&gt;

&lt;h3 id=&#34;span-id-filters-filters-span&#34;&gt;&lt;span id=&#34;FILTERS&#34;&gt;FILTERS&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Many wheels handle incoming and outgoing data. They exist to help the user get data from some strange source (say, HTTP) into a format the user can analyze or take apart in perlish ways. &lt;code&gt;POE::Wheel::SocketFactory&lt;/code&gt;, for instance, handles all the scariness of nonblocking socket creation and maintenance. For most of us, however, SocketFactory doesn&amp;rsquo;t go far enough. I don&amp;rsquo;t want to have to worry about pack calls or http headers or whatever other nonsense is necessary to take a transaction off the wire and make it palatable. Special modules in the &lt;code&gt;POE::Filter&lt;/code&gt; namespace handle this drudgery.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package POE::Filter::MyData;

    sub new {
        # ...
    }

    sub put {
        # ...
    }

    sub get {
        # ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Filters are very simple data parsing modules. Most POE filters are limited enough to be used outside of a POE environment. They know nothing of POE or of the running POE environment. The standard interface requires three methods: &lt;code&gt;new()&lt;/code&gt;, the constructor; &lt;code&gt;get()&lt;/code&gt;, the input parser; and &lt;code&gt;put()&lt;/code&gt; the output generator. &lt;code&gt;get()&lt;/code&gt; takes a stream of data and returns parsed records, which may be hashes, arrays, objects, or anything else one might desire. &lt;code&gt;put()&lt;/code&gt; takes user generated records and converts them to raw data.&lt;/p&gt;

&lt;h1 id=&#34;span-id-design-design-span&#34;&gt;&lt;span id=&#34;Design&#34;&gt;Design&lt;/span&gt;&lt;/h1&gt;

&lt;p&gt;With these four simple building blocks, POE applications can grow to meet almost any need while still being maintainable. The key is to break the application up into small chunks. This is beneficial for two main reasons: 1) the individual chunks are more easily understood by a new staff member or someone else looking at the code six months from now. 2) Smaller blocks of code spend less time &amp;hellip; well, blocking.&lt;/p&gt;

&lt;p&gt;As noted above, a POE application is a single-threaded process that pretends to perform asynchronous actions through a technique called cooperative multitasking. At any given time, only one subroutine inside a POE application is executing. If that one subroutine has a &lt;code&gt;sleep 60;&lt;/code&gt; inside of it, the entire application will sleep for 60 seconds. No alarms will be triggered; no actions will occur. Smaller blocks of code mean that POE gets a chance to do other actions like cleaning up sessions that are shutting down or executing another event.&lt;/p&gt;

&lt;p&gt;Even long-running for-loops can be broken down into small POE events.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    while(@data) {
        # ... process, process
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;can become&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $poe_kernel-&amp;gt;yield(&#39;process_data&#39; =&amp;gt; $_) for @data;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This gives POE time to read from sockets, do internal housekeeping, and so on,between each bit of processing time. If &lt;code&gt;@data&lt;/code&gt; is large enough, however, this method can lead to resource depletion - spewing out 5000 events to process &lt;code&gt;@data&lt;/code&gt; may get the job done and allow POE to do housekeeping, but it means that for the next 5000 event invocations, POE is doing nothing but processing that array.&lt;/p&gt;

&lt;p&gt;POE&amp;rsquo;s event queue is a FIFO (First In First Out). Events are processed in the order they are invoked. There are two major exceptions to this. Signals can trigger immediate event processing, and using &lt;code&gt;call()&lt;/code&gt; instead of &lt;code&gt;yield()&lt;/code&gt; or &lt;code&gt;post()&lt;/code&gt; will cause immediate event processing. Beyond those two exceptions, every event happens in order, all of the time.&lt;/p&gt;

&lt;p&gt;In the example above, we asked POE to push a large number of events on the queue. While POE can still read off whatever socket we&amp;rsquo;re getting data from inbetween those &lt;code&gt;yield&lt;/code&gt;s, the events triggered by that socket read will not be invoked until after we&amp;rsquo;re done processing our giant array. We can break that pattern out very easily.&lt;/p&gt;

&lt;p&gt;If we don&amp;rsquo;t need to process &lt;code&gt;@data&lt;/code&gt; in any timely fashion, we can stagger the processing out further:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $poe_kernel-&amp;gt;delay_add(&#39;process_data&#39; =&amp;gt; $hence++ =&amp;gt; $_) for @data;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will process one chunk of &lt;code&gt;@data&lt;/code&gt; every second. Not very efficient or timely but other events can take place between invocations. One second is by no means the smallest time value accepted by &lt;code&gt;delay_add()&lt;/code&gt;. Use of &lt;code&gt;Time::HiRes&lt;/code&gt; allows for microsecond delay values:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Time::HiRes;
    use POE;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The use of &lt;code&gt;Time::HiRes&lt;/code&gt; before importing &lt;code&gt;POE&lt;/code&gt; causes POE to use &lt;code&gt;Time::HiRes&lt;/code&gt;&amp;rsquo; &lt;code&gt;time()&lt;/code&gt; instead of perl&amp;rsquo;s built-in &lt;code&gt;time()&lt;/code&gt;. While &lt;code&gt;Time::HiRes&lt;/code&gt; has much greater resolution on time values, it may or may not be the most accurate time keeper on your particular platform. Do your homework and make the choice that best suits your situation and needs.&lt;/p&gt;

&lt;h1 id=&#34;span-id-conclusion-conclusion-span&#34;&gt;&lt;span id=&#34;Conclusion&#34;&gt;Conclusion&lt;/span&gt;&lt;/h1&gt;

&lt;p&gt;POE is a flexible application framework appropriate for long-running large-scale perl applications. It provides standard interfaces for task abstraction and forces the coder to think about their software in smaller, more maintainable chunks.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://metacpan.org/pod/POE&#34;&gt;POE is available on CPAN&lt;/a&gt; and has a rich, community-maintained website (&lt;a href=&#34;http://poe.perl.org&#34;&gt;http://poe.perl.org&lt;/a&gt;).&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

