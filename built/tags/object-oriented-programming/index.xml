<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Object Oriented Programming on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/object-oriented-programming/</link>
    <description>Recent content in Object Oriented Programming on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 18 Dec 2000 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/object-oriented-programming/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Beginners Intro to Perl - Part 5</title>
      <link>http://localhost:1313/pub/2000/12/begperl5.html/</link>
      <pubDate>Mon, 18 Dec 2000 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2000/12/begperl5.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this venerable series is undergoing updates. You might be interested in the newer versions, available at:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2008/04/23/a-beginners-introduction-to-perl-510.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Perl 5.10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2008/05/07/beginners-introduction-to-perl-510-part-2.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Files and Strings with Perl 5.10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://news.oreilly.com/2008/06/a-beginners-introduction-to-pe.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Regular Expressions with Perl 5.10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://broadcast.oreilly.com/2008/09/a-beginners-introduction-to-pe.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Perl Web Programming&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;strong&gt;Beginners Intro to Perl&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;•&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/10/begperl1.html&#34;&gt;Part 1 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
•&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/11/begperl2.html&#34;&gt;Part 2 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
•&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/11/begperl3.html&#34;&gt;Part 3 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
•&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/12/begperl4.html&#34;&gt;Part 4 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
•&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2001/01/begperl6.html&#34;&gt;Part 6 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;br /&gt;
•&lt;a href=&#34;#what%20is%20an%20object&#34;&gt;What Is an Object?&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#our%20goal&#34;&gt;Our Goal&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#starting%20off&#34;&gt;Starting Off&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#what%20does%20our%20object%20do&#34;&gt;What Does Our Object Do?&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#our%20goal,%20part%202&#34;&gt;Our Goal, Part 2&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#encapsulation&#34;&gt;Encapsulation&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#play%20around!&#34;&gt;Play Around!&lt;/a&gt;&lt;br /&gt;
&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;So far, we&amp;rsquo;ve mostly stuck to writing everything for our programs ourselves. One of the big advantages of Perl is that you don&amp;rsquo;t need to do this. More than 1,000 people worldwide have contributed more than 5,000 utility packages, or &lt;em&gt;modules&lt;/em&gt;, for common tasks.&lt;/p&gt;

&lt;p&gt;In this installment, we&amp;rsquo;ll learn how modules work by building one, and along the way we&amp;rsquo;ll learn a bit about &lt;em&gt;object-oriented programming&lt;/em&gt; in Perl.&lt;/p&gt;

&lt;h3 id=&#34;span-id-what-is-an-object-what-is-an-object-span&#34;&gt;&lt;span id=&#34;what is an object&#34;&gt;What Is an Object?&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Think back to the first article in this series, when we discussed the two basic data types in Perl, strings and numbers. There&amp;rsquo;s a third basic data type: the &lt;em&gt;object&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Objects are a convenient way of packaging information with the things you actually &lt;em&gt;do&lt;/em&gt; with that information. The information an object contains is called its &lt;em&gt;properties&lt;/em&gt;, and the things you can do with that information are called &lt;em&gt;methods&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;For example, you might have an &lt;code&gt;AddressEntry&lt;/code&gt; object for an address book program - this object would contain &lt;em&gt;properties&lt;/em&gt; that store a person&amp;rsquo;s name, mailing address, phone number and e-mail address; and &lt;em&gt;methods&lt;/em&gt; that print a nicely formatted mailing label or allow you to change the person&amp;rsquo;s phone number.&lt;/p&gt;

&lt;p&gt;During the course of this article, we&amp;rsquo;ll build a small, but useful, class: a container for configuration file information.&lt;/p&gt;

&lt;h3 id=&#34;span-id-our-goal-our-goal-span&#34;&gt;&lt;span id=&#34;our goal&#34;&gt;Our Goal&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;So far, we&amp;rsquo;ve put the code for setting various options in our programs directly in the program&amp;rsquo;s source code. This isn&amp;rsquo;t a good approach. You may want to install a program and allow multiple users to run it, each with their own preferences, or you may want to store common sets of options for later. What you need is a configuration file to store these options.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll use a simple plain-text format, where name and value pairs are grouped in sections, and sections are indicated by a header name in brackets. When we want to refer to the value of a specific key in our configuration file, we call the key &lt;code&gt;section.name&lt;/code&gt;. For instance, the value of &lt;em&gt;author.firstname&lt;/em&gt; in this simple file is ``Doug:&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   [author]
   firstname=Doug
   lastname=Sheppard

   [site]
   name=Perl.com
   url=http://www.perl.com/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(If you used Windows in the ancient days when versions had numbers, not years, you&amp;rsquo;ll recognize this as being similar to the format of INI files.)&lt;/p&gt;

&lt;p&gt;Now that we know the real-world purpose of our module, we need to think about what &lt;em&gt;properties&lt;/em&gt; and &lt;em&gt;methods&lt;/em&gt; it will have: What do &lt;code&gt;TutorialConfig&lt;/code&gt; objects store, and what can we do with them?&lt;/p&gt;

&lt;p&gt;The first part is simple: We want the object&amp;rsquo;s properties to be the values in our configuration file.&lt;/p&gt;

&lt;p&gt;The second part is a little more complex. Let&amp;rsquo;s start by doing the two things we &lt;em&gt;need&lt;/em&gt; to do: read a configuration file, and get a value from it. We&amp;rsquo;ll call these two methods &lt;code&gt;read&lt;/code&gt; and &lt;code&gt;get&lt;/code&gt;. Finally, we&amp;rsquo;ll add another method that will allow us to set or change a value from within our program, which we&amp;rsquo;ll call &lt;code&gt;set&lt;/code&gt;. These three methods will cover nearly everything we want to do.&lt;/p&gt;

&lt;h3 id=&#34;span-id-starting-off-starting-off-span&#34;&gt;&lt;span id=&#34;starting off&#34;&gt;Starting Off&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ll use the name &lt;code&gt;TutorialConfig&lt;/code&gt; for our configuration file class. (Class names are normally named in this InterCapitalized style.) Since Perl looks for a module by its filename, this means we&amp;rsquo;ll call our module file &lt;code&gt;TutorialConfig.pm&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Put the following into a file called &lt;code&gt;TutorialConfig.pm&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package TutorialConfig;

    warn &amp;quot;TutorialConfig is successfully loaded!\n&amp;quot;;
    1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(I&amp;rsquo;ll be sprinkling debugging statements throughout the code. You can take them out in practice. The &lt;code&gt;warn&lt;/code&gt; keyword is useful for warnings - things that you want to bring to the user&amp;rsquo;s attention without ending the program the way &lt;code&gt;die&lt;/code&gt; would.)&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;package&lt;/code&gt; keyword tells Perl the name of the class you&amp;rsquo;re defining. This is generally the same as the module name. (It doesn&amp;rsquo;t &lt;em&gt;have&lt;/em&gt; to be, but it&amp;rsquo;s a good idea!) The &lt;code&gt;1;&lt;/code&gt; will return a true value to Perl, which indicates that the module was loaded successfully.&lt;/p&gt;

&lt;p&gt;You now have a simple module called &lt;code&gt;TutorialConfig&lt;/code&gt;, which you can use in your code with the &lt;code&gt;use&lt;/code&gt; keyword. Put the following into a very simple, one-line program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use TutorialConfig;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we run this program, we see the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    TutorialConfig is successfully loaded!
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-what-does-our-object-do-what-does-our-object-do-span&#34;&gt;&lt;span id=&#34;what does our object do&#34;&gt;What Does Our Object Do?&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Before we can create an object, we need to know &lt;em&gt;how&lt;/em&gt; to create it. That means we must write a method called &lt;code&gt;new&lt;/code&gt; that will set up an object and return it to us. This is also where you put any special initialization code that you might need to run for each object when it is created.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;new&lt;/code&gt; method for our &lt;code&gt;TutorialConfig&lt;/code&gt; class looks like this, and goes into &lt;code&gt;TutorialConfig.pm&lt;/code&gt; right after the package declaration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub new {
        my ($class_name) = @_;

        my ($self) = {};
        warn &amp;quot;We just created our new variable...\n &amp;quot;;

        bless ($self, $class_name);
        warn &amp;quot;and now it&#39;s a $class_name object!\n&amp;quot;;

        $self-&amp;gt;{&#39;_created&#39;} = 1;
        return $self;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Again, you won&amp;rsquo;t need those &lt;code&gt;warn&lt;/code&gt; statements in actual practice.)&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s break this down line by line.&lt;/p&gt;

&lt;p&gt;First, notice that we define methods by using &lt;code&gt;sub&lt;/code&gt;. (All methods are really just a special sort of sub.) When we call &lt;code&gt;new&lt;/code&gt;, we pass it one parameter: the &lt;em&gt;type&lt;/em&gt; of object we want to create. We store this in a private variable called &lt;code&gt;$class_name&lt;/code&gt;. (You can also pass extra parameters to &lt;code&gt;new&lt;/code&gt; if you want. Some modules use this for special initialization routines.)&lt;/p&gt;

&lt;p&gt;Next, we tell Perl that &lt;code&gt;$self&lt;/code&gt; is a hash. The syntax &lt;code&gt;my ($self) = {};&lt;/code&gt; is a special idiom that&amp;rsquo;s used mostly in Perl object programming, and we&amp;rsquo;ll see how it works in some of our methods. (The technical term is that &lt;code&gt;$self&lt;/code&gt; is an &lt;em&gt;anonymous hash&lt;/em&gt;, if you want to read more about it elsewhere.)&lt;/p&gt;

&lt;p&gt;Third, we use the &lt;code&gt;bless&lt;/code&gt; function. You give this function two parameters: a variable that you want to make into an object, and the type of object you want it to be. This is the line that makes the magic happen!&lt;/p&gt;

&lt;p&gt;Fourth, we&amp;rsquo;ll set a &lt;em&gt;property&lt;/em&gt; called ``_created&amp;rdquo;. This property isn&amp;rsquo;t really that useful, but it does show the syntax for accessing the contents of an object: &lt;em&gt;$object_name-&amp;gt;{property_name}&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Finally, now that we&amp;rsquo;ve made &lt;code&gt;$self&lt;/code&gt; into a new &lt;code&gt;TutorialConfig&lt;/code&gt; object, we &lt;code&gt;return&lt;/code&gt; it.&lt;/p&gt;

&lt;p&gt;Our program to create a &lt;code&gt;TutorialConfig&lt;/code&gt; object looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use TutorialConfig;
    $tut = new TutorialConfig;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(You don&amp;rsquo;t need to use parentheses here, unless your object&amp;rsquo;s &lt;code&gt;new&lt;/code&gt; method takes any extra parameters. But if you feel more comfortable writing &lt;code&gt;$tut = new TutorialConfig();&lt;/code&gt;, it&amp;rsquo;ll work just as well.)&lt;/p&gt;

&lt;p&gt;When you run this code, you&amp;rsquo;ll see:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    TutorialConfig is successfully loaded!
    We just created the variable ...
    and now it&#39;s a TutorialConfig object!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have a class and we can create objects with it, let&amp;rsquo;s make our class &lt;em&gt;do&lt;/em&gt; something!&lt;/p&gt;

&lt;h3 id=&#34;span-id-our-goal-part-2-our-goal-part-2-span&#34;&gt;&lt;span id=&#34;our goal, part 2&#34;&gt;Our Goal, Part 2&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Look at our goals again. We need to write three methods for our &lt;code&gt;TutorialConfig&lt;/code&gt; module: &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The first method, &lt;code&gt;read&lt;/code&gt;, obviously requires that we tell it what file we want to read. Notice that when we write the source code for this method, we must give it &lt;em&gt;two&lt;/em&gt; parameters. The first parameter is the object we&amp;rsquo;re using, and the second is the filename we want to use. We&amp;rsquo;ll use &lt;code&gt;return&lt;/code&gt; to indicate whether the file was successfully read.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   sub read {
      my ($self, $file) = @_;
      my ($line, $section);

      open (CONFIGFILE, $file) or return 0;

      # We&#39;ll set a special property 
      # that tells what filename we just read.
      $self-&amp;gt;{&#39;_filename&#39;} = $file;



      while ($line = &amp;lt;CONFIGFILE&amp;gt;) {

         # Are we entering a new section?
         if ($line =~ /^\[(.*)\]/) {
            $section = $1;
         } elsif ($line =~ /^([^=]+)=(.*)/) {
            my ($config_name, $config_val) = ($1, $2);
            if ($section) {
               $self-&amp;gt;{&amp;quot;$section.$config_name&amp;quot;} = $config_val;
            } else {
               $self-&amp;gt;{$config_name} = $config_val;
            }
         }
      }

      close CONFIGFILE;
      return 1;
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we&amp;rsquo;ve read a configuration file, we need to look at the values we just read. We&amp;rsquo;ll call this method &lt;code&gt;get&lt;/code&gt;, and it doesn&amp;rsquo;t have to be complex:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub get {
        my ($self, $key) = @_;

        return $self-&amp;gt;{$key};
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These two methods are really all we need to begin experimenting with our &lt;code&gt;TutorialConfig&lt;/code&gt; object. Take the module and sample configuration file from above (or &lt;a href=&#34;http://localhost:1313/media/_pub_2000_12_begperl5/tutc.txt&#34;&gt;download the configuration file here&lt;/a&gt; and &lt;a href=&#34;http://localhost:1313/media/_pub_2000_12_begperl5/TutorialConfig.pm&#34;&gt;the module here&lt;/a&gt;), put it in a file called &lt;code&gt;tutc.txt&lt;/code&gt;, and then run &lt;a href=&#34;http://localhost:1313/media/_pub_2000_12_begperl5/sample.pl&#34;&gt;this simple program&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use TutorialConfig;

    $tut = new TutorialConfig;
    $tut-&amp;gt;read(&#39;tutc.txt&#39;) or die &amp;quot;Couldn&#39;t read config file: $!&amp;quot;;

    print &amp;quot;The author&#39;s first name is &amp;quot;, 
             $tut-&amp;gt;get(&#39;author.firstname&#39;), 
             &amp;quot;.\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Notice the syntax for calling an object&amp;rsquo;s methods: &lt;code&gt;$object-&amp;gt;method(parameters)&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;When you run this program, you&amp;rsquo;ll see something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    TutorialConfig has been successfully loaded!
    We just created the variable... 
    and now it&#39;s a TutorialConfig object!
    The author&#39;s first name is Doug.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now have an object that will read configuration files and show us values inside those files. This is good enough, but we&amp;rsquo;ve decided to make it better by writing a &lt;code&gt;set&lt;/code&gt; method that allows us to add or change configuration values from within our program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub set {
        my ($self, $key, $value) = @_;

        $self-&amp;gt;{$key} = $value;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s test it out:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use TutorialConfig;
    $tut = new TutorialConfig;

    $tut-&amp;gt;read(&#39;tutc.txt&#39;) or die &amp;quot;Can&#39;t read config file: $!&amp;quot;;
    $tut-&amp;gt;set(&#39;author.country&#39;, &#39;Canada&#39;);

    print $tut-&amp;gt;get(&#39;author.firstname&#39;), &amp;quot; lives in &amp;quot;,
          $tut-&amp;gt;get(&#39;author.country&#39;), &amp;quot;.\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These three methods (&lt;code&gt;read&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;) are everything we&amp;rsquo;ll need for our &lt;code&gt;TutorialConfig.pm&lt;/code&gt; module. More complex modules might have dozens of methods!&lt;/p&gt;

&lt;h3 id=&#34;span-id-encapsulation-encapsulation-span&#34;&gt;&lt;span id=&#34;encapsulation&#34;&gt;Encapsulation&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;You may be wondering why we have &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; methods at all. Why are we using &lt;code&gt;$tut-&amp;gt;set(&#39;author.country&#39;, &#39;Canada&#39;)&lt;/code&gt; when we could use &lt;code&gt;$tut-&amp;gt;{&#39;author.country&#39;} = &#39;Canada&#39;&lt;/code&gt; instead? There are two reasons to use methods instead of playing directly with an object&amp;rsquo;s properties.&lt;/p&gt;

&lt;p&gt;First, you can generally trust that a module won&amp;rsquo;t change its methods, no matter how much their implementation changes. Someday, we might want to switch from using text files to hold configuration information to using a database like MySQL or Postgres. Our new &lt;code&gt;TutorialConfig.pm&lt;/code&gt; module might have &lt;code&gt;new&lt;/code&gt;, &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; methods that look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      sub new {
          my ($class) = @_;
          my ($self) = {};
          bless $self, $class;
          return $self;
      }

      sub read {
          my ($self, $file) = @_;
          my ($db) = database_connect($file);
          if ($db) {
              $self-&amp;gt;{_db} = $db;
              return $db;
          }
          return 0;
      }

      sub get {
          my ($self, $key) = @_;
          my ($db) = $self-&amp;gt;{_db};

          my ($value) = database_lookup($db, $key);
          return $value;
      }

      sub set {
          my ($self, $key, $value) = @_;
          my ($db) = $self-&amp;gt;{_db};

          my ($status) = database_set($db, $key, $value);
          return $status;
      }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Our module would define the &lt;code&gt;database_connect&lt;/code&gt;, &lt;code&gt;database_lookup&lt;/code&gt; and &lt;code&gt;database_set&lt;/code&gt; routines elsewhere.)&lt;/p&gt;

&lt;p&gt;Even though the entire module&amp;rsquo;s source code has changed, all of our methods still have the same names and syntax. Code that uses these methods will continue working just fine, but code that directly manipulates properties will break!&lt;/p&gt;

&lt;p&gt;For instance, let&amp;rsquo;s say you have some code that contains this line to set a configuration value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     $tut-&amp;gt;{&#39;author.country&#39;} = &#39;Canada&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works fine with the original &lt;code&gt;TutorialConfig.pm&lt;/code&gt; module, because when you call &lt;code&gt;$tut-&amp;gt;get(&#39;author.country&#39;)&lt;/code&gt;, it looks in the object&amp;rsquo;s properties and returns ``Canada&amp;rdquo; just like you expected. So far, so good. However, when you upgrade to the new version that uses databases, the code will no longer return the correct result. Instead of &lt;code&gt;get()&lt;/code&gt; looking in the object&amp;rsquo;s properties, it&amp;rsquo;ll go to the database, which won&amp;rsquo;t contain the correct value for ``author.country&amp;rdquo;! If you&amp;rsquo;d used &lt;code&gt;$tut-&amp;gt;set(&#39;author.country&#39;, &#39;Canada&#39;)&lt;/code&gt; all along, things would work fine.&lt;/p&gt;

&lt;p&gt;As a module author, writing methods will let you make changes (bug fixes, enhancements, or even complete rewrites) without requiring your module&amp;rsquo;s users to rewrite any of their code.&lt;/p&gt;

&lt;p&gt;Second, using methods lets you avoid impossible values. You might have an object that takes a person&amp;rsquo;s age as a property. A person&amp;rsquo;s age must be a positive number (you can&amp;rsquo;t be -2 years old!), so the &lt;code&gt;age()&lt;/code&gt; method for this object will reject negative numbers. If you bypass the method and directly manipulate &lt;code&gt;$obj-&amp;gt;{&#39;age&#39;}&lt;/code&gt;, you may cause problems elsewhere in the code (a routine to calculate the person&amp;rsquo;s birth year, for example, might fail or produce an odd result).&lt;/p&gt;

&lt;p&gt;As a module author, you can use methods to help programmers who use your module write better software. You can write a good error-checking routine once, and it will be used many times.&lt;/p&gt;

&lt;p&gt;(Some languages, by the way, &lt;em&gt;enforce&lt;/em&gt; encapsulation, by giving you the ability to make certain properties private. Perl doesn&amp;rsquo;t do this. In Perl, encapsulation isn&amp;rsquo;t the law, it&amp;rsquo;s just a very good idea.)&lt;/p&gt;

&lt;h3 id=&#34;span-id-play-around-play-around-span&#34;&gt;&lt;span id=&#34;play around!&#34;&gt;Play Around!&lt;/span&gt;&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Our &lt;code&gt;TutorialConfig.pm&lt;/code&gt; module could use a method that will write a new configuration file to any filename you desire. Write your own &lt;code&gt;write()&lt;/code&gt; method (use &lt;code&gt;keys %$self&lt;/code&gt; to get the keys of the object&amp;rsquo;s properties). Be sure to use &lt;code&gt;or&lt;/code&gt; to warn if the file couldn&amp;rsquo;t be opened!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Write a &lt;code&gt;BankAccount.pm&lt;/code&gt; module. Your &lt;code&gt;BankAccount&lt;/code&gt; object should have &lt;code&gt;deposit&lt;/code&gt;, &lt;code&gt;withdraw&lt;/code&gt;, and &lt;code&gt;balance&lt;/code&gt; methods. Make the &lt;code&gt;withdraw&lt;/code&gt; method fail if you try to withdraw more money than you have, or deposit or withdraw a negative amount of money.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;CGI.pm&lt;/code&gt; also lets you use objects if you want. (Each object represents a single CGI query.) The method names are the same as the CGI functions we used in the last article:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use CGI;
$cgi = new CGI;

print $cgi-&amp;gt;header(), $cgi-&amp;gt;start_html();
print &amp;quot;The &#39;name&#39; parameter is &amp;quot;, $cgi-&amp;gt;param(&#39;name&#39;), &amp;quot;.\n&amp;quot;;
print $cgi-&amp;gt;end_html();
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Try rewriting one of your CGI programs to use &lt;code&gt;CGI&lt;/code&gt; objects instead of the CGI functions.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;A big advantage of using CGI objects is that you can store and retrieve queries on disk. Take a look in the &lt;code&gt;CGI.pm&lt;/code&gt; documentation to learn how to use the &lt;code&gt;save()&lt;/code&gt; method to store queries, and how to pass a filehandle to &lt;code&gt;new&lt;/code&gt; to read them from disk. Try writing a CGI program that saves recently used queries for easy retrieval.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2000_12_begperl5/TutorialConfig.pm&#34;&gt;Complete &lt;code&gt;TutorialConfig.pm&lt;/code&gt; module&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2000_12_begperl5/sample.pl&#34;&gt;Demo program&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2000_12_begperl5/tutc.txt&#34;&gt;Sample configuration file&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>

