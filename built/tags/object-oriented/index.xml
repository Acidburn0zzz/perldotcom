<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Object Oriented on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/object-oriented/</link>
    <description>Recent content in Object Oriented on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 07 Nov 2001 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/object-oriented/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Object-Oriented Perl</title>
      <link>http://localhost:1313/pub/2001/11/07/ooperl.html/</link>
      <pubDate>Wed, 07 Nov 2001 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2001/11/07/ooperl.html/</guid>
      <description>

&lt;p&gt;I&amp;rsquo;ve recently started learning to play the game of Go. Go and Perl have many things in common &amp;ndash; the basic stuff of which they are made, the rules of the game, are relatively simple, and hide an amazing complexity of possibilities beneath the surface. But I think the most interesting thing I&amp;rsquo;ve found that Go and Perl have in common is that there are various different stages in your development as you learn either one. It&amp;rsquo;s almost as if there are several different plateaus of experience, and you have to climb up a huge hill before getting onto the next plateau.&lt;/p&gt;

&lt;p&gt;For instance, a Go player can play very simply and acquit himself quite decently, but to stop being a beginner and really get into the game, he has to learn how to attack and defend economically. Then, to move on to the next stage, he has to master fighting a repetitive sequence called a &amp;ldquo;ko.&amp;rdquo; As I progress, I expect there to be other difficult strategies I need to master before I can become a better player.&lt;/p&gt;

&lt;p&gt;Perl, too, is not without its plateaus of knowledge, and in my experience, the one that really separates the beginner from the intermediate programmer is an understanding of object-oriented (OO) programming. Once you&amp;rsquo;ve understood how to use OO Perl, the door is opened to a huge range of interesting and useful CPAN modules, new programming techniques, and mastery of the upper plateaus of Perl programming.&lt;/p&gt;

&lt;h3 id=&#34;so-what-is-it&#34;&gt;So what is it?&lt;/h3&gt;

&lt;p&gt;Object-oriented programming is one of those buzzwordy manager-speak phrases, but unlike most of them, it actually means something. Let&amp;rsquo;s take a look at some perfectly ordinary procedural Perl code, bread and butter programming to most beginning programmers:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $request = accept_request($client);
my $answer = process_request($request);
answer_request($client, $answer);
$new_request = redirect_request($client, $request, $new_url);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The example here is of something like a Web server: we receive a request from a client, process it in some way to obtain an answer, and send the answer to the client. Additionally, we can also redirect the request to a different URL.&lt;/p&gt;

&lt;p&gt;The same code, written in an object-oriented style, would look a little different:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $request = $client-&amp;gt;accept();
$request-&amp;gt;process();
$client-&amp;gt;answer($request);
$new_request = $request-&amp;gt;redirect($new_url);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What&amp;rsquo;s going on here? What are these funny arrows? The thing to remember about object-oriented programming is that we&amp;rsquo;re no longer passing the data around to subroutines, to have subroutines do things for us &amp;ndash; now, we&amp;rsquo;re telling the data to do things for itself. You can think of the arrows, (&lt;code&gt;-&amp;gt;&lt;/code&gt;, formally the &amp;ldquo;method call operator&amp;rdquo;) as instructions to the data. In the first line, we&amp;rsquo;re telling the data that represents the client to accept a request and pass us something back.&lt;/p&gt;

&lt;p&gt;What is this &amp;ldquo;data that represents the client,&amp;rdquo; and what does it pass back? Well, if this is object-oriented programming, we can probably guess the answer: they&amp;rsquo;re both objects. They look like ordinary Perl scalars, right? Well, that&amp;rsquo;s just because objects really are like ordinary Perl scalars.&lt;/p&gt;

&lt;p&gt;The only difference between &lt;code&gt;$client&lt;/code&gt; and &lt;code&gt;$request&lt;/code&gt; in each example is that in the object-oriented version, the scalars happen to know where to find some subroutines that they can call. (In OO speak, we call them &amp;ldquo;methods&amp;rdquo; instead of &amp;ldquo;subroutines.&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;This is why we don&amp;rsquo;t have to say &lt;code&gt;process_request&lt;/code&gt; in the OO case: if we&amp;rsquo;re calling the &lt;code&gt;process&lt;/code&gt; method on something that knows it&amp;rsquo;s a request, it knows that it&amp;rsquo;s processing a request. Simple, eh? In OO speak, we say that the &lt;code&gt;$request&lt;/code&gt; object is in the Request &amp;ldquo;class&amp;rdquo; &amp;ndash; a class is the &amp;ldquo;type of thing&amp;rdquo; that the object is, and classes are how objects locate their methods. Hence, &lt;code&gt;$request-&amp;gt;redirect&lt;/code&gt; and &lt;code&gt;$mail-&amp;gt;redirect&lt;/code&gt; will call completely different methods if &lt;code&gt;$request&lt;/code&gt; and &lt;code&gt;$mail&lt;/code&gt; are in different classes; what it means to redirect a Request object is very different to redirecting a Mail object.&lt;/p&gt;

&lt;p&gt;You might wonder what&amp;rsquo;s actually going on when we call a method. Since we know that methods are just the OO form of subroutines, you shouldn&amp;rsquo;t be surprised to find that methods in Perl really are just subroutines. What about classes? Well, the purpose of a class is to distinguish one set of methods from another. And what&amp;rsquo;s a natural way to distinguish one set of subroutines from another in Perl? You guessed it &amp;ndash; in Perl, classes are just packages. So if we&amp;rsquo;ve got an object called &lt;code&gt;$request&lt;/code&gt; in the &lt;code&gt;Request&lt;/code&gt; class and we call the redirect method, this is what actually happens:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# $request-&amp;gt;redirect($new_url)

Request::redirect($request, $new_url)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s right &amp;ndash; we just call the &lt;code&gt;redirect&lt;/code&gt; subroutine in the appropriate package, and pass in the object along with any other parameters. Why do we pass in the object? So that &lt;code&gt;redirect&lt;/code&gt; knows what object it&amp;rsquo;s working on.&lt;/p&gt;

&lt;p&gt;At a very basic level, this is all OO Perl is &amp;ndash; it&amp;rsquo;s another syntax for writing subroutine calls so that it looks like you&amp;rsquo;re performing actions on some data. At that, for most users of OO Perl modules, is as much as you need to know.&lt;/p&gt;

&lt;h3 id=&#34;why-is-it-a-win&#34;&gt;Why is it a win?&lt;/h3&gt;

&lt;p&gt;So if that&amp;rsquo;s all it is, why does everyone think that OO Perl is the best thing since sliced bread? You&amp;rsquo;ll certainly find that a whole host of interesting and useful modules out there depend on OO techniques. To understand what everyone sees in it, let&amp;rsquo;s go back to procedural code for a moment. Here&amp;rsquo;s something that extracts the sender and subject of a mail message:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub mail_subject {
    my $mail = shift;
    my @lines = split /\n/, $mail;
    for (@lines) {
        return $1 if /^Subject: (.*)/;
        return if /^$/; # Blank line ends headers
    }
}
sub mail_sender {
    my $mail = shift;
    my @lines = split /\n/, $mail;
    for (@lines) {
        return $1 if /^From: (.*)/;
        return if /^$/;
    }
}

my $subject = mail_subject($mail);
my $from    = mail_sender($mail);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All well and good, but notice that we have to run through the whole mail each time we want to get new information about it. Now, it&amp;rsquo;s true we could replace the body of these two subroutines with quite a complicated regular expression, but that&amp;rsquo;s not the point: we&amp;rsquo;re still doing more work than we ought to.&lt;/p&gt;

&lt;p&gt;For our equivalent OO example, let&amp;rsquo;s use the CPAN module &lt;code&gt;Mail::Header&lt;/code&gt;. This takes a reference to an array of lines, and spits out a mail header object to which we can then do things.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my @lines = split /\n/, $mail;
my $header = Mail::Header-&amp;gt;new(\@lines);

my $subject = $header-&amp;gt;get(&amp;quot;subject&amp;quot;);
my $from    = $header-&amp;gt;get(&amp;quot;from&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not only are we now looking at the problem from a perspective of &amp;ldquo;doing things to the header&amp;rdquo;, we&amp;rsquo;re also giving the module an opportunity to make this more efficient. How come?&lt;/p&gt;

&lt;p&gt;One of the main benefits of CPAN modules is that they give us a set of functions we can call, and we don&amp;rsquo;t have to care how they&amp;rsquo;re implemented. OO programming calls this &amp;ldquo;abstraction&amp;rdquo; - the implementation is abstracted from the user&amp;rsquo;s perspective. Similarly, we don&amp;rsquo;t have to care what &lt;code&gt;$mail_obj&lt;/code&gt; really is. It could just be our reference to an array of lines, but on the other hand, &lt;code&gt;Mail::Header&lt;/code&gt; can do clever things with it.&lt;/p&gt;

&lt;p&gt;In reality, &lt;code&gt;$header&lt;/code&gt; is a hash reference under the hood. Again, we don&amp;rsquo;t need to care whether or not it&amp;rsquo;s a hash reference or an array reference or something altogether different, but as it&amp;rsquo;s a hash reference, this allows the constructor, &lt;code&gt;new&lt;/code&gt; (a constructor is just a method that creates a new object) to do all the pre-processing on our array of lines once and for all, and then store the subject, sender, and all sorts of other fields into some hash keys. All that &lt;code&gt;get&lt;/code&gt; does, essentially, is retrieve the appropriate value from the hash. This is obviously vastly more efficient than running through the whole message each time.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s what an object really is: it&amp;rsquo;s something that the module can rearrange and use any representation of your data that it likes so that it&amp;rsquo;s most efficient to operate on in the future. You, as an end user, get the benefits of a smart implementation (assuming, of course, that the person who wrote the module is smart&amp;hellip;) and you don&amp;rsquo;t need to care about, or even actually see, see what&amp;rsquo;s going on underneath.&lt;/p&gt;

&lt;h3 id=&#34;using-it&#34;&gt;Using it&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ve seen a simple use of OO techniques by using &lt;code&gt;Mail::Header&lt;/code&gt;. Let&amp;rsquo;s now look at a slightly more involved program, to solidify our knowledge. This is a very simple system information server for a Unix machine. (Don&amp;rsquo;t be put off &amp;ndash; these programs will work on non-Unix systems as well.) Unix has a client/server protocol called &amp;ldquo;finger,&amp;rdquo; by which you can contact a server and ask for information about its users. I run &amp;ldquo;finger&amp;rdquo; on my username at a local machine, and get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% finger simon
Login name: simon       (messages off)  In real life: Simon Cozens
Office: Computing S
Directory: /v0/xzdg/simon               Shell: /usr/local/bin/bash
On since Nov  6 10:03:46                5 minutes 38 seconds Idle Time
   on pts/166 from riot-act.somewhere
On since Nov  6 12:28:08
   on pts/197 from riot-act.somewhere
Project: Hacking Perl for Sugalski
Plan:

Insert amusing anecdote here.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What we&amp;rsquo;re going to do is write our own finger client and a server which dishes out information about the current system, and we&amp;rsquo;re going to do this using the object-oriented &lt;code&gt;IO::Socket&lt;/code&gt; module. Of course, we could do this completely procedurally, using &lt;code&gt;Socket.pm&lt;/code&gt;, but it&amp;rsquo;s actually comparatively much easier to do it this way.&lt;/p&gt;

&lt;p&gt;First, the client. The finger protocol, as much as we need to care about it, is really simple. The client connects and sends a line of text &amp;ndash; generally, a username. The server sends back some text, and then closes the connection.&lt;/p&gt;

&lt;p&gt;By using &lt;code&gt;IO::Socket&lt;/code&gt; to manage the connection, we can come up with something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/perl
use IO::Socket::INET;

my ($host, $username) = @ARGV;

my $socket = IO::Socket::INET-&amp;gt;new(
                        PeerAddr =&amp;gt; $host,
                        PeerPort =&amp;gt; &amp;quot;finger&amp;quot;
                      ) or die $!;

$socket-&amp;gt;print($username.&amp;quot;\n&amp;quot;);

while ($_ = $socket-&amp;gt;getline) {
    print;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is pretty straightforward: the &lt;code&gt;IO::Socket::INET&lt;/code&gt; constructor &lt;code&gt;new&lt;/code&gt; gives us an object representing the connection to peer address &lt;code&gt;$host&lt;/code&gt; on port &lt;code&gt;finger&lt;/code&gt;. We can then call the &lt;code&gt;print&lt;/code&gt; and &lt;code&gt;getline&lt;/code&gt; methods to send and receive data from the connection. Compare this with the non-OO equivalent, and you may realize why people prefer dealing with objects:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/perl -w
use strict;
use Socket;
my ($remote,$port, $iaddr, $paddr, $proto, $user);

($remote, $user) = @ARGV; 

$port    = getservbyname(&#39;finger&#39;, &#39;tcp&#39;)   || die &amp;quot;no port&amp;quot;;
$iaddr   = inet_aton($remote)               || die &amp;quot;no host: $remote&amp;quot;;
$paddr   = sockaddr_in($port, $iaddr);

$proto   = getprotobyname(&#39;tcp&#39;);
socket(SOCK, PF_INET, SOCK_STREAM, $proto)  || die &amp;quot;socket: $!&amp;quot;;
connect(SOCK, $paddr)                       || die &amp;quot;connect: $!&amp;quot;;
print SOCK &amp;quot;$user\n&amp;quot;;
while (&amp;lt;SOCK&amp;gt;)) {
   print;
}

close (SOCK)            || die &amp;quot;close: $!&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, to turn to the server. We&amp;rsquo;ll also use another OO module, &lt;code&gt;Net::hostent&lt;/code&gt;, which allows us to treat the result of &lt;code&gt;gethostbyaddr&lt;/code&gt; as an object, rather than as a list of values. This means we don&amp;rsquo;t have to worry about remembering which element of the list means what we want.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/perl -w
use IO::Socket;
use Net::hostent;

my $server = IO::Socket::INET-&amp;gt;new( Proto     =&amp;gt; &#39;tcp&#39;,
                                    LocalPort =&amp;gt; &#39;finger&#39;,
                                    Listen    =&amp;gt; SOMAXCONN,
                                    Reuse     =&amp;gt; 1);
die &amp;quot;can&#39;t setup server&amp;quot; unless $server;

while ($client = $server-&amp;gt;accept()) {
  $client-&amp;gt;autoflush(1);
  $hostinfo = gethostbyaddr($client-&amp;gt;peeraddr);
  printf &amp;quot;[Connect from %s]\n&amp;quot;, $hostinfo-&amp;gt;name || $client-&amp;gt;peerhost;
  my $command = client-&amp;gt;getline();
  if    ($command =~ /^uptime/) { $client-&amp;gt;print(`uptime`); }
  elsif ($command =~ /^date/)   { $client-&amp;gt;print(scalar localtime, &amp;quot;\n&amp;quot;); }
  else  { $client-&amp;gt;print(&amp;quot;Unknown command\n&amp;quot;);
  $client-&amp;gt;close;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is chock-full of OO Perl goodness &amp;ndash; a method call on nearly every line. We start in a very similar way to how we wrote the client: using &lt;code&gt;IO::Socket::INET-&amp;gt;new&lt;/code&gt; as a constructor. Did you notice anything strange about this? &lt;code&gt;IO::Socket::INET&lt;/code&gt; is a package name, which means it must be a class, rather than an object. But we can still call methods on classes (they&amp;rsquo;re generally called &amp;ldquo;class methods,&amp;rdquo; for obvious reasons) and this is how most objects actually get instantiated: the class provides a method called &lt;code&gt;new&lt;/code&gt; that produces an object for us to manipulate.&lt;/p&gt;

&lt;p&gt;The big &lt;code&gt;while&lt;/code&gt; loop calls the &lt;code&gt;accept&lt;/code&gt; method that waits until a client connects and, when one does, returns another &lt;code&gt;IO::Socket::INET&lt;/code&gt; object representing the connection to the client. We can call the client&amp;rsquo;s &lt;code&gt;autoflush&lt;/code&gt; method, which is the equivalent to setting &lt;code&gt;$|&lt;/code&gt; for its handle; the &lt;code&gt;peeraddr&lt;/code&gt; method returns the address of the client, which we can feed to &lt;code&gt;gethostbyaddr&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As we mentioned earlier, this isn&amp;rsquo;t the usual Perl &lt;code&gt;gethostbyadd&lt;/code&gt;, but one provided by &lt;code&gt;Net::Hostent&lt;/code&gt;, and it returns yet another object! We use the &lt;code&gt;name&lt;/code&gt; method from this object, which represents information about a given host, to find the host&amp;rsquo;s name.&lt;/p&gt;

&lt;p&gt;The rest isn&amp;rsquo;t anything new. If you think back to our client, it sent a line and awaited a response &amp;ndash; so our server has to read a line, and send a response. You get bonus points for adding more possible responses to our server.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;So there we are. We&amp;rsquo;ve seen a couple of examples of using object-oriented modules. It wasn&amp;rsquo;t that bad, was it? Hopefully now you&amp;rsquo;ll be well-enough equipped to be able to start using some of the many OO modules on CPAN for yourself.&lt;/p&gt;

&lt;p&gt;If, on the other hand, you feel you need a little more in-depth coverage of OO Perl, you could take a look at the &amp;ldquo;perlboot,&amp;rdquo; &amp;ldquo;perltoot,&amp;rdquo; and &amp;ldquo;perltootc&amp;rdquo; pages in the Perl documentation. &lt;em&gt;The Perl Cookbook&lt;/em&gt;, an invaluable book for any serious Perl programmer, has a very comprehensive and easy to follow treatment of OO techniques. Finally, the most in-depth treatment of all can be found in Damian Conway&amp;rsquo;s &amp;ldquo;Object-Oriented Perl&amp;rdquo;, which will see you through from a complete beginner way up to Perl 4 or 5 dan&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Damian Conway Talks Shop</title>
      <link>http://localhost:1313/pub/2000/08/conway.html/</link>
      <pubDate>Mon, 21 Aug 2000 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2000/08/conway.html/</guid>
      <description>&lt;p&gt;&lt;em&gt;Dr. Damian Conway is best known in the United States for authoring&lt;/em&gt; Object Oriented Perl&lt;em&gt;, published by Manning. His lectures at Perl conferences are becoming legendary and are a joy for Perl hackers of all levels. I managed to catch up with Dr. Conway just before his fall semester of lecturing at Monash University in Australia began.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Joe Johnston: Although you give a pretty decent account of your teaching career at &lt;a href=&#34;http://www.csse.monash.edu.au/~damian/bio.html&#34;&gt;http://www.csse.monash.edu.au/~damian/bio.html&lt;/a&gt;, could you state your day job for the record?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Damian Conway&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;Name: Conway, D. M.
Rank: Senior Lecturer, Computer Science, Monash University.
Serial number: 8371 466.
&lt;strong&gt;JJ: Fred Brook&amp;rsquo;s Mythical Man Month and No Silver Bullet are classic essays on the business and art of software engineering. The main point of the former is that application developers need to be managed more like commissioned artists, rather than as factory workers. The later work suggests that there will never be a design tool that significantly makes software development schedules more deterministic. Are these works still relevant and do you have your undergrads read either of these?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC:&lt;/strong&gt; I often recommend &amp;ldquo;MMM&amp;rdquo; to my software engineering students, but mainly for the real life horror stories it includes. They do a semester of SE and think they&amp;rsquo;re ready to build their own operating system. Brooks&amp;rsquo; tales from the trenches are a useful antidote.&lt;/p&gt;

&lt;p&gt;Both books &lt;em&gt;are&lt;/em&gt; still relevant, even though we&amp;rsquo;re now living in The Future. The situations and problems they describe may be now mainly historical, but the underlying issues are perennial.&lt;/p&gt;

&lt;p&gt;Programming is a Dark Art, and it will always be. The programmer is fighting against the two most destructive forces in the universe: entropy and human stupidity. They&amp;rsquo;re not things you can always overcome with a &amp;ldquo;methodology&amp;rdquo; or on a schedule.&lt;/p&gt;

&lt;p&gt;And when you look at it, we haven&amp;rsquo;t come that far in the quarter century since Brooks first published &amp;ldquo;MMM.&amp;rdquo; Sure we have more development tools and techniques, but most of them (and most programming languages too!) don&amp;rsquo;t really help. Especially not on large projects (i.e., anything over three or four developers).&lt;/p&gt;

&lt;p&gt;They&amp;rsquo;re designed to force the software team into someone else&amp;rsquo;s (usually academic) conception of how a program should be created. Generally they advocate ways of working that make &lt;em&gt;no&lt;/em&gt; allowance for the needs, motivations, and goals of the humans in the system. So Real Programmers don&amp;rsquo;t use them, and programming stays a handicraft &amp;ndash; a multi-trillion dollar cottage industry.&lt;/p&gt;

&lt;p&gt;Of course, it would be easy to fix that: make the software vendors liable for the correctness and reliability of their software and you&amp;rsquo;d see an instant revolution in development. There&amp;rsquo;s plenty of research and practical experience in building reliable systems using unreliable components (i.e., programmers). But as long a companies can turn a buck or two (billion) by shipping pre-beta quality software, why would they bother to find or mandate better ways?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JJ: There are those in the Open Source Community that point out that greed is not sufficient motivation to produce quality software, which is often the labor of love. How can Joe Programmer (not this Joe programmer) learn to love developing accounting applications?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC:&lt;/strong&gt; He or she &lt;em&gt;can&amp;rsquo;t&lt;/em&gt;. No more than you can make a COBOL programmer love hacking kernel. People sometimes offer me contracts writing DB interfaces or building websites, but I tell them I&amp;rsquo;m not worth what I&amp;rsquo;d charge to do that. Because I&amp;rsquo;d be doing it strictly for the (very large amount of) money, rather than for love of the project. They wouldn&amp;rsquo;t get my best.&lt;/p&gt;

&lt;p&gt;Whatever software your trying to build, you need people who are inspired by the &lt;em&gt;idea&lt;/em&gt; of that software. Even if they aren&amp;rsquo;t virtuoso hackers: you can always teach a person to code better, or tidy their code after it&amp;rsquo;s written; you can &lt;em&gt;never&lt;/em&gt; teach a person to love your project. And without that emotional engagement, you&amp;rsquo;ll never get the superhuman effort that&amp;rsquo;s required to produce quality software.&lt;/p&gt;

&lt;p&gt;It often seems to me that recruiters ask the wrong questions when interviewing programmers. Sure you have to find out if they know the difference between an argument and a parameter, but it&amp;rsquo;s vastly more important to discover what kind of enthusiasm and energy they&amp;rsquo;re going to bring to your project, why they&amp;rsquo;ll put in 18-hour days on it, why they&amp;rsquo;d pay &lt;em&gt;you&lt;/em&gt; to work on it. Find those people and you&amp;rsquo;ll get quality accounting software.&lt;/p&gt;

&lt;p&gt;And in a roundabout way, that&amp;rsquo;s why we need diversity in languages (and &lt;em&gt;within&lt;/em&gt; languages). So that there can be languages that fit a diversity of brains. So that every kind of geek can find his or her passion. Many of us love to diss COBOL and VB and Ada and PHP and Python, but we need to remember that, without those languages and the brave souls dedicated to &amp;ndash; and inspired by &amp;ndash; them, &lt;em&gt;we&lt;/em&gt; would have to write accounting software and bad GUIs and defence protocols and dull websites. In Perl. &lt;code&gt;:-(&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JJ: The world needs uncool software. Can we judge the hepness of an application by its quality?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC:&lt;/strong&gt; No. Because to some folks it &lt;em&gt;really is&lt;/em&gt; hip to be square. All you can tell about quality software is that someone thought it was important enough to care about, to invest themselves in. And people can feel that way about the oddest, unheppest things: model trains, mime, cloisonne eggs, folk dancing, even accounting applications.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JJ: At Perl Conference 4.0, the Best Technical Paper award was renamed the Damian Conway Award. I don&amp;rsquo;t even have a name on my office door. Will you be posing for the award statue?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC:&lt;/strong&gt; I&amp;rsquo;m only 5&amp;rsquo;6&amp;rdquo;. Put me on a block of marble and I could &lt;em&gt;be&lt;/em&gt; the award statue!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JJ: That won&amp;rsquo;t work. You wouldn&amp;rsquo;t stand still long enough to present the award.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC:&lt;/strong&gt; That could be the criterion: to win the award you have to keep up with it &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JJ: If a calendar of Perl Hunks were assembled, which month would you be?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC&lt;/strong&gt;: JJ: You &lt;em&gt;have&lt;/em&gt; to get off the drugs, Joe! And soon! A Perl Hunk calendar??? How sick is that?&lt;/p&gt;

&lt;p&gt;Oh, very well then: August.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JJ: This just in from the Perl section of Teen Beat, what tunes are on your CD/LP/MP3 player these days?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Five&amp;rdquo;, J.J.Cale&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Oxygene&amp;rdquo;, Jean-Michel Jarre&lt;/li&gt;
&lt;li&gt;&amp;rdquo;&amp;lsquo;Gladiator&amp;rsquo; soundtrack&amp;rdquo;, Zimmer &amp;amp; Gerrard&lt;/li&gt;
&lt;li&gt;&amp;rdquo;&amp;lsquo;Sense &amp;amp; Sensibility&amp;rsquo; soundtrack&amp;rdquo;, Carl Davis&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;JJ: Speaking of fluff, Paul Allen has been &lt;em&gt;real&lt;/em&gt; busy spending money these days. From seeding Transmeta to donating millions to the Search for ExtraTerrestrial Intelligence (SETI), Allen has been spreading his Microsoft millions liberally. What projects would you like to fund with your future trillions?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC:&lt;/strong&gt; C&amp;rsquo;mon! I&amp;rsquo;m a mad scientist/hacker from Australia. I &lt;em&gt;seriously&lt;/em&gt; doubt I will ever have major disposable income.&lt;/p&gt;

&lt;p&gt;But if I did, I&amp;rsquo;d be funding:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Nanotechnology. I &lt;em&gt;want&lt;/em&gt; microbots tending each blade of grass on my lawn and quitely rolling dust and dirt off my floors.&lt;/li&gt;
&lt;li&gt;Vacuum point energy research. I hate having to recharge lap-top batteries. Energy wants to be Free.&lt;/li&gt;
&lt;li&gt;Gerontology. We only get one go, and 100 years isn&amp;rsquo;t nearly long enough.&lt;/li&gt;
&lt;li&gt;Education. Better education reduces world misery in so many ways. It fights poverty, overpopulation, prejudice, and tyranny.&lt;/li&gt;
&lt;li&gt;People. I&amp;rsquo;d spend my time finding humanity&amp;rsquo;s best and most creative people, and just pay them to be them. Sure, you might not pick the right person 9 times out of 10. But what if the tenth were another Mary Shelley, or Frank Lloyd Wright, or Murasaki Shikibu, or Larry Wall?&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A Buddhist monastery. Peace is a renewable resource, but the world lacks enough processing capacity.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JJ: For the people that have read your book &amp;ldquo;Object Oriented Perl&amp;rdquo; or heard your conference lectures, your commitment to bring respectability to Perl&amp;rsquo;s OO model is well known. Oddly enough, you have seem to have other comp sci interests. What is &amp;ldquo;automation of hypermedia&amp;rdquo; and how does it apply to user interfaces?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC:&lt;/strong&gt; Anyone who has put together a large website knows how long and hard the process is. Anyone who has tried to use a large website knows how rarely the process is done well.&lt;/p&gt;

&lt;p&gt;For a time, I was developing tools to make it possible to generate navigable, comprehensible, usable websites with nothing more that vi. I developed a system that used text files for content, with very minimal mark-up, to generate full websites for various programming courses I was running. It would index all the material, cross-reference it, annotate it with exercises, hyperlink it back to glossaries and bibliographies, construct course syllabuses and outlines, etc., etc.&lt;/p&gt;

&lt;p&gt;And, of course, it was all done with a single, rambling, arcane, semi-sentient Perl program &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JJ: Have you used HTML::Template or HTML::Mason? Both allow Perl to be embedded in an otherwise static HTML page. This is sort of the server-side include method as used by ASP and Cold Fusion.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC&lt;/strong&gt;: I haven&amp;rsquo;t used them, but I&amp;rsquo;ve heard very good things about both modules.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JJ: More generally, is Perl ready for next generation web applications or are Perl tools not evolving fast enough for very large websites with large and diverse development teams?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC:&lt;/strong&gt; I&amp;rsquo;m not sure anyone or any tool is ready for the demands of mega-websites, anymore than existing software development approaches are ready for Programming In The Very Large. I don&amp;rsquo;t think we know how to reliably create huge linear programs that are safe, robust, and efficient. Add in the web&amp;rsquo;s demands for multimedia, hyperconnectivity, and interactivity, and I think our software technologies are at least a decade behind demand.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Some parent groups in the U.S. question whether computers are having a positive impact on children. They claim that video games are not meaningfully more interactive than Plain Old TV (POTV). Should any nation eschew raising teachers&amp;rsquo; salaries in favor of installing classroom computers? Are the Luddites right?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC:&lt;/strong&gt; Technology is not the enemy. &lt;em&gt;Deification&lt;/em&gt; of technology is the enemy.&lt;/p&gt;

&lt;p&gt;Any nation that favours a technological fix over funding good teaching is going to get what it deserves: neither a technological fix, nor good teaching.&lt;/p&gt;

&lt;p&gt;Western culture is increasing about magic bullets. We think a pill or a weekend course or a laying-on-of-hands is going to instantly solve our problem. As though we lived in a weekly sitcom with a 30-minute story arc.&lt;/p&gt;

&lt;p&gt;Putting computers in classrooms instead of teachers is doing just that: Latching on to a single &amp;ldquo;quick fix&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Of course, you do have to give the kids access to the technology. Not doing so nowadays is as criminal as not teaching them to read. But you still have to teach them to read, and think, and learn, as well!&lt;/p&gt;

&lt;p&gt;Put 30 kids in a room with an easel, a computer, and a guitar. You&amp;rsquo;ll get one Van Gogh, one Von Neumann, and one Van Halen (or Van Morrison). And 27 burger flippers. &lt;code&gt;:-(&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Every child has some great potential, but almost all of them need help to find it, and nurture it, and control it, and master it. They need a teacher, a guide, a role model. No machine is going to give them that. At least, not for a long time yet.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JJ: The big news at TPC 4.0 of course was Perl Episode 6, The Phantom Rewrite. What are three (or more) things you&amp;rsquo;d most like to see addressed in this reconstruction?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC:&lt;/strong&gt; Well, I have a list of 40 or so things I&amp;rsquo;m hoping to propose for Perl 6. The big ones include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Getting rid of the requirement for a final true value in &lt;code&gt;require&lt;/code&gt;&amp;rsquo;d files&lt;/li&gt;
&lt;li&gt;Finding a better name for &lt;code&gt;local&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Making == work more DWIMly on numeric operands strings&lt;/li&gt;
&lt;li&gt;New control structures: co-routines, switch statement, multiway comparisons&lt;/li&gt;
&lt;li&gt;Fixing the nested iteration behaviour of hashes&lt;/li&gt;
&lt;li&gt;Redesigning the format syntax and make it a subroutine in a pragma&lt;/li&gt;
&lt;li&gt;Subroutine parameter lists and extra context specifiers&lt;/li&gt;
&lt;li&gt;Numerous enhancements to OO Perl:

&lt;ul&gt;
&lt;li&gt;hierarchical construction and destruction&lt;/li&gt;
&lt;li&gt;built-in encapsulation of attributes&lt;/li&gt;
&lt;li&gt;extended, integrated operator overloading&lt;/li&gt;
&lt;li&gt;multimethods&lt;/li&gt;
&lt;li&gt;method redispatch&lt;/li&gt;
&lt;li&gt;method pre-conditions, post-conditions, and invariants (also for ordinary subroutines)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Regular expression matching against subroutines and filehandles&lt;/li&gt;
&lt;li&gt;Run-time access to source code parse tree, and simpler source filters&lt;/li&gt;
&lt;li&gt;Higher order functions&lt;/li&gt;
&lt;li&gt;Lazy evaluation of subroutine argument lists&lt;/li&gt;
&lt;li&gt;Extended context detection features&lt;/li&gt;
&lt;li&gt;Superpositions&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;JJ: What are the three scariest nightmares the corporate world has about Perl that prevent wider adoption of our favorite language?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC&lt;/strong&gt;: I don&amp;rsquo;t know very much about the corporate world, but I guess three common fears might be:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Perl is unclassifiable&lt;br /&gt;
COBOL is a banking language, Fortran is a numerical computation language, C is a systems programming language, Visual Basic is a GUI applications language, Java is a web programming language. What is Perl?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Perl is unmaintainable&lt;br /&gt;
Line noise programs, numerous defaults, subtle context propagation, symbolic references, closures, unconstrained OO model, one-liners, weird modules maintained by weirder hackers, typeglobs, AUTOLOADING, operator overloading, source filters, etc., etc.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Perl is unsupported&lt;br /&gt;
Yeah, I know, I know. But there&amp;rsquo;s no $599 MS-Perl with a GUI interface and an exorbitant support contract.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Perl Mongers are making valiant in-roads against those perceptions, but they can&amp;rsquo;t make Perl the static, commercial, boring tool that many managers are used to. And hence comfortable with.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll have to wait until the grunts who are actually using Perl in the trenches &amp;ndash; and holding entire organizations together with it &amp;ndash; get promoted into management. For them, Perl &lt;em&gt;will&lt;/em&gt; be the safe and familiar option.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JJ: You&amp;rsquo;re a big burly OO dude. Why aren&amp;rsquo;t you programming in Python?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC:&lt;/strong&gt; When you live in Australia, you learn to be wary of snakes.&lt;/p&gt;

&lt;p&gt;Seriously though, I don&amp;rsquo;t use Python because I&amp;rsquo;m not &lt;em&gt;just&lt;/em&gt; a big burly OO dude. I&amp;rsquo;m also a frightening functional dude, and a devious declarative dude, and an insidious imperative dude. In order to mess with people&amp;rsquo;s minds, I need to be able to mess with a programming language&amp;rsquo;s syntax and semantics: add a switch statement, change the dispatch model, superimpose scalars, lock down hash access, intercept error messages and convert them to haiku, impose design-by-contract constraints, or reconstruct the language in Latin or Klingon. Only Perl lets me push (fold, spindle, multilate) the envelope like that.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JJ: What&amp;rsquo;s your favorite part of your native country?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC:&lt;/strong&gt; The hilly spa country around Daylesford, Victoria. Rolling green hills, temperate climate, clean air, perfect.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JJ: The US &amp;ldquo;Dot.COMomy&amp;rdquo; has become colder than a bartender after closing time. Will those programmers who have only been in start-ups have a hard time adjusting to an economy in which they aren&amp;rsquo;t lusted after like jade idols?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC:&lt;/strong&gt; Good programmers will always be in demand &amp;ndash; there are so few of them around. And computers and the Internet are here to stay, even after the hype has died.&lt;/p&gt;

&lt;p&gt;Those refugees from Start-Ups are not going to see the same mania for their services, but they&amp;rsquo;ll still see good salaries and packages. What they&amp;rsquo;ll have trouble adjusting to is an economy where they&amp;rsquo;re expected to perform within the rules, keep office hours, wear shoes, write reports, cut code to spec rather than because it&amp;rsquo;s cool. That&amp;rsquo;s going to hurt. But the companies that survive will survive because they extract more value from their employees than those employees cost. In that sense, there is no &amp;ldquo;new&amp;rdquo; economy.&lt;/p&gt;

&lt;p&gt;The down side is that, in the future, you&amp;rsquo;ll have to be right on the end of the bell curve to offer your boss enough value to justify the cost of your bohemian behaviour.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JJ: If Perl were to disappear tomorrow, what would its legacy be?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC&lt;/strong&gt; That programing languages should be made to fit humans, not vice versa.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>

