<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Windows Automation on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/windows-automation/</link>
    <description>Recent content in Windows Automation on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 11 Aug 2005 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/windows-automation/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Automated GUI Testing</title>
      <link>http://localhost:1313/pub/2005/08/11/win32guitest.html/</link>
      <pubDate>Thu, 11 Aug 2005 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2005/08/11/win32guitest.html/</guid>
      <description>

&lt;p&gt;You use Perl at work. Sometimes you are unhappy because there is one application you always have to click on and fill all those input boxes. It&amp;rsquo;s very boring. Why not let Perl do that while you go grab a coffee? Also, maybe you sometimes feel frustrated that you need to start that nice app and want someone else type in for you. Let Perl do that, too.&lt;/p&gt;

&lt;h3 id=&#34;why-perl&#34;&gt;Why Perl?&lt;/h3&gt;

&lt;p&gt;Simply put: because you like Perl.&lt;/p&gt;

&lt;p&gt;The long story is that there are all sorts of software packages that you may use to automate graphical applications. Are they really good fits for what you want to do?&lt;/p&gt;

&lt;p&gt;Windows has many libraries that help you automate such things, but do the applications you use support those automation libraries? Too many do not. Moreover, is this enough for you to say you have tested a certain GUI feature? If not, read on.&lt;/p&gt;

&lt;h3 id=&#34;what-you-need&#34;&gt;What You Need&lt;/h3&gt;

&lt;p&gt;You need a working installation of Perl, with Perl/Tk included. I recommend &lt;a href=&#34;http://www.activestate.com/&#34;&gt;ActiveState&lt;/a&gt;&amp;rsquo;s ActivePerl. You also need the &lt;a href=&#34;https://metacpan.org/pod/Win32::GuiTest&#34;&gt;Win32::GuiTest&lt;/a&gt; module. Install it from the CPAN or, ideally, through PPM.&lt;/p&gt;

&lt;h3 id=&#34;example-code&#34;&gt;Example Code&lt;/h3&gt;

&lt;p&gt;Download the &lt;a href=&#34;http://localhost:1313/media/_pub_2005_08_11_win32guitest/tester.pl&#34;&gt;&lt;em&gt;tester.pl&lt;/em&gt;&lt;/a&gt; and the &lt;a href=&#34;http://localhost:1313/media/_pub_2005_08_11_win32guitest/tested.pl&#34;&gt;&lt;em&gt;tested.pl&lt;/em&gt;&lt;/a&gt; programs. They need to both be in the same directory. First run the &lt;em&gt;tested.pl&lt;/em&gt; program in order to see the windows it has and how it looks. The program does nothing by itself; it just serves as a &amp;ldquo;run&amp;rdquo; application. &lt;em&gt;tester.pl&lt;/em&gt; is more interesting. It spawns &lt;em&gt;tested.pl&lt;/em&gt; and starts sending it input (mouse moves, mouse clicks, and keystrokes).&lt;/p&gt;

&lt;p&gt;I tested these two programs on Windows 2000 Professional and Windows XP Home Edition using ActiveState&amp;rsquo;s distribution of Perl.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;tested.pl&lt;/em&gt; program is just a dummy GUI used to demonstrate the examples. It uses Tk, so although it is a Win32 GUI, it isn&amp;rsquo;t a native one. This has the effect that not all of the functions you can use with Win32::GuiTest will work as you would expect them to work against a native Win32 GUI. Fortunately, there are workarounds.&lt;/p&gt;

&lt;h3 id=&#34;a-few-words-about-windows&#34;&gt;A Few Words About Windows&lt;/h3&gt;

&lt;p&gt;Graphical user interfaces manage windows. Windows are just reusable objects with which users can interact. Almost all GUIs have more than just one window. I use &amp;ldquo;window&amp;rdquo; just as a generic term for any graphical object that an application may produce. This means that &amp;ldquo;window&amp;rdquo; is an abstract term after all.&lt;/p&gt;

&lt;p&gt;Windows have common elements that you need to consider before writing a program that interacts with a GUI.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Each window belongs to a window class (making it possible to search them by class).&lt;/li&gt;
&lt;li&gt;Windows have an organizational hierarchy; every GUI has at least one root window, and every window may have child windows. Windows form a tree. This makes them searchable (by class or not) in depth: start from a root window and search among its siblings.&lt;/li&gt;
&lt;li&gt;Some windows have text attached to them. This is useful to identify windows.&lt;/li&gt;
&lt;li&gt;Windows have an numeric ID that uniquely identifies them.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This means that you can identify windows by any of their text, class, and parent window attributes. You can also pinpoint a window by its ID.&lt;/p&gt;

&lt;h3 id=&#34;finding-windows&#34;&gt;Finding Windows&lt;/h3&gt;

&lt;p&gt;When testing a GUI, first make sure the application you want to test has started. To do this, use the Win32::GuiTest exported function named &lt;code&gt;FindWindowLike()&lt;/code&gt;. Remember that hierarchy of Windows? If you search for an &lt;em&gt;Edit&lt;/em&gt; window, you may find it in the wrong place. That There can be multiple different GUIs started that &lt;em&gt;have&lt;/em&gt; editor windows. There should be a way to differentiate between these hypothetical editor windows&amp;ndash;and the hierarchical organization of windows helps.&lt;/p&gt;

&lt;p&gt;First look for the main window of the application, and then descend the hierarchy (that you have to know beforehand) until you reach the desired window.&lt;/p&gt;

&lt;p&gt;How can you know the windows hierarchy? There are two main ways. If you have written the GUI yourself or have access to its sources and have enough experience, you may find out what the hierarchy of windows is. Unfortunately, that&amp;rsquo;s quite tricky and prone to error.&lt;/p&gt;

&lt;p&gt;Another much simpler way to do this on Windows platforms is to use the free &lt;a href=&#34;http://www.catch22.net/software/winspy.asp&#34;&gt;WinSpy++&lt;/a&gt; program. Basically, it allows you to &lt;a href=&#34;http://www.piotrkaluski.com/files/winguitest/docs/ch02.html&#34;&gt;peek at an application&amp;rsquo;s window structure&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;When you use WinSpy++ to look at an application windowing structure, you will notice that every window has a numeric handle, expressed in hex. However, Perl expresses in decimal. This will come up again in a moment.&lt;/p&gt;

&lt;p&gt;The syntax for &lt;code&gt;FindWindowLike&lt;/code&gt; is: &lt;code&gt;FindWindowLike($window,$titleregex,$classregex,$childid,   $maxlevel)&lt;/code&gt;. It returns a list of found windows. The parameters are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;$window&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This is the (numeric) handle of the parent window to search under (remember the hierarchical organization of windows in a GUI). You may use &lt;em&gt;undef&lt;/em&gt; in order to search for all windows.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;$window&lt;/em&gt; should be a decimal value, so if you know the window&amp;rsquo;s hex handle (as displayed by WinSpy++) you need to convert it.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;$titleregex&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This is the most often used parameter. It is a regular expression for &lt;code&gt;FindWindowLike&lt;/code&gt; to match against window titles to find the appropriate window(s).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;$classregex&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This matches against a window class. Suppose that you want to find all buttons in an application. Use the function like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my @windows = FindWindowLike(undef,&amp;quot;&amp;quot;,&amp;quot;Button&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Note:&lt;/code&gt; if you don&amp;rsquo;t care what the class of the window is, do not omit the &lt;code&gt;$classregex&lt;/code&gt; parameter. Instead, use an empty string.&lt;/p&gt;

&lt;p&gt;Currently the &lt;code&gt;FindWindowLike()&lt;/code&gt; function does not check if &lt;code&gt;$classregex&lt;/code&gt; is undefined, so you will end up with a lot of Perl warnings.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;$childid&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If you pass this argument, then the function will match all windows with this ID.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;$maxlevel&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Maximum depth level to match windows.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As you may have noticed, the &lt;code&gt;tested&lt;/code&gt; program has a title that matches the string &amp;ldquo;Tested&amp;rdquo;. Thus, the &lt;code&gt;tester&lt;/code&gt; starts by searching windows matching this title:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@windows = FindWindowLike( undef, &amp;quot;Tested&amp;quot;, &amp;quot;&amp;quot; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;@windows&lt;/em&gt; will contain a list of window IDs that have a title matching the string. The point here is that you probably don&amp;rsquo;t want the &lt;code&gt;tested&lt;/code&gt; program to start more than once simultaneously.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ( @windows &amp;gt; 1 ) {
     print &amp;quot;* The \&amp;quot;tested\&amp;quot; program is started more than once!\n&amp;quot;;
     ...
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If there is no &lt;code&gt;tested&lt;/code&gt; application already running, the program can start it and repeat the procedure, searching for windows that match our criteria (they contain the string &amp;ldquo;Tested&amp;rdquo; in their titles). If it&amp;rsquo;s running just once, its ID is &lt;code&gt;$windows[0]&lt;/code&gt;. In fact, this is the root window of the application.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s no point in going further with the program if the GUI hasn&amp;rsquo;t started, so the code checks this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unless ( @windows ) {
     print &amp;quot;* The program hasn&#39;t started!\n&amp;quot;;
     exit 1;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;setting-a-specific-window-to-foreground&#34;&gt;Setting a Specific Window to Foreground&lt;/h3&gt;

&lt;p&gt;Finding a window is sometimes not enough. Often, you need to send some input to the window. Obviously, the window should be in the foreground. The appropriate functions are &lt;code&gt;SetActiveWindow()&lt;/code&gt; and &lt;code&gt;SetForegroundWindow()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Because of the way windows work under Win32, this may be trickier than it seems. Basically, if the caller is not in the foreground, it can not give another window &amp;ldquo;focus.&amp;rdquo; MSDN explains this in the documentation of the &lt;a href=&#34;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/winui/windowsuserinterface/windowing/windows/windowreference/windowfunctions/setforegroundwindow.asp&#34;&gt;&lt;code&gt;SetForegroundWindow&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/winui/windowsuserinterface/userinput/keyboardinput/keyboardinputreference/keyboardinputfunctions/setactivewindow.asp&#34;&gt;&lt;code&gt;SetActiveWindow&lt;/code&gt;&lt;/a&gt; functions.&lt;/p&gt;

&lt;p&gt;While this behavior is easy to explain if you consider that you usually don&amp;rsquo;t want applications that run in background to be able to annoy you (at least) by grabbing focus, there is at least one drawback. If you are running a GUI (perhaps remotely) to which you will send sensitive input for some reason, you may send those secrets to another, possibly malicious, application if the tested application does not have focus!&lt;/p&gt;

&lt;p&gt;Another problem is in running tester programs remotely, or at regular intervals. Suppose that your tester program spawns the tested program, then starts sending it events (mouse events and/or keystrokes). If the computer is in a &amp;ldquo;locked&amp;rdquo; state, according to Microsoft documentation, no application can be in the foreground. You may have unexpected results.&lt;/p&gt;

&lt;p&gt;If the GUI you are automating receives sensitive input (such as passwords), you have to find a means to &amp;ldquo;isolate&amp;rdquo; that machine&amp;rsquo;s input/output devices, such as keyboard/mouse/monitor, so that no one unauthorized can peek at what your Perl program is typing in. Good luck.&lt;/p&gt;

&lt;p&gt;In my opinion, every time you send input to a GUI, the Win32::GuiTest program should check if the application is in the foreground. If it isn&amp;rsquo;t, it should try to bring it to the front. If it can&amp;rsquo;t do that, it should fail and not continue.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a sample routine that &lt;em&gt;tester.pl&lt;/em&gt; uses:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; sub bring_window_to_front {
     my $window  = shift;
     my $success = 1;

     if ( SetActiveWindow($window) ) {
         print &amp;quot;* Successfully set the window id: $window active\n&amp;quot;;
     }
     else {
         print &amp;quot;* Could not set the window id: $window active\n&amp;quot;;
         $success = 0;
     }
     if ( SetForegroundWindow($window) ) {
         print &amp;quot;* Window id: $window brought to foreground\n&amp;quot;;
     }
     else {
         print &amp;quot;* Window id: $window could not be brought to foreground\n&amp;quot;;
         $success = 0;
     }

     return $success;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In case you don&amp;rsquo;t want to bring a window to front but expect it to be in front, use &lt;code&gt;GetForegroundWindow()&lt;/code&gt;. That way, you can just check the return value with a window ID and find out if it is in front.&lt;/p&gt;

&lt;h3 id=&#34;key-pressing&#34;&gt;Key Pressing&lt;/h3&gt;

&lt;p&gt;You have found your window and have made sure that it has focus. What next?&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s time to send data to the window. This is the purpose of the &lt;code&gt;SendKeys()&lt;/code&gt; function. You can send to an application not only basic keypresses, but combinations of keys too. Here&amp;rsquo;s an example from the &lt;em&gt;tester.pl&lt;/em&gt; program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my @keys = ( &amp;quot;%{F}&amp;quot;, &amp;quot;{RIGHT}&amp;quot;, &amp;quot;E&amp;quot;, );
for my $key (@keys) {
    SendKeys( $key, $pause_between_keypress );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code starts with an array containing the keypresses. Note the format of the first three elements. The keypresses are: &lt;code&gt;Alt&lt;/code&gt;+&lt;code&gt;F&lt;/code&gt;, right arrow, and &lt;code&gt;E&lt;/code&gt;. With the application open, this navigates the menu in order to open the editor.&lt;/p&gt;

&lt;p&gt;For a full listing of &amp;ldquo;special&amp;rdquo; keystrokes or combinations of keys, consult the function&amp;rsquo;s documentation.&lt;/p&gt;

&lt;h3 id=&#34;finding-text-in-your-application&#34;&gt;Finding Text in Your Application&lt;/h3&gt;

&lt;p&gt;You may want to learn how you can &amp;ldquo;read&amp;rdquo; text written in GUI windows. Unfortunately, you can&amp;rsquo;t read everything. You &lt;em&gt;can&lt;/em&gt; read the text written in the title of windows (useful for identifying a window by its title). You can also read text in &lt;code&gt;Edit&lt;/code&gt; class windows; for example, the part of Internet Explorer where you type in a URL, or the list items in a &lt;code&gt;ListBox&lt;/code&gt;. There may be other window classes from where you can fetch text; just verify with WinSpy++ whether you can &amp;ldquo;read&amp;rdquo; from a window, before writing your program, in order to avoid frustration.&lt;/p&gt;

&lt;p&gt;Remember that you can&amp;rsquo;t (at least now) read everything written in a window. Maybe a future version of Win32::GuiTest will provide a means by which to fetch text from a window, no matter what class that window is. In my humble opinion, it would be an awesome feature.&lt;/p&gt;

&lt;p&gt;The two functions useful for grabbing text are &lt;code&gt;GetWindowText()&lt;/code&gt; and &lt;code&gt;WMGetText()&lt;/code&gt;. Both take as a parameter the window ID:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$text = GetWindowText($window);
$text = WMGetText($window);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;pushing-buttons&#34;&gt;Pushing Buttons&lt;/h3&gt;

&lt;p&gt;Pushing buttons can be tricky. The syntax is &lt;code&gt;PushButton($button[,$delay])&lt;/code&gt;, and the variable &lt;code&gt;$button&lt;/code&gt; can be either the text of the button (its caption) or the button ID. As Piotr Kaluski points out in &amp;ldquo;&lt;a href=&#34;http://www.piotrkaluski.com/files/automation/gui/carfl_pushcb.html&#34;&gt;Be Careful with &lt;code&gt;PushChildButton&lt;/code&gt;&lt;/a&gt;,&amp;rdquo; you sometimes want to specify a button ID, but instead the function matches a button having text like the one you used in the regexp. He posted &lt;a href=&#34;http://groups.yahoo.com/group/perlguitest/message/876?threaded=1&#34;&gt;a patch to the &lt;em&gt;perlguitest&lt;/em&gt; mailing list&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Also note that when using Tk, as I do in this example, you can&amp;rsquo;t identify buttons by their text&amp;ndash;you need to use their IDs (if you know them). With native Win32 applications, you can identify buttons by their text. To check the differences, use WinSpy++ to look at a Tk button&amp;rsquo;s caption and a native Win32 button&amp;rsquo;s caption.&lt;/p&gt;

&lt;p&gt;Although &lt;code&gt;PushButton()&lt;/code&gt; works fine on native Win32 buttons, I couldn&amp;rsquo;t make it work on my Tk application, so in &lt;em&gt;tester.pl&lt;/em&gt;, I use a trick in the &lt;code&gt;push_button()&lt;/code&gt; subroutine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub push_button {
    my $parent_window_title = shift;
    my @button;
    my @window;

    SendKeys(&amp;quot;%{F}&amp;quot;);
    SendKeys(&amp;quot;O&amp;quot;);
    sleep 1;

    @window = FindWindowLike( undef, $parent_window_title, &amp;quot;&amp;quot; );

    if ( !bring_window_to_front( $window[0] ) ) {
        print &amp;quot;* Could not bring to front $window[0]\n&amp;quot;;
    }

    @button = FindWindowLike( $window[0], &amp;quot;&amp;quot;, &amp;quot;Button&amp;quot; );
    sleep 1;

    print &amp;quot;* Trying to push button id: $button[0]\n&amp;quot;;
    PushChildButton( $window[0], $button[0], 0.25 );
    sleep 1;

    click_on_the_middle_of_window( $button[0] );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that the function depends on the &lt;em&gt;tested.pl&lt;/em&gt; application, as it has hard-coded the way to spawn the &lt;code&gt;Button&lt;/code&gt; window (by navigating the menu using keystrokes). It is easy to adapt it to be more flexible and to be less coupled with the rest of the code.&lt;/p&gt;

&lt;p&gt;After sending the right combination of keys (&lt;code&gt;Alt&lt;/code&gt;+&lt;code&gt;F&lt;/code&gt;, &lt;code&gt;O&lt;/code&gt;), the code expects that the window containing the &lt;code&gt;Button&lt;/code&gt; will pop up. Then it uses &lt;code&gt;FindWindowLike()&lt;/code&gt; again, using as a search item the title of the window containing the button (in this case, &lt;code&gt;here&lt;/code&gt;). Remember what I said about the windows hierarchy?&lt;/p&gt;

&lt;p&gt;Next, it ensures that the &lt;code&gt;Button&lt;/code&gt; window has the focus, although this is not entirely necessary at this point. After bringing the window to the front, the code searches for a button in the window (I already know that there&amp;rsquo;s only one button there).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@button = FindWindowLike( $window[0], &amp;quot;&amp;quot;, &amp;quot;Button&amp;quot; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This narrows down the search: &amp;ldquo;Search for a window of the class &lt;code&gt;Button&lt;/code&gt; under the window that has the ID &lt;code&gt;$window[0]&lt;/code&gt;,&amp;rdquo; the window having the ID in &lt;code&gt;$window[0]&lt;/code&gt; having been previously found by its title.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PushChildButton( $window[0], $button[0], 0.25 );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is here just for the power of example, as it doesn&amp;rsquo;t work for the Tk button. It would work for a native Win32 button.&lt;/p&gt;

&lt;p&gt;The trick is that the code can still push it using the mouse! Having the button ID, as returned by &lt;code&gt;FindWindowLike()&lt;/code&gt;, the code calls the &lt;code&gt;click_on_the_middle_of_window&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub click_on_the_middle_of_window {
    my $window = shift;

    print &amp;quot;* Moving the mouse over the window id: $window\n&amp;quot;;

    my ( $left, $top, $right, $bottom ) = GetWindowRect($window);

    MouseMoveAbsPix( ( $right + $left ) / 2, ( $top + $bottom ) / 2 );

    sleep(1);

    print &amp;quot;* Left Clicking on the window id: $window\n&amp;quot;;
    SendMouse(&amp;quot;{LeftClick}&amp;quot;);
    sleep(1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The function takes a window ID as its parameter, searches its rectangle using &lt;code&gt;GetWindowRect()&lt;/code&gt;, and then moves the mouse pointer right in the middle of it with &lt;code&gt;MouseMoveAbsPix()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;With the pointer over the button, sending &lt;code&gt;LeftClick&lt;/code&gt; presses the button.&lt;/p&gt;

&lt;h3 id=&#34;moving-around-with-the-mouse&#34;&gt;Moving Around with the Mouse&lt;/h3&gt;

&lt;p&gt;As seen earlier, moving the mouse is straightforward: just use &lt;code&gt;MouseMoveAbsPix()&lt;/code&gt;. It takes as parameters the coordinates where you want the pointer to be (horizontal and vertical positions) in pixels.&lt;/p&gt;

&lt;p&gt;It is useful to use other two functions in conjunction: &lt;code&gt;SendMouse()&lt;/code&gt; and &lt;code&gt;GetWindowRect()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SendMouse&lt;/code&gt; sends a mouse action to the &lt;code&gt;Desktop&lt;/code&gt;. It takes only one parameter: a mouse action such as &lt;code&gt;{LeftDown}&lt;/code&gt;, &lt;code&gt;{LeftUp}&lt;/code&gt;, or &lt;code&gt;{LeftClick}&lt;/code&gt;. For more details, see the function&amp;rsquo;s documentation.&lt;/p&gt;

&lt;p&gt;You can also move the mouse wheel using &lt;code&gt;MouseMoveWheel()&lt;/code&gt;. It takes a positive or a negative argument, indicating the direction of the motion.&lt;/p&gt;

&lt;p&gt;To send an action, you need to know where we send it. Usually you will move the mouse pointer over a window. &lt;code&gt;GetWindowRect()&lt;/code&gt; is useful to find the coordinates of a window.&lt;/p&gt;

&lt;p&gt;It can be simpler to create a wrapper around these three functions in order to move the mouse pointer over a selected window, and then generate a mouse action, as I did with &lt;code&gt;click_on_the_middle_of_window()&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;further-reading&#34;&gt;Further Reading&lt;/h3&gt;

&lt;p&gt;Here are some links you may find useful.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Win32::GuiTest&#34;&gt;Win32::GuiTest documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Win32::GuiTest::Examples&#34;&gt;Win32::GuiTest::Examples&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The &lt;a href=&#34;http://groups.yahoo.com/group/perlguitest/&#34;&gt;PerlGuiTest group&lt;/a&gt; on Yahoo; this is quite an active group.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.piotrkaluski.com/files/winguitest/docs/index.html&#34;&gt;Win32::GuiTest extended tutorial&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Automating Windows Applications with Win32::OLE</title>
      <link>http://localhost:1313/pub/2005/04/21/win32ole.html/</link>
      <pubDate>Thu, 21 Apr 2005 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2005/04/21/win32ole.html/</guid>
      <description>

&lt;h3 id=&#34;getting-my-feet-wet&#34;&gt;Getting My Feet Wet&lt;/h3&gt;

&lt;p&gt;My first glimpse of the Internet happened at Lotus Development somewhere around 1994. A Mosaic demonstration duly impressed me. A few months later, working at a small Cambridge, MA company called Dataware brought me closer to the online revolution.&lt;/p&gt;

&lt;p&gt;I landed a job at America Online in 1995 working for their browser team. They originally had their own browser, which they had purchased from CMGI. It was kind of cool at the time because it included a tabbed frames feature about eight years before the Gecko engine.&lt;/p&gt;

&lt;p&gt;It was there that Pete Deschanes wrote a tool using Microsoft Visual Test to automate the America Online embedded web browser. I was especially interested in certain functions he was using that captured browser events.&lt;/p&gt;

&lt;p&gt;Later, I moved on to a company in Chelmsford, MA that was using OLE Automation to drive the translation of Microsoft Word Documents into Fax documents. Rob Murtha explained a lot to me about OLE Automation and introduced me to Perl and Java.&lt;/p&gt;

&lt;h3 id=&#34;washed-up&#34;&gt;Washed Up&lt;/h3&gt;

&lt;p&gt;The internet bubble burst for me in 2002 and I wound up stranded on the shores of Fidelity Investments as a manual tester for one of their many investment Web page groups. After a few weeks of manual testing, I was ready to automate several of my tasks.&lt;/p&gt;

&lt;p&gt;There was a problem. There were plenty of available Winrunner licenses, but I was not allowed to use them because I was not part of their automation group. In fact, I was reprimanded and almost lost my job for being too persistent in asking to use one. Then I decided to write my own automation tool.&lt;/p&gt;

&lt;p&gt;I had experience with C, C++, Java, and Perl. I decided to start with a scripting language just to get a prototype going. I also thought it would be cool to have a real open source script language to write code with instead of something that a few engineers had developed exclusively for Web automation.&lt;/p&gt;

&lt;p&gt;My process consisted of:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ask a question.&lt;/li&gt;
&lt;li&gt;Do some research.&lt;/li&gt;
&lt;li&gt;Write some code.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h3&gt;

&lt;p&gt;The first thing I needed to do was to see if I could start &lt;code&gt;IExplore.exe&lt;/code&gt; from Perl. I knew I did not want to simply start the process with &lt;code&gt;system(&amp;quot;C:\\Program Files\\Internet Explorer\\IExplore.exe&amp;quot;);&lt;/code&gt;. Yes, I could get IE up and running that way, but I would not be able to do anything useful with it except to kill it.&lt;/p&gt;

&lt;p&gt;I noticed that Active Perl contained an interesting module called &lt;a href=&#34;https://metacpan.org/pod/Win32::OLE&#34;&gt;Win32::OLE&lt;/a&gt;. I opened the &lt;em&gt;OLE.pm&lt;/em&gt; file and began to read the comments.&lt;/p&gt;

&lt;p&gt;Comments like this looked very promising:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This module provides an interface to OLE Automation from Perl. OLE Automation brings VisualBasic-like scripting capabilities and offers powerful extensibility and the ability to control many Win32 applications from Perl scripts.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This one also looked pretty good:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;MessageLoop()&lt;/code&gt; class method will run a standard Windows message loop, dispatching messages until the &lt;code&gt;QuitMessageLoop()&lt;/code&gt; class method is called. It is used to wait for OLE events.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Keeping in mind that faith is the substance of things hoped for and the evidence of things not seen, I set about to write a Simple Automation Module for Internet Explorer using Active Perl&amp;rsquo;s &lt;code&gt;Win32::OLE&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Going back to the &lt;code&gt;Win32::OLE&lt;/code&gt; documentation I found out how to start IE through the COM object. I translated some examples for Excel and Word and wound up with this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$IE = Win32::OLE-&amp;gt;new(&amp;quot;InternetExplorer.Application&amp;quot;)
    || die &amp;quot;Could not start Internet Explorer.Application\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That was nice, but nothing appeared on my computer screen. I could hear the hard drive making a sound like it was starting an application but I couldn&amp;rsquo;t see Internet Explorer. I decided to Google for some examples. The information out there was very sparse but I found something that set the visible attribute to 1:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$IE-&amp;gt;{visible} = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This time Internet Explorer appeared with a blank screen. It was a start. I figured that there were a bunch of IE processes that I could not see on my machine from my previous efforts, so I killed those using the task manager.&lt;/p&gt;

&lt;p&gt;Next, I started a free Microsoft tool called &lt;code&gt;OLEVIEW.exe&lt;/code&gt;. This gave me a tree view of all automation objects registered on my machine. There were hundreds of them. I found the one called Internet Explorer (Ver. 1.0) and expanded the tree looking for methods. &lt;code&gt;IWebBrowser2&lt;/code&gt; looked interesting so I clicked on that and selected the View Type Info button. Out popped up a new window with a list of methods. This was looking better all the time.&lt;/p&gt;

&lt;p&gt;I clicked on a method called &lt;code&gt;Navigate&lt;/code&gt; and saw:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[id(0x00000068), helpstring(&amp;quot;Navigates to a URL or file.&amp;quot;)].
void Navigate(
    [in] BSTR URL,
    [in, optional] VARIANT* Flags,
    [in, optional] VARIANT* TargetFrameName,
    [in, optional] VARIANT* PostData,
    [in, optional] VARIANT* Headers);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I decided to try it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$IE-&amp;gt;Navigate(&amp;quot;http://www.google.com&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I had navigated to my first website with my new automation tool.&lt;/p&gt;

&lt;h3 id=&#34;on-the-road&#34;&gt;On the Road&lt;/h3&gt;

&lt;p&gt;I knew I was getting close to hitting the wall. I had seen through Google and newsgroups that lots of folks had reached this point in the game and turned around. Remembering back to Pete Deschanes&amp;rsquo; Visual Test Tool, I was certain that I could make more progress if I could capture Internet Explorer&amp;rsquo;s events. I went back to the &lt;em&gt;OLE.pm&lt;/em&gt; documentation to do a little more reading about events.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;=item Win32::OLE-&amp;gt;WithEvents(OBJECT[, HANDLER[, INTERFACE]])

This class method enables and disables the firing of events by
the specified OBJECT.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If I could just grok what &lt;code&gt;OBJECT&lt;/code&gt;, &lt;code&gt;HANDLER&lt;/code&gt;, and &lt;code&gt;INTERFACE&lt;/code&gt; represented, I felt that I could get my events. I made some guesses.&lt;/p&gt;

&lt;p&gt;The Object: that would be what &lt;code&gt;Win32::OLE-&amp;gt;new()&lt;/code&gt; returned. Everyone knows you instantiate an object with the &lt;code&gt;new&lt;/code&gt; operator.&lt;/p&gt;

&lt;p&gt;The Handler: I read further through &lt;em&gt;OLE.pm&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The HANDLER argument to &lt;code&gt;Win32::OLE-&amp;gt;WithEvents()&lt;/code&gt; can either be a CODE reference or a package name. In the first case, all events will invoke this particular function. The first two arguments to this function will be the OBJECT itself and the name of the event. The remaining arguments will be event-specific.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Win32::OLE-&amp;gt;WithEvents($Obj, \&amp;amp;Event);
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now I understood that &lt;code&gt;WithEvents&lt;/code&gt; was going to tell Internet Explorer to call my Perl Handler whenever IE fired an event. I had to give the &lt;code&gt;WithEvents&lt;/code&gt; call a reference to my subroutine like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\&amp;amp;Event
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What was the Interface name going to be? I went back to OLEVIEWER and looked through the interface folder. It looked like &lt;code&gt;DwebBrowserEvents2&lt;/code&gt; would deliver what I wanted.&lt;/p&gt;

&lt;p&gt;This is what I came up with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Win32::OLE-&amp;gt;WithEvents($IE,\&amp;amp;Event,&amp;quot;DWebBrowserEvents2&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now all I needed was to write an Event subroutine for IE to call. The &lt;em&gt;OLE.pm&lt;/em&gt; comments told me that &amp;ldquo;the first two arguments to this function will be the OBJECT itself and the name of the event&amp;rdquo;, so I just used the document example.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub Event {
    my ($Obj,$Event,@Args) = @_;
    print &amp;quot;Event triggered: &#39;$Event&#39;\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I noticed that there was a third argument called &lt;code&gt;@Args&lt;/code&gt; and assumed that this was there to catch all other unknown parameters for each event.&lt;/p&gt;

&lt;p&gt;How was I going to block my code to wait for the events to transpire? I returned to the &lt;em&gt;Win32::OLE&lt;/em&gt; comments:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;MessageLoop()&lt;/code&gt; class method will run a standard Windows message loop, dispatching messages until the &lt;code&gt;QuitMessageLoop()&lt;/code&gt; class method is called. It is used to wait for OLE events.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I added this code, just to see if I could capture IE events:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Win32::OLE-&amp;gt;MessageLoop();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;i-ve-been-to-the-mountain-top&#34;&gt;I&amp;rsquo;ve Been to the Mountain Top&lt;/h3&gt;

&lt;p&gt;It was quite a moment when I saw these events pouring out of my nine lines of code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Event triggered: CommandStateChange
Event triggered: OnVisible
Event triggered: PropertyChange
Event triggered: BeforeNavigate2
Event triggered: DownloadBegin
Event triggered: StatusTextChange
Event triggered: ProgressChange
Event triggered: FileDownload
Event triggered: DownloadComplete
Event triggered: TitleChange
Event triggered: NavigateComplete2
Event triggered: OnQuit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Internet Explorer was firing off events and its COM object was calling my Perl Event subroutine.&lt;/p&gt;

&lt;p&gt;From here, I kept searching the newsgroups. I found one sentence where someone mentioned acquiring the DOM from the &lt;code&gt;DocumentComplete&lt;/code&gt; Event. I knew this was a key, but how could I take this reference using Perl?&lt;/p&gt;

&lt;p&gt;I read up about the DOM. I borrowed a book from someone at work. &lt;a href=&#34;http://msdn.microsoft.com/workshop/author/dhtml/reference/dhtml_reference_entry.asp&#34;&gt;Microsoft has their own version&lt;/a&gt; of the DOM called DHTML and I came across their Web page. After reading this documentation for a while, I saw that the DOM could give me everything I needed to have a full-blown automation tool. All I needed was the reference.&lt;/p&gt;

&lt;h3 id=&#34;finding-the-dom&#34;&gt;Finding the DOM&lt;/h3&gt;

&lt;p&gt;I broke up my Event subroutine into pieces. I wanted to do something different for each triggered event. Specifically I wanted to try to take a reference to the DOM when the &lt;code&gt;DocumentComplete&lt;/code&gt; event triggered. My idea was that if I shifted out the first element of the @Args array, I would find the reference I was looking for. I rewrote the Event subroutine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub Event {
    my ($Obj,$Event,@Args) = @_;
    print &amp;quot; Event triggered: $Event\n&amp;quot;;
    if ($Event eq &amp;quot;DocumentComplete&amp;quot;) {
        $IEObject = shift @Args;
        print &amp;quot;Here is my reference: $IEObject\n&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This printed out:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Here is the Event: DocumentComplete
Here is my reference: Win32::OLE=HASH(0x1a524fc)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This was looking better all the time.&lt;/p&gt;

&lt;p&gt;I had a reference, but was it to the DHTML on the page that had just loaded? There was only one way to find out: could I use it to make a DHTML call? I looked on the Microsoft DHTML reference page for a property that would tell me I had a reference. &lt;code&gt;URL&lt;/code&gt; looked like a good one, so I tried this code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print &amp;quot;URL: &amp;quot; . $IEObject-&amp;gt;URL . &amp;quot;\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That gave me nothing. I went back to the OLEVIEWER and found this interesting method&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[id(0x000000cb), propget, helpstring(&amp;quot;Returns the active 
   Document automation object, if any.&amp;quot;)]
IDispatch* Document();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Active document sounded good, so I tried:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print &amp;quot;URL: &amp;quot; . $IEObject-&amp;gt;Document-&amp;gt;URL . &amp;quot;\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This gave me:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;URL: http://www.google.com/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Golden! My next step was to find a way to break out of the &lt;code&gt;MessageLoop()&lt;/code&gt; I was in.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Win32::OLE-&amp;gt;QuitMessageLoop();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;going-on-home&#34;&gt;Going On Home&lt;/h3&gt;

&lt;p&gt;My last step was to do something more useful with my reference to the DHTML. It was time to write a subroutine that would enter text into an edit box. That would seal my proof of concept.&lt;/p&gt;

&lt;p&gt;Other automation tools need you to make a GUI map (Mercury Winrunner) or an include file (Segue Silk) of every page you view before running the automation. I wanted something that would just look through the code that was already on the page and pick out a control on the fly using the power of regular expressions.&lt;/p&gt;

&lt;p&gt;I found all of the methods and properties in the following example in the &lt;a href=&#34;http://msdn.microsoft.com/workshop/author/dhtml/reference/dhtml_reference_entry.asp&#34;&gt;Microsoft DHTML API documentation&lt;/a&gt;. First I needed a name for my subroutine. &lt;code&gt;SetEditBox&lt;/code&gt; seemed easy to understand.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub SetEditBox {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next I need to pass in two parameters. The first would be the name of the control and the second would set the text.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub SetEditBox {
    my ($name,$value) = @_;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I had to start with the document object from my reference to the DOM:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub SetEditBox {
    my ($name,$value) = @_;
    $IEDocument = $IEObject-&amp;gt;{Document};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To save time iterating, I made the assumption that edit boxes would only appear inside forms. I used the collection called &lt;code&gt;forms&lt;/code&gt; to return all forms on the page.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$forms = $IEDocument-&amp;gt;forms;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now it was time to iterate.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for ($i = 0; $i &amp;lt; $forms-&amp;gt;length; $i++) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First I needed each item in the form collection.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$form = $forms-&amp;gt;item($i);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Inside this iteration I wanted to find a specific element of the form with the name of the edit box.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (defined($form-&amp;gt;elements($name))) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Inside this if statement I wanted to set the value of the edit box to the value passed into the subroutine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$form-&amp;gt;elements($name)-&amp;gt;{value} = $value;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then it was time to get out of Dodge so I wouldn&amp;rsquo;t waste time continuing the iteration.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is the final initial subroutine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub SetEditBox {
    my ($name, $value) = @_;
    my $IEDocument     = $IEObject-&amp;gt;{Document};
    my $forms          = $IEDocument-&amp;gt;forms;

    for (my $i = 0; $i &amp;lt; $forms-&amp;gt;length; $i++) {
        my $form       = $forms-&amp;gt;item($i);
        if (defined($form-&amp;gt;elements($name))) {
           $form-&amp;gt;elements($name)-&amp;gt;{value} = $value;
        }
        return;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is something very similar to the first original proof of concept version of &lt;a href=&#34;http://samie.sourceforge.net&#34;&gt;SAMIE&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Win32::OLE qw(EVENTS);
my $URL = &amp;quot;http://samie.sf.net/simpleform.html&amp;quot;;
my $IE  = Win32::OLE-&amp;gt;new(&amp;quot;InternetExplorer.Application&amp;quot;)
    || die &amp;quot;Could not start Internet Explorer.Application\n&amp;quot;;
Win32::OLE-&amp;gt;WithEvents($IE,\&amp;amp;Event,&amp;quot;DWebBrowserEvents2&amp;quot;);

$IE-&amp;gt;{visible} = 1;

$IE-&amp;gt;Navigate($URL);

Win32::OLE-&amp;gt;MessageLoop();
SetEditBox(&amp;quot;name&amp;quot;,&amp;quot;samie&amp;quot;);

sub Event {
    my ($Obj,$Event,@Args) = @_;
    print &amp;quot;Here is the Event: $Event\n&amp;quot;;
    if ($Event eq &amp;quot;DocumentComplete&amp;quot;) {
        $IEObject = shift @Args;
        print &amp;quot;Here is my reference: $IEObject\n&amp;quot;;
        print &amp;quot;URL: &amp;quot; .  $IEObject-&amp;gt;Document-&amp;gt;URL . &amp;quot;\n&amp;quot;;
            Win32::OLE-&amp;gt;QuitMessageLoop();
    }
}

sub SetEditBox {
    my ($name, $value) = @_;
    my $IEDocument     = $IEObject-&amp;gt;{Document};
    my $forms          = $IEDocument-&amp;gt;forms;

    for (my $i = 0; $i &amp;lt; $forms-&amp;gt;length; $i++) {
        my $form       = $forms-&amp;gt;item($i);
        if (defined($form-&amp;gt;elements($name))) {
           $form-&amp;gt;elements($name)-&amp;gt;{value} = $value;
        }
        return;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It made me laugh and tip my hat to Larry Wall, to think that I had the basic proof of concept of a $3,000 dollar per seat automation tool with about thirty lines of Perl. See more at the &lt;a href=&#34;http://samie.sourceforge.net/&#34;&gt;SAMIE home page&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Automating Windows (DNS) with Perl</title>
      <link>http://localhost:1313/pub/2005/03/24/perl_dns.html/</link>
      <pubDate>Thu, 24 Mar 2005 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2005/03/24/perl_dns.html/</guid>
      <description>

&lt;h3 id=&#34;driving-windows-dns-server&#34;&gt;Driving Windows DNS Server&lt;/h3&gt;

&lt;p&gt;If you happen to manage a DNS server running on Windows 2000 or Windows 2003 with more than just a couple of dozen resource records on it, you&amp;rsquo;ve probably already hit the limits of the MMC DNS plugin, the Windows administrative GUI for the DNS server implementation. Doing mass operations like creating 20 new records at once, moving a bunch of A records from one zone to another, or just searching for the next free IP in a reverse zone, can challenge your patience. To change the name part of an A record, you have to delete the entire record and re-create it from scratch using the new name. You&amp;rsquo;ve probably thought to yourself, &amp;ldquo;There MUST be another way to do this.&amp;rdquo; There is!&lt;/p&gt;

&lt;p&gt;Silently, almost shyly, behind the scenes and without the usual bells and whistles, Microsoft has arrived at the &lt;a href=&#34;http://www.pragmaticprogrammer.com/ppbook/extracts/rule_list.html&#34;&gt;power of the command shell&lt;/a&gt;. For the DNS services[1], the command line utility &lt;code&gt;dnscmd&lt;/code&gt; is available as part of the AdminPac for the server operating systems. &lt;code&gt;dnscmd&lt;/code&gt; is a very solid command line utility, with lots of options and subcommands, that allows you to do almost every possible operation on your DNS server. These include starting and stopping the server, adding and deleting zones and resource records, and controlling a lot of its behavior.&lt;/p&gt;

&lt;p&gt;This article explores how to run &lt;code&gt;dnscmd&lt;/code&gt; from Perl. In that respect, it is a classic &amp;ldquo;Perl-as-a-driver&amp;rdquo; script, invoking &lt;code&gt;dnscmd&lt;/code&gt; with various options and working on its outputs.&lt;/p&gt;

&lt;h3 id=&#34;dnscmd&#34;&gt;DNSCMD&lt;/h3&gt;

&lt;p&gt;Invoke &lt;code&gt;dnscmd /?&lt;/code&gt; to see a top-level list of available subcommands and type &lt;code&gt;dnscmd /subcommand&lt;/code&gt; /? for more specific help for this subcommand. &lt;code&gt;dnscmd /?&lt;/code&gt; shows that there is a subcommand &lt;code&gt;RecordDelete&lt;/code&gt;, and &lt;code&gt;dnscmd /recorddelete /?&lt;/code&gt; (case not significant) explains that you need a zone name (like &amp;ldquo;my.dom.ain&amp;rdquo;), a node name within this zone (like &amp;ldquo;host1&amp;rdquo;), a record type (like &amp;ldquo;A&amp;rdquo;), and the data part of the resource record to delete (like &amp;ldquo;10.20.40.5&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;The first argument to &lt;code&gt;dnscmd&lt;/code&gt;, if you actually want to do something with it, is the name of the DNS server to use. A full working command looks something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dnscmd dnssrv.my.dom.ain /RecordDelete my.dom.ain host1 A 10.20.40.5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This opens the very welcome opportunity to run &lt;code&gt;dnscmd&lt;/code&gt; remotely—from your workstation, for example—which frees you from the need to log in to your DNS server.&lt;/p&gt;

&lt;h3 id=&#34;wdns-pl-media-pub-2005-03-24-perl-dns-wdns-pl-the-script&#34;&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2005_03_24_perl_dns/wdns.pl&#34;&gt;WDNS.PL&lt;/a&gt; (The Script)&lt;/h3&gt;

&lt;p&gt;The script in the current version only handles A and PTR records. There is no handling of CNAME records, for example. Within this limitation, it is also very A record-oriented: you can add or delete A records, change the IP or name of an A record, or move the A record to a different zone. It keeps PTR records in sync with these changes, creating or deleting a corresponding PTR record with its A record. This is mostly what you want.&lt;/p&gt;

&lt;p&gt;The most important thing to understand with this script is the format and the meaning of the input data it takes (&amp;ldquo;Show me your data &amp;hellip;&amp;rdquo;)[2]. The format is simple, just:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;name1&amp;gt;      &amp;lt;target1&amp;gt;
    &amp;lt;name2&amp;gt;      ...
    ...          ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Separate &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;target&lt;/code&gt; by whitespace. A name is a relative or fully- qualified domain name. A target can be one of these:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;another domain name, meaning to rename to that name;&lt;/li&gt;
&lt;li&gt;an IP, meaning to change to this IP;&lt;/li&gt;
&lt;li&gt;nothing or undef, meaning to delete this name.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This mirrors the basic functions of the script. To add some extra candy, the target parameter has two other possibilities which have proven very useful in my environment. A target can also be:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a C net, given as a triple of IP buckets (like &amp;ldquo;10.20.40&amp;rdquo;);&lt;/li&gt;
&lt;li&gt;a net segment identifier (&amp;ldquo;v1&amp;rdquo;, &amp;ldquo;v2&amp;rdquo;, and so on, in my example).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In both cases, the script will give the name a free IP (if possible) from either the C net or the net segment specified by its identifier. I&amp;rsquo;ll return to this idea soon.&lt;/p&gt;

&lt;p&gt;To pull all of the various possibilities together, here is a list of sample input lines, each representing one of the mentioned possibilities for the target:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          pcthe                10.20.90.53     -- new ip
          pcthe.my.dom.ain     10.20.90.53     -- new ip full qualified
          pcthe                10.20.90        -- search free ip in range
          pcthe                @v8             -- search free ip in net segment v8
          pcthe                pcthe2          -- rename host
          pcthe                pcthe.oth.dom   -- rename host full qualified
          pcthe                                -- delete host (with -r option)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pass this data to the script through either an input file or STDIN[3].&lt;/p&gt;

&lt;h4 id=&#34;init&#34;&gt;&lt;code&gt;init()&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;Now to the code. At startup, &lt;code&gt;wdns.pl&lt;/code&gt; pulls in the list of primary zones from the given DNS server, both forward (names as lookup keys) and reverse (IPs as lookup keys) zones. This is handy, because it will use this list again and again.&lt;/p&gt;

&lt;h4 id=&#34;mv-ip&#34;&gt;&lt;code&gt;mv_ip()&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;The main worker routine is the sub &lt;code&gt;mv_ip&lt;/code&gt;. (Don&amp;rsquo;t think too much about the name; it&amp;rsquo;s from the time when the only function of the script was to change the IP of a given name). For any given name/target pair, it does the following: First it tries to find a FQDN for the name. If it finds a host for the given name, it uses the FQDN as a basis to construct the name part of the targeted record. If it cannot find a name, it assumes that it should create an entirely new record. If the options permit (&lt;code&gt;-c&lt;/code&gt;), it constructs one.&lt;/p&gt;

&lt;p&gt;Then it inspects the target. Depending on its type, the program prepares to assign a new IP to the name, rename an existing A record while retaining the IP, search for a free IP in a certain range, or just delete existing records. When everything settles, the actual changes take place, using &lt;code&gt;dnscmd&lt;/code&gt; to delete and add A and PTR records as appropriate. (There is no &lt;code&gt;UpdateRecord&lt;/code&gt; function in &lt;code&gt;dnscmd&lt;/code&gt;, so updating is in fact a combination of delete and create).&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it! The rest of the code is lower-level functions that help to achieve this.&lt;/p&gt;

&lt;h4 id=&#34;create-and-delete&#34;&gt;&lt;code&gt;create_*&lt;/code&gt; and &lt;code&gt;delete_*&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;The four subs &lt;code&gt;create_A&lt;/code&gt;, &lt;code&gt;create_PTR&lt;/code&gt;, &lt;code&gt;delete_A&lt;/code&gt;, and &lt;code&gt;delete_PTR&lt;/code&gt; are wrapper functions around the respective invocations of &lt;code&gt;dnscmd&lt;/code&gt;. An additional issue of interest is that Windows DNS will delete a PTR record once you delete the corresponding A record, so you don&amp;rsquo;t have to do so explicitly.&lt;/p&gt;

&lt;h4 id=&#34;get-rev-zone-and-get-fwd-zone&#34;&gt;&lt;code&gt;get_rev_zone()&lt;/code&gt; and &lt;code&gt;get_fwd_zone()&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;One of the major issues when manipulating DNS resource records is picking the right zone to do the change in. If you have just one forward and one reverse zone, this is simple. However, if you are maintaining a lot of zones with domains and nested subdomains, while other subdomains of the same parent have their own zones, this might be tedious.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;wdns.pl&lt;/code&gt; can offload this task for you. The subs &lt;code&gt;get_rev_zone&lt;/code&gt; and &lt;code&gt;get_fwd_zone&lt;/code&gt; use the initially retrieved list of primary zones from your server. They take an IP or a fully qualified domain name respectively, and split it into the node part and the zone part. So the IP 10.20.40.5 might split into 10.20.40 and 5 (if the proper zone of this IP is 40.20.10.in-addr.arpa) or 10 and 20.40.5 (if 10.in-addr.arpa happens to be the enclosing zone), depending on your zone settings. The same applies for domain names. Other routines use this information to add or delete resource records in their appropriate zones.&lt;/p&gt;

&lt;h4 id=&#34;ip-lookup-functions&#34;&gt;IP Lookup Functions&lt;/h4&gt;

&lt;p&gt;There is a set of subs I called &amp;ldquo;IP lookup functions&amp;rdquo;. They all help to find a free IP in an appropriate range. Depending on the target specification, they will search a certain C net or a whole net segment of unused address. This searching breaks down to finding the appropriate zone, the appropriate node (&amp;ldquo;subdomain&amp;rdquo;), and then listing the already existing leaf nodes in this range. Once it has the list of used nodes, it starts scanning for gaps or unused nodes off the end of the list.&lt;/p&gt;

&lt;p&gt;An additional feature of these routines is that they honor certain reservations in the ranges, either through fixed directives (&amp;ldquo;leave the first 50 addresses free at the beginning of each net segment&amp;rdquo;) or through inspecting dedicated TXT records on the DNS server that contain the &lt;code&gt;RESERVED&lt;/code&gt; keyword. (The actual format of these records is &lt;code&gt;RESERVED:&amp;lt;range-spec&amp;gt;:&amp;lt;free text&amp;gt;&lt;/code&gt;, where &lt;code&gt;range-spec&lt;/code&gt; is a colon-separated list of IPs or IP ranges. An example is &lt;code&gt;RESERVED:1,3,5,10-20,34:IPs reserved for the VPN switches&lt;/code&gt;). This helps avoid re-using reserved IPs accidentally through the automatic script, and also helps avoid messing things up when time is short.&lt;/p&gt;

&lt;p&gt;In the case of these TXT records, I used &lt;code&gt;dnscmd&lt;/code&gt; to retrieve them, not &lt;code&gt;nslookup&lt;/code&gt;, which would have been equally possible.&lt;/p&gt;

&lt;h3 id=&#34;a-word-about-the-net-segments&#34;&gt;A Word About the Net Segments&lt;/h3&gt;

&lt;p&gt;If your IPs reside in a segmented network, which is likely to be the case for most sites, make sure that your hosts have addresses for the segments to which they attach. For this script I have chosen a poor man&amp;rsquo;s approach to represent the segments just by the list of their respective C nets in the script itself (see the hash &lt;code&gt;%netsegs&lt;/code&gt; in the &amp;ldquo;Config section&amp;rdquo;). There might be a more clever way to do this. If you are going to run the script in your environment, edit this hash to reflect your network topology.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;dns_lookup&lt;/code&gt; sub looks up the current DNS entries. It runs the extern command &lt;code&gt;nslookup&lt;/code&gt; and parses its output. If you need more sophisticated DNS lookups (and &lt;code&gt;nslookup&lt;/code&gt;&amp;rsquo;s options just won&amp;rsquo;t do), you might want to resort to &lt;code&gt;dig&lt;/code&gt; (which has a Windows version) or &lt;a href=&#34;https://metacpan.org/pod/Net::DNS&#34;&gt;Net::DNS&lt;/a&gt; (which runs on Windows in any case). This simple way of doing it was just enough for my needs.&lt;/p&gt;

&lt;h4 id=&#34;footnotes&#34;&gt;Footnotes&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;In the Windows world, server processes are usually referred to as &amp;ldquo;services&amp;rdquo;; I tend to mix this term with &amp;ldquo;server&amp;rdquo; every now and then.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Show me your functions, and I will be confused. Show me your data, and your functions will be obvious&amp;rdquo;, to re-coin a famous quote from Frederick Brooks&amp;rsquo; &lt;em&gt;The Mythical Man-month&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Depending on your Windows command shell, you might have to tinker a bit to get the STDIN input to work as desired. Cygwin&amp;rsquo;s bash works like a breeze and takes Ctrl-Z&amp;lt;RET&amp;gt; as the EOF sequence.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>

