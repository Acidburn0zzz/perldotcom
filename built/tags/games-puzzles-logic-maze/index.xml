<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Games Puzzles Logic Maze on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/games-puzzles-logic-maze/</link>
    <description>Recent content in Games Puzzles Logic Maze on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 17 Nov 2003 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/games-puzzles-logic-maze/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Solving Puzzles with LM-Solve</title>
      <link>http://localhost:1313/pub/2003/11/17/lmsolve.html/</link>
      <pubDate>Mon, 17 Nov 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/11/17/lmsolve.html/</guid>
      <description>

&lt;p&gt;Suppose you encounter a (single-player) riddle or a puzzle that you don&amp;rsquo;t know how to solve. Let&amp;rsquo;s also suppose that this puzzle involves moving between several states of the board with an enumerable number of moves emerging from one state. In this case, &lt;a href=&#34;http://vipe.technion.ac.il/~shlomif/lm-solve/&#34;&gt;LM-Solve&lt;/a&gt; (or Games::LMSolve on CPAN) may be of help.&lt;/p&gt;

&lt;p&gt;LM-Solve was originally written to tackle various types of the so-called &lt;a href=&#34;http://www.logicmazes.com/&#34;&gt;logic mazes&lt;/a&gt; that can be found online. Nevertheless, it can be extended to support many other types of single-player puzzles.&lt;/p&gt;

&lt;p&gt;In this article, I will demonstrate how to use LM-Solve to solve a type of puzzle that it does not know yet to solve.&lt;/p&gt;

&lt;h2 id=&#34;installation&#34;&gt;Installation&lt;/h2&gt;

&lt;p&gt;Use the CPAN.pm module &lt;code&gt;install Games::LMSolve&lt;/code&gt; command to install LM-Solve. For instance, invoke the following command on the command line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl -MCPAN -e &#39;install Games::LMSolve&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it! (LM-Solve does not require any non-base modules, and should run on all recent versions of Perl.)&lt;/p&gt;

&lt;h2 id=&#34;the-puzzle-in-question&#34;&gt;The Puzzle in Question&lt;/h2&gt;

&lt;p&gt;The puzzle in question is called &amp;ldquo;Jumping Cards&amp;rdquo; and is taken from the &lt;a href=&#34;http://mathforum.org/wagon/spring02/p949.html&#34;&gt;Macalester College Problem of the Week No. 949&lt;/a&gt;. In this puzzle, we start with eight cards in a row (labeled 1 to 8). We have to transform it into the 8 to 1 sequence, by swapping two cards at a time, as long as the following condition is met: at any time, two neighboring cards must be in one, two, or three spaces of each other.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s experience with this puzzle a bit. We start with the following formation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 2 3 4 5 6 7 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s swap 1 and 3, and see what it gives us:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3 2 1 4 5 6 7 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we cannot exchange 1 and 4, because then, 1 would be close to the 5, and 5-1 is 4, which is more than 3. So let&amp;rsquo;s exchange 2 and 1:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3 1 2 4 5 6 7 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can exchange 2 and 4:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3 1 4 2 5 6 7 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And so on.&lt;/p&gt;

&lt;h2 id=&#34;let-s-start-coding&#34;&gt;Let&amp;rsquo;s Start &amp;hellip; Coding!&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;Games::LMSolve::Base&lt;/code&gt; class tries to solve a game by iterating through its various positions, recording every one it passes through, and trying to reach the solution. However, it does not know in advance what the games rules are, and what the meaning of the positions and moves are. In order for it to know that, we need to inherit it and code several methods that are abstract in the base class.&lt;/p&gt;

&lt;p&gt;We will code a derived class that will implement the logic specific to the Jumping Cards game. It will implement the following methods, which, together with the methods of the base class, enable the solver to solve the game:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;input_board&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pack_state&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unpack_state&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;display_state&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;check_if_final_state&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;enumerate_moves&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;perform_move&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;render_move&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Here&amp;rsquo;s the beginning of the file where we put the script:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package Jumping::Cards;

use strict;

use Games::LMSolve::Base;

use vars qw(@ISA);

@ISA=qw(Games::LMSolve::Base);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As can be seen, we declared a new package, &lt;code&gt;Jumping::Cards&lt;/code&gt;, imported the &lt;code&gt;Games::LMSolve::Base&lt;/code&gt; namespace, and inherited from it. Now let&amp;rsquo;s start declaring the methods. First, a method to input the board in question.&lt;/p&gt;

&lt;p&gt;Since our board is constant, we just return an array reference that contains the initial sequence.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub input_board
{
    my $self = shift;

    my $filename = shift;

    return [ 1 .. 8 ];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When &lt;code&gt;Games::LMSolve::Base&lt;/code&gt; iterates over the states, it stores data about each state in a hash. This means we&amp;rsquo;re going to have to provide a way to convert each state from its expanded form into a uniquely identifying string. The &lt;code&gt;pack_state&lt;/code&gt; method does this, and in our case, it will look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# A function that accepts the expanded state (as an array ref)
# and returns an atom that represents it.
sub pack_state
{
    my $self = shift;
    my $state_vector = shift;
    return join(&amp;quot;,&amp;quot;, @$state_vector);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is a good idea to use functions like &lt;code&gt;pack&lt;/code&gt;, &lt;code&gt;join&lt;/code&gt; or any other serialization mechanism here. In our case, we simply used &lt;code&gt;join&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It is not very convenient to manipulate a packed state, and so we need another function to expand it. &lt;code&gt;unpack_state&lt;/code&gt; does the opposite of &lt;code&gt;pack_state&lt;/code&gt; and expands a packed state.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# A function that accepts an atom that represents a state 
# and returns an array ref that represents it.
sub unpack_state
{
    my $self = shift;
    my $state = shift;
    return [ split(/,/, $state) ];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;display_state()&lt;/code&gt; converts a packed state to a user-readable string. This is so that it can be displayed to the user. In our case, the comma-delimited notation is already readable, so we leave it as that.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Accept an atom that represents a state and output a 
# user-readable string that describes it.
sub display_state
{
    my $self = shift;
    my $state = shift;
    return $state;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We need to determine when we have reached our goal and can terminate the search with a success. The &lt;code&gt;check_if_final_state&lt;/code&gt; function accepts an expanded state and checks if it qualifies as a final state. In our case, it is final if it&amp;rsquo;s the 8-to-1 sequence.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub check_if_final_state
{
    my $self = shift;

    my $coords = shift;
    return join(&amp;quot;,&amp;quot;, @$coords) eq &amp;quot;8,7,6,5,4,3,2,1&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we need a function that will tell the solver what subsequent states are available from each state. This is done by enumerating a set of moves that can be performed on the state. The &lt;code&gt;enumerate_moves&lt;/code&gt; function does exactly that.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# This function enumerates the moves accessible to the state.
sub enumerate_moves
{
    my $self = shift;

    my $state = shift;

    my (@moves);
    for my $i (0 .. 6)
    {
        for my $j (($i+1) .. 7)
        {
            my @new = @$state;
            @new[$i,$j]=@new[$j,$i];
            my $is_ok = 1;
            for my $t (0 .. 6)
            {
                if (abs($new[$t]-$new[$t+1]) &amp;gt; 3)
                {
                    $is_ok = 0;
                    last;
                }
            }
            if ($is_ok)
            {
                push @moves, [$i,$j];
            }
        }
    }
    return @moves;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What &lt;code&gt;enumerate_moves&lt;/code&gt; does is iterate over the indices of the locations twice, and checks every move for the validity of the resultant board. If it&amp;rsquo;s OK, it pushes the exchanged indices to the array &lt;code&gt;@moves&lt;/code&gt;, which is returned at the end.&lt;/p&gt;

&lt;p&gt;We also need a function that will translate an origin state and a move to a resultant state. The &lt;code&gt;perform_move&lt;/code&gt; function performs a move on a state and returns the new state. In our case, it simply swaps the cards in the two indices specified by the move.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# This function accepts a state and a move. It tries to perform the
# move on the state. If it is successful, it returns the new state.
sub perform_move
{
    my $self = shift;

    my $state = shift;
    my $m = shift;

    my @new = @$state;

    my ($i,$j) = @$m;
    @new[$i,$j]=@new[$j,$i];
    return \@new;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we need a function that will render a move into a user-readable string, so it can be displayed to the user.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub render_move
{
    my $self = shift;

    my $move = shift;

    if (defined($move))
    {
        return join(&amp;quot; &amp;lt;=&amp;gt; &amp;quot;, @$move);
    }
    else
    {
        return &amp;quot;&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;invoking-the-solver&#34;&gt;Invoking the Solver&lt;/h2&gt;

&lt;p&gt;To make the solver invokable, create an instance of it in the main namespace, and call its &lt;code&gt;main()&lt;/code&gt; function. This will turn it into a script that will solve the board. The code is this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main;

my $solver = Jumping::Cards-&amp;gt;new();
$solver-&amp;gt;main();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now save everything to a file, &lt;em&gt;jumping_cards.pl&lt;/em&gt; (or download &lt;a href=&#34;http://t2.technion.ac.il/~shlomif/solving-with-lms/jumping_cards.pl&#34;&gt;the complete one&lt;/a&gt;), and invoke it like this: &lt;code&gt;perl jumping_cards.pl --norle --output-states&lt;/code&gt;. The &lt;code&gt;--norle&lt;/code&gt; option means not to run-length encode the moves. In our case, run-length encoding will do no good, because a move can appear only once (or else its effect will be reversed). &lt;code&gt;--output-states&lt;/code&gt; causes the states to be displayed in the solution.&lt;/p&gt;

&lt;p&gt;The program thinks a little and then outputs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;solved
solved
1,2,3,4,5,6,7,8: Move = 0 &amp;lt;=&amp;gt; 1
2,1,3,4,5,6,7,8: Move = 1 &amp;lt;=&amp;gt; 2
2,3,1,4,5,6,7,8: Move = 1 &amp;lt;=&amp;gt; 3
2,4,1,3,5,6,7,8: Move = 4 &amp;lt;=&amp;gt; 5
2,4,1,3,6,5,7,8: Move = 0 &amp;lt;=&amp;gt; 4
6,4,1,3,2,5,7,8: Move = 2 &amp;lt;=&amp;gt; 3
6,4,3,1,2,5,7,8: Move = 0 &amp;lt;=&amp;gt; 1
4,6,3,1,2,5,7,8: Move = 0 &amp;lt;=&amp;gt; 7
8,6,3,1,2,5,7,4: Move = 6 &amp;lt;=&amp;gt; 7
8,6,3,1,2,5,4,7: Move = 3 &amp;lt;=&amp;gt; 5
8,6,3,5,2,1,4,7: Move = 2 &amp;lt;=&amp;gt; 7
8,6,7,5,2,1,4,3: Move = 1 &amp;lt;=&amp;gt; 2
8,7,6,5,2,1,4,3: Move = 4 &amp;lt;=&amp;gt; 6
8,7,6,5,4,1,2,3: Move = 5 &amp;lt;=&amp;gt; 7
8,7,6,5,4,3,2,1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which is a correct solution to the problem. If you want to see a run-time display of the solving process, add the &lt;code&gt;--rtd&lt;/code&gt; switch.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;LM-Solve is a usable and flexible framework for writing your own solvers for various kind of puzzles such as the above. Puzzles that are good candidates for implementing solvers have a relatively limited number of states and a small number of states emerging from each origin state.&lt;/p&gt;

&lt;p&gt;I found several solitaire games, such as Freecell, to be solvable by methods similar to the above. On the other hand, Klondike and other games with &lt;code&gt;talon&lt;/code&gt;, are very hard to solve using such methods, because the &lt;code&gt;talon&lt;/code&gt; expands the number of states a great deal.&lt;/p&gt;

&lt;p&gt;Still, for most &amp;ldquo;simple-minded&amp;rdquo; puzzles, LM-Solve is very attractive as a solver framework. Have fun!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

