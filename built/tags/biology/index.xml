<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Biology on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/biology/</link>
    <description>Recent content in Biology on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 20 Oct 2005 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/biology/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Data Munging for Non-Programming Biologists</title>
      <link>http://localhost:1313/pub/2005/10/20/scriptome.html/</link>
      <pubDate>Thu, 20 Oct 2005 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2005/10/20/scriptome.html/</guid>
      <description>

&lt;p&gt;Have you ever renamed 768 files? Merged the content from 96 files into a spreadsheet? Filtered 100 lines out of a 20,000-line file?&lt;/p&gt;

&lt;p&gt;Have you ever done these things by hand?&lt;/p&gt;

&lt;p&gt;Disciples of laziness&amp;ndash;one of the three Perl programmer&amp;rsquo;s virtues&amp;ndash;know that you should never repeat anything five times, let alone 768. It dismayed me to learn that biologists do this kind of thing all the time.&lt;/p&gt;

&lt;h3 id=&#34;on-the-origin-of-scripts-the-problem&#34;&gt;On the Origin of Scripts: The Problem&lt;/h3&gt;

&lt;p&gt;Experimental biologists increasingly face large sets of large files in often-incompatible formats, which they need to filter, reformat, merge, and otherwise &lt;a href=&#34;http://www.catb.org/~esr/jargon/html/M/munge.html&#34;&gt;munge&lt;/a&gt; (definition 3). Biologists who can&amp;rsquo;t write Perl (most of them) often end up editing large files by hand. When they have the same problem a week later, &lt;em&gt;they do the same thing again&lt;/em&gt;&amp;ndash;or they just give up.&lt;/p&gt;

&lt;p&gt;My job description includes helping biologists to use computers. I could just write tailored, one-off scripts for them, right? As an answer, let me tell you about Neeraj. Neeraj is a typical NPB (non-programming biologist) who works down the hall. He came into my office, saying, &amp;ldquo;I have 12,000 sequences that I need to make primers for.&amp;rdquo; I said, &amp;ldquo;Make what?&amp;rdquo; (I haven&amp;rsquo;t been doing biology for very long.) Luckily, we figured out pretty quickly that all he wants to do is get characters 201-400 from each DNA sequence in a file. Those of you who have been Perling for a while can do this with your eyes closed (if you can touch type):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;perl -ne &#39;print substr($_, 200, 200), &amp;quot;\n&amp;quot;&#39; sequences.in &amp;gt;
    primers.out
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Voil√°! I gave Neeraj his output file and he went away, happy, to finish building his clone army to take over the world. (Or was he going to genetically modify rice to solve world hunger? I keep forgetting.)&lt;/p&gt;

&lt;p&gt;Unfortunately, that wasn&amp;rsquo;t the end. The next day, Neeraj came back, because he also wanted primers from the back end of the sequences (&lt;code&gt;substr($_, -400, 200)&lt;/code&gt;). Because he&amp;rsquo;s doing cutting-edge research, he may have totally different requirements next month, when he finishes his experiments. With just a few people in our group supporting hundreds or even thousands of biologists, writing tailored scripts, even quick one-liners, doesn&amp;rsquo;t scale. Other common solutions, such as teaching biologists Perl or creating graphical workflow managers, didn&amp;rsquo;t seem to fully address the data manipulation problem especially for occasional users, who won&amp;rsquo;t be munging every day.&lt;/p&gt;

&lt;p&gt;We need some tool that allows Neeraj, or any NPB, to munge his own data, rather than relying on (and explaining biology to) a programmer. Keeping the biologist in the loop this way gives him the best chance of applying the relevant data and algorithms to answer the right questions. The tool must be easy for a non-programmer to learn and to remember after a month harvesting fish eyes in Africa. It should also be TMTOWTDI-compliant, allowing him to play with data until he can sculpt it in the most meaningful way. While we&amp;rsquo;re at it, the tool will need to evolve rapidly as biologists ask new questions and create new kinds of data at an ever-increasing rate.&lt;/p&gt;

&lt;p&gt;When I told Neeraj&amp;rsquo;s story to others in our group, they said that they have struggled with this problem for years. During one of our brainstorming sessions, my not-so-pointy-haired boss, Eitan Rubin, said, &amp;ldquo;Wouldn&amp;rsquo;t it be nice if we could just give them a book of magical data-munging scripts that Just Work?&amp;rdquo; &amp;ldquo;Hm&amp;ndash;a sort of Script Tome?&amp;rdquo; And thus the Scriptome was born. (The joke here is that every self-respecting area of study in biology these days needs to have &amp;ldquo;ome&amp;rdquo; in its name: the genome, proteome, metabolome. There&amp;rsquo;s even a journal called &lt;em&gt;OMICS&lt;/em&gt; now.)&lt;/p&gt;

&lt;h3 id=&#34;harnessing-the-power-of-the-atom&#34;&gt;Harnessing the Power of the Atom&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://sysbio.harvard.edu/csb/resources/computational/scriptome/&#34;&gt;The Scriptome&lt;/a&gt; is a cookbook for munging biological data. The cookbook model nicely fits the UNIX paradigm of small tools that do simple operations. Instead of UNIX pipes, though, we encourage the use of intermediate files to avoid errors.&lt;/p&gt;

&lt;p&gt;We use a couple of tricks in order to make this cookbook accessible to NPBs. We use the familiar web browser as our GUI and harness the power of hyperlinking to develop a highly granular, hierarchical table of contents for the tools. This means we can include dozens to hundreds of tools, without requiring users to remember command names. Another trick is syntax highlighting. We gray out most of the Perl, to signify that reading it is optional. Parameters&amp;ndash;such as filenames, or maximum values to filter a certain column by&amp;ndash;we highlight in attention-getting red. Finally, we make a conscious effort to avoid computer science or invented terminology. Instead, we use language biologists find familiar. For example, tools are &amp;ldquo;atoms,&amp;rdquo; rather than &amp;ldquo;snippets.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Each Scriptome tool consists of a Perl one-liner in a colored box, along with a couple of sentences of documentation (any more than that and no one will read it), and sample inputs and outputs. In order to use a tool, you:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Pick a tool type, perhaps &amp;ldquo;Choose&amp;rdquo; to choose certain lines or columns from a file.&lt;/li&gt;
&lt;li&gt;Browse a hierarchical table of contents.&lt;/li&gt;
&lt;li&gt;Cut and paste the code from the colored box onto a Unix, Mac OS X, or Windows command line. (Friendlier interfaces are in alpha testing&amp;ndash;a later section explains more.)&lt;/li&gt;
&lt;li&gt;Change red text as desired, using arrow keys or a text editor.&lt;/li&gt;
&lt;li&gt;Hit &lt;code&gt;Enter&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;That&amp;rsquo;s it!&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2005_10_20_scriptome/perl_com_pic.gif&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_10_20_scriptome/perl_com_pic_sm.gif&#34; alt=&#34;Figure 1&#34; width=&#34;300&#34; height=&#34;114&#34; /&gt;&lt;/a&gt;&lt;br /&gt;
Figure 1. A Scriptome tool for finding unique lines in a file--click image for full-size screen shot.&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The tool in Figure 1 reads the input line by line, using Perl&amp;rsquo;s &lt;code&gt;-n&lt;/code&gt; option, and prints each line only when it sees the value in a given, user-editable column for the first time. The substitution removes a newline, even if it&amp;rsquo;s a Windows file being read on a UNIX machine. Then the line is split on tabs. A hash keeps track of unique values in the given column, deciding which lines to print. Finally, the script prints to the screen a very quick diagnostic, specifically how many lines it chose out of how many total lines it read. (Choosing all lines or zero lines may mean you&amp;rsquo;re not filtering correctly.)&lt;/p&gt;

&lt;p&gt;By cutting and pasting tools like this, a biologist can perform basic data munging operations, without any programming knowledge or program installation (except for ActivePerl on Windows). Unfortunately, that&amp;rsquo;s still not really enough to solve real-world problems.&lt;/p&gt;

&lt;h3 id=&#34;splicing-the-scriptome&#34;&gt;Splicing the Scriptome&lt;/h3&gt;

&lt;p&gt;As it happens, the story I told you about Neeraj earlier wasn&amp;rsquo;t entirely accurate. He actually wanted to print both the beginning and ending substrings from his sequences. Also, his input was in the common FASTA format, where each sequence has an ID line like &lt;code&gt;&amp;gt;A2352334&lt;/code&gt; followed by a variable number of lines with DNA letters. We don&amp;rsquo;t have one tool that parses FASTA and takes out two different substrings; writing every possible combination of tools would take even longer than writing Perl 6 (ahem). Instead, again following UNIX, we leave it up to the biologist to combine the tools into problem-specific solutions. In this case, that solution would involve using the FASTA-to-table converter, followed by a tool to pull out the sequence column, and then two copies of the substring tool.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re asking biologists to break a problem down into pieces&amp;ndash;each of which is solvable using some set of tools&amp;ndash;and then to string those tools together in the right order with the right parameters. That sounds an awful lot like programming, doesn&amp;rsquo;t it? Although you may not think about it anymore, some of the fundamental concepts of programming are new and difficult. Luckily, it turns out that biologists learned more in grad school than how to extract things out of (reluctant) other things. In fact, they already know how to break down problems, loop, branch, and debug; instead of programming, though, they call it developing protocols. They also already have &lt;a href=&#34;http://www.molecularcloning.com/public/tour/index.html&#34;&gt;cookbooks for experimental molecular biology&lt;/a&gt;. Such a protocol might include lines like:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Add 1 ml of such-and-such enzyme to the DNA.&lt;/li&gt;
&lt;li&gt;Incubate test tube at 90 degrees C for an hour.&lt;/li&gt;
&lt;li&gt;If the mixture turns clear, goto step 5.&lt;/li&gt;
&lt;li&gt;Repeat steps 2-3 three times.&lt;/li&gt;
&lt;li&gt;Pour liquid into a sterile bottle &lt;em&gt;very carefully&lt;/em&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We borrowed the term &amp;ldquo;protocol&amp;rdquo; to describe an ordered set of parameterized Scriptome tools that solves a larger problem. (The right word for this is a script, but don&amp;rsquo;t tell our users&amp;ndash;they might realize they&amp;rsquo;re learning how to program.) We feature some pre-written protocols on the website. Note that because each tool is a command-line command, a set of them together is really just an executable shell script.&lt;/p&gt;

&lt;p&gt;The Scriptome may be even more than a high-level, mostly syntax-free, non-toy language for NPBs. Because it exposes the Perl directly on the website&amp;ndash;giving new meaning to the term &amp;ldquo;open source&amp;rdquo;&amp;ndash;some curious biologists may even start reading the short, simple, relevant examples of Perl code. (Unfortunately, putting the command into one line makes it harder to read. One of our TODOs is an Explain button next to each tool, which would show you a commented, multi-line version of each script.) From there, it&amp;rsquo;s a short hop to tweaking the tools, and before you know it, we&amp;rsquo;ll have more annoying newbie posts on &lt;em&gt;comp.lang.perl.misc&lt;/em&gt;!&lt;/p&gt;

&lt;h3 id=&#34;intelligent-design-the-geeky-details&#34;&gt;Intelligent Design: The Geeky Details&lt;/h3&gt;

&lt;p&gt;If you&amp;rsquo;ve read this far, you may have realized by now that the Scriptome is not a programming project at heart. Design, interface, documentation, and examples are as important as the programming itself, which is pretty easy. This being an article on Perl.com, though, I want to discuss the use of Perl throughout the project.&lt;/p&gt;

&lt;h4 id=&#34;why-perl&#34;&gt;Why Perl?&lt;/h4&gt;

&lt;p&gt;Several people asked me why we didn&amp;rsquo;t write the Scriptome in Python, or R, or just use UNIX &lt;code&gt;sh&lt;/code&gt; for everything. Well, other than the obvious (&amp;ldquo;It&amp;rsquo;s the One True Language!&amp;rdquo;), Perl data munges by design, it&amp;rsquo;s great for fast tool development, it&amp;rsquo;s portable to many platforms, and it&amp;rsquo;s already installed on every Unix and Mac OS X box. Moreover, the &lt;a href=&#34;http://bioperl.org/&#34;&gt;Bioperl&lt;/a&gt; modules offer me a huge number of tools to steal, um, reuse. Finally, Perl is the preferred language of the entire Scriptome development team (me).&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;div class=&#34;secondary&#34;&gt;
&lt;h4 id=&#34;what-kind-of-perl&#34; align=&#34;center&#34;&gt;What kind of Perl?&lt;/h4&gt;
&lt;p&gt;Perl allows you to write pretty impressive tools in only a couple of hundred characters, with Perl Golf tricks such as the &lt;code&gt;-n&lt;/code&gt; option, autovivification, and the implicit &lt;code&gt;$_&lt;/code&gt; variable. On the other hand, we want the code to be readable, especially if we want newbies to learn from it, so we can&#39;t use too many Golf shortcuts. (For example, here&#39;s the winning solution in the Perl Golf contest for a script to find the last non-zero digit of N factorial by Juho Snellman:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; #!perl -l $_*=$`%9e9,??for+1=~?0*$?..pop;print$`%10&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Some might consider this difficult for newbies to read.)&lt;/p&gt;
&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;the-scriptome-build&#34;&gt;The Scriptome Build&lt;/h4&gt;

&lt;p&gt;Even though we&amp;rsquo;re trying to keep the tools pretty generic and simple, we know we&amp;rsquo;ll need several dozen at least, to be at all useful. In addition, data formats and biologists&amp;rsquo; interests will change over time. We knew we had to make the process of creating a new tool fast and automatic.&lt;/p&gt;

&lt;p&gt;I write the tool pages in POD, which lets me use Vim rather than a fancy web-page editor. My Makefile runs &lt;code&gt;pod2html&lt;/code&gt; to create a nice, if simple, web page that includes the table of contents for free. A Perl filter then adds a navigation bar and some simple interface-enhancing JavaScript, and makes the parameters red. I may give in and switch to a templating system, database back end, or XML eventually, and automated testing would be great. For now, keeping it simple means I can create, test, document, and publish a new tool in under an hour. (Okay, I didn&amp;rsquo;t include debugging in that time.)&lt;/p&gt;

&lt;h4 id=&#34;perl-culture&#34;&gt;Perl Culture&lt;/h4&gt;

&lt;p&gt;There&amp;rsquo;s lots of Perl code in the project, but I&amp;rsquo;m trying to incorporate some Perl &lt;em&gt;attitude&lt;/em&gt; as well. The &amp;ldquo;Aha!&amp;rdquo; moment of the Scriptome came when we realized we could just post a bunch of hacked one-liners on the Web to help biologists &lt;em&gt;now&lt;/em&gt;, rather than spend six or 12 months crafting the perfect solution. While many computational biologists focus on writing O(N) programs for sophisticated sequence analysis or gene expression studies, we&amp;rsquo;re not ashamed to write glue instead; we solve the unglamorous problem of taking the output from their fancy programs and throwing it into tabular format, so that a biologist can study the results in Excel. After all, if data munging is even one step in Neeraj&amp;rsquo;s pipeline, then he still can&amp;rsquo;t get his paper published without these tools. Finally, we&amp;rsquo;re listening aggressively to our users, because only they can tell us which easy things to make easy and which hard things to make possible.&lt;/p&gt;

&lt;h3 id=&#34;filling-the-niche-the-scriptome-and-other-solutions&#34;&gt;Filling the Niche: The Scriptome and Other Solutions&lt;/h3&gt;

&lt;p&gt;One of my greatest concerns in talking to people about biologists&amp;rsquo; data munging is that people don&amp;rsquo;t even realize that there&amp;rsquo;s a problem, or they think it&amp;rsquo;s already been solved. Biologists&amp;ndash;who happily pipette things over and over and over again&amp;ndash;don&amp;rsquo;t realize that computers could save them lots of time. Too many programmers figure that anyone who needs to can just read &lt;em&gt;Learning Perl&lt;/em&gt;. I&amp;rsquo;m all for that, of course, but experimental biologists need to spend much more of their time getting data (dissecting bee brains, say) than analyzing it, so they can&amp;rsquo;t afford the time it takes to become programmers. They shouldn&amp;rsquo;t have to. Does the average biologist need multiple inheritance, &lt;code&gt;getprotobyname()&lt;/code&gt;, and negative look-behind regexes? There&amp;rsquo;s a large body of problems out there that are too diverse for simple, inflexible tools to handle, but are too simple to need full-fledged programming.&lt;/p&gt;

&lt;p&gt;How about teaching a three-hour course with just enough Perl to munge simple data? At minimum, it should teach variables, arrays, hashes, regular expressions, and control structures&amp;ndash;and then there&amp;rsquo;s syntax. &amp;ldquo;Wait, what&amp;rsquo;s the difference between &lt;code&gt;@{$a[$a]}&lt;/code&gt; and &lt;code&gt;@a{$a[$a]}&lt;/code&gt; again?&amp;rdquo; &amp;ldquo;Oh, my, look at the time.&amp;rdquo; As Damian Conway writes in &amp;ldquo;&lt;a href=&#34;http://www.csse.monash.edu.au/~damian/papers/PDF/SevenDeadlySins.pdf&#34;&gt;Seven Deadly Sins of Introductory Programming Language Design&lt;/a&gt;&amp;rdquo; (PDF link), syntax oddities often distract newbies from learning basic programming concepts. How much can you teach in three hours, and how much will they remember after a month without practicing?&lt;/p&gt;

&lt;p&gt;Another route would be building a graphical program that can do everything a biologist would want, where pipelines are developed by dragging and dropping icons and connectors. Unfortunately, a comprehensive graphical environment requires a major programming effort to build, and to keep current. Not only that, but the interface for such a full-featured, graphical program will necessarily be complex, raising the learning barrier.&lt;/p&gt;

&lt;p&gt;In building the Scriptome, we purposely narrowed our scope, to maximize learnability and memorability for occasional users. While teaching programming and graphical tools are effective solutions for some, I believe the Scriptome fills an empty niche in the data munging ecosphere (the greposphere?).&lt;/p&gt;

&lt;h3 id=&#34;creation-is-not-easy&#34;&gt;Creation Is Not Easy&lt;/h3&gt;

&lt;p&gt;How much progress have we made in addressing the problem space between tool use and programming? Our early reviews have been mostly positive, or at least constructive. Suzy, our first power user, started out skeptical, saying she&amp;rsquo;d probably have to learn Perl because any tools we gave her wouldn&amp;rsquo;t be flexible enough. I encouraged her to use the Scriptome in parallel with learning Perl. She ended up a self-described &amp;ldquo;Scriptome monster,&amp;rdquo; tweaking tool code and creating a 16-step protocol that did real bioinformatics. Still, one good review won&amp;rsquo;t get you any Webby awards. Our first priority at this point is to build a user base and to get feedback on the learnability, memorability, and effectiveness of the website, with its 50 or so tools.&lt;/p&gt;

&lt;p&gt;It will take more than just feedback to implement the myriad ideas we have for improving the Scriptome, which is why I&amp;rsquo;m here to make a bald-faced plea for your help. The project needs lots of new tools, new protocols, and possibly new interfaces. You, the Perl.com reader, can certainly write code for new tools; the real question is whether you (unlike certain, unnamed CPAN contributors) can also write good documentation and examples, or find bugs in early versions of tools. We would also love to get relevant protocol ideas. Check out the &lt;a href=&#34;https://bioinformatics.org/project/?group_id=505&#34;&gt;Scriptome project page&lt;/a&gt; and send something to me or the &lt;em&gt;scriptome-users&lt;/em&gt; mailing list.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a little challenge. I really did have a client who renamed 768 files by hand before I could Perl it for him. Can you write a generic renaming atom that a NPB could use? (Hint: &amp;ldquo;Tell the user to learn regular expressions&amp;rdquo; is not a valid solution.) The winner will receive a commemorative plaque (&lt;code&gt;&amp;lt;bgcolor=&amp;quot;gold&amp;quot;&amp;gt;&lt;/code&gt;) on the Scriptome website.&lt;/p&gt;

&lt;p&gt;Speaking of new interfaces, one common concern we hear from programmers is that NPBs won&amp;rsquo;t be able or willing to handle the command-line paradigm shift and the few commands needed (&lt;code&gt;cd&lt;/code&gt;, &lt;code&gt;more&lt;/code&gt;, &lt;code&gt;dir/ls&lt;/code&gt;) to use the Scriptome. In case our users do tell us it&amp;rsquo;s a problem, we&amp;rsquo;re exploring a few different ways to wrap the Scriptome tools, such as:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A Firefox plugin that gives you a command line in a toolbar and displays your output file in the browser. (Currently being developed by Rob Miller and his group at MIT.)&lt;/li&gt;
&lt;li&gt;An Excel VBA that lets you put command lines into a column, and creates a shell script out of it.&lt;/li&gt;
&lt;li&gt;Wrapping the command-line tools in &lt;a href=&#34;http://www.pasteur.fr/recherche/unites/sis/Pise/&#34;&gt;Pise&lt;/a&gt; (web forms around shell commands) or &lt;a href=&#34;http://www.genepattern.org/&#34;&gt;GenePattern&lt;/a&gt; (a more general GUI bio tool).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We&amp;rsquo;ll probably try several of these avenues, because they allow us to keep using the command-line interface if desired.&lt;/p&gt;

&lt;p&gt;As for the future, well, who says that only biologists are interested in munging tabular data? Certainly, chemists and astronomers could get into this. I set my sights even higher. How about a Scriptome for a business manager wanting to munge reports? An Apache Scriptome to munge your website&amp;rsquo;s access logs? An iTunes Scriptome to manage your music? Let&amp;rsquo;s give users the power to do what they want with their data.&lt;/p&gt;

&lt;p&gt;Sorry, &lt;em&gt;GUI Neanderthalis&lt;/em&gt;, but you can&amp;rsquo;t adapt to today&amp;rsquo;s data munging needs. Make room for &lt;em&gt;Homo Scriptiens&lt;/em&gt;!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A Chromosome at a Time with Perl, Part 1</title>
      <link>http://localhost:1313/pub/2003/09/10/bioinformatics.html/</link>
      <pubDate>Thu, 11 Sep 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/09/10/bioinformatics.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;James D. Tisdall is the author of the soon-to-be-released&lt;/em&gt; &lt;a href=&#34;http://www.oreilly.com/catalog/mperlbio/index.html?CMP=IL7015&#34;&gt;Mastering Perl for Bioinformatics&lt;/a&gt;&lt;em&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;For some time now, the use of Perl in biology has been standard practice. Perl remains the most popular language among biologists for a multitude of programming tasks. The same reasons why Perl has been a success story among system administrators, as well as one of the big success stories in the early days of the Web and CGI programming, have also made it the lingua franca of programming in biology, known as &lt;em&gt;bioinformatics&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;One of the reasons why Perl has been equally well suited to dealing with things like DNA and protein sequence data is that it&amp;rsquo;s so easy to declare and use a string. You just use it, without worrying about allocating memory, or managing memory as the string shrinks or grows. DNA and proteins and other standard biological data are almost always represented in Perl as strings, so this facility with strings translates directly into a facility with DNA and proteins.&lt;/p&gt;

&lt;p&gt;For example, say you have a subroutine &lt;code&gt;get_chromosome&lt;/code&gt; that returns a string of all the DNA in a human chromosome. In humans, this might be a string about 100Mb in length. This snippet of code calls &lt;code&gt;get_chromosome&lt;/code&gt; to initialize a scalar variable, &lt;code&gt;$chromosome1&lt;/code&gt;, with the string of DNA sequence data that summarizes human chromosome 1:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$chromosome1 = get_chromosome( 1 );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This programming is as easy as cake. I mean, simple as pie. Well, you know what I mean.&lt;/p&gt;

&lt;p&gt;But beneath this wonderful ease of programming lurks a problem. It&amp;rsquo;s a problem that can make your wonderful, intuitive code for tossing around chromosomes and genomes&amp;ndash;which looks so elegant in your printout, and which appears so neatly divided into intuitively satisfying, interacting subroutines&amp;ndash;an inefficient mess that barely runs at all, when it&amp;rsquo;s not completely clogging up your computer.&lt;/p&gt;

&lt;p&gt;So, in this short article I&amp;rsquo;ll show you a handful of tricks that enable you to write code for dealing with large amounts of biological sequence data&amp;ndash;in this case, very long strings&amp;ndash;while still getting satisfactory speed from the program.&lt;/p&gt;

&lt;h3 id=&#34;memory-is-the-bottleneck&#34;&gt;Memory is the Bottleneck&lt;/h3&gt;

&lt;p&gt;What is the problem, exactly? It usually comes down to this: by dealing with very large strings, each one of which uses a significant portion of the main memory that your computer uses to hold a running program, you can easily overtax the amount of main memory available.&lt;/p&gt;

&lt;p&gt;When a program on your computer (a &lt;em&gt;process&lt;/em&gt; on your Linux, Unix, or Mac OS X computer) runs out of main memory, its performance starts to seriously degrade. It may try to overcome the lack of fast and efficient main memory by enlisting a portion of disk space to hold the part of the running program that it can no longer fit.&lt;/p&gt;

&lt;p&gt;But when a program starts writing and reading to and from hard disk memory it can get awfully slow awfully fast. And depending on the nature of the computation, the program may start &amp;ldquo;thrashing,&amp;rdquo; that is, repeatedly writing and reading large amounts of data between main memory and hard disk. Your elegant program has turned into a greedy, lazy misanthrope that grabs up all the resources available and then seems to just sit there. You&amp;rsquo;ve created a monster!&lt;/p&gt;

&lt;p&gt;Take the snippet of code above that calls &lt;code&gt;get_chromosome&lt;/code&gt;. Without knowing anything more about the subroutine, it&amp;rsquo;s a pretty good bet that it is fetching the 100Mb of data from somewhere, perhaps a disk file, or a relational database, or a web site. To do so, it must be using at least 100Mb of memory. Then, when it returns the data to be stored in &lt;code&gt;$chromosome1&lt;/code&gt;, the program uses another 100Mb of memory. Now, perhaps you want to do a regular expression search on the chromosome, saving the desired expression with parentheses that set the special variables &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$&amp;amp;&lt;/code&gt;, and so on. These special variables can be quite large, and that means use of even more memory by your program.&lt;/p&gt;

&lt;p&gt;And since this is elegant, simple code you&amp;rsquo;ve written, you may well make other copies of the chromosome data or portions of it, in your tenacious hunt for the elusive cure for a deadly disease. The resulting code may be clear, straightforward to understand, and correct&amp;ndash;all good and proper things for code to be&amp;ndash;but the amount of string copies will land you in the soup. Not only does copying a large string take up memory, but the actual copying can itself be slow, especially if there&amp;rsquo;s a lot of it.&lt;/p&gt;

&lt;h3 id=&#34;space-efficiency&#34;&gt;Space Efficiency&lt;/h3&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;div class=&#34;secondary&#34;&gt;
&lt;h4 id=&#34;more-from-this-author&#34;&gt;More from this author&lt;/h4&gt;
&lt;p&gt;‚Ä¢ &lt;a href=&#34;http://localhost:1313/pub/2001/11/16/perlbio2.html&#34;&gt;Parsing Protein Domains with Perl&lt;/a&gt;&lt;br /&gt;
‚Ä¢ &lt;a href=&#34;http://localhost:1313/pub/2002/01/02/bioinf.html&#34;&gt;Beginning Bioinformatics&lt;/a&gt;&lt;br /&gt;
‚Ä¢ &lt;a href=&#34;http://www.oreilly.com/news/perlbio_1001.html&#34;&gt;Why Biologists Want to Program Computers&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;You may need to add a new constraint to your program design when you&amp;rsquo;ve got a large amount of data in a running program. The constraint is &lt;em&gt;&amp;ldquo;Use minimal memory.&amp;rdquo;&lt;/em&gt; Often, a program that barely runs at all and takes many hours of clogging up the computer, can be rewritten to run in a few minutes by reworking the algorithm so that it uses only a small fraction of the memory.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s a case of decreasing time by first decreasing space. (Astrophysicists, take note.)&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;There&amp;rsquo;s one easy way to cut down on the number of big strings in a program.&lt;/p&gt;

&lt;p&gt;If you need a subroutine to return a large string, as in the &lt;code&gt;get_chromosome&lt;/code&gt; subroutine I&amp;rsquo;ve used as an example, you can use &lt;em&gt;references&lt;/em&gt; to eliminate some of this memory usage.&lt;/p&gt;

&lt;p&gt;The practice of passing references to a subroutine is familiar to experienced Perl programmers. In our example, we can rewrite the subroutine so that the return value is placed into a string that is passed in as an argument. But we don&amp;rsquo;t pass a copy of the string&amp;ndash;we pass a reference to the string, which takes almost no additional space, and which still enables the subroutine to provide the entire chromosome 1 DNA to the calling program. Here&amp;rsquo;s an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;load_chromosome( 1, \$chromosome1 );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This new subroutine has two arguments. The &lt;code&gt;1&lt;/code&gt; presumably will tell the subroutine which human chromosome we want (we want the biggest human chromosome, chromosome 1).&lt;/p&gt;

&lt;p&gt;The second argument is a reference to a scalar variable. Inside the subroutine, the reference is most likely used to initialize an argument like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my($chromnumber, $chromref) = @_;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then the DNA data is put into the string by calling it &lt;code&gt;$$chromref&lt;/code&gt;, for instance like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$$chromref = &#39;ACGTGTGAACGGA&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No return value is needed. After the subroutine call, the main program will find that the contents of &lt;code&gt;$chromosome1&lt;/code&gt; have changed, and now consist of &amp;ldquo;ACGTGTGAACGGA.&amp;rdquo; (Of course, a chromosome is much longer than this little fragment.)&lt;/p&gt;

&lt;p&gt;Using references is also a great way to pass a large amount of data &lt;em&gt;into&lt;/em&gt; a subroutine without making copies of it. In this case, however, the fact that the subroutine can change the contents of the referenced data is something to watch out for. Sometimes you just want a subroutine to get to use the data, but you expect the variable containing the data to still have the same data after the subroutine gets a look at it. So you have to watch what you do when you&amp;rsquo;re passing references to data into a subroutine, and make sure you know what you want.&lt;/p&gt;

&lt;h3 id=&#34;managing-memory-with-buffers&#34;&gt;Managing Memory with Buffers&lt;/h3&gt;

&lt;p&gt;One of the most efficient ways to deal with very large strings is to deal with them a little at a time.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an example of a program for searching an entire chromosome for a particular 12-base pattern, using very little memory. (A &lt;em&gt;base&lt;/em&gt; is one of the four molecules that are the principal building blocks of DNA. The four bases are represented in Perl strings as the characters A, C, G, and T. You&amp;rsquo;ll often hear biologists talking about &amp;ldquo;megabases&amp;rdquo; instead of &amp;ldquo;megabytes&amp;rdquo; in a string. If you hear that, you&amp;rsquo;re probably talking to a bioinformatician.)&lt;/p&gt;

&lt;p&gt;When writing a program that will search for any regular expression in a chromosome, it&amp;rsquo;s hard to see how you could avoid putting the whole chromosome in a string. But very often there&amp;rsquo;s a limit to the size of what you&amp;rsquo;re searching for. In this program, I&amp;rsquo;m looking for the 12-base pattern &amp;ldquo;ACGTACGTACGT.&amp;rdquo; And I&amp;rsquo;m going to get the chromosome data from a disk file.&lt;/p&gt;

&lt;p&gt;My trick is going to be to just read in the chromosome data a line or two at a time, search for the pattern, and then &lt;em&gt;reuse&lt;/em&gt; the memory to read in the next line or two of data.&lt;/p&gt;

&lt;p&gt;The extra work I have to do in programming is, first, I need to keep track myself of how much of the data has been read in, so I can report the locations in the chromosome of successful searches. Second, I need to keep aware that my pattern might start at the end of one line and complete at the beginning of the next line, so I need to make sure I search across line breaks as well as within lines of data from the input file.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a small program that reads in a FASTA file given as an argument on the command line and searches for my pattern in any amount of DNA&amp;ndash;a whole chromosome, a whole genome, even all known genetic data, just assuming that the data is in a FASTA file named in the command line. I&amp;rsquo;ll call my program &lt;code&gt;find_fragment&lt;/code&gt;, and assuming the DNA is in a FASTA file called &lt;code&gt;human.dna&lt;/code&gt;, I&amp;rsquo;ll call it like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[tisdall@coltrane]$ perl find_fragment human.dna
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For testing purposes I made a very short FASTA DNA file, &lt;code&gt;human.dna&lt;/code&gt;, which contains:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; human dna--Not!  The fragment ACGTACGTACGT appears at positions 10, 40, and 98
AAAAAAAAAACGTACGTACGTCCGCGCGCGCGCGCGCGCACGTACGTACG
TGGGGGGGGGGGGGGGCCCCCCCCCCGGGGGGGGGGGGAAAAAAAAAACG
TACGTACGTTTTTTTTTTTTTTTTTTTTTTTTTTT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s the code for the program &lt;code&gt;find_fragment&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/perl

#
# find_fragment : find &#39;ACGTACGTACGT&#39; in a very large DNA FASTA file
# using minimal memory
#
#  N.B. This example program does no checking of the input to ensure
#       that it is DNA data in FASTA format; it just assumes that
#       it is. This program also assumes there is just one FASTA
#       record in the input file.
#
#  Copyright (c) 2003 James Tisdall
#

use warnings;
use strict;
use Carp;

# Make sure the program is called with one argument, presumably a
# FASTA file of DNA
my $USAGE = &amp;quot;perl find_fragment file.FASTA&amp;quot;;
unless(@ARGV == 1) { croak &amp;quot;$USAGE:$!\n&amp;quot; }

# $fragment: the pattern to search for
# $fraglen:  the length of $fragment
# $buffer:   a buffer to hold the DNA from the input file
# $position: the position of the buffer in the total DNA
my($fragment, $fraglen, $buffer, $position) = (&#39;ACGTACGTACGT&#39;, 12, &#39;&#39;, 0);

# The first line of a FASTA file is a header and begins with &#39;&amp;gt;&#39;
my $header = &amp;lt;&amp;gt;;

# Get the first line of DNA data, to start the ball rolling
$buffer = &amp;lt;&amp;gt;;
chomp $buffer;

# The remaining lines are DNA data ending with newlines
while(my $newline = &amp;lt;&amp;gt;) {

    # Add the new line to the buffer
    chomp $newline;
    $buffer .= $newline;

    # Search for the DNA fragment, which has a length of 12
    # (Report the character at string position 0 as being at position 1,
    # as usual in biology)
    while($buffer =~ /$fragment/gi) {
        print &amp;quot;Found $fragment at position &amp;quot;, $position + $-[0] + 1, &amp;quot;\n&amp;quot;;
    }

    # Reset the position counter (will be true after you reset the buffer, next)
    $position = $position + length($buffer) - $fraglen + 1;

    # Discard the data in the buffer, except for a portion at the end
    # so patterns that appear across line breaks are not missed
    $buffer = substr($buffer, length($buffer) - $fraglen + 1, $fraglen - 1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s the output of running the command &lt;code&gt;perl find_fragment human.dna&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Found ACGTACGTACGT at position 10
Found ACGTACGTACGT at position 40
Found ACGTACGTACGT at position 98
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;how-the-code-works&#34;&gt;How the Code Works&lt;/h3&gt;

&lt;p&gt;After the highly recommended &lt;code&gt;use strict&lt;/code&gt; and &lt;code&gt;use warnings&lt;/code&gt; are turned on, and the Carp module is loaded so the program can &amp;ldquo;croak&amp;rdquo; when needed, the program variables are declared and initialized.&lt;/p&gt;

&lt;p&gt;The first line of the FASTA file is a header and is not needed here, so it&amp;rsquo;s read and not used. Then the first line of DNA data is read into the buffer and its &lt;code&gt;newline&lt;/code&gt; character is removed. I start with this because I want to search for the fragment even if it is broken by new lines, so I&amp;rsquo;ll have to look at least at the first two lines; here I get the first line, and in the while loop that follows I&amp;rsquo;ll start by adding the second line to the buffer.&lt;/p&gt;

&lt;p&gt;Then the while loop, which does the main work of the program, starts reading in the next line of the FASTA file named on the command line, in this case the FASTA file &lt;code&gt;human.dna&lt;/code&gt;. The &lt;code&gt;newline&lt;/code&gt; is removed with &amp;ldquo;chomp,&amp;rdquo; and the new line is added to the buffer.&lt;/p&gt;

&lt;p&gt;Then comes the short while loop that does the regular expression pattern match of the &lt;code&gt;$fragment&lt;/code&gt; in the &lt;code&gt;$buffer&lt;/code&gt;. It has modifiers &amp;ldquo;g&amp;rdquo; for *g*lobal search (the fragment may appear more than once in the buffer); and &amp;ldquo;i&amp;rdquo; for case *i*nsensitive search, that is, either uppercase or lowercase DNA data (e.g. ACGT or acgt).&lt;/p&gt;

&lt;p&gt;When the fragment is found the program simply prints out the position. &lt;code&gt;$position&lt;/code&gt; holds the position of the beginning of the buffer in the total DNA, and is something I have to keep track of. &lt;code&gt;$-[0]&lt;/code&gt; is a special variable that gives the offset of the last successful pattern match in the string. I also add 1, because biologists always say that the first base in a sequence of DNA is at position 1, whereas Perl says that the first character in a string is at position 0. So I add 1 to the Perl position to get the biologist&amp;rsquo;s position.&lt;/p&gt;

&lt;p&gt;The last two lines of code reset the buffer by eliminating the beginning part of it, and then adjust the position counter accordingly. The buffer is shortened so that it just keeps the part at the very end that might be part of a pattern match that crosses over the lines of the input file. This would be the tail part of the buffer that is just one base shorter than the length of the fragment.&lt;/p&gt;

&lt;p&gt;In this way, the program keeps at most two lines&amp;rsquo; worth of DNA in &lt;code&gt;$buffer&lt;/code&gt;, but still manages to search the entire genome (or chromosome or whatever is in the FASTA file) for the fragment. It performs very quickly, compared to a program that reads in a whole genome and blows out the memory in the process.&lt;/p&gt;

&lt;h3 id=&#34;when-you-should-bother&#34;&gt;When You Should Bother&lt;/h3&gt;

&lt;p&gt;A space-inefficient program might well work fine on your better computers, but it won&amp;rsquo;t work well at all when you need to run it on another computer with less main memory installed. Or, it might work fine on the fly genome, but slow to a crawl on the human genome.&lt;/p&gt;

&lt;p&gt;The rule of thumb is that if you know you&amp;rsquo;ll be dealing with large data sets, consider the amount of space your program uses as an important constraint when designing and coding. Then you won&amp;rsquo;t have to go back and redo the entire program when a large amount of DNA gets thrown at you.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: Stay tuned for part two in this two-part series later this month. In it, James will take a more in-depth look at space efficiency, and include a more general version of a program that uses a buffer. In particular, part two will cover running subroutines with minimal space, eliminating subroutines altogether, and sequence motifs with bounded lengths.&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;O&amp;rsquo;Reilly &amp;amp; Associates will soon release (September 2003) &lt;a href=&#34;http://www.oreilly.com/catalog/mperlbio/index.html?CMP=IL7015&#34;&gt;Mastering Perl for Bioinformatics&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.oreilly.com/catalog/mperlbio/chapter/index.html?CMP=IL7015&#34;&gt;Sample Chapter 9, Introduction to Bioperl&lt;/a&gt;, is available free online.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can also look at the &lt;a href=&#34;http://www.oreilly.com/catalog/mperlbio/toc.html?CMP=IL7015&#34;&gt;Table of Contents&lt;/a&gt;, the &lt;a href=&#34;http://www.oreilly.com/catalog/mperlbio/inx.html?CMP=IL7015&#34;&gt;Index&lt;/a&gt;, and the &lt;a href=&#34;http://www.oreilly.com/catalog/mperlbio/desc.html?CMP=IL7015&#34;&gt;Full Description&lt;/a&gt; of the book.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;For more information, or to order the book, &lt;a href=&#34;http://www.oreilly.com/catalog/mperlbio/index.html?CMP=IL7015&#34;&gt;click here&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Beginning Bioinformatics</title>
      <link>http://localhost:1313/pub/2002/01/02/bioinf.html/</link>
      <pubDate>Wed, 02 Jan 2002 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2002/01/02/bioinf.html/</guid>
      <description>

&lt;p&gt;Bioinformatics, the use of computers in biology research, has been increasing in importance during the past decade as the Human Genome Project went from its beginning to the announcement last year of a &amp;ldquo;draft&amp;rdquo; of the complete sequence of human DNA.&lt;/p&gt;

&lt;p&gt;The importance of programming in biology stretches back before the previous decade. And it certainly has a significant future now that it is a recognized part of research into many areas of medicine and basic biological research. This may not be news to biologists. But Perl programmers may be surprised to find that their handsome language has become one of the most - if not &lt;em&gt;the&lt;/em&gt; most popular - of computer languages used in bioinformatics.&lt;/p&gt;

&lt;p&gt;My new book &lt;a href=&#34;http://www.oreilly.com/catalog/begperlbio/&#34;&gt;&lt;strong&gt;Beginning Perl for Bioinformatics&lt;/strong&gt;&lt;/a&gt; from &lt;em&gt;O&amp;rsquo;Reilly &amp;amp; Associates&lt;/em&gt; addresses the needs of biologists who want to learn Perl programming. In this article, I&amp;rsquo;m going to approach the subject from another, almost opposite, angle. I want to address the needs of Perl programmers who want to learn biology and bioinformatics.&lt;/p&gt;

&lt;p&gt;First, let me talk about ways to go from Perl programmer to &amp;ldquo;bioinformatician&amp;rdquo;. I&amp;rsquo;ll describe my experience, and give some ideas for making the jump. Then, I&amp;rsquo;ll try to give you a taste of modern biology by talking about some of the technology used in the sequencing of genomes.&lt;/p&gt;

&lt;h3 id=&#34;my-experience&#34;&gt;My Experience&lt;/h3&gt;

&lt;p&gt;Bioinformaticians generally have either a biology or programming background, and then receive additional training in the other field. The common wisdom is that it&amp;rsquo;s easier for biologists to pick up programming than the other way around; but, of course, it depends on the individual. How does one take the skills learned while programming in, say, the telecommunications industry, and bring them to a job programming for biology?&lt;/p&gt;

&lt;p&gt;I used to work at Bell Labs in Murray Hill, N.J., in the Speech Research Department. It was my first computer programming job; I got to do stuff with computer sound, and learn about speech science and linguistics as well. I also got to do some computer music on the side, which was fantastic for me. I became interested in the theory of computer science, and entered academia full time for a few years.&lt;/p&gt;

&lt;p&gt;When it became time for me to get back to a regular salary, the Human Genome Project had just started a bioinformatics lab at the university where I was studying. I had a year of molecular biology some years before as an undergraduate, but that was before the PCR technique revolutionized the field. At that time, I read Watson&amp;rsquo;s classic &amp;ldquo;The Molecular Biology of the Gene&amp;rdquo; and so I had an inkling about DNA, which probably helped, and I knew I liked the subject. I went over to meet the directors and leveraged my Unix and C and Bell Labs background to get a job as the systems manager. (PCR, the polymerase chain reaction, is the way we make enough copies (&amp;ldquo;clones&amp;rdquo;) of a stretch of DNA to be able to do experiments on it. After learning the basics of DNA &amp;ndash; keep reading! &amp;ndash; PCR would be a great topic to start learning about molecular biology techniques. I&amp;rsquo;ll explain how in just a bit.)&lt;/p&gt;

&lt;p&gt;In my new job I started working with bioinformatics software, both supporting and writing it. In previous years, I&amp;rsquo;d done practically no programming, having concentrated on complexity theory and parallel algorithms. Now I was plunged into a boatload of programming &amp;ndash; C, Prolog, Unix shell and FORTRAN were the principal languages we used. At that time, just as I was starting the job, a friend at the university pressed his copy of &lt;a href=&#34;http://oreilly.com/catalog/pperl3/&#34;&gt;Programming Perl&lt;/a&gt; into my hands. It made a strong impression on me, and in short order I was turning to Perl for most of the programming jobs I did.&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;a href=&#34;http://conferences.oreilly.com/biocon/&#34;&gt;O&amp;#39;Reilly Bioinformatics Technology Conference&lt;/a&gt;
&lt;p&gt;Don&#39;t miss the &lt;a href=&#34;http://conferences.oreillynet.com/cs/bio2002/view/e_sess/1935&#34;&gt;Beginning Perl for Bioinformatics session&lt;/a&gt;, Monday, January 28, 2002, at the &lt;a href=&#34;http://conferences.oreilly.com/biocon/&#34;&gt;O&#39;Reilly Bioinformatics Technology Conference&lt;/a&gt;.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;I also started hanging out with the genome project people. I took some graduate courses in human genetics and molecular biology, which helped me a lot in understanding what everyone around me was doing.&lt;/p&gt;

&lt;p&gt;After a few years, when the genome project closed down at my university, I went to other organizations to do bioinformatics, first at a biotech startup, then at a national comprehensive cancer center, and now consulting for biology researchers. So that&amp;rsquo;s my story in a nutshell, which I offer as one man&amp;rsquo;s path from programming to bioinformatics.&lt;/p&gt;

&lt;h3 id=&#34;bringing-programming-to-biology&#34;&gt;Bringing Programming to Biology&lt;/h3&gt;

&lt;p&gt;Especially now that bioinformatics is seen as an important field, many biology researchers are adding bioinformatics to their grant proposals and research programs. I believe the kind of path that I took is even more possible now than then, simply due to the amount of bioinformatics funding and jobs that are now staffed. Find biology research organizations that are advertising for programmers, and let them know you have the programming skills and the interest in biology that would make you an asset to their work.&lt;/p&gt;

&lt;p&gt;But what about formal training? It&amp;rsquo;s true that the ideal bioinformatician has graduate degrees in both computer science and biology. But such people are extremely rare. Most workers in the field have a good mix of computer and biology skills, but their degrees tend to come from one or the other. Still, formal training in biology is a good way for a computer programmer to learn about bioinformatics, either preceding or concurrently with a job in the field.&lt;/p&gt;

&lt;p&gt;I can understand the reluctance to face another degree. (I earned my degrees with a job and a family to support, and it was stressful at times.) Yes, it is best to get a degree if you&amp;rsquo;re going to be working in biology. A masters degree is OK, but most of the best jobs go to those who have their doctrate degree. They are, however, in ample supply and often get relatively low pay, as in postdoc positions that are frequently inhabited for many years. So the economic benefit of formal training in biology is not great, compared to what you may be earning as a computer expert. But at present bioinformatics pays OK.&lt;/p&gt;

&lt;p&gt;On the other hand, to really work in biology, training is a good thing. It&amp;rsquo;s a deep subject, and in many ways quite dissimilar to computer science or electrical engineering or similar fields. It has many surprises, and the whole &amp;ldquo;wet lab&amp;rdquo; experimental approach is hard to get out of books.&lt;/p&gt;

&lt;p&gt;For self-study, there&amp;rsquo;s one book that I think is a real gem for Perl programmers who want to learn about modern biology research. The book is called &amp;ldquo;Recombinant DNA,&amp;rdquo; by the co-discoverer of the structure of DNA, James Watson, and his co-authors Gilman, Witkowski, Zoller, and Witkowski. The book was deliberately written for a wide audience, so you can start at the beginning with an explanation of what, exactly, are DNA and proteins, the two most important types of molecules in biology. But it goes on to introduce a wide range of fundamental topics in biology research, including explanations of the molecular biology laboratory techniques that form the basis of the revolution and the golden age in biology that we&amp;rsquo;re now experiencing. I particularly like the use of illustrations to explain the techniques and the biology &amp;ndash; they&amp;rsquo;re outstanding. In my jobs as manager of bioinformatics, I&amp;rsquo;ve always strongly urged the programmers to keep the book around and to dip into it often.&lt;/p&gt;

&lt;p&gt;The book does have one drawback, however. It was published in 1992. Ten years is as long in biology as it is in computer technology; so &amp;ldquo;Recombinant DNA&amp;rdquo; will not go into newer stuff such as microarrays or SNPs. (And don&amp;rsquo;t get the even earlier &amp;ldquo;Recombinant DNA: A Short Course&amp;rdquo; &amp;ndash; the 1992 edition is the one to get for now.) But what it does give you is a chance to really understand the fundamental techniques of modern molecular biology; and if you want to bring your Perl programming expertise to a biology research setting, then this is a great way to get a good start getting the general idea.&lt;/p&gt;

&lt;p&gt;There are a few other good books out, and several more coming during the next year, in the bioinformatics field. Waterman; Mount; Grant and Ewens; Baxevanis et al, and Pevzner are a few of the most popular books (some more theoretical than others). My book, although for beginning programmers, may be helpful in the later chapters to get an idea of basic biological data and programs. Gibas and Jambeck&amp;rsquo;s book &lt;a href=&#34;http://www.oreilly.com/catalog/bioskills/&#34;&gt;Developing Bioinformatics Computer Skills&lt;/a&gt; gives a good overview of much of the software and the general computational approach that&amp;rsquo;s used in bioinformatics, although it also includes some beginning topics unsuitable for the experienced programmer.&lt;/p&gt;

&lt;p&gt;Of all the bioinformatics programs that one might want to learn about, the Perl programmer will naturally gravitate toward the Bioperl project. This is an open-source, international collaborative effort to write useful Perl bioinformatics modules, and it has reached a point during the past few years where it is quite useful stuff. The 1.0 release may be available by the time you read this. Exploring this software, available at &lt;a href=&#34;http://www.bioperl.org&#34;&gt;http://www.bioperl.org&lt;/a&gt;, is highly recommended, with one caveat: It does not include much tutorial material, certainly not for teaching basic biology concepts. Still, you&amp;rsquo;ll find lots of great stuff to explore and use in Bioperl. It&amp;rsquo;s a must for the Perl bioinformatician.&lt;/p&gt;

&lt;p&gt;Apart from self-study, you may also want to try to get into some seminars or reading groups at the local university or biotech firm, or generally meet people. If you&amp;rsquo;re job hunting, then you may want to go introduce yourself to the head of the biology department at the U, and let her (yes, there are a lot of women working in biology research, a much better situation than in programming) &amp;ndash; know that you want a bioinformatics job and that you are a wizard at 1) programming in general, 2) Web programming, and 3) getting a lot out of computers for minimal money. But be prepared for them to have sticker shock when it comes to salaries. Maybe it&amp;rsquo;s getting a little better now, but I&amp;rsquo;ve often found that biologists want to pay you about half of what you&amp;rsquo;re worth on the market. Their pay level is just lower than that in computer programming. When you get to that point, you might have to be a bit hardnosed during salary negotiations to maintain your children&amp;rsquo;s nutritional requirements.&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t know of a book or training program that&amp;rsquo;s specifically targeted at programmers interested in learning about biology. However, many universities have started offering bioinformatics courses, training programs, and even degrees, and some of their course offerings are designed for the experienced programmer. You might consider attending one of the major bioinformatics conferences. However, there will be a tutorial aimed at you in the &lt;a href=&#34;http://conferences.oreilly.com/biocon/&#34;&gt;upcoming O&amp;rsquo;Reilly bioinformatics conference&lt;/a&gt; &amp;ndash; indeed, the main focus of that conference is from the programming side more than the biology side.&lt;/p&gt;

&lt;p&gt;Apart from the upcoming O&amp;rsquo;Reilly conference already mentioned, there is the &lt;a href=&#34;http://www.ismb.org&#34;&gt;ISMB conference&lt;/a&gt;, the largest in the bioinformatics field, which is in Calgary this coming summer; a good place to meet people and learn. It will also play host to the Bioperl yearly meeting, which is directly on target. Actually, if you check out the presenters at the ISMB, RECOMB or O&amp;rsquo;Reilly conferences, then you will find computer science people who are specializing in biology-related problems, as well as biologists specializing in infomatics, and many of these will be many of these will be lab heads or managers who maintain staffs of programmers.
The thing about biology is that it&amp;rsquo;s a very large area. Most researchers stake out a claim to some particular system &amp;ndash; say, the regulation of nervous system development in the fly &amp;ndash; and work there. So it&amp;rsquo;s hard to really prepare yourself for the particular biology you might find on the job. The &amp;ldquo;Recombinant DNA&amp;rdquo; book will give you an overview of some of the more important techniques that are commonly used in most labs.&lt;/p&gt;

&lt;h3 id=&#34;a-taste-of-molecular-biology&#34;&gt;A Taste of Molecular Biology&lt;/h3&gt;

&lt;p&gt;Now that I&amp;rsquo;ve given you my general take on how a Perl programmer could move into biology research, I&amp;rsquo;ll turn my attention to two basic molecular biology techniques that are fundamental in biology research, as for instance in the Human Genome Project: restriction enzymes and cloning with PCR.&lt;/p&gt;

&lt;p&gt;First, we have to point out that the two most important biological molecules, DNA and proteins, are both polymers, which are chains of smaller building block molecules. DNA is made out of four building blocks, the nucleotides or &amp;ldquo;bases&amp;rdquo;; proteins are made from 20 amino acids. DNA has a regular structure, usually the famous double helix of two complementary strands intertwined; whereas proteins fold up in a wide variety of ways that have an important effect on what the proteins are able to do inside the cell. DNA is the primary genetic material that transmits traits to succeeding generations. Finally, DNA contains the coded templates from which proteins are made; and proteins accomplish much of the work of the cell.&lt;/p&gt;

&lt;p&gt;One important class of proteins are &lt;em&gt;enzymes&lt;/em&gt;, which promote certain specific chemical reactions in the cell. In 1978 the Nobel Prize was awarded to Werner Arber, Daniel Nathans, and Hamilton Smith for their discovery and work on &lt;em&gt;restriction enzymes&lt;/em&gt; in the 1960s and early 1970s. Restriction enzymes are a large group of enzymes that have the useful property of cutting DNA at specific locations called &lt;em&gt;restriction sites&lt;/em&gt;. This has been exploited in several important ways. It has been an important technique in &lt;em&gt;fingerprinting&lt;/em&gt; DNA, as is used in forensic science to identify individuals. It has been instrumental in developing &lt;em&gt;physical maps&lt;/em&gt;, which are known positions along DNA and are used to zero in on the location of genes, and also serve as a reference point for the lengthy process of the determination of the entire sequence of bases in DNA.&lt;/p&gt;

&lt;p&gt;Restriction enzymes are fundamental to modern biological research. To learn more about them, you could go to the &lt;a href=&#34;http://www.neb.com/rebase%20&#34;&gt;REBASE&lt;/a&gt; restriction enzyme database where detailed information about all known restriction enzymes is collected. Many of them are easily ordered from supply houses for use in the lab.&lt;/p&gt;

&lt;p&gt;One of the most common restriction enzymes is called EcoRI. When it finds the six bases GAATTC along a strand of DNA, it cleaves the DNA.&lt;/p&gt;

&lt;p&gt;The other main technique I want to introduce is one already mentioned: PCR, or the polymerase chain reaction. This is the most important way that DNA samples are cloned, that is, have copies made. PCR is very powerful at this; in a short time many millions of copies of a stretch of DNA can be created, at which point there is enough of a &amp;ldquo;sample&amp;rdquo; of the DNA to perform other molecular biology experiments, such as determining what exactly is the sequence of bases in the DNA (as has been accomplished for humans in the Human Genome Project.)&lt;/p&gt;

&lt;p&gt;PCR also won a Nobel prize for its invention, by Kary Mullis in 1983. The basic idea is quite simple. We&amp;rsquo;ve mentioned that the two intertwined strands of the double helix of DNA are complementary. They are different, but given one strand we know what the other strand is, as they always pair in a specific way. PCR exploits this property.&lt;/p&gt;

&lt;h3 id=&#34;motivation&#34;&gt;Motivation&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s clear that a short article is not going to get very far in introducing a major science such as biology. But I hope I&amp;rsquo;ve given you enough pointers to enable you to make a good start at learning about this explosive science, and about how a Perl programmer might be able to bring needed skills to the great challenge of understanding life and curing disease.&lt;/p&gt;

&lt;p&gt;In the 10 years I&amp;rsquo;ve been working in biology, I&amp;rsquo;ve found it to be a really exciting field, very stimulating intellectually; and I&amp;rsquo;ve found that going to work to try to help to cure cancer, Alzheimer&amp;rsquo;s disease, and others, has been very satisfying emotionally.&lt;/p&gt;

&lt;p&gt;I wish you the very best of luck. If you make it to the &lt;a href=&#34;http://conferences.oreilly.com/biocon/&#34;&gt;O&amp;rsquo;Reilly conference&lt;/a&gt;, please look me up!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

