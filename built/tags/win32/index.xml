<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Win32 on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/win32/</link>
    <description>Recent content in Win32 on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 11 Dec 2014 14:44:25 +0000</lastBuildDate>
    <atom:link href="/tags/win32/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Automated Internet Explorer screenshots using Win32::OLE</title>
      <link>http://localhost:1313/article/139/2014/12/11/Automated-Internet-Explorer-screenshots-using-Win32--OLE/</link>
      <pubDate>Thu, 11 Dec 2014 14:44:25 +0000</pubDate>
      
      <guid>http://localhost:1313/article/139/2014/12/11/Automated-Internet-Explorer-screenshots-using-Win32--OLE/</guid>
      <description>

&lt;h3 id=&#34;background&#34;&gt;Background&lt;/h3&gt;

&lt;p&gt;Some time ago I &lt;a href=&#34;http://blog.nu42.com/2012/06/using-win32ole-with-events-to-capture.html&#34;&gt;wrote&lt;/a&gt; about using Perl&amp;rsquo;s Win32::OLE to drive Internet Explorer in response to a &lt;a href=&#34;http://stackoverflow.com/a/11220026/100754&#34;&gt;question&lt;/a&gt; on Stackoverflow.&lt;/p&gt;

&lt;p&gt;At the time I was still clinging to Windows XP. Since then, I have upgraded to Windows 8.1 Pro 64-bit, and instead of using &lt;a href=&#34;http://www.activestate.com/activeperl/ppm-perl-modules&#34;&gt;PPMs&lt;/a&gt; for &lt;a href=&#34;http://www.activestate.com/activeperl&#34;&gt;ActivePerl&lt;/a&gt;, I have been using &lt;a href=&#34;http://blog.nu42.com/2014/11/64-bit-perl-5201-with-visual-studio.html&#34;&gt;Visual Studio 2013&lt;/a&gt; to build &lt;code&gt;perl&lt;/code&gt;, and the modules I need.&lt;/p&gt;

&lt;p&gt;I have been using Perl&amp;rsquo;s &lt;a href=&#34;https://metacpan.org/pod/Win32::OLE&#34;&gt;Win32::OLE&lt;/a&gt; to drive Internet Explorer for various purposes for almost 10 years now. There is really not much to it other than having to read copious amounts of Microsoft documentation. It always amazes me how, after all these years, there is no language or environment as well documented as Perl, not just in terms of the amount of information provided, but also the ease with which you can find clear, correct, and useful information.&lt;/p&gt;

&lt;p&gt;In any case, while the organization of the information leaves a lot to be desired, a good starting point for finding information on driving Internet Explorer via OLE is the InternetExplorer object &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/aa752084%28v=vs.85%29&#34;&gt;documentation&lt;/a&gt; on MSDN. If you want to interact with the content within an InternetExplorer object, you can consult the MSHTML Scripting Object Interfaces &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/hh801967%28v=vs.85%29.aspx&#34;&gt;topic&lt;/a&gt;. It also helps to know a little bit about the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/19z074ky.aspx&#34;&gt;OLE&lt;/a&gt; interface.&lt;/p&gt;

&lt;p&gt;Reading brian d foy&amp;rsquo;s article on &lt;a href=&#34;https://perltricks.com/article/138/2014/12/7/Controlling-Firefox-from-Perl&#34;&gt;controlling Firefox from Perl&lt;/a&gt;, I noticed that Win32::IE::Mechanize has disappeared from CPAN. The &lt;a href=&#34;http://www.perlmonks.org?node_id=1061372&#34;&gt;discussion on PerlMonks&lt;/a&gt; did not make much sense to me, as I remember very clearly using Win32::OLE to drive Internet Explorer 8 for a massive scraping job.&lt;/p&gt;

&lt;p&gt;I decided to look at my old screenshot utility, and see what changes were needed to get it to run on Windows 8, using Internet Explorer 10. My &lt;a href=&#34;https://gist.github.com/nanis/3dac6b386bd056095e12&#34;&gt;revised working script is available in a GitHub gist&lt;/a&gt;. Here, I am going to cover the highlights.&lt;/p&gt;

&lt;h3 id=&#34;tracing-execution&#34;&gt;Tracing execution&lt;/h3&gt;

&lt;p&gt;The idea is to use the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/aa768283%28v=vs.85%29.aspx&#34;&gt;DWebBrowserEvents2&lt;/a&gt; to figure out the right time to capture the browser window. I decided to see if my answer from 2012 still worked. I pointed it to my personal website, and it failed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Win32::OLE(0.1712) error 0x80020009: &amp;quot;Exception occurred&amp;quot;
    in METHOD/PROPERTYGET &amp;quot;StatusText&amp;quot; at iescreenshot.pl line 38.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The cause of the problem lay in accessing the &lt;code&gt;StatusText&lt;/code&gt; property of the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/aa752084%28v=vs.85%29&#34;&gt;Internet Explorer object&lt;/a&gt;. Apparently, IE10 no longer exposes this property. Well, I had only used it so as to give some idea of what was happening. I decided instead to write a quick logging function which could be used with all events:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;log_browser_event&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $event &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; shift;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;no&lt;/span&gt; warnings &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;uninitialized&amp;#39;&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $args &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; eval { join(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; map valof($_), @_) };
    say &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;$event: $args&amp;#34;&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Not an example of perfect code, but, I am trying to keep this short and sweet.&lt;/p&gt;

&lt;h3 id=&#34;event-handling&#34;&gt;Event handling&lt;/h3&gt;

&lt;p&gt;We are only interested in two events: &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/aa768282%28v=vs.85%29.aspx&#34;&gt;DocumentComplete&lt;/a&gt;, so we know when to take a screenshot, and &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/aa768340%28v=vs.85%29.aspx&#34;&gt;onQuit&lt;/a&gt;, so we can quit cleanly if the user closes the browser window before we get to that point.&lt;/p&gt;

&lt;p&gt;You initialize OLE events using the call:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;Win32::OLE&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;WithEvents(
    $object,
    $handler,
    $interface
);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then, presumably, your &lt;code&gt;$handler&lt;/code&gt; has some giant switch statement, dispatching on the basis of the actual events received. Instead, I opted for a dispatch table:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;const &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; %BrowserEvents &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; (
    DocumentComplete &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; {
        $do_take_screenshot &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        Win32::MessageLoop&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;QuitMessageLoop;
    },
    OnQuit &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; {
        $do_take_screenshot &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        Win32::MessageLoop&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;QuitMessageLoop;
    },
    _ &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; { },
);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Notice the use of &lt;a href=&#34;https://metacpan.org/pod/Win32::MessageLoop&#34;&gt;Win32::MessageLoop-&amp;gt;QuitMessageLoop&lt;/a&gt; instead of &lt;code&gt;Win32::OLE-&amp;gt;QuitMessageLoop&lt;/code&gt; to avoid spurious sleep calls.&lt;/p&gt;

&lt;p&gt;Then, I initialize the OLE events interface using:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;Win32::OLE&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;WithEvents(
    $browser,
    &lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; { $handler&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;\&lt;/span&gt;%BrowserEvents, @_) },
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;DWebBrowserEvents2&amp;#39;&lt;/span&gt;
);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;$handler&lt;/code&gt; in this case just logs the event, and consults the dispatch table to see if we are interested in the event:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;WebBrowserEventHandler&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $handlers &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; shift;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $browser &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; shift;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $event &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; shift;

    log_browser_event($event, @_);

    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $handler &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; exists $handlers&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{$event}
                ? $handlers&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{$event}
                : $handlers&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{_}
    ;
    $handler&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;($browser, $event, @_);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Upon receiving either &lt;code&gt;DocumentComplete&lt;/code&gt; or &lt;code&gt;onQuit&lt;/code&gt;, we terminate the message loop, which returns control to the navigation function. At that point, the only thing left is to check if we should capture a screenshot. After that, the program terminates.&lt;/p&gt;

&lt;h3 id=&#34;capturing-the-internet-explorer-window&#34;&gt;Capturing the Internet Explorer window&lt;/h3&gt;

&lt;p&gt;When I ran this revised script, and tried to take screenshots using &lt;a href=&#34;https://metacpan.org/pod/Imager::Screenshot&#34;&gt;Imager::Screenshot&lt;/a&gt;, I got screenshots with only the frame of the browser, and none of the content. I am not sure what&amp;rsquo;s going on, and I will try to diagnose that issue later. For now, since I was using the venerable &lt;a href=&#34;https://metacpan.org/pod/Win32::GuiTest&#34;&gt;Win32::GuiTest&lt;/a&gt; module anyway, I decided to use the &lt;code&gt;Win32::GuiTest::DibSect&lt;/code&gt; class it provides:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;take_screenshot&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $browser &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; shift;

    wait_until_ready($browser);

    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $hwnd &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; $browser&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{HWND};
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $title &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; $browser&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{Document}{title};
    $title &lt;span style=&#34;color:#f92672&#34;&gt;=~&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;s/[^A-Za-z0-9_-]+/-/g&lt;/span&gt;;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $ds &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Win32::GuiTest::DibSect&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $fgwnd &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; GetForegroundWindow();
    SetForegroundWindow $hwnd;
    $ds&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;CopyWindow($hwnd);
    SetForegroundWindow $fgwnd;

    $ds&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;SaveAs(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;$title.bmp&amp;#34;&lt;/span&gt;);
    $ds&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;Destroy;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;waiting-for-the-document-to-be-rendered&#34;&gt;Waiting for the document to be rendered&lt;/h3&gt;

&lt;p&gt;With that in place, I was still getting the occasional screenshot with a blank document area. If I understand this correctly, the fact that the &lt;code&gt;DocumentReady&lt;/code&gt; event fired does not mean the document has been fully rendered. It just means that you can manipulate the DOM. So, I added a simple spin loop for the browser to stop being &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/aa752050%28v=vs.85%29&#34;&gt;busy&lt;/a&gt;. This is by no means foolproof, but it has worked for most sites have tried. Sites with a lot of AJAXy stuff tend to have issues with this. There are site-specific ways of dealing with that, but that&amp;rsquo;s beyond the scope of this article.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;wait_until_ready&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $browser &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; shift;
    {
        local $| &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; ($browser&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;Busy) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.&amp;#39;&lt;/span&gt;;
            sleep &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        }
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;At this point, you can run the script from the command line with a simple &lt;code&gt;perl iescreenshot.pl perltricks.com&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;the-webdriver-api&#34;&gt;The WebDriver API&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/ie/dn725045%28v=vs.85%29.aspx&#34;&gt;WebDriver API&lt;/a&gt; might obviate the need for using any other solution to drive Internet Explorer, but, until that is available everywhere, &lt;a href=&#34;https://metacpan.org/pod/Win32::OLE&#34;&gt;Win32::OLE&lt;/a&gt; is more than adequate.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Using &lt;a href=&#34;https://metacpan.org/pod/Win32::OLE&#34;&gt;Win32::OLE&lt;/a&gt; to drive Internet Explorer has been very helpful to me in the past. Taking a screenshot is just a simple, proof-of-concept exercise. The beauty of using Perl is that once you reach a page containing the information you want, you can use Perl&amp;rsquo;s excellent HTML parsing modules to get exactly what you want out of it, and then, say, save it to an Excel worksheet, generate PDF document, or just stuff it in a database somewhere.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A Zero Cost Solution</title>
      <link>http://localhost:1313/pub/1998/11/article.html/</link>
      <pubDate>Tue, 17 Nov 1998 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/1998/11/article.html/</guid>
      <description>&lt;p&gt;Creating a Task Tracking System For $0 in Licensing Fees, Hardware, and Software Costs&lt;/p&gt;

&lt;p&gt;CONEXANT (formerly Rockwell Semiconductor Systems) Supply Chain Management Planning and Execution Systems needed a way to keep track of in-house tasks. When associate departments requested something be done for them, a centralized repository of their requests needed to be created for tracking and management purposes, and the ability to assign tasks to programmer/analysts needed to be integrated into this repository of data.&lt;/p&gt;

&lt;p&gt;We looked for a simple software solution to meet our needs with no luck. There were many solutions found that did LOTS more than we needed them to do, with steep learning curves for users due to the products&amp;rsquo; complexities, and more often than not, enormous pricetags accompanied most of these products. We needed a system that could accomodate as many as 200 users down the road, and licensing fees for this quantity of users were outrageous.&lt;/p&gt;

&lt;p&gt;So I decided to build one in-house. I had a couple of criteria: 1) The system had to be able to run on both an Alpha-powered Digital Unix server, and on a Microsoft NT 4.0 server. 2) The system needed to be developed fast. Our tasks were piling up and the system was needed to keep track of them in a way that all concerned could get at the data, search it, assign tasks from it, modify it, etc.&lt;/p&gt;

&lt;p&gt;Enter Perl. I&amp;rsquo;d been using it for basic CGI for a little over 6 months, mainly to dynamically generate web pages from text files FTP&amp;rsquo;d to me by Oracle database queries. Open a filehandle, read in the text file, process a few loops, and print some HTML. I looked around the web for a simple text database management system, found a couple, but didn&amp;rsquo;t understand how the programmers had come up with the code I saw. I&amp;rsquo;m still learning the basics of Perl, and figured I could try to code a solution that would do the job we needed done, and I could learn a lot in the process!&lt;/p&gt;

&lt;p&gt;Perl amazed me. I was able to logically think of what I wanted to do, and the language allowed me to stumble and fall gracefully as the solution quickly came together. It was actually very fun to do! I worked with &lt;em&gt;Learning Perl&lt;/em&gt;, &lt;em&gt;Programming Perl&lt;/em&gt;, and &lt;em&gt;Effective Perl Programming&lt;/em&gt; close at hand, and only needed one trip to the Perl newsgroup to ask a silly question, which was very promptly and courteously answered.&lt;/p&gt;

&lt;p&gt;I got the majority of the basic add, delete, modify, search and assign (email) process written in about a week, and from start to completely finished product, it took me only 4 weeks. I must thank Matt Wright for his &lt;a href=&#34;http://www.worldwidemart.com/scripts/&#34;&gt;FormMail&lt;/a&gt; Perl script that I use on the Alpha for form to email processing in the &amp;ldquo;assign task&amp;rdquo; code.&lt;/p&gt;

&lt;p&gt;The Home screen greets the user, and lets them know they can use any browser they wish to use the system, and a few other minor tidbits.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1998_11_article/home.gif&#34; alt=&#34;Home Screen&#34; width=&#34;330&#34; height=&#34;226&#34; /&gt;
&lt;strong&gt;Home screen&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The Add screen is where a new task is added to the database. The database is an ASCII text delimited file, and I provide a link to it on the Home screen so that users can download it and play in Access or Excel or whatever. Drop down menus were built with as much information as possible to make data entry easier on the users throughout the system.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1998_11_article/add.gif&#34; alt=&#34;Add Screen&#34; width=&#34;449&#34; height=&#34;279&#34; /&gt;
&lt;strong&gt;Add screen&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The Delete screen is presented when the delete menu item is selected. A radio button allows the user to select which task record is to be deleted.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1998_11_article/delete.gif&#34; alt=&#34;Delete Screen&#34; width=&#34;450&#34; height=&#34;338&#34; /&gt;
&lt;strong&gt;Delete screen&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The first Modify screen is similiar to the Delete screen&amp;hellip;a radio button selects the task record for modification.&lt;/p&gt;

&lt;p&gt;The second Modification screen brings the record back to textboxes, where the user can modify fields and the information is written back to the database.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1998_11_article/modify.gif&#34; alt=&#34;The second modify screen&#34; width=&#34;418&#34; height=&#34;278&#34; /&gt;
&lt;strong&gt;Second modify screen&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The first Assign screen is similiar to the Delete screen&amp;hellip;a radio button selects the task record for assignment.&lt;/p&gt;

&lt;p&gt;The second Assign screen brings the record back to the user, where after review the user selects the task recipient from a drop down menu, and identifys themself from another drop down menu. When the &amp;ldquo;Assign Task&amp;rdquo; button is pressed, the record data is passed to the sendmail daemon on the Alpha through Matt Wright&amp;rsquo;s FormMail script.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1998_11_article/assign.gif&#34; alt=&#34;Second assignment screen&#34; width=&#34;449&#34; height=&#34;246&#34; /&gt;
&lt;strong&gt;Second assign screen&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The Search screen facilitates entry of data for search on a single field in the database. (As I learn more Perl, I&amp;rsquo;ll add the ability to search on more than one field at a time, but this works for now!)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1998_11_article/search.gif&#34; alt=&#34;Search screen&#34; width=&#34;316&#34; height=&#34;262&#34; /&gt;
&lt;strong&gt;Search screen&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;And finally there is a Show All function, returning all records.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1998_11_article/showall.gif&#34; alt=&#34;Show all screen&#34; width=&#34;450&#34; height=&#34;338&#34; /&gt;
&lt;strong&gt;Show All screen&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The program is currently running on Gurusamy Sarathy&amp;rsquo;s 5.004_02 Win32 binary distribution on a NT 4.0 server, and works great! It was fun to write, and I suspect I&amp;rsquo;ll be fiddling with it, adding capabilties as the users request them, for some time to come. Big thanks to all the Perl community for helping to develop such a great tool for rapid application development, a tool easily learned, and very forgiving to us Perl newbies!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

