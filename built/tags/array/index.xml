<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Array on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/array/</link>
    <description>Recent content in Array on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 24 Oct 2014 12:42:52 +0000</lastBuildDate>
    <atom:link href="/tags/array/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Perl&#39;s versatile split function</title>
      <link>http://localhost:1313/article/121/2014/10/24/Perl-s-versatile-split-function/</link>
      <pubDate>Fri, 24 Oct 2014 12:42:52 +0000</pubDate>
      
      <guid>http://localhost:1313/article/121/2014/10/24/Perl-s-versatile-split-function/</guid>
      <description>

&lt;p&gt;I love Perl&amp;rsquo;s &lt;a href=&#34;https://perldoc.perl.org/functions/split.html&#34;&gt;split&lt;/a&gt; function. Far more powerful than its feeble cousin &lt;a href=&#34;https://perldoc.perl.org/functions/join.html&#34;&gt;join&lt;/a&gt;, split has some wonderful features that should make it a regular feature of any Perl programmer&amp;rsquo;s toolbox. Let&amp;rsquo;s look at some examples.&lt;/p&gt;

&lt;h3 id=&#34;split-a-sentence-into-words&#34;&gt;Split a sentence into words&lt;/h3&gt;

&lt;p&gt;To split a sentence into words, you might think about using a whitespace regex pattern like &lt;code&gt;/\s+/&lt;/code&gt; which splits on contiguous whitespace. Split will ignore trailing whitespace, but what if the input string has &lt;em&gt;leading&lt;/em&gt; whitespace? A better option is to use a single space string: &lt;code&gt;&#39; &#39;&lt;/code&gt;. This is a special case where Perl emulates awk and will split on all contiguous whitespace, trimming any leading or trailing whitespace as well.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @words &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; split &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;, $sentence;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Or loop through each word and do something:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5.010&lt;/span&gt;;
say &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (split &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; 12 Angry Men &amp;#39;&lt;/span&gt;);
&lt;span style=&#34;color:#75715e&#34;&gt;# 12&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# Angry&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# Men&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The single-space pattern is also the default pattern for &lt;code&gt;split&lt;/code&gt;, which by default operates on &lt;code&gt;$_&lt;/code&gt;. This can lead to some seriously minimalist code. For example if I needed to split every name in a list of full names and do something with them:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (@full_names)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (split)
    {
        &lt;span style=&#34;color:#75715e&#34;&gt;# do something&lt;/span&gt;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And who says Perl looks like line noise?&lt;/p&gt;

&lt;h3 id=&#34;create-a-char-array&#34;&gt;Create a char array&lt;/h3&gt;

&lt;p&gt;To split a word into separate letters, just pass an empty regex &lt;code&gt;//&lt;/code&gt; to split:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @letters &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; split &lt;span style=&#34;color:#e6db74&#34;&gt;//&lt;/span&gt;, $word;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;parse-a-url-or-filepath&#34;&gt;Parse a URL or filepath&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s tempting to reach for a regex when parsing strings, but for URLs or filepaths &lt;code&gt;split&lt;/code&gt; usually works better. For example if you wanted to get the parent directory from a filepath:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @directories &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; split &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/home/user/documents/business_plan.ods&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $parent_directory &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; $directories[&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;];&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here I split the filepath on slash and use the negative index &lt;code&gt;-2&lt;/code&gt; to get the parent directory. The challenge with filepaths is that they can have n depth, but the parent directory of a file will always be the last but one element of a filepath, so &lt;code&gt;split&lt;/code&gt; works well.&lt;/p&gt;

&lt;h3 id=&#34;extract-only-the-first-few-columns-from-a-separated-file&#34;&gt;Extract only the first few columns from a separated file&lt;/h3&gt;

&lt;p&gt;How many times have you parsed a comma separated file, but didn&amp;rsquo;t want all of the columns in the file? Let&amp;rsquo;s say you wanted the first 3 columns from a file, you might do it like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;lt;$read_file&amp;gt;&lt;/span&gt;
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @columns &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; split &lt;span style=&#34;color:#e6db74&#34;&gt;/,/&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $name    &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; $columns[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;];
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $email   &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; $columns[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $account &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; $columns[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;];
    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is all well and good, but &lt;code&gt;split&lt;/code&gt; can return a limited number of results if you want:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;lt;$read_file&amp;gt;&lt;/span&gt;
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; ($name, $email, $account) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; split &lt;span style=&#34;color:#e6db74&#34;&gt;/,/&lt;/span&gt;;
    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Or to revisit an earlier example, splitting on whitespace:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (@full_names)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; ($firstname, $lastname) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; split;
    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;These are just a few examples of Perl&amp;rsquo;s versatile &lt;code&gt;split&lt;/code&gt; function. Check out the official documentation &lt;a href=&#34;https://perldoc.perl.org/functions/split.html&#34;&gt;online&lt;/a&gt; or via the terminal with &lt;code&gt;$ perldoc -f split&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Perl references: create, dereference and debug with confidence</title>
      <link>http://localhost:1313/article/80/2014/3/27/Perl-references--create--dereference-and-debug-with-confidence/</link>
      <pubDate>Thu, 27 Mar 2014 18:03:49 +0000</pubDate>
      
      <guid>http://localhost:1313/article/80/2014/3/27/Perl-references--create--dereference-and-debug-with-confidence/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Learning Perl&amp;rsquo;s references is a rite-of-passage for Perl programmers. Until you &amp;ldquo;get&amp;rdquo; references, large parts of the language will remain alien to you. References have their own special syntax and rules, which can make them seem strange and hard to understand. The good news is that the core features of references are easy to learn and use. This article describes the main ways to use references and some handy tools to get you out of trouble if you run into it. So even if you&amp;rsquo;re not completely comfortable with references, you&amp;rsquo;ll be able to write code that works.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;what-are-references&#34;&gt;What are references?&lt;/h3&gt;

&lt;p&gt;A reference is a scalar variable whose value is a pointer to another Perl variable. If you were to print out a reference, you would see something like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;SCALAR(&lt;span style=&#34;color:#ae81ff&#34;&gt;0x509ea0&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The value looks like a memory address, bu it&amp;rsquo;s actually an internal key for Perl, which points to another variable. A reference can refer to any of Perl&amp;rsquo;s variable types: scalars, arrays, hashes, filehandles, subroutines and globs. References are useful because they:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;save memory - why create two copies of the same variable when you only need one?&lt;/li&gt;
&lt;li&gt;enable subroutines to return values that are not in a scalar or list format. (the reference is a scalar pointer to values that can be in any kind of format).&lt;/li&gt;
&lt;li&gt;can encapsulate complex data structures comprising of nested arrays, hashes, scalars and more.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Accessing the value that a reference points to is called &amp;ldquo;dereferencing&amp;rdquo;. When you dereference a reference, instead of returning the value of it&amp;rsquo;s pointer, Perl will fetch the actual variable that the reference is pointing to. The need to dereference a reference variable in order to use it&amp;rsquo;s underlying value is the main disadvantage of references; direct variable access will always be faster.&lt;/p&gt;

&lt;h3 id=&#34;declaring-and-accessing-references&#34;&gt;Declaring and accessing references&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;re going to focus on array and hash references as those are the most commonly encountered reference types. Working them is easy. For arrays, use square brackets instead of parentheses to declare, and the arrow operator (&amp;ldquo;-&amp;gt;&amp;rdquo;) to dereference:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @array       &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;apple&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;banana&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;pear&amp;#39;&lt;/span&gt;);
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $array_ref   &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;apple&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;banana&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;pear&amp;#39;&lt;/span&gt;];

&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; $array[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];       &lt;span style=&#34;color:#75715e&#34;&gt;#banana&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; $array_ref&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]; &lt;span style=&#34;color:#75715e&#34;&gt;#banana&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For hashes, use curly braces instead of parentheses to declare, and the same arrow operator to dereference:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; %hash        &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (one &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, two &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, three &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;);
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $hash_ref    &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {one &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, two &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, three &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;};

&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; $hash{three};       &lt;span style=&#34;color:#75715e&#34;&gt;#3&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; $hash_ref&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{three}; &lt;span style=&#34;color:#75715e&#34;&gt;#3&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;One of the coolest things about references is the ability to create complex data structures to hold any kind of data you need. Let&amp;rsquo;s look at a more realistic data structure for a fictional customer:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $customer &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; { name   &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Mr Smith&amp;#39;&lt;/span&gt;,
                 dob    &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;01/18/1987&amp;#39;&lt;/span&gt;,
                 phones &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; { home   &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;212-608-5787&amp;#39;&lt;/span&gt;,
                             work   &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;347-558-0352&amp;#39;&lt;/span&gt;},
                 last_3_purchase_values &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; [ &lt;span style=&#34;color:#ae81ff&#34;&gt;78.92&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;98.36&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;131.00&lt;/span&gt; ],
                 addresses &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; [ {   street &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;37 Allright Ave&amp;#39;&lt;/span&gt;,
                                    zip    &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;11025&amp;#39;&lt;/span&gt;,
                                    city   &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;New York&amp;#39;&lt;/span&gt;,
                                    state  &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;NY&amp;#39;&lt;/span&gt;,
                                },
                                {   street &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;23 Broadway&amp;#39;&lt;/span&gt;,
                                    zip    &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;10125&amp;#39;&lt;/span&gt;,
                                    city   &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;New York&amp;#39;&lt;/span&gt;,
                                    state  &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;NY&amp;#39;&lt;/span&gt;,
                                },
                               ],
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;$customer is a hash ref with 5 keys. Two of the keys (&amp;ldquo;name&amp;rdquo; and &amp;ldquo;dob&amp;rdquo;) have the usual scalar values. The other key values though are nested references: &amp;ldquo;phones&amp;rdquo; is a nested hashref, and &amp;ldquo;last_3_purchase_values&amp;rdquo; and &amp;ldquo;addresses&amp;rdquo; are arrayrefs. So how would you access any of the values in $customer data structure? Check this out:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; $customer&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{name}; &lt;span style=&#34;color:#75715e&#34;&gt;# Mr Smith&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; $customer&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{phones}{home}; &lt;span style=&#34;color:#75715e&#34;&gt;# 212-608-5787&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; $customer&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{last_3_purchase_values}[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]; &lt;span style=&#34;color:#75715e&#34;&gt;# 78.92&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; $customer&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{addresses}[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]{street}; &lt;span style=&#34;color:#75715e&#34;&gt;# 23 Broadway&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To dereference a value in $customer, we start by using the arrow operator. From there, we add the required key or index to access the next level of data. The main challenge when working with references is to understand the datatype you are dereferencing: if it is an array, you&amp;rsquo;ll need to use the array accessor syntax &amp;ldquo;[#]&amp;ldquo;, whereas if it&amp;rsquo;s a hash, you need to pass the key in curly braces &amp;ldquo;{key_value}&amp;ldquo;.&lt;/p&gt;

&lt;h3 id=&#34;working-with-arrayrefs&#34;&gt;Working with arrayrefs&lt;/h3&gt;

&lt;p&gt;Sometimes you&amp;rsquo;ll need to loop through an arrayref. The syntax for this is the same as an ordinary array, except that you need to dereference the entire array, rather than a single element of it. This is done by enclosing the arrayref in with a dereferencing array block: &amp;ldquo;@{ $array_ref }&amp;ldquo;. Let look at some examples using $customer&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; feature &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;say&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#75715e&#34;&gt;#iterate through a nested array&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;foreach&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $purchase_value (@{ $customer&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{last_3_purchase_values} }) {
    say $purchase_value;
}

&lt;span style=&#34;color:#75715e&#34;&gt;#iterate through a nested array and dereference and print the street&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;foreach&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $address (@{ $customer&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{addresses} }) {
    say $address&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{street};
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Arrays support other operations like push and shift. In these cases you will need a dereferencing array block too:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;push @{$customer&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{addresses}}, { street &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;157 Van Cordant Street&amp;#39;&lt;/span&gt;,
                                  zip    &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;10008&amp;#39;&lt;/span&gt;,
                                  city   &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;New York&amp;#39;&lt;/span&gt;,
                          state  &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;NY&amp;#39;&lt;/span&gt;,
                                 };&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here we have pushed a new address on to the &amp;ldquo;addresses&amp;rdquo; arrayref. We used a dereferencing array block to dereference &amp;ldquo;addresses&amp;rdquo; so that we could perform a push on it.&lt;/p&gt;

&lt;h3 id=&#34;working-with-hashrefs&#34;&gt;Working with hashrefs&lt;/h3&gt;

&lt;p&gt;Dereferencing blocks can be used for hash operations too. Probably the most common operation is looping through the keys of the hash, using the &amp;ldquo;keys&amp;rdquo; function. In this case, you&amp;rsquo;ll need to use a dereferencing hash block &amp;ldquo;%{ $hash_ref }&amp;ldquo;. Let&amp;rsquo;s look at an example using $customer:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; feature &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;say&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#75715e&#34;&gt;# iterate through a nested hash&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;foreach&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $key (keys %{ $customer&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{phones} }) {
    say $customer&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{phones}{$key};
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;troubleshooting-references&#34;&gt;Troubleshooting References&lt;/h3&gt;

&lt;p&gt;References can be harder to debug than normal variables as you need to dereference the reference in order to see what variable it is pointing to. Imagine you wanted to print out the contents of $customer. This doesn&amp;rsquo;t work:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; $customer; &lt;span style=&#34;color:#75715e&#34;&gt;# HASH(0x2683b30)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Fortunately you can use Data::Dumper&amp;rsquo;s &amp;ldquo;Dumper&amp;rdquo; function to dereference and pretty-print a reference for you:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Data::Dumper;

&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; Dumper($customer);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Would print:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$VAR1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
          &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;last_3_purchase_values&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; [
                                        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;78.92&amp;#39;&lt;/span&gt;,
                                        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;98.36&amp;#39;&lt;/span&gt;,
                                        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;131&amp;#39;&lt;/span&gt;
                                      ],
          &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;dob&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;01/18/1987&amp;#39;&lt;/span&gt;,
          &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;addresses&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; [
                           {
                             &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;city&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;New York&amp;#39;&lt;/span&gt;,
                             &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;zip&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;11025&amp;#39;&lt;/span&gt;,
                             &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;street&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;37 Allright Ave&amp;#39;&lt;/span&gt;,
                             &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;state&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;NY&amp;#39;&lt;/span&gt;
                           },
                           {
                             &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;city&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;New York&amp;#39;&lt;/span&gt;,
                             &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;zip&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;10125&amp;#39;&lt;/span&gt;,
                             &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;street&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;23 Broadway&amp;#39;&lt;/span&gt;,
                             &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;state&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;NY&amp;#39;&lt;/span&gt;
                           },
                           {
                             &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;city&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;New York&amp;#39;&lt;/span&gt;,
                             &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;zip&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;10008&amp;#39;&lt;/span&gt;,
                             &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;street&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;157 Van Cordant Street&amp;#39;&lt;/span&gt;,
                             &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;state&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;NY&amp;#39;&lt;/span&gt;
                           }
                         ],
          &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;name&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Mr Smith&amp;#39;&lt;/span&gt;,
          &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;phones&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
                        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;work&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;347-558-0352&amp;#39;&lt;/span&gt;,
                        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;home&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;212-608-5787&amp;#39;&lt;/span&gt;
                      }
        };&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Another useful tool is the Perl&amp;rsquo;s &lt;a href=&#34;https://perldoc.perl.org/functions/ref.html&#34;&gt;ref&lt;/a&gt; function. Just pass the reference variable into ref, and it will return which variable type the reference points to.&lt;/p&gt;

&lt;h3 id=&#34;creating-references-from-variables&#34;&gt;Creating references from variables&lt;/h3&gt;

&lt;p&gt;To create a reference to an existing variable, use the backslash operator:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $array_ref   &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;\&lt;/span&gt;@array;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $hash_ref    &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;\&lt;/span&gt;%hash;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The backslash operator often comes into play when working within a subroutine. For instance consider these three subs:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# example 1 - processor &amp;amp; memory inefficient&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;return_array&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @array &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;foreach&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $element (@array) {
        calculate($element);
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; @array;
}

&lt;span style=&#34;color:#75715e&#34;&gt;# example 2 - processor inefficient&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;return_array&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $array &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;];
    &lt;span style=&#34;color:#66d9ef&#34;&gt;foreach&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $element (@$array) {
        calculate($element);
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; $array;
}

&lt;span style=&#34;color:#75715e&#34;&gt;# example 3 - best option&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;return_array&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @array &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;foreach&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $element (@array) {
        calculate($element);
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;\&lt;/span&gt;@array;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;All of these subs are trying to do the same thing - declare an array, loop through it and then return it. Example 1 will return a list of the the array&amp;rsquo;s elements. This is inefficient as the list comprises of scalar copies of the original array&amp;rsquo;s elements, which means: Perl makes the copies, returns them and then throws away the original array when it goes out of scope.&lt;/p&gt;

&lt;p&gt;Example 2&amp;rsquo;s main drawback is that by starting with a reference, Perl has to dereference the array in order to loop though it, which is a waste of processing. Example 3 has none of these disadvantages, as it begins with an array, loops through it and then returns a reference to the array. This is a popular Perl programming pattern.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;If references were a mystery to you before, hopefully this article helps to kickstart you into using them with confidence. Are you thirsty for more references? There&amp;rsquo;s a lot more to them than described here. Check out Perl&amp;rsquo;s official documentation, perldoc which has a &lt;a href=&#34;https://perldoc.perl.org/perlreftut.html&#34;&gt;tutorial&lt;/a&gt; and more &lt;a href=&#34;https://perldoc.perl.org/perlref.html&#34;&gt;detailed guide&lt;/a&gt;. &lt;a href=&#34;http://www.amazon.com/gp/product/1449393098/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=1449393098&amp;amp;linkCode=as2&amp;amp;tag=perltrickscom-20&#34;&gt;Intermediate Perl&lt;/a&gt; is fantastic book that has over 100 pages on references (affiliate link).&lt;/p&gt;

&lt;p&gt;Enjoyed this article? Help us out and &lt;a href=&#34;https://twitter.com/intent/tweet?original_referer=http%3A%2F%2Fperltricks.com%2Farticle%2F80%2F2014%2F3%2F27%2FPerl-references-create-dereference-and-debug-with-confidence&amp;amp;text=Perl+references%3A+create%2C+dereference+and+debug+with+confidence&amp;amp;tw_p=tweetbutton&amp;amp;url=http%3A%2F%2Fperltricks.com%2Farticle%2F80%2F2014%2F3%2F27%2FPerl-references-create-dereference-and-debug-with-confidence&amp;amp;via=perltricks&#34;&gt;retweet&lt;/a&gt; it!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to read a string into an array of characters using split</title>
      <link>http://localhost:1313/article/42/2013/10/3/How-to-read-a-string-into-an-array-of-characters-using-split/</link>
      <pubDate>Thu, 03 Oct 2013 00:42:18 +0000</pubDate>
      
      <guid>http://localhost:1313/article/42/2013/10/3/How-to-read-a-string-into-an-array-of-characters-using-split/</guid>
      <description>&lt;p&gt;Perl&amp;rsquo;s split function has a useful feature that will split a string into characters. This works by supplying an empty regex pattern (&amp;ldquo;//&amp;rdquo;) to the split function. This can be used to easily split a word into an array of letters, for example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $word &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;camel&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @letters &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; split(&lt;span style=&#34;color:#e6db74&#34;&gt;//&lt;/span&gt;, $word);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Perl&amp;rsquo;s official documentation has more on the split function. You can read it &lt;a href=&#34;https://perldoc.perl.org/functions/split.html&#34;&gt;online&lt;/a&gt; or by running the following command at the terminal:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;perldoc &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;f split&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Perl for loops</title>
      <link>http://localhost:1313/article/17/2013/4/12/Perl-for-loops/</link>
      <pubDate>Fri, 12 Apr 2013 10:03:44 +0000</pubDate>
      
      <guid>http://localhost:1313/article/17/2013/4/12/Perl-for-loops/</guid>
      <description>

&lt;p&gt;Perl&amp;rsquo;s for loops are a powerful feature that, like the rest of Perl can be as concise, flexible and versatile required. This article covers the core features for Perl&amp;rsquo;s for loops.&lt;/p&gt;

&lt;h3 id=&#34;c-style-for-loops&#34;&gt;C-style for loops&lt;/h3&gt;

&lt;p&gt;The C-style for loop follows programming tradition and requires three parameters (count; logical test; count modifier). It looks like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; feature &lt;span style=&#34;color:#e6db74&#34;&gt;qw/say/&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;# print numbers 0 to 9&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; $i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;; $i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
    say $i;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let&amp;rsquo;s review the code above. First of all we import the feature &amp;lsquo;say&amp;rsquo; which works like the print command except that it appends a newline to the printed string. Before the loop begins, Perl initialises the scalar variable $i as zero. Perl will then check the logical condition ($i &amp;lt; 10). If the condition is true, Perl will execute all the code between the braces { } once. Perl will also increment $i by 1 because the count modifier condition is set to $i++. Having finished one iteration, Perl will then check the logical condition again. After one iteration, $i is equal to 1, so Perl will loop through the code again. This will continue until $i is equal to 10 and the logical condition returns false, at which point Perl will then move on to process any code below the loop. The loop above used an increment modifier ($i++), however it can decrement as well:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; feature &lt;span style=&#34;color:#e6db74&#34;&gt;qw/say/&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;# print numbers 10 to 1&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;; $i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; $i&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;) {
    say $i;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In fact we can use any modifier we choose, for example to print only odd numbers, we can use Perl&amp;rsquo;s add-to operator $i += 2 which is a shortcut for ($i = $i + 2).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; feature &lt;span style=&#34;color:#e6db74&#34;&gt;qw/say/&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;# print only odd numbers 1 - 9&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; $i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;; $i &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) {
    say $i;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The C-style for loop can be used to access elements of an array.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; feature &lt;span style=&#34;color:#e6db74&#34;&gt;qw/say/&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @weather_elements &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;wind&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;rain&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;snow&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;cloud&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;sunshine&amp;#39;&lt;/span&gt;);
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; $i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; @weather_elements; $i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
    say $weather_elements[$i];
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that the count is started at zero because Perl array indexes are zero-based, and the array is used as one-side of the logical condition ($i &amp;lt; @weather_elements) because in this context Perl will helpfully return the length of the array (5).&lt;/p&gt;

&lt;h3 id=&#34;for-loops-with-arrays&#34;&gt;for loops with arrays&lt;/h3&gt;

&lt;p&gt;There are simpler ways than using the C-style for loop to iterate through every element of an array in Perl. If an array is passed to a for loop, it will iterate through every element of the array until it reaches the end. For example this is the same loop as above, written using the array technique:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; feature &lt;span style=&#34;color:#e6db74&#34;&gt;qw/say/&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @weather_elements &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;wind&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;rain&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;snow&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;cloud&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;sunshine&amp;#39;&lt;/span&gt;);
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $weather_element (@weather_elements) {
    say $weather_element;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the code above Perl iterates through the array, assigning the value of the current element to $weather_element. Once the loop finishes $weather_element goes out of scope and will be garbage collected.&lt;/p&gt;

&lt;p&gt;We can simplify this code further. If no scalar variable is included in the argument, Perl will use $_ as the temporary variable:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; feature &lt;span style=&#34;color:#e6db74&#34;&gt;qw/say/&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @weather_elements &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;wind&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;rain&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;snow&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;cloud&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;sunshine&amp;#39;&lt;/span&gt;);
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (@weather_elements) {
    say $_;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Instead of using &amp;lsquo;for&amp;rsquo;, some Perl programmers use a &amp;lsquo;foreach&amp;rsquo; loop, although in Perl &amp;lsquo;for&amp;rsquo; and &amp;lsquo;foreach&amp;rsquo; are synonyms and can be used interchangeably. I like &amp;lsquo;foreach&amp;rsquo; because it clarifies the programmer&amp;rsquo;s intentions. For example this code will do the same thing as the previous code example above:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; feature &lt;span style=&#34;color:#e6db74&#34;&gt;qw/say/&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @weather_elements &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;wind&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;rain&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;snow&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;cloud&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;sunshine&amp;#39;&lt;/span&gt;);
&lt;span style=&#34;color:#66d9ef&#34;&gt;foreach&lt;/span&gt; (@weather_elements) {
    say $_;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;foreach&lt;/code&gt; loop also accepts a list instead of an array:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; feature &lt;span style=&#34;color:#e6db74&#34;&gt;qw/say/&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;foreach&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;wind&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;rain&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;snow&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;cloud&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;sunshine&amp;#39;&lt;/span&gt;) {
    say $_;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;for-loops-with-ranges&#34;&gt;for loops with ranges&lt;/h3&gt;

&lt;p&gt;Sometimes you just need Perl to &amp;lsquo;do something n number of times&amp;rsquo;. A quick way to do this is using a range i..n. For example, if we wanted to print 6 random lottery numbers:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; feature &lt;span style=&#34;color:#e6db74&#34;&gt;qw/say/&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;) {
    say int(rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;58&lt;/span&gt;)) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;for-loop-functions-redo-next-and-last&#34;&gt;for loop functions: redo, next and last&lt;/h3&gt;

&lt;p&gt;Perl provides several functions which can be used to control the for loop iterations. &lt;code&gt;redo&lt;/code&gt; instructs Perl to re-run the current iteration. Let&amp;rsquo;s modify the lottery numbers example above to redo the loop if we generate an unlucky number 13.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $number &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(rand(&lt;span style=&#34;color:#ae81ff&#34;&gt;58&lt;/span&gt;)) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;redo&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; $number &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt;;
    say $number;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the example above, if a number 13 is generated, the &lt;code&gt;redo&lt;/code&gt; function will restart the iteration and the code will never reach the say &lt;code&gt;$number&lt;/code&gt; statement.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;next&lt;/code&gt; function stops the current iteration and moves to the next iteration. This can be useful when we have additional processing that we want to be done only for certain elements. For example if we were surveying a group of people about their education, it only makes sense to ask what school the person attended, if they have a degree:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; feature &lt;span style=&#34;color:#e6db74&#34;&gt;qw/say/&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;){
        &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Please type your name and press enter: &amp;#34;&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $name &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;;
        say $name;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Do you have a bachelors degree? (y/n) &amp;#34;&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $degree_flag &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;;
        say $degree_flag;
        chomp $degree_flag;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; $degree_flag &lt;span style=&#34;color:#f92672&#34;&gt;eq&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;n&amp;#39;&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Which school did you get the degree from?&amp;#34;&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $school &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;;
        say $school;
        &lt;span style=&#34;color:#75715e&#34;&gt;# continues ...&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;last&lt;/code&gt; function allows the current iteration to finish and then exits loop entirely. This is often used when doing pattern matching as once a match has been found, there is no need to check other possibilities:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $variable_type &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;$scalar&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @perlvariable_regexes &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;^\$&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;^@&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;^%&amp;#39;&lt;/span&gt;);
&lt;span style=&#34;color:#66d9ef&#34;&gt;foreach&lt;/span&gt; (@perlvariable_regexes ){
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ($variable_type &lt;span style=&#34;color:#f92672&#34;&gt;=~&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;m/$_/&lt;/span&gt;) {
        say &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;match found with $_&amp;#34;&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;last&lt;/span&gt;;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For further detail on Perl&amp;rsquo;s for loops, check out the &lt;a href=&#34;https://perldoc.perl.org/perlsyn.html#For-Loops&#34;&gt;official Perl documentation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>List shortcuts: qw the quote whitespace operator</title>
      <link>http://localhost:1313/article/15/2013/4/9/List-shortcuts--qw-the-quote-whitespace-operator/</link>
      <pubDate>Tue, 09 Apr 2013 00:02:11 +0000</pubDate>
      
      <guid>http://localhost:1313/article/15/2013/4/9/List-shortcuts--qw-the-quote-whitespace-operator/</guid>
      <description>&lt;p&gt;A popular way to build a list of literal quotes in Perl is to use the quote whitespace operator (qw). It&amp;rsquo;s terse, versatile and elegant. To see why, let&amp;rsquo;s look at a typical statement using a list of strings:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# import the Encode module and three subroutines&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Encode (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;decode&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;encode&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;find_encoding&amp;#39;&lt;/span&gt;);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To define the list of strings in Perl we had to encase every string with apostrophes, separated by commas and surrounded by parentheses. That&amp;rsquo;s a lot of fluff, and opens the door to easy mistakes such as using speechmarks (&amp;ldquo;) when you needed an apostrophe. Instead of doing that, we could have used the quote whitespace operator:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Encode &lt;span style=&#34;color:#e6db74&#34;&gt;qw/decode encode find_encoding/&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The quote whitespace operator takes a list delimiter followed by a list of plain strings separated by whitespace and returns list of literal quoted strings. The delimiter can be an ASCII symbol (slash / is a popular choice), brackets or parentheses. Let&amp;rsquo;s review some more examples:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# assign a list of an array&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @ny_boroughs &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;qw{Bronx Brooklyn Manhattan Queens Staten_Island}&lt;/span&gt;;

&lt;span style=&#34;color:#75715e&#34;&gt;# Quote some tricky symbols using tilde as the list delimiter&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @ascii_symbols &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;qw~! @ $ % ^ &amp;amp; * ( ) - _ = + { } [ ] \ | / ? ~&lt;/span&gt;;

&lt;span style=&#34;color:#75715e&#34;&gt;# Use qw an input to a loop&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;foreach&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $firm (&lt;span style=&#34;color:#e6db74&#34;&gt;qw/Deloitte ErnstAndYoung KPMG PWC/&lt;/span&gt;){
    &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; $firm; 
}

&lt;span style=&#34;color:#75715e&#34;&gt;# It will ignore spaces, even double or triple spaces&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @colours &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;qw(red  blue   yellow    pink   green   )&lt;/span&gt;; 
&lt;span style=&#34;color:#66d9ef&#34;&gt;foreach&lt;/span&gt; (@colours) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; $_;
}
&lt;span style=&#34;color:#75715e&#34;&gt;# red&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# blue&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# yellow&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# pink&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# green&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Using the quote whitespace operator often results in a cleaner, simpler syntax that reduces the risk of error when working with lists.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Perl arrays 101 - create, loop and manipulate</title>
      <link>http://localhost:1313/article/11/2013/4/4/Perl-arrays-101---create--loop-and-manipulate/</link>
      <pubDate>Thu, 04 Apr 2013 20:22:51 +0000</pubDate>
      
      <guid>http://localhost:1313/article/11/2013/4/4/Perl-arrays-101---create--loop-and-manipulate/</guid>
      <description>

&lt;p&gt;Arrays in Perl contain an ordered list of values that can be accessed using built-in functions. They are one of the most useful data structures and frequently used in Perl programming.&lt;/p&gt;

&lt;h3 id=&#34;creating-an-array&#34;&gt;Creating an array&lt;/h3&gt;

&lt;p&gt;In Perl variables are identified using sigils. Arrays use @ (as in &amp;lsquo;a&amp;rsquo; for array), so the format is: @any_name_you_choose_here. Arrays are initialised by assigning a list of values (comma separated values between parentheses). Unlike more formal languages, Perl arrays can contain a mix of numbers, strings, objects and references.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @empty_array;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @another_empty_array &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ();

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @numbers &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;);

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @names_start_with_j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;John&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Judy&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Julia&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;James&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Jennifer&amp;#39;&lt;/span&gt;);

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @random_collection &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;2013&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;keyboard&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;perltricks.com&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;finding-the-array-length-size&#34;&gt;Finding the array length / size&lt;/h3&gt;

&lt;p&gt;The length of an array (aka the &amp;lsquo;size&amp;rsquo;) is the count of the number of elements in the array. To find the array length, use the array in a scalar context:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @numbers &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;);
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $array_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; @numbers;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; $array_length;
&lt;span style=&#34;color:#75715e&#34;&gt;# 5&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;accessing-array-elements-directly&#34;&gt;Accessing array elements directly&lt;/h3&gt;

&lt;p&gt;Arrays can be accessed in a variety of ways: by directly accessing an element, slicing a group of elements or looping through the entire array, accessing one element at a time.&lt;/p&gt;

&lt;p&gt;When directly accessing an array element, use the array name prefaced with the scalar sigil ($) instead of (@) and the index number of the element enclosed in square brackets. Arrays are zero-based, which means that the first element&amp;rsquo;s index number is 0 (not 1!).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @names_start_with_j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;John&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Judy&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Julia&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;James&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Jennifer&amp;#39;&lt;/span&gt;);
$names_start_with_j[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]; &lt;span style=&#34;color:#75715e&#34;&gt;# John&lt;/span&gt;
$names_start_with_j[&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;]; &lt;span style=&#34;color:#75715e&#34;&gt;# Jennifer&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The implication of zero-based indexing is that the index number of the last element in an array is equal to the length of the array minus one.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @numbers &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;64&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;29&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;22&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;);
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $numbers_array_length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; @numbers;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $last_element_index &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; numbers_array_length &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;# therefore ...&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; $numbers[$last_element_index];
&lt;span style=&#34;color:#75715e&#34;&gt;# 100&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For simpler ways to access the last element of an array - see our &lt;a href=&#34;http://perltricks.com/article/6/2013/3/28/Find-the-index-of-the-last-element-in-an-array&#34;&gt;recent article&lt;/a&gt; for examples.&lt;/p&gt;

&lt;h3 id=&#34;loop-through-an-array-with-foreach&#34;&gt;Loop through an array with foreach&lt;/h3&gt;

&lt;p&gt;Arrays elements can be accessed sequentially using a foreach loop to iterate through the array one element at a time.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @names_start_with_j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;John&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Judy&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Julia&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;James&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Jennifer&amp;#39;&lt;/span&gt;);
&lt;span style=&#34;color:#66d9ef&#34;&gt;foreach&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $element (@names_start_with_j) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;$element\n&amp;#34;&lt;/span&gt;;
}
&lt;span style=&#34;color:#75715e&#34;&gt;# John&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# Judy&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# Julia&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# James&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# Jennifer&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Other common functions for looping through arrays are &lt;a href=&#34;https://perldoc.perl.org/functions/grep.html&#34;&gt;grep&lt;/a&gt; and &lt;a href=&#34;https://perldoc.perl.org/functions/map.html&#34;&gt;map&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;shift-unshift-push-and-pop&#34;&gt;shift, unshift, push and pop&lt;/h3&gt;

&lt;p&gt;Perl arrays are dynamic in length, which means that elements can be added to and removed from the array as required. Perl provides four functions for this: shift, unshift, push and pop.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;shift&lt;/strong&gt; removes and returns the first element from the array, reducing the array length by 1.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @compass_points &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;north&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;east&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;south&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;west&amp;#39;&lt;/span&gt;);
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $direction &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; shift @compass_points;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; $direction;
&lt;span style=&#34;color:#75715e&#34;&gt;# north&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If no array is passed to shift, it will operate on @_. This makes it useful in subroutines and methods where by default @_ contains the arguments from the subroutine / method call. E.G.:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;print_caller(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;perltricks&amp;#34;&lt;/span&gt;);
&lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;print_caller&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $caller_name &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; shift;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; $caller_name;
}
&lt;span style=&#34;color:#75715e&#34;&gt;# perltricks&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The other three array functions work similarly to shift. &lt;strong&gt;unshift&lt;/strong&gt; receives and inserts a new element into the front of the array increasing the array length by 1.&lt;strong&gt;push&lt;/strong&gt; receives and inserts a new element to the end of the array, increasing the array length by 1. &lt;strong&gt;pop&lt;/strong&gt; removes and returns the last element in the array, reducing the array length by 1.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @compass_points &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;north&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;east&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;south&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;west&amp;#39;&lt;/span&gt;);
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $direction &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;north-east&amp;#39;&lt;/span&gt;;
unshift @compass_points, $direction;
&lt;span style=&#34;color:#75715e&#34;&gt;# @compass_points contains: north-east, north, east, south and west&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $west &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pop @compass_points;
push @compass_points, $new_direction; &lt;span style=&#34;color:#75715e&#34;&gt;# put $west back&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;check-an-array-is-null-or-undefined&#34;&gt;Check an array is null or undefined&lt;/h3&gt;

&lt;p&gt;A simple way to check if an array is null or defined is to examine it in a scalar context to obtain the number of elements in the array. If the array is empty, it will return 0, which Perl will also evaluate as boolean false. Bear in mind that this is not quite the same thing as undefined, as it is possible to have an empty array.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @empty_array;
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (@empty_array) {
    &lt;span style=&#34;color:#75715e&#34;&gt;# do something - will not be reached if the array has 0 elements&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Upgrade your list printing using field separator variables</title>
      <link>http://localhost:1313/article/12/2013/4/3/Upgrade-your-list-printing-using-field-separator-variables/</link>
      <pubDate>Wed, 03 Apr 2013 22:24:28 +0000</pubDate>
      
      <guid>http://localhost:1313/article/12/2013/4/3/Upgrade-your-list-printing-using-field-separator-variables/</guid>
      <description>&lt;p&gt;A typical way to print every element of an array in Perl is using a foreach loop:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @sportscar_brands &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;qw/Ferrari Aston_Martin Lambourgini/&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;foreach&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $brand (@sportscar_brands){
    &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;$brand\n&amp;#34;&lt;/span&gt;;
}
&lt;span style=&#34;color:#75715e&#34;&gt;# Ferrari&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# Aston_Martin&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# Lambourgini&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;An alternative method is to set value of the the output field separator variable ($,). When printing a list or array Perl injects this variable between elements. Hence, if you set the output field separator to a newline (\n) you will achieve the same affect as the previous example, without the foreach loop.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$, &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\n&amp;#34;&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;# set the output field separator to newline&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @sportscar_brands &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;qw/Ferrari Aston_Martin Lambourgini/&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; @sportscar_brands;
&lt;span style=&#34;color:#75715e&#34;&gt;# Ferrari&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# Aston_Martin&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# Lambourgini&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The output field separator also works on lists:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$, &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\n&amp;#34;&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;qw/Ferrari Aston_Martin Lambourgini/&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;# Ferrari&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# Aston_Martin&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# Lambourgini&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There is another variable called the list separator ($&amp;ldquo;). Perl injects the value of $&amp;rdquo; between the elements of an array in an interpolated string. The subtle difference here is that the output field separator will apply when using print, however the list separator applies to all arrays in an interpolated string context. For example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$&amp;#34; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\n&amp;#34;&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;# set the list separator to newline&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @normalcar_brands &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;qw/Ford Honda Toyota Fiat/&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; @normalcar_brands; &lt;span style=&#34;color:#75715e&#34;&gt;# not inside an interpolated string&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# FordHondaToyotaFiat&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;@normalcar_brands&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;# works in interpolated string&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# Ford&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# Honda&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# Toyota&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# Fiat&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $separated_list_string &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;@normalcar_brands&amp;#34;&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;# injects the separator&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; $separated_list_string;
&lt;span style=&#34;color:#75715e&#34;&gt;# Ford&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# Honda&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# Toyota&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# Fiat&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;One additional difference: despite its name, the list separator variable ($&amp;ldquo;) does not work on lists whilst the output field separator ($,) does (in Perl 5.16.3).&lt;/p&gt;

&lt;p&gt;Finally if you have set both $, and $&amp;rdquo; and print an interpolated array, $&amp;rdquo; will be injected and $, will be ignored.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Find the index of the last element in an array</title>
      <link>http://localhost:1313/article/6/2013/3/28/Find-the-index-of-the-last-element-in-an-array/</link>
      <pubDate>Thu, 28 Mar 2013 23:30:33 +0000</pubDate>
      
      <guid>http://localhost:1313/article/6/2013/3/28/Find-the-index-of-the-last-element-in-an-array/</guid>
      <description>

&lt;p&gt;Most Perl programmers know that to find the size of an array, the array must called in a scalar context like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Declare the array&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @numbers_array &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;41&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;67&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;62&lt;/span&gt;); 
&lt;span style=&#34;color:#75715e&#34;&gt;# Get the array size&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $size_of_array &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; @numbers_array;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This understanding can lead to programmers applying a scalar context to an array to access its last element (subtracting 1 because arrays are zero-based).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; $numbers_array[@numbers_array &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
&lt;span style=&#34;color:#75715e&#34;&gt;# 62&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;the-last-index-variable&#34;&gt;The last-index variable&lt;/h3&gt;

&lt;p&gt;Perl has a &amp;lsquo;last-index&amp;rsquo; variable for arrays ($#array_name).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; $#numbers_array; 
&lt;span style=&#34;color:#75715e&#34;&gt;# 4&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; $numbers_array[$#numbers_array]; 
&lt;span style=&#34;color:#75715e&#34;&gt;# 62&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The last index operator ($#array_name) also works on arrayrefs if you insert an extra dollar sigil:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $arrayref &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;41&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;67&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;62&lt;/span&gt;];
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; $#$arrayref;
&lt;span style=&#34;color:#75715e&#34;&gt;# 4&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; $$arrayref[$#$arrayref]; 
&lt;span style=&#34;color:#75715e&#34;&gt;# 62&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;negative-indexing&#34;&gt;Negative indexing&lt;/h3&gt;

&lt;p&gt;Perl provides a shorter syntax for accessing the last element of an array: negative indexing. Negative indices track the array from the end, so -1 refers to the last element, -2 the second to last element and so on.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Declare the array&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @cakes &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;qw(victoria_sponge chocolate_gateau carrot)&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; $cakes[&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]; &lt;span style=&#34;color:#75715e&#34;&gt;# carrot&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; $cakes[&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]; &lt;span style=&#34;color:#75715e&#34;&gt;# chocolate_gateau&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; $cakes[&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;]; &lt;span style=&#34;color:#75715e&#34;&gt;# victoria_sponge&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; $cakes[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;];  &lt;span style=&#34;color:#75715e&#34;&gt;# victoria_sponge&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; $cakes[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];  &lt;span style=&#34;color:#75715e&#34;&gt;# chocolate_gateau&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; $cakes[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;];  &lt;span style=&#34;color:#75715e&#34;&gt;# carrot&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Designing a Search Engine</title>
      <link>http://localhost:1313/pub/2001/04/10/engine.html/</link>
      <pubDate>Tue, 10 Apr 2001 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2001/04/10/engine.html/</guid>
      <description>&lt;p&gt;A couple of months ago, I was approached by a company that I had done some work for previously, and was asked to build them a search engine to index about 200MB of HTML. However, some fairly strict rules were laid down about what I could and couldn&amp;rsquo;t do. First, the search engine had to be built from scratch, so that the rights to it were fully theirs. Second, I wasn&amp;rsquo;t allowed to use any non-standard modules. Third, the data had to be held in plain-text files. Fourth, I was assured that all DB* modules were not working, and couldn&amp;rsquo;t be made to work, which seemed somewhat surprising. And finally, one had to be able to perform Boolean searches, including the use of brackets.&lt;/p&gt;

&lt;p&gt;As you can imagine, this presented quite a challenge, so I accepted and got to work. I want to discuss the two most interesting parts of the project: how to store and retrieve the data efficiently, and how to parse search terms.&lt;/p&gt;

&lt;p&gt;Because of the ideas I had on parsing the search terms, which will be discussed later, I needed a system that could take a word and send back a list of all the files it appeared in and how many times it appeared in them. This had to be as fast as possible without using insane amounts of disk space. Second, I needed to be able to get information about the files indexed quickly without actually opening them - the files could be large, and could be held remotely.&lt;/p&gt;

&lt;p&gt;The first thing to do was to assign each indexed file a unique number - this would allow me to save space when referring to it, and would allow me to easily look up information on the file. Each word would have a list of these numbers listed under it, so I could take the word &amp;lsquo;camel&amp;rsquo; for example, and get a list of file numbers back.&lt;/p&gt;

&lt;p&gt;To me, the most obvious way of implementing this was to use a tied hash. However, my project rules stated I wasn&amp;rsquo;t allowed to do that. I tried to think of other ways to implement a tied-hash system without using any of the DB or DBI modules. My first idea was to piggy back off a similar feature used in almost all operating systems; or, to be more precise, every file system. By creating each word as a file I could easily &lt;code&gt;open (DATA, &amp;quot;camel&amp;quot;)&lt;/code&gt; to get my data.&lt;/p&gt;

&lt;p&gt;At this point, I had two types of indexes: one that listed summary information for each file by file number, and another that held information about each word.&lt;/p&gt;

&lt;p&gt;There were two problems, however, with using the file system as my hash. While with a small number of words it was quite fast, most operating systems use a linear search to locate files in a directory, so opening &amp;ldquo;zulu&amp;rdquo; in a 10,000 file directory quickly became quite slow. The other problem was minimum file sizes, especially under Windows. This is a huge problem when your minimum file size is 16kb - as it is on fat16 with a 1GB hard drive - as 100 files translates as 1.6MB. When the data you&amp;rsquo;re indexing is 20MB and you get about four times this much worth of index files, you&amp;rsquo;re doing something wrong.&lt;/p&gt;

&lt;p&gt;The solution for the file numbers was quite easy: I would spit out the file offsets of where information about each file was stored in my file index. Then, I&amp;rsquo;d read these offsets in at the start of each search, so that if I wanted information about file 15, I could get the offset by saying $file[15] and then seeking to that point.&lt;/p&gt;

&lt;p&gt;I was beginning to despair for an elegant solution to the word indexing until Simon Cozens pointed out the wonderful Search::Dict. Search::Dict is a standard module that searches for keys in dictionary files. Essentially, it allows you to give it a word and a file-handle, where the file-handle is tied to a bunch of lines in alphabetical order, and will then change the next read position of the file-handle to the line that starts with the word. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;look *INDEX, &amp;quot;camel&amp;quot;;
$line = &amp;lt;INDEX&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;would assign $line to the first line in the file handle beginning with camel. In addition, since it uses an effective binary search to achieve this, retrieval of data was fast. Problem solved.&lt;/p&gt;

&lt;p&gt;Parsing of the Boolean search terms was the most difficult part of the program. Users had to be able to enter terms such as cat and (dog not sheep) and get sane results. The only way I could deal with this, I decided, was to go along the search terms from left to right and keep an array of file numbers that were still applicable.&lt;/p&gt;

&lt;p&gt;To do this, I created three subroutines that I called &lt;code&gt;&amp;amp;array_and&lt;/code&gt;, &lt;code&gt;&amp;amp;array_not&lt;/code&gt;, and &lt;code&gt;&amp;amp;array_both&lt;/code&gt;. &lt;code&gt;&amp;amp;array_and&lt;/code&gt; would take our current results array and add the list of file numbers from a given word. &lt;code&gt;&amp;amp;array_not&lt;/code&gt; would &amp;lsquo;subtract&amp;rsquo; the file numbers from one word from our results array, and &lt;code&gt;&amp;amp;array_both&lt;/code&gt; would return shared elements between the results array and the file numbers from the search word.&lt;/p&gt;

&lt;p&gt;I ripped a lot of code from the Perl Cookbook to make these array functions. The code for these functions can be seen below:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub array_both {
 my $prev = &#39;nonesuch&#39;;
 my @total_first = (@{$_[0]}, @{$_[1]});
 @total_first = sort(@total_first);
 my $current;
 my @return_array;
 foreach $current (@total_first) {
  if ($prev eq $current) { push(@return_array, $prev);  }
  $prev = $current;
 }
 @return_array = @{&amp;amp;add_array(\@return_array, \@return_array)};
 return \@return_array;
}

sub array_and {
 my $prev = &#39;nonesuch&#39;;
 my @total_first = (@{$_[0]}, @{$_[1]});
 my %seen = (); # These next two lines are from the PCB
 my @return_array = grep { ! $seen{$_} ++ } @total_first ;
 return \@return_array;
}

sub array_not {

 # Again this is ripped straight from PCB

 my @a = @{$_[0]};
 my @b = @{$_[1]};
 my %hash = map {$_ =&amp;gt; 1} @a;
 my $current;
 foreach $current (@b) {
  delete $hash{$current};
 }
 @a = keys %hash;
 @a = sort(@a);
 return \@a;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only big problem left was dealing with brackets. The only solution I could come up with was to make the search term parsing code a subroutine that returned an array. This way when I came to some logic in brackets, I could send it back to the subroutine, from which I would get a list of words, exactly like if the logic had been a single word. The main problem that I envisaged with this would be getting Perl to deal with expressions such as &lt;code&gt;sheep and (dog not cat) and (camel not panther)&lt;/code&gt;. How did I get Perl to match just the first set of brackets, or, if nested brackets were present, to match all the logic? Damian Conway has written an excellent module called Text::Balanced, which I was just about to start using, before the project specifications changed(!) and I was told we no longer needed to allow nested-bracket searching.&lt;/p&gt;

&lt;p&gt;Yet again, Perl came into its own when writing the search engine. The availability of solutions to my problems in the form of modules saved me a lot of time, and saved the task from being inundated with my own, rather bad, code. The ability to use Perl to quickly extract titles from HTML documents and strip HTML tags in very few lines of code also made my life far easier.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

