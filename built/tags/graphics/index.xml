<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Graphics on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/graphics/</link>
    <description>Recent content in Graphics on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 24 Jan 2011 06:00:01 -0800</lastBuildDate>
    <atom:link href="/tags/graphics/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Visualizing Music with SDL and Perl</title>
      <link>http://localhost:1313/pub/2011/01/visualizing-music-with-sdl-and-perl.html/</link>
      <pubDate>Mon, 24 Jan 2011 06:00:01 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2011/01/visualizing-music-with-sdl-and-perl.html/</guid>
      <description>

&lt;h1 id=&#34;music-visualization-with-perl-and-sdl&#34;&gt;&lt;strong&gt;Music Visualization with Perl and SDL&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;Many users know SDL as a powerful cross-platform library for graphics programming and input, especially as the foundation of many open source games. Perl users know it as the technology behind the beloved &lt;a href=&#34;http://www.frozen-bubble.org/&#34;&gt;Frozen Bubble&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Perl and SDL can do far more than destroy an infinite onslaught of cartoon bubbles, however. The recently revitalized &lt;a href=&#34;http://sdlperl.ath.cx/projects/SDLPerl/&#34;&gt;SDL Perl&lt;/a&gt; project has taken up the challenge of demonstrating that everyone&amp;rsquo;s favorite system administration language is capable of producing powerful multimedia programs—including, but not limited to, games.&lt;/p&gt;

&lt;p&gt;In this edited excerpt from the &lt;a href=&#34;http://sdlperl.ath.cx/releases/SDL_Manual.html&#34;&gt;SDL Perl manual&lt;/a&gt;, lead developer Kartik Thakore walks through a non-game application of SDL and Perl, building a music player with visualizations in just a few lines of code.&lt;/p&gt;

&lt;h2 id=&#34;running-this-demo&#34;&gt;&lt;strong&gt;Running this Demo&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;To run this example software, you need:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Perl 5.10, with threading enabled&lt;/li&gt;
&lt;li&gt;A curent installation of CPAN&lt;/li&gt;
&lt;li&gt;The native libraries of libsdl, libsdl_mixer (with Ogg support), libsdl_gfx, and their development packages&lt;/li&gt;
&lt;li&gt;SDL perl version 5.526 or newer&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2011_01_visualizing-music-with-sdl-and-perl/music_visualizer.zip&#34;&gt;this article&amp;rsquo;s example files&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With all of that installed, extract the example file and run the visualizer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $ cd music_visualiser/
    $ perl visualiser.pl
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;music-visualizer&#34;&gt;&lt;strong&gt;Music Visualizer&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;The music visualizer example processes real-time sound data—data as it plays—and displays the wave form on the screen. It will look something like Figure 1.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2011_01_visualizing-music-with-sdl-and-perl/spectro-1.png&#34; alt=&#34;Simple Music Visualization&#34; /&gt;
&lt;em&gt;Figure 1. A simple music visualization.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;the-code-and-comments&#34;&gt;&lt;strong&gt;The Code and Comments&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;The program begins with the usual boilerplate of an SDL Perl application:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use strict;
    use warnings;

    use Cwd;
    use Carp;
    use File::Spec;

    use threads;
    use threads::shared;

    use SDL;
    use SDL::Event;
    use SDL::Events;

    use SDL::Audio;
    use SDL::Mixer;
    use SDL::Mixer::Music;
    use SDL::Mixer::Effects;

    use SDLx::App;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It then creates an application with both audio and video support:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $app = SDLx::App-&amp;gt;new(
        init   =&amp;gt; SDL_INIT_AUDIO | SDL_INIT_VIDEO,
        width  =&amp;gt; 800,
        height =&amp;gt; 600,
        depth  =&amp;gt; 32,
        title  =&amp;gt; &amp;quot;Sound Event Demo&amp;quot;,
        eoq    =&amp;gt; 1,
        dt     =&amp;gt; 0.2,
    );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The application must initialize the audio system with a format matching the expected audio input. &lt;code&gt;AUDIO_S16&lt;/code&gt; provides a 16-bit signed integer array for the stream data:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Initialize the Audio
    unless ( SDL::Mixer::open_audio( 44100, AUDIO_S16, 2, 1024 ) == 0 ) {
        Carp::croak &amp;quot;Cannot open audio: &amp;quot; . SDL::get_error();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The music player needs the music files from the &lt;em&gt;data/music/&lt;/em&gt; directory:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Load our music files
    my $data_dir = &#39;.&#39;;
    my @songs    = glob &#39;data/music/*.ogg&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A music effect reads the music data into a stream array, shared between threads:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @stream_data :shared;

    #  Music Effect to pull Stream Data
    sub music_data {
        my ( $channel, $samples, $position, @stream ) = @_;

        {
            lock(@stream_data);
            push @stream_data, @stream;
        }

        return @stream;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; and that effect gets registered as a callback with &lt;code&gt;SDL::Mixer::Effects&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $music_data_effect_id =
          SDL::Mixer::Effects::register( MIX_CHANNEL_POST, &amp;quot;main::music_data&amp;quot;,
            &amp;quot;main::done_music_data&amp;quot;, 0 );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The program&amp;rsquo;s single command-line option governs the number of lines to display in the visualizer. The default is 50.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $lines = $ARGV[0] || 50;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The drawing callback for the &lt;code&gt;SDLx::App&lt;/code&gt; runs while a song plays. It reads the stream data and displays it on the screen as a wave form. The math calculations produce a multi-colored bar graph representing slices of the music data. The remaining visualization code should be straightforward:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #  Music Playing Callbacks
    my $current_song = 0;
    my $lines        = $ARGV[0] || 50;

    my $current_music_callback = sub {
        my ( $delta, $app ) = @_;

        $app-&amp;gt;draw_rect( [ 0, 0, $app-&amp;gt;w(), $app-&amp;gt;h() ], 0x000000FF );
        $app-&amp;gt;draw_gfx_text(
            [ 5, $app-&amp;gt;h() - 10 ],
            [ 255, 0, 0, 255 ],
            &amp;quot;Playing Song: &amp;quot; . $songs[ $current_song - 1 ]
        );

        my @stream;
        {
            lock @stream_data;
            @stream      = @stream_data;
            @stream_data = ();
        }

        # To show the right amount of lines we choose a cut of the stream
        # this is purely for asthetic reasons.

        my $cut = @stream / $lines;

        # The width of each line is calculated to use.
        my $l_wdt = ( $app-&amp;gt;w() / $lines ) / 2;

        for ( my $i = 0 ; $i &amp;lt; $#stream ; $i += $cut ) {

            #  In stereo mode the stream is split between two alternating streams
            my $left  = $stream[$i];
            my $right = $stream[ $i + 1 ];

            #  For each bar we calculate a Y point and a X point
            my $point_y = ( ( ($left) ) * $app-&amp;gt;h() / 4 / 32000 ) + ( $app-&amp;gt;h / 2 );
            my $point_y_r =
              ( ( ($right) ) * $app-&amp;gt;h() / 4 / 32000 ) + ( $app-&amp;gt;h / 2 );
            my $point_x = ( $i / @stream ) * $app-&amp;gt;w;

            # Using the parameters
            #   Surface, box coordinates and color as RGBA
            SDL::GFX::Primitives::box_RGBA(
                $app,
                $point_x - $l_wdt,
                $app-&amp;gt;h() / 2,
                $point_x + $l_wdt,
                $point_y, 40, 0, 255, 128
            );
            SDL::GFX::Primitives::box_RGBA(
                $app,
                $point_x - $l_wdt,
                $app-&amp;gt;h() / 2,
                $point_x + $l_wdt,
                $point_y_r, 255, 0, 40, 128
            );

        }

      $app-&amp;gt;flip();
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whenever a song finishes, &lt;code&gt;SDL::Mixer::Music::playing_music&lt;/code&gt; returns &lt;code&gt;0&lt;/code&gt;. The program detects this state change and calls &lt;code&gt;music_finished_playing()&lt;/code&gt;, where the program attaches the &lt;code&gt;$play_next_song_callback&lt;/code&gt; callback to switch to the next song gracefully:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $cms_move_callback_id;
    my $pns_move_callback_id;
    my $play_next_song_callback;

    sub music_finished_playing {
        SDL::Mixer::Music::halt_music();
        $pns_move_callback_id = $app-&amp;gt;add_move_handler( $play_next_song_callback )
            if defined $play_next_song_callback;
    }

    $play_next_song_callback = sub {
        return $app-&amp;gt;stop() if $current_song &amp;gt;= @songs;

        my $song = SDL::Mixer::Music::load_MUS($songs[$current_song++]);

        SDL::Mixer::Music::hook_music_finished(&#39;main::music_finished_playing&#39;);
        SDL::Mixer::Music::play_music($song, 0 );

        $app-&amp;gt;remove_move_handler( $pns_move_callback_id )
            if defined $pns_move_callback_id;
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A move handler detects if music is playing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $app-&amp;gt;add_move_handler(
       sub {
           my $music_playing = SDL::Mixer::Music::playing_music();
           music_finished_playing() unless $music_playing;
       }
   );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first callback to trigger &lt;code&gt;$play_next_song_callback&lt;/code&gt; gets the first song:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $app-&amp;gt;add_show_handler($current_music_callback);
    $pns_move_callback_id = $app-&amp;gt;add_move_handler( $play_next_song_callback);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; and a keyboard event handler for a keypress allows the user to move through songs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $app-&amp;gt;add_event_handler(
        sub {
            my ($event, $app) = @_;

            if ($event-&amp;gt;type == SDL_KEYDOWN &amp;amp;&amp;amp; $event-&amp;gt;key_sym == SDLK_DOWN)
            {
                # Indicate that we are done playing the music_finished_playing
                music_finished_playing();
            }
        }
    );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From there, the application is ready to run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $app-&amp;gt;run();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; and the final code gracefully stops &lt;code&gt;SDL::Mixer&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    SDL::Mixer::Effects::unregister( MIX_CHANNEL_POST, $music_data_effect_id );
    SDL::Mixer::Music::hook_music_finished();
    SDL::Mixer::Music::halt_music();
    SDL::Mixer::close_audio();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The result? Several dozen lines of code glue together the SDL mixer and display a real-time visualization of the music.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Perl and Mandrakelinux</title>
      <link>http://localhost:1313/pub/2005/02/24/mandrakelinux.html/</link>
      <pubDate>Thu, 24 Feb 2005 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2005/02/24/mandrakelinux.html/</guid>
      <description>&lt;p&gt;&lt;em&gt;Perl programmers have a special reason for choosing &lt;a href=&#34;http://www.mandrakelinux.com/&#34;&gt;Mandrakelinux&lt;/a&gt; as their desktop operating system. Mandrakelinux uses Perl for dozens of the graphical &amp;ldquo;value added&amp;rdquo; utilities included with the distribution, including much of the Mandrakelinux Control Center. I asked Mandrakelinux for an interview with a top Perl contributor and they sent &lt;a href=&#34;http://rgarciasuarez.free.fr/&#34;&gt;Rafael Garcia-Suarez&lt;/a&gt; my way. Besides being heavily involved with Perl at Mandrakesoft, Rafael is also the pumpking for the Perl 5.10 release. Rafael answered my questions about using Perl for GUI programming and how he balances his day job with being pumpking.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O&amp;rsquo;Reilly Network:&lt;/strong&gt; Briefly tell us about the Perl work you do for Mandrakelinux.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rafael:&lt;/strong&gt; My main responsibility is to maintain and enhance the command-line tool urpmi (and its GUI counterpart rpmdrake), which are the Mandrakelinux equivalent of Debian&amp;rsquo;s apt or Fedora&amp;rsquo;s yum; that is, fetching RPMs and their dependencies and installing or upgrading them.&lt;/p&gt;

&lt;p&gt;This job extends to whatever pertains to installing RPMs; that means that I also participate in enhancing Mandrakelinux&amp;rsquo;s installer. All those tools are written in Perl.&lt;/p&gt;

&lt;p&gt;Besides this, I also maintain the RPM of perl itself and of a load of CPAN modules for Mandrakelinux.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ORN:&lt;/strong&gt; Perl is uncommon choice for graphical programming, yet Mandrakelinux has used Perl for over 50 graphical applications. Many of these tools are specific to Mandrakelinux, adding value to the distribution. What can you tell us about why Mandrakelinux uses Perl for this important role?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rafael:&lt;/strong&gt; Not all tools were always written in Perl. However using consistently a same language allows to share and reuse libraries across all tools, be it the perl/rpmlib bindings or custom graphical toolboxes. Thus, for example, the OS installer shares code with urpmi and rpmdrake. A scripting language was preferred because of rapidity of development and ease of debug &amp;ndash; attempts at writing rpmdrake in C were painful, although that was before I was hired by Mandrakesoft. Perl was a natural choice since there were already very good in-house skills for it.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editors note: Recently, the &lt;a href=&#34;http://www.linspire.com/&#34;&gt;Linspire&lt;/a&gt; distributionexemplified the use of dynamic languages to bring a graphical application to market quickly. Their &lt;a href=&#34;http://info.linspire.com/lsongs/&#34;&gt;Lsongs&lt;/a&gt; nd &lt;a href=&#34;http://info.linspire.com/lphoto/&#34;&gt;Lphoto&lt;/a&gt; programs use Python.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ORN:&lt;/strong&gt; Could you give a specific example of where Perl has made a noticeable difference in shortening development time?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rafael:&lt;/strong&gt; I think that using a scripting language in general shortens the development time, notably due to the shorter write code / compile / test / debug cycle. However perl is particularly useful due to the high number of development modules available on CPAN. For example running the OS installer under &lt;a href=&#34;https://metacpan.org/pod/Devel::Trace&#34;&gt;Devel::Trace&lt;/a&gt; produces lots of logs, but is tremendously helpful to trace obscure bugs. You can&amp;rsquo;t do this in C without adding &lt;code&gt;printf&lt;/code&gt;s everywhere and recompiling the whole stuff.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ORN:&lt;/strong&gt; What tools does Mandrakelinux use for automated testing of graphical Perl applications?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rafael:&lt;/strong&gt; Er, interns ?&lt;/p&gt;

&lt;p&gt;More seriously, there is no automated testing for GUIs. Automated testing of such applications raises several difficult problems, since they often modify a system&amp;rsquo;s configuration or necessitate some specific hardware (and I&amp;rsquo;m not even speaking of the OS installer GUI).&lt;/p&gt;

&lt;p&gt;Writing more unit tests is definitively something I want to do in the future, however; it would be very useful to have complete sets of regression tests for the urpmi dependency solver, for example.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ORN:&lt;/strong&gt; What has been the response of the Perl community to Mandrakelinux Perl-based tools, especially in terms of contributing patches back to your organization?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rafael:&lt;/strong&gt; The people who send patches for the tools are mostly interested in improving the distribution they use; even if they might belong to the Perl community as well, their point of view is the one of a Mandrakelinux user. That&amp;rsquo;s one of the reasons why the tools have little visibility outside the MDK community.&lt;/p&gt;

&lt;p&gt;Another reason is that there never was a strong motivation in Mandrakesoft for splitting the libraries in what is and is not MDK-specific, and to write clear and comprehensive documentation: both need efforts, don&amp;rsquo;t pay immediately and are likely to be postponed when you have deadlines.&lt;/p&gt;

&lt;p&gt;However, the CVS repository in which the tools&amp;rsquo; source code is kept is openly accessible; some contributors (i.e. non Mandrakesoft employees) have been granted commit access to it. We now need to make the learning curve softer.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ORN:&lt;/strong&gt;What advice do have for Perl programmers interested in contributing to the Perl-based Mandrakelinux utilities? Any helpful hints for getting started?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rafael:&lt;/strong&gt; As with any open-source project, if you want to learn how it&amp;rsquo;s done and to contribute, use the latest version available. In the case of Mandrakelinux, that would be &amp;ldquo;cooker&amp;rdquo;, the development distribution. Subscribe to the mailing list, become familiar with the tools, have a checkout from the CVS repository, get yourself a Bugzilla account and don&amp;rsquo;t be afraid to ask questions. Learning to build RPMs, at least to be able to rebuild the RPMs of the tools, would be helpful too. Those questions are covered in the wiki; a good page to begin with is:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://qa.mandrakesoft.com/twiki/bin/view/Main/HowTo&#34;&gt;http://qa.mandrakesoft.com/twiki/bin/view/Main/HowTo&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;ORN:&lt;/strong&gt; What challenges have you faced maintaining Perl as a core part of the operating system, with so many key utilities depending on it?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rafael:&lt;/strong&gt; There are two kinds of challenges: spatial and temporal, would I say.&lt;/p&gt;

&lt;p&gt;First, spatially, you have to devise how to split the standard Perl distribution on smaller packages (&amp;ldquo;perl-base&amp;rdquo; for the essentials, &amp;ldquo;perl&amp;rdquo; for the rest of modules, &amp;ldquo;perl-devel&amp;rdquo; for Perl development tools and &amp;ldquo;perl-doc&amp;rdquo; for, well, perldoc itself and the standard documentation.) This split is not arbitrary. When you maintain a core tool like urpmi, which is essential to system administration, you don&amp;rsquo;t want it to require too many Perl modules, or even too many core modules. (The same goes for the installer, that must not take all the space on the installation CDs). So perl-base contains the modules used by urpmi, and urpmi doesn&amp;rsquo;t use modules that are in perl but not in perl-base.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ORN:&lt;/strong&gt; Perl has a reputation for being &amp;ldquo;slow&amp;rdquo; when used for graphical programming. How is that addressed in Mandrakelinux applications?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rafael:&lt;/strong&gt; I think that Perl doesn&amp;rsquo;t deserve this reputation, only some Perl programs do ! The MDK tools use the perl-Gtk2 bindings (mostly for historical reasons, the Qt bindings weren&amp;rsquo;t mature enough when the development of those tools started); and since they&amp;rsquo;re pretty close to the C lib, performance is very acceptable.&lt;/p&gt;

&lt;p&gt;Did you know that the game &lt;a href=&#34;http://www.frozen-bubble.org/&#34;&gt;Frozen Bubble&lt;/a&gt;, written by a former Mandrakesoft employee, is implemented in Perl ? It&amp;rsquo;s not anywhere near slow. Actually people are often surprised to learn that Frozen Bubble or the MDK tools are written in Perl, since they don&amp;rsquo;t give the impression of slowness generally associated to scripted GUIs.&lt;/p&gt;

&lt;p&gt;In fact, it appears that the speed bottlenecks of the MDK tools are, like in other programs, data processing, not display.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ORN:&lt;/strong&gt; You&amp;rsquo;ve recently become the pumpking for Perl 5.10. How does your this interact with your day job and how do you balance the two positions?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rafael:&lt;/strong&gt; I was deeply involved in the development of Perl 5 before that, taking time to review and apply patches and so on. So I was mostly working on it on evenings and week-ends. I can now work on Perl 5 during my dayjob, since Mandrakesoft allows its developers to work on free projects they like part time. However, I&amp;rsquo;d point out that my day job is a bit special, since, contrary to proprietary projects, I&amp;rsquo;m always in contact with its community of users, via mail, IRC or other internet-based media (and even sometimes in real life.) Thus I&amp;rsquo;m sometimes led to work during my free time as well&amp;hellip; In other words the frontier between day job and other open source development is blurred. In both cases things have to be done. The only difference is that for the day job thing, I have deadlines, and they pay me for it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ORN:&lt;/strong&gt; Do you have a favorite Perl module that more people should know about?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rafael:&lt;/strong&gt; I don&amp;rsquo;t really know, I learn new modules mostly by hanging around in places where the cool kids discover them before me &amp;ndash; mailing lists, mongers, &lt;a href=&#34;http://use.perl.org/&#34;&gt;use.perl&lt;/a&gt;. I use &lt;a href=&#34;https://metacpan.org/pod/B::Concise&#34;&gt;B::Concise&lt;/a&gt; all the time, but I suspect it&amp;rsquo;s not useful for people who are not familiar with the internals of perl. Also, recently, I found &lt;a href=&#34;https://metacpan.org/pod/encoding::warnings&#34;&gt;encoding::warnings&lt;/a&gt; useful for debugging Unicode-related bugs.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

