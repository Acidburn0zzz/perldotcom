<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Perl Cookbook on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/perl-cookbook/</link>
    <description>Recent content in Perl Cookbook on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 17 Sep 2003 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/perl-cookbook/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Cooking with Perl, Part 3</title>
      <link>http://localhost:1313/pub/2003/09/17/perlcookbook.html/</link>
      <pubDate>Wed, 17 Sep 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/09/17/perlcookbook.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: In this third and final batch of recipes excerpted from &lt;a href=&#34;http://www.oreilly.com/catalog/perlckbk2/index.html?CMP=IL7015&#34;&gt;Perl Cookbook&lt;/a&gt;, you&amp;rsquo;ll find solutions and code examples for extracting HTML table data, templating with HTML::Mason, and making simple changes to elements or text.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;sample-recipe-extracting-table-data&#34;&gt;Sample Recipe: Extracting Table Data&lt;/h3&gt;

&lt;h4 id=&#34;problem&#34;&gt;Problem&lt;/h4&gt;

&lt;p&gt;You have data in an HTML table, and you would like to turn that into a Perl data structure. For example, you want to monitor changes to an author&amp;rsquo;s CPAN module list.&lt;/p&gt;

&lt;h4 id=&#34;solution&#34;&gt;Solution&lt;/h4&gt;

&lt;p&gt;Use the HTML::TableContentParser module from CPAN:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use HTML::TableContentParser;
 
$tcp = HTML::TableContentParser-&amp;gt;new;
$tables = $tcp-&amp;gt;parse($HTML);
 
foreach $table (@$tables) {
  @headers = map { $_-&amp;gt;{data} } @{ $table-&amp;gt;{headers} };
  # attributes of table tag available as keys in hash
  $table_width = $table-&amp;gt;{width};
 
  foreach $row (@{ $tables-&amp;gt;{rows} }) {
    # attributes of tr tag available as keys in hash
    foreach $col (@{ $row-&amp;gt;{cols} }) {
      # attributes of td tag available as keys in hash
      $data = $col-&amp;gt;{data};
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;discussion&#34;&gt;Discussion&lt;/h4&gt;

&lt;p&gt;The HTML::TableContentParser module converts all tables in the HTML document into a Perl data structure. As with HTML tables, there are three layers of nesting in the data structure: the table, the row, and the data in that row.&lt;/p&gt;

&lt;p&gt;Each table, row, and data tag is represented as a hash reference. The hash keys correspond to attributes of the tag that defined that table, row, or cell. In addition, the value for a special key gives the contents of the table, row, or cell. In a table, the value for the &lt;code&gt;rows&lt;/code&gt; key is a reference to an array of rows. In a row, the &lt;code&gt;cols&lt;/code&gt; key points to an array of cells. In a cell, the &lt;code&gt;data&lt;/code&gt; key holds the HTML contents of the data tag.&lt;/p&gt;

&lt;p&gt;For example, take the following table:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;table width=&amp;quot;100%&amp;quot; bgcolor=&amp;quot;#ffffff&amp;quot;&amp;gt;
  &amp;lt;tr&amp;gt;
    &amp;lt;td&amp;gt;Larry &amp;amp;amp; Gloria&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;Mountain View&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;California&amp;lt;/td&amp;gt;
  &amp;lt;/tr&amp;gt;
  &amp;lt;tr&amp;gt;
    &amp;lt;td&amp;gt;&amp;lt;b&amp;gt;Tom&amp;lt;/b&amp;gt;&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;Boulder&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;Colorado&amp;lt;/td&amp;gt;
  &amp;lt;/tr&amp;gt;
  &amp;lt;tr&amp;gt;
    &amp;lt;td&amp;gt;Nathan &amp;amp;amp; Jenine&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;Fort Collins&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;Colorado&amp;lt;/td&amp;gt;
  &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;parse&lt;/code&gt; method returns this data structure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  {
    &#39;width&#39; =&amp;gt; &#39;100%&#39;,
    &#39;bgcolor&#39; =&amp;gt; &#39;#ffffff&#39;,
    &#39;rows&#39; =&amp;gt; [
               {
                &#39;cells&#39; =&amp;gt; [
                            { &#39;data&#39; =&amp;gt; &#39;Larry &amp;amp;amp; Gloria&#39; },
                            { &#39;data&#39; =&amp;gt; &#39;Mountain View&#39; },
                            { &#39;data&#39; =&amp;gt; &#39;California&#39; },
                           ],
                &#39;data&#39; =&amp;gt; &amp;quot;\n      &amp;quot;
               },
               {
                &#39;cells&#39; =&amp;gt; [
                            { &#39;data&#39; =&amp;gt; &#39;&amp;lt;b&amp;gt;Tom&amp;lt;/b&amp;gt;&#39; },
                            { &#39;data&#39; =&amp;gt; &#39;Boulder&#39; },
                            { &#39;data&#39; =&amp;gt; &#39;Colorado&#39; },
                           ],
                &#39;data&#39; =&amp;gt; &amp;quot;\n      &amp;quot;
               },
               {
                &#39;cells&#39; =&amp;gt; [
                            { &#39;data&#39; =&amp;gt; &#39;Nathan &amp;amp;amp; Jenine&#39; },
                            { &#39;data&#39; =&amp;gt; &#39;Fort Collins&#39; },
                            { &#39;data&#39; =&amp;gt; &#39;Colorado&#39; },
                           ],
                &#39;data&#39; =&amp;gt; &amp;quot;\n      &amp;quot;
               }
              ]
  }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The data tags still contain tags and entities. If you don&amp;rsquo;t want the tags and entities, remove them by hand using techniques from &amp;ldquo;Extracting or Removing HTML Tags.&amp;rdquo;&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;div class=&#34;secondary&#34;&gt;
&lt;h4 id=&#34;previous-articles-in-this-series&#34;&gt;Previous Articles in this Series&lt;/h4&gt;
&lt;p&gt;• &lt;a href=&#34;http://localhost:1313/pub/2003/08/21/perlcookbook.html&#34;&gt;Cooking with Perl&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2003/09/03/perlcookbook.html&#34;&gt;Cooking with Perl, Part 2&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a href=&#34;http://admin.oreillynet.com/catalog/perlckbk2/excerpts/ch20.html#77026&#34;&gt;Example 20-11&lt;/a&gt; fetches a particular CPAN author&amp;rsquo;s page and displays in plain text the modules they own. You could use this as part of a system that notifies you when your favorite CPAN authors do something new.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example 20-11:&lt;/strong&gt; &lt;strong&gt;Dump modules for a particular CPAN author&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #!/usr/bin/perl -w
  # dump-cpan-modules-for-author - display modules a CPAN author owns
  use LWP::Simple;
  use URI;
  use HTML::TableContentParser;
  use HTML::Entities;
  use strict;
  our $URL = shift || &#39;http://search.cpan.org/author/TOMC/&#39;;
  my $tables = get_tables($URL);
  my $modules = $tables-&amp;gt;[4];    # 5th table holds module data
  foreach my $r (@{ $modules-&amp;gt;{rows} }) {
    my ($module_name, $module_link, $status, $description) =
        parse_module_row($r, $URL);
    print &amp;quot;$module_name &amp;lt;$module_link&amp;gt;\n\t$status\n\t$description\n\n&amp;quot;;
  }
  sub get_tables {
    my $URL = shift;
    my $page = get($URL);
    my $tcp = new HTML::TableContentParser;
    return $tcp-&amp;gt;parse($page);
  }
  sub parse_module_row {
    my ($row, $URL) = @_;
    my ($module_html, $module_link, $module_name, $status, $description);
    # extract cells
    $module_html = $row-&amp;gt;{cells}[0]{data};  # link and name in HTML
    $status      = $row-&amp;gt;{cells}[1]{data};  # status string and link
    $description = $row-&amp;gt;{cells}[2]{data};  # description only
    $status =~ s{&amp;lt;.*?&amp;gt;}{  }g; # naive link removal, works on this simple HTML
    # separate module link and name from html
    ($module_link, $module_name) = $module_html =~ m{href=&amp;quot;(.*?)&amp;quot;.*?&amp;gt;(.*)&amp;lt;}i;
    $module_link = URI-&amp;gt;new_abs($module_link, $URL); # resolve relative links
    # clean up entities and tags
    decode_entities($module_name);
    decode_entities($description);
    return ($module_name, $module_link, $status, $description);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;see-also&#34;&gt;See Also&lt;/h4&gt;

&lt;p&gt;The documentation for the CPAN module &lt;a href=&#34;https://metacpan.org/pod/HTML::TableContentParser&#34;&gt;HTML::TableContentParser&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;sample-recipe-templating-with-html-mason&#34;&gt;Sample Recipe: Templating with HTML::Mason&lt;/h3&gt;

&lt;h3 id=&#34;problem-1&#34;&gt;Problem&lt;/h3&gt;

&lt;p&gt;You want to separate presentation (HTML formatting) from logic (Perl code) in your program. Your web site has a lot of components with only slight variations between them. You&amp;rsquo;d like to abstract out common elements and build your pages from templates without having a lot of &amp;ldquo;if I&amp;rsquo;m in this page, then print this; else if I&amp;rsquo;m in some other page &amp;hellip; &amp;rdquo; conditional statements in a single master template.&lt;/p&gt;

&lt;h4 id=&#34;solution-1&#34;&gt;Solution&lt;/h4&gt;

&lt;p&gt;Use HTML::Mason components and inheritance.&lt;/p&gt;

&lt;h4 id=&#34;discussion-1&#34;&gt;Discussion&lt;/h4&gt;

&lt;p&gt;HTML::Mason (also simply called Mason) offers the power of Perl in templates. The basic unit of a web site built with Mason is the component&amp;ndash;a file that produces output. The file can be HTML, Perl, or a mixture of both. Components can take arguments and execute arbitrary Perl code. Mason has many features, documented at &lt;a href=&#34;http://masonhq.com/&#34;&gt;http://masonhq.com/&lt;/a&gt; and in Embedding Perl in HTML with Mason by Dave Rolsky and Ken Williams (O&amp;rsquo;Reilly; online at &lt;a href=&#34;http://masonbook.com/&#34;&gt;http://masonbook.com/&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Mason works equally well with CGI, mod_perl, and non-web programs. For the purposes of this recipe, however, we look at how to use it with mod_perl. The rest of this recipe contains a few demonstrations to give you a feel for what you can do with Mason and how your site will be constructed. There are more tricks, traps, and techniques for everything we discuss, though, so be sure to visit the web site and read the book for the full story.&lt;/p&gt;

&lt;h5 id=&#34;configuration&#34;&gt;Configuration&lt;/h5&gt;

&lt;p&gt;Install the HTML-Mason distribution from CPAN and add the following to your &lt;em&gt;httpd.conf&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PerlModule HTML::Mason::ApacheHandler
&amp;lt;Location /mason&amp;gt;
  SetHandler perl-script
  PerlHandler HTML::Mason::ApacheHandler
  DefaultType text/html
&amp;lt;/Location&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This tells mod_perl that every URL that starts with &lt;code&gt;/mason&lt;/code&gt; is handled by Mason. So if you request &lt;code&gt;/mason/hello.html&lt;/code&gt;, the file &lt;em&gt;mason/hello.html&lt;/em&gt; in your document directory will be compiled and executed as a Mason component. The DefaultType directive lets you omit the &lt;em&gt;.html&lt;/em&gt; from component names.&lt;/p&gt;

&lt;p&gt;Next create a directory for Mason to cache the compiled components in. Mason does this to speed up execution.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd $SERVER_ROOT
mkdir mason
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then make a &lt;em&gt;mason&lt;/em&gt; directory for components to live in:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd $DOCUMENT_ROOT
mkdir mason
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you&amp;rsquo;re ready for &amp;ldquo;Hello, World&amp;rdquo;. Put this in &lt;em&gt;mason/hello&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hello, &amp;lt;% (&amp;quot;World&amp;quot;, &amp;quot;Puny Human&amp;quot;)[rand 2] %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Restart Apache and load up the &lt;em&gt;mason/hello&lt;/em&gt; page. If you reload it, you should see &amp;ldquo;Hello, World&amp;rdquo; and &amp;ldquo;Hello, Puny Human&amp;rdquo; randomly. If not, look at the Mason FAQ (&lt;a href=&#34;http://www.masonhq.com/docs/faq/&#34;&gt;http://www.masonhq.com/docs/faq/&lt;/a&gt;), which answers most commonly encountered problems.&lt;/p&gt;

&lt;h5 id=&#34;basic-mason-syntax&#34;&gt;Basic Mason syntax&lt;/h5&gt;

&lt;p&gt;There are four types of new markup in Mason components: substitutions, Perl code, component calls, and block tags. You saw a substitution in the &amp;ldquo;Hello World&amp;rdquo; example: &lt;code&gt;&amp;lt;% ...  %&amp;gt;&lt;/code&gt; evaluates the contents as Perl code and inserts the result into the surrounding text.&lt;/p&gt;

&lt;p&gt;Perl code is marked with a &lt;code&gt;%&lt;/code&gt; at the start of the line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% $now = localtime;   # embedded Perl
This page was generated on &amp;lt;% $now %&amp;gt;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because substitutions can be almost any Perl code you like, this could have been written more simply as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;This page was generated on &amp;lt;% scalar localtime %&amp;gt;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If either of these variations were saved in &lt;em&gt;footer.mas&lt;/em&gt;, you could include it simply by saying:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;&amp;amp; footer.mas &amp;amp;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is an example of a component call&amp;ndash;Mason runs the component and inserts its result into the document that made the call.&lt;/p&gt;

&lt;p&gt;Block tags define different regions of your component. &lt;code&gt;&amp;lt;%perl&amp;gt; ... &amp;lt;/%perl&amp;gt;&lt;/code&gt; identifies Perl code. While &lt;code&gt;%&lt;/code&gt; at the start of a line indicates that just that line is Perl code, you can have any number of lines in a &lt;code&gt;&amp;lt;%perl&amp;gt;&lt;/code&gt; block.&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;&amp;lt;%init&amp;gt; ... &amp;lt;/%init&amp;gt;&lt;/code&gt; block is like an INIT block in Perl. The code in the block is executed before the main body of code. It lets you store definitions, initialization, database connections, etc. at the bottom of your component, where they&amp;rsquo;re out of the way of the main logic.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;&amp;lt;%args&amp;gt; ... &amp;lt;/%args&amp;gt;&lt;/code&gt; block lets you define arguments to your component, optionally with default values. For example, here&amp;rsquo;s &lt;em&gt;greet.mas&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;%args&amp;gt;
   $name =&amp;gt; &amp;quot;Larry&amp;quot;
   $town =&amp;gt; &amp;quot;Mountain View&amp;quot;
&amp;lt;/%args&amp;gt;
Hello, &amp;lt;% $name %&amp;gt;.  How&#39;s life in &amp;lt;% $town %&amp;gt;?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Calling it with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;&amp;amp; greet.mas &amp;amp;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;emits:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hello, Larry.  How&#39;s life in Mountain View?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can provide options on the component call:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;&amp;amp; greet.mas, name =&amp;gt; &amp;quot;Nat&amp;quot;, town =&amp;gt; &amp;quot;Fort Collins&amp;quot; &amp;amp;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That emits:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hello, Nat.  How&#39;s life in Fort Collins?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because there are default values, you can supply only some of the arguments:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;&amp;amp; greet.mas, name =&amp;gt; &amp;quot;Bob&amp;quot; &amp;amp;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That emits:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hello, Bob.  How&#39;s life in Mountain View?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Arguments are also how Mason components access form parameters. Take this form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;form action=&amp;quot;compliment&amp;quot;&amp;gt;
  How old are you?  &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;age&amp;quot;&amp;gt; &amp;lt;br /&amp;gt;
  &amp;lt;input type=&amp;quot;submit&amp;quot;&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s a &lt;em&gt;compliment&lt;/em&gt; component that could take that parameter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;%args&amp;gt;
  $age
&amp;lt;/%args&amp;gt;
Hi.  Are you really &amp;lt;% $age %&amp;gt;?  You don&#39;t look it!
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;objects&#34;&gt;Objects&lt;/h5&gt;

&lt;p&gt;All Mason components have access to a &lt;code&gt;$m&lt;/code&gt; variable, which contains an HTML::Mason::Request object. Methods on this object give access to Mason features. For example, you can redirect with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$m-&amp;gt;redirect($URL);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;$r&lt;/code&gt; variable is the mod_perl request object, so you have access to the information and functions of Apache from your Mason handlers. For example, you can discover the client&amp;rsquo;s IP address with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ip = $r-&amp;gt;connection-&amp;gt;remote_ip;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;autohandlers&#34;&gt;Autohandlers&lt;/h5&gt;

&lt;p&gt;When a page is requested through Mason, Mason can do more than simply execute the code in that page. Mason inspects each directory between the component root and the requested page, looking for components called &lt;em&gt;autohandler&lt;/em&gt;. This forms a &lt;em&gt;wrapping chain&lt;/em&gt;, with the top-level autohandler at the start of the chain and the requested page at the end. Mason then executes the code at the start of the chain. Each autohandler can say &amp;ldquo;insert the output of the next component in the chain here.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Imagine a newspaper site. Some parts don&amp;rsquo;t change, regardless of which article you&amp;rsquo;re looking at: the banner at the top, the random selection of ads, the list of sections down the lefthand side. However, the actual article text varies from article to article. Implement this in Mason with a directory structure like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/sports
/sports/autohandler
/sports/story1
/sports/story2
/sports/story3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The individual story files contain only the text of each story. The autohandler builds the page (the banner, the ads, the navigation bar), and when it wants to insert the content of the story, it says:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% $m-&amp;gt;call_next;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This tells Mason to call the next component in the chain (the story) and insert its output here.&lt;/p&gt;

&lt;p&gt;The technique of having a chain of components is called &lt;em&gt;inheritance&lt;/em&gt;, and autohandlers aren&amp;rsquo;t the only way to do it. In a component, you can designate a parent with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;%flags&amp;gt;
  inherit = &#39;parent.mas&#39;
&amp;lt;/%flags&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This lets you have different types of content in the one directory, and each contained component gets to identify its surrounding page (its parent).&lt;/p&gt;

&lt;h5 id=&#34;dhandlers&#34;&gt;Dhandlers&lt;/h5&gt;

&lt;p&gt;Sometimes it&amp;rsquo;s nice to provide the illusion of a directory full of pages, when in reality they are all dynamically generated. For example, stories kept in a database could be accessed through URLs like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/sports/1
/sports/2
/sports/3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Mason way to dynamically generate the pages at these URLs is with a component called &lt;em&gt;dhandler&lt;/em&gt; in the &lt;em&gt;sports&lt;/em&gt; directory. The &lt;em&gt;dhandler&lt;/em&gt; component accesses the name of the missing page (&lt;em&gt;123&lt;/em&gt; in this case) by calling:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$m-&amp;gt;dhandler_arg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You could then use this to retrieve the story from the database and insert it into a page template.&lt;/p&gt;

&lt;h4 id=&#34;see-also-1&#34;&gt;See Also&lt;/h4&gt;

&lt;p&gt;Recipe 15.11 in mod_perl Developer&amp;rsquo;s Cookbook; Embedding Perl in HTML with Mason; &lt;a href=&#34;http://www.masonhq.com/&#34;&gt;http://www.masonhq.com/&lt;/a&gt; and &lt;a href=&#34;http://www.masonbook.com/&#34;&gt;http://www.masonbook.com/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;sample-recipe-making-simple-changes-to-elements-or-text&#34;&gt;Sample Recipe: Making Simple Changes to Elements or Text&lt;/h3&gt;

&lt;h3 id=&#34;problem-2&#34;&gt;Problem&lt;/h3&gt;

&lt;p&gt;You want to filter some XML. For example, you want to make substitutions in the body of a document, or add a price to every book described in an XML document, or you want to change &lt;code&gt;&amp;lt;book  id=&amp;quot;1&amp;quot;&amp;gt;&lt;/code&gt; to &lt;code&gt;&amp;lt;book&amp;gt;  &amp;lt;id&amp;gt;1&amp;lt;/id&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;solution-2&#34;&gt;Solution&lt;/h4&gt;

&lt;p&gt;Use the XML::SAX::Machines module from CPAN:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/perl -w
 
use MySAXFilter1;
use MySAXFilter2;
use XML::SAX::ParserFactory;
use XML::SAX::Machines qw(Pipeline);
 
my $machine = Pipeline(MySAXFilter1 =&amp;gt; MySAXFilter2); # or more
$machine-&amp;gt;parse_uri($FILENAME);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Write a handler, inheriting from XML::SAX::Base as in &amp;ldquo;Parsing XML into SAX Events,&amp;rdquo; then whenever you need a SAX event, call the appropriate handler in your superclass. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$self-&amp;gt;SUPER::start_element($tag_struct);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;discussion-2&#34;&gt;Discussion&lt;/h4&gt;

&lt;p&gt;A SAX filter accepts SAX events and triggers new ones. The XML::SAX::Base module detects whether your handler object is called as a filter. If so, the XML::SAX::Base methods pass the SAX events onto the next filter in the chain. If your handler object is not called as a filter, then the XML::SAX::Base methods consume events but do not emit them. This makes it almost as simple to write events as it is to consume them.&lt;/p&gt;

&lt;p&gt;The XML::SAX::Machines module chains the filters for you. Import its &lt;code&gt;Pipeline&lt;/code&gt; function, then say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $machine = Pipeline(Filter1 =&amp;gt; Filter2 =&amp;gt; Filter3 =&amp;gt; Filter4);
$machine-&amp;gt;parse_uri($FILENAME);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SAX events triggered by parsing the XML file go to Filter1, which sends possibly different events to Filter2, which in turn sends events to Filter3, and so on to Filter4. The last filter should print or otherwise do something with the incoming SAX events. If you pass a reference to a typeglob, XML::SAX::Machines writes the XML to the filehandle in that typeglob.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://admin.oreillynet.com/catalog/perlckbk2/excerpts/ch22.html#45625&#34;&gt;Example 22-5&lt;/a&gt; shows a filter that turns the &lt;code&gt;id&lt;/code&gt; attribute in &lt;code&gt;book&lt;/code&gt; elements from the XML document in Example 22-1 into a new &lt;code&gt;id&lt;/code&gt; element. For example, &lt;code&gt;&amp;lt;book id=&amp;quot;1&amp;quot;&amp;gt;&lt;/code&gt; becomes &lt;code&gt;&amp;lt;book&amp;gt;&amp;lt;id&amp;gt;1&amp;lt;/id&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;45625&#34;&gt;Example 22-5:&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;filters-rewriteids&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package RewriteIDs;
# RewriteIDs.pm -- turns &amp;quot;id&amp;quot; attributes into elements
 
use base qw(XML::SAX::Base);
 
my $ID_ATTRIB = &amp;quot;{  }id&amp;quot;;   # the attribute hash entry we&#39;re interested in
 
sub start_element {
    my ($self, $data) = @_;
 
    if ($data-&amp;gt;{Name} eq &#39;book&#39;) {
        my $id = $data-&amp;gt;{Attributes}{$ID_ATTRIB}{Value};
        delete $data-&amp;gt;{Attributes}{$ID_ATTRIB};
        $self-&amp;gt;SUPER::start_element($data);
 
        # make new element parameter data structure for the &amp;lt;id&amp;gt; tag
        my $id_node = {  };
        %$id_node = %$self;
        $id_node-&amp;gt;{Name} = &#39;id&#39;;     # more complex if namespaces involved
        $id_node-&amp;gt;{Attributes} = {  };
 
        # build the &amp;lt;id&amp;gt;$id&amp;lt;/id&amp;gt;
        $self-&amp;gt;SUPER::start_element($id_node);
        $self-&amp;gt;SUPER::characters({ Data =&amp;gt; $id });
        $self-&amp;gt;SUPER::end_element($id_node);
    } else {
        $self-&amp;gt;SUPER::start_element($data);
    }
}
 
1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://admin.oreillynet.com/catalog/perlckbk2/excerpts/ch22.html#15387&#34;&gt;Example 22-6&lt;/a&gt; is the stub that uses XML::SAX::Machines to create the pipeline for processing &lt;em&gt;books.xml&lt;/em&gt; and print the altered XML.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;15387&#34;&gt;Example 22-6:&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;filters-rewriteprog&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/perl -w
# rewrite-ids -- call RewriteIDs SAX filter to turn id attrs into elements
 
use RewriteIDs;
use XML::SAX::Machines qw(:all);
 
my $machine = Pipeline(RewriteIDs =&amp;gt; *STDOUT);
$machine-&amp;gt;parse_uri(&amp;quot;books.xml&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output of &lt;a href=&#34;http://admin.oreillynet.com/catalog/perlckbk2/excerpts/ch22.html#15387&#34;&gt;Example 22-6&lt;/a&gt; is as follows (truncated for brevity):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;book&amp;gt;&amp;lt;id&amp;gt;1&amp;lt;/id&amp;gt;
    &amp;lt;title&amp;gt;Programming Perl&amp;lt;/title&amp;gt;
 ...
&amp;lt;book&amp;gt;&amp;lt;id&amp;gt;2&amp;lt;/id&amp;gt;
    &amp;lt;title&amp;gt;Perl &amp;amp;amp; LWP&amp;lt;/title&amp;gt;
 ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To save the XML to the file &lt;em&gt;new-books.xml&lt;/em&gt;, use the XML::SAX::Writer module:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/perl -w
 
use RewriteIDs;
use XML::SAX::Machines qw(:all);
use XML::SAX::Writer;
 
my $writer = XML::SAX::Writer-&amp;gt;new(Output =&amp;gt; &amp;quot;new-books.xml&amp;quot;);
my $machine = Pipeline(RewriteIDs =&amp;gt; $writer);
$machine-&amp;gt;parse_uri(&amp;quot;books.xml&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also pass a scalar reference as the &lt;code&gt;Output&lt;/code&gt; parameter to have the XML appended to the scalar; as an array reference to have the XML appended to the array, one array element per SAX event; or as a filehandle to have the XML printed to that filehandle.&lt;/p&gt;

&lt;h4 id=&#34;see-also-2&#34;&gt;See Also&lt;/h4&gt;

&lt;p&gt;The documentation for the modules XML::SAX::Machines and XML::SAX::Writer&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Cooking with Perl, Part 2</title>
      <link>http://localhost:1313/pub/2003/09/03/perlcookbook.html/</link>
      <pubDate>Wed, 03 Sep 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/09/03/perlcookbook.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: The new edition of &lt;a href=&#34;http://www.oreilly.com/catalog/perlckbk2/index.html?CMP=IL7015&#34;&gt;Perl Cookbook&lt;/a&gt; has released, so this week we continue to highlight recipes&amp;ndash;new to the second edition&amp;ndash;for your sampling pleasure. This week&amp;rsquo;s excerpts include recipes from Chapter 14 (&amp;ldquo;Database Access&amp;rdquo;) and Chapter 18 (&amp;ldquo;Internet Services&amp;rdquo;). And be sure to check back here next week for more new recipes on extracting table data, making simple changes to elements or text, and templating with HTML::Mason.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;sample-recipe-using-sql-without-a-database-server&#34;&gt;Sample Recipe: Using SQL Without a Database Server&lt;/h3&gt;

&lt;h4 id=&#34;problem&#34;&gt;Problem&lt;/h4&gt;

&lt;p&gt;You want to make complex SQL queries but don&amp;rsquo;t want to maintain a relational database server.&lt;/p&gt;

&lt;h4 id=&#34;solution&#34;&gt;Solution&lt;/h4&gt;

&lt;p&gt;Use the DBD::SQLite module from CPAN:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use DBI;
 
$dbh = DBI-&amp;gt;connect(&amp;quot;dbi:SQLite:dbname=/Users/gnat/salaries.sqlt&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;,
                    { RaiseError =&amp;gt; 1, AutoCommit =&amp;gt; 1 });
 
$dbh-&amp;gt;do(&amp;quot;UPDATE salaries SET salary = 2 * salary WHERE name = &#39;Nat&#39;&amp;quot;);
 
$sth = $dbh-&amp;gt;prepare(&amp;quot;SELECT id,deductions FROM salaries WHERE name = &#39;Nat&#39;&amp;quot;);
# ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;discussion&#34;&gt;Discussion&lt;/h4&gt;

&lt;p&gt;An SQLite database lives in a single file, specified with the &lt;code&gt;dbname&lt;/code&gt; parameter in the DBI constructor. Unlike most relational databases, there&amp;rsquo;s no database server here&amp;ndash;DBD::SQLite interacts directly with the file. Multiple processes can read from the same database file at the same time (with SELECTs), but only one process can make changes (and other processes are prevented from reading while those changes are being made).&lt;/p&gt;

&lt;p&gt;SQLite supports transactions. That is, you can make a number of changes to different tables, but the updates won&amp;rsquo;t be written to the file until you commit them:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use DBI;
$dbh = DBI-&amp;gt;connect(&amp;quot;dbi:SQLite:dbname=/Users/gnat/salaries.sqlt&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;,
                    { RaiseError =&amp;gt; 1, AutoCommit =&amp;gt; 0 });
eval {
  $dbh-&amp;gt;do(&amp;quot;INSERT INTO people VALUES (29, &#39;Nat&#39;, 1973)&amp;quot;);
  $dbh-&amp;gt;do(&amp;quot;INSERT INTO people VALUES (30, &#39;William&#39;, 1999)&amp;quot;);
  $dbh-&amp;gt;do(&amp;quot;INSERT INTO father_of VALUES (29, 30)&amp;quot;);
  $dbh-&amp;gt;commit(  );
};
if ($@) {
      eval { $dbh-&amp;gt;rollback(  ) };
      die &amp;quot;Couldn&#39;t roll back transaction&amp;quot; if $@;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SQLite is a typeless database system. Regardless of the types specified when you created a table, you can put any type (strings, numbers, dates, blobs) into any field. Indeed, you can even create a table without specifying any types:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE people (id, name, birth_year);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only time that data typing comes into play is when comparisons occur, either through WHERE clauses or when the database has to sort values. The database ignores the type of the column and looks only at the type of the specific value being compared. Like Perl, SQLite recognizes only strings and numbers. Two numbers are compared as floating-point values, two strings are compared as strings, and a number is always less than a string when values of two different types are compared.&lt;/p&gt;

&lt;p&gt;There is only one case when SQLite looks at the type you declare for a column. To get an automatically incrementing column, such as unique identifiers, specify a field of type &amp;ldquo;INTEGER PRIMARY KEY&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE people (id INTEGER PRIMARY KEY, name, birth_year);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;#79318&#34;&gt;Example 14-6&lt;/a&gt; shows how this is done.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;79318&#34;&gt;Example 14-6:&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;ipk&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #!/usr/bin/perl -w
  # ipk - demonstrate integer primary keys
  use DBI;
  use strict;
  my $dbh = DBI-&amp;gt;connect(&amp;quot;dbi:SQLite:ipk.dat&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;,
  {RaiseError =&amp;gt; 1, AutoCommit =&amp;gt; 1});
  # quietly drop the table if it already existed
  eval {
    local $dbh-&amp;gt;{PrintError} = 0;
    $dbh-&amp;gt;do(&amp;quot;DROP TABLE names&amp;quot;);
  };
  # (re)create it
  $dbh-&amp;gt;do(&amp;quot;CREATE TABLE names (id INTEGER PRIMARY KEY, name)&amp;quot;);
  # insert values
  foreach my $person (qw(Nat Tom Guido Larry Damian Jon)) {
    $dbh-&amp;gt;do(&amp;quot;INSERT INTO names VALUES (NULL, &#39;$person&#39;)&amp;quot;);
  }
  # remove a middle value
  $dbh-&amp;gt;do(&amp;quot;DELETE FROM names WHERE name=&#39;Guido&#39;&amp;quot;);
  # add a new value
  $dbh-&amp;gt;do(&amp;quot;INSERT INTO names VALUES (NULL, &#39;Dan&#39;)&amp;quot;);
  # display contents of the table
  my $all = $dbh-&amp;gt;selectall_arrayref(&amp;quot;SELECT id,name FROM names&amp;quot;);
  foreach my $row (@$all) {
    my ($id, $word) = @$row;
    print &amp;quot;$word has id $id\n&amp;quot;;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SQLite can hold 8-bit text data, but can&amp;rsquo;t hold an ASCII NUL character (&lt;code&gt;\0&lt;/code&gt;). The only workaround is to do your own encoding (for example, URL encoding or Base64) before you store and after you retrieve the data. This is true even of columns declared as BLOBs.&lt;/p&gt;

&lt;h4 id=&#34;see-also&#34;&gt;See Also&lt;/h4&gt;

&lt;p&gt;&amp;ldquo;Executing an SQL Command Using DBI;&amp;rdquo; the documentation for the CPAN module DBD::SQLite; the SQLite home page at &lt;a href=&#34;http://www.hwaci.com/sw/sqlite/&#34;&gt;http://www.hwaci.com/sw/sqlite/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;sample-recipe-sending-attachments-in-mail&#34;&gt;Sample Recipe: Sending Attachments in Mail&lt;/h3&gt;

&lt;h4 id=&#34;problem-1&#34;&gt;Problem&lt;/h4&gt;

&lt;p&gt;You want to send mail that includes attachments; for example, you want to mail a PDF document.&lt;/p&gt;

&lt;h4 id=&#34;solution-1&#34;&gt;Solution&lt;/h4&gt;

&lt;p&gt;Use the MIME::Lite module from CPAN. First, create a MIME::Lite object representing the multipart message:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use MIME::Lite;
 
$msg = MIME::Lite-&amp;gt;new(From    =&amp;gt; &#39;sender@example.com&#39;,
                       To      =&amp;gt; &#39;recipient@example.com&#39;,
                       Subject =&amp;gt; &#39;My photo for the brochure&#39;,
                       Type    =&amp;gt; &#39;multipart/mixed&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, add content through the &lt;code&gt;attach&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$msg-&amp;gt;attach(Type        =&amp;gt; &#39;image/jpeg&#39;,
             Path        =&amp;gt; &#39;/Users/gnat/Photoshopped/nat.jpg&#39;,
             Filename    =&amp;gt; &#39;gnat-face.jpg&#39;);
 
$msg-&amp;gt;attach(Type        =&amp;gt; &#39;TEXT&#39;,
             Data        =&amp;gt; &#39;I hope you can use this!&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, send the message, optionally specifying how to send it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$msg-&amp;gt;send(  );            # default is to use sendmail(1)
# alternatively
$msg-&amp;gt;send(&#39;smtp&#39;, &#39;mailserver.example.com&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;discussion-1&#34;&gt;Discussion&lt;/h4&gt;

&lt;p&gt;The MIME::Lite module creates and sends mail with MIME-encoded attachments. MIME stands for Multimedia Internet Mail Extensions, and is the standard way of attaching files and documents. It can&amp;rsquo;t, however, extract attachments from mail messages&amp;ndash;for that you need to read Recipe &amp;ldquo;Extracting Attachments from Mail.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;When creating and adding to a MIME::Lite object, pass parameters as a list of named parameter pairs. The pair conveys both mail headers (e.g., &lt;code&gt;From&lt;/code&gt;, &lt;code&gt;To&lt;/code&gt;, &lt;code&gt;Subject&lt;/code&gt;) and those specific to MIME::Lite. In general, mail headers should be given with a trailing colon:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$msg = MIME::Lite-&amp;gt;new(&#39;X-Song-Playing:&#39; =&amp;gt; &#39;Natchez Trace&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, MIME::Lite accepts the headers in &lt;a href=&#34;#20112&#34;&gt;Table 18-2&lt;/a&gt; without a trailing colon. &lt;code&gt;*&lt;/code&gt; indicates a wildcard, so &lt;code&gt;Content-*&lt;/code&gt; includes &lt;code&gt;Content-Type&lt;/code&gt; and &lt;code&gt;Content-ID&lt;/code&gt; but not &lt;code&gt;Dis-Content&lt;/code&gt;.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Approved&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Encrypted&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Received&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Bcc&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;From&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;References&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Subject&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Cc&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Keywords&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Reply-To&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;To&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Comments&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Message-ID&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Resent-*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;X-*&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Content-*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;MIME-Version&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Return-Path&lt;/code&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Organization&lt;/code&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The full list of MIME::Lite options is given in &lt;a href=&#34;#21965&#34;&gt;Table 18-3&lt;/a&gt;.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Data&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;FH&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ReadNow&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Datestamp&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Filename&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Top&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Disposition&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Id&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Type&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Encoding&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Length&lt;/code&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Filename&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The MIME::Lite options and their values govern what is attached (the data) and how:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Path&lt;/code&gt;
The file containing the data to attach.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Filename&lt;/code&gt;
The default filename for the reader of the message to save the file as. By default this is the filename from the &lt;code&gt;Path&lt;/code&gt; option (if &lt;code&gt;Path&lt;/code&gt; was specified).&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Data&lt;/code&gt;
The data to attach.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Type&lt;/code&gt;
The &lt;code&gt;Content-Type&lt;/code&gt; of the data to attach.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Disposition&lt;/code&gt;
Either &lt;code&gt;inline&lt;/code&gt; or &lt;code&gt;attachment&lt;/code&gt;. The former indicates that the reader should display the data as part of the message, not as an attachment. The latter indicates that the reader should display an option to decode and save the data. This is, at best, a hint.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;FH&lt;/code&gt;
An open filehandle from which to read the attachment data.&lt;/p&gt;

&lt;p&gt;There are several useful content types: &lt;code&gt;TEXT&lt;/code&gt; means &lt;code&gt;text/plain&lt;/code&gt;, which is the default; &lt;code&gt;BINARY&lt;/code&gt; similarly is short for &lt;code&gt;application/octet-stream&lt;/code&gt;; &lt;code&gt;multipart/mixed&lt;/code&gt; is used for a message that has attachments; &lt;code&gt;application/msword&lt;/code&gt; for Microsoft Word files; &lt;code&gt;application/vnd.ms-excel&lt;/code&gt; for Microsoft Excel files; &lt;code&gt;application/pdf&lt;/code&gt; for PDF files; &lt;code&gt;image/gif&lt;/code&gt;, &lt;code&gt;image/jpeg&lt;/code&gt;, and &lt;code&gt;image/png&lt;/code&gt; for GIF, JPEG, and PNG files, respectively; &lt;code&gt;audio/mpeg&lt;/code&gt; for MP3 files; &lt;code&gt;video/mpeg&lt;/code&gt; for MPEG movies; &lt;code&gt;video/quicktime&lt;/code&gt; for Quicktime (&lt;em&gt;.mov&lt;/em&gt;) files.&lt;/p&gt;

&lt;p&gt;The only two ways to send the message are using &lt;em&gt;sendmail&lt;/em&gt;(1) or using Net::SMTP. Indicate Net::SMTP by calling &lt;code&gt;send&lt;/code&gt; with a first argument of &lt;code&gt;&amp;quot;smtp&amp;quot;&lt;/code&gt;. Remaining arguments are parameters to the Net::SMTP constructor:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# timeout of 30 seconds
$msg-&amp;gt;send(&amp;quot;smtp&amp;quot;, &amp;quot;mail.example.com&amp;quot;, Timeout =&amp;gt; 30);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you plan to make more than one MIME::Lite object, be aware that invoking &lt;code&gt;send&lt;/code&gt; as a class method changes the default way to send messages:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MIME::Lite-&amp;gt;send(&amp;quot;smtp&amp;quot;, &amp;quot;mail.example.com&amp;quot;);
$msg = MIME::Lite-&amp;gt;new(%opts);
# ...
$msg-&amp;gt;send(  );                   # sends using SMTP
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you&amp;rsquo;re going to process multiple messages, also look into the &lt;code&gt;ReadNow&lt;/code&gt; parameter. This specifies that the data for the attachment should be read from the file or filehandle immediately, rather than when the message is sent, written, or converted to a string.&lt;/p&gt;

&lt;p&gt;Sending the message isn&amp;rsquo;t the only thing you can do with it. You can get the final message as a string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$text = $msg-&amp;gt;as_string;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;print&lt;/code&gt; method writes the string form of the message to a filehandle:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$msg-&amp;gt;print($SOME_FILEHANDLE);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;#85143&#34;&gt;Example 18-3&lt;/a&gt; is a program that mails filenames given on the command line as attachments.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;85143&#34;&gt;Example 18-3:&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;mail-attachment&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/perl -w
# mail-attachment - send files as attachments
 
use MIME::Lite;
use Getopt::Std;
 
my $SMTP_SERVER = &#39;smtp.example.com&#39;;           # CHANGE ME
my $DEFAULT_SENDER = &#39;sender@example.com&#39;;      # CHANGE ME
my $DEFAULT_RECIPIENT = &#39;recipient@example.com&#39;;# CHANGE ME
 
MIME::Lite-&amp;gt;send(&#39;smtp&#39;, $SMTP_SERVER, Timeout=&amp;gt;60);
 
my (%o, $msg);
 
# process options
 
getopts(&#39;hf:t:s:&#39;, \%o);
 
$o{f} ||= $DEFAULT_SENDER;
$o{t} ||= $DEFAULT_RECIPIENT;
$o{s} ||= &#39;Your binary file, sir&#39;;
 
if ($o{h} or !@ARGV) {
    die &amp;quot;usage:\n\t$0 [-h] [-f from] [-t to] [-s subject] file ...\n&amp;quot;;
}
 
# construct and send email
 
$msg = new MIME::Lite(
    From =&amp;gt; $o{f},
    To   =&amp;gt; $o{t},
    Subject =&amp;gt; $o{s},
    Data =&amp;gt; &amp;quot;Hi&amp;quot;,
    Type =&amp;gt; &amp;quot;multipart/mixed&amp;quot;,
);
 
while (@ARGV) {
  $msg-&amp;gt;attach(&#39;Type&#39; =&amp;gt; &#39;application/octet-stream&#39;,
               &#39;Encoding&#39; =&amp;gt; &#39;base64&#39;,
               &#39;Path&#39; =&amp;gt; shift @ARGV);
}
 
$msg-&amp;gt;send(  );
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;see-also-1&#34;&gt;See Also&lt;/h4&gt;

&lt;p&gt;The documentation for MIME::Lite&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;O&amp;rsquo;Reilly &amp;amp; Associates recently released (August 2003) &lt;a href=&#34;http://www.oreilly.com/catalog/perlckbk2/index.html?CMP=IL7015&#34;&gt;Perl Cookbook, 2nd Edition.&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.oreilly.com/catalog/perlckbk2/chapter/index.html?CMP=IL7015&#34;&gt;Sample Chapter 1, Strings&lt;/a&gt; is available free online.&lt;/li&gt;
&lt;li&gt;You can also look at the &lt;a href=&#34;http://www.oreilly.com/catalog/perlckbk2/toc.html?CMP=IL7015&#34;&gt;Table of Contents&lt;/a&gt;, the &lt;a href=&#34;http://www.oreilly.com/catalog/perlckbk2/inx.html?CMP=IL7015&#34;&gt;Index&lt;/a&gt;, and the &lt;a href=&#34;http://www.oreilly.com/catalog/perlckbk2/desc.html?CMP=IL7015&#34;&gt;full description&lt;/a&gt; of the book.&lt;/li&gt;
&lt;li&gt;For more information, or to order the book, &lt;a href=&#34;http://www.oreilly.com/catalog/perlckbk2/index.html?CMP=IL7015&#34;&gt;click here&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Cooking with Perl</title>
      <link>http://localhost:1313/pub/2003/08/21/perlcookbook.html/</link>
      <pubDate>Thu, 21 Aug 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/08/21/perlcookbook.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: The new edition of &lt;a href=&#34;http://www.oreilly.com/catalog/perlckbk2/&#34;&gt;Perl Cookbook&lt;/a&gt; is about to hit store shelves, so to trumpet its release, we offer some recipes&amp;ndash;new to the second edition&amp;ndash;for your sampling pleasure. This week&amp;rsquo;s excerpts include recipes from Chapter 6 (&amp;ldquo;Pattern Matching&amp;rdquo;) and Chapter 8 (&amp;ldquo;File Contents&amp;rdquo;). And be sure to check back here in the coming weeks for more new recipes on topics such as using SQL without a database server, extracting table data, templating with HTML::Mason, and more.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;sample-recipe-matching-nested-patterns&#34;&gt;Sample Recipe: Matching Nested Patterns&lt;/h2&gt;

&lt;h3 id=&#34;problem&#34;&gt;Problem&lt;/h3&gt;

&lt;p&gt;You want to match a nested set of enclosing delimiters, such as the arguments to a function call.&lt;/p&gt;

&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;

&lt;p&gt;Use match-time pattern interpolation, recursively:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $np;
$np = qr{
           \(
           (?:
              (?&amp;gt; [^(  )]+ )    # Non-capture group w/o backtracking
            |
              (??{ $np })     # Group with matching parens
           )*
           \)
        }x;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or use the Text::Balanced module&amp;rsquo;s &lt;code&gt;extract_bracketed&lt;/code&gt; function.&lt;/p&gt;

&lt;h3 id=&#34;discussion&#34;&gt;Discussion&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;$(??{&lt;/code&gt;&lt;em&gt;CODE&lt;/em&gt;&lt;code&gt;})&lt;/code&gt; construct runs the code and interpolates the string that the code returns right back into the pattern. A simple, non-recursive example that matches palindromes demonstrates this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ($word =~ /^(\w+)\w?(??{reverse $1})$/ ) {
    print &amp;quot;$word is a palindrome.\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Consider a word like &amp;ldquo;reviver&amp;rdquo;, which this pattern correctly reports as a palindrome. The &lt;code&gt;$1&lt;/code&gt; variable contains &lt;code&gt;&amp;quot;rev&amp;quot;&lt;/code&gt; partway through the match. The optional word character following catches the &lt;code&gt;&amp;quot;i&amp;quot;&lt;/code&gt;. Then the code &lt;code&gt;reverse $1&lt;/code&gt; runs and produces &lt;code&gt;&amp;quot;ver&amp;quot;&lt;/code&gt;, and that result is interpolated into the pattern.&lt;/p&gt;

&lt;p&gt;For matching something balanced, you need to recurse, which is a bit tricker. A compiled pattern that uses &lt;code&gt;(??{&lt;/code&gt;&lt;em&gt;CODE&lt;/em&gt;&lt;code&gt;})&lt;/code&gt; can refer to itself. The pattern given in the Solution matches a set of nested parentheses, however deep they may go. Given the value of &lt;code&gt;$np&lt;/code&gt; in that pattern, you could use it like this to match a function call:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$text = &amp;quot;myfunfun(1,(2*(3+4)),5)&amp;quot;;
$funpat = qr/\w+$np/;   # $np as above
$text =~ /^$funpat$/;   # Matches!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;ll find many CPAN modules that help with matching (parsing) nested strings. The Regexp::Common module supplies canned patterns that match many of the tricker strings. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Regexp::Common;
$text = &amp;quot;myfunfun(1,(2*(3+4)),5)&amp;quot;;
if ($text =~ /(\w+\s*$RE{balanced}{-parens=&amp;gt;&#39;(  )&#39;})/o) {
  print &amp;quot;Got function call: $1\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Other patterns provided by that module match numbers in various notations and quote-delimited strings:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$RE{num}{int}
$RE{num}{real}
$RE{num}{real}{&#39;-base=2&#39;}{&#39;-sep=,&#39;}{&#39;-group=3&#39;}
$RE{quoted}
$RE{delimited}{-delim=&amp;gt;&#39;/&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The standard (as of v5.8) Text::Balanced module provides a general solution to this problem.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Text::Balanced qw/extract_bracketed/;
$text = &amp;quot;myfunfun(1,(2*(3+4)),5)&amp;quot;;
if (($before, $found, $after)  = extract_bracketed($text, &amp;quot;(&amp;quot;)) {
    print &amp;quot;answer is $found\n&amp;quot;;
} else {
    print &amp;quot;FAILED\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;see-also&#34;&gt;See Also&lt;/h3&gt;

&lt;p&gt;The section on &amp;ldquo;Match-Time Pattern Interpolation&amp;rdquo; in Chapter 5, &amp;ldquo;Pattern Matching,&amp;rdquo; of &lt;a href=&#34;http://www.oreilly.com/catalog/pperl3/&#34;&gt;Programming Perl, 3rd Edition&lt;/a&gt;; the documentation for the Regexp::Common CPAN module and the standard Text::Balanced module.&lt;/p&gt;

&lt;h2 id=&#34;sample-recipe-pretending-a-string-is-a-file&#34;&gt;Sample Recipe: Pretending a String Is a File&lt;/h2&gt;

&lt;h2 id=&#34;problem-1&#34;&gt;Problem&lt;/h2&gt;

&lt;p&gt;You have data in string, but would like to treat it as a file. For example, you have a subroutine that expects a filehandle as an argument, but you would like that subroutine to work directly on the data in your string instead. Additionally, you don&amp;rsquo;t want to write the data to a temporary file.&lt;/p&gt;

&lt;h3 id=&#34;solution-1&#34;&gt;Solution&lt;/h3&gt;

&lt;p&gt;Use the scalar I/O in Perl v5.8:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open($fh, &amp;quot;+&amp;lt;&amp;quot;, \$string);   # read and write contents of $string
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;discussion-1&#34;&gt;Discussion&lt;/h3&gt;

&lt;p&gt;Perl&amp;rsquo;s I/O layers include support for input and output from a scalar. When you read a record with &lt;code&gt;&amp;lt;$fh&amp;gt;&lt;/code&gt;, you are reading the next line from &lt;code&gt;$string&lt;/code&gt;. When you write a record with &lt;code&gt;print&lt;/code&gt;, you change &lt;code&gt;$string&lt;/code&gt;. You can pass &lt;code&gt;$fh&lt;/code&gt; to a function that expects a filehandle, and that subroutine need never know that it&amp;rsquo;s really working with data in a string.&lt;/p&gt;

&lt;p&gt;Perl respects the various access modes in &lt;code&gt;open&lt;/code&gt; for strings, so you can specify that the strings be opened as read-only, with truncation, in append mode, and so on:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open($fh, &amp;quot;&amp;lt;&amp;quot;,  \$string);   # read only
open($fh, &amp;quot;&amp;gt;&amp;quot;,  \$string);   # write only, discard original contents
open($fh, &amp;quot;+&amp;gt;&amp;quot;, \$string);   # read and write, discard original contents
open($fh, &amp;quot;+&amp;lt;&amp;quot;, \$string);   # read and write, preserve original contents
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These handles behave in all respects like regular filehandles, so all I/O functions work, such as &lt;code&gt;seek&lt;/code&gt;, &lt;code&gt;truncate&lt;/code&gt;, &lt;code&gt;sysread&lt;/code&gt;, and friends.&lt;/p&gt;

&lt;h3 id=&#34;see-also-1&#34;&gt;See Also&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;open&lt;/code&gt; function in &lt;em&gt;perlfunc&lt;/em&gt;(1) and in Chapter 29 (&amp;ldquo;Functions&amp;rdquo;) of &lt;a href=&#34;http://www.oreilly.com/catalog/pperl3/&#34;&gt;Programming Perl, 3rd Edition&lt;/a&gt;; &amp;ldquo;Using Random-Access I/O;&amp;rdquo; and &amp;ldquo;Setting the Default I/O Layers&amp;rdquo;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;O&amp;rsquo;Reilly &amp;amp; Associates will soon release (August 2003) &lt;a href=&#34;http://www.oreilly.com/catalog/perlckbk2/&#34;&gt;Perl Cookbook, 2nd Edition.&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.oreilly.com/catalog/perlckbk2/chapter/index.html&#34;&gt;Sample Chapter 1, Strings&lt;/a&gt; is available free online.&lt;/li&gt;
&lt;li&gt;You can also look at the &lt;a href=&#34;http://www.oreilly.com/catalog/perlckbk2/toc.html&#34;&gt;Table of Contents&lt;/a&gt;, the &lt;a href=&#34;http://www.oreilly.com/catalog/perlckbk2/inx.html&#34;&gt;Index&lt;/a&gt;, and the &lt;a href=&#34;http://www.oreilly.com/catalog/perlckbk2/desc.html&#34;&gt;full description&lt;/a&gt; of the book.&lt;/li&gt;
&lt;li&gt;For more information, or to order the book, &lt;a href=&#34;http://www.oreilly.com/catalog/perlckbk2/&#34;&gt;click here&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
</description>
    </item>
    
  </channel>
</rss>

