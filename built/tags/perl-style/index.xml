<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Perl Style on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/perl-style/</link>
    <description>Recent content in Perl Style on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 04 Jan 2018 09:00:06 +0000</lastBuildDate>
    <atom:link href="/tags/perl-style/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Hidden Gems of Perl.com</title>
      <link>http://localhost:1313/article/hidden-gems-of-perl-com/</link>
      <pubDate>Thu, 04 Jan 2018 09:00:06 +0000</pubDate>
      
      <guid>http://localhost:1313/article/hidden-gems-of-perl-com/</guid>
      <description>

&lt;p&gt;A few months ago, as I was familiarizing myself with the old Perl.com source material, I kept getting distracted by these wonderful articles that I hadn&amp;rsquo;t read before. Now that the site has relaunched, and the old articles lovingly restored, I thought I&amp;rsquo;d share a few of these hidden gems with you.&lt;/p&gt;

&lt;h3 id=&#34;here-be-wizards&#34;&gt;Here be Wizards&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Where Wizards Fear to Tread&lt;/em&gt; was a brief, perlguts-focused series started by &lt;a href=&#34;https://www.perl.com/authors/simon-cozens/&#34;&gt;Simon Cozens&lt;/a&gt;. This particular &lt;a href=&#34;http://localhost:1313/pub/2002/05/07/optree.html/&#34;&gt;article&lt;/a&gt; discusses the Perl op tree.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;d love to rekindle this series. If you have a Perl internals article that you&amp;rsquo;d like to write, please get in touch with &lt;a href=&#34;mailto:perl.com-editor@perl.org&#34;&gt;me&lt;/a&gt; or see our contributing &lt;a href=&#34;https://github.com/dnmfarrell/perldotcom/blob/master/CONTRIBUTING.md&#34;&gt;guide&lt;/a&gt; and send us a pull request with a draft article.&lt;/p&gt;

&lt;h3 id=&#34;naughty-perl&#34;&gt;Naughty Perl&lt;/h3&gt;

&lt;p&gt;In the old Perl.com source code, I came across several raw documents which didn&amp;rsquo;t appear to have been officially published on the site, but did contain good content. For example &lt;a href=&#34;https://www.perl.com/authors/tom-christiansen/&#34;&gt;Tom Christiansen&amp;rsquo;s&lt;/a&gt; article &lt;a href=&#34;http://localhost:1313/doc/FMTEYEWTK/versus/perl.html/&#34;&gt;The Seven Deadly Sins of Perl&lt;/a&gt; is a fun read worthy of your time. Can you count how many of the &amp;ldquo;sins&amp;rdquo; have been addressed since then?&lt;/p&gt;

&lt;h3 id=&#34;just-code-it-in-perl-6&#34;&gt;Just code it in Perl (6)?&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/pub/2001/06/27/ctoperl.html/&#34;&gt;Why not Translate Perl to C?&lt;/a&gt; is a sobering reminder by &lt;a href=&#34;https://www.perl.com/authors/mark-jason-dominus/&#34;&gt;Mark Jason Dominus&lt;/a&gt; that re-writing Perl as C often won&amp;rsquo;t yield faster programs. The article ends with optimistic speculation that Perl 6 may use gradual typing and static data structures to deliver better performance. Fast-forward a few years, and good news! Perl 6 supports &lt;a href=&#34;https://perl6advent.wordpress.com/2015/12/18/day-18-sized-typed-shaped/&#34;&gt;sized and typed data structures&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;MJD regularly blogs at his own &lt;a href=&#34;https://blog.plover.com/&#34;&gt;site&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;state-of-the-onion&#34;&gt;State of the Onion&lt;/h3&gt;

&lt;p&gt;Larry has a good number of &lt;a href=&#34;https://www.perl.com/authors/larry-wall/&#34;&gt;articles&lt;/a&gt; on Perl.com, including some of the oldest. The &lt;a href=&#34;http://localhost:1313/pub/1998/08/show/onion.html/&#34;&gt;2nd State of the Onion&lt;/a&gt; was published way back in August 1998, and it&amp;rsquo;s still an entertaining read (or re-read if you&amp;rsquo;ve forgotten it).&lt;/p&gt;

&lt;h3 id=&#34;more-to-come&#34;&gt;More to come&lt;/h3&gt;

&lt;p&gt;There are more articles to recommend, but for the sake of brevity I&amp;rsquo;ll stop here. In the meantime feel free to explore the site; you never know, you might stumble upon another &amp;hellip; hidden gem!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/hidden-gems-of-perl-com/indiana-stone.jpg&#34; alt=&#34;Indiana Jones discovers treasure&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;Cover image by &lt;a href=&#34;http://i.imgur.com/4VOS6iz.png&#34;&gt;Shachar Harshuv&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Making Sense of Subroutines</title>
      <link>http://localhost:1313/pub/2005/11/03/subroutines.html/</link>
      <pubDate>Thu, 03 Nov 2005 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2005/11/03/subroutines.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: This article has a followup in &lt;a href=&#34;http://localhost:1313/pub/2006/02/23/advanced_subroutines.html&#34;&gt;Advanced Subroutine Techniques&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A subroutine (or routine, function, procedure, macro, etc.) is, at its heart, a named chunk of work. It&amp;rsquo;s shorthand that allows you to think about your problem in bigger chunks. Bigger chunks means two things:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;You can break the problem up into smaller problems that you can solve independently.&lt;/li&gt;
&lt;li&gt;You can use these solutions to solve your overall problem with greater confidence.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Well-written subroutines will make your programs smaller (in lines and memory), faster (both in writing and executing), less buggy, and easier to modify.&lt;/p&gt;

&lt;h3 id=&#34;you-re-kidding-right&#34;&gt;You&amp;rsquo;re Kidding, Right?&lt;/h3&gt;

&lt;p&gt;Consider this: when you lift your sandwich to take a bite, you don&amp;rsquo;t think about all the work that goes into contracting your muscles and coordinating your movements so that the mayo doesn&amp;rsquo;t end up in your hair. You, in essence, execute a series of subroutines that say &amp;ldquo;Lift the sandwich up to my mouth and take a bite of it, then put it back down on the plate.&amp;rdquo; If you had to think about all of your muscle contractions and coordinating them every time you wanted to take a bite, you&amp;rsquo;d starve to death.&lt;/p&gt;

&lt;p&gt;The same is true for your code. We write programs for a human&amp;rsquo;s benefit. The computer doesn&amp;rsquo;t care how complicated or simple your code is to read&amp;ndash;it converts everything to the same 1s and 0s whether it has perfect indentation or is all on one line. Programming guidelines, and nearly every single programming language feature, exist for human benefit.&lt;/p&gt;

&lt;h3 id=&#34;tell-me-more&#34;&gt;Tell Me More&lt;/h3&gt;

&lt;p&gt;Subroutines truly are the magical cure for all that ails your programs. When done right, you will find that you write your programs in half the time, you have more confidence in what you&amp;rsquo;ve written, and you can explain it to others more easily.&lt;/p&gt;

&lt;h4 id=&#34;naming&#34;&gt;Naming&lt;/h4&gt;

&lt;p&gt;A subroutine provides a name for a series of steps. This is especially important when dealing with complicated processes (or algorithms). While this includes ivory-tower solutions such as the Guttler-Rossman transformation (for sorting), this also includes the overly complicated way your company does accounts receivables. By putting a name on it, you&amp;rsquo;re making it easier to work with.&lt;/p&gt;

&lt;h4 id=&#34;code-reuse&#34;&gt;Code Reuse&lt;/h4&gt;

&lt;p&gt;Face it&amp;ndash;you&amp;rsquo;re going to need to do the same thing over and over in different parts of your code. If you have the same 30 lines of code in 40 places, it&amp;rsquo;s much harder to apply a bugfix or a requirements change. Even better, if your code uses subroutines, it&amp;rsquo;s much easier to optimize just that one little bit that&amp;rsquo;s slowing the whole application down. Studies have shown that 80 percent of the application&amp;rsquo;s runtime generally occurs within one percent of an application&amp;rsquo;s code. If that one percent is in a few subroutines, you can optimize it and hide the nasty details from the rest of your code.&lt;/p&gt;

&lt;h4 id=&#34;testability&#34;&gt;Testability&lt;/h4&gt;

&lt;p&gt;To many people, &amp;ldquo;test&amp;rdquo; is a four-letter word. I firmly believe this is because they don&amp;rsquo;t have enough interfaces to test against. A subroutine provides a way of grabbing a section of your code and testing it independently of all the rest of your code. This independence is key to having confidence in your tests, both now and in the future.&lt;/p&gt;

&lt;p&gt;In addition, when someone finds a bug, the bug will usually occur in a single subroutine. When this happens, you can alter that one subroutine, leaving the rest of the system unchanged. The fewer changes made to an application, the more confidence there is in the fix not introducing new bugs along with the bugfix.&lt;/p&gt;

&lt;h4 id=&#34;ease-of-development&#34;&gt;Ease of Development&lt;/h4&gt;

&lt;p&gt;No one argues that subroutines are bad when there are ten developers working on a project. They allow different developers to work on different parts of the application in parallel. (If there are dependencies, one developer can &lt;em&gt;stub&lt;/em&gt; the missing subroutines.) However, they provide an equal amount of benefit for the solo developer: they allow you to focus on one specific part of the application without having to build all of the pieces up together. You will be happy for the good names you chose when you have to read code you wrote six months ago.&lt;/p&gt;

&lt;p&gt;Consider the following example of a convoluted conditional:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ((($x &amp;gt; 3 &amp;amp;&amp;amp; $x&amp;lt;12) || ($x&amp;gt;15 &amp;amp;&amp;amp; $x&amp;lt;23)) &amp;amp;&amp;amp;
    (($y&amp;lt;2260 &amp;amp;&amp;amp; $y&amp;gt;2240) || ($z&amp;gt;foo_bar() &amp;amp;&amp;amp; $z&amp;lt;bar_foo()))) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s very hard to exactly what&amp;rsquo;s going on. Some judicious white space can help, as can improved layout. That leaves:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (
     (
       ( $x &amp;gt; 3 &amp;amp;&amp;amp; $x &amp;lt; 12) || ($x &amp;gt; 15 &amp;amp;&amp;amp; $x &amp;lt; 23)
     )
     &amp;amp;&amp;amp;
     (
       ($y &amp;lt; 2260 &amp;amp;&amp;amp; $y &amp;gt; 2240) || ($z &amp;gt; foo_bar() &amp;amp;&amp;amp; $z &amp;lt; bar_foo())
     )
   )
{
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Gah, that&amp;rsquo;s almost worse. Enter a subroutine to the rescue:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub is_between {
    my ($value, $left, $right) = @_;

    return ( $left &amp;lt; $value &amp;amp;&amp;amp; $value &amp;lt; $right );
}

if (
    ( is_between( $x, 3, 12 ) ||
      is_between( $x, 15, 23 )
    ) &amp;amp;&amp;amp; (
      is_between( $y, 2240, 2260 ) ||
      is_between( $z, foo_bar(), bar_foo() )
    ) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s so much easier to read. One thing to notice is that, in this case, the rewrite doesn&amp;rsquo;t actually save any characters. In fact, this is slightly longer than the original version. Yet, it&amp;rsquo;s easier to read, which makes it easier to both validate for correctness as well as to modify safely. (When writing this subroutine for the article, I actually found an error I had made&amp;ndash;I had flipped the values for comparing &lt;code&gt;$y&lt;/code&gt; so that the &lt;code&gt;$y&lt;/code&gt; conditional could never be true.)&lt;/p&gt;

&lt;h3 id=&#34;how-do-i-know-if-i-m-doing-it-right&#34;&gt;How Do I Know if I&amp;rsquo;m Doing It Right?&lt;/h3&gt;

&lt;p&gt;Just as there are good sandwiches (turkey club on dark rye) and bad sandwiches (peanut butter and banana on Wonder bread), there are also good and bad subroutines. While writing good subroutines is very much an art form, there are several characteristics you can look for when writing good subroutines. A good subroutine is readable and has a well-defined interface, strong internal cohesion, and loose external coupling.&lt;/p&gt;

&lt;h4 id=&#34;readability&#34;&gt;Readability&lt;/h4&gt;

&lt;p&gt;The best subroutines are concise&amp;ndash;usually 25-50 lines long, which is one or two average screens in height. (While &lt;em&gt;your&lt;/em&gt; screen might be 110 lines high, you will one day have to debug your code on a VT100 terminal at 3 a.m. on a Sunday.)&lt;/p&gt;

&lt;p&gt;Part of being readable also means that the code isn&amp;rsquo;t overly indented. The guidelines for the Linux kernel code include a statement that all code should be less 80 characters wide and that indentations should be eight characters wide. This is to discourage more than three levels of indentation. It&amp;rsquo;s too hard to follow the logic flows with any more than that.&lt;/p&gt;

&lt;h4 id=&#34;well-defined-interfaces&#34;&gt;Well-Defined Interfaces&lt;/h4&gt;

&lt;p&gt;This means that you know all of the inputs and all of the outputs. Doing this allows you to muck with either side of this wall and, so long as you keep to the contract, you have a &lt;em&gt;guarantee&lt;/em&gt; that the code on the other side of the interface will be safe from harm. This is also critical to good testing. By having a solid interface, you can write test suites to validate both the subroutine and to mock the subroutine to test the code that uses it.&lt;/p&gt;

&lt;h4 id=&#34;strong-internal-cohesion&#34;&gt;Strong Internal Cohesion&lt;/h4&gt;

&lt;p&gt;Internal cohesion is about how strongly the lines of code within the subroutine relate to one another. Ideally, a subroutine does one thing and only one thing. This means that someone calling the subroutine can be confident that it will do only what they want to have done.&lt;/p&gt;

&lt;h4 id=&#34;loose-external-coupling&#34;&gt;Loose External Coupling&lt;/h4&gt;

&lt;p&gt;This means that changes to code outside of the subroutine will not affect how the subroutine performs, and vice versa. This allows you to make changes within the subroutine safely. This is also known as having no side effects.&lt;/p&gt;

&lt;p&gt;As an example, a loosely coupled subroutine should not access global variables unnecessarily. Proper scoping is critical for any variables you create in your subroutine, using the &lt;code&gt;my&lt;/code&gt; keyword.&lt;/p&gt;

&lt;p&gt;This also means that a subroutine should be able to run without depending upon other subroutines to be run before or after it. In functional programming, this means that the function is &lt;em&gt;stateless&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Perl has global special variables (such as &lt;code&gt;$_&lt;/code&gt;, &lt;code&gt;@_&lt;/code&gt;, &lt;code&gt;$?&lt;/code&gt;, &lt;code&gt;$@&lt;/code&gt;, and &lt;code&gt;$!&lt;/code&gt;). If you modify them, be sure to localize them with the &lt;code&gt;local&lt;/code&gt; keyword.&lt;/p&gt;

&lt;h3 id=&#34;what-should-i-call-it&#34;&gt;What Should I Call It?&lt;/h3&gt;

&lt;p&gt;Naming things well is important for all parts of your code. With subroutines, it&amp;rsquo;s even more important. A subroutine is a chunk of work described to the reader only by its name. If the name is too short, no one knows what it means. If the name is too long, then it&amp;rsquo;s too hard to understand and potentially difficult to type. If the name is too specific, you will confuse the reader when you call it for more general circumstances.&lt;/p&gt;

&lt;p&gt;Subroutine names should flow when read out loud: &lt;code&gt;doThis()&lt;/code&gt; for actions and &lt;code&gt;is_that()&lt;/code&gt; for Boolean checks. Ideally, a subroutine name should be &lt;code&gt;verbNoun()&lt;/code&gt; (or &lt;code&gt;verb_noun()&lt;/code&gt;). To test this, take a section of your code and read it out loud to your closest non-geek friend. When you&amp;rsquo;re done, ask them what that piece of code should do. If they have no idea, your subroutines (and variables) may have poor names. (I&amp;rsquo;ve provided examples in two forms, &amp;ldquo;camelCase&amp;rdquo; and &amp;ldquo;under_score.&amp;rdquo; Some people prefer one way and some prefer the other. As long as you&amp;rsquo;re consistent, it doesn&amp;rsquo;t matter which you choose.)&lt;/p&gt;

&lt;h3 id=&#34;what-else-can-i-do&#34;&gt;What Else Can I Do?&lt;/h3&gt;

&lt;p&gt;(This section assumes a strong grasp of Perl fundamentals, especially hashes and references.)&lt;/p&gt;

&lt;p&gt;Perl is one of a class of languages that allows you to treat subroutines as first-class objects. This means you can use subroutines in nearly every place you can use a variable. This concept comes from functional programming (FP), and is a very powerful technique.&lt;/p&gt;

&lt;p&gt;The basic building block of FP in Perl is the reference to a subroutine, or &lt;code&gt;subref&lt;/code&gt;. For a named subroutine, you can say &lt;code&gt;my $subref = \&amp;amp;foobar;&lt;/code&gt;. You can then say &lt;code&gt;$subref-&amp;gt;(1, 2)&lt;/code&gt; and it will be as if you said &lt;code&gt;foobar(1, 2)&lt;/code&gt;. A subref is a regular scalar, so you can pass it around as you can any other reference (say, to an array or hash) and you can put them into arrays and hashes. You can also construct them anonymously by saying &lt;code&gt;my $subref = sub { ... };&lt;/code&gt; (where the &lt;code&gt;...&lt;/code&gt; is the body of the subroutine).&lt;/p&gt;

&lt;p&gt;This provides several very neat options.&lt;/p&gt;

&lt;h4 id=&#34;closures&#34;&gt;Closures&lt;/h4&gt;

&lt;p&gt;Closures are the main building blocks for using subroutines in functional programming. A closure is a subroutine that remembers its lexical scratchpad. In English, this means that if you take a reference to a subroutine that uses a &lt;code&gt;my&lt;/code&gt; variable defined outside of it, it will remember the value of that variable when it was defined and be able to access it, even if you use the subroutine outside of the scope of that variable.&lt;/p&gt;

&lt;p&gt;There are two main variations of closures you see in normal code. The first is a named closure.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    my $counter = 0;
    sub inc_counter { return $counter++ }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you call &lt;code&gt;inc_counter()&lt;/code&gt;, you&amp;rsquo;re obviously out of scope for the &lt;code&gt;$counter&lt;/code&gt; variable. Yet, it will increment the counter and return the value as if it were in scope.&lt;/p&gt;

&lt;p&gt;This is a very good way to handle global state, if you&amp;rsquo;re uncomfortable with object-oriented programming. Just extend the idea to multiple variables and have a getter and setter for each one.&lt;/p&gt;

&lt;p&gt;The second is an anonymous closure.&lt;/p&gt;

&lt;h4 id=&#34;recursion&#34;&gt;Recursion&lt;/h4&gt;

&lt;p&gt;Many recursive functions are simple enough that they do not need to keep any state. Those that do are more complicated, especially if you want to be able to call the function more than once at a time. Enter anonymous subroutines.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub recursionSetup {
    my ($x, $y) = @_;

    my @stack;

    my $_recurse = sub {
        my ($foo, $bar) = @_;

        # Do stuff here with $x, $y, and @stack;
    };
    my $val = $_recurse-&amp;gt;( $x, $y );

    return $val;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;inner-subroutines&#34;&gt;Inner Subroutines&lt;/h4&gt;

&lt;p&gt;Subroutine definitions are global in Perl. This means that Perl doesn&amp;rsquo;t have inner subroutines.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub foo {
    sub bar {
    }

    # This bar() should only be accessible from within foo(),
    # but it is accessible from everywhere
    bar():
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Enter anonymous subroutines again.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub foo {
    my $bar = sub {
    };

    # This $bar is only accessible from within foo()
    $bar-&amp;gt;();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;dispatch-tables&#34;&gt;Dispatch Tables&lt;/h4&gt;

&lt;p&gt;Often, you need to call a specific subroutine based some user input. The first attempts to do this usually look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ( $input eq &#39;foo&#39; ) {
    foo( @params );
}
elsif ( $input eq &#39;bar&#39; ) {
    bar( @params );
}
else {
    die &amp;quot;Cannot find the subroutine &#39;$input&#39;\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, some enterprising soul learns about soft references and tries something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;amp;{ $input }( @params );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s unsafe, because you don&amp;rsquo;t know what &lt;code&gt;$input&lt;/code&gt; will to contain. You cannot guarantee &lt;em&gt;anything&lt;/em&gt; about it, even with taint and all that jazz on. It&amp;rsquo;s much safer just to use dispatch tables:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my %dispatch = (
    foo =&amp;gt; sub { ... },
    bar =&amp;gt; \&amp;amp;bar,
);

if ( exists $dispatch{ $input } ) {
    $dispatch{ $input }-&amp;gt;( @params );
}
else {
    die &amp;quot;Cannot find the subroutine &#39;$input&#39;\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Adding and removing available subroutines is simpler than the &lt;code&gt;if&lt;/code&gt;-&lt;code&gt;elsif&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt; scenario, and this is much safer than the soft references scenario. It&amp;rsquo;s the best of both worlds.&lt;/p&gt;

&lt;h4 id=&#34;subroutine-factories&#34;&gt;Subroutine Factories&lt;/h4&gt;

&lt;p&gt;Often, you will have many subroutines that look very similar. You might have accessors for an object that differ only in which attribute they access. Alternately, you might have a group of mathematical functions that differ only in the constants they use.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub make_multiplier { 
    my ($multiplier) = @_;

    return sub {
        my ($value) = @_;
        return $value * $multiplier;
    };
}

my $times_two  = make_multiplier( 2 );
my $times_four = make_multiplier( 4 );

print $times_two-&amp;gt;( 6 ), &amp;quot;\n&amp;quot;;
print $times_four-&amp;gt;( 3 ), &amp;quot;\n&amp;quot;;

----

12
12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Try that code and see what it does. You should see the values below the dotted line.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Subroutines are arguably the most powerful tool in a programmer&amp;rsquo;s toolbox. They provide the ability to reuse sections of code, validate those sections, and create new algorithms that solve problems in novel ways. They will reduce the amount of time you spend programming, yet allow you to do more in that time. They will reduce the number of bugs in your code ten-fold, and allow other people to work with you while feeling safe about it. They truly are programming&amp;rsquo;s super-tool.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ten Essential Development Practices</title>
      <link>http://localhost:1313/pub/2005/07/14/bestpractices.html/</link>
      <pubDate>Thu, 14 Jul 2005 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2005/07/14/bestpractices.html/</guid>
      <description>

&lt;p&gt;The following ten tips come from &lt;em&gt;&lt;a href=&#34;http://www.oreilly.com/catalog/perlbp/&#34;&gt;Perl Best Practices&lt;/a&gt;&lt;/em&gt;, a new book of Perl coding and development guidelines by Damian Conway.&lt;/p&gt;

&lt;h3 id=&#34;1-design-the-module-s-interface-first&#34;&gt;1. Design the Module&amp;rsquo;s Interface First&lt;/h3&gt;

&lt;p&gt;The most important aspect of any module is not how it implements the facilities it provides, but the way in which it provides those facilities in the first place. If the module&amp;rsquo;s API is too awkward, or too complex, or too extensive, or too fragmented, or even just poorly named, developers will avoid using it. They&amp;rsquo;ll write their own code instead. In that way, a poorly designed module can actually reduce the overall maintainability of a system.&lt;/p&gt;

&lt;p&gt;Designing module interfaces requires both experience and creativity. Perhaps the easiest way to work out how an interface should work is to &amp;ldquo;play test&amp;rdquo; it: to write examples of code that will use the module before implementing the module itself. These examples will not be wasted when the design is complete. You can usually recycle them into demos, documentation examples, or the core of a test suite.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://conferences.oreillynet.com/os2005/&#34;&gt;&lt;img src=&#34;http://conferences.oreillynet.com/images/os2005/banners/120x240.gif&#34; alt=&#34;O&amp;#39;Reilly Open Source Convention 2005.&#34; width=&#34;120&#34; height=&#34;240&#34; /&gt;&lt;/a&gt;
The key, however, is to write that code as if the module were already available, and write it the way you&amp;rsquo;d most like the module to work.&lt;/p&gt;

&lt;p&gt;Once you have some idea of the interface you want to create, convert your &amp;ldquo;play tests&amp;rdquo; into actual tests (see Tip #2). Then it&amp;rsquo;s just a Simple Matter Of Programming to make the module work the way that the code examples and the tests want it to.&lt;/p&gt;

&lt;p&gt;Of course, it may not be possible for the module to work the way you&amp;rsquo;d most like, in which case attempting to implement it that way will help you determine what aspects of your API are not practical, and allow you to work out what might be an acceptable alternative.&lt;/p&gt;

&lt;h3 id=&#34;2-write-the-test-cases-before-the-code&#34;&gt;2. Write the Test Cases Before the Code&lt;/h3&gt;

&lt;p&gt;Probably the single best practice in all of software development is writing your test suite first.&lt;/p&gt;

&lt;p&gt;A test suite is an executable, self-verifying specification of the behavior of a piece of software. If you have a test suite, you can&amp;ndash;at any point in the development process&amp;ndash;verify that the code works as expected. If you have a test suite, you can&amp;ndash;after any changes during the maintenance cycle&amp;ndash;verify that the code still works as expected.&lt;/p&gt;

&lt;p&gt;Write the tests first. Write them as soon as you know what your interface will be (see #1). Write them before you start coding your application or module. Unless you have tests, you have no unequivocal specification of what the software should do, and no way of knowing whether it does it.&lt;/p&gt;

&lt;p&gt;Writing tests always seems like a chore, and an unproductive chore at that: you don&amp;rsquo;t have anything to test yet, so why write tests? Yet most developers will&amp;ndash;almost automatically&amp;ndash;write driver software to test their new module in an ad hoc way:&lt;span id=&#34;OLE_LINK428&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; cat try_inflections.pl

# Test my shiny new English inflections module...

use Lingua::EN::Inflect qw( inflect );

# Try some plurals (both standard and unusual inflections)...

my %plural_of = (
   &#39;house&#39;         =&amp;gt; &#39;houses&#39;,
   &#39;mouse&#39;         =&amp;gt; &#39;mice&#39;,
   &#39;box&#39;           =&amp;gt; &#39;boxes&#39;,
   &#39;ox&#39;            =&amp;gt; &#39;oxen&#39;,
   &#39;goose&#39;         =&amp;gt; &#39;geese&#39;,
   &#39;mongoose&#39;      =&amp;gt; &#39;mongooses&#39;,
   &#39;law&#39;           =&amp;gt; &#39;laws&#39;,
   &#39;mother-in-law&#39; =&amp;gt; &#39;mothers-in-law&#39;,
);

# For each of them, print both the expected result and the actual inflection...

for my $word ( keys %plural_of ) {
   my $expected = $plural_of{$word};
   my $computed = inflect( &amp;quot;PL_N($word)&amp;quot; );

   print &amp;quot;For $word:\n&amp;quot;,
         &amp;quot;\tExpected: $expected\n&amp;quot;,
         &amp;quot;\tComputed: $computed\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A driver like that is actually harder to write than a test suite, because you have to worry about formatting the output in a way that is easy to read. It&amp;rsquo;s also much harder to use the driver than it would be to use a test suite, because every time you run it you have to wade though that formatted output and verify &amp;ldquo;by eye&amp;rdquo; that everything is as it should be. That&amp;rsquo;s also error-prone; eyes are not optimized for picking out small differences in the middle of large amounts of nearly identical text.&lt;/p&gt;

&lt;p&gt;Instead of hacking together a driver program, it&amp;rsquo;s easier to write a test program using the standard &lt;a href=&#34;https://metacpan.org/pod/Test::Simple&#34;&gt;Test::Simple&lt;/a&gt; module. Instead of &lt;code&gt;print&lt;/code&gt; statements showing what&amp;rsquo;s being tested, you just write calls to the &lt;code&gt;ok()&lt;/code&gt; subroutine, specifying as its first argument the condition under which things are okay, and as its second argument a description of what you&amp;rsquo;re actually testing:&lt;span id=&#34;OLE_LINK429&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; cat inflections.t

use Lingua::EN::Inflect qw( inflect);

use Test::Simple qw( no_plan);

my %plural_of = (
   &#39;mouse&#39;         =&amp;gt; &#39;mice&#39;,
   &#39;house&#39;         =&amp;gt; &#39;houses&#39;,
   &#39;ox&#39;            =&amp;gt; &#39;oxen&#39;,
   &#39;box&#39;           =&amp;gt; &#39;boxes&#39;,
   &#39;goose&#39;         =&amp;gt; &#39;geese&#39;,
   &#39;mongoose&#39;      =&amp;gt; &#39;mongooses&#39;,
   &#39;law&#39;           =&amp;gt; &#39;laws&#39;,
   &#39;mother-in-law&#39; =&amp;gt; &#39;mothers-in-law&#39;,
);

for my $word ( keys %plural_of ) {
   my $expected = $plural_of{$word};
   my $computed = inflect( &amp;quot;PL_N($word)&amp;quot; );

   ok( $computed eq $expected, &amp;quot;$word -&amp;gt; $expected&amp;quot; );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that this code loads &lt;code&gt;Test::Simple&lt;/code&gt; with the argument &lt;code&gt;qw( no_plan )&lt;/code&gt;. Normally that argument would be &lt;code&gt;tests =&amp;gt; count&lt;/code&gt;, indicating how many tests to expect, but here the tests are generated from the &lt;code&gt;%plural_of&lt;/code&gt; table at run time, so the final count will depend on how many entries are in that table. Specifying a fixed number of tests when loading the module is useful if you happen know that number at compile time, because then the module can also &amp;ldquo;meta-test:&amp;rdquo; verify that you carried out all the tests you expected to.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Test::Simple&lt;/code&gt; program is slightly more concise and readable than the original driver code, and the output is much more compact and informative:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; perl inflections.t

ok 1 - house -&amp;gt; houses
ok 2 - law -&amp;gt; laws
not ok 3 - mongoose -&amp;gt; mongooses
#     Failed test (inflections.t at line 21)
ok 4 - goose -&amp;gt; geese
ok 5 - ox -&amp;gt; oxen
not ok 6 - mother-in-law -&amp;gt; mothers-in-law
#     Failed test (inflections.t at line 21)
ok 7 - mouse -&amp;gt; mice
ok 8 - box -&amp;gt; boxes
1..8
# Looks like you failed 2 tests of 8.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More importantly, this version requires far less effort to verify the correctness of each test. You just scan down the left margin looking for a &lt;code&gt;not&lt;/code&gt; and a comment line.&lt;/p&gt;

&lt;p&gt;You might prefer to use the &lt;a href=&#34;https://metacpan.org/pod/Test::More&#34;&gt;Test::More&lt;/a&gt; module instead of &lt;code&gt;Test::Simple&lt;/code&gt;. Then you can specify the actual and expected values separately, by using the &lt;code&gt;is()&lt;/code&gt; subroutine, rather than &lt;code&gt;ok()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Lingua::EN::Inflect qw( inflect );
use Test::More qw( no_plan ); # Now using more advanced testing tools

my %plural_of = (
   &#39;mouse&#39;         =&amp;gt; &#39;mice&#39;,
   &#39;house&#39;         =&amp;gt; &#39;houses&#39;,
   &#39;ox&#39;            =&amp;gt; &#39;oxen&#39;,
   &#39;box&#39;           =&amp;gt; &#39;boxes&#39;,
   &#39;goose&#39;         =&amp;gt; &#39;geese&#39;,
   &#39;mongoose&#39;      =&amp;gt; &#39;mongooses&#39;,
   &#39;law&#39;           =&amp;gt; &#39;laws&#39;,
   &#39;mother-in-law&#39; =&amp;gt; &#39;mothers-in-law&#39;,
);

for my $word ( keys %plural_of ) {
   my $expected = $plural_of{$word};
   my $computed = inflect( &amp;quot;PL_N($word)&amp;quot; );

   # Test expected and computed inflections for string equality...
   is( $computed, $expected, &amp;quot;$word -&amp;gt; $expected&amp;quot; );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apart from no longer having to type the &lt;code&gt;eq&lt;/code&gt; yourself, this version also produces more detailed error messages:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; perl inflections.t

ok 1 - house -&amp;gt; houses
ok 2 - law -&amp;gt; laws
not ok 3 - mongoose -&amp;gt; mongooses
#     Failed test (inflections.t at line 20)
#          got: &#39;mongeese&#39;
#     expected: &#39;mongooses&#39;
ok 4 - goose -&amp;gt; geese
ok 5 - ox -&amp;gt; oxen
not ok 6 - mother-in-law -&amp;gt; mothers-in-law
#     Failed test (inflections.t at line 20)
#          got: &#39;mothers-in-laws&#39;
#     expected: &#39;mothers-in-law&#39;
ok 7 - mouse -&amp;gt; mice
ok 8 - box -&amp;gt; boxes
1..8
# Looks like you failed 2 tests of 8.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;a href=&#34;https://metacpan.org/pod/Test::Tutorial&#34;&gt;Test::Tutorial&lt;/a&gt; documentation that comes with Perl 5.8 provides a gentle introduction to both &lt;code&gt;Test::Simple&lt;/code&gt; and &lt;code&gt;Test::More&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;3-create-standard-pod-templates-for-modules-and-applications&#34;&gt;3. Create Standard POD Templates for Modules and Applications&lt;/h3&gt;

&lt;p&gt;One of the main reasons documentation can often seem so unpleasant is the &amp;ldquo;blank page effect.&amp;rdquo; Many programmers simply don&amp;rsquo;t know how to get started or what to say.&lt;/p&gt;

&lt;p&gt;Perhaps the easiest way to make writing documentation less forbidding (and hence, more likely to actually occur) is to circumvent that initial empty screen by providing a template that developers can cut and paste into their code.&lt;/p&gt;

&lt;p&gt;For a module, that documentation template might look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;=head1 NAME

&amp;lt;Module::Name&amp;gt; - &amp;lt;One-line description of module&#39;s purpose&amp;gt;

=head1 VERSION

The initial template usually just has:

This documentation refers to &amp;lt;Module::Name&amp;gt; version 0.0.1.

=head1 SYNOPSIS

   use &amp;lt;Module::Name&amp;gt;;

   # Brief but working code example(s) here showing the most common usage(s)
   # This section will be as far as many users bother reading, so make it as
   # educational and exemplary as possible.

=head1 DESCRIPTION

A full description of the module and its features.

May include numerous subsections (i.e., =head2, =head3, etc.).

=head1 SUBROUTINES/METHODS

A separate section listing the public components of the module&#39;s interface.

These normally consist of either subroutines that may be exported, or methods
that may be called on objects belonging to the classes that the module
provides.

Name the section accordingly.

In an object-oriented module, this section should begin with a sentence (of the
form &amp;quot;An object of this class represents ...&amp;quot;) to give the reader a high-level
context to help them understand the methods that are subsequently described.

=head1 DIAGNOSTICS

A list of every error and warning message that the module can generate (even
the ones that will &amp;quot;never happen&amp;quot;), with a full explanation of each problem,
one or more likely causes, and any suggested remedies.

=head1 CONFIGURATION AND ENVIRONMENT

A full explanation of any configuration system(s) used by the module, including
the names and locations of any configuration files, and the meaning of any
environment variables or properties that can be set. These descriptions must
also include details of any configuration language used.

=head1 DEPENDENCIES

A list of all of the other modules that this module relies upon, including any
restrictions on versions, and an indication of whether these required modules
are part of the standard Perl distribution, part of the module&#39;s distribution,
or must be installed separately.

=head1 INCOMPATIBILITIES

A list of any modules that this module cannot be used in conjunction with.
This may be due to name conflicts in the interface, or competition for system
or program resources, or due to internal limitations of Perl (for example, many
modules that use source code filters are mutually incompatible).

=head1 BUGS AND LIMITATIONS

A list of known problems with the module, together with some indication of
whether they are likely to be fixed in an upcoming release.

Also, a list of restrictions on the features the module does provide: data types
that cannot be handled, performance issues and the circumstances in which they
may arise, practical limitations on the size of data sets, special cases that
are not (yet) handled, etc.

The initial template usually just has:

There are no known bugs in this module.

Please report problems to &amp;lt;Maintainer name(s)&amp;gt; (&amp;lt;contact address&amp;gt;)

Patches are welcome.

=head1 AUTHOR

&amp;lt;Author name(s)&amp;gt;  (&amp;lt;contact address&amp;gt;)

=head1 LICENSE AND COPYRIGHT

Copyright (c) &amp;lt;year&amp;gt; &amp;lt;copyright holder&amp;gt; (&amp;lt;contact address&amp;gt;).
All rights reserved.

followed by whatever license you wish to release it under.

For Perl code that is often just:

This module is free software; you can redistribute it and/or modify it under
the same terms as Perl itself. See L&amp;lt;perlartistic&amp;gt;.  This program is
distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, the specific details that your templates provide may vary from those shown here, according to your other coding practices. The most likely variation will be in the license and copyright, but you may also have specific in-house conventions regarding version numbering, the grammar of diagnostic messages, or the attribution of authorship.&lt;/p&gt;

&lt;h3 id=&#34;4-use-a-revision-control-system&#34;&gt;4. Use a Revision Control System&lt;/h3&gt;

&lt;p&gt;Maintaining control over the creation and modification of your source code is utterly essential for robust team-based development. And not just over source code: you should be revision controlling your documentation, and data files, and document templates, and makefiles, and style sheets, and change logs, and any other resources your system requires.&lt;/p&gt;

&lt;p&gt;Just as you wouldn&amp;rsquo;t use an editor without an Undo command or a word processor that can&amp;rsquo;t merge documents, so too you shouldn&amp;rsquo;t use a file system you can&amp;rsquo;t rewind, or a development environment that can&amp;rsquo;t integrate the work of many contributors.&lt;/p&gt;

&lt;p&gt;Programmers make mistakes, and occasionally those mistakes will be catastrophic. They will reformat the disk containing the most recent version of the code. Or they&amp;rsquo;ll mistype an editor macro and write zeros all through the source of a critical core module. Or two developers will unwittingly edit the same file at the same time and half their changes will be lost. Revision control systems can prevent those kinds of problems.&lt;/p&gt;

&lt;p&gt;Moreover, occasionally the very best debugging technique is to just give up, stop trying to get yesterday&amp;rsquo;s modifications to work correctly, roll the code back to a known stable state, and start over again. Less drastically, comparing the current condition of your code with the most recent stable version from your repository (even just a line-by-line &lt;code&gt;diff&lt;/code&gt;) can often help you isolate your recent &amp;ldquo;improvements&amp;rdquo; and work out which of them is the problem.&lt;/p&gt;

&lt;p&gt;Revision control systems such as RCS, CVS, Subversion, Monotone, &lt;code&gt;darcs&lt;/code&gt;, Perforce, GNU arch, or BitKeeper can protect against calamities, and ensure that you always have a working fallback position if maintenance goes horribly wrong. The various systems have different strengths and limitations, many of which stem from fundamentally different views on what exactly revision control is. It&amp;rsquo;s a good idea to audition the various revision control systems, and find the one that works best for you. &lt;em&gt;Pragmatic Version Control Using Subversion&lt;/em&gt;, by Mike Mason (Pragmatic Bookshelf, 2005) and &lt;a href=&#34;http://www.oreilly.com/catalog/cvs/&#34;&gt;&lt;em&gt;Essential CVS&lt;/em&gt;&lt;/a&gt;, by Jennifer Vesperman (O&amp;rsquo;Reilly, 2003) are useful starting points.&lt;/p&gt;

&lt;h3 id=&#34;5-create-consistent-command-line-interfaces&#34;&gt;5. Create Consistent Command-Line Interfaces&lt;/h3&gt;

&lt;p&gt;Command-line interfaces have a strong tendency to grow over time, accreting new options as you add features to the application. Unfortunately, the evolution of such interfaces is rarely designed, managed, or controlled, so the set of flags, options, and arguments that a given application accepts are likely to be ad hoc and unique.&lt;/p&gt;

&lt;p&gt;This also means they&amp;rsquo;re likely to be inconsistent with the unique ad hoc sets of flags, options, and arguments that other related applications provide. The result is inevitably a suite of programs, each of which is driven in a distinct and idiosyncratic way. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; orchestrate source.txt -to interim.orc

&amp;gt; remonstrate +interim.rem -interim.orc

&amp;gt; fenestrate  --src=interim.rem --dest=final.wdw
Invalid input format

&amp;gt; fenestrate --help
Unknown option: --help.
Type &#39;fenestrate -hmo&#39; for help
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, the &lt;code&gt;orchestrate&lt;/code&gt; utility expects its input file as its first argument, while the &lt;code&gt;-to&lt;/code&gt; flag specifies its output file. The related &lt;code&gt;remonstrate&lt;/code&gt; tool uses &lt;code&gt;-infile&lt;/code&gt; and &lt;code&gt;+outfile&lt;/code&gt; options instead, with the output file coming first. The &lt;code&gt;fenestrate&lt;/code&gt; program seems to require GNU-style &amp;ldquo;long options:&amp;rdquo; &lt;code&gt;--src=infile&lt;/code&gt; and &lt;code&gt;--dest=outfile&lt;/code&gt;, except, apparently, for its oddly named help flag. All in all, it&amp;rsquo;s a mess.&lt;/p&gt;

&lt;p&gt;When you&amp;rsquo;re providing a suite of programs, all of them should appear to work the same way, using the same flags and options for the same features across all applications. This enables your users to take advantage of existing knowledge&amp;ndash;instead of continually asking you.&lt;/p&gt;

&lt;p&gt;Those three programs should work like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; orchestrate -i source.txt -o dest.orc

&amp;gt; remonstrate -i source.orc -o dest.rem

&amp;gt; fenestrate  -i source.rem -o dest.wdw
Input file (&#39;source.rem&#39;) not a valid Remora file
(type &amp;quot;fenestrate --help&amp;quot; for help)

&amp;gt; fenestrate --help
fenestrate - convert Remora .rem files to Windows .wdw format
Usage: fenestrate [-i &amp;lt;infile&amp;gt;] [-o &amp;lt;outfile&amp;gt;] [-cstq] [-h|-v]
Options:
   -i &amp;lt;infile&amp;gt; Specify input source [default: STDIN]
   -o &amp;lt;outfile&amp;gt; Specify output destination [default: STDOUT]
   -c Attempt to produce a more compact representation
   -h Use horizontal (landscape) layout
   -v Use vertical (portrait) layout
   -s Be strict regarding input
   -t Be extra tolerant regarding input
   -q Run silent
   --version Print version information
   --usage Print the usage line of this summary
   --help Print this summary
   --man Print the complete manpage
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, every application that takes input and output files uses the same two flags to do so. A user who wants to use the &lt;code&gt;substrate&lt;/code&gt; utility (to convert that final .wdw file to a subroutine) is likely to be able to guess correctly the required syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; substrate  -i dest.wdw -o dest.sub
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Anyone who can&amp;rsquo;t guess that probably can guess that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; substrate --help
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is likely to render aid and comfort.&lt;/p&gt;

&lt;p&gt;A large part of making interfaces consistent is being consistent in specifying the individual components of those interfaces. Some conventions that may help to design consistent and predictable interfaces include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Require a flag preceding every piece of command-line data, except filenames.&lt;/p&gt;

&lt;p&gt;Users don&amp;rsquo;t want to have to remember that your application requires &amp;ldquo;input file, output file, block size, operation, fallback strategy,&amp;rdquo; and requires them in that precise order:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; lustrate sample_data proc_data 1000 normalize log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;They want to be able to say explicitly what they mean, in any order that suits them:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; lustrate sample_data proc_data -op=normalize -b1000 --fallback=log
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Provide a flag for each filename, too, especially when a program can be given files for different purposes.&lt;/p&gt;

&lt;p&gt;Users might also not want to remember the order of the two positional filenames, so let them label those arguments as well, and specify them in whatever order they prefer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; lustrate -i sample_data -op normalize -b1000 --fallback log -o proc_data
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use a single &lt;code&gt;-&lt;/code&gt; prefix for short-form flags, up to three letters (&lt;code&gt;-v&lt;/code&gt;, &lt;code&gt;-i&lt;/code&gt;, &lt;code&gt;-rw&lt;/code&gt;, &lt;code&gt;-in&lt;/code&gt;, &lt;code&gt;-out&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Experienced users appreciate short-form flags as a way of reducing typing and limiting command-line clutter. Don&amp;rsquo;t make them type two dashes in these shortcuts.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use a double &lt;code&gt;--&lt;/code&gt; prefix for longer flags (&lt;code&gt;--verbose&lt;/code&gt;, &lt;code&gt;--interactive&lt;/code&gt;, &lt;code&gt;--readwrite&lt;/code&gt;, &lt;code&gt;--input&lt;/code&gt;, &lt;code&gt;--output&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Flags that are complete words improve the readability of a command line (in a shell script, for example). The double dash also helps to distinguish between the longer flag name and any nearby file names.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If a flag expects an associated value, allow an optional &lt;code&gt;=&lt;/code&gt; between the flag and the value.&lt;/p&gt;

&lt;p&gt;Some people prefer to visually associate a value with its preceding flag:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; lustrate -i=sample_data -op=normalize -b=1000 --fallback=log -o=proc_data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Others don&amp;rsquo;t:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; lustrate -i sample_data -op normalize -b1000 --fallback log -o proc_data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Still others want a bit each way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; lustrate -i sample_data -o proc_data -op=normalize -b=1000 --fallback=log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let the user choose.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Allow single-letter options to be &amp;ldquo;bundled&amp;rdquo; after a single dash.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s irritating to have to type repeated dashes for a series of flags:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; lustrate -i sample_data -v -l -x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Allow experienced users to also write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; lustrate -i sample_data -vlx
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Provide a multi-letter version of every single-letter flag.&lt;/p&gt;

&lt;p&gt;Short-form flags may be nice for experienced users, but they can be troublesome for new users: hard to remember and even harder to recognize. Don&amp;rsquo;t force people to do either. Give them a verbose alternative to every concise flag; full words that are easier to remember, and also more self-documenting in shell scripts.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Always allow &lt;code&gt;-&lt;/code&gt; as a special filename.&lt;/p&gt;

&lt;p&gt;A widely used convention is that a dash (&lt;code&gt;-&lt;/code&gt;) where an input file is expected means &amp;ldquo;read from standard input,&amp;rdquo; and a dash where an output file is expected means &amp;ldquo;write to standard output.&amp;rdquo;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Always allow &lt;code&gt;--&lt;/code&gt; as a file list marker.&lt;/p&gt;

&lt;p&gt;Another widely used convention is that the appearance of a double dash (&lt;code&gt;--&lt;/code&gt;) on the command line marks the end of any flagged options, and indicates that the remaining arguments are a list of filenames, even if some of them look like flags.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;6-agree-upon-a-coherent-layout-style-and-automate-it-with-perltidy&#34;&gt;6. Agree Upon a Coherent Layout Style and Automate It with &lt;code&gt;perltidy&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Formatting. Indentation. Style. Code layout. Whatever you choose to call it, it&amp;rsquo;s one of the most contentious aspects of programming discipline. More and bloodier wars have been fought over code layout than over just about any other aspect of coding.&lt;/p&gt;

&lt;p&gt;What is the best practice here? Should you use classic Kernighan and Ritchie style? Or go with BSD code formatting? Or adopt the layout scheme specified by the GNU project? Or conform to the Slashcode coding guidelines?&lt;/p&gt;

&lt;p&gt;Of course not! Everyone knows that &lt;em&gt;&amp;lt;insert your personal coding style here&amp;gt;&lt;/em&gt; is the One True Layout Style, the only sane choice, as ordained by &lt;em&gt;&amp;lt;insert your favorite Programming Deity here&amp;gt;&lt;/em&gt; since Time Immemorial! Any other choice is manifestly absurd, willfully heretical, and self-evidently a Work of Darkness!&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s precisely the problem. When deciding on a layout style, it&amp;rsquo;s hard to decide where rational choices end and rationalized habits begin.&lt;/p&gt;

&lt;p&gt;Adopting a coherently designed approach to code layout, and then applying that approach consistently across all your coding, is fundamental to best-practice programming. Good layout can improve the readability of a program, help detect errors within it, and make the structure of your code much easier to comprehend. Layout matters.&lt;/p&gt;

&lt;p&gt;However, most coding styles&amp;ndash;including the four mentioned earlier&amp;ndash;confer those benefits almost equally well. While it&amp;rsquo;s true that having a consistent code layout scheme matters very much indeed, the particular code layout scheme you ultimately decide upon does not matter at all! All that matters is that you adopt a single, coherent style; one that works for your entire programming team, and, having agreed upon that style, that you then apply it consistently across all your development.&lt;/p&gt;

&lt;p&gt;In the long term, it&amp;rsquo;s best to train yourself and your team to code in a consistent, rational, and readable style. However, the time and commitment necessary to accomplish that isn&amp;rsquo;t always available. In such cases, a reasonable compromise is to prescribe a standard code-formatting tool that must be applied to all code before it&amp;rsquo;s committed, reviewed, or otherwise displayed in public.&lt;/p&gt;

&lt;p&gt;There is now an excellent code formatter available for Perl: &lt;a href=&#34;http://perltidy.sourceforge.net/&#34;&gt;&lt;code&gt;perltidy&lt;/code&gt;&lt;/a&gt;. It provides an extensive range of user-configurable options for indenting, block delimiter positioning, column-like alignment, and comment positioning.&lt;/p&gt;

&lt;p&gt;Using &lt;code&gt;perltidy&lt;/code&gt;, you can convert code like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if($sigil eq &#39;$&#39;){
   if($subsigil eq &#39;?&#39;){
       $sym_table{substr($var_name,2)}=delete $sym_table{locate_orig_var($var)};
       $internal_count++;$has_internal{$var_name}++
   } else {
       ${$var_ref} =
           q{$sym_table{$var_name}}; $external_count++; $has_external{$var_name}++;
}} elsif ($sigil eq &#39;@&#39;&amp;amp;&amp;amp;$subsigil eq &#39;?&#39;) {
   @{$sym_table{$var_name}} = grep
       {defined $_} @{$sym_table{$var_name}};
} elsif ($sigil eq &#39;%&#39; &amp;amp;&amp;amp; $subsigil eq &#39;?&#39;) {
delete $sym_table{$var_name}{$EMPTY_STR}; } else
{
${$var_ref}
=
q{$sym_table{$var_name}}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;into something readable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ( $sigil eq &#39;$&#39; ) {
   if ( $subsigil eq &#39;?&#39; ) {
       $sym_table{ substr( $var_name, 2 ) }
           = delete $sym_table{ locate_orig_var($var) };
       $internal_count++;
       $has_internal{$var_name}++;
   }
   else {
       ${$var_ref} = q{$sym_table{$var_name}};
       $external_count++;
       $has_external{$var_name}++;
   }
}
elsif ( $sigil eq &#39;@&#39; &amp;amp;&amp;amp; $subsigil eq &#39;?&#39; ) {
   @{ $sym_table{$var_name} }
       = grep {defined $_} @{ $sym_table{$var_name} };
}
elsif ( $sigil eq &#39;%&#39; &amp;amp;&amp;amp; $subsigil eq &#39;?&#39; ) {
   delete $sym_table{$var_name}{$EMPTY_STR};
}
else {
   ${$var_ref} = q{$sym_table{$var_name}};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mandating that everyone use a common tool to format their code can also be a simple way of sidestepping the endless objections, acrimony, and dogma that always surround any discussion on code layout. If &lt;code&gt;perltidy&lt;/code&gt; does all the work for them, then it will cost developers almost no effort to adopt the new guidelines. They can simply set up an editor macro that will &amp;ldquo;straighten&amp;rdquo; their code whenever they need to.&lt;/p&gt;

&lt;h3 id=&#34;7-code-in-commented-paragraphs&#34;&gt;7. Code in Commented Paragraphs&lt;/h3&gt;

&lt;p&gt;A paragraph is a collection of statements that accomplish a single task: in literature, it&amp;rsquo;s a series of sentences conveying a single idea; in programming, a series of instructions implementing a single step of an algorithm.&lt;/p&gt;

&lt;p&gt;Break each piece of code into sequences that achieve a single task, placing a single empty line between each sequence. To further improve the maintainability of the code, place a one-line comment at the start of each such paragraph, describing what the sequence of statements does. Like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Process an array that has been recognized...
sub addarray_internal {
   my ($var_name, $needs_quotemeta) = @_;

   # Cache the original...
   $raw .= $var_name;

   # Build meta-quoting code, if requested...
   my $quotemeta = $needs_quotemeta ?  q{map {quotemeta $_} } : $EMPTY_STR;

   # Expand elements of variable, conjoin with ORs...
   my $perl5pat = qq{(??{join q{|}, $quotemeta \@{$var_name}})};

   # Insert debugging code if requested...
   my $type = $quotemeta ? &#39;literal&#39; : &#39;pattern&#39;;
   debug_now(&amp;quot;Adding $var_name (as $type)&amp;quot;);
   add_debug_mesg(&amp;quot;Trying $var_name (as $type)&amp;quot;);

   return $perl5pat;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Paragraphs are useful because humans can focus on only a few pieces of information at once. Paragraphs are one way of aggregating small amounts of related information, so that the resulting &amp;ldquo;chunk&amp;rdquo; can fit into a single slot of the reader&amp;rsquo;s limited short-term memory. Paragraphs enable the physical structure of a piece of writing to reflect and emphasize its logical structure.&lt;/p&gt;

&lt;p&gt;Adding comments at the start of each paragraph further enhances the chunking by explicitly summarizing the purpose of each chunk (note: the purpose, not the behavior). Paragraph comments need to explain why the code is there and what it achieves, not merely paraphrase the precise computational steps it&amp;rsquo;s performing.&lt;/p&gt;

&lt;p&gt;Note, however, that the contents of paragraphs are only of secondary importance here. It is the vertical gaps separating each paragraph that are critical. Without them, the readability of the code declines dramatically, even if the comments are retained:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub addarray_internal {
   my ($var_name, $needs_quotemeta) = @_;
   # Cache the original...
   $raw .= $var_name;
   # Build meta-quoting code, if required...
   my $quotemeta = $needs_quotemeta ?  q{map {quotemeta $_} } : $EMPTY_STR;
   # Expand elements of variable, conjoin with ORs...
   my $perl5pat = qq{(??{join q{|}, $quotemeta \@{$var_name}})};
   # Insert debugging code if requested...
   my $type = $quotemeta ? &#39;literal&#39; : &#39;pattern&#39;;
   debug_now(&amp;quot;Adding $var_name (as $type)&amp;quot;);
   add_debug_mesg(&amp;quot;Trying $var_name (as $type)&amp;quot;);
   return $perl5pat;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;8-throw-exceptions-instead-of-returning-special-values-or-setting-flags&#34;&gt;8. Throw Exceptions Instead of Returning Special Values or Setting Flags&lt;/h3&gt;

&lt;p&gt;Returning a special error value on failure, or setting a special error flag, is a very common error-handling technique. Collectively, they&amp;rsquo;re the basis for virtually all error notification from Perl&amp;rsquo;s own built-in functions. For example, the built-ins &lt;code&gt;eval&lt;/code&gt;, &lt;code&gt;exec&lt;/code&gt;, &lt;code&gt;flock&lt;/code&gt;, &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;stat&lt;/code&gt;, and &lt;code&gt;system&lt;/code&gt; all return special values on error. Unfortunately, they don&amp;rsquo;t all use the same special value. Some of them also set a flag on failure. Sadly, it&amp;rsquo;s not always the same flag. See the &lt;a href=&#34;https://perldoc.perl.org/perlfunc.html&#34;&gt;perlfunc&lt;/a&gt; manpage for the gory details.&lt;/p&gt;

&lt;p&gt;Apart from the obvious consistency problems, error notification via flags and return values has another serious flaw: developers can silently ignore flags and return values, and ignoring them requires absolutely no effort on the part of the programmer. In fact, in a void context, ignoring return values is Perl&amp;rsquo;s default behavior. Ignoring an error flag that has suddenly appeared in a special variable is just as easy: you simply don&amp;rsquo;t bother to check the variable.&lt;/p&gt;

&lt;p&gt;Moreover, because ignoring a return value is the void-context default, there&amp;rsquo;s no syntactic marker for it. There&amp;rsquo;s no way to look at a program and immediately see where a return value is deliberately being ignored, which means there&amp;rsquo;s also no way to be sure that it&amp;rsquo;s not being ignored accidentally.&lt;/p&gt;

&lt;p&gt;The bottom line: regardless of the programmer&amp;rsquo;s (lack of) intention, an error indicator is being ignored. That&amp;rsquo;s not good programming.&lt;/p&gt;

&lt;p&gt;Ignoring error indicators frequently causes programs to propagate errors in entirely the wrong direction. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Find and open a file by name, returning the filehandle
# or undef on failure...
sub locate_and_open {
   my ($filename) = @_;

   # Check acceptable directories in order...
   for my $dir (@DATA_DIRS) {
       my $path = &amp;quot;$dir/$filename&amp;quot;;

       # If file exists in an acceptable directory, open and return it...
       if (-r $path) {
           open my $fh, &#39;&amp;lt;&#39;, $path;
           return $fh;
       }
   }

   # Fail if all possible locations tried without success...
   return;
}

# Load file contents up to the first &amp;lt;DATA/&amp;gt; marker...
sub load_header_from {
   my ($fh) = @_;

   # Use DATA tag as end-of-&amp;quot;line&amp;quot;...
   local $/ = &#39;&amp;lt;DATA/&amp;gt;&#39;;

   # Read to end-of-&amp;quot;line&amp;quot;...
   return &amp;lt;$fh&amp;gt;;
}

# and later...
for my $filename (@source_files) {
   my $fh = locate_and_open($filename);
   my $head = load_header_from($fh);
   print $head;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;locate_and_open()&lt;/code&gt; subroutine simply assumes that the call to &lt;code&gt;open&lt;/code&gt; works, immediately returning the filehandle (&lt;code&gt;$fh&lt;/code&gt;), whatever the actual outcome of the &lt;code&gt;open&lt;/code&gt;. Presumably, the expectation is that whoever calls &lt;code&gt;locate_and_open()&lt;/code&gt; will check whether the return value is a valid filehandle.&lt;/p&gt;

&lt;p&gt;Except, of course, &amp;ldquo;whoever&amp;rdquo; doesn&amp;rsquo;t check. Instead of testing for failure, the main &lt;code&gt;for&lt;/code&gt; loop takes the failure value and immediately propagates it &amp;ldquo;across&amp;rdquo; the block, to the rest of the statements in the loop. That causes the call to &lt;code&gt;loader_header_from()&lt;/code&gt; to propagate the error value &amp;ldquo;downwards.&amp;rdquo; It&amp;rsquo;s in that subroutine that the attempt to treat the failure value as a filehandle eventually kills the program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;readline() on unopened filehandle at demo.pl line 28.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Code like that&amp;ndash;where an error is reported in an entirely different part of the program from where it actually occurred&amp;ndash;is particularly onerous to debug.&lt;/p&gt;

&lt;p&gt;Of course, you could argue that the fault lies squarely with whoever wrote the loop, for using &lt;code&gt;locate_and_open()&lt;/code&gt; without checking its return value. In the narrowest sense, that&amp;rsquo;s entirely correct&amp;ndash;but the deeper fault lies with whoever actually wrote &lt;code&gt;locate_and_open()&lt;/code&gt; in the first place, or at least, whoever assumed that the caller would always check its return value.&lt;/p&gt;

&lt;p&gt;Humans simply aren&amp;rsquo;t like that. Rocks almost never fall out of the sky, so humans soon conclude that they never do, and stop looking up for them. Fires rarely break out in their homes, so humans soon forget that they might, and stop testing their smoke detectors every month. In the same way, programmers inevitably abbreviate &amp;ldquo;almost never fails&amp;rdquo; to &amp;ldquo;never fails,&amp;rdquo; and then simply stop checking.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s why so very few people bother to verify their &lt;code&gt;print&lt;/code&gt; statements:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!print &#39;Enter your name: &#39;) {
   print {*STDLOG} warning =&amp;gt; &#39;Terminal went missing!&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s human nature to &amp;ldquo;trust but not verify.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Human nature is why returning an error indicator is not best practice. Errors are (supposed to be) unusual occurrences, so error markers will almost never be returned. Those tedious and ungainly checks for them will almost never do anything useful, so eventually they&amp;rsquo;ll be quietly omitted. After all, leaving the tests off almost always works just fine. It&amp;rsquo;s so much easier not to bother. Especially when not bothering is the default!&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t return special error values when something goes wrong; throw an exception instead. The great advantage of exceptions is that they reverse the usual default behaviors, bringing untrapped errors to immediate and urgent attention. On the other hand, ignoring an exception requires a deliberate and conspicuous effort: you have to provide an explicit &lt;code&gt;eval&lt;/code&gt; block to neutralize it.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;locate_and_open()&lt;/code&gt; subroutine would be much cleaner and more robust if the errors within it threw exceptions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Find and open a file by name, returning the filehandle
# or throwing an exception on failure...
sub locate_and_open {
   my ($filename) = @_;

   # Check acceptable directories in order...
   for my $dir (@DATA_DIRS) {
       my $path = &amp;quot;$dir/$filename&amp;quot;;

       # If file exists in acceptable directory, open and return it...
       if (-r $path) {
           open my $fh, &#39;&amp;lt;&#39;, $path
               or croak( &amp;quot;Located $filename at $path, but could not open&amp;quot;);
           return $fh;
       }
   }

   # Fail if all possible locations tried without success...
   croak( &amp;quot;Could not locate $filename&amp;quot; );
}

# and later...
for my $filename (@source_files) {
   my $fh = locate_and_open($filename);
   my $head = load_header_from($fh);
   print $head;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that the main &lt;code&gt;for&lt;/code&gt; loop didn&amp;rsquo;t change at all. The developer using &lt;code&gt;locate_and_open()&lt;/code&gt; still assumes that nothing can go wrong. Now there&amp;rsquo;s some justification for that expectation, because if anything does go wrong, the thrown exception will automatically terminate the loop.&lt;/p&gt;

&lt;p&gt;Exceptions are a better choice even if you are the careful type who religiously checks every return value for failure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SOURCE_FILE:
for my $filename (@source_files) {
   my $fh = locate_and_open($filename);
   next SOURCE_FILE if !defined $fh;
   my $head = load_header_from($fh);
   next SOURCE_FILE if !defined $head;
   print $head;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Constantly checking return values for failure clutters your code with validation statements, often greatly decreasing its readability. In contrast, exceptions allow an algorithm to be implemented without having to intersperse any error-handling infrastructure at all. You can factor the error-handling out of the code and either relegate it to after the surrounding &lt;code&gt;eval&lt;/code&gt;, or else dispense with it entirely:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for my $filename (@directory_path) {

   # Just ignore any source files that don&#39;t load...
   eval {
       my $fh = locate_and_open($filename);
       my $head = load_header_from($fh);
       print $head;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;9-add-new-test-cases-before-you-start-debugging&#34;&gt;9. Add New Test Cases Before you Start Debugging&lt;/h3&gt;

&lt;p&gt;The first step in any debugging process is to isolate the incorrect behavior of the system, by producing the shortest demonstration of it that you reasonably can. If you&amp;rsquo;re lucky, this may even have been done for you:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;To: DCONWAY@cpan.org
From: sascha@perlmonks.org
Subject: Bug in inflect module

Zdravstvuite,

I have been using your Lingua::EN::Inflect module to normalize terms in a
data-mining application I am developing, but there seems to be a bug in it,
as the following example demonstrates:

   use Lingua::EN::Inflect qw( PL_N );
   print PL_N(&#39;man&#39;), &amp;quot;\n&amp;quot;;       # Prints &amp;quot;men&amp;quot;, as expected
   print PL_N(&#39;woman&#39;), &amp;quot;\n&amp;quot;;     # Incorrectly prints &amp;quot;womans&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once you have distilled a short working example of the bug, convert it to a series of tests, such as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Lingua::EN::Inflect qw( PL_N );
use Test::More qw( no_plan );
is(PL_N(&#39;man&#39;) ,  &#39;men&#39;, &#39;man -&amp;gt; men&#39;     );
is(PL_N(&#39;woman&#39;), &#39;women&#39;, &#39;woman -&amp;gt; women&#39; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Don&amp;rsquo;t try to fix the problem straight away, though. Instead, immediately add those tests to your test suite. If that testing has been well set up, that can often be as simple as adding a couple of entries to a table:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my %plural_of = (
   &#39;mouse&#39;         =&amp;gt; &#39;mice&#39;,
   &#39;house&#39;         =&amp;gt; &#39;houses&#39;,
   &#39;ox&#39;            =&amp;gt; &#39;oxen&#39;,
   &#39;box&#39;           =&amp;gt; &#39;boxes&#39;,
   &#39;goose&#39;         =&amp;gt; &#39;geese&#39;,
   &#39;mongoose&#39;      =&amp;gt; &#39;mongooses&#39;,
   &#39;law&#39;           =&amp;gt; &#39;laws&#39;,
   &#39;mother-in-law&#39; =&amp;gt; &#39;mothers-in-law&#39;,

   # Sascha&#39;s bug, reported 27 August 2004...
   &#39;man&#39;           =&amp;gt; &#39;men&#39;,
   &#39;woman&#39;         =&amp;gt; &#39;women&#39;,
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The point is: if the original test suite didn&amp;rsquo;t report this bug, then that test suite was broken. It simply didn&amp;rsquo;t do its job (finding bugs) adequately. Fix the test suite first by adding tests that cause it to fail:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; perl inflections.t
ok 1 - house -&amp;gt; houses
ok 2 - law -&amp;gt; laws
ok 3 - man -&amp;gt; men
ok 4 - mongoose -&amp;gt; mongooses
ok 5 - goose -&amp;gt; geese
ok 6 - ox -&amp;gt; oxen
not ok 7 - woman -&amp;gt; women
#     Failed test (inflections.t at line 20)
#          got: &#39;womans&#39;
#     expected: &#39;women&#39;
ok 8 - mother-in-law -&amp;gt; mothers-in-law
ok 9 - mouse -&amp;gt; mice
ok 10 - box -&amp;gt; boxes
1..10
# Looks like you failed 1 tests of 10.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once the test suite is detecting the problem correctly, then you&amp;rsquo;ll be able to tell when you&amp;rsquo;ve correctly fixed the actual bug, because the tests will once again fall silent.&lt;/p&gt;

&lt;p&gt;This approach to debugging is most effective when the test suite covers the full range of manifestations of the problem. When adding test cases for a bug, don&amp;rsquo;t just add a single test for the simplest case. Make sure you include the obvious variations as well:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my %plural_of = (
   &#39;mouse&#39;         =&amp;gt; &#39;mice&#39;,
   &#39;house&#39;         =&amp;gt; &#39;houses&#39;,
   &#39;ox&#39;            =&amp;gt; &#39;oxen&#39;,
   &#39;box&#39;           =&amp;gt; &#39;boxes&#39;,
   &#39;goose&#39;         =&amp;gt; &#39;geese&#39;,
   &#39;mongoose&#39;      =&amp;gt; &#39;mongooses&#39;,
   &#39;law&#39;           =&amp;gt; &#39;laws&#39;,
   &#39;mother-in-law&#39; =&amp;gt; &#39;mothers-in-law&#39;,

   # Sascha&#39;s bug, reported 27 August 2004...
   &#39;man&#39;           =&amp;gt; &#39;men&#39;,
   &#39;woman&#39;         =&amp;gt; &#39;women&#39;,
   &#39;human&#39;         =&amp;gt; &#39;humans&#39;,
   &#39;man-at-arms&#39;   =&amp;gt; &#39;men-at-arms&#39;,
   &#39;lan&#39;           =&amp;gt; &#39;lans&#39;,
   &#39;mane&#39;          =&amp;gt; &#39;manes&#39;,
   &#39;moan&#39;          =&amp;gt; &#39;moans&#39;,
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The more thoroughly you test the bug, the more completely you will fix it.&lt;/p&gt;

&lt;h3 id=&#34;10-don-t-optimize-code-benchmark-it&#34;&gt;10. Don&amp;rsquo;t Optimize Code&amp;ndash;Benchmark It&lt;/h3&gt;

&lt;p&gt;If you need a function to remove duplicate elements of an array, it&amp;rsquo;s natural to think that a &amp;ldquo;one-liner&amp;rdquo; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub uniq { return keys %{ { map {$_=&amp;gt;1} @_ } } }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will be more efficient than two statements:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub uniq {
   my %seen;
   return grep {!$seen{$_}++} @_;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unless you are deeply familiar with the internals of the Perl interpreter (in which case you already have far more serious personal issues to deal with), intuitions about the relative performance of two constructs are exactly that: unconscious guesses.&lt;/p&gt;

&lt;p&gt;The only way to know for sure which of two&amp;ndash;or more&amp;ndash;alternatives will perform better is to actually time each of them. The standard &lt;a href=&#34;https://metacpan.org/pod/Benchmark&#34;&gt;Benchmark&lt;/a&gt; module makes that easy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# A short list of not-quite-unique values...
our @data = qw( do re me fa so la ti do );

# Various candidates...
sub unique_via_anon {
   return keys %{ { map {$_=&amp;gt;1} @_ } };
}

sub unique_via_grep {
   my %seen;
   return grep { !$seen{$_}++ } @_;
}

sub unique_via_slice {
   my %uniq;
   @uniq{@_} = ();
   return keys %uniq;
}

# Compare the current set of data in @data
sub compare {
   my ($title) = @_;
   print &amp;quot;\n[$title]\n&amp;quot;;

   # Create a comparison table of the various timings, making sure that
   # each test runs at least 10 CPU seconds...
   use Benchmark qw( cmpthese );
   cmpthese -10, {
       anon  =&amp;gt; &#39;my @uniq = unique_via_anon(@data)&#39;,
       grep  =&amp;gt; &#39;my @uniq = unique_via_grep(@data)&#39;,
       slice =&amp;gt; &#39;my @uniq = unique_via_slice(@data)&#39;,
   };

   return;
}

compare(&#39;8 items, 10% repetition&#39;);

# Two copies of the original data...
@data = (@data) x 2;
compare(&#39;16 items, 56% repetition&#39;);

# One hundred copies of the original data...
@data = (@data) x 50;
compare(&#39;800 items, 99% repetition&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;cmpthese()&lt;/code&gt; subroutine takes a number, followed by a reference to a hash of tests. The number specifies either the exact number of times to run each test (if the number is positive), or the absolute number of CPU seconds to run the test for (if the number is negative). Typical values are around 10,000 repetitions or ten CPU seconds, but the module will warn you if the test is too short to produce an accurate benchmark.&lt;/p&gt;

&lt;p&gt;The keys of the test hash are the names of your tests, and the corresponding values specify the code to be tested. Those values can be either strings (which are &lt;code&gt;eval&lt;/code&gt;&amp;rsquo;d to produce executable code) or subroutine references (which are called directly).&lt;/p&gt;

&lt;p&gt;The benchmarking code shown above would print out something like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[8 items, 10% repetitions]
        Rate anon  grep slice
anon  28234/s --  -24%  -47%
grep  37294/s   32% --  -30%
slice 53013/s   88% 42%    --

[16 items, 50% repetitions]
        Rate anon  grep slice
anon  21283/s --  -28%  -51%
grep  29500/s   39% --  -32%
slice 43535/s  105% 48%    --

[800 items, 99% repetitions]
       Rate  anon grep slice
anon   536/s --  -65%  -89%
grep  1516/s  183% --  -69%
slice 4855/s  806%  220% --
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each of the tables printed has a separate row for each named test. The first column lists the absolute speed of each candidate in repetitions per second, while the remaining columns allow you to compare the relative performance of any two tests. For example, in the final test tracing across the &lt;code&gt;grep&lt;/code&gt; row to the &lt;code&gt;anon&lt;/code&gt; column reveals that the &lt;code&gt;grep&lt;/code&gt;ped solution was 1.83 times (183 percent) faster than using an anonymous hash. Tracing further across the same row also indicates that &lt;code&gt;grep&lt;/code&gt;ping was 69 percent slower (-69 percent faster) than slicing.&lt;/p&gt;

&lt;p&gt;Overall, the indication from the three tests is that the slicing-based solution is consistently the fastest for this particular set of data on this particular machine. It also appears that as the data set increases in size, slicing also scales much better than either of the other two approaches.&lt;/p&gt;

&lt;p&gt;However, those two conclusions are effectively drawn from only three data points (namely, the three benchmarking runs). To get a more definitive comparison of the three methods, you&amp;rsquo;d also need to test other possibilities, such as a long list of non-repeating items, or a short list with nothing but repetitions.&lt;/p&gt;

&lt;p&gt;Better still, test on the real data that you&amp;rsquo;ll actually be &amp;ldquo;unique-ing.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;For example, if that data is a sorted list of a quarter of a million words, with only minimal repetitions, and which has to remain sorted, then test exactly that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;our @data = slurp &#39;/usr/share/biglongwordlist.txt&#39;;

use Benchmark qw( cmpthese );

cmpthese 10, {
    # Note: the non-grepped solutions need a post-uniqification re-sort
    anon  =&amp;gt; &#39;my @uniq = sort(unique_via_anon(@data))&#39;,
    grep  =&amp;gt; &#39;my @uniq = unique_via_grep(@data)&#39;,
    slice =&amp;gt; &#39;my @uniq = sort(unique_via_slice(@data))&#39;,
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not surprisingly, this benchmark indicates that the &lt;code&gt;grep&lt;/code&gt;ped solution is markedly superior on a large sorted data set:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s/iter anon slice  grep
anon    4.28 --   -3%  -46%
slice   4.15 3%    --  -44%
grep    2.30 86%   80%    --
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perhaps more interestingly, the &lt;code&gt;grep&lt;/code&gt;ped solution still benchmarks as being marginally faster when the two hash-based approaches aren&amp;rsquo;t re-sorted. This suggests that the better scalability of the sliced solution as seen in the earlier benchmark is a localized phenomenon, and is eventually undermined by the growing costs of allocation, hashing, and bucket-overflows as the sliced hash grows very large.&lt;/p&gt;

&lt;p&gt;Above all, that last example demonstrates that benchmarks only benchmark the cases you actually benchmark, and that you can only draw useful conclusions about performance from benchmarking real data.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

