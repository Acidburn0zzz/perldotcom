<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Scripting on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/scripting/</link>
    <description>Recent content in Scripting on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 06 Dec 2007 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/scripting/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Programming is Hard, Let&#39;s Go Scripting...</title>
      <link>http://localhost:1313/pub/2007/12/06/soto-11.html/</link>
      <pubDate>Thu, 06 Dec 2007 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2007/12/06/soto-11.html/</guid>
      <description>

&lt;p&gt;I think, to most people, scripting is a lot like obscenity. I can&amp;rsquo;t define it, but I&amp;rsquo;ll know it when I see it. Here are some common memes floating around:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Simple language
    &amp;quot;Everything is a string&amp;quot;
    Rapid prototyping
    Glue language
    Process control
    Compact/concise
    Worse-is-better
    Domain specific
    &amp;quot;Batteries included&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;I don&amp;rsquo;t see any real center here, at least in terms of technology. If I had to pick one metaphor, it&amp;rsquo;d be easy onramps. And a slow lane. Maybe even with some optional fast lanes.&lt;/p&gt;

&lt;h3 id=&#34;easy-onramps&#34;&gt;Easy Onramps&lt;/h3&gt;

&lt;p&gt;But basically, scripting is not a technical term. When we call something a scripting language, we&amp;rsquo;re primarily making a linguistic and cultural judgment, not a technical judgment.&lt;/p&gt;

&lt;p&gt;I see scripting as one of the humanities. It&amp;rsquo;s our linguistic roots showing through. So speaking of roots&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;the-past&#34;&gt;The Past&lt;/h3&gt;

&lt;p&gt;Suppose you went back to Ada Lovelace and asked her the difference between a script and a program. She&amp;rsquo;d probably look at you funny, then say something like: Well, a script is what you give the actors, but a program is what you give the audience. That Ada was one sharp lady&amp;hellip;&lt;/p&gt;

&lt;p&gt;Since her time, we seem to have gotten a bit more confused about what we mean when we say scripting. It confuses even me, and I&amp;rsquo;m supposed to be one of the experts.&lt;/p&gt;

&lt;p&gt;So I&amp;rsquo;m afraid all I can do is give you my own worm&amp;rsquo;s eye view of the past, the present, and the future. Let me warn you that I am not without a few prejudices here and there.&lt;/p&gt;

&lt;h3 id=&#34;basic&#34;&gt;BASIC&lt;/h3&gt;

&lt;p&gt;Now, however it was initially intended, I think BASIC turned out to be one of the first major scripting languages, especially the extended version that DEC put onto its minicomputers called BASIC/PLUS, which happily included recursive functions with arguments. I started out as a BASIC programmer. Some people would say that I&amp;rsquo;m permanently damaged. Some people are undoubtedly right.&lt;/p&gt;

&lt;p&gt;But I&amp;rsquo;m not going to apologize for that. All language designers have their occasional idiosyncracies. I&amp;rsquo;m just better at it than most. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;rsts-basic-plus&#34;&gt;RSTS BASIC/PLUS&lt;/h3&gt;

&lt;p&gt;Anyway, when I was a RSTS programmer on a PDP-11, I certainly treated BASIC as a scripting language, at least in terms of rapid prototyping and process control. I&amp;rsquo;m sure it warped my brain forever. Perl&amp;rsquo;s statement modifiers are straight out of BASIC/PLUS. It even had some cute sigils on the ends of its variables to distinguish string and integer from floating point.&lt;/p&gt;

&lt;p&gt;But you could do extreme programming. In fact, I had a college buddy I did pair programming with. We took a compiler writing class together and studied all that fancy stuff from the dragon book. Then of course the professor announced we would be implementing our own language, called PL/0. After thinking about it a while, we announced that we were going to do our project in BASIC. The professor looked at us like were insane. Nobody else in the class was using BASIC. And you know what? Nobody else in the class finished their compiler either. We not only finished but added I/O extensions, and called it PL 0.5. That&amp;rsquo;s rapid prototyping.&lt;/p&gt;

&lt;h3 id=&#34;unix&#34;&gt;Unix?&lt;/h3&gt;

&lt;p&gt;I remember one day our computer center got a letter from Bell Labs telling us that we could get a tape of Unix V6 for cheap, only $100 because they were coming out shortly with V7. We all looked at each other and said, Why would we ever want to use this thing called Unix? We have RSTS.&lt;/p&gt;

&lt;h3 id=&#34;jam-no-not-that-one&#34;&gt;JAM (no not that one)&lt;/h3&gt;

&lt;p&gt;My first scripting language was written in BASIC. For my job in the computer center I wrote a language that I called JAM, short for Jury-rigged All-purpose Meta-language. Story of my life&amp;hellip;&lt;/p&gt;

&lt;p&gt;JAM was an inside-out text-processing language much like PHP, except that HTML hadn&amp;rsquo;t been invented yet. We mostly used it as a fancy macro processor for BASIC. Unlike PHP, it did not have 3,000 functions in one namespace. We wouldn&amp;rsquo;t have had the memory, for one thing.&lt;/p&gt;

&lt;h3 id=&#34;lisp&#34;&gt;LISP&lt;/h3&gt;

&lt;p&gt;For good or ill, when I went off to grad school, I studied linguistics, so the only computer language I used there was LISP. It was my own personal McCarthy era.&lt;/p&gt;

&lt;p&gt;Is LISP a candidate for a scripting language? While you can certainly write things rapidly in it, I cannot in good conscience call LISP a scripting language. By policy, LISP has never really catered to mere mortals.&lt;/p&gt;

&lt;p&gt;And, of course, mere mortals have never really forgiven LISP for not catering to them.&lt;/p&gt;

&lt;h3 id=&#34;pascal-ada&#34;&gt;Pascal, Ada&lt;/h3&gt;

&lt;p&gt;Once I got into industry, I wrote a compiler in Pascal for a discrete event simulator, and slavered over the forthcoming Ada specs. As a linguist, I don&amp;rsquo;t think of Ada as a big language. Now, English and Japanese, those are big languages. Ada is just a medium-sized language.&lt;/p&gt;

&lt;h3 id=&#34;unix-shell&#34;&gt;Unix, shell&lt;/h3&gt;

&lt;p&gt;After several years I finally became acquainted with Unix and its various scripting languages. OK, to be more precise, BSD, and csh.&lt;/p&gt;

&lt;h3 id=&#34;bsd-csh&#34;&gt;BSD, csh&lt;/h3&gt;

&lt;p&gt;Yeah, yeah, I know. More brain damage&amp;hellip;&lt;/p&gt;

&lt;p&gt;I also learned a little C.&lt;/p&gt;

&lt;h3 id=&#34;c&#34;&gt;C&lt;/h3&gt;

&lt;p&gt;That&amp;rsquo;s because a little C is all there is. I&amp;rsquo;m still learning those libraries though.&lt;/p&gt;

&lt;h3 id=&#34;shell-awk-sed-find-expr&#34;&gt;shell + awk + sed + find + expr&amp;hellip;&lt;/h3&gt;

&lt;p&gt;But the frustrations of Unix shell programming led directly to the creation of Perl, which I don&amp;rsquo;t really have time to tell. But essentially, I found that shell scripting was intrinsically limited by the fact that most of its verbs are not under its control and hence largely inconsistent with each other. And the nouns are impoverished, restricted to strings and files, with who-knows-what typology.&lt;/p&gt;

&lt;h3 id=&#34;c-xor-shell&#34;&gt;C xor shell&lt;/h3&gt;

&lt;p&gt;More destructive was the mindset that it was a one-dimensional universe: you either programmed in C or you programmed in shell, because they&amp;rsquo;re obviously at opposite ends of the One True Continuum. Perl came about when I realized that scripting did not always have to viewed as the opposite of programming, but that a single language could be pretty good for both. That opened up a huge ecological niche. Many of you have seen my old clamshell diagram, with the two dimensions of manipulexity and whipuptitude.&lt;/p&gt;

&lt;h3 id=&#34;tcl&#34;&gt;Tcl&lt;/h3&gt;

&lt;p&gt;After Perl came Tcl, which in a sense is a purer scripting language than Perl. Perl just pretends that everything is a string when it&amp;rsquo;s convenient, but Tcl really believes that as a controlling metaphor. The string metaphor tends to have bad performance ramifications, but that&amp;rsquo;s not why Tcl languished, I think. There were two reasons for that.&lt;/p&gt;

&lt;p&gt;First, Tcl stayed in the Unix mindset that controlling tools was the opposite of creating tools, so they didn&amp;rsquo;t optimize much. The fast parts can always be written in C, after all.&lt;/p&gt;

&lt;p&gt;The second reason was the lack of a decent extension mechanism, so you ended up with separate executables for expect, incr-tcl, etc.&lt;/p&gt;

&lt;p&gt;I must say, though, that I&amp;rsquo;ve always admired Tcl&amp;rsquo;s delegational model of semantics. But it fell into the same trap as LISP by expecting everyone to use the One True Syntax. Speaking of the One True Syntax:&lt;/p&gt;

&lt;h3 id=&#34;python&#34;&gt;Python&lt;/h3&gt;

&lt;p&gt;After Tcl came Python, which in Guido&amp;rsquo;s mind was inspired positively by ABC, but in the Python community&amp;rsquo;s mind was inspired negatively by Perl. I&amp;rsquo;m not terribly qualified to talk about Python however. I don&amp;rsquo;t really know much about Python. I only stole its object system for PerlÂ 5. I have since repented.&lt;/p&gt;

&lt;h3 id=&#34;ruby&#34;&gt;Ruby&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;m much more qualified to talk about Ruby&amp;ndash;that&amp;rsquo;s because a great deal of Ruby&amp;rsquo;s syntax is borrowed from Perl, layered over Smalltalk semantics. I&amp;rsquo;ve always viewed Ruby as a much closer competitor for Perls ecological niche, not just because of the borrowed ideas, but because both Perl and Ruby take their functional programming support rather more seriously that Python does. On the other hand, I think Ruby kind of screwed up on its declaration syntax, among other things.&lt;/p&gt;

&lt;h3 id=&#34;sh&#34;&gt;*sh&lt;/h3&gt;

&lt;p&gt;Meanwhile, the Bourne shell was extended into the Korn shell and bash. I didn&amp;rsquo;t have much to do with those either. Thankfully. I will say that the continued evolution of the shell shows just how crufty a language can get when you just keep adding on ad hoc syntactic features.&lt;/p&gt;

&lt;h3 id=&#34;php&#34;&gt;PHP&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ve also seen the rise of PHP, which takes the worse-is-better approach to dazzling new depths, as it were. By and large PHP seems to be making the same progression of mistakes as early Perl did, only slower. The one thing it does better is packaging. And when I say packaging, I don&amp;rsquo;t mean namespaces.&lt;/p&gt;

&lt;h3 id=&#34;javascript&#34;&gt;JavaScript&lt;/h3&gt;

&lt;p&gt;Then there&amp;rsquo;s JavaScript, a nice clean design. It has some issues, but in the long run JavaScript might actually turn out to be a decent platform for running PerlÂ 6 on. Pugs already has part of a backend for JavaScript, though sadly that has suffered some bitrot in the last year. I think when the new JavaScript engines come out we&amp;rsquo;ll probably see renewed interest in a JavaScript backend.&lt;/p&gt;

&lt;h3 id=&#34;monad-powershell&#34;&gt;Monad/PowerShell&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;ve looked a bit at Microsoft&amp;rsquo;s Monad, and I&amp;rsquo;m pleased to note that it has object pipes like PerlÂ 6. I just hope they don&amp;rsquo;t patent it.&lt;/p&gt;

&lt;h3 id=&#34;lua-applescript&#34;&gt;Lua, AppleScript&lt;/h3&gt;

&lt;p&gt;There are other scripting languages in wide use. Sadly, I must confess I never looked closely at Lua or AppleScript, probably because I&amp;rsquo;m not a game designer with a Mac.&lt;/p&gt;

&lt;p&gt;Actually, I suspect it runs deeper than that, which brings us up to the present time.&lt;/p&gt;

&lt;h3 id=&#34;the-present&#34;&gt;The Present&lt;/h3&gt;

&lt;p&gt;When I look at the present situation, what I see is the various scripting communities behaving a lot like neighboring tribes in the jungle, sometimes trading, sometimes warring, but by and large just keeping out of each other&amp;rsquo;s way in complacent isolation.&lt;/p&gt;

&lt;p&gt;I tend to take an anthropological view of these things. Many of you here are Perl programmers, but some of you come from other programming tribes. And depending on your tribal history, you might think of a string as a pointer to a byte array if you&amp;rsquo;re a C programmer, or as a list if you&amp;rsquo;re a functional programmer, or as an object if you&amp;rsquo;re a Java programmer. I view a string as a Text, with a capital T.&lt;/p&gt;

&lt;h3 id=&#34;text&#34;&gt;Text&lt;/h3&gt;

&lt;p&gt;I read that word from a postmodern perspective. Of course, the term Postmodern is itself context-sensitive. Some folks think Postmodernism means little more than the Empowerment of the Vulgar. Some folks think the same about Perl.&lt;/p&gt;

&lt;p&gt;But I take Postmodernism to mean that a Text, whether spoken or written, is an act of communication requiring intelligence on both ends, and sometimes in the middle too. I don&amp;rsquo;t want to talk to a stupid computer language. I want my computer language to understand the strings I type.&lt;/p&gt;

&lt;p&gt;Perl is a postmodern language, and a lot of conservative folks feel like Postmodernism is a rather liberal notion. So it&amp;rsquo;s rather ironic that my views on Postmodernism were primarily informed by studying linguistics and translation as taught by missionaries, specifically, the Wycliffe Bible Translators. One of the things they hammered home is that there&amp;rsquo;s really no such thing as a primitive human language. By which they mean essentially that all human languages are Turing complete.&lt;/p&gt;

&lt;p&gt;When you go out to so-called primitive tribes and analyze their languages, you find that structurally they&amp;rsquo;re just about as complex as any other human language. Basically, you can say pretty much anything in any human language, if you work at it long enough. Human languages are Turing complete, as it were.&lt;/p&gt;

&lt;p&gt;Human languages therefore differ not so much in what you &lt;em&gt;can&lt;/em&gt; say but in what you &lt;em&gt;must&lt;/em&gt; say. In English, you are forced to differentiate singular from plural. In Japanese, you don&amp;rsquo;t have to distinguish singular from plural, but you do have to pick a specific level of politeness, taking into account not only your degree of respect for the person you&amp;rsquo;re talking to, but also your degree of respect for the person or thing you&amp;rsquo;re talking about.&lt;/p&gt;

&lt;p&gt;So languages differ in what you&amp;rsquo;re forced to say. Obviously, if your language forces you to say something, you can&amp;rsquo;t be concise in that particular dimension using your language. Which brings us back to scripting.&lt;/p&gt;

&lt;p&gt;How many ways are there for different scripting languages to be concise?&lt;/p&gt;

&lt;p&gt;How many recipes for borscht are there in Russia?&lt;/p&gt;

&lt;p&gt;Language designers have many degrees of freedom. I&amp;rsquo;d like to point out just a few of them.&lt;/p&gt;

&lt;h3 id=&#34;early-binding-late-binding&#34;&gt;early binding / late binding&lt;/h3&gt;

&lt;p&gt;Binding in this context is about exactly when you decide which routine you&amp;rsquo;re going to call for a given routine name. In the early days of computing, most binding was done fairly early for efficiency reasons, either at compile time, or at the latest, at link time. You still tend to see this approach in statically typed languages. With languages like Smalltalk, however, we began to see a different trend, and these days most scripting languages are trending towards later binding. That&amp;rsquo;s because scripting languages are trying to be dwimmy (Do What I Mean), and the dwimmiest decision is usually a late decision because you then have more available semantic and even pragmatic context to work with. Otherwise you have to predict the future, which is hard.&lt;/p&gt;

&lt;p&gt;So scripting languages naturally tend to move toward an object-oriented point of view, where the binding doesn&amp;rsquo;t happen &amp;lsquo;til method dispatch time. You can still see the scars of conflict in languages like C++ and Java though. C++ makes the default method type non-virtual, so you have to say virtual explicitly to get late binding. Java has the notion of final classes, which force calls to the class to be bound at compile time, essentially. I think both of those approaches are big mistakes. PerlÂ 6 will make different mistakes. In PerlÂ 6 all methods are virtual by default, and only the application as a whole can tell the optimizer to finalize classes, presumably only after you know how all the classes are going to be used by all the other modules in the program.&lt;/p&gt;

&lt;h3 id=&#34;single-dispatch-multiple-dispatch&#34;&gt;single dispatch / multiple dispatch&lt;/h3&gt;

&lt;p&gt;In a sense, multiple dispatch is a way to delay binding even longer. You not only have to delay binding &amp;lsquo;til you know the type of the object, but you also have to know the types of all rest of the arguments before you can pick a routine to call. Python and Ruby always do single dispatch, while Dylan does multiple dispatch. Here is one dimension in which PerlÂ 6 &lt;em&gt;forces&lt;/em&gt; the caller to be explicit for clarity. I think it&amp;rsquo;s an important distinction for the programmer to bear in mind, because single dispatch and multiple dispatch are philosophically very different ideas, based on different metaphors.&lt;/p&gt;

&lt;p&gt;With single-dispatch languages, you are basically sending a message to an object, and the object decides what to do with that message. With multiple dispatch languages, however, there is no privileged object. All the objects involved in the call have equal weight. So one way to look at multiple dispatch is that the objects are completely passive. But if the objects aren&amp;rsquo;t deciding how to bind, who is?&lt;/p&gt;

&lt;p&gt;Well, it&amp;rsquo;s sort of a democratic thing. All the routines of a given name get together and hold a political conference. (Well, not really, but this is how the metaphor works.) Each of the routines is a delegate to the convention. All the potential candidates put their names in the hat. Then all the routines vote on who the best candidate is, and the next best, and the next best after that. And eventually the routines themselves decide what the best routine to call is.&lt;/p&gt;

&lt;p&gt;So basically, multiple dispatch is like democracy. It&amp;rsquo;s the worst way to do late binding, except for all the others.&lt;/p&gt;

&lt;p&gt;But I really do think that&amp;rsquo;s true, and likely to become truer as time goes on. I&amp;rsquo;m spending a lot of time on this multiple dispatch issue because I think programming in the large is mutating away from the command-and-control model implicit in single dispatch. I think the field of computation as a whole is moving more toward the kinds of decisions that are better made by swarms of insects or schools of fish, where no single individual is in control, but the swarm as a whole has emergent behaviors that are somehow much smarter than any of the individual components.&lt;/p&gt;

&lt;h3 id=&#34;eager-evaluation-lazy-evaluation&#34;&gt;eager evaluation / lazy evaluation&lt;/h3&gt;

&lt;p&gt;Most languages evaluate eagerly, including PerlÂ 5. Some languages evaluate all expressions as lazily as possible. Haskell is a good example of that. It doesn&amp;rsquo;t compute anything until it is forced to. This has the advantage that you can do lots of cool things with infinite lists without running out of memory. Well, at least until someone asks the program to calculate the whole list. Then you&amp;rsquo;re pretty much hosed in any language, unless you have a real Turing machine.&lt;/p&gt;

&lt;p&gt;So anyway, in PerlÂ 6 we&amp;rsquo;re experimenting with a mixture of eager and lazy. Interestingly, the distinction maps very nicely onto PerlÂ 5&amp;rsquo;s concept of scalar context vs. list context. So in PerlÂ 6, scalar context is eager and list context is lazy. By default, of course. You can always force a scalar to be lazy or a list to be eager if you like. But you can say things like &lt;code&gt;for 1..Inf&lt;/code&gt; as long as your loop exits some other way a little bit before you run into infinity.&lt;/p&gt;

&lt;h3 id=&#34;eager-typology-lazy-typology&#34;&gt;eager typology / lazy typology&lt;/h3&gt;

&lt;p&gt;Usually known as static vs. dynamic, but again there are various positions for the adjustment knob. I rather like the gradual typing approach for a number of reasons. Efficiency is one reason. People usually think of strong typing as a reason, but the main reason to put types into PerlÂ 6 turns out not to be strong typing, but rather multiple dispatch. Remember our political convention metaphor? When the various candidates put their names in the hat, what distinguishes them? Well, each candidate has a political platform. The planks in those political platforms are the types of arguments they want to respond to. We all know politicians are only good at responding to the types of arguments they want to have&amp;hellip;&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s another way in which PerlÂ 6 is slightly more lazy than PerlÂ 5. We still have the notion of contexts, but exactly when the contexts are decided has changed. In PerlÂ 5, the compiler usually knows at compile time which arguments will be in scalar context, and which arguments will be in list context. But PerlÂ 6 delays that decision until method binding time, which is conceptually at run time, not at compile time. This might seem like an odd thing to you, but it actually fixes a great number of things that are suboptimal in the design of PerlÂ 5. Prototypes, for instance. And the need for explicit references. And other annoying little things like that, many of which end up as frequently asked questions.&lt;/p&gt;

&lt;h3 id=&#34;limited-structures-rich-structures&#34;&gt;limited structures / rich structures&lt;/h3&gt;

&lt;p&gt;Awk, Lua, and PHP all limit their composite structures to associative arrays. That has both pluses and minuses, but the fact that awk did it that way is one of the reasons that Perl does it differently, and differentiates ordered arrays from unordered hashes. I just think about them differently, and I think a lot of other people do too.&lt;/p&gt;

&lt;h3 id=&#34;symbolic-wordy&#34;&gt;symbolic / wordy&lt;/h3&gt;

&lt;p&gt;Arguably APL is also a kind of scripting language, largely symbolic. At the other extreme we have languages that eschew punctuation in favor of words, such as AppleScript and COBOL, and to a lesser extent all the Algolish languages that use words to indicate blocks where the C-derived languages use curlies. I prefer a balanced approach here, where symbols and identifiers are each doing what theyre best at. I like it when most of the actual words are those chosen by the programmer to represent the problem at hand. I don&amp;rsquo;t like to see words used for mere syntax. Such syntactic functors merely obscure the real words. That&amp;rsquo;s one thing I learned when I switched from Pascal to C. Braces for blocks. It&amp;rsquo;s just right visually.&lt;/p&gt;

&lt;p&gt;Actually, there are languages that do it even worse than COBOL. I remember one Pascal variant that required your keywords to be capitalized so that they would stand out. No, no, no, no, no! You don&amp;rsquo;t want your functors to stand out. It&amp;rsquo;s shouting the wrong words: IF! foo THEN! bar ELSE! baz END! END! END! END!&lt;/p&gt;

&lt;p&gt;Anyway, in PerlÂ 6 we&amp;rsquo;re raising the standard for where we use punctuation, and where we don&amp;rsquo;t. We&amp;rsquo;re getting rid of some of our punctuation that isn&amp;rsquo;t really pulling its weight, such as parentheses around conditional expressions, and most of the punctuational variables. And we&amp;rsquo;re making all the remaining punctuation work harder. Each symbol has to justify its existence according to Huffman coding.&lt;/p&gt;

&lt;p&gt;Oddly, there&amp;rsquo;s one spot where we&amp;rsquo;re introducing new punctuation. After your sigil you can add a twigil, or secondary sigil. Just as a sigil tells you the basic structure of an object, a twigil tells you that a particular variable has a weird scope. This is basically an idea stolen from Ruby, which uses sigils to indicate weird scoping. But by hiding our twigils after our sigils, we get the best of both worlds, plus an extensible twigil system for weird scopes we haven&amp;rsquo;t thought of yet.&lt;/p&gt;

&lt;p&gt;We think about extensibility a lot. We think about languages we don&amp;rsquo;t know how to think about yet. But leaving spaces in the grammar for new languages is kind of like reserving some of our land for national parks and national forests. Or like an archaeologist not digging up half the archaeological site because we know our descendants will have even better analytical tools than we have.&lt;/p&gt;

&lt;p&gt;Really designing a language for the future involves a great deal of humility. As with science, you have to assume that, over the long term, a great deal of what you think is true will turn out not to be quite the case. On the other hand, if you don&amp;rsquo;t make your best guess now, you&amp;rsquo;re not really doing science either. In retrospect, we know APL had too many strange symbols. But we wouldn&amp;rsquo;t be as sure about that if APL hadn&amp;rsquo;t tried it first.&lt;/p&gt;

&lt;h3 id=&#34;compile-time-run-time&#34;&gt;compile time / run time&lt;/h3&gt;

&lt;p&gt;Many dynamic languages can eval code at run time. Perl also takes it the other direction and runs a lot of code at compile time. This can get messy with operational definitions. You don&amp;rsquo;t want to be doing much file I/O in your &lt;code&gt;BEGIN&lt;/code&gt; blocks, for instance. But that leads us to another distinction:&lt;/p&gt;

&lt;h3 id=&#34;declarational-operational&#34;&gt;declarational / operational&lt;/h3&gt;

&lt;p&gt;Most scripting languages are way over there on the operational side. I thought PerlÂ 5 had an oversimplified object system till I saw Lua. In Lua, an object is just a hash, and there&amp;rsquo;s a bit of syntactic sugar to call a hash element if it happens to contain code. Thats all there is. They don&amp;rsquo;t even have classes. Anything resembling inheritance has to be handled by explicit delegation. That&amp;rsquo;s a choice the designers of Lua made to keep the language very small and embeddable. For them, maybe it&amp;rsquo;s the right choice.&lt;/p&gt;

&lt;p&gt;PerlÂ 5 has always been a bit more declarational than either Python or Ruby. I&amp;rsquo;ve always felt strongly that implicit scoping was just asking for trouble, and that scoped variable declarations should be very easy to recognize visually. Thats why we have &lt;code&gt;my&lt;/code&gt;. It&amp;rsquo;s short because I knew we&amp;rsquo;d use it frequently. Huffman coding. Keep common things short, but not too short. In this case, 0 is too short.&lt;/p&gt;

&lt;p&gt;PerlÂ 6 has more different kinds of scopes, so we&amp;rsquo;ll have more declarators like &lt;code&gt;my&lt;/code&gt; and &lt;code&gt;our&lt;/code&gt;. But appearances can be deceiving. While the language looks more declarative on the surface, we make most of the declarations operationally hookable underneath to retain flexibility. When you declare the type of a variable, for instance, you&amp;rsquo;re really just doing a kind of tie, in PerlÂ 5 terms. The main difference is that you&amp;rsquo;re tying the implementation to the variable at compile time rather than run time, which makes things more efficient, or at least potentially optimizable.&lt;/p&gt;

&lt;h3 id=&#34;immutable-classes-mutable-classes&#34;&gt;immutable classes / mutable classes&lt;/h3&gt;

&lt;p&gt;Classes in Java are closed, which is one of the reasons Java can run pretty fast. In contrast, Ruby&amp;rsquo;s classes are open, which means you can add new things to them at any time. Keeping that option open is perhaps one of the reasons Ruby runs so slow. But that flexibility is also why Ruby has Rails.&lt;/p&gt;

&lt;p&gt;PerlÂ 6 will have an interesting mix of immutable generics and mutable classes here, and interesting policies on who is allowed to close classes when. Classes are never allowed to close or finalize themselves, for instance. Sorry, for some reason I keep talking about PerlÂ 6. It could have something to do with the fact that we&amp;rsquo;ve had to think about all of these dimensions in designing PerlÂ 6.&lt;/p&gt;

&lt;h3 id=&#34;class-based-prototype-based&#34;&gt;class-based / prototype-based&lt;/h3&gt;

&lt;p&gt;Here&amp;rsquo;s another dimension that can open up to allow both approaches. Some of you may be familiar with classless languages like Self or JavaScript. Instead of classes, objects just clone from their ancestors or delegate to other objects. For many kinds of modeling, it&amp;rsquo;s actually closer to the way the real world works. Real organisms just copy their DNA when they reproduce. They don&amp;rsquo;t have some DNA of their own, and an &lt;code&gt;@ISA&lt;/code&gt; array telling you which parent objects contain the rest of their DNA.&lt;/p&gt;

&lt;p&gt;The meta-object protocol for PerlÂ 6 defaults to class-based, but is flexible enough to set up prototype-based objects as well. Some of you have played around with &lt;a href=&#34;https://metacpan.org/pod/Moose&#34;&gt;Moose&lt;/a&gt; in PerlÂ 5. Moose is essentially a prototype of PerlÂ 6&amp;rsquo;s object model. On a semantic level, anyway. The syntax is a little different. Hopefully a little more natural in PerlÂ 6.&lt;/p&gt;

&lt;h3 id=&#34;passive-data-global-consistency-active-data-local-consistency&#34;&gt;passive data, global consistency / active data, local consistency&lt;/h3&gt;

&lt;p&gt;Your view of data and control will vary with how functional or object-oriented your brain is. People just think differently. Some people think mathematically, in terms of provable universal truths. Functional programmers don&amp;rsquo;t much care if they strew implicit computation state throughout the stack and heap, as long as everything &lt;em&gt;looks&lt;/em&gt; pure and free from side-effects.&lt;/p&gt;

&lt;p&gt;Other people think socially, in terms of cooperating entities that each have their own free will. And it&amp;rsquo;s pretty important to them that the state of the computation be stored with each individual object, not off in some heap of continuations somewhere.&lt;/p&gt;

&lt;p&gt;Of course, some of us can&amp;rsquo;t make up our minds whether we&amp;rsquo;d rather emulate the logical Sherlock Holmes or sociable Dr. Watson. Fortunately, scripting is not incompatible with either of these approaches, because both approaches can be made more approachable to normal folk.&lt;/p&gt;

&lt;h3 id=&#34;info-hiding-scoping-attachment&#34;&gt;info hiding / scoping / attachment&lt;/h3&gt;

&lt;p&gt;And finally, if you&amp;rsquo;re designing a computer language, there are a couple bazillion ways to encapsulate data. You have to decide which ones are important. What&amp;rsquo;s the best way to let the programmer achieve separation of concerns?&lt;/p&gt;

&lt;h3 id=&#34;object-class-aspect-closure-module-template-trait&#34;&gt;object / class / aspect / closure / module / template / trait&lt;/h3&gt;

&lt;p&gt;You can use any of these various traditional encapsulation mechanisms.&lt;/p&gt;

&lt;h3 id=&#34;transaction-reaction-dynamic-scope&#34;&gt;transaction / reaction / dynamic scope&lt;/h3&gt;

&lt;p&gt;Or you can isolate information to various time-based domains.&lt;/p&gt;

&lt;h3 id=&#34;process-thread-device-environment&#34;&gt;process / thread / device / environment&lt;/h3&gt;

&lt;p&gt;You can attach info to various OS concepts.&lt;/p&gt;

&lt;h3 id=&#34;screen-window-panel-menu-icon&#34;&gt;screen / window / panel / menu / icon&lt;/h3&gt;

&lt;p&gt;You can hide info various places in your GUI. Yeah, yeah, I know, everything is an object. But some objects are more equal than others.&lt;/p&gt;

&lt;h3 id=&#34;syntactic-scope-semantic-scope-pragmatic-scope&#34;&gt;syntactic scope / semantic scope / pragmatic scope&lt;/h3&gt;

&lt;p&gt;Information can attach to various abstractions of your program, including, bizarrely, lexical scopes. Though if you think about it hard enough, you realize lexical scopes are also a funny kind of dynamic scope, or recursion wouldn&amp;rsquo;t work right. A &lt;code&gt;state&lt;/code&gt; variable is actually more purely lexical than a &lt;code&gt;my&lt;/code&gt; variable, because it&amp;rsquo;s shared by all calls to that lexical scope. But even state variables get cloned with closures. Only global variables can be truly lexical, as long as you refer to them only in a given lexical scope. Go figure.&lt;/p&gt;

&lt;p&gt;So really, most of our scopes are semantic scopes that happen to be attached to a particular syntactic scope.&lt;/p&gt;

&lt;p&gt;You may be wondering what I mean by a &lt;em&gt;pragmatic&lt;/em&gt; scope. That&amp;rsquo;s the scope of what the user of the program is storing in their brain, or in some surrogate for their brain, such as a game cartridge. In a sense, most of the web pages out there on the Internet are part of the pragmatic scope. As is most of the data in databases. The hallmark of the pragmatic scope is that you really don&amp;rsquo;t know the lifetime of the container. It&amp;rsquo;s just out there somewhere, and will eventually be collected by that Great Garbage Collector that collects all information that anyone forgets to remember. The Google cache can only last so long. Eventually we will forget the meaning of every URL. But we must not forget the &lt;em&gt;principle&lt;/em&gt; of the URL. That leads us to our next degree of freedom.&lt;/p&gt;

&lt;h3 id=&#34;use-lingua-perligata&#34;&gt;use Lingua::Perligata;&lt;/h3&gt;

&lt;p&gt;If you allow a language to mutate its own grammar within a lexical scope, how do you keep track of that cleanly? PerlÂ 5 discovered one really bad way to do it, namely source filters, but even so we ended up with Perl dialects such as Perligata and Klingon. What would it be like if we actually did it right?&lt;/p&gt;

&lt;p&gt;Doing it right involves treating the evolution of the language as a pragmatic scope, or as a set of pragmatic scopes. You have to be able to name your dialect, kind of like a URL, so there needs to be a universal root language, and ways of warping that universal root language into whatever dialect you like. This is actually near the heart of the vision for PerlÂ 6. We don&amp;rsquo;t see PerlÂ 6 as a single language, but as the root for a family of related languages. As a family, there are shared cultural values that can be passed back and forth among sibling languages as well as to the descendants.&lt;/p&gt;

&lt;p&gt;I hope you&amp;rsquo;re all scared stiff by all these degrees of freedom. I&amp;rsquo;m sure there are other dimensions that are even scarier.&lt;/p&gt;

&lt;p&gt;But&amp;hellip; I think its a manageable problem. I think its possible to still think of PerlÂ 6 as a scripting language, with easy onramps.&lt;/p&gt;

&lt;p&gt;And the reason I think its manageable is because, for each of these dimensions, it&amp;rsquo;s not just a binary decision, but a knob that can be positioned at design time, compile time, or even run time. For a given dimension X, different scripting languages make different choices, set the knob at different locations.&lt;/p&gt;

&lt;h3 id=&#34;you-can-t-even-think-about-x&#34;&gt;You can&amp;rsquo;t even think about X!&lt;/h3&gt;

&lt;p&gt;There&amp;rsquo;s only one way to do X!
There&amp;rsquo;s more than one way to do X!
There are too many ways to do X!&lt;/p&gt;

&lt;p&gt;You may recognize some slogans in here.&lt;/p&gt;

&lt;h3 id=&#34;curling-up&#34;&gt;Curling Up&lt;/h3&gt;

&lt;p&gt;So I&amp;rsquo;m not suggesting that all scripting languages have to take all these dimensions into account, even if PerlÂ 6 tries to. The scripting paradigm is not any one of these dimensions. According to various theories the universe may be laid out in ten or twenty dimensions, but generally we get by with only about three and a half of those dimensions. The rest are said to be curled up. Maybe we live in a scripting universe.&lt;/p&gt;

&lt;p&gt;Most of the scripting languages we call PerlÂ 6 will have most of these dimensions curled up most of the time. But unlike the real universe, where it takes huge machines to uncurl these dimensions, we&amp;rsquo;ll make the dimensions uncurl just by keeping our declarations straight. Well, we&amp;rsquo;ll try. And where that fails, we&amp;rsquo;ll rely on the culture to keep things straight.&lt;/p&gt;

&lt;p&gt;For example, that&amp;rsquo;s exactly what happened already with PerlÂ 5. We have the declarations, &lt;code&gt;use strict; use warnings;&lt;/code&gt;. But it&amp;rsquo;s the culture that decided to enforce the use of them. So much so that we&amp;rsquo;ve decided that they should be the default for most of PerlÂ 6. It was one of those decisions by the hive. In this case the swarm turned out to be smarter than the language designer. And that&amp;rsquo;s as it should be.&lt;/p&gt;

&lt;h3 id=&#34;the-future&#34;&gt;The Future&lt;/h3&gt;

&lt;p&gt;Well, so what&amp;rsquo;s the future of scripting?&lt;/p&gt;

&lt;p&gt;In my completely unbiased opinion, that would be PerlÂ 6. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Seriously though, it&amp;rsquo;s always safe to predict that the ecological landscape will end up with many small languages and a few dominant ones. Some languages like AppleScript have particular ecological niches and are unlikely to grow out of them. Other languages get used outside their original niche. There will always be the generalists, like crows and mockingbirds, and the specialists, like penguins and dodos. (Well, maybe not always the dodos&amp;hellip;)&lt;/p&gt;

&lt;p&gt;Among the generalists, the conventional wisdom is that the worse-is-better approach is more adaptive. Personally, I get a little tired of the argument: My worse-is-better is better than your worse-is-better because I&amp;rsquo;m better at being worser! Is it really true that the worse-is-better approach always wins? With PerlÂ 6 we&amp;rsquo;re trying to sneak one better-is-better cycle in there and hope to come out ahead before reverting to the tried and true worse-is-better approach. Whether that works, only time will tell.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introducing Mac::Glue</title>
      <link>http://localhost:1313/pub/2004/01/23/macglue.html/</link>
      <pubDate>Fri, 23 Jan 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/01/23/macglue.html/</guid>
      <description>

&lt;p&gt;Thanks to the popularity of Mac OS X, the new iBook, and the PowerBook G4, it&amp;rsquo;s no longer uncool to talk about owning an Apple. Longtime Mac devotees have now been joined by longtime Unix devotees and pretty much anyone who wants computers to be shiny, and speakers at conferences such as the &lt;a href=&#34;http://conferences.oreillynet.com/os2004/&#34;&gt;Open Source Convention&lt;/a&gt; are beginning to get used to looking down over a sea of Apple laptops.&lt;/p&gt;

&lt;p&gt;One of the great features about Apple&amp;rsquo;s Mac OS is its support for flexible inter-process communication (IPC), which Apple calls inter-application communication (IAC). One of the components of IAC is called Apple events, and allows applications to command each other to perform various tasks. On top of the raw Apple events layer, Apple has developed the &lt;strong&gt;Open Scripting Architecture&lt;/strong&gt;, an architecture for scripting languages such as Apple&amp;rsquo;s own AppleScript.&lt;/p&gt;

&lt;p&gt;But this is &lt;code&gt;perl.com&lt;/code&gt;, and we don&amp;rsquo;t need inferior scripting languages! The &lt;code&gt;Mac::Glue&lt;/code&gt; module provides OSA compatibility and allows us to talk to Mac applications with Perl code. Let&amp;rsquo;s take a look at how to script Mac tools at a high level in Perl.&lt;/p&gt;

&lt;h3 id=&#34;the-pre-history-of-mac-glue&#34;&gt;The Pre-History of &lt;code&gt;Mac::Glue&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;In the beginning, there was &lt;code&gt;Mac::AppleEvents&lt;/code&gt;. This module wrapped the raw Apple events API, with its cryptic four-character codes to describe applications and their capabilities, and its collection of awkward constants. You had to find out the four-character identifiers yourself, you had to manage and dispose of memory yourself, but at least it got you talking Apple events. Here&amp;rsquo;s some &lt;code&gt;Mac::AppleEvents&lt;/code&gt; code to open your System Folder in the Finder::&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Mac::AppleEvents;

my $evt = AEBuildAppleEvent(&#39;aevt&#39;, &#39;odoc&#39;, typeApplSignature, 
             &#39;MACS&#39;, kAutoGenerateReturnID, kAnyTransactionID,
             &amp;quot;&#39;----&#39;: obj{want:type(prop), from:&#39;null&#39;(),&amp;quot; .
                &amp;quot;form:prop, seld:type(macs)}&amp;quot;
          );
my $rep = AESend($evt, kAEWaitReply);

AEDisposeDesc($evt);
AEDisposeDesc($rep);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Obviously this isn&amp;rsquo;t putting the computer to its full use; in a high-level language like Perl, we shouldn&amp;rsquo;t have to concern ourselves with clearing up descriptors when they&amp;rsquo;re no longer in use, or providing low-level flags. We just want to send the message to the Finder. So along came &lt;code&gt;Mac::AppleEvents::Simple&lt;/code&gt;, which does more of the work:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Mac::AppleEvents::Simple;
do_event(qw(aevt odoc MACS),
     &amp;quot;&#39;----&#39;: obj{want:type(prop), from:&#39;null&#39;(),&amp;quot; .
     &amp;quot;form:prop, seld:type(macs)}&amp;quot;
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a bit better; at least we&amp;rsquo;re just talking the IAC language now, instead of having to emulate the raw API. But those troublesome identifiers &amp;ndash; &amp;ldquo;aevt&amp;rdquo; for the Finder, &amp;ldquo;odoc&amp;rdquo; to open a document, and &amp;ldquo;MACS&amp;rdquo; for the System folder.&lt;/p&gt;

&lt;p&gt;Maybe we&amp;rsquo;d be better off in AppleScript after all &amp;ndash; the AppleScript code for the same operation looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tell application &amp;quot;Finder&amp;quot; to open folder &amp;quot;System Folder&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And before &lt;code&gt;Mac::Glue&lt;/code&gt; was ported to Mac OS X, this is exactly what we had to do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Mac::AppleScript qw(RunAppleScript);
RunAppleScript(&#39;tell application &amp;quot;Finder&amp;quot; to open folder &amp;quot;System Folder&amp;quot;&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is considerably easier to understand, but it&amp;rsquo;s just not Perl. &lt;code&gt;Mac::Glue&lt;/code&gt; uses the same magic that allows AppleScript to use names instead of identifiers, but wraps it in Perl syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Mac::Glue;
my $finder = Mac::Glue-&amp;gt;new(&#39;Finder&#39;);
$finder-&amp;gt;open( $finder-&amp;gt;prop(&#39;System Folder&#39;) );
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;setting-up-and-creating-glues&#34;&gt;Setting Up and Creating Glues&lt;/h3&gt;

&lt;p&gt;On Mac OS 9, MacPerl comes with &lt;code&gt;Mac::Glue&lt;/code&gt;. However, OS X users will need to install it themselves. &lt;code&gt;Mac::Glue&lt;/code&gt; requires several other CPAN modules to be installed, including the &lt;code&gt;Mac-Carbon&lt;/code&gt; distribution.&lt;/p&gt;

&lt;p&gt;Because this in turn requires the Carbon headers to be available, you need to install the correct Apple developer kits; if you don&amp;rsquo;t have the Developer Tools installed already, you can download them from &lt;a href=&#34;https://connect.apple.com/&#34;&gt;the ADC site&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Once you have the correct headers installed, the best way to get &lt;code&gt;Mac::Glue&lt;/code&gt; up and running is through the CPAN or CPANPLUS modules:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% perl -MCPAN -e &#39;install &amp;quot;Mac::Glue&amp;quot;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This should download and install all the prerequisites and then the &lt;code&gt;Mac::Glue&lt;/code&gt; module itself.&lt;/p&gt;

&lt;p&gt;When it installs itself, &lt;code&gt;Mac::Glue&lt;/code&gt; also creates &amp;ldquo;glue&amp;rdquo; files for the core applications &amp;ndash; Finder, the System Events library, and so on. A glue file is used to describe the resources available to an application and what can be done to the properties that it has.&lt;/p&gt;

&lt;p&gt;If you try to use &lt;code&gt;Mac::Glue&lt;/code&gt; to control an application for which it doesn&amp;rsquo;t currently have a glue file, it will say something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;No application glue for &#39;JEDict&#39; found in 
&#39;/Library/Perl/5.8.1/Mac/Glue/glues&#39; at -e line 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To create glues for additional applications that are not installed by default, you can drop them onto the Mac OS 9 droplet &amp;ldquo;macglue.&amp;rdquo; On Mac OS X, run the &lt;code&gt;gluemac&lt;/code&gt; command.&lt;/p&gt;

&lt;h3 id=&#34;what-s-a-property&#34;&gt;What&amp;rsquo;s a Property?&lt;/h3&gt;

&lt;p&gt;Once you have all your glues set up, you can start scripting Mac applications in Perl. It helps if you already have some knowledge of how AppleScript works before doing this, because sometimes &lt;code&gt;Mac::Glue&lt;/code&gt; doesn&amp;rsquo;t behave the way you expect it to.&lt;/p&gt;

&lt;p&gt;For instance, we want to dump all the active to-do items from iCal. To-dos are associated with calendars, so first we need a list of all the calendars:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Mac::Glue;
my $ical = new Mac::Glue(&amp;quot;iCal&amp;quot;);

my @cals = $ical-&amp;gt;prop(&amp;quot;calendars&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem we face immediately is that &lt;code&gt;$ical-&amp;gt;prop(&amp;quot;calendars&amp;quot;)&lt;/code&gt; doesn&amp;rsquo;t give us the calendars. Instead, it gives us a way to talk about the calendars&amp;rsquo; property. It&amp;rsquo;s an object. To get the value of that property, we call its &lt;code&gt;get&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my @cals = $ical-&amp;gt;prop(&amp;quot;calendars&amp;quot;)-&amp;gt;get;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This returns a list of objects that allow us to talk about individual calendars. We can get their titles like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for my $cal (@cals) {
    my $name = $cal-&amp;gt;prop(&amp;quot;title&amp;quot;)-&amp;gt;get;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now we want to get the to-dos in each calendar that haven&amp;rsquo;t yet been completed or have no completion date:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @todos = grep { !$_-&amp;gt;prop(&amp;quot;completion_date&amp;quot;)-&amp;gt;get }
                       $cal-&amp;gt;prop(&amp;quot;todos&amp;quot;)-&amp;gt;get;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we then store the summary for each of the to-do items in a hash keyed by the calendar name:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $todos{$name} = [ map { $_-&amp;gt;prop(&amp;quot;summary&amp;quot;)-&amp;gt;get } @todos ]
    if @todos;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we can print out the summary of all the outstanding to-do items in each calendar:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for my $cal(keys %todo) {
    print &amp;quot;$cal:\n&amp;quot;;
    print &amp;quot;\t$_\n&amp;quot; for @{$todo{$cal}};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Putting it all together, the code looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Mac::Glue;
my $ical = new Mac::Glue(&amp;quot;iCal&amp;quot;);

my @cals = $ical-&amp;gt;prop(&amp;quot;calendars&amp;quot;)-&amp;gt;get;
for my $cal (@cals) {
    my $name = $cal-&amp;gt;prop(&amp;quot;title&amp;quot;)-&amp;gt;get;
    my @todos = map  { $_-&amp;gt;prop(&amp;quot;summary&amp;quot;)-&amp;gt;get }
                grep { !$_-&amp;gt;prop(&amp;quot;completion_date&amp;quot;)-&amp;gt;get }
                       $cal-&amp;gt;prop(&amp;quot;todos&amp;quot;)-&amp;gt;get;
    $todo{$name} = \@todos if @todos;
}

for my $cal(keys %todo) {
    print &amp;quot;$cal:\n&amp;quot;;
    print &amp;quot;\t$_\n&amp;quot; for @{$todo{$cal}};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The question is, where did we get the property names like &lt;code&gt;summary&lt;/code&gt; and &lt;code&gt;completion_date&lt;/code&gt; from? How did we know that the calendars had &lt;code&gt;titles&lt;/code&gt; but the to-do items had &lt;code&gt;summaries&lt;/code&gt;, and so on?&lt;/p&gt;

&lt;p&gt;There are two answers to this: the first is to use the documentation created when the glue is installed. Typing &lt;code&gt;gluedoc iCal&lt;/code&gt; on Mac OS X or using Shuck on Mac OS 9, you will find the verbs, properties, and objects that the application supports. For instance, under the calendar class, you should see:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This class represents a calendar&lt;/p&gt;

&lt;p&gt;Properties:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    description (wr12/utxt): This is the calendar
description. (read-only)
    inheritance (c@#^/item): All of the properties of the
superclass. (read-only)
    key (wr03/utxt): An unique calendar key (read-only)
    tint (wr04/utxt): The calendar color (read-only)
    title (wr02/utxt): This is the calendar title.
    writable (wr05/bool): If this calendar is writable
(read-only)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Elements:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    event, todo
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;This tells us that we can ask a calendar for its &lt;code&gt;title&lt;/code&gt; property, and also for the &lt;code&gt;events&lt;/code&gt; or &lt;code&gt;todos&lt;/code&gt; contained within it.&lt;/p&gt;

&lt;p&gt;Similarly, when we get the events back, we can look up the &amp;ldquo;event&amp;rdquo; class in the documentation and see what properties are available on it.&lt;/p&gt;

&lt;p&gt;The second, and perhaps easier, way to find out what you can do with an application is to open the AppleScript Script Editor application, select Open Dictionary from the File menu, and choose the application you want to script. Now you can browse a list of the classes and commands associated with the application:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2004_01_23_macglue/glue.jpg&#34; width=&#34;450&#34; height=&#34;343&#34; /&gt;
When you need to know how to translate those back into Perl, you can then consult the glue documentation. It takes a few attempts to get used to the way &lt;code&gt;Mac::Glue&lt;/code&gt; works, but once you&amp;rsquo;ve done that, you&amp;rsquo;ll find that you can translate between the AppleScript documentation and a &lt;code&gt;Mac::Glue&lt;/code&gt; equivalent in your head.&lt;/p&gt;

&lt;h3 id=&#34;some-examples&#34;&gt;Some Examples&lt;/h3&gt;

&lt;p&gt;In a couple of weeks, we&amp;rsquo;ll be presenting a &amp;ldquo;Mac::Glue Hacks&amp;rdquo; article in the spirit of the O&amp;rsquo;Reilly &lt;a href=&#34;http://hacks.oreilly.com&#34;&gt;hacks books&lt;/a&gt; series, with several simple &lt;code&gt;Mac::Glue&lt;/code&gt;-based application scripting tricks to whet your appetite and explore what &lt;code&gt;Mac::Glue&lt;/code&gt; can do. But to get you started, here&amp;rsquo;s a couple we found particularly useful.&lt;/p&gt;

&lt;p&gt;First, iTunes allows you to give a rating to your favorite songs, on the scale of zero to five stars. Actually, internally, this is stored in the iTunes database as a number between 0 and 100. Simon keeps iTunes playing randomly over his extensive music collection, and every time an interesting track comes up, he runs this script:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $itunes = Mac::Glue-&amp;gt;new(&amp;quot;iTunes&amp;quot;);
exit unless $itunes-&amp;gt;prop(&amp;quot;player state&amp;quot;)-&amp;gt;get eq &amp;quot;playing&amp;quot;;

my $rating = $itunes-&amp;gt;prop(&amp;quot;current track&amp;quot;)-&amp;gt;prop(&amp;quot;rating&amp;quot;);
$rating-&amp;gt;set(to =&amp;gt; ($rating-&amp;gt;get + 20))
  if $rating-&amp;gt;get &amp;lt; 81;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As well as getting properties from &lt;code&gt;Mac::Glue&lt;/code&gt;, we can also set them back with the &lt;code&gt;set&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;One more complex example is the &lt;a href=&#34;http://dev.macperl.org/files/scripts/happening&#34;&gt;happening&lt;/a&gt; script Chris uses to publish details of what&amp;rsquo;s going on at his computer. As well as simply reporting the current foremost application, it dispatches based on that application to report more information. For instance, if Safari has the focus, it reports what web page is being looked at; if it&amp;rsquo;s the Terminal, what program is currently being run. It also contacts iTunes to see what song is playing, and if there&amp;rsquo;s nothing playing on a local iTunes, asks likely other computers on the network if they&amp;rsquo;re playing anything.&lt;/p&gt;

&lt;p&gt;Once &lt;code&gt;happening&lt;/code&gt; has discovered what&amp;rsquo;s going on, it checks to see if the iChat status is set to &amp;ldquo;Available,&amp;rdquo; and if so, resets itself it to report this status. Let&amp;rsquo;s break down &lt;code&gt;happening&lt;/code&gt; and see how it accomplishes each of these tasks.&lt;/p&gt;

&lt;p&gt;First, to work out the name of the currently focused application:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $system = get_app(&#39;System Events&#39;) or return;
$app    ||= $system-&amp;gt;prop(name =&amp;gt; item =&amp;gt; 1,
    application_process =&amp;gt; whose(frontmost =&amp;gt; equals =&amp;gt; 1)
);

$app-&amp;gt;get;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;get_app&lt;/code&gt; is just a utility function that memorizes the process of calling &lt;code&gt;Mac::Glue-&amp;gt;new($app_name)&lt;/code&gt;; since loading up the glue file is quite expensive, keeping around application glue objects is a big speed-saving approach.&lt;/p&gt;

&lt;p&gt;The next incantation shows you how natural &lt;code&gt;Mac::Glue&lt;/code&gt; programming can look, but also how much you need to know about how the Apple environment works. We&amp;rsquo;re asking the System Events library to tell us about the application process that matches a certain condition. &lt;code&gt;Mac::Glue&lt;/code&gt; exports the &lt;code&gt;whose&lt;/code&gt; function to create conditions.&lt;/p&gt;

&lt;p&gt;The important thing about this is the fact that we use &lt;code&gt;$app ||= ...&lt;/code&gt;. The construction that we saved in &lt;code&gt;$app&lt;/code&gt; does not give us &amp;ldquo;the name of the front-most application at this moment,&amp;rdquo; but it represents the whole concept of &amp;ldquo;the name of the front-most application.&amp;rdquo; At any time in the future, we can call &lt;code&gt;get&lt;/code&gt; on it, and it will find out and return the name of the front-most application at that time, even if it has changed since the last time you called &lt;code&gt;get&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now that we know what the front-most application is, we can look it up in a hash that contains subroutines returning information specific to that application. For instance, here&amp;rsquo;s the entry for Safari:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Safari =&amp;gt; sub { my ($glue) = @_;
                my $obj = $glue-&amp;gt;prop(url =&amp;gt; document =&amp;gt; 1 =&amp;gt; window =&amp;gt; 1);
                my $url = $obj-&amp;gt;get;
                return URI-&amp;gt;new($url)-&amp;gt;host if $url;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This returns the host part of the URL in the first document in the first window. For &lt;code&gt;ircle&lt;/code&gt;, an IRC client, this code will get the channel and server name for the current connection:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ircle       =&amp;gt; sub { sprintf(&amp;quot;%s:%s&amp;quot;,
               $_[0]-&amp;gt;prop(&#39;currentchannel&#39;)-&amp;gt;get,
               $_[0]-&amp;gt;prop(servername =&amp;gt; connection =&amp;gt;
                   $_[0]-&amp;gt;prop(&#39;currentconnection&#39;)-&amp;gt;get
               )-&amp;gt;get
              )
            },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A decent default action is to return the window title:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;default     =&amp;gt; sub { my($glue) = @_;
                     my $obj = $objs{$glue-&amp;gt;{APPNAME}} ||=
                               $glue-&amp;gt;prop(name =&amp;gt; window =&amp;gt; 1);
                     $obj-&amp;gt;get;
                   },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As before, we cache the concept of &amp;ldquo;the name of the current window&amp;rdquo; and only create it when we don&amp;rsquo;t have one already.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s look at the &amp;ldquo;Now playing in iTunes&amp;rdquo; part:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$state  ||= $itunes-&amp;gt;prop(&#39;player state&#39;);
return unless $state-&amp;gt;get eq &amp;quot;playing&amp;quot;;

$track  ||= $itunes-&amp;gt;prop(&#39;current track&#39;);
%props    = map { $_ =&amp;gt; $track-&amp;gt;prop($_) } qw(name artist)
            unless keys %props;

my %info;
for my $prop (keys %props) {
    $info{$prop} = $props{$prop}-&amp;gt;get;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This first checks to see if iTunes is playing, and returns unless it is. Next, we look for the current track, and get handles to the name and artist properties of that track, as in our previous iTunes example.&lt;/p&gt;

&lt;p&gt;Finally, when we&amp;rsquo;ve set up all the handles we need, we call &lt;code&gt;get&lt;/code&gt; to turn them into real data. This populates &lt;code&gt;%info&lt;/code&gt; with the name and artist of the currently playing track.&lt;/p&gt;

&lt;p&gt;Now that we have the current application name, the extra information, and the current track, we can publish them as the iChat status, with this subroutine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Mac::Apps::Launch qw(IsRunning);

sub ichat {
    my($output) = @_;

    my $ichat = get_app(&#39;iChat&#39;) or return;
    return unless IsRunning($ichat-&amp;gt;{ID});

    $status  ||= $ichat-&amp;gt;prop(&#39;status&#39;);
    return unless $status-&amp;gt;get eq &#39;available&#39;;

    $message ||= $ichat-&amp;gt;prop(&#39;status message&#39;);
    $message-&amp;gt;set(to =&amp;gt; $output);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, we have the &lt;code&gt;IsRunning&lt;/code&gt; subroutine from &lt;code&gt;Mac::AppleEvents::Simple&lt;/code&gt;, which takes the old-style four-character ID of the application we want to ask about. The &lt;code&gt;ID&lt;/code&gt; slot of the glue object will tell us this ID, and so we can immediately give up setting the iChat status if iChat isn&amp;rsquo;t even running. Then we use &lt;code&gt;set&lt;/code&gt; as before to change the status to whatever we want.&lt;/p&gt;

&lt;p&gt;Finally, we mentioned that &lt;code&gt;happening&lt;/code&gt; can also ask other hosts what&amp;rsquo;s playing on their iTunes as well. This is because, if &amp;ldquo;Remote Apple Events&amp;rdquo; is turned on in the Sharing preferences, Macs support passing these Apple events between machines. Of course, this often requires authentication, so when it first contacts a host to send an Event, &lt;code&gt;happening&lt;/code&gt; will pop-up a login box to ask for credentials &amp;ndash; this is all handled internally by the operating system. Here&amp;rsquo;s the code that &lt;code&gt;happening&lt;/code&gt; actually uses:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $found = 0;
if (IsRunning($itunes-&amp;gt;{ID})) {
    $itunes-&amp;gt;ADDRESS;
    $found = 1 if $state-&amp;gt;get eq &#39;playing&#39;;
}

unless ($found) {
    for my $host (@hosts) {
        next unless $hosts{$host} + 60 &amp;lt; time();
        $itunes-&amp;gt;ADDRESS(eppc =&amp;gt; iTunes =&amp;gt; $host);
        $found = 1, last if $state-&amp;gt;get eq &#39;playing&#39;;
        $hosts{$host} = time();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first paragraph checks to see if iTunes is running locally. If so, we&amp;rsquo;re done. If not, we&amp;rsquo;re going to have to ask the hosts specified in the &lt;code&gt;@hosts&lt;/code&gt; array about it. The first and last lines inside the &lt;code&gt;for&lt;/code&gt; loop simple ensure that hosts are only tried every minute at most. The second line in there is the interesting one, though:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$itunes-&amp;gt;ADDRESS(eppc =&amp;gt; iTunes =&amp;gt; $host);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This changes the &lt;code&gt;iTunes&lt;/code&gt; glue handle from being a local one to being one that contacts the &amp;ldquo;iTunes&amp;rdquo; application on host &lt;code&gt;$host&lt;/code&gt; over EPPC, the remote Apple events transport.&lt;/p&gt;

&lt;p&gt;Because &lt;code&gt;$state&lt;/code&gt; is the player status of &lt;code&gt;$itunes&lt;/code&gt;, it will now return the correct status even though &lt;code&gt;$itunes&lt;/code&gt; now refers to an application on a different computer! Similarly, all the handles we have to the artist and name of the current track will correctly refer to &lt;code&gt;$itunes&lt;/code&gt;, no matter which iTunes instance that means.&lt;/p&gt;

&lt;p&gt;We hope you&amp;rsquo;ll join us next time for more &lt;code&gt;Mac::Glue&lt;/code&gt; tips and tricks, as we look at real-life applications of scripting Mac applications in Perl.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Beginners Intro to Perl - Part 4</title>
      <link>http://localhost:1313/pub/2000/12/begperl4.html/</link>
      <pubDate>Wed, 06 Dec 2000 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2000/12/begperl4.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this venerable series is undergoing updates. You might be interested in the newer versions, available at:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2008/04/23/a-beginners-introduction-to-perl-510.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Perl 5.10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2008/05/07/beginners-introduction-to-perl-510-part-2.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Files and Strings with Perl 5.10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://news.oreilly.com/2008/06/a-beginners-introduction-to-pe.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Regular Expressions with Perl 5.10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://broadcast.oreilly.com/2008/09/a-beginners-introduction-to-pe.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Perl Web Programming&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;it-s-cgi-time&#34;&gt;It&amp;rsquo;s CGI time&lt;/h3&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;strong&gt;Beginners Intro to Perl&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;â¢&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/10/begperl1.html&#34;&gt;Part 1 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
â¢&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/11/begperl2.html&#34;&gt;Part 2 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
â¢&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/11/begperl3.html&#34;&gt;Part 3 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
â¢&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/12/begperl5.html&#34;&gt;Part 5 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
â¢&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2001/01/begperl6.html&#34;&gt;Part 6 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;br /&gt;
â¢&lt;a href=&#34;#cgi&#34;&gt;What is CGI?&lt;/a&gt;&lt;br /&gt;
â¢&lt;a href=&#34;#cgi_program&#34;&gt;A Real CGI Program&lt;/a&gt;&lt;br /&gt;
â¢&lt;a href=&#34;#uhoh&#34;&gt;Uh-Oh!&lt;/a&gt;&lt;br /&gt;
â¢&lt;a href=&#34;#second_script&#34;&gt;Our Second Script&lt;/a&gt;&lt;br /&gt;
â¢&lt;a href=&#34;#sorting&#34;&gt;Sorting&lt;/a&gt;&lt;br /&gt;
â¢&lt;a href=&#34;#trust&#34;&gt;Trust No One&lt;/a&gt;&lt;br /&gt;
â¢&lt;a href=&#34;#play_around&#34;&gt;Play Around!&lt;/a&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;So far, we&amp;rsquo;ve talked about Perl as a language for mangling numbers, strings, and files - the original purpose of the language. Now it&amp;rsquo;s time to talk about what Perl does on the Web. In this installment, we&amp;rsquo;re going to talk about CGI programming.&lt;/p&gt;

&lt;h3 id=&#34;span-id-cgi-what-is-cgi-span&#34;&gt;&lt;span id=&#34;cgi&#34;&gt;What is CGI?&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The Web is based on a client-server model: your browser (the client) making requests to a Web server. Most of these are simple requests for documents or images, which the server delivers to the browser for display.&lt;/p&gt;

&lt;p&gt;Of course, sometimes you want the server to do more than just dump the contents of a file. You&amp;rsquo;d like to do something with a server-side program - whether that &amp;ldquo;something&amp;rdquo; is using Web-based e-mail, looking up a phone number in a database or ordering a copy of &lt;em&gt;Evil Geniuses in a Nutshell&lt;/em&gt; for your favorite techie. This means the browser must be able to send information (an e-mail address, a name to look up, shipping information for a book) to the server, and the server must be able to use that information and return the results to the user.&lt;/p&gt;

&lt;p&gt;The standard for communication between a user&amp;rsquo;s Web browser and a server-side program running on the Web server is called &lt;strong&gt;CGI&lt;/strong&gt;, or Common Gateway Interface. It is supported by all popular Web server software. To get the most out of this article, you will need to have a server that supports CGI. This may be a server running on your desktop machine or an account with your ISP (though probably not a free Web-page service). If you don&amp;rsquo;t know whether you have CGI capabilities, ask your ISP or a local sysadmin how to set things up.&lt;/p&gt;

&lt;p&gt;Notice that I haven&amp;rsquo;t described how CGI works; that&amp;rsquo;s because you don&amp;rsquo;t &lt;em&gt;need&lt;/em&gt; to know. There&amp;rsquo;s a standard Perl module called &lt;code&gt;CGI.pm&lt;/code&gt; that will handle the CGI protocol for you. CGI.pm is part of the core Perl distribution, and any properly installed Perl should have it available.&lt;/p&gt;

&lt;p&gt;Telling your CGI program that you want to use the CGI module is as simple as this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use CGI &#39;:standard&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;use CGI &#39;:standard&#39;;&lt;/code&gt; statement tells Perl that you want to use the CGI.pm module in your program. This will load the module and make a set of CGI functions available for your code.&lt;/p&gt;

&lt;h3 id=&#34;span-id-cgi-program-a-real-cgi-program-span&#34;&gt;&lt;span id=&#34;cgi_program&#34;&gt;A Real CGI Program&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s write our first real CGI program. Instead of doing something complex, we&amp;rsquo;ll write something that will simply throw back whatever we throw at it. We&amp;rsquo;ll call this script &lt;code&gt;backatcha.cgi&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/local/bin/perl

use CGI &#39;:standard&#39;;

print header();
print start_html();

for $i (param()) {
    print &amp;quot;&amp;lt;b&amp;gt;&amp;quot;, $i, &amp;quot;&amp;lt;/b&amp;gt;: &amp;quot;, param($i), &amp;quot;&amp;lt;br&amp;gt;\n&amp;quot;;
}

print end_html();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you&amp;rsquo;ve never used HTML, the pair of &amp;lt;b&amp;gt; and &amp;lt;/b&amp;gt; tags mean &amp;ldquo;begin bold&amp;rdquo; and &amp;ldquo;end bold&amp;rdquo;, respectively, and the &amp;lt;br&amp;gt; tag means &amp;ldquo;line break.&amp;rdquo; (A good paper reference to HTML is O&amp;rsquo;Reilly&amp;rsquo;s &lt;em&gt;HTML &amp;amp; XHTML: The Definitive Guide&lt;/em&gt;, and online, I like &lt;a href=&#34;http://www.htmlhelp.com/&#34;&gt;the Web Design Group&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;Install this program on your server and do a test run. (If you don&amp;rsquo;t have a Web server of your own, we&amp;rsquo;ve put a copy online for you &lt;a href=&#34;http://localhost:1313/media/_pub_2000_12_begperl4/backatcha.pl&#34;&gt;here&lt;/a&gt;.) Here&amp;rsquo;s a short list of what you do to install a CGI program:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Make sure the program is placed where your Web server will recognize it as a CGI script. This may be a special &lt;code&gt;cgi-bin&lt;/code&gt; directory or making sure the program&amp;rsquo;s filename ends in &lt;code&gt;.pl&lt;/code&gt; or &lt;code&gt;.cgi&lt;/code&gt;. If you don&amp;rsquo;t know where to place the program, your ISP or sysadmin should.&lt;/li&gt;
&lt;li&gt;Make sure the program can be run by the server. If you are using a Unix system, you may have to give the Web-server user read and execute permission for the program. It&amp;rsquo;s easiest to give these permissions to everybody by using &lt;code&gt;chmod filename 755&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Make a note of the program&amp;rsquo;s URL, which will probably be something like http://&lt;em&gt;server name&lt;/em&gt;/cgi-bin/backatcha.cgi) and go to that URL in your browser. (Take a guess what you should do if you don&amp;rsquo;t know what the URL of the program is. Hint: It involves the words &amp;ldquo;ask,&amp;rdquo; &amp;ldquo;your&amp;rdquo; and &amp;ldquo;ISP.&amp;rdquo;)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If this works, you will see in your browser &amp;hellip; a blank page! Don&amp;rsquo;t worry, this is what is &lt;em&gt;supposed&lt;/em&gt; to happen. The &lt;code&gt;backatcha.cgi&lt;/code&gt; script throws back what you throw at it, and we haven&amp;rsquo;t thrown anything at it yet. We&amp;rsquo;ll give it something to show us in a moment.&lt;/p&gt;

&lt;p&gt;If it &lt;em&gt;didn&amp;rsquo;t&lt;/em&gt; work, you probably saw either an error message or the source code of the script. We&amp;rsquo;ll try to diagnose these problems in the next section.&lt;/p&gt;

&lt;h3 id=&#34;span-id-uhoh-uh-oh-span&#34;&gt;&lt;span id=&#34;uhoh&#34;&gt;Uh-Oh!&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;If you saw an error message, your Web server had a problem running the CGI program. This may be a problem with the program or the file permissions.&lt;/p&gt;

&lt;p&gt;First, are you &lt;em&gt;sure&lt;/em&gt; the program has the correct file permissions? Did you set the file permissions on your program to 755? If not, do it now. (Windows Web servers will have a different way of doing this.) Try it again; if you see a blank page now, you&amp;rsquo;re good.&lt;/p&gt;

&lt;p&gt;Second, are you &lt;em&gt;sure&lt;/em&gt; the program actually works? (Don&amp;rsquo;t worry, it happens to the best of us.) Change the &lt;code&gt;use CGI&lt;/code&gt; line in the program to read:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use CGI &#39;:standard&#39;, &#39;-debug&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now run the program from the command line. You should see the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(offline mode: enter name=value pairs on standard input)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This message indicates that you&amp;rsquo;re &lt;em&gt;testing&lt;/em&gt; the script. You can now press Ctrl-D to tell the script to continue running without telling it any form items.&lt;/p&gt;

&lt;p&gt;If Perl reports any errors in the script, you can fix them now.&lt;/p&gt;

&lt;p&gt;(The &lt;code&gt;-debug&lt;/code&gt; option is incredibly useful. Use it whenever you have problems with a CGI program, and ignore it at your peril.)&lt;/p&gt;

&lt;p&gt;The other common problem is that you&amp;rsquo;re seeing the source code of your program, not the result of running your program. There are two simple problems that can cause this.&lt;/p&gt;

&lt;p&gt;First, are you &lt;em&gt;sure&lt;/em&gt; you&amp;rsquo;re going through your Web server? If you use your browser&amp;rsquo;s &amp;ldquo;load local file&amp;rdquo; option (to look at something like &lt;code&gt;/etc/httpd/cgi-bin/backatcha.cgi&lt;/code&gt; instead of something like &lt;code&gt;http://localhost/cgi-bin/backatcha.cgi&lt;/code&gt;), you aren&amp;rsquo;t even touching the Web server! Your browser is doing what you &amp;ldquo;wanted&amp;rdquo; to do: loading the contents of a local file and displaying them.&lt;/p&gt;

&lt;p&gt;Second, are you &lt;em&gt;sure&lt;/em&gt; the Web server knows it&amp;rsquo;s a CGI program? Most Web server software will have a special way of designating a file as a CGI program, whether it&amp;rsquo;s a special &lt;code&gt;cgi-bin&lt;/code&gt; directory, the &lt;code&gt;.cgi&lt;/code&gt; or &lt;code&gt;.pl&lt;/code&gt; extension on a file, or something else. Unless you live up to these expectations, the Web server will think the program is a text file, and serve up your program&amp;rsquo;s source code in plain-text form. Ask your ISP for help.&lt;/p&gt;

&lt;p&gt;CGI programs are unruly beasts at the best of times; don&amp;rsquo;t worry if it takes a bit of work to make them run properly.&lt;/p&gt;

&lt;h3 id=&#34;making-the-form-talk-back&#34;&gt;Making the Form Talk Back&lt;/h3&gt;

&lt;p&gt;At this point, you should have a working copy of &lt;code&gt;backatcha.cgi&lt;/code&gt; spitting out blank pages from a Web server. Let&amp;rsquo;s make it actually tell us something. Take the following HTML code and put it in a file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;FORM ACTION=&amp;quot;putyourURLhere&amp;quot; METHOD=GET&amp;gt;
    &amp;lt;P&amp;gt;What is your favorite color? &amp;lt;INPUT NAME=&amp;quot;favcolor&amp;quot;&amp;gt;&amp;lt;/P&amp;gt;
&amp;lt;INPUT TYPE=submit VALUE=&amp;quot;Send form&amp;quot;&amp;gt;
lt;/FORM&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Be sure to replace &lt;code&gt;putyourURLhere&lt;/code&gt; with the actual URL of your copy of &lt;code&gt;backatcha.cgi&lt;/code&gt;! If you want, you can use the &lt;a href=&#34;http://localhost:1313/media/_pub_2000_12_begperl4/backatcha.pl&#34;&gt;copy installed here&lt;/a&gt; at Perl.com.&lt;/p&gt;

&lt;p&gt;This is a simple form. It will show a text box where you can enter your favorite color and a &amp;ldquo;submit&amp;rdquo; button that sends your information to the server. Load this form in your browser and submit a favorite color. You should see this returned from the server:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;favcolor: green
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;cgi-functions&#34;&gt;CGI functions&lt;/h3&gt;

&lt;p&gt;The CGI.pm module loads several special CGI functions for you. What are these functions?&lt;/p&gt;

&lt;p&gt;The first one, &lt;code&gt;header()&lt;/code&gt;, is used to output any necessary HTTP headers before the script can display HTML output. Try taking this line out; you&amp;rsquo;ll get an error from the Web server when you try to run it. This is &lt;em&gt;another&lt;/em&gt; common source of bugs!&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;start_html()&lt;/code&gt; function is there for convenience. It returns a simple HTML header for you. You can pass parameters to it by using a hash, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print $cgi-&amp;gt;start_html( -title =&amp;gt; &amp;quot;My document&amp;quot; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(The &lt;code&gt;end_html()&lt;/code&gt; method is similar, but outputs the footers for your page.)&lt;/p&gt;

&lt;p&gt;Finally, the most important CGI function is &lt;code&gt;param()&lt;/code&gt;. Call it with the name of a form item, and a list of all the values of that form item will be returned. (If you ask for a scalar, you&amp;rsquo;ll only get the first value, no matter how many there are in the list.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$yourname = param(&amp;quot;firstname&amp;quot;);
print &amp;quot;&amp;lt;P&amp;gt;Hi, $yourname!&amp;lt;/P&amp;gt;\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you call &lt;code&gt;param()&lt;/code&gt; without giving it the name of a form item, it will return a list of &lt;em&gt;all&lt;/em&gt; the form items that are available. This form of &lt;code&gt;param()&lt;/code&gt; is the core of our backatcha script:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for $i (param()) {
    print &amp;quot;&amp;lt;b&amp;gt;$i&amp;lt;/b&amp;gt;: &amp;quot;, param($i), &amp;quot;&amp;lt;br&amp;gt;\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remember, a single form item can have more than one value. You might encounter code like this on the Web site of a pizza place that takes orders over the Web:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;P&amp;gt;Pick your toppings!&amp;lt;BR&amp;gt;
       &amp;lt;INPUT TYPE=checkbox NAME=top VALUE=pepperoni&amp;gt; Pepperoni &amp;lt;BR&amp;gt;
       &amp;lt;INPUT TYPE=checkbox NAME=top VALUE=mushrooms&amp;gt; Mushrooms &amp;lt;BR&amp;gt;
       &amp;lt;INPUT TYPE=checkbox NAME=top VALUE=ham&amp;gt; Ham &amp;lt;BR&amp;gt;
    &amp;lt;/P&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Someone who wants all three toppings would submit a form where the form item &lt;code&gt;top&lt;/code&gt; has three values: &amp;ldquo;pepperoni,&amp;rdquo; &amp;ldquo;mushrooms&amp;rdquo; and &amp;ldquo;ham.&amp;rdquo; The server-side code might include this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print &amp;quot;&amp;lt;P&amp;gt;You asked for the following pizza toppings: &amp;quot;;
    @top = param(&amp;quot;top&amp;quot;);
    for $i (@top) {
        print $i, &amp;quot;. &amp;quot;;
    }
    print &amp;quot;&amp;lt;/P&amp;gt;&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, here&amp;rsquo;s something to watch out for. Take another look at the pizza-topping HTML code. Try pasting that little fragment into the backatcha form, just above the &lt;code&gt;&amp;lt;INPUT TYPE=submit...&amp;gt;&lt;/code&gt; tag. Enter a favorite color, and check all three toppings. You&amp;rsquo;ll see this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    favcolor: burnt sienna
    top: pepperonimushroomsham
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Why did this happens? When you call &lt;code&gt;param(&#39;name&#39;)&lt;/code&gt;, you get back a &lt;em&gt;list&lt;/em&gt; of all of the values for that form item. This could be considered a bug in the &lt;code&gt;backatcha.cgi&lt;/code&gt; script, but it&amp;rsquo;s easily fixed - use &lt;code&gt;join()&lt;/code&gt; to separate the item values:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print &amp;quot;&amp;lt;b&amp;gt;$i&amp;lt;/b&amp;gt;: &amp;quot;, join(&#39;, &#39;, param($i)), &amp;quot;&amp;lt;br&amp;gt;\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or call C&amp;lt;param()&amp;gt; in a scalar context first to get only the first value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $j = param($i);
    print &amp;quot;&amp;lt;b&amp;gt;$i&amp;lt;/b&amp;gt;: $j
\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Always keep in mind that form items can have more than one value!&lt;/p&gt;

&lt;h3 id=&#34;span-id-second-script-our-second-script-span&#34;&gt;&lt;span id=&#34;second_script&#34;&gt;Our Second Script&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;So now we know how to build a CGI program, and we&amp;rsquo;ve seen a simple example. Let&amp;rsquo;s write something useful. In the last article, we wrote a pretty good HTTP log analyzer. Why not Web-enable it? This will allow you to look at your usage figures from anywhere you can get to a browser.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2000_12_begperl4/httpreport.pl&#34;&gt;Download the source code for the HTTP log analyzer&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;First, let&amp;rsquo;s decide what we want to do with our analyzer. Instead of showing all of the reports we generate at once, we&amp;rsquo;ll show only those the user selects. Second, we&amp;rsquo;ll let the user choose whether each report shows the entire list of items, or the top 10, 20 or 50 sorted by access count.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll use a form such as this for our user interface:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;FORM ACTION=&amp;quot;/cgi-bin/http-report.pl&amp;quot; METHOD=POST&amp;gt;
        &amp;lt;P&amp;gt;Select the reports you want to see:&amp;lt;/P&amp;gt;

 &amp;lt;P&amp;gt;&amp;lt;INPUT TYPE=checkbox NAME=report VALUE=url&amp;gt;URLs requested&amp;lt;BR&amp;gt;
    &amp;lt;INPUT TYPE=checkbox NAME=report VALUE=status&amp;gt;Status codes&amp;lt;BR&amp;gt;
    &amp;lt;INPUT TYPE=checkbox NAME=report VALUE=hour&amp;gt;Requests by hour&amp;lt;BR&amp;gt;
    &amp;lt;INPUT TYPE=checkbox NAME=report VALUE=type&amp;gt;File types
 &amp;lt;/P&amp;gt;

 &amp;lt;P&amp;gt;&amp;lt;SELECT NAME=&amp;quot;number&amp;quot;&amp;gt;
     &amp;lt;OPTION VALUE=&amp;quot;ALL&amp;quot;&amp;gt;Show all
     &amp;lt;OPTION VALUE=&amp;quot;10&amp;quot;&amp;gt;Show top 10
     &amp;lt;OPTION VALUE=&amp;quot;20&amp;quot;&amp;gt;Show top 20
     &amp;lt;OPTION VALUE=&amp;quot;50&amp;quot;&amp;gt;Show top 50
 &amp;lt;/SELECT&amp;gt;&amp;lt;/P&amp;gt;

 &amp;lt;INPUT TYPE=submit VALUE=&amp;quot;Show report&amp;quot;&amp;gt;
    &amp;lt;/FORM&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Remember that you may need to change the URL!)&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re sending two different types of form item in this HTML page. One is a series of checkbox widgets, which set values for the form item &lt;code&gt;report&lt;/code&gt;. The other is a single drop-down list which will assign a single value to &lt;code&gt;number&lt;/code&gt;: either ALL, 10, 20 or 50.&lt;/p&gt;

&lt;p&gt;Take a look at the original HTTP log analyzer. We&amp;rsquo;ll start with two simple changes. First, the original program gets the filename of the usage log from a command-line argument:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      # We will use a command line argument to determine the log filename.
      $logfile = $ARGV[0];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We obviously can&amp;rsquo;t do that now, since the Web server won&amp;rsquo;t allow us to enter a command line for our CGI program! Instead, we&amp;rsquo;ll hard-code the value of &lt;code&gt;$logfile&lt;/code&gt;. I&amp;rsquo;ll use &amp;ldquo;/var/log/httpd/access_log&amp;rdquo; as a sample value.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      $logfile = &amp;quot;/var/log/httpd/access_log&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Second, we must make sure that we output all the necessary headers to our Web server before we print anything else:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      print header();
      print start_html( -title =&amp;gt; &amp;quot;HTTP Log report&amp;quot; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now look at the &lt;code&gt;report()&lt;/code&gt; sub from our original program. It has one problem, relative to our new goals: It outputs all the reports instead of only the ones we&amp;rsquo;ve selected. We&amp;rsquo;ll rewrite &lt;code&gt;report()&lt;/code&gt; so that it will cycle through all the values of the &lt;code&gt;report&lt;/code&gt; form item and show the appropriate report for each.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; sub report {
    for $i (param(&#39;report&#39;)) {
 if ($i eq &#39;url&#39;) {
     report_section(&amp;quot;URL requests&amp;quot;, %url_requests);
 } elsif ($i eq &#39;status&#39;) {
     report_section(&amp;quot;Status code requests&amp;quot;, %status_requests);
 } elsif ($i eq &#39;hour&#39;) {
     report_section(&amp;quot;Requests by hour&amp;quot;, %hour_requests);
 } elsif ($i eq &#39;type&#39;) {
     report_section(&amp;quot;Requests by file type&amp;quot;, %type_requests);
 }
    }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we rewrite the &lt;code&gt;report_section()&lt;/code&gt; sub to output HTML instead of plain text. (We&amp;rsquo;ll discuss the new way we&amp;rsquo;re using &lt;code&gt;sort&lt;/code&gt; in a moment.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub report_section {
 my ($header, %type) = @_;
 my (@type_keys);

 # Are we sorting by the KEY, or by the NUMBER of accesses?
 if (param(&#39;number&#39;) ne &#39;ALL&#39;) {
     @type_keys = sort { $type{$b} &amp;lt;=&amp;gt; $type{$a}; } keys %type;

     # Chop the list if we have too many results
     if ($#type_keys &amp;gt; param(&#39;number&#39;) - 1) {
         $#type_keys = param(&#39;number&#39;) - 1;
     }
 } else {
     @type_keys = sort keys %type;
 }

 # Begin a HTML table
 print &amp;quot;&amp;lt;TABLE&amp;gt;\n&amp;quot;;

 # Print a table row containing a header for the table
 print &amp;quot;&amp;lt;TR&amp;gt;&amp;lt;TH COLSPAN=2&amp;gt;&amp;quot;, $header, &amp;quot;&amp;lt;/TH&amp;gt;&amp;lt;/TR&amp;gt;\n&amp;quot;;

 # Print a table row containing each item and its value
 for $i (@type_keys) {
     print &amp;quot;&amp;lt;TR&amp;gt;&amp;lt;TD&amp;gt;&amp;quot;, $i, &amp;quot;&amp;lt;/TD&amp;gt;&amp;lt;TD&amp;gt;&amp;quot;, $type{$i}, &amp;quot;&amp;lt;/TD&amp;gt;&amp;lt;/TR&amp;gt;\n&amp;quot;;
 }

 # Finish the table
 print &amp;quot;&amp;lt;/TABLE&amp;gt;\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-sorting-sorting-span&#34;&gt;&lt;span id=&#34;sorting&#34;&gt;Sorting&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Perl allows you to sort lists with the &lt;code&gt;sort&lt;/code&gt; keyword. By default, the sort will happen alphanumerically: numbers before letters, uppercase before lowercase. This is sufficient 99 percent of the time. The other 1 percent of the time, you can write a custom sorting routine for Perl to use.&lt;/p&gt;

&lt;p&gt;This sorting routine is just like a small sub. In it, you compare two special variables, &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt;, and return one of three values depending on how you want them to show up in the list. Returning -1 means &amp;ldquo;&lt;code&gt;$a&lt;/code&gt; should come before &lt;code&gt;$b&lt;/code&gt; in the sorted list,&amp;rdquo; 1 means &amp;ldquo;&lt;code&gt;$b&lt;/code&gt; should come before &lt;code&gt;$a&lt;/code&gt; in the sorted list&amp;rdquo; and 0 means &amp;ldquo;they&amp;rsquo;re equal, so I don&amp;rsquo;t care which comes first.&amp;rdquo; Perl will run this routine to compare each pair of items in your list and produce the sorted result.&lt;/p&gt;

&lt;p&gt;For example, if you have a hash called &lt;code&gt;%type&lt;/code&gt;, here&amp;rsquo;s how you might sort its keys in descending order of their &lt;em&gt;values&lt;/em&gt; in the hash.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sort {
        if ($type{$b} &amp;gt; $type{$a}) { return 1; }
 if ($type{$b} &amp;lt; $type{$a}) { return -1; }
 return 0;
    } keys %type;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, numeric sorting happens so often, Perl gives you a convenient shorthand for it: the &amp;lt;=&amp;gt; operator. This operator will perform the above comparison between two values for you and return the appropriate value. That means we can rewrite that test as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sort { $type{$b} &amp;lt;=&amp;gt; $type{$a}; } keys %type
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(And this, in fact, is what we use in our log analyzer.)&lt;/p&gt;

&lt;p&gt;You can also compare strings with &lt;code&gt;sort&lt;/code&gt;. The &lt;code&gt;lt&lt;/code&gt; and &lt;code&gt;gt&lt;/code&gt; operators are the string equivalents of &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;cmp&lt;/code&gt; will perform the same test as &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt;. (Remember, string comparisons will sort numbers before letters and uppercase before lowercase.)&lt;/p&gt;

&lt;p&gt;For example, you have a list of names and phone numbers in the format &amp;ldquo;John Doe 555-1212.&amp;rdquo; You want to sort this list by the person&amp;rsquo;s last name, and sort by first name when the last names are the same. This is a job made for &lt;code&gt;cmp&lt;/code&gt;!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     @sorted = sort {
         ($c) = ($a =~ / (\w+)/);
  ($d) = ($b =~ / (\w+)/);
  if ($c eq $d) {   # Last names are the same, sort on first name
      ($c) = ($a =~ /^(\w+)/);
      ($d) = ($b =~ /^(\w+)/);
      return $c cmp $d;
  } else {
      return $c cmp $d;
  }
     } @phone_numbers;
     for $i (@sorted) { print $i, &amp;quot;\n&amp;quot;; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-trust-trust-no-one-span&#34;&gt;&lt;span id=&#34;trust&#34;&gt;Trust No One&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Now that we know how CGI programs can do what you want, let&amp;rsquo;s make sure they won&amp;rsquo;t do what you &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; want. This is harder than it looks, because you can&amp;rsquo;t trust anyone to do what you expect.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a simple example: You want to make sure the HTTP log analyzer will never show more than 50 items per report, because it takes too long to send larger reports to the user. The easy thing to do would be to eliminate the &amp;ldquo;ALL&amp;rdquo; line from our HTML form, so that the only remaining options are 10, 20 and 50. It would be very easy - and wrong.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2000_12_begperl4/httpsecured.pl&#34;&gt;Download the source code for the HTTP analyzer with security enhancements&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We saw that you can modify HTML forms when we pasted the pizza-topping sample code into our backatcha page. You can also use the URL to pass form items to a script - try going to &lt;code&gt;http://www.perl.com/2000/12/backatcha.cgi?itemsource=URL&amp;amp;typedby=you&lt;/code&gt; in your browser. Obviously, if someone can do this with the backatcha script, they can also do it with your log analyzer and stick any value for &lt;code&gt;number&lt;/code&gt; in that they want: &amp;ldquo;ALL&amp;rdquo; or &amp;ldquo;25000&amp;rdquo;, or &amp;ldquo;four score and seven years ago.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Your form doesn&amp;rsquo;t allow this, you say. Who cares? People will write custom HTML forms to exploit weaknesses in your programs, or will just pass bad form items to your script directly. You cannot trust anything users or their browsers tell you.&lt;/p&gt;

&lt;p&gt;You eliminate these problems by knowing what you expect from the user, and &lt;em&gt;disallowing&lt;/em&gt; everything else. Whatever you do not expressly permit is totally forbidden. Secure CGI programs consider everything guilty until it is &lt;em&gt;made&lt;/em&gt; innocent.&lt;/p&gt;

&lt;p&gt;For example, we want to limit the size of reports from our HTTP log analyzer. We decide that means the &lt;code&gt;number&lt;/code&gt; form item must have a value that is between 10 and 50. We&amp;rsquo;ll verify it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Make sure that the &amp;quot;number&amp;quot; form item has a reasonable value
    ($number) = (param(&#39;number&#39;) =~ /(\d+)/);
    if ($number &amp;lt; 10) {
        $number = 10;
    } elsif ($number &amp;gt; 50) {
        $number = 50;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, we also have to change the &lt;code&gt;report_section()&lt;/code&gt; sub so it uses the &lt;code&gt;$number&lt;/code&gt; variable. Now, whether your user tries to tell your log analyzer that the value of &lt;code&gt;number&lt;/code&gt; is &amp;ldquo;10,&amp;rdquo; &amp;ldquo;200,&amp;rdquo; &amp;ldquo;432023,&amp;rdquo; &amp;ldquo;ALL&amp;rdquo; or &amp;ldquo;redrum,&amp;rdquo; your program will restrict it to a reasonable value.&lt;/p&gt;

&lt;p&gt;We don&amp;rsquo;t need to do anything with &lt;code&gt;report&lt;/code&gt;, because we only act when one of its values is something we expected. If the user tries to enter something other than our expressly permitted values (&amp;ldquo;url,&amp;rdquo; &amp;ldquo;status,&amp;rdquo; &amp;ldquo;hour&amp;rdquo; or &amp;ldquo;type&amp;rdquo;), we just ignore it.&lt;/p&gt;

&lt;p&gt;Use this sort of logic everywhere you know what the user &lt;em&gt;should&lt;/em&gt; enter. You might use &lt;code&gt;s/\D//g&lt;/code&gt; to remove non-numeric characters from items that should be numbers (and then test to make sure what&amp;rsquo;s left is within your range of allowable numbers!), or &lt;code&gt;/^\w+$/&lt;/code&gt; to make sure that the user entered a single word.&lt;/p&gt;

&lt;p&gt;All of this has two significant benefits. First, you simplify your error-handling code, because you make sure as early in your program as possible that you&amp;rsquo;re working with valid data. Second, you increase security by reducing the number of &amp;ldquo;impossible&amp;rdquo; values that might help an attacker compromise your system or mess with other users of your Web server.&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t just take my word for it, though. The &lt;a href=&#34;http://www.w3.org/Security/Faq/&#34;&gt;CGI Security FAQ&lt;/a&gt; has more information about safe CGI programming in Perl than you ever thought could possibly exist, including a section listing some &lt;a href=&#34;http://www.w3.org/Security/Faq/wwwsf4.html#Q35&#34;&gt;security holes&lt;/a&gt; in real CGI programs.&lt;/p&gt;

&lt;h3 id=&#34;span-id-play-around-play-around-span&#34;&gt;&lt;span id=&#34;play_around&#34;&gt;Play Around!&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;You should now know enough about CGI programming to write a useful Web application. (Oh, and you learned a little bit more about sorting and comparison.)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Write the quintessential CGI program: a guestbook. Users enter their name, e-mail address and a short message, which is appended to an HTML file for all to see.&lt;/p&gt;

&lt;p&gt;Be careful! Never trust the user! A good beginning precaution is to &lt;em&gt;disallow all HTML&lt;/em&gt; by either removing &amp;lt; and &amp;gt; characters from all of the user&amp;rsquo;s information or replacing them with the &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; character entities.&lt;/p&gt;

&lt;p&gt;Use &lt;code&gt;substr()&lt;/code&gt;, too, to cut anything the user enters down to a reasonable size. Asking for a &amp;ldquo;short&amp;rdquo; message will do nothing to prevent the user dumping a 500k file into the message field!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Write a program that plays tic-tac-toe against the user. Be sure that the computer AI is in a sub so it can be easily upgraded. (You&amp;rsquo;ll probably need to study HTML a bit to see how to output the tic-tac-toe board.)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>

