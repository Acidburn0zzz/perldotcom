<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Only Module Version on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/only-module-version/</link>
    <description>Recent content in Only Module Version on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 18 Mar 2003 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/only-module-version/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>For Perl Programmers : only</title>
      <link>http://localhost:1313/pub/2003/03/18/only.html/</link>
      <pubDate>Tue, 18 Mar 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/03/18/only.html/</guid>
      <description>

&lt;p&gt;Have you ever wished that you could have more than one version of a Perl module installed on your system, and that you could easily tell Perl exactly which one you wanted to load? Perhaps you have some legacy programs that only run with older versions of certain modules, while the rest of your system is coded to the more-modern versions of the same module. Or maybe you administer a multiuser system, where your various users request different module versions.&lt;/p&gt;

&lt;p&gt;Perl&amp;rsquo;s built-in mechanism for module version control is very rudimentary. Basically, you can say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use XML::Parser 2.27;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;use&lt;/code&gt; command will load XML::Parser and then proceed to &lt;code&gt;die&lt;/code&gt; unless &lt;code&gt;$XML::Parser::VERSION&lt;/code&gt; is greater than or equal to 2.27. There is no way to ask for one specific version or a range of versions. Most of the time this is OK. It&amp;rsquo;s OK if you assume that successive versions of modules always improve, never drop functionality and are fully backward compatible. Unfortunately, in real life, this isn&amp;rsquo;t always true.&lt;/p&gt;

&lt;p&gt;Take Lincoln Stein&amp;rsquo;s excellent &lt;code&gt;GD&lt;/code&gt; module for example. &lt;code&gt;GD.pm&lt;/code&gt; is a toolset for creating graphic images from Perl programs. Up to version 1.19, &lt;code&gt;GD&lt;/code&gt; supported the GIF format. Due to GIF&amp;rsquo;s licensing restrictions, the author was forced to retract support. GIF support was replaced by the PNG format, and later JPEG support was added. If you are required to use &lt;code&gt;GD&lt;/code&gt; for both GIF and PNG format types, then you need to do some monkeying around with library paths to get it to work.&lt;/p&gt;

&lt;p&gt;With big projects in restrictive environments, dealing with module versioning issues can quickly become a tangled briar patch. When your needs for using specific modules become too thorny, you need a sharper chainsaw. This article describes such a saw.&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-only-way-the-only-way-span&#34;&gt;&lt;span id=&#34;the_only_way&#34;&gt;The Only Way&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Introducing &lt;code&gt;only.pm&lt;/code&gt;! &lt;code&gt;only&lt;/code&gt; is a full featured system for installing and loading multiple versions of Perl modules.&lt;/p&gt;

&lt;p&gt;To make sure that your program loads version &lt;code&gt;1.19&lt;/code&gt; of &lt;code&gt;GD&lt;/code&gt;, simply say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use only GD =&amp;gt; 1.19;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you know that any of the &lt;code&gt;GD&lt;/code&gt; versions from 2.01 up to 2.06 are OK, then say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use only GD =&amp;gt; &#39;2.01-2.06&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you also want to import &lt;code&gt;GD::foo&lt;/code&gt; and &lt;code&gt;GD::bar&lt;/code&gt;, then:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use only GD =&amp;gt; &#39;2.01-2.06&#39;, qw(foo bar);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;only&lt;/code&gt; acts as an extension to Perl&amp;rsquo;s &lt;code&gt;use&lt;/code&gt; command. It intercepts the parameters that you would normally pass to &lt;code&gt;use&lt;/code&gt; along with an acceptable version range. It takes all of that information and does a &amp;ldquo;heap of bit-wrangling&amp;rdquo; to make sure that you get the version of the module you wanted. In every other respect, it tries to act like a regular &lt;code&gt;use&lt;/code&gt; statement.&lt;/p&gt;

&lt;h3 id=&#34;span-id-easy-installations-easy-installations-span&#34;&gt;&lt;span id=&#34;easy_installations&#34;&gt;Easy Installations&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;How do you go about installing several versions of Perl modules? Perl is really only designed to support the installation of a single module version. Whenever you install a new version of a module, it simply overwrites the older version. This is known as upgrading. Usually that&amp;rsquo;s what you want, but in the context of &lt;code&gt;only&lt;/code&gt;, you actually want to have multiple versions installed simultaneously.&lt;/p&gt;

&lt;p&gt;Advanced Perl programmers know that is possible to install modules into different directories. You can supply a &lt;code&gt;PREFIX=&lt;/code&gt; parameter to the &lt;code&gt;make install&lt;/code&gt; process. But then you have to remember where you installed the module, and manually adjust &lt;code&gt;@INC&lt;/code&gt; to have the right sequence of paths. That&amp;rsquo;s just no fun.&lt;/p&gt;

&lt;p&gt;Fortunately, &lt;code&gt;only&lt;/code&gt; makes it extremely simple to install multiple versions. To start with, just go about building your module in the usual way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    tar xvzf Cat-Fancy-0.09.tar.gz
    cd Cat-Fancy-0.09
    perl Makefile.PL
    make test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Normally, the next step is &lt;code&gt;make install&lt;/code&gt;. But if you want to store version &lt;code&gt;0.09&lt;/code&gt; separate from any other version of &lt;code&gt;Cat::Fancy&lt;/code&gt;, do this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    perl -Monly=install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This actually does the same procedure as &lt;code&gt;make install&lt;/code&gt; would except that it automatically determines a safe place to stick your module; one that &lt;code&gt;only.pm&lt;/code&gt; can find when you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use only Cat::Fancy =&amp;gt; 0.09;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: If you need authorized access to install modules on your system, then you can do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sudo perl -Monly=install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But &lt;em&gt;be careful&lt;/em&gt;. The &lt;code&gt;perl&lt;/code&gt; used by &lt;code&gt;sudo&lt;/code&gt; may not be the same &lt;code&gt;perl&lt;/code&gt; as the one used by &lt;code&gt;make&lt;/code&gt;. If this is the case, then you&amp;rsquo;ll need to specify the full path to &lt;code&gt;perl&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;span-id-where-is-my-only-module-where-is-my-only-module-span&#34;&gt;&lt;span id=&#34;where_is_my_only_module&#34;&gt;Where Is My Only Module?&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;You may wonder, &amp;ldquo;Where exactly do these modules get installed and will they conflict with my existing modules?&amp;rdquo;. The short answer is, &amp;ldquo;They get installed exactly where you told them to!&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;When you install the &lt;code&gt;only&lt;/code&gt; module, you are asked to select a base directory where &lt;code&gt;only::install&lt;/code&gt; can install modules. The default value is a modification of your Perl&amp;rsquo;s &lt;code&gt;sitelib&lt;/code&gt; directory. For instance, if your &lt;code&gt;sitelib&lt;/code&gt; was:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /usr/local/perl580/lib/sitelib/5.8.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then &lt;code&gt;only.pm&lt;/code&gt; would default to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /usr/local/perl580/lib/version/5.8.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Even though this is the default, you are prompted to select any directory you want. Your choice is saved permanently in &lt;code&gt;only::config&lt;/code&gt;. The constant &lt;code&gt;only::config::versionlib&lt;/code&gt;, becomes the base directory where &lt;code&gt;only&lt;/code&gt; will install and search for versioned modules.&lt;/p&gt;

&lt;p&gt;If you really need to, then you can override this directory as well. For installation, you would say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    perl -Monly=install - versionlib=/home/ingy/modules
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;versionlib&lt;/code&gt; is just the base directory. &lt;code&gt;only&lt;/code&gt; separates various module versions by sticking them into a subdirectory named after the version. So &lt;code&gt;Cat::Fancy&lt;/code&gt; would be installed as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /usr/local/perl580/lib/version/5.8.0/0.09/Cat/Fancy.pm
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-module-build-module-build-span&#34;&gt;&lt;span id=&#34;module::build&#34;&gt;Module::Build&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Many new Perl modules are using &lt;code&gt;Module::Build&lt;/code&gt; for their build process, instead of the age-old &lt;code&gt;Makefile.PL&lt;/code&gt; and &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt;. &lt;code&gt;Module::Build&lt;/code&gt; is a wonderfully organized and extensible replacement for its stalwart yet terribly crufty predecessor.&lt;/p&gt;

&lt;p&gt;One of the side benefits of modules distributions that have &lt;code&gt;Module::Build&lt;/code&gt; is that you can do version-specific installations natively by saying:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    perl Build.PL
    ./Build versioninstall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although this is just a pass-through call to &lt;code&gt;only::install&lt;/code&gt;, it does not suffer from the aforementioned &amp;ldquo;sudo&amp;rdquo; problem.&lt;/p&gt;

&lt;h3 id=&#34;span-id-only-the-facts-only-the-facts-span&#34;&gt;&lt;span id=&#34;only_the::facts&#34;&gt;only The::Facts&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Back to &lt;code&gt;only.pm&lt;/code&gt;. In this section, I&amp;rsquo;ll discuss all the gory details of the &lt;code&gt;use only&lt;/code&gt; syntax. It really isn&amp;rsquo;t that bad. The basic form is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use only MODULE =&amp;gt; CONDITION;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where MODULE is a module name, and CONDITION is either a simple version number or a more complex version specification. More on version conditions in a moment. If you have arguments to pass to the module, then simply tack them on to the end:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use only MODULE =&amp;gt; CONDITION, ARGUMENTS;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;only&lt;/code&gt; even accounts for situations where different versions need different arguments. You match up the conditions and arguments as a set of anonymous arrays:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use only MODULE =&amp;gt;
        [ CONDITION1, ARGUMENTS1 ],
        ...,
        [ CONDITION7, ARGUMENTS7 ];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, there are some special options that you can pass to &lt;code&gt;only&lt;/code&gt; to tell it how to behave. This is accomplished syntactically by passing an anonymous hash of option/value pairs. Put the options hash directly after &lt;code&gt;use only&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use only { OPTION =&amp;gt; VALUE},
        MODULE =&amp;gt; CONDITION;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to set the options globally (for all subsequent &lt;code&gt;only&lt;/code&gt; interaction), then just specify the options without any other arguments. For example, to override the &lt;code&gt;versionlib&lt;/code&gt; option for all &lt;code&gt;use only ...&lt;/code&gt; statements, say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use only { versionlib =&amp;gt; &#39;/home/ingy/modules&#39; };
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-hazardous-conditions-hazardous-conditions-span&#34;&gt;&lt;span id=&#34;hazardous_conditions&#34;&gt;Hazardous Conditions&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Even though a &amp;ldquo;version condition&amp;rdquo; can be as simple as a single version number like &amp;lsquo;0.42&amp;rsquo;, &lt;code&gt;only&lt;/code&gt; offers flexible syntax for expressing exactly which versions you are (and aren&amp;rsquo;t) interested in.&lt;/p&gt;

&lt;p&gt;If you want to specify a list of versions, then just use a space-separated enumeration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use only Bird::Talk =&amp;gt; &#39;0.42 0.44 0.47 0.50&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If your version requirements fall into a range, then you can specify those, too. Just use two versions, separated by a dash:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use only Bird::Talk =&amp;gt; &#39;0.42-0.50&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, you can list multiple ranges as well. And if you leave one of the versions off the range, then that means the range is open-ended.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use only Bird::Talk =&amp;gt; &#39;0.42-0.50 0.55-0.62 0.67-&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sometimes it&amp;rsquo;s easier to just specify the versions you don&amp;rsquo;t want. Using a &amp;lsquo;!&amp;rsquo; in front of either a range or a single version, negates that meaning. To avoid all versions of &lt;code&gt;Bird::Talk&lt;/code&gt; below 0.42, and also the extremely buggy version .53, say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use only Bird::Talk =&amp;gt; &#39;!-0.41 !0.53&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When more than one eligible version of &lt;code&gt;Bird::Talk&lt;/code&gt; is installed on your system, &lt;code&gt;only&lt;/code&gt; always chooses the highest version. If you don&amp;rsquo;t specify any version, then that is an indication to choose the highest-numbered version. This is different than saying:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Bird::Talk;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;because &lt;code&gt;only&lt;/code&gt; will search your &lt;code&gt;versionlib&lt;/code&gt; first.&lt;/p&gt;

&lt;h4 id=&#34;span-id-for-arguments-sake-for-argument-s-sake-span&#34;&gt;&lt;span id=&#34;for_arguments&#39;_sake&#34;&gt;For Argument&amp;rsquo;s Sake&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;There&amp;rsquo;s not much to say about passing arguments. Just pass them in the same way you would on a normal &lt;code&gt;use&lt;/code&gt; statement. This should even work for modules like &lt;code&gt;Inline.pm&lt;/code&gt; where the arguments are not import lists:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use only Inline =&amp;gt; 0.44, &#39;Java&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is one exception. In Perl, when you say something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Dog::Walk ();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s a cue to not call the module&amp;rsquo;s &lt;code&gt;import&lt;/code&gt; method at all. In other words, it ensures that no functions will be exported into your namespace. But if you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use only Dog::Walk =&amp;gt; 1.00, ();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then you will not get the same effect. Unfortunately, there is no way for &lt;code&gt;only.pm&lt;/code&gt; to detect that you called it that way. As a workaround, &lt;code&gt;only&lt;/code&gt; lets you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use only Dog::Walk =&amp;gt; 1.00, [];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This has a similar visual appearance and is meant as a mnemonic. (Hopefully, there aren&amp;rsquo;t a whole lot of modules in the world where it is important to pass in a single empty array ref :)&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-only-options-the-only-options-span&#34;&gt;&lt;span id=&#34;the_only_options&#34;&gt;The Only Options&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The only (no pun intended) option currently implemented for &lt;code&gt;only&lt;/code&gt; is &lt;code&gt;versionlib&lt;/code&gt;. This option allows you to override the system &lt;code&gt;versionlib&lt;/code&gt; stored in &lt;code&gt;only::config&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use only { versionlib =&amp;gt; &#39;/home/ingy/modules&#39; },
        Corn::Stalk =&amp;gt; 0.99, [];
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-friends-and-family-friends-and-family-span&#34;&gt;&lt;span id=&#34;friends_and_family&#34;&gt;Friends and Family&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;One important duty of &lt;code&gt;only&lt;/code&gt; is to ensure that when you load a specific version of some module, all of that module&amp;rsquo;s related modules are also loaded from the same version level. This is tricky, because in Perl, you never know when a module is going to be loaded. It could be loaded by your original module or not. It might happen at compile time ( &lt;code&gt;use&lt;/code&gt; ) or run time ( &lt;code&gt;require&lt;/code&gt; ). It could be loaded hours later in a long-running process (or a very, very, very slow computer :) There might also be autoloaded functions involved.&lt;/p&gt;

&lt;p&gt;Most importantly, some of the sub-modules might be loaded using &lt;code&gt;use only&lt;/code&gt;, while others are loaded with standard &lt;code&gt;use&lt;/code&gt; and &lt;code&gt;require&lt;/code&gt; statements. To make all this happen the way you&amp;rsquo;d expect it to, &lt;code&gt;only&lt;/code&gt; plays some tricks with &lt;code&gt;@INC&lt;/code&gt;. More on that shortly, my preciouses.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;only&lt;/code&gt; knows which modules are related because it saves the information as metadata for every module it installs. For example, if I install a module like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $ cd YAML-0.35
    $ perl Makefile.PL
    ... lines deleted
    $ make test
    ... lines deleted
    $ perl -Monly=install
    Installing /usr/local/perl580/lib/version/5.8.0/0.35/YAML.pm
    Installing /usr/local/perl580/lib/version/5.8.0/0.35/YAML.pod
    Installing /usr/local/perl580/lib/version/5.8.0/0.35/YAML/Error.pm
    Installing /usr/local/perl580/lib/version/5.8.0/0.35/YAML/Family.pm
    Installing /usr/local/perl580/lib/version/5.8.0/0.35/YAML/Node.pm
    Installing /usr/local/perl580/lib/version/5.8.0/0.35/YAML/Transfer.pm
    Installing /usr/local/perl580/lib/version/5.8.0/0.35/YAML/Error.yaml
    Installing /usr/local/perl580/lib/version/5.8.0/0.35/YAML/Family.yaml
    Installing /usr/local/perl580/lib/version/5.8.0/0.35/YAML/Node.yaml
    Installing /usr/local/perl580/lib/version/5.8.0/0.35/YAML/Transfer.yaml
    Installing /usr/local/perl580/lib/version/5.8.0/0.35/YAML.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then I get a YAML metadata file for each module. The metadata file &lt;code&gt;YAML.yaml&lt;/code&gt; looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # This meta file created by/for only.pm
    meta_version: 0.25
    install_version: 0.35
    distribution_name: YAML
    distribution_version: 0.35
    distribution_modules:
      - YAML.pm
      - YAML/Error.pm
      - YAML/Family.pm
      - YAML/Node.pm
      - YAML/Transfer.pm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This way, no matter which module is loaded first, &lt;code&gt;only&lt;/code&gt; knows about every other module that was installed with that module.&lt;/p&gt;

&lt;h3 id=&#34;span-id-only-on-the-inside-only-on-the-inside-span&#34;&gt;&lt;span id=&#34;only_on_the_inside&#34;&gt;Only on the Inside&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The internals of &lt;code&gt;only.pm&lt;/code&gt; are not incredibly complicated, but there is a little black magic going on. Most of it boils down to a relatively new and under-publicized feature of Perl5: putting &lt;strong&gt;objects&lt;/strong&gt; onto the &lt;code&gt;@INC&lt;/code&gt; array.&lt;/p&gt;

&lt;p&gt;As you probably know, &lt;code&gt;@INC&lt;/code&gt; is a special global array of file-system paths. When a program tries to load a Perl module with the &lt;code&gt;use&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; commands, it searches each of these paths in order until the module is found. The default paths in &lt;code&gt;@INC&lt;/code&gt; are compiled into Perl. You can alter the array with the &lt;code&gt;PERL5LIB&lt;/code&gt; environment variable, the &lt;code&gt;lib.pm&lt;/code&gt; module, or even by simply changing it with regular Perl array commands. It&amp;rsquo;s just an array, after all.&lt;/p&gt;

&lt;p&gt;As of Perl 5.6.1, you can actually put Perl objects onto &lt;code&gt;@INC&lt;/code&gt; and have &lt;code&gt;use&lt;/code&gt; and &lt;code&gt;require&lt;/code&gt; interact with them. When &lt;code&gt;require&lt;/code&gt; encounters an object in &lt;code&gt;@INC&lt;/code&gt; it attempts to call that object&amp;rsquo;s &lt;code&gt;INC&lt;/code&gt; method. The &lt;code&gt;INC&lt;/code&gt; method can do anything it wants to load the module. It could actually go out on the internet and locate the module, download it, install it and load it!&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;INC&lt;/code&gt; method should either return a filehandle or nothing. If a filehandle is returned, then &lt;code&gt;require&lt;/code&gt; considers the operation a success. It reads the contents of that filehandle and &lt;code&gt;eval&lt;/code&gt;-s the module into existence. If nothing is returned, then the operation is considered unsuccessful, and &lt;code&gt;require&lt;/code&gt; continues its merry way down &lt;code&gt;@INC&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The heart of the &lt;code&gt;only&lt;/code&gt; module&amp;rsquo;s magic lies in the fact that it puts an object onto &lt;code&gt;@INC&lt;/code&gt; that is responsible for loading an appropriate version of your module. Not only that,it is also responsible for loading the matching version of any related modules that were installed at the same time as your module.&lt;/p&gt;

&lt;h3 id=&#34;span-id-ooo-object-oriented-only-o-o-o-object-oriented-only-span&#34;&gt;&lt;span id=&#34;ooo__object_oriented_only&#34;&gt;O-O-o - Object-Oriented Only&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Since &lt;code&gt;only&lt;/code&gt; is an object-oriented module on the inside, it is no surprise that it offers an OO API to the those of you on the outside. (I assume that you don&amp;rsquo;t live inside a Perl module :)&lt;/p&gt;

&lt;p&gt;Using the OO interface can give you more understanding and control of the version specific loading process, at the cost of a slightly more verbose syntax specification. As an example, if you would normally do this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use only Good::Stuff =&amp;gt; &#39;1.20-1.55&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then you can say the same thing by doing this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use only;
    my $only;
    BEGIN {
        $only = only-&amp;gt;new;
        $only-&amp;gt;module(&#39;Good::Stuff&#39;);
        $only-&amp;gt;condition(&#39;1.20-1.55&#39;);
        $only-&amp;gt;include;
    }
    use Good::Stuff;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the &lt;code&gt;use&lt;/code&gt; statement is absolutely normal. No &lt;code&gt;only&lt;/code&gt; involved. But it still does what we want! That&amp;rsquo;s because the preceding code sticks one of those magic &lt;code&gt;only&lt;/code&gt; objects onto &lt;code&gt;@INC&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The methods should be fairly self-explanatory. The key method call is &lt;code&gt;only-&lt;/code&gt;include&amp;gt;. It tells the object to attach itself to the front of @INC.&lt;/p&gt;

&lt;p&gt;One nice thing is that you can actually do stuff with the object later on in the program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use only;
    my $only;
    BEGIN {    # methods can be stacked
        $only = only-&amp;gt;new-&amp;gt;module(&#39;Good::Stuff&#39;)-&amp;gt;condition(&#39;1.20-1.55&#39;)-&amp;gt;include;
    }
    use Good::Stuff;
    ...
    print &amp;quot;Using Good::Stuff version: &amp;quot; . $only-&amp;gt;distribution_version . &amp;quot;\n&amp;quot;;
    ...
    $only-&amp;gt;remove;    # Remove object from @INC;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-conclusion-conclusion-span&#34;&gt;&lt;span id=&#34;conclusion&#34;&gt;Conclusion&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;I always believed that if my old Triumph motorcycle ever broke down out on the open road, I could somehow figure out a way to repair it by walking down the road for a half mile in either direction, and finding some odds and ends lying around that I could use for tools. That&amp;rsquo;s because the roads are usually littered with all sorts of weird things, and I see everything as a tool to somehow suit my needs.&lt;/p&gt;

&lt;p&gt;Perl is much like that roadside. There are all kinds of weird things lying around that can help it solve its own problems. Even when Perl is playing the part of a busted Triumph bike, its roadside qualities always seem to be able to kickstart it right back into action.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;only.pm&lt;/code&gt; is a great example of this. Even though Perl was inadequate in regards to module versioning yesterday, today, it&amp;rsquo;s packing a brand new chainsaw. Rev it up!&lt;/p&gt;

&lt;h3 id=&#34;span-id-about-the-author-about-the-author-span&#34;&gt;&lt;span id=&#34;about_the_author&#34;&gt;About the Author&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Brian Ingerson has been programming for more than 20 years, and hacking Perl for five of those. He is dedicated to improving the overall quality of scripting languages including Perl, Python, PHP and Ruby. He currently hails from Portland, Ore. &amp;ndash; the location of this year&amp;rsquo;s O&amp;rsquo;Reilly Open Source Convention. How convenient!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

