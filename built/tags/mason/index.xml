<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mason on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/mason/</link>
    <description>Recent content in Mason on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 01 Apr 2004 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/mason/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Photo Galleries with Mason and Imager</title>
      <link>http://localhost:1313/pub/2004/04/01/masongal.html/</link>
      <pubDate>Thu, 01 Apr 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/04/01/masongal.html/</guid>
      <description>

&lt;p&gt;Creating a photo gallery is usually considered a daunting task. Lots of people have tried it, not many have succeeded. One of the reasons for so many similar projects is that they don&amp;rsquo;t often integrate well into an existing web site. In this article we&amp;rsquo;re going to build a photo gallery using two important components, Mason and Imager. Writing our gallery in Mason will make it much easier to integrate into an existing web site.&lt;/p&gt;

&lt;p&gt;Mason, also known as &lt;a href=&#34;https://metacpan.org/pod/HTML::Mason&#34;&gt;&lt;code&gt;HTML::Mason&lt;/code&gt;&lt;/a&gt;, is a web application framework written in Perl. Mason can run in any environment, but is tuned to work best with mod_perl. We will be using a number of Mason features in this article. If you&amp;rsquo;re not familiar with Mason I suggest you &lt;a href=&#34;http://www.oreilly.com/catalog/perlhtmlmason/&#34;&gt;get the book&lt;/a&gt; or &lt;a href=&#34;http://masonbook.com&#34;&gt;browse&lt;/a&gt; before you buy. This article is not meant to be an introduction to Mason, so some experience will definitely help when reading this. Mason idioms will be briefly reviewed when they come up.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://metacpan.org/pod/Imager&#34;&gt;&lt;code&gt;Imager&lt;/code&gt;&lt;/a&gt; is a Perl module for dealing with images. It has mechanisms to manipulate an image, and read and write various formats. It&amp;rsquo;s rather lightweight and has a clean interface in comparison to the alternative, &lt;a href=&#34;https://metacpan.org/pod/Image::Magick&#34;&gt;&lt;code&gt;Image::Magick&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Combining these two Perl modules, and adding a few others, allows us to write a feature-full photo gallery in just 200 lines. Let&amp;rsquo;s get started.&lt;/p&gt;

&lt;h3 id=&#34;span-id-apache-configuration-apache-configuration-span&#34;&gt;&lt;span id=&#34;Apache_Configuration&#34;&gt;Apache Configuration&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;re going to use Mason from mod_perl for our gallery. This requires an Apache built with mod_perl, and bit of web server configuration.&lt;/p&gt;

&lt;p&gt;First, Mason&amp;rsquo;s Apache handler must be pre-loaded.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  PerlModule HTML::Mason::ApacheHandler
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we need to tell Apache to let Mason handle any requests that it gets for resources within our gallery.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;Location /gallery&amp;gt;
    SetHandler perl-script
    PerlHandler HTML::Mason::ApacheHandler
  &amp;lt;/Location&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We want to keep special Mason files secret from the general public. If they&amp;rsquo;re requested, Apache should always return a &lt;code&gt;404&lt;/code&gt; HTTP status code, for &lt;em&gt;Not Found&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;LocationMatch &amp;quot;(dhandler|autohandler)$&amp;quot;&amp;gt;
    SetHandler perl-script
    PerlInitHandler Apache::Constants::NOT_FOUND
  &amp;lt;/LocationMatch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point, every file inside the gallery will be considered a Mason component. If you enjoy paying for lots of bandwidth and you want the full-size images to be viewable by the public, one last configuration step must occur. The raw images are not Mason components so Apache should handle those in the default way.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;Location /gallery/images&amp;gt;
    SetHandler default
  &amp;lt;/Location&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-directory-structure-directory-structure-span&#34;&gt;&lt;span id=&#34;Directory_Structure&#34;&gt;Directory Structure&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;For this article we&amp;rsquo;ll use the following directory structure, in a directory called &lt;em&gt;gallery&lt;/em&gt;, inside our site &lt;code&gt;DocumentRoot&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  .
  |-- autohandler
  |-- dhandler
  |-- images
  |   `-- dhandler
  |-- index.html
  `-- pictures
      `-- [lots of images and sub-directories]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, all the actual photos will be uploaded to the &lt;em&gt;gallery/pictures&lt;/em&gt; directory. Our code will recognize sub-galleries and allow for infinite nesting. We can keep our photos very neatly organized this way.&lt;/p&gt;

&lt;p&gt;As for the rest, it&amp;rsquo;s all code. &lt;em&gt;autohandler&lt;/em&gt; and &lt;em&gt;dhandler&lt;/em&gt; are special Mason files, and &lt;em&gt;index.html&lt;/em&gt; is just a wrapper around the top level &lt;em&gt;dhandler&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-autohandler-the-autohandler-span&#34;&gt;&lt;span id=&#34;The_autohandler&#34;&gt;The &lt;em&gt;autohandler&lt;/em&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;For this example, our &lt;em&gt;autohandler&lt;/em&gt; is extremely simple. I&amp;rsquo;m going to assume that you already have a Mason site running with your own &lt;em&gt;autohandler&lt;/em&gt; wrappers in place. If you don&amp;rsquo;t, you can use this one.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%method .title&amp;gt;My Website&amp;lt;/%method&amp;gt;

  &amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
      &amp;lt;title&amp;gt;&amp;lt;&amp;amp; SELF:.title &amp;amp;&amp;gt;&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
      &amp;lt;% $m-&amp;gt;call_next %&amp;gt;
    &amp;lt;/body&amp;gt;
  &amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first thing our &lt;em&gt;autohandler&lt;/em&gt; does is define a subcomponent called &lt;code&gt;.title&lt;/code&gt;. Mason subcomponents are wrapped in &lt;code&gt;&amp;lt;%method&amp;gt;&lt;/code&gt; blocks. They are templates just like files; the only difference is they live inside the files. This is analogous to Perl files and subroutines.&lt;/p&gt;

&lt;p&gt;Next we define the skeleton of the web page. The &lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; tag&amp;rsquo;s content is dynamically generated by the output of the &lt;code&gt;SELF:.title&lt;/code&gt; subcomponent. Any time you want to call a subcomponent, the call is wrapped in &lt;code&gt;&amp;lt;&amp;amp; &amp;amp;&amp;gt;&lt;/code&gt; delimiters.&lt;/p&gt;

&lt;p&gt;The body, or content, of our web page will be provided by whatever component is next in the call stack. Using the global variable to access Mason object, &lt;code&gt;$m&lt;/code&gt;, the &lt;code&gt;call_next()&lt;/code&gt; method is executed to do just that.&lt;/p&gt;

&lt;p&gt;In our gallery the next component in the call stack will be one of two files. If we&amp;rsquo;re at the topmost level, &lt;code&gt;http://example.com/gallery/&lt;/code&gt;, for example, &lt;em&gt;index.html&lt;/em&gt; will be called. Everywhere else &lt;em&gt;dhandler&lt;/em&gt; will be called. This is because no files exist for Mason to map to, and when that happens, Mason looks for a &lt;em&gt;dhandler&lt;/em&gt; to execute.&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-invisible-index-the-invisible-index-span&#34;&gt;&lt;span id=&#34;The_Invisible_Index&#34;&gt;The Invisible Index&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;dhandlers&lt;/code&gt; are default handlers for files inside a directory, and not that directory itself. Because of this we are required to provide an &lt;em&gt;index.html&lt;/em&gt; file or Apache will attempt to display a directory listing, or possibly return a &lt;em&gt;forbidden&lt;/em&gt; status code, if directory listings are not allowed. In reality, our &lt;em&gt;index.html&lt;/em&gt; doesn&amp;rsquo;t do anything at all.&lt;/p&gt;

&lt;p&gt;In its entirety, &lt;em&gt;index.html&lt;/em&gt; simply states that it inherits from &lt;em&gt;dhandler&lt;/em&gt;. Now &lt;em&gt;dhandler&lt;/em&gt; will be executed for all non-image access to our photo gallery.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%flags&amp;gt;
    inherit =&amp;gt; &#39;dhandler&#39;
  &amp;lt;/%flags&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This uncovers a portion of Mason&amp;rsquo;s object-like component inheritance. By default, all components inherit from &lt;em&gt;autohandler&lt;/em&gt;. For &lt;em&gt;index.html&lt;/em&gt; we&amp;rsquo;ve changed that. &lt;em&gt;dhandler&lt;/em&gt; still inherits from &lt;em&gt;autohandler&lt;/em&gt;, so anytime a request is sent to &lt;em&gt;index.html&lt;/em&gt;, &lt;em&gt;dhandler&lt;/em&gt; is first called, which calls &lt;em&gt;autohandler&lt;/em&gt; first. Then &lt;em&gt;autohandler&lt;/em&gt; does its thing and moves down the call stack to &lt;em&gt;dhandler&lt;/em&gt;. &lt;em&gt;dhandler&lt;/em&gt;, as we&amp;rsquo;ll see, is not configured to call down the stack to &lt;em&gt;index.html&lt;/em&gt;, because it doesn&amp;rsquo;t need to. Thus ends the very high-level overview of Mason inheritance.&lt;/p&gt;

&lt;h3 id=&#34;span-id-displaying-gallery-pages-displaying-gallery-pages-span&#34;&gt;&lt;span id=&#34;Displaying_Gallery_Pages&#34;&gt;Displaying Gallery Pages&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Moving on to the meat of our application, the top-level &lt;em&gt;dhandler&lt;/em&gt;. This file has the bulk of our code, roughly 150 lines. The code is neatly organized into subcomponents, so we&amp;rsquo;ll start by discussing the high-level code. And from that we&amp;rsquo;ll work in order of execution.&lt;/p&gt;

&lt;p&gt;Each page in our photo gallery has just one optional argument, a page number. By default we always start on page one (&lt;code&gt;1&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%args&amp;gt;
    $page =&amp;gt; 1
  &amp;lt;/%args&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, the &lt;code&gt;&amp;lt;%shared&amp;gt;&lt;/code&gt; block is executed. It does a lot, so we&amp;rsquo;ll look at it in great detail. We&amp;rsquo;re using a &lt;code&gt;&amp;lt;%shared&amp;gt;&lt;/code&gt; block instead of an &lt;code&gt;&amp;lt;%init&amp;gt;&lt;/code&gt; block because some of the variables defined here need to be used within multiple subcomponents. As the name suggests, &lt;code&gt;&amp;lt;%shared&amp;gt;&lt;/code&gt; blocks allow just that.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%shared&amp;gt;
    use List::Group qw[group];
    use HTML::Table;
    use File::Spec::Functions qw[:ALL];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first step is to load the Perl modules this component will be using. &lt;a href=&#34;https://metacpan.org/pod/List::Group&#34;&gt;&lt;code&gt;List::Group&lt;/code&gt;&lt;/a&gt; turns a flat list into a List-of-Lists (LoL) based on specific grouping options, &lt;a href=&#34;https://metacpan.org/pod/HTML::Table&#34;&gt;&lt;code&gt;HTML::Table&lt;/code&gt;&lt;/a&gt; turns such an LoL into an HTML table structure, and &lt;a href=&#34;https://metacpan.org/pod/File::Spec::Functions&#34;&gt;&lt;code&gt;File::Spec::Functions&lt;/code&gt;&lt;/a&gt; provides a number of portable file and directory operations.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $GALLERY_ROOT = $r-&amp;gt;document_root . &amp;quot;/gallery/pictures&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we define the first shared variable. &lt;code&gt;$GALLERY_ROOT&lt;/code&gt; is the absolute path to the location of the gallery pictures on the file system.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (my $path_from_uri = $m-&amp;gt;dhandler_arg) =~ s!(?:(?:/index)?\.html|/)$!!;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s time to determine the relative path to the resource being requested. Because we&amp;rsquo;re inside a &lt;em&gt;dhandler&lt;/em&gt;, Mason provides the &lt;code&gt;dhandler_arg()&lt;/code&gt; method, which is similar in purpose to Apache&amp;rsquo;s &lt;code&gt;uri()&lt;/code&gt; method. It returns the portion of a URI that is relative to the directory containing the &lt;em&gt;dhandler&lt;/em&gt;. If we request &lt;code&gt;/gallery/Family/IMG_0001.JPG.html&lt;/code&gt;, &lt;code&gt;$m-&amp;gt;dhandler_arg()&lt;/code&gt; will return &lt;code&gt;/Family/IMG_0001.JPG.html&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Because we&amp;rsquo;re looking for the path to an actual photo or gallery directory, there is some information to be removed from the end of our relative path. So our regex removes useless information such as index files, HTML extensions, and extra backslashes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $file = catdir $GALLERY_ROOT, $path_from_uri;
    $m-&amp;gt;clear_buffer and $m-&amp;gt;abort(404) unless -e $file;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From these two variables we can construct the absolute path to the file we&amp;rsquo;re interested in using &lt;code&gt;catdir()&lt;/code&gt;, from &lt;code&gt;File::Spec::Functions&lt;/code&gt;. If this file doesn&amp;rsquo;t exist, we don&amp;rsquo;t want to go any further, so Mason&amp;rsquo;s output buffer is cleared and the request is aborted immediately with a &lt;code&gt;404&lt;/code&gt; HTTP status code, meaning &lt;em&gt;Not Found&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;If a gallery is being requested, not a specific photo, we must get the contents of that gallery. If a photo is being requested, we must get the contents of the gallery that photo belongs to.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $dir = -d $file ? $file : (splitpath $file)[1];
    opendir DIR, $dir or die $!;
    my $dir_list = [ map &amp;quot;$dir/$_&amp;quot;, grep { ! /^\./ } readdir DIR ];
    closedir DIR;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using a file test operator, we can determine if the current request is for a file or a directory. If a directory we simply assign &lt;code&gt;$file&lt;/code&gt; to &lt;code&gt;$dir&lt;/code&gt;. If a file, we use &lt;code&gt;splitpath()&lt;/code&gt; from &lt;code&gt;File::Spec::Functions&lt;/code&gt;. &lt;code&gt;splitpath()&lt;/code&gt; returns three elements, the volume, directory tree, and filename. We&amp;rsquo;re after the directory tree, or second element.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;$dir_list&lt;/code&gt; array reference is populated with a list of absolute paths to each file in &lt;code&gt;$dir&lt;/code&gt;, excluding files that begin with a dot (&lt;code&gt;.&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Now it&amp;rsquo;s time to move on to building the breadcrumbs for navigation. This method of navigating &amp;ldquo;up&amp;rdquo; the photo gallery is important because we can have infinite levels of sub-galleries.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @bread_crumb = (&#39;Gallery&#39;, splitdir $path_from_uri);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First we define our plain-text list of crumbs in &lt;code&gt;@bread_crumb&lt;/code&gt;. The first element is the name of our photo gallery, which I imaginatively named &lt;em&gt;Gallery&lt;/em&gt;. The rest of our breadcrumbs come from &lt;code&gt;$path_from_uri&lt;/code&gt; by calling &lt;code&gt;splitpath()&lt;/code&gt; to get the list of elements.&lt;/p&gt;

&lt;p&gt;Our &lt;code&gt;@bread_crumb&lt;/code&gt; list is great for the title of the page, but it doesn&amp;rsquo;t contain any links for use inside the page for navigation. A new list of breadcrumbs will be created with correct linking.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @bread_crumb_href;
    push @bread_crumb_href, sprintf &#39;&amp;lt;a href=&amp;quot;/gallery/%s&amp;quot;&amp;gt;%s&amp;lt;/a&amp;gt;&#39;,
      join(&#39;/&#39;,@bread_crumb[1..$_]), $bread_crumb[$_]
        for 0 .. $#bread_crumb - 1;
    push @bread_crumb_href, $bread_crumb[-1];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For each breadcrumb except the very last, we create an HTML link. The reference location for each link, from left to right, needs to cumulatively add directories from the links before it. That&amp;rsquo;s what &lt;code&gt;join(&#39;/&#39;,@bread_crumb[1..$_])&lt;/code&gt; does. Finally we tack on the last element of the breadcrumb, unlinked, because it is the currently requested resource.&lt;/p&gt;

&lt;p&gt;To illustrate, if a request is made to &lt;code&gt;/gallery/Backgrounds/Nature%20Backgrounds/ICmiddleFalls1280x1024.jpg.html&lt;/code&gt;, the following list is in &lt;code&gt;@bread_crumb_href&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  (
   &#39;&amp;lt;a href=&amp;quot;/gallery/&amp;quot;&amp;gt;Gallery&amp;lt;/a&amp;gt;&#39;,
   &#39;&amp;lt;a href=&amp;quot;/gallery/Backgrounds&amp;quot;&amp;gt;Backgrounds&amp;lt;/a&amp;gt;&#39;,
   &#39;&amp;lt;a href=&amp;quot;/gallery/Backgrounds/Nature Backgrounds&amp;quot;&amp;gt;Nature Backgrounds&amp;lt;/a&amp;gt;&#39;,
   &#39;ICmiddleFalls1280x1024.jpg&#39;
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we construct two scalars to hold the contents of our breadcrumbs.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $bread_crumb      = join &#39; &amp;amp;middot; &#39;, @bread_crumb;
    my $bread_crumb_href = join &#39; &amp;amp;middot; &#39;, @bread_crumb_href;
  &amp;lt;/%shared&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point we can define the &lt;code&gt;.title&lt;/code&gt; subcomponent, using the &lt;code&gt;$bread_crumb&lt;/code&gt; shared variable.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%method .title&amp;gt;&amp;lt;&amp;amp; PARENT:.title &amp;amp;&amp;gt; &amp;amp;middot; &amp;lt;% $bread_crumb %&amp;gt;&amp;lt;/%method&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that there is a subcomponent call to &lt;code&gt;PARENT:.title&lt;/code&gt;. This is another illustration of Mason&amp;rsquo;s inheritance model. Because &lt;em&gt;dhandler&lt;/em&gt; &lt;strong&gt;inherits&lt;/strong&gt; from &lt;em&gt;autohandler&lt;/em&gt;, the &lt;code&gt;.title&lt;/code&gt; subcomponent in &lt;em&gt;dhandler&lt;/em&gt; is overriding the &lt;code&gt;.title&lt;/code&gt; method in &lt;em&gt;autohandler&lt;/em&gt;. That is to say, &lt;em&gt;dhandler&lt;/em&gt; is &lt;strong&gt;subclassing&lt;/strong&gt; &lt;em&gt;autohandler&lt;/em&gt;. For this reason, if we don&amp;rsquo;t want to clobber the &lt;code&gt;.title&lt;/code&gt; subcomponent declared in &lt;em&gt;autohandler&lt;/em&gt; we must be sure to call our parent. This is very similar to invoking a &lt;code&gt;SUPER::&lt;/code&gt; method in Perl.&lt;/p&gt;

&lt;p&gt;Now we can move on to the actual gallery display.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;h1&amp;gt;Photo Gallery&amp;lt;/h1&amp;gt;
  &amp;lt;h2&amp;gt;&amp;lt;% $bread_crumb_href %&amp;gt;&amp;lt;/h2&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using another shared variable, &lt;code&gt;$bread_crumb_href&lt;/code&gt;, we construct our backward navigation.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;table&amp;gt;
    &amp;lt;tr&amp;gt;
      &amp;lt;td valign=&amp;quot;top&amp;quot; width=&amp;quot;15%&amp;quot;&amp;gt;
        &amp;lt;&amp;amp; SELF:.sub_gal_list, dir_list =&amp;gt; $dir_list &amp;amp;&amp;gt;
      &amp;lt;/td&amp;gt;
      &amp;lt;td valign=&amp;quot;top&amp;quot; width=&amp;quot;35%&amp;quot;&amp;gt;
        &amp;lt;&amp;amp; SELF:.photo_list, dir_list =&amp;gt; $dir_list, page =&amp;gt; $page &amp;amp;&amp;gt;
      &amp;lt;/td&amp;gt;
      &amp;lt;td valign=&amp;quot;top&amp;quot; width=&amp;quot;50%&amp;quot;&amp;gt;
  % if ( -f $file ) {
        &amp;lt;&amp;amp; SELF:.photo_view, file =&amp;gt; $file &amp;amp;&amp;gt;
  % }
      &amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
  &amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have three columns of information to display at any one time &amp;ndash; an HTML table is a good way to do that. (Some standards purists and XHTML masochists will disagree with me on this point. I&amp;rsquo;m interested in keeping the examples simple, not pure.) Each of the table cells calls a subcomponent with the appropriate arguments. Those subcomponents are discussed in detail later in this article. Notice that before we call &lt;code&gt;SELF:.photo_view&lt;/code&gt; we check to see if the request is currently for a file. This can save us from calling that subcomponent if we currently don&amp;rsquo;t want to look at a photo.&lt;/p&gt;

&lt;p&gt;The first subcomponent called is &lt;code&gt;SELF:.sub_gal_list&lt;/code&gt;. As the name suggests, it will list sub-galleries.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%method .sub_gal_list&amp;gt;
    &amp;lt;%args&amp;gt;
      @dir_list
      $wrap =&amp;gt; 1
    &amp;lt;/%args&amp;gt;

    &amp;lt;h3&amp;gt;Sub &amp;lt;% @dir_list == 1 ? &amp;quot;Gallery&amp;quot; : &amp;quot;Galleries&amp;quot; %&amp;gt;&amp;lt;/h3&amp;gt;
    &amp;lt;% $table %&amp;gt;

    &amp;lt;%init&amp;gt;
      @dir_list = grep { -d $_ } @dir_list;
      return unless @dir_list;
      $_ = $m-&amp;gt;scomp(&#39;SELF:.sub_gal_view&#39;,dir =&amp;gt; $_) for @dir_list;
      my $table = HTML::Table-&amp;gt;new(-data =&amp;gt; [ group \@dir_list, cols =&amp;gt; $wrap ]);
    &amp;lt;/%init&amp;gt;
  &amp;lt;/%method&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.sub_gal_list&lt;/code&gt; accepts a directory listing argument. It also optionally accepts an argument detailing after how many entries in the list should be in each row.&lt;/p&gt;

&lt;p&gt;Jumping to the &lt;code&gt;&amp;lt;%init&amp;gt;&lt;/code&gt; block (remember the order of execution?), we filter the directory listing to exclude any entries that are not directories themselves. If that produces an empty list, there&amp;rsquo;s no need to continue processing this subcomponent, so just &lt;code&gt;return&lt;/code&gt;. Next, each of the entries are reformatted by passing them to the &lt;code&gt;SELF:.sub_gal_view&lt;/code&gt; method. This is where it gets fun.&lt;/p&gt;

&lt;p&gt;When a subcomponent is called, it&amp;rsquo;s really just syntactic sugar to call &lt;code&gt;$m-&amp;gt;comp()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;&amp;amp; SELF:.sub_gal_view, dir =&amp;gt; $_ &amp;amp;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The previous statement is exactly equivalent to the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % $m-&amp;gt;comp( &#39;SELF:.sub_gal_view&#39;, dir =&amp;gt; $_ );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mason also defines the &lt;code&gt;scomp()&lt;/code&gt; method, which compiles a subcomponent but returns its output as a string, just like Perl&amp;rsquo;s &lt;code&gt;sprintf&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;After reformatting the entries, we group the flat list into a List-of-Lists containing just one column. That list is used as the value of the &lt;code&gt;-data&lt;/code&gt; parameter to &lt;code&gt;HTML::Table-&lt;/code&gt;new()&amp;gt;, which returns a table object.&lt;/p&gt;

&lt;p&gt;Now it&amp;rsquo;s time to process the template portion. First a heading is created. It&amp;rsquo;s only plural if we have more than one sub-gallery. After the heading the sub-gallery table is displayed. Because an &lt;code&gt;HTML::Table&lt;/code&gt; object overloads stringify, there&amp;rsquo;s no need to call a method on it to get the HTML output.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s quickly look at the &lt;code&gt;.sub_gal_view&lt;/code&gt; subcomponent used to reformat each directory listing.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%method .sub_gal_view&amp;gt;
    &amp;lt;%args&amp;gt;
      $dir
    &amp;lt;/%args&amp;gt;
    &amp;lt;a href=&amp;quot;/gallery/&amp;lt;% $rel_dir %&amp;gt;&amp;quot;&amp;gt;&amp;lt;% $label %&amp;gt;&amp;lt;/a&amp;gt;
    &amp;lt;%init&amp;gt;
      my $rel_dir = abs2rel $dir, $GALLERY_ROOT;
      my $label   = (splitpath $rel_dir)[-1];
    &amp;lt;/%init&amp;gt;
  &amp;lt;/%method&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This subcomponent is extremely straightforward. It accepts a directory. Inside &lt;code&gt;&amp;lt;%init&amp;gt;&lt;/code&gt;, &lt;code&gt;$rel_dir&lt;/code&gt; is set to the relative directory path in relation to the &lt;code&gt;$GALLERY_ROOT&lt;/code&gt;, which will give us a proper URL for the link. Finding the label for the link is simple, it is the real directory name, which is the last element of the list returned by &lt;code&gt;splitpath()&lt;/code&gt;, from &lt;code&gt;File::Spec::Functions&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This subcomponent finally generates the proper link for navigating to sub-galleries.&lt;/p&gt;

&lt;p&gt;The next subcomponent called by our top-level component is &lt;code&gt;.photo_list&lt;/code&gt;, which generates the thumbnail view of our images.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%method .photo_list&amp;gt;
    &amp;lt;%args&amp;gt;
      @dir_list
      $wrap =&amp;gt; 5
      $rows =&amp;gt; 7
      $page =&amp;gt; 1
    &amp;lt;/%args&amp;gt;

    &amp;lt;h3&amp;gt;&amp;lt;% @dir_list == 1 ? &amp;quot;Photo&amp;quot; : &amp;quot;Photos&amp;quot; %&amp;gt;
        &amp;lt;&amp;amp; SELF:.photo_pager, page =&amp;gt; $page, pages =&amp;gt; $pages &amp;amp;&amp;gt;&amp;lt;/h3&amp;gt;
    &amp;lt;% $table %&amp;gt;

    &amp;lt;%init&amp;gt;
      @dir_list = grep { -f $_ } @dir_list;
      return unless @dir_list;
      $_ = $m-&amp;gt;scomp(&#39;SELF:.thumb_view&#39;,file =&amp;gt; $_, page =&amp;gt; $page)
        for @dir_list;
      my @files = group \@dir_list, cols =&amp;gt; $wrap;

      my $pages  = int( @files / $rows );
         $pages += 1 if $pages &amp;lt; ( @files / $rows );
      @files = splice @files, $rows * ($page - 1), $rows;

      my $table = HTML::Table-&amp;gt;new(-data =&amp;gt; \@files);
    &amp;lt;/%init&amp;gt;
  &amp;lt;/%method&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just like &lt;code&gt;.sub_gal_list&lt;/code&gt;, the only required argument to this component is the directory listing. The other optional arguments correspond to how many images should be in each row (&lt;code&gt;$wrap&lt;/code&gt;), how many rows to show on a page (&lt;code&gt;$rows&lt;/code&gt;), and what page we&amp;rsquo;re currently on (&lt;code&gt;$page&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Once again we jump to the &lt;code&gt;&amp;lt;%init&amp;gt;&lt;/code&gt; block where the directory listing is filtered to only include files. If there are no files, there&amp;rsquo;s no reason to go any further, so just &lt;code&gt;return&lt;/code&gt; from this subcomponent. Just as we did with sub-gallery listings, we reformat the remaining list of files by calling a subcomponent and storing its output. Next, we group the list of files into a List-of-Lists (LoL), each row containing &lt;code&gt;$wrap&lt;/code&gt; entries.&lt;/p&gt;

&lt;p&gt;Photo galleries may contain any number of photos, so it&amp;rsquo;s essential to support paging for thumbnails. First we need to determine how many pages this gallery will have in total. To do that we divide the total number of rows by the number of rows we want on each page. That could return a fractional number that will be cut off to the nearest decimal by &lt;code&gt;int&lt;/code&gt;. If that&amp;rsquo;s the case then we want to increment the number of pages by one (&lt;code&gt;1&lt;/code&gt;). Next we can extract the rows for our current page from all the rows currently in &lt;code&gt;@files&lt;/code&gt; using a &lt;code&gt;splice&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Finally, a new &lt;code&gt;HTML::Table&lt;/code&gt; object is created, and populated with &lt;code&gt;@files&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In the template portion a header is output, again only using the plural if we have more than one photo. Our header also contains paging information, provided by the &lt;code&gt;.photo_pager&lt;/code&gt; subcomponent. Lastly, the HTML table full of thumbnails is displayed.&lt;/p&gt;

&lt;p&gt;Speaking of thumbnails, it&amp;rsquo;s time to look at the code in the &lt;code&gt;.thumb_view&lt;/code&gt; subcomponent.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%method .thumb_view&amp;gt;
    &amp;lt;%args&amp;gt;
      $file
      $page
    &amp;lt;/%args&amp;gt;
      &amp;lt;a href=&amp;quot;/gallery/&amp;lt;% $rel_img %&amp;gt;.html?page=&amp;lt;% $page %&amp;gt;&amp;quot;&amp;gt;
        &amp;lt;img src=&amp;quot;/gallery/images/&amp;lt;% $rel_img %&amp;gt;?xsize=50;ysize=40&amp;quot; border=&amp;quot;0&amp;quot; /&amp;gt;
      &amp;lt;/a&amp;gt;
    &amp;lt;%init&amp;gt;
      my $rel_img = abs2rel $file, $GALLERY_ROOT;
    &amp;lt;/%init&amp;gt;
  &amp;lt;/%method&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This component takes two arguments. &lt;code&gt;$file&lt;/code&gt; is the image to be turned into a thumbnail, and &lt;code&gt;$page&lt;/code&gt; is the current page of this gallery. The &lt;code&gt;&amp;lt;%init&amp;gt;&lt;/code&gt; block just finds the relative path of this image from the &lt;code&gt;$GALLERY_ROOT&lt;/code&gt;. In the template the thumbnail is linked to the HTML file that this image would be displayed on, and includes the current page information as a means of saving that state.&lt;/p&gt;

&lt;p&gt;The source of the image points to a file under &lt;em&gt;/gallery/images&lt;/em&gt;, and includes query parameters for maximum width (&lt;code&gt;xsize&lt;/code&gt;) and height (&lt;code&gt;ysize&lt;/code&gt;). This is interesting because the pictures don&amp;rsquo;t live there at all. If you recall, the only thing inside the &lt;em&gt;images&lt;/em&gt; directory was a &lt;em&gt;dhandler&lt;/em&gt;. More on that later.&lt;/p&gt;

&lt;p&gt;The other subcomponent that &lt;code&gt;.photo_list&lt;/code&gt; called was &lt;code&gt;.photo_pager&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%method .photo_pager&amp;gt;
    &amp;lt;%args&amp;gt;
      $page
      $pages
    &amp;lt;/%args&amp;gt;
    (
  % for ( 1 .. $pages ) {
  %   if ( $_ == $page ) {
        &amp;lt;strong&amp;gt;&amp;lt;% $page %&amp;gt;&amp;lt;/strong&amp;gt;
  %   } else {
        &amp;lt;a href=&amp;quot;?page=&amp;lt;% $_ %&amp;gt;&amp;quot;&amp;gt;&amp;lt;% $_ %&amp;gt;&amp;lt;/a&amp;gt;
  %   }
      &amp;lt;% $_ != $pages ? &amp;quot;&amp;amp;middot;&amp;quot; : &amp;quot;&amp;quot; %&amp;gt;
  % }
    )
    &amp;lt;%init&amp;gt;
      return if $pages == 1;
    &amp;lt;/%init&amp;gt;
  &amp;lt;/%method&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This subcomponent takes two arguments, the current page and the total number of pages. Before anything is output, the &lt;code&gt;&amp;lt;%init&amp;gt;&lt;/code&gt; block checks to make sure we have more than one page. If not, no sense in going on. Looping through all the page numbers, we link all the numbers except our current page. After every number except the last one, we output a stylish separator. This subcomponent is very simple, but big enough that it&amp;rsquo;s worth abstracting from the &lt;code&gt;.photo_list&lt;/code&gt; subcomponent.&lt;/p&gt;

&lt;p&gt;The final subcomponent in the top-level &lt;em&gt;dhandler&lt;/em&gt; is &lt;code&gt;.photo_view&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%method .photo_view&amp;gt;
    &amp;lt;%args&amp;gt;
      $file
    &amp;lt;/%args&amp;gt;
    &amp;lt;h3&amp;gt;Photo&amp;lt;/h3&amp;gt;
    &amp;lt;img src=&amp;quot;/gallery/images/&amp;lt;% $rel_image %&amp;gt;?xsize=400x;ysize=300&amp;quot; /&amp;gt;
    &amp;lt;%init&amp;gt;
      my $rel_image = abs2rel $file, $GALLERY_ROOT;
    &amp;lt;/%init&amp;gt;
  &amp;lt;/%method&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This component does things that we&amp;rsquo;ve already seen done in &lt;code&gt;.thumb_view&lt;/code&gt;, so there&amp;rsquo;s no need to expound upon it here.&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-images-dhandler-the-images-dhandler-span&#34;&gt;&lt;span id=&#34;The_Images_dhandler&#34;&gt;The Images &lt;em&gt;dhandler&lt;/em&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;You&amp;rsquo;ve probably guessed by now that we intend to use Mason to process images. Mason is well suited to outputting many forms of data, not just text, and we&amp;rsquo;ll be exploiting that fact for our image gallery.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%args&amp;gt;
    $xsize =&amp;gt; undef
    $ysize =&amp;gt; undef
  &amp;lt;/%args&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This component accepts two parameters that we&amp;rsquo;ve already described. &lt;code&gt;$xsize&lt;/code&gt; is the maximum width an image can be, and &lt;code&gt;$ysize&lt;/code&gt; is the maximum height an image can be.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%flags&amp;gt;
    inherit =&amp;gt; undef
  &amp;lt;/%flags&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the important part. Because components have inheritance, the &lt;em&gt;dhandler&lt;/em&gt; would normally inherit from the &lt;em&gt;autohandler&lt;/em&gt;. That&amp;rsquo;s bad news when the &lt;em&gt;autohandler&lt;/em&gt; is tuned to sending out HTML and our &lt;em&gt;dhandler&lt;/em&gt; is trying to send binary image data. Setting the &lt;code&gt;inherit&lt;/code&gt; flag to &lt;code&gt;undef&lt;/code&gt; tells Mason that the &lt;em&gt;dhandler&lt;/em&gt; doesn&amp;rsquo;t inherit anything, that it&amp;rsquo;s responsible for its own output.&lt;/p&gt;

&lt;p&gt;The only code remaining in this template resides in the &lt;code&gt;&amp;lt;%init&amp;gt;&lt;/code&gt; block, so let&amp;rsquo;s step through that now.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%init&amp;gt;
    $m-&amp;gt;clear_buffer;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The very first thing we do is clear Mason&amp;rsquo;s output buffer. This clears any headers that have already been built up in the buffer.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Imager;
    use File::Type;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we use the modules that will help scale the images, &lt;code&gt;Imager&lt;/code&gt; and &lt;code&gt;File::Type&lt;/code&gt;. &lt;code&gt;Imager&lt;/code&gt; has already been discussed. &lt;code&gt;File::Type&lt;/code&gt; uses magic to discover the type of files, and does so in a very memory-sensitive way.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $send_img = sub {
      $r-&amp;gt;content_type( &amp;quot;image/$_[0]&amp;quot; );
      $r-&amp;gt;send_http_header;
      $m-&amp;gt;print($_[1]);
      $m-&amp;gt;abort(200);
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This anonymous subroutine just encapsulates code being executed twice, as a means to remove duplication. It sets the HTTP &lt;code&gt;Content-Type&lt;/code&gt; header to the image type passed as the first argument. Next it sends the HTTP header out. Then it sends the image data out, which is the second argument passed to this subroutine. Finally, it aborts execution with an HTTP &lt;code&gt;200&lt;/code&gt; status code, everything is &lt;em&gt;OK&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ( my $file = $r-&amp;gt;document_root . $r-&amp;gt;uri ) =~ s/images/pictures/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Discovering the proper file name for the image takes just a little work. After concatenating the &lt;code&gt;document_root()&lt;/code&gt; with the &lt;code&gt;uri()&lt;/code&gt;, we replace the &lt;em&gt;images&lt;/em&gt; portion of the file path with &lt;em&gt;pictures&lt;/em&gt;. Remember, none of the images are actually in the &lt;em&gt;images&lt;/em&gt; directory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my ($image, $type) = split /\//, File::Type-&amp;gt;checktype_filename($file);
    $type = &#39;png&#39; if $type eq &#39;x-png&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the knowledge of the proper file name, &lt;code&gt;File::Type&lt;/code&gt; can figure out what type of file we have. This is more foolproof than attempting a guess based on filename extensions. As a minor oddity, &lt;code&gt;File::Type&lt;/code&gt; returns a non-HTTP friendly &lt;code&gt;$type&lt;/code&gt; for PNG images, so we need to fix that problem if it exists.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $key = &amp;quot;$file|$xsize|$ysize&amp;quot;;
    if ( my $data = $m-&amp;gt;cache-&amp;gt;get( $key ) ) {
      $send_img-&amp;gt;($type, $data);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Generating scaled images from huge photos is a time-consuming function. It also has the potential to eat memory like a sieve. As a result, it&amp;rsquo;s imperative that we take advantage of Mason&amp;rsquo;s built-in caching functionality. The key for each entry in our cache must be unique for each file, and the dimensions we&amp;rsquo;re trying to scale it to. Those three pieces of data will make up our &lt;code&gt;$key&lt;/code&gt;. If data is returned from the cache using the &lt;code&gt;$key&lt;/code&gt;, then the image data is sent and the request is immediately aborted. This is a quick short-circuit that allows us to grab an image from the cache and return it at the earliest possible moment. Later in the article you&amp;rsquo;ll see how to set the data into the cache.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $m-&amp;gt;abort(500) if $image ne &#39;image&#39; || ! exists $Imager::formats{$type};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s possible that the file being requested isn&amp;rsquo;t an image. It&amp;rsquo;s also possible that our installation of &lt;code&gt;Imager&lt;/code&gt; doesn&amp;rsquo;t support this type of image. If either of these conditions are true, we should abort immediately with a &lt;code&gt;500&lt;/code&gt; HTTP status code, &lt;em&gt;Internal Server Error&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $img  = Imager-&amp;gt;new;
    if ( $img-&amp;gt;open(file =&amp;gt; $file, type =&amp;gt; $type) ) {
        if ( $xsize ) {
          $img = $img-&amp;gt;scale( xpixels =&amp;gt; $xsize )
            unless $img-&amp;gt;getwidth &amp;lt; $xsize;
        }
        if ( $ysize ) {
          $img = $img-&amp;gt;scale( ypixels =&amp;gt; $ysize )
            unless $img-&amp;gt;getheight &amp;lt; $ysize;
        }

        my $img_data;
        $img-&amp;gt;write(data =&amp;gt; \$img_data, type =&amp;gt; $type);
        $m-&amp;gt;cache-&amp;gt;set( $key =&amp;gt; $img_data );
        $send_img-&amp;gt;($type, $img_data);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the heart and soul of image manipulation. The first step is to create a new &lt;code&gt;Imager&lt;/code&gt; object. Next we try to open the image &lt;code&gt;$file&lt;/code&gt;. If that succeeds, we can proceed to scaling the image.&lt;/p&gt;

&lt;p&gt;When scaling, it&amp;rsquo;s more important (to me) that the height of the image is exactly how I want it, so width is scaled first. Before the image is scaled its size is tested against the size of the image to be created. No scaling should occur if the image is smaller than the preferred size.&lt;/p&gt;

&lt;p&gt;Once scaling has finished the image data can be extracted from the &lt;code&gt;Imager&lt;/code&gt; object. When calling &lt;code&gt;write()&lt;/code&gt; on the object we can pass a &lt;code&gt;data&lt;/code&gt; option to let &lt;code&gt;Imager&lt;/code&gt; write to a scalar reference. After the image data has been retrieved it is placed in the cache using the same &lt;code&gt;$key&lt;/code&gt; that we first used when attempting to get information out of the cache. Finally, the image is sent out and the request is aborted.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    warn &amp;quot;[$file] [$image/$type] &amp;quot; . $img-&amp;gt;errstr;
    $m-&amp;gt;abort(500);
  &amp;lt;/%init&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the event that &lt;code&gt;Imager&lt;/code&gt; wasn&amp;rsquo;t able to open the &lt;code&gt;$file&lt;/code&gt;, the request should be aborted with a &lt;code&gt;500&lt;/code&gt; HTTP status code, &lt;em&gt;Internal Server Error&lt;/em&gt;. Before abortion, however, it would be useful to get some information in the &lt;em&gt;error_log&lt;/em&gt;. The requested &lt;code&gt;$file&lt;/code&gt;, its type information, and the error produced by &lt;code&gt;Imager&lt;/code&gt; are all printed to &lt;code&gt;STDOUT&lt;/code&gt; via &lt;code&gt;warn&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-what-it-looks-like-what-it-looks-like-span&#34;&gt;&lt;span id=&#34;What_It_Looks_Like&#34;&gt;What It Looks Like&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;For the less adventurous, yet overly curious members of the audience, a screenshot of our photo gallery follows.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2004_04_01_masongal/figure_0.jpg&#34; alt=&#34;Photo Gallery Screenshot&#34; width=&#34;450&#34; height=&#34;285&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As an aside, that image was originally much larger, but I really wanted it to be just &lt;code&gt;450&lt;/code&gt; pixels wide. I don&amp;rsquo;t have any image manipulation tools to do that job, but I do have &lt;code&gt;Imager&lt;/code&gt;. Thanks to &lt;code&gt;Imager&lt;/code&gt;, it took me 30 seconds to whip up the following command line snippet.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  perl -MImager -le&#39;Imager-&amp;gt;new-&amp;gt;open(file=&amp;gt;shift,type=&amp;gt;&amp;quot;jpeg&amp;quot;)
    -&amp;gt;scale(xpixels=&amp;gt;450)
    -&amp;gt;write(file=&amp;gt;shift,type=&amp;gt;&amp;quot;jpeg&amp;quot;)&#39; figure_0.jpg figure_0_0.jpg
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-conclusion-conclusion-span&#34;&gt;&lt;span id=&#34;Conclusion&#34;&gt;Conclusion&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ve just created a photo gallery that takes all the hard work out of maintaining photo galleries. There&amp;rsquo;s no need to pre-generate HTML or thumbnails. There&amp;rsquo;s no web application interface so you don&amp;rsquo;t have to change ownership of your gallery directory to the same user that Apache runs as. Using Mason&amp;rsquo;s built-in caching, photo galleries are nearly as fast as accessing the data directly from the file system. Well, at least on the second request. Our galleries have paging and infinite sub-galleries. Most importantly, using Mason to its full potential has given us a fully customizable, very tiny web application that can be dropped into any existing web site or framework.&lt;/p&gt;

&lt;p&gt;In fact, this code is the majority of the &lt;em&gt;faceplant&lt;/em&gt; project. The source code can be downloaded from &lt;a href=&#34;https://metacpan.org/pod/faceplant&#34;&gt;faceplant on MetaCPAN&lt;/a&gt;. &lt;em&gt;faceplant&lt;/em&gt; implements a few more features and is a bit more customizable. As such, its code is an excellent follow-up to this article. Go forth, now, and plant thy face on the Internet!
&amp;ldquo; &amp;gt;}}&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Programming with Mason</title>
      <link>http://localhost:1313/pub/2002/12/11/mason.html/</link>
      <pubDate>Wed, 11 Dec 2002 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2002/12/11/mason.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Dave Rolsky and Ken Williams are the authors of &lt;a href=&#34;http://www.oreilly.com/catalog/perlhtmlmason/&#34;&gt;Embedding Perl in HTML with Mason&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Mason is a powerful framework for generating dynamic text, and is especially useful when creating complex, featureful Web sites. For those (hopefully few) folks who haven&amp;rsquo;t yet heard of Mason, it is a Perl-based templating framework comparable to frameworks such as Apache::ASP, Embperl, and Template Toolkit. Like the first two, and unlike the latter, Mason operates by embedding Perl in text.&lt;/p&gt;

&lt;p&gt;Mason is based around the idea of a &lt;em&gt;component&lt;/em&gt;. A component is roughly equivalent to a Perl subroutine, and can contain text and/or code. Here is a &lt;em&gt;very&lt;/em&gt; simple, but complete component that has both text and code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; % my $planet = &amp;quot;World&amp;quot;;
 Hello, &amp;lt;% $planet %&amp;gt;!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When Mason runs this code, the output is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; Hello, World!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The rest of this article assumes at least a minimal familiarity with Mason, though if you&amp;rsquo;re at all familiar with other templating systems, you&amp;rsquo;ll probably be able to grok the code we show. For more details, I would of course recommend &lt;em&gt;Embedding Perl in HTML with Mason&lt;/em&gt;, written by Ken Williams and myself. Mason also comes with its own documentation, which can be seen online at &lt;a href=&#34;http://www.masonhq.com/&#34;&gt;www.masonhq.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As with any powerful and flexible system, Mason is applicable to a lot of problems, and there is always more than one way to do it. It is a &lt;em&gt;Perl&lt;/em&gt;-based system, after all!&lt;/p&gt;

&lt;p&gt;Below you&amp;rsquo;ll find some cookbook recipes for solving a few typical Web application problems. All the recipes assume that you are using the latest version of Mason, which at the time of this writing is 1.15, though most of them will work untouched with older versions.&lt;/p&gt;

&lt;h3 id=&#34;putting-a-session-id-in-all-urls&#34;&gt;Putting a Session ID in All URLs&lt;/h3&gt;

&lt;p&gt;If you&amp;rsquo;ve ever written a dynamic Web application, then it&amp;rsquo;s likely that you&amp;rsquo;ve used sessions to store data as the user moves through the application. Typically, sessions are identified by session IDs that are stored in a cookie.&lt;/p&gt;

&lt;p&gt;If you cannot use cookies, then you can store the session ID in the URL. There are security and application problems with this approach (as well as with the user of cookies), but those are outside the scope of this article. The mod_perl user list archives at &lt;a href=&#34;http://marc.theaimsgroup.com/?l=apache-modperl&#34;&gt;marc.theaimsgroup.com/?l=apache-modperl&lt;/a&gt; contain a number of discussions related to this topic.&lt;/p&gt;

&lt;p&gt;Putting the session ID in the URL can be a hassle, because it means that you have to somehow process all the URLs you generate. Using Mason, this isn&amp;rsquo;t as difficult as it would be otherwise. There are at least two ways to do this.&lt;/p&gt;

&lt;p&gt;The first would be to put a filter in your top level &lt;code&gt;autohandler&lt;/code&gt; component:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%filter&amp;gt;
   s/href=&amp;quot;([^&amp;quot;])+&amp;quot;/&#39;href=&amp;quot;&#39; . add_session_id($1) . &#39;&amp;quot;&#39;/eg;
   s/action=&amp;quot;([^&amp;quot;])+&amp;quot;/&#39;href=&amp;quot;&#39; . add_session_id($1) . &#39;&amp;quot;&#39;/eg;
  &amp;lt;/%filter&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;add_session_id()&lt;/code&gt; subroutine, which should be defined in a module, might look something like this:
      sub add_session_id {
          my $url = shift;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      return $url if $url =~ m{^\w+://}; # Don&#39;t alter external URLs

      if ($url =~ /\?/) {
      $url =~ s/\?/?session_id=$MasonBook::Session{_session_id}&amp;amp;/;
      } else {
          $url .= &amp;quot;?session_id=$MasonBook::Session{_session_id}&amp;quot;;
      }

      return $url;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This routine accounts for external links as well as links with or without an existing query string.&lt;/p&gt;

&lt;p&gt;The drawback to putting this in a &lt;code&gt;&amp;lt;%filter&amp;gt;&lt;/code&gt; section is that it only filters URLs in the content generated by components, and misses any URLs that might be in headers, such as in a redirect. Therefore, you&amp;rsquo;d need to handle those cases separately with this solution.&lt;/p&gt;

&lt;p&gt;Another solution would be to create all URLs (including those intended for redirects) via a dedicated component or subroutine that adds the session id. This latter solution is probably a better idea, as it handles redirects properly. The drawback with this strategy is that you&amp;rsquo;ll have a Mason component call for every link, instead of just regular HTML.&lt;/p&gt;

&lt;p&gt;Here is just such a component:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%args&amp;gt;
   $scheme   =&amp;gt; &#39;http&#39;
   $username =&amp;gt; undef
   $password =&amp;gt; &#39;&#39;
   $host     =&amp;gt; undef
   $port     =&amp;gt; undef
   $path
   %query    =&amp;gt; ()
   $fragment =&amp;gt; undef
  &amp;lt;/%args&amp;gt;
  &amp;lt;%init&amp;gt;
   my $uri = URI-&amp;gt;new;

   if ($host) {
       $uri-&amp;gt;scheme($scheme);

       if (defined $username) {
           $uri-&amp;gt;authority( &amp;quot;$username:$password&amp;quot; );
       }

       $uri-&amp;gt;host($host);
       $uri-&amp;gt;port($port) if $port;
   }

   # Sometimes we may want to include a path in a query string as part
   # of the path but the URI module will escape the question mark.
   my $q;

   if ( $path =~ s/\?(.*)$// ) {
       $q = $1;
   }

   $uri-&amp;gt;path($path);

   # If there was a query string, we integrate it into the query
   # parameter.
   if ($q) {
       %query = ( %query, split /[&amp;amp;=]/, $q );
   }

   $query{session_id} = $UserSession{session_id};

   # $uri-&amp;gt;query_form doesn&#39;t handle hash ref values properly
   while ( my ( $key, $value ) = each %query ) {
       $query{$key} = ref $value eq &#39;HASH&#39; ? [ %$value ] : $value;
   }

   $uri-&amp;gt;query_form(%query) if %query;

   $uri-&amp;gt;fragment($fragment) if $fragment;
  &amp;lt;/%init&amp;gt;
  &amp;lt;% $uri-&amp;gt;canonical | n %&amp;gt;\
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you didn&amp;rsquo;t want to put the session ID in the query string, then you might instead make it part of the URL path. The application could retrieve the session id from incoming requests by using a mod_perl handler during the URL translation stage of request handling.&lt;/p&gt;

&lt;p&gt;This component provides a programmatic interface to URL generation. Here is an example of how to use it, assuming that you&amp;rsquo;ve saved it as a component called &lt;code&gt;/url&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   ... some HTML ...
   Look at &amp;lt;a href=&amp;quot;&amp;lt;&amp;amp; /url, path =&amp;gt; &amp;quot;books.html&amp;quot; &amp;amp;&amp;gt;&amp;quot;&amp;gt;our books&amp;lt;/a&amp;gt;
   or &amp;lt;a href=&amp;quot;&amp;lt;&amp;amp; /url, host =&amp;gt; &amp;quot;www.oreilly.com&amp;quot;
                        path =&amp;gt; &amp;quot;/catalog&amp;quot; &amp;amp;&amp;gt;&amp;quot;&amp;gt;O&#39;Reilly&#39;s&amp;lt;/a&amp;gt;.
   ... some HTML ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;making-use-of-autoflush&#34;&gt;Making Use of Autoflush&lt;/h3&gt;

&lt;p&gt;Every once in a while, you may have to output a very large component or a file to the client. If you simply let this accumulate in the output buffer, you could use up a lot of memory. Furthermore, the slow response time may make the user think that the site has stalled.&lt;/p&gt;

&lt;p&gt;Here is an example that sends out the contents of a potentially large file without sucking up lots of memory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%args&amp;gt;
   $filename
  &amp;lt;/%args&amp;gt;
  &amp;lt;%init&amp;gt;
   local *FILE;
   open FILE, &amp;quot;&amp;lt; $filename&amp;quot; or die &amp;quot;Cannot open $filename: $!&amp;quot;;
   $m-&amp;gt;autoflush(1);
   while (&amp;lt;FILE&amp;gt;) {
       $m-&amp;gt;print($_);
   }
   $m-&amp;gt;autoflush(0);
  &amp;lt;/%init&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If each line wasn&amp;rsquo;t too huge, then you might just flush the buffer every once in a while:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%args&amp;gt;
   $filename
  &amp;lt;/%args&amp;gt;
  &amp;lt;%init&amp;gt;
   local *FILE;
   open FILE, &amp;quot;&amp;lt; $filename&amp;quot; or die &amp;quot;Cannot open $filename: $!&amp;quot;;
   while (&amp;lt;FILE&amp;gt;) {
       $m-&amp;gt;print($_);
       $m-&amp;gt;flush_buffer unless $. % 10;
   }
   $m-&amp;gt;flush_buffer;
  &amp;lt;/%init&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;unless $. % 10&lt;/code&gt; bit makes use of the special Perl variable &lt;code&gt;$.&lt;/code&gt;, which is the current line number of the file being read. If this number modulo 10 is equal to zero, then we flush the buffer. This means that we flush the buffer every 10 lines. (Replace the number 10 with any desired value.)&lt;/p&gt;

&lt;h3 id=&#34;user-authentication-and-authorization&#34;&gt;User Authentication and Authorization&lt;/h3&gt;

&lt;p&gt;One problem that Web sites have to solve over and over again is user authentication and authorization. These two topics are related but not the same, as some might think. Authentication is the process of figuring out if someone is who they say they are, and usually involves checking passwords or keys. Authorization comes after this, when we want to determine whether a particular person is allowed to perform a certain action.&lt;/p&gt;

&lt;p&gt;There are a number of modules on CPAN that are intended to help do these things under &lt;code&gt;mod_perl&lt;/code&gt;. In fact, Apache has separate request-handling phases for both authentication and authorization that &lt;code&gt;mod_perl&lt;/code&gt; can handle. It is certainly possible to use these modules with Mason.&lt;/p&gt;

&lt;p&gt;You can also do authentication and authorization using Mason components. Authentication will usually involve some sort of request for a login and a password, after which you give the user some sort of token (either in a cookie or a session) that indicates that they have been authenticated. You can then check the validity of this token for each request.&lt;/p&gt;

&lt;p&gt;If you have such a token, then authorization simply consists of checking that the user to whom the token belongs is allowed to perform a given action.&lt;/p&gt;

&lt;h3 id=&#34;using-apache-authcookie&#34;&gt;Using Apache::AuthCookie&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;Apache::AuthCookie&lt;/code&gt; module, available from CPAN, is a module that handles both authentication and authorization via &lt;code&gt;mod_perl&lt;/code&gt; and can be easily hooked into Mason. Rather than go through all the details of configuring &lt;code&gt;Apache::AuthCookie&lt;/code&gt;, which requires various settings in your server config file, let&amp;rsquo;s just skip all that and show you how you&amp;rsquo;d make the interface to Mason.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Apache::AuthCookie&lt;/code&gt; requires that you create a &amp;ldquo;login script&amp;rdquo; that will be executed the first time a browser tries to access a protected area. Calling this a script is actually somewhat misleading since it is really a page rather than a script (though it could be a script that generates a page). Regardless, using a Mason component for your &amp;ldquo;login script&amp;rdquo; merely requires that you specify the path to your Mason component for the login script parameter.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll call this &amp;ldquo;script&amp;rdquo; &lt;code&gt;AuthCookieLoginForm.comp&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
  &amp;lt;title&amp;gt;Mason Book AuthCookie Login Form&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
  &amp;lt;p&amp;gt;
  Your attempt to access this document was denied
  (&amp;lt;% $r-&amp;gt;prev-&amp;gt;subprocess_env(&amp;quot;AuthCookieReason&amp;quot;) %&amp;gt;).  Please enter
  your username and password.
  &amp;lt;/p&amp;gt;

  &amp;lt;form action=&amp;quot;/AuthCookieLoginSubmit&amp;quot;&amp;gt;
  &amp;lt;input type=&amp;quot;hidden&amp;quot; name=&amp;quot;destination&amp;quot; value=&amp;quot;&amp;lt;% $r-&amp;gt;prev-&amp;gt;uri %&amp;gt;&amp;quot;&amp;gt;
  &amp;lt;table align=&amp;quot;left&amp;quot;&amp;gt;
   &amp;lt;tr&amp;gt;
    &amp;lt;td align=&amp;quot;right&amp;quot;&amp;gt;&amp;lt;b&amp;gt;Username:&amp;lt;/b&amp;gt;&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;credential_0&amp;quot; size=&amp;quot;10&amp;quot; maxlength=&amp;quot;10&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
   &amp;lt;/tr&amp;gt;
   &amp;lt;tr&amp;gt;
    &amp;lt;td align=&amp;quot;right&amp;quot;&amp;gt;&amp;lt;b&amp;gt;Password:&amp;lt;/b&amp;gt;&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;&amp;lt;input type=&amp;quot;password&amp;quot; name=&amp;quot;credential_1&amp;quot; size=&amp;quot;8&amp;quot; maxlength=&amp;quot;8&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
   &amp;lt;/tr&amp;gt;
   &amp;lt;tr&amp;gt;
    &amp;lt;td colspan=&amp;quot;2&amp;quot; align=&amp;quot;center&amp;quot;&amp;gt;&amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Continue&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
   &amp;lt;/tr&amp;gt;
  &amp;lt;/table&amp;gt;
  &amp;lt;/form&amp;gt;

  &amp;lt;/body&amp;gt;
  &amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This component is modified version of the example login script included with the &lt;code&gt;Apache::AuthCookie&lt;/code&gt; distribution.&lt;/p&gt;

&lt;p&gt;The action used for this form, `&lt;code&gt;, is configured as part of your AuthCookie configuration in your&lt;/code&gt;httpd.conf` file.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s about all it takes to glue &lt;code&gt;Apache::AuthCookie&lt;/code&gt; and Mason together. The rest of authentication and authorization is handled by configuring &lt;code&gt;mod_perl&lt;/code&gt; to use &lt;code&gt;Apache::AuthCookie&lt;/code&gt; to protect anything on your site that needs authorization. A very simple configuration might include the following directives:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  PerlSetVar MasonBookLoginScript /AuthCookieLoginForm.comp

  &amp;lt;location /authcookieloginsubmit&amp;gt;
    AuthType MasonBook::AuthCookieHandler
    AuthName MasonBook
    SetHandler  perl-script
    PerlHandler MasonBook::AuthCookieHandler-&amp;gt;login
  &amp;lt;/location&amp;gt;

  &amp;lt;location /protected&amp;gt;
    AuthType MasonBook::AuthCookieHandler
    AuthName MasonBook
    PerlAuthenHandler MasonBook::AuthCookieHandler-&amp;gt;authenticate
    PerlAuthzHandler  MasonBook::AuthCookieHandler-&amp;gt;authorize
    require valid-user
  &amp;lt;/location&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;MasonBook::AuthCookieHandler&lt;/code&gt; module would look like this:
      package MasonBook::AuthCookieHandler;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use strict;

  use base qw(Apache::AuthCookie);

  use Digest::SHA1;

  my $secret = &amp;quot;You think I&#39;d tell you?  Hah!&amp;quot;;

  sub authen_cred {
      my $self = shift;
      my $r = shift;
      my ($username, $password) = @_;

      # implementing _is_valid_user() is out of the scope of this chapter
      if ( _is_valid_user($username, $password) ) {
          my $session_key =
            $username . &#39;::&#39; . Digest::SHA1::sha1_hex( $username, $secret );
          return $session_key;
      }
  }

  sub authen_ses_key {
      my $self = shift;
      my $r = shift;
      my $session_key = shift;

      my ($username, $mac) = split /::/, $session_key;

      if ( Digest::SHA1::sha1_hex( $username, $secret ) eq $mac ) {
          return $session_key;
      }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This provides the minimal interface an &lt;code&gt;Apache::AuthCookie&lt;/code&gt; subclass needs to provide to get authentication working.&lt;/p&gt;

&lt;h3 id=&#34;doing-it-my-way-thanks-frank&#34;&gt;Doing It My Way (Thanks Frank)&lt;/h3&gt;

&lt;p&gt;But what if you don&amp;rsquo;t want to use &lt;code&gt;Apache::AuthCookie&lt;/code&gt;? For example, your site may need to work without using cookies. No doubt this was exactly what Frank Sinatra was thinking about when he sang &amp;ldquo;My Way,&amp;rdquo; so let&amp;rsquo;s do it our way.&lt;/p&gt;

&lt;p&gt;First, we will show an example authentication system that only uses Mason and passes the authentication token around via the URL (actually, via a session).&lt;/p&gt;

&lt;p&gt;This example assumes that we already have some sort of session system that passes the session id around as part of the URL, as discussed previously.&lt;/p&gt;

&lt;p&gt;We start with a quick login form. We will call this component &lt;code&gt;login_form.html&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%args&amp;gt;
   $username =&amp;gt; &#39;&#39;
   $password =&amp;gt; &#39;&#39;
   $redirect_to =&amp;gt; &#39;&#39;
   @errors =&amp;gt; ()
  &amp;lt;/%args&amp;gt;
  &amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
  &amp;lt;title&amp;gt;Mason Book Login&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;

  &amp;lt;body&amp;gt;

  % if (@errors) {
  &amp;lt;h2&amp;gt;Errors&amp;lt;/h2&amp;gt;
  %   foreach (@errors) {
  &amp;lt;b&amp;gt;&amp;lt;% $_ | h %&amp;gt;&amp;lt;/b&amp;gt;&amp;lt;br&amp;gt;
  %   }
  % }

  &amp;lt;form action=&amp;quot;login_submit.html&amp;quot;&amp;gt;
  &amp;lt;input type=&amp;quot;hidden&amp;quot; name=&amp;quot;redirect_to&amp;quot; value=&amp;quot;&amp;lt;% $redirect_to %&amp;gt;&amp;quot;&amp;gt;
  &amp;lt;table align=&amp;quot;left&amp;quot;&amp;gt;
   &amp;lt;tr&amp;gt;
    &amp;lt;td align=&amp;quot;right&amp;quot;&amp;gt;&amp;lt;b&amp;gt;Login:&amp;lt;/b&amp;gt;&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;username&amp;quot; value=&amp;quot;&amp;lt;% $username %&amp;gt;&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
   &amp;lt;/tr&amp;gt;
   &amp;lt;tr&amp;gt;
    &amp;lt;td align=&amp;quot;right&amp;quot;&amp;gt;&amp;lt;b&amp;gt;Password:&amp;lt;/b&amp;gt;&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;&amp;lt;input type=&amp;quot;password&amp;quot; name=&amp;quot;password&amp;quot; value=&amp;quot;&amp;lt;% $password %&amp;gt;&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
   &amp;lt;/tr&amp;gt;
   &amp;lt;tr&amp;gt;
    &amp;lt;td colspan=&amp;quot;2&amp;quot; align=&amp;quot;center&amp;quot;&amp;gt;&amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Login&amp;quot;&amp;gt;&amp;lt;/td&amp;gt;
   &amp;lt;/tr&amp;gt;
  &amp;lt;/table&amp;gt;
  &amp;lt;/form&amp;gt;

  &amp;lt;/body&amp;gt;
  &amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This form uses some of the same techniques we show in Chapter 8 (&amp;ldquo;Building a Mason Site&amp;rdquo;) to pre-populate the form and to handle errors.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s make the component that handles the form submission. This component, called &lt;code&gt;login_submit.html&lt;/code&gt;, will check the username and password and, if they are valid, place an authentication token into the user&amp;rsquo;s session:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%args&amp;gt;
   $username
   $password
   $redirect_to
  &amp;lt;/%args&amp;gt;
  &amp;lt;%init&amp;gt;
   if (my @errors = check_login($username, $password) {
       $m-&amp;gt;comp( &#39;redirect.mas&#39;,
                  path =&amp;gt; &#39;login_form.html&#39;,
                  query =&amp;gt; { errors =&amp;gt; \@errors,
                             username =&amp;gt; $username,
                             password =&amp;gt; $password,
                             redirect_to =&amp;gt; $redirect_to } );
   }

   $MasonBook::Session{username} = $username;
   $MasonBook::Session{token} =
       Digest::SHA1::sha1_hex( &#39;My secret phrase&#39;, $username );

   $m-&amp;gt;comp( &#39;redirect.mas&#39;,
             path =&amp;gt; $redirect_to );
  &amp;lt;/%init&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This component simply checks (via magic hand waving) that the username and password are valid and if they are, it generates an authentication token, which is added to the user&amp;rsquo;s session. To generate this token, we take the username, which is also in the session, and combine it with a secret phrase. We then generate a MAC from those two things.&lt;/p&gt;

&lt;p&gt;The authentication and authorization check looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  if ( $MasonBook::Session{token} ) {
      if ( $MasonBook::Session{token} eq
           Digest::SHA1::sha1_hex( &#39;My secret phrase&#39;,
                                   $MasonBook::Session{username} ) {

          # R&amp;lt;... valid login, do something here&amp;gt;
      } else {
          # R&amp;lt;... someone is trying to be sneaky!&amp;gt;
      }
  } else { # no token
       my $wanted_page = $r-&amp;gt;uri;

       # Append query string if we have one.
       $wanted_page .= &#39;?&#39; . $r-&amp;gt;args if $r-&amp;gt;args;

       $m-&amp;gt;comp( &#39;redirect.mas&#39;,
                  path =&amp;gt; &#39;/login/login_form.html&#39;,
                  query =&amp;gt; { redirect_to =&amp;gt; $wanted_page } );
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We could put all the pages that require authorization in a single directory tree and have a top-level autohandler in that tree do the check. If there is no token to check, then we redirect the browser to the login page, and after a successful login they&amp;rsquo;ll return, assuming that they submit valid login credentials.&lt;/p&gt;

&lt;h3 id=&#34;access-controls-with-attributes&#34;&gt;Access Controls With Attributes&lt;/h3&gt;

&lt;p&gt;The components we saw previously assumed that there are only two access levels, unauthenticated and authenticated. A more complicated version of this code might involve checking that the user has a certain access level or role.&lt;/p&gt;

&lt;p&gt;In that case, we&amp;rsquo;d first check that we had a valid authentication token and then go on to check that the user actually had the appropriate access rights. This is simply an extra step in the authorization process.&lt;/p&gt;

&lt;p&gt;Using attributes, we can easily define access controls for different portions of our site. Let&amp;rsquo;s assume that we have four access levels, &amp;ldquo;Guest,&amp;rdquo; &amp;ldquo;User,&amp;rdquo; &amp;ldquo;Editor&amp;rdquo; and &amp;ldquo;Admin.&amp;rdquo; Most of the site is public, and viewable by anyone. Some parts of the site require a valid login, while some require a higher level of privilege.&lt;/p&gt;

&lt;p&gt;We implement our access check in our top-level autohandler, ``, from which all other components &lt;em&gt;must&lt;/em&gt; inherit in order for the access control code to be effective.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%init&amp;gt;
   my $user = get_user();  # again, hand waving

   my $required_access = $m-&amp;gt;base_comp-&amp;gt;attr(&#39;required_access&#39;);

   unless ( $user-&amp;gt;has_access_level($required_access) ) {
      # R&amp;lt;... do something like send them to another page&amp;gt;
   }

   $m-&amp;gt;call_next;
  &amp;lt;/%init&amp;gt;
  &amp;lt;%attr&amp;gt;
   required_access =&amp;gt; &#39;Guest&#39;
  &amp;lt;/%attr&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is crucial that we set a default access level in this autohandler. By doing this, we are saying that by default, all components are accessible by all people, since every visitor will have at least &amp;ldquo;Guest&amp;rdquo; access.&lt;/p&gt;

&lt;p&gt;We can override this default elsewhere. For example, in a component called &lt;code&gt;/admin/autohandler&lt;/code&gt;, we might have:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%attr&amp;gt;
   required_access =&amp;gt; &#39;Admin&#39;
  &amp;lt;/%attr&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As long as all the components in the &lt;code&gt;directory inherit from the&lt;/code&gt; component and don&amp;rsquo;t override the &lt;code&gt;required_access&lt;/code&gt; attribute, we have effectively limited that directory (and its subdirectories) to administration users only. If we, for some reason, had an individual component in the `` directory that we wanted editors to be able to see, we could simply set the &amp;ldquo;required_access&amp;rdquo; attribute for that component to &amp;ldquo;Editor.&amp;rdquo;&lt;/p&gt;

&lt;h3 id=&#34;managing-dbi-connections&#34;&gt;Managing DBI Connections&lt;/h3&gt;

&lt;p&gt;Not infrequently, we see people on the Mason users list asking questions about how to handle caching DBI connections.&lt;/p&gt;

&lt;p&gt;Our recipe for this is really simple:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use Apache::DBI
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rather than reinventing the wheel, use &lt;code&gt;Apache::DBI&lt;/code&gt;, which provides the following features:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;It is completely transparent to use. Once you&amp;rsquo;ve used it, you simply call &lt;code&gt;DBI-&amp;gt;connect()&lt;/code&gt; as always and &lt;code&gt;Apache::DBI&lt;/code&gt; gives you an existing handle if one is available.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It makes sure that the handle is live, so that if your RDBMS goes down and then back up, your connections still work just fine.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It does not cache handles made before Apache forks, as many DBI drivers do not support using a handle after a fork.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;generating-config-files&#34;&gt;Generating Config Files&lt;/h3&gt;

&lt;p&gt;Config files are a good candidate for generation by Mason. For example, your production and staging Web server config files might differ in only a few areas. Changes to one usually will need to be propagated to another. This is especially true with &lt;code&gt;mod_perl&lt;/code&gt;, where Web server configuration can basically be part of a Web-based application.&lt;/p&gt;

&lt;p&gt;On top of this, you may decide to set up a per-developer environment, either by having each developer run the necessary software on their own machine, or by starting Web servers on many different ports on a single development server. In this scenario, a template-driven config file generator becomes even more appealing.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a simple script to drive this generation. This script assumes that all the processes are running on one shared development machine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #!/usr/bin/perl -w

  use strict;

  use Cwd;
  use File::Spec;
  use HTML::Mason;
  use User::pwent;

  my $comp_root =
      File::Spec-&amp;gt;rel2abs( File::Spec-&amp;gt;catfile( cwd(), &#39;config&#39; ) );

  my $output;
  my $interp =
      HTML::Mason::Interp-&amp;gt;new( comp_root  =&amp;gt; $comp_root,
                out_method =&amp;gt; \$output,
                  );

  my $user = getpwuid($&amp;lt;);

  $interp-&amp;gt;exec( &#39;/httpd.conf.mas&#39;, user =&amp;gt; $user );

  my $file =  File::Spec-&amp;gt;catfile( $user-&amp;gt;dir, &#39;etc&#39;, &#39;httpd.conf&#39; );
  open FILE, &amp;quot;&amp;gt;$file&amp;quot; or die &amp;quot;Cannot open $file: $!&amp;quot;;
  print FILE $output;
  close FILE;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;httpd.conf.mas&lt;/code&gt; component might look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ServerRoot &amp;lt;% $user-&amp;gt;dir %&amp;gt;

  PidFile &amp;lt;% File::Spec-&amp;gt;catfile( $user-&amp;gt;dir, &#39;logs&#39;, &#39;httpd.pid&#39; ) %&amp;gt;

  LockFile &amp;lt;% File::Spec-&amp;gt;catfile( $user-&amp;gt;dir, &#39;logs&#39;, &#39;httpd.lock&#39; ) %&amp;gt;

  Port &amp;lt;% $user-&amp;gt;uid + 5000 %&amp;gt;

  # loads Apache modules, defines content type handling, etc.
  &amp;lt;&amp;amp; standard_apache_config.mas &amp;amp;&amp;gt;

  &amp;lt;perl&amp;gt;
   use lib &amp;lt;% File::Spec-&amp;gt;catfile( $user-&amp;gt;dir, &#39;project&#39;, &#39;lib&#39; ) %&amp;gt;;
  &amp;lt;/perl&amp;gt;

  DocumentRoot &amp;lt;% File::Spec-&amp;gt;catfile( $user-&amp;gt;dir, &#39;project&#39;, &#39;htdocs&#39; ) %&amp;gt;

  PerlSetVar MasonCompRoot &amp;lt;% File::Spec-&amp;gt;catfile( $user-&amp;gt;dir, &#39;project&#39;, &#39;htdocs&#39; ) %&amp;gt;
  PerlSetVar MasonDataDir &amp;lt;% File::Spec-&amp;gt;catfile( $user-&amp;gt;dir, &#39;mason&#39; ) %&amp;gt;

  PerlModule HTML::Mason::ApacheHandler

  &amp;lt;filesmatch &amp;quot;\.html$&amp;quot;&amp;gt;
   SetHandler perl-script
   PerlHandler HTML::Mason::ApacheHandler
  &amp;lt;/filesmatch&amp;gt;

  &amp;lt;%args&amp;gt;
  $user
  &amp;lt;/%args&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This points the server&amp;rsquo;s document root to the developer&amp;rsquo;s working directory. Similarly, it adds the &lt;code&gt;project/lib&lt;/code&gt; directory to Perl&amp;rsquo;s &lt;code&gt;@INC&lt;/code&gt; via &lt;code&gt;use lib&lt;/code&gt; so that the user&amp;rsquo;s working copy of the project&amp;rsquo;s modules are seen first. The server will listen on a port equal to the user&amp;rsquo;s user ID, plus 5,000.&lt;/p&gt;

&lt;p&gt;Obviously, this is an incomplete example. It doesn&amp;rsquo;t specify where logs will go, or other necessary config items. It also doesn&amp;rsquo;t handle generating the config file for a server intended to be run by the root user on a standard port.&lt;/p&gt;

&lt;h3 id=&#34;if-you-want-more&#34;&gt;If You Want More &amp;hellip;&lt;/h3&gt;

&lt;p&gt;These recipes were adapted from Chapter 11, &amp;ldquo;Recipes,&amp;rdquo; of &lt;em&gt;Embedding Perl in HTML With Mason&lt;/em&gt;. And, of course, the book contains a lot more than just recipes. If you&amp;rsquo;re interested in learning more about Mason, the book is a great place to start.&lt;/p&gt;

&lt;p&gt;Also, don&amp;rsquo;t forget to check out the Mason HQ site at &lt;a href=&#34;http://www.masonhq.com/&#34;&gt;www.masonhq.com/&lt;/a&gt;, which contains online documentation, user-contributed code and docs, and links to the Mason users mailing list, which is another great resource for developers using Mason.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;O&amp;rsquo;Reilly &amp;amp; Associates recently released (October 2002) &lt;a href=&#34;http://www.oreilly.com/catalog/perlhtmlmason/&#34;&gt;Embedding Perl in HTML with Mason&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.oreilly.com/catalog/perlhtmlmason/chapter/index.html&#34;&gt;Sample Chapter 5, Advanced Features&lt;/a&gt;, is available free online.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can also look at the [Table of Contents](), the [Index](), and the [Full Description]() of the book.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;For more information, or to order the book, [click here]().&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>

