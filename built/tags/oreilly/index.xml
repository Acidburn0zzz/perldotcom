<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Oreilly on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/oreilly/</link>
    <description>Recent content in Oreilly on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 25 Apr 2017 08:23:17 +0000</lastBuildDate>
    <atom:link href="/tags/oreilly/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Thinking about Perl 6</title>
      <link>http://localhost:1313/article/an-interview-with-laurent-rosenfeld/</link>
      <pubDate>Tue, 25 Apr 2017 08:23:17 +0000</pubDate>
      
      <guid>http://localhost:1313/article/an-interview-with-laurent-rosenfeld/</guid>
      <description>&lt;p&gt;&lt;em&gt;brian d foy interviews Laurent Rosenfeld, whose new book &lt;a href=&#34;http://shop.oreilly.com/product/0636920065883.do&#34;&gt;Think Perl 6&lt;/a&gt; from O&amp;rsquo;Reilly Media, comes out this summer and is available for pre-order. This book joins a series of &lt;a href=&#34;http://greenteapress.com/wp/think-python/&#34;&gt;Think &amp;hellip;&lt;/a&gt; books targeting different subjects and is provided for free under a &lt;a href=&#34;https://creativecommons.org/licenses/by-nc/3.0/&#34;&gt;Creative Commons license&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This article was made possible through a reward on brian&amp;rsquo;s &lt;a href=&#34;https://www.kickstarter.com/projects/1422827986/learning-perl-6&#34;&gt;Kickstarter project for Learning Perl 6&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What&amp;rsquo;s your Perl programming background? How did you discover the language, how did it help you solve problems, and what did you like about it?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(Laurent)&lt;/em&gt; I started to program in Perl 5 in 2002. At the time I was using mainly Python (and also a bit of TCL/TK) for my scripting needs.&lt;/p&gt;

&lt;p&gt;The integration and implementation team for which I started to work at the time was using a number of mostly relatively small Perl programs in the context of a data migration suite.&lt;/p&gt;

&lt;p&gt;Although I wasn&amp;rsquo;t working as a developer at the time, I felt it would be good to get to get acquainted to the language. So I picked up a tutorial on the Internet and started to work on it, and I found the language to be quite pleasant.&lt;/p&gt;

&lt;p&gt;At that point, we received some large improperly formatted data files that needed to be pre-processed before we could use them. I first thought about writing quickly a Python script and then changed my mind: since I was trying to learn about Perl, maybe I could try to write that script in Perl. Within a day or so, I had a Perl script doing what was needed. That script was probably quite clumsy, and certainly did not comply with the best practices, but it worked exactly as needed.&lt;/p&gt;

&lt;p&gt;I was quite impressed how easily I had been able to write a script for real professional use with the small subset of Perl that I knew at the time. I continued with Perl. It is really a few years later that I started to really consider Perl as a programming language, rather than simply a scripting language.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;When did you start with Perl 6?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I have made various tests and experiments with Perl 6 in 2012 and early 2013, but I started to work seriously with Perl 6 during the second half of 2013. I started to write about Perl 6 in 2014.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What are some of your favorite features of the new language?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Well, first that it belongs to the Perl family, with the same spirit (TIMTOWTDI, DWIM, etc.). This made it easy for me to learn it, even though Perl 5 and Perl 6 are different languages.&lt;/p&gt;

&lt;p&gt;Then the features I prefer are its powerful object model, the very good support for functional style programming, the enhanced regex features and grammars. I love the built-in possibilities of extending the languages, such as constructing new operators, extending the Perl 6 grammar, etc.&lt;/p&gt;

&lt;p&gt;The support for concurrent programming and parallel processing also seems to be great, but I have only played with that, I haven&amp;rsquo;t done anything serious with it at this point.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Your new book, &lt;em&gt;Think Perl 6&lt;/em&gt;, is based on a similar Python book. How did you discover that book? Were you doing Python at the time?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Many years ago I read the first edition of &lt;a href=&#34;http://greenteapress.com/wp/think-python/&#34;&gt;Think Python&lt;/a&gt; and had found it was a great book, because it wasn&amp;rsquo;t teaching Python, but rather teaching computer science and programming, using Python. This is the main idea of &lt;em&gt;Think Perl 6&lt;/em&gt;: teaching computer science using Perl 6.&lt;/p&gt;

&lt;p&gt;I have been using Python in the past, but I don&amp;rsquo;t remember if was using it regularly when I first read &lt;em&gt;Think Python&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How alike are the two books? Did you have to change much of the book to accommodate Perl 6?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The early chapters are quite similar (except of course for the code examples and differences in syntactic features).&lt;/p&gt;

&lt;p&gt;As I said, both books are about teaching computer programming more than teaching the specific language. So most of what is about the art of programming is quite similar. But when it comes to the languages&amp;rsquo; features, there are obviously some major differences.&lt;/p&gt;

&lt;p&gt;The chapter on strings, for example, is quite different because there is a long part on regular expressions or regexes in &lt;em&gt;Think Perl 6&lt;/em&gt;, whereas the Python book does not even mention them.&lt;/p&gt;

&lt;p&gt;The later chapters, such as those about object-oriented programming, grammars or functional programming are completely different or even brand new.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;You started translating &lt;em&gt;Think Python&lt;/em&gt; into French. What motivated you to do that?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;As I said, I had loved the first edition of that book. When friends of mine considered translating that book into French I strongly supported the idea.&lt;/p&gt;

&lt;p&gt;Initially, someone else (whom I knew well for having worked on other projects with her) started to translate the book, and I initially acted as a technical editor of the translation. Then I was dragged more into the project and translated myself the more technical parts.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What else have you translated?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I have translated a number of other things. Concerning items that have the size of a book, I should mention &lt;em&gt;Modern Perl&lt;/em&gt;, the book by chromatic, and I am currently working on the translation of a book about Scala.&lt;/p&gt;

&lt;p&gt;Besides that, I have translated many shorter tutorials and articles on various features of programming languages such as Perl 5, Perl 6, Python, C++, Go, etc., as well as various articles about big data and also some pieces on the Raspberry Pi.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Do you think about the subject differently in French than English? Do these spoken languages affect how you explain things?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;No, I don&amp;rsquo;t think that the human language I use affects the way I think. Sometimes I think in English when writing something in French, and sometimes the other way around, but, most of the time, I think in the language in which I will try to express myself. I even dream in both languages (although more frequently in French). I think that I am truly bilingual in the sense that I can really think in both languages with no real difference (although, of course, my command of English is less fluent than my command of French, my mother tongue).&lt;/p&gt;

&lt;p&gt;But the language I use does of course change to a certain extent the way to express ideas.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Think Perl 6&lt;/em&gt;&amp;rsquo;s subtitle is &amp;ldquo;Think Like a Computer Scientist&amp;rdquo;. Do you think that the programming world needs more academic rigor?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;More academic rigor, well, yes, in a certain way, but I am not sure that&amp;rsquo;s really what is lacking. A broader understanding of computer science is certainly needed. Sometimes I see people developing in one language, say PHP, and not really knowing any other language or any other way of doing things; that&amp;rsquo;s not very good. I tend to think you can&amp;rsquo;t really be a good programmer if you know only one language. I personally love programming languages and I have used at least three dozens of them over the last thirty years. I think it opens the mind to other approaches and better ways of doing things.&lt;/p&gt;

&lt;p&gt;I really agree with Tom Christiansen who said that a programmer that hasn&amp;rsquo;t been exposed to imperative or procedural programming, object-oriented programming, functional programming, and logical or declarative programming has some conceptual blindspots.&lt;/p&gt;

&lt;p&gt;And I also don&amp;rsquo;t think you can become a good programmer in just one semester or by simply reading &amp;ldquo;Programming X for Dummies.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What book has most influenced your programming habits?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Relatively recently, definitely &lt;em&gt;&lt;a href=&#34;http://hop.perl.plover.com&#34;&gt;Higher Order Perl&lt;/a&gt;&lt;/em&gt;, the book by Mark Jason Dominus about functional programming in Perl 5. It is probably, in my opinion, the best IT/CS book I&amp;rsquo;ve read in the last ten years. It has changed really the way I program not only in Perl, but also how I write code in other programming languages.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Which books using languages other than Perl have made you a better Perl programmer?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;It is hard to make a list and not to forget some important ones. Just naming a few, in no particular order: &lt;em&gt;The Practice of Programming&lt;/em&gt; (Kernighan and Pike), &lt;em&gt;Structure and Interpretation of Programming Languages&lt;/em&gt; (Abelson and Sussman), &lt;em&gt;Think Python&lt;/em&gt; (A. Downey), &lt;em&gt;Programming Pearls&lt;/em&gt; (Jon Bentley), &lt;em&gt;Mastering Regular Expressions&lt;/em&gt; (Jeffrey Friedl).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Even if someone isn&amp;rsquo;t going to work in Perl 6, what lessons from your book can people take to other languages?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Well, I certainly wish that people that use my book to learn programming will continue to program in Perl 6, but I&amp;rsquo;ll be very happy if they learned programming with my book and become good programmers in another languages.&lt;/p&gt;

&lt;p&gt;Personally, when I was studying, I had to use a number of programming languages that I never or seldom used afterwards for any real-life purpose (Basic, Fortran, Pascal, Lisp, Scheme, Caml, Ada, Prolog, Modula-2, etc.). But I learned quite a bit from them.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What future do you see in Perl 6?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I frankly don&amp;rsquo;t know. I think this language is really very good and efficient, but that&amp;rsquo;s not enough to become the leading language. There is an element of luck: is the language coming at the right time? Let&amp;rsquo;s face it: Perl 6 took way too long to come out. But that&amp;rsquo;s doesn&amp;rsquo;t matter too much if Perl 6 is the good match for today&amp;rsquo;s needs; I think it probably is. The good point about Perl 6 is that it can easily be extended; so, it is likely to satisfy not only current needs, but also tomorrow&amp;rsquo;s needs.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What future would you like to see in Perl 6?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I really think it is the greatest programming language I have seen so far. I hope people will start recognizing that.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>5 things I learned from Learning Perl 7th Edition</title>
      <link>http://localhost:1313/article/5-things-i-learned-from-learning-perl-7th-edition/</link>
      <pubDate>Fri, 23 Sep 2016 08:12:54 +0000</pubDate>
      
      <guid>http://localhost:1313/article/5-things-i-learned-from-learning-perl-7th-edition/</guid>
      <description>

&lt;p&gt;The 7th edition of &lt;a href=&#34;https://www.learning-perl.com/&#34;&gt;Learning Perl&lt;/a&gt; is due to be released later this month. I was one of the technical reviewers of the book - I hadn&amp;rsquo;t read it since the 3rd edition where it was a course text at my University (and Perl was described as a &amp;ldquo;text processing language&amp;rdquo;!). Reviewing the book, I was struck by how much detail it contained. If you&amp;rsquo;re looking for a thorough introduction to Perl, it&amp;rsquo;s a great place to start. I picked up (or re-learned) a few tricks along the way, that I thought were worth sharing.&lt;/p&gt;

&lt;h3 id=&#34;1-stacked-file-test-operators&#34;&gt;1. Stacked file test operators&lt;/h3&gt;

&lt;p&gt;You probably know that Perl supports a bunch of &lt;a href=&#34;https://perldoc.perl.org/functions/-X.html&#34;&gt;file test operators&lt;/a&gt; that do useful things like check if a file exists, if it&amp;rsquo;s readable and so on:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;e $filepath &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;r $filepath) {
    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
  }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But did you know that since version 5.10, you can stack file test operators?&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;e &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;r $filepath) {
    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
  }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This way is cleaner and shorter. Oh and bonus! file test operators work on filehandles too. Stacked file operators are not part of the &lt;a href=&#34;https://perldoc.perl.org/feature.html&#34;&gt;feature&lt;/a&gt; pragma, so an explicit &lt;code&gt;use 5.10.0;&lt;/code&gt; is not required, although if your code is going to be shared, you should probably include it.&lt;/p&gt;

&lt;h3 id=&#34;2-glob-s-checkered-past&#34;&gt;2. Glob&amp;rsquo;s checkered past&lt;/h3&gt;

&lt;p&gt;Learning Perl has a lot of anecdotes about Perl history in it. You might have used the &lt;code&gt;glob&lt;/code&gt; function before:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @json_files &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; glob &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;*.json&amp;#39;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This returns all file names ending in &lt;code&gt;.json&lt;/code&gt; in the current working directory. Glob takes a string of patterns separated by whitespace, so you can provide multiple patterns:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @config_files &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; glob &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;*.json *.toml *.ini&amp;#39;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Instead of using the word &lt;code&gt;glob&lt;/code&gt; you can use angle brackets:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @json_files &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;lt;*.json&amp;gt;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;These angle brackets treat the text between them like a double-quoted string. One thing I learned was that ancient versions of Perl (pre 5.6) simply called &lt;code&gt;/bin/csh&lt;/code&gt; every time they encountered &lt;code&gt;glob&lt;/code&gt;! This made globbing slow, and directory handles were preferred over &lt;code&gt;glob&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;3-perl-supports-inline-binary-notation&#34;&gt;3. Perl supports inline binary notation&lt;/h3&gt;

&lt;p&gt;In many C-based languages you can write numbers in hexadecimal and octal notation, and you can in Perl too:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $byte_max &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0xff&lt;/span&gt;;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $permissions &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0755&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In Perl though, you can also write binary numbers inline, with the prefix &lt;code&gt;0b&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $bits &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b10111000&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This can make it easier to work with binary data; instead of using hexadecimal notation and doing the mental arithmetic to calculate values, you can write binary data inline. For example, let&amp;rsquo;s say you are reviewing some code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ($bit_array &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x40&lt;/span&gt;) {
    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
  }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To understand this example in hexadecimal, you have to calculate that 4 * 16 = 64, and then either just know, or convert that number to binary to find out that the 7th bit is flipped, and understand that this is testing whether &lt;code&gt;$bit_array&lt;/code&gt; has that bit flipped too. Here&amp;rsquo;s the same code with inline binary:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ($bit_array &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b1000000&lt;/span&gt;) {
    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
  }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this example, you can just see that the 7th bit is flipped, and the intent of the if statement becomes obvious. If you&amp;rsquo;re interested in understanding bit arrays and bitwise operators, I recently wrote an &lt;a href=&#34;http://localhost:1313/article/save-space-with-bit-arrays/&#34;&gt;introduction&lt;/a&gt; to them.&lt;/p&gt;

&lt;h3 id=&#34;4-check-an-installed-module-is-up-to-date&#34;&gt;4. Check an installed module is up to date&lt;/h3&gt;

&lt;p&gt;These days we have so many advanced Perl package installers like &lt;a href=&#34;https://metacpan.org/pod/App::cpanminus&#34;&gt;cpanm&lt;/a&gt; and &lt;a href=&#34;https://metacpan.org/pod/distribution/App-cpm/script/cpm&#34;&gt;cpm&lt;/a&gt; it&amp;rsquo;s easy to forget that the basic CPAN client can do a lot too. For instance, the &lt;code&gt;-D&lt;/code&gt; option checks the installed version of a module and compares it to the latest version on CPAN. So to check if the &lt;code&gt;Test::More&lt;/code&gt; module is up to date, at the terminal I can enter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cpan -D Test::More

CPAN: Storable loaded ok (v2.53)
Reading &#39;/home/dfarrell/.local/share/.cpan/Metadata&#39;
  Database was generated on Thu, 22 Sep 2016 21:53:30 GMT
Test::More
-------------------------------------------------------------------------
      (no description)
      E/EX/EXODIST/Test-Simple-1.302056.tar.gz
      /home/dfarrell/.plenv/versions/5.22.0/lib/perl5/5.22.0/Test/More.pm
      Installed: 1.001014
      CPAN:      1.302056  Not up to date
      Chad Granum (EXODIST)
      exodist7@gmail.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Woah, mine is pretty out of date. I should upgrade &amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;5-avoiding-the-shell-for-system-commands&#34;&gt;5. Avoiding the shell for system commands&lt;/h3&gt;

&lt;p&gt;The Perl built-in functions &lt;a href=&#34;https://perldoc.perl.org/functions/exec.html&#34;&gt;exec&lt;/a&gt; and &lt;a href=&#34;https://perldoc.perl.org/functions/system.html&#34;&gt;system&lt;/a&gt; &lt;em&gt;may&lt;/em&gt; invoke the shell when running a system command. Generally you want to avoid this as invoking the shell is slower than executing the command directly. Perl looks at the first argument passed to &lt;code&gt;exec&lt;/code&gt; or &lt;code&gt;system&lt;/code&gt; and if it contains shell &lt;a href=&#34;http://faculty.salina.k-state.edu/tim/unix_sg/shell/metachar.html&#34;&gt;metacharacters&lt;/a&gt; invokes the shell.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $command &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; join &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;, $program, $arg1, $arg2;
system $command; &lt;span style=&#34;color:#75715e&#34;&gt;# may invoke shell&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So let&amp;rsquo;s say you need to invoke a system command, and you&amp;rsquo;re not sure whether the command arguments will contain metacharacters or not. If they do, the shell will be invoked and any metacharacters will be interpolated. One way to avoid the shell interpolating metacharacters is to escape them. But shell escape sequences are rarely simple (e.g. &lt;a href=&#34;https://stackoverflow.com/questions/1250079/how-to-escape-single-quotes-within-single-quoted-strings#1250279&#34;&gt;escaping a single quote&lt;/a&gt;). Learning Perl shows a better way: passing a list.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;system $program, $arg1, $arg2; &lt;span style=&#34;color:#75715e&#34;&gt;# never invokes the shell&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This will never invoke the shell, and avoid metacharacter interpolation.&lt;/p&gt;

&lt;h3 id=&#34;pre-order-learning-perl-now&#34;&gt;Pre-order Learning Perl now&lt;/h3&gt;

&lt;p&gt;Learning Perl 7th Edition has nearly 400 pages describing the Perl syntax, and how to accomplish important tasks like file IO, process management and module installations. It&amp;rsquo;s available for pre-order now on &lt;a href=&#34;https://goo.gl/DvCB14&#34;&gt;Amazon&lt;/a&gt; (that&amp;rsquo;s an affiliate link for brian d foy, the author of this edition). You can also get it from the publisher, &lt;a href=&#34;http://shop.oreilly.com/product/0636920049517.do&#34;&gt;O&amp;rsquo;Reilly&lt;/a&gt;. Check out the book&amp;rsquo;s offical &lt;a href=&#34;https://www.learning-perl.com/&#34;&gt;website&lt;/a&gt; where brian has been blogging about the new edition.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Understanding Haskell types</title>
      <link>http://localhost:1313/article/198/2015/10/14/Understanding-Haskell-types/</link>
      <pubDate>Wed, 14 Oct 2015 12:47:18 +0000</pubDate>
      
      <guid>http://localhost:1313/article/198/2015/10/14/Understanding-Haskell-types/</guid>
      <description>

&lt;p&gt;I recently took a break from Perl work to study at the &lt;a href=&#34;http://recurse.com&#34;&gt;Recurse Center&lt;/a&gt;. I&amp;rsquo;m learning Haskell, and it&amp;rsquo;s been an interesting adventure so far. I&amp;rsquo;d heard good things about Haskell&amp;rsquo;s type system and started with an introductory book &lt;a href=&#34;http://learnyouahaskell.com/&#34;&gt;Learn You a Haskell for Great Good!&lt;/a&gt;. The book is filled with cartoonish humor - &amp;ldquo;how hard can this be?&amp;rdquo; I asked myself. The answer was &amp;ldquo;hard&amp;rdquo;. I found Haskell&amp;rsquo;s type system to be counter-intuitive, so this article lays out my understanding of Haskell types. If you&amp;rsquo;re a programmer with an imperative programming background, you might find this useful.&lt;/p&gt;

&lt;h3 id=&#34;your-intuition-is-wrong&#34;&gt;Your intuition is wrong&lt;/h3&gt;

&lt;p&gt;For imperative-language programmers, Haskell keywords are likely to mislead. Take the &lt;code&gt;type&lt;/code&gt; keyword for instance. It&amp;rsquo;s not for creating new types per se, but &lt;em&gt;type synonyms&lt;/em&gt;, which are like aliases for existing types. I might use it like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;type FirstName &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; String
type LastName &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; String
type Age &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Int&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;One way to declare new types is with the &lt;code&gt;data&lt;/code&gt; keyword (naturally!). If I wanted to create a person type, I could use &lt;code&gt;data&lt;/code&gt; :&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;data Person &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Person String String Int&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This declares a new type called &lt;code&gt;Person&lt;/code&gt; with 2 strings and 1 integer as attributes. But I could also use our type synonyms from the earlier example, and clarify my intentions:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;data Person &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Person FirstName LastName Age&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;functions-and-types&#34;&gt;Functions and types&lt;/h3&gt;

&lt;p&gt;In Haskell function signatures can be restricted by types. I can create a function to tell which of two people is older:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;eldest &lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt; Person &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; Person &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; String
eldest (Person x1 y1 z1) (Person x2 y2 z2)
  &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; z1 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; z2   &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x1 &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; y1 &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; is older&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; z1 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; z2   &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x2 &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; y2 &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; is older&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; otherwise &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;They&amp;#39;re the same age!&amp;#34;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is a lot of new syntax, so bear with me. The first line declares a function called &lt;code&gt;eldest&lt;/code&gt; which takes two persons and returns a string. The second line assigns the attributes of each person to variables. The rest of the function tests which person is older and returns an appropriate message. I&amp;rsquo;ll save all of this code into a file called &amp;ldquo;person.hs&amp;rdquo;, so I can test the function in the Haskell REPL, &lt;code&gt;ghci&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;ghci&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; :l person&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;hs
[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; of &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] Compiling Main             ( person&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;hs, interpreted )
Ok, modules loaded: Main&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;
ghci&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; let a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Person &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Bart&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Simpson&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
ghci&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; let b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Person &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Lisa&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Simpson&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;
ghci&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; eldest a b
&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Bart Simpson is older&amp;#34;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Sometimes we don&amp;rsquo;t need to access all of the attributes of a type in a function. In these cases Haskell let&amp;rsquo;s you use &lt;code&gt;_&lt;/code&gt; as a placeholder, that won&amp;rsquo;t be assigned to a variable. For example to print the initials of a person, I only need to know their first and last names:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;initials &lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt; Person &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; String
initials (Person x y _) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [head x,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.&amp;#39;&lt;/span&gt;,head y, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.&amp;#39;&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The second line of code assigns a person&amp;rsquo;s firstname to &lt;code&gt;x&lt;/code&gt; and lastname to &lt;code&gt;y&lt;/code&gt;. It then takes the first char of each using &lt;code&gt;head&lt;/code&gt; and returns a new list of chars with a dot after each char. I can test the function by reloading &amp;ldquo;person.hs&amp;rdquo;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;ghci&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; :l person&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;hs
[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; of &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] Compiling Main             ( person&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;hs, interpreted )
Ok, modules loaded: Main&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;
ghci&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; let a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Person &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Maggie&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Simpson&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
ghci&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; initials a
&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;M.S.&amp;#34;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;typeclasses&#34;&gt;Typeclasses&lt;/h3&gt;

&lt;p&gt;Typeclasses are similar to traits (roles in Perl-speak) for types. For example, integers are instances of typeclasses like &lt;code&gt;Ord&lt;/code&gt; as they are orderable, &lt;code&gt;Num&lt;/code&gt; as they are numbers, and so on. Each typeclass defines functions for handling types in specific contexts. The &lt;code&gt;Eq&lt;/code&gt; typeclass adds the ability to compare types for equality using operators like &lt;code&gt;==&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;By generalizing the properties of types with typeclasses, Haskell can support generic functions which operate on typeclasses, instead of being restricted to one type. The signature of the &lt;code&gt;quicksort&lt;/code&gt; function from &lt;a href=&#34;http://learnyouahaskell.com/recursion&#34;&gt;Learn You a Haskell&lt;/a&gt; is a great example of this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;quicksort &lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt; (Ord a) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; [a] &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; [a]
quicksort &lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt;
quicksort (x:xs) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;·&lt;/span&gt;
    let smallerSorted &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; quicksort [a &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;-&lt;/span&gt; xs, a &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; x]
        biggerSorted &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; quicksort [a &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;-&lt;/span&gt; xs, a &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; x]
    in  smallerSorted &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; [x] &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; biggerSorted&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This declares a new function called quicksort which is restricted to lists of orderable types. Ignore the body and just focus on the first line of code, the function signature. The code &lt;code&gt;(Ord a)&lt;/code&gt; defines the typeclass constraint for the function. This function can be used to sort anything orderable, like lists of numbers. Aren&amp;rsquo;t strings just lists of chars? I guess we can sort them with &lt;code&gt;quicksort&lt;/code&gt; too then.&lt;/p&gt;

&lt;h3 id=&#34;instance-and-class&#34;&gt;Instance and Class&lt;/h3&gt;

&lt;p&gt;If you saw the &lt;code&gt;instance&lt;/code&gt; keyword in some Haskell code, you might think &amp;ldquo;aha, a singleton constructor!&amp;rdquo; but actually &lt;code&gt;instance&lt;/code&gt; is used to make types instances of typeclasses. This makes sense when you consider that every type is an &lt;strong&gt;instance&lt;/strong&gt; of a typeclass. Revisiting my &lt;code&gt;Person&lt;/code&gt; type from earlier, what if I wanted to make it orderable? Typically in the English-speaking parts of the world, people are sorted by their last name, so I&amp;rsquo;m going to implement it that way:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;data Person &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Person FirstName LastName Age deriving (Eq, Show)

instance Ord Person where
  compare (Person _ a _) (Person _ b _) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; compare a b&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I start by updating the type declaration of Person with &lt;code&gt;deriving (Eq, Show)&lt;/code&gt;. These operate on the whole type (all of its attributes together). &lt;code&gt;Eq&lt;/code&gt; will let Haskell compare Persons for equality and &lt;code&gt;Show&lt;/code&gt; just let&amp;rsquo;s Haskell serialize the type as a string. The second line of code uses &lt;code&gt;instance&lt;/code&gt; to make persons orderable. The final line implements a comparison function using the lastname attribute of the Person. I can test the code using the &lt;code&gt;quicksort&lt;/code&gt; function declared above.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;ghci&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; :l person&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;hs
[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; of &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] Compiling Main             ( person&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;hs, interpreted )
Ok, modules loaded: Main&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;
ghci&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; let a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Person &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Jason&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Bourne&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;37&lt;/span&gt;
ghci&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; let b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Person &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;James&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Bond&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt;
ghci&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; quicksort [a,b]
[Person &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;James&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Bond&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;43&lt;/span&gt;,Person &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Jason&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Bourne&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;37&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This sorted our list of people by their lastname, and because &lt;code&gt;Person&lt;/code&gt; is an instance of &lt;code&gt;Show&lt;/code&gt;, Haskell was able to print out the detail to the command line. Not bad!&lt;/p&gt;

&lt;p&gt;The final keyword to be aware of is &lt;code&gt;class&lt;/code&gt;. By now it shouldn&amp;rsquo;t surprise you to find out that &lt;code&gt;class&lt;/code&gt; is not for declaring classes like in imperative programming, but for creating new typeclasses. You probably won&amp;rsquo;t use this much when starting out with Haskell, but it&amp;rsquo;s useful to keep in mind for reducing repetitive code. If you have multiple sets of code doing very similar things for different types, consider creating a new typeclass and merging the functions to operate on the new type class, to keep things &lt;a href=&#34;https://en.wikipedia.org/wiki/Don&#39;t_repeat_yourself&#34;&gt;DRY&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;code-complete&#34;&gt;Code complete&lt;/h3&gt;

&lt;p&gt;This is the finished code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;person&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;hs
type FirstName &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; String
type LastName  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; String
type Age &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Int 

data Person &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Person FirstName LastName Age deriving (Eq, Show)

eldest &lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt; Person &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; Person &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; String
eldest (Person x1 y1 z1) (Person x2 y2 z2)
  &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; z1 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; z2   &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x1 &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; y1 &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; is older&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; z1 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; z2   &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x2 &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; y2 &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; is older&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; otherwise &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;They&amp;#39;re the same age!&amp;#34;&lt;/span&gt;

initials &lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt; Person &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; String
initials (Person x y _) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [head x,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.&amp;#39;&lt;/span&gt;,head y, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.&amp;#39;&lt;/span&gt;]

quicksort &lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt;
quicksort (x:xs) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;·&lt;/span&gt;
    let smallerSorted &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; quicksort [a &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;-&lt;/span&gt; xs, a &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; x]
        biggerSorted &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; quicksort [a &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;-&lt;/span&gt; xs, a &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; x]
    in  smallerSorted &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; [x] &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; biggerSorted

instance Ord Person where
  compare (Person _ a _) (Person _ b _) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; compare a b&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;learn-haskell-the-hard-way&#34;&gt;Learn Haskell the Hard Way&lt;/h3&gt;

&lt;p&gt;Despite its childish demeanor, &lt;a href=&#34;http://learnyouahaskell.com/&#34;&gt;Learn You a Haskell&lt;/a&gt; goes deep into the Haskell type system and can be a bit long-winded at times. My current learning method involves reading the book, and typing out every code example, and studying Penn State&amp;rsquo;s &lt;a href=&#34;https://www.cis.upenn.edu/~cis194/spring13/lectures.html&#34;&gt;cis194 course&lt;/a&gt;. Both are free. O&amp;rsquo;Reilly&amp;rsquo;s &lt;a href=&#34;http://book.realworldhaskell.org/read/&#34;&gt;Real World Haskell&lt;/a&gt; is also available for free online, and emphasizes more immediate practical uses of Haskell. It&amp;rsquo;s good for when you&amp;rsquo;re tired of coding binary search trees and sorting algorithms. If you find yourself needing to lookup a Haskell term, DuckDuckGo has the &lt;code&gt;!h&lt;/code&gt; bang, which searches &lt;a href=&#34;https://www.haskell.org/hoogle/&#34;&gt;Hoogle&lt;/a&gt; automatically.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Parsing Protein Domains with Perl</title>
      <link>http://localhost:1313/pub/2001/11/16/perlbio2.html/</link>
      <pubDate>Fri, 16 Nov 2001 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2001/11/16/perlbio2.html/</guid>
      <description>

&lt;p&gt;The Perl programming language is popular with biologists because of its practicality. In my book, &lt;a href=&#34;http://www.oreilly.com/catalog/begperlbio/&#34;&gt;Beginning Perl for Bioinformatics&lt;/a&gt;, I demonstrate how many of the things biologists want to write programs for are readily&amp;ndash;even enjoyably&amp;ndash;accomplished with Perl.&lt;/p&gt;

&lt;p&gt;My book teaches biologists how to program in Perl, even if they have never programmed before. This article will use Perl at the level found in the middle-to-late chapters in my book, after some of the basics have been learned. However, this article can be read by biologists who do not (yet) know any programming. They should be able to skim the program code in this article, only reading the comments, to get a general feel for how Perl is used in practical applications, using real biological data.&lt;/p&gt;

&lt;p&gt;Biological data on computers tends to be either in structured ASCII flat files&amp;ndash;that is to say, in plain-text files&amp;ndash;or in relational databases. Both of these data sources are easy to handle with Perl programs. For this article, I will discuss one of the flat-file data sources, the &lt;a href=&#34;http://ca.expasy.org/prosite/&#34;&gt;Prosite database&lt;/a&gt;, which contains valuable biological information about protein domains. I will demonstrate how to use Perl to extract and use the protein domain information. In &lt;em&gt;Beginning Perl for Bioinformatics&lt;/em&gt; I also show how to work with several other similar data sources, including GenBank (Genetic Data Bank), PDB (Protein DataBank), BLAST (Basic Local Alignment Search Tool) output files, and REBASE (Restriction Enzyme Database).&lt;/p&gt;

&lt;h3 id=&#34;what-is-prosite&#34;&gt;What is Prosite?&lt;/h3&gt;

&lt;p&gt;Prosite stands for &amp;ldquo;A Dictionary of Protein Sites and Patterns.&amp;rdquo; To learn more about the fascinating biology behind Prosite, visit the &lt;a href=&#34;http://ca.expasy.org/cgi-bin/lists?prosuser.txt&#34;&gt;Prosite User Manual&lt;/a&gt;. Here&amp;rsquo;s an introductory description of Prosite from the user manual:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;Prosite is a method of determining what is the function of uncharacterized proteins translated from genomic or cDNA sequences. It consists of a database of biologically significant sites and patterns formulated in such a way that with appropriate computational tools it can rapidly and reliably identify to which known family of protein (if any) the new sequence belongs.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;In some cases, the sequence of an unknown protein is too distantly related to any protein of known structure to detect its resemblance by overall sequence alignment. However, it can be identified by the occurrence in its sequence of a particular cluster of residue types, variously known as a pattern, a motif, a signature, or a fingerprint. These motifs arise because of particular requirements on the structure of specific regions of a protein, which may be important, for example, for their binding properties, or for their enzymatic activity.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Prosite is available as a set of plain-text files that provide the data, plus documentation. The &lt;a href=&#34;http://www.expasy.ch/prosite&#34;&gt;Prosite home page&lt;/a&gt; provides a user interface that allows you to query the database and examine the documentation. The database can also be obtained for local installation from the &lt;a href=&#34;ftp://www.expasy.ch/databases/prosite&#34;&gt;Prosite ftp site&lt;/a&gt;. Its use is free of charge for noncommercial users.
There is some fascinating and important biology involved here; and in the programs that follow there are interesting and useful Perl programming techniques. See the Prosite User Manual for the biology background, and &lt;em&gt;Beginning Perl for Bioinformatics&lt;/em&gt; for the programming background. Or just keep reading to get a taste for what is possible when you combine programming skills with biological data.&lt;/p&gt;

&lt;h3 id=&#34;prosite-data&#34;&gt;Prosite Data&lt;/h3&gt;

&lt;p&gt;The Prosite data can be downloaded to your computer. It is in the ASCII flat file called &lt;a href=&#34;ftp://ca.expasy.org/databases/prosite/release_with_updates/prosite.dat&#34;&gt;prosite.dat&lt;/a&gt; and is more than 4MB in size. A small version of this file created for this article, called &lt;em&gt;prosmall.dat&lt;/em&gt;, is available &lt;a href=&#34;http://perl.com/2001/11/16/examples/prosmall.dat&#34;&gt;here&lt;/a&gt;. This version of the data has just the first few records from the complete file, making it easier for you to download and test, and it&amp;rsquo;s the file that we&amp;rsquo;ll use in the code discussed later in this article.&lt;/p&gt;

&lt;p&gt;Prosite also provides an accompanying data file, &lt;a href=&#34;ftp://ca.expasy.org/databases/prosite/release_with_updates/prosite.doc&#34;&gt;prosite.doc&lt;/a&gt;, which contains documentation for all the records in &lt;em&gt;prosite.dat&lt;/em&gt;. Though we will not use it for this article, I do recommend you look at it and think about how to use the information along with the code presented here if you plan on doing more with Prosite.&lt;/p&gt;

&lt;blockquote&gt;
&lt;hr /&gt;

&lt;blockquote&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;p&gt;&lt;a href=&#34;http://conferences.oreilly.com/biocon/&#34;&gt;&lt;img src=&#34;http://oreilly.com/graphics_new/biocon_logo.gif&#34; alt=&#34;O&amp;#39;Reilly Bioinformatics Technology Conference&#34; width=&#34;120&#34; height=&#34;70&#34; /&gt;&lt;/a&gt; James Tisdall will be speaking at O&#39;Reilly&#39;s first Bioinformatics Technology Conference, January 28-31, 2002, in Tuscon, Arizona. For more information visit &lt;a href=&#34;http://conferences.oreilly.com/biocon/&#34;&gt;Bioinformatics Conference Web site&lt;/a&gt;.&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;The Prosite data in &lt;a href=&#34;ftp://ca.expasy.org/databases/prosite/release_with_updates/prosite.dat&#34;&gt;prosite.dat&lt;/a&gt; (or our much smaller test file &lt;em&gt;prosmall.dat&lt;/em&gt;) is organized in &amp;ldquo;records,&amp;rdquo; each of which consists of several lines, and which always include an ID line and a termination line containing &amp;ldquo;//&amp;rdquo;. The Prosite lines all begin with a two-character code that specifies the kind of data that appears on that line. Here&amp;rsquo;s a breakdown of all the possible line types that a record may contain from the &lt;a href=&#34;http://ca.expasy.org/cgi-bin/lists?prosuser.txt&#34;&gt;Prosite User Manual&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;**
ID
Identification (Begins each entry; one per entry)&lt;/p&gt;

&lt;p&gt;AC
Accession number (one per entry)&lt;/p&gt;

&lt;p&gt;DT
Date (one per entry)&lt;/p&gt;

&lt;p&gt;DE
Short description (one per entry)&lt;/p&gt;

&lt;p&gt;PA
Pattern (&amp;gt;=0 per entry)&lt;/p&gt;

&lt;p&gt;MA
Matrix/profile (&amp;gt;=0 per entry)&lt;/p&gt;

&lt;p&gt;RU
Rule (&amp;gt;=0 per entry)&lt;/p&gt;

&lt;p&gt;NR
Numerical results (&amp;gt;=0 per entry)&lt;/p&gt;

&lt;p&gt;CC
Comments (&amp;gt;=0 per entry)&lt;/p&gt;

&lt;p&gt;DR
Cross references to SWISS-PROT (&amp;gt;=0 per entry)&lt;/p&gt;

&lt;p&gt;3D
Cross references to PDB (&amp;gt;=0 per entry)&lt;/p&gt;

&lt;p&gt;DO
Pointer to the documentation file (one per entry)&lt;/p&gt;

&lt;p&gt;//
Termination line (Ends each entry; one per entry)&lt;/p&gt;

&lt;p&gt;Each of these line types has certain kinds of information that are formatted in a specific manner, as is detailed in the Prosite documentation.&lt;/p&gt;

&lt;h3 id=&#34;prosite-patterns&#34;&gt;Prosite Patterns&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s look specifically at the Prosite patterns. These are presented in a kind of mini-language that describes a set of short stretches of protein that may be a region of known biological activity. Here&amp;rsquo;s the description of the pattern &amp;ldquo;language&amp;rdquo; from the &lt;a href=&#34;http://ca.expasy.org/cgi-bin/lists?prosuser.txt&#34;&gt;Prosite User Manual&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The PA (PAttern) lines contains the definition of a Prosite pattern. The patterns are described using the following conventions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The standard IUPAC one-letter codes for the amino acids are used.&lt;/li&gt;
&lt;li&gt;The symbol `x&amp;rsquo; is used for a position where any amino acid is accepted.&lt;/li&gt;
&lt;li&gt;Ambiguities are indicated by listing the acceptable amino acids for a given position, between square parentheses `[ ]&amp;rsquo;. For example: [ALT] stands for Ala or Leu or Thr.&lt;/li&gt;
&lt;li&gt;Ambiguities are also indicated by listing between a pair of curly brackets `{ }&amp;rsquo; the amino acids that are not accepted at a given position. For example: {AM} stands for any amino acid except Ala and Met.&lt;/li&gt;
&lt;li&gt;Each element in a pattern is separated from its neighbor by a `-&amp;lsquo;.&lt;/li&gt;
&lt;li&gt;Repetition of an element of the pattern can be indicated by following that element with a numerical value or a numerical range between parenthesis. Examples: x(3) corresponds to x-x-x, x(2,4) corresponds to x-x or x-x-x or x-x-x-x.&lt;/li&gt;
&lt;li&gt;When a pattern is restricted to either the N- or C-terminal of a sequence, that pattern either starts with a `&amp;lt;&amp;rsquo; ` a ends or respectively symbol with&amp;gt;&amp;rsquo; symbol.&lt;/li&gt;
&lt;li&gt;A period ends the pattern.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;perl-subroutine-to-translate-prosite-patterns-into-perl-regular-expressions&#34;&gt;Perl Subroutine to Translate Prosite Patterns into Perl Regular Expressions&lt;/h4&gt;

&lt;p&gt;In order to use this pattern data in our Perl program, we need to translate the Prosite patterns into Perl regular expressions, which are the main way that you search for patterns in data in Perl. For the sake of this article I will assume that you know the basic regular expression syntax. (If not, just read the program comments, and skip the Perl regular expressions.) As an example of what the following subroutine does, it will translate the Prosite pattern &lt;code&gt;[AC]-x-V-x(4)-{ED}.&lt;/code&gt; into the equivalent Perl regular expression &lt;code&gt;[AC].V.{4}[^ED]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Here, then, is our first Perl code, the subroutine &lt;code&gt;PROSITE_2_regexp&lt;/code&gt;, to translate the Prosite patterns to Perl regular expressions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#
# Calculate a Perl regular expression
#  from a PROSITE pattern
#
sub PROSITE_2_regexp {

  #
  # Collect the PROSITE pattern
  #
  my($pattern) = @_;

  #
  # Copy the pattern to a regular expression
  #
  my $regexp = $pattern;

  #
  # Now start translating the pattern to an
  #  equivalent regular expression
  #

  #
  # Remove the period at the end of the pattern
  #
  $regexp =~ s/.$//;

  #
  # Replace &#39;x&#39; with a dot &#39;.&#39;
  #
  $regexp =~ s/x/./g;

  #
  # Leave an ambiguity such as &#39;[ALT]&#39; as is.
  #   However, there are two patterns [G&amp;gt;] that need
  #   special treatment (and the PROSITE documentation
  #   is a bit vague, perhaps).
  #
  $regexp =~ s/\[G\&amp;gt;\]/(G|\$)/;

  #
  # Ambiguities such as {AM} translate to [^AM].
  #
  $regexp =~ s/{([A-Z]+)}/[^$1]/g;

  #
  # Remove the &#39;-&#39; between elements in a pattern
  #
  $regexp =~ s/-//g;

  #
  # Repetitions such as x(3) translate as x{3}
  #
  $regexp =~ s/\((\d+)\)/{$1}/g;

  #
  # Repetitions such as x(2,4) translate as x{2,4}
  #
  $regexp =~ s/\((\d+,\d+)\)/{$1}/g;

  #
  # &#39;&amp;lt;&#39; &amp;quot;beginning # $regexp=&amp;quot;~&amp;quot; &#39; &#39;^&#39; ; \&amp;lt; ^ becomes for of s sequence&amp;quot;&amp;gt;&#39; becomes &#39;$&#39; for &amp;quot;end of sequence&amp;quot;
  #
  $regexp =~ s/\&amp;gt;/\$/;

  #
  # Return the regular expression
  #
  return $regexp;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Subroutine &lt;code&gt;PROSITE_2_regexp&lt;/code&gt; takes the Prosite pattern and translates its parts step by step into the equivalent Perl regular expression, as explained in the comments for the subroutine. If you do not know Perl regular expression syntax at this point, just read the comments&amp;ndash;that is, the lines that start with the # character. That will give you the general idea of the subroutine, even if you don&amp;rsquo;t know any Perl at all.&lt;/p&gt;

&lt;blockquote&gt;
&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;Learn more about the power of regular expressions from O&amp;rsquo;Reilly&amp;rsquo;s &lt;a href=&#34;http://www.oreilly.com/catalog/regex/&#34;&gt;Mastering Regular Expressions: Powerful Techniques for Perl and Other Tools&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;perl-subroutine-to-parse-prosite-records-into-their-line-types&#34;&gt;Perl Subroutine to Parse Prosite Records into Their Line Types&lt;/h4&gt;

&lt;p&gt;The other task we need to accomplish is to parse the various types of lines, so that, for instance, we can get the ID and the PA pattern lines easily. The next subroutine accomplishes this task: given a Prosite record, it returns a hash with the lines of each type indexed by a key that is the two-character &amp;ldquo;line type&amp;rdquo;. The keys we&amp;rsquo;ll be interested in are the ID key for the line that has the identification information; and the PA key for the line(s) that have the pattern information.&lt;/p&gt;

&lt;p&gt;This &amp;ldquo;get_line_types&amp;rdquo; subroutine does more than we need. It makes a hash index on all the line types, not just the ID and PA lines that we&amp;rsquo;ll actually use here. But that&amp;rsquo;s OK. The subroutine is short and simple enough, and we may want to use it later to do things with some of the other types of lines in a Prosite record.&lt;/p&gt;

&lt;p&gt;By building our hash to store the lines of a record, we can extract any of the data lines from the record that we like, just by giving the line type code (such as ID for identification number). We can use this hash to extract two line types that will interest us here, the ID identifier line and the PA pattern line. Then, by translating the Prosite pattern into a Perl regular expression (using our first subroutine), we will be in a position to actually look for all the patterns in a protein sequence. In other words, we will have extracted the pattern information and made it available for use in our Perl program, so we can search for the patterns in the protein sequence.&lt;/p&gt;

&lt;blockquote&gt;
&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;If you&amp;rsquo;re interested in learning Perl, don&amp;rsquo;t miss O&amp;rsquo;Reilly&amp;rsquo;s best-selling &lt;a href=&#34;http://www.oreilly.com/catalog/lperl3/&#34;&gt;Learning Perl, 3rd Edition&lt;/a&gt;, which has been updated to cover Perl version 5.6 and rewritten to reflect the needs of programmers learning Perl today. For a complete list of O&amp;rsquo;Reilly&amp;rsquo;s books on Perl, go to &lt;a href=&#34;http://perl.oreilly.com&#34;&gt;perl.oreilly.com&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;/blockquote&gt;

&lt;p&gt;Here, then, is our second subroutine, which accepts a Prosite record, and returns a hash which has the lines of the record indexed by their line types:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#
# Parse a PROSITE record into &amp;quot;line types&amp;quot; hash
#
sub get_line_types {

  #
  # Collect the PROSITE record
  #
  my($record) = @_;

  #
  # Initialize the hash
  #   key   = line type
  #   value = lines
  #
  my %line_types_hash = ();

  #
  # Split the PROSITE record to an array of lines
  #
  my @records = split(/\n/,$record);

  #
  # Loop through the lines of the PROSITE record
  #
  foreach my $line (@records) {

    #
    # Extract the 2-character name
    # of the line type
    #
    my $line_type = substr($line,0,2);

    #
    # Append the line to the hash
    # indexed by this line type
    #
    (defined $line_types_hash{$line_type})
    ?  ($line_types_hash{$line_type} .= $line)
    :  ($line_types_hash{$line_type} = $line);
  }

  #
  # Return the hash
  #
  return %line_types_hash;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;main-program&#34;&gt;Main Program&lt;/h3&gt;

&lt;p&gt;Now let&amp;rsquo;s see the code at work. The following program uses the subroutines we&amp;rsquo;ve just defined to read in the Prosite records one at a time from the database in the flat file prosmall.txt. It then separates the different kinds of lines (such as &amp;ldquo;PA&amp;rdquo; for pattern), and translates the patterns into regular expressions, using the subroutine PROSITE_2_regexp we already wrote. Finally, it searches for the regular expressions in the protein sequence, and reports the position of the matched pattern in the sequence.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/perl
#
# Parse patterns from the PROSITE database, and
# search for them in a protein sequence
#

#
# Turn on useful warnings and constraints
#
use strict;
use warnings;

#
# Declare variables
#

#
# The PROSITE database
#
my $prosite_file = &#39;prosmall.dat&#39;;

#
# A &amp;quot;handle&amp;quot; for the opened PROSITE file
#
my $prosite_filehandle;

#
# Store each PROSITE record that is read in
#
my $record = &#39;&#39;;

#
# The protein sequence to search
# (use &amp;quot;join&amp;quot; and &amp;quot;qw&amp;quot; to keep line length short)
#
my $protein = join &#39;&#39;, qw(
MNIDDKLEGLFLKCGGIDEMQSSRTMVVMGGVSG
QSTVSGELQDSVLQDRSMPHQEILAADEVLQESE
MRQQDMISHDELMVHEETVKNDEEQMETHERLPQ
);

#
# open the PROSITE database or exit the program
#
open($prosite_filehandle, $prosite_file)
 or die &amp;quot;Cannot open PROSITE file $prosite_file&amp;quot;;

#
# set input separator to termination line //
#
$/ = &amp;quot;//\n&amp;quot;;

#
# Loop through the PROSITE records
#
while($record = &amp;lt;$prosite_filehandle&amp;gt;) {

  #
  # Parse the PROSITE record into its &amp;quot;line types&amp;quot;
  #
  my %line_types = get_line_types($record);

  #
  # Skip records without an ID (the first record)
  #
  defined $line_types{&#39;ID&#39;} or next;

  #
  # Skip records that are not PATTERN
  # (such as MATRIX or RULE)
  #
  $line_types{&#39;ID&#39;} =~ /PATTERN/ or next;

  #
  # Get the ID of this record
  #
  my $id = $line_types{&#39;ID&#39;};
  $id =~ s/^ID   //;
  $id =~ s/; .*//;

  #
  # Get the PROSITE pattern from the PA line(s)
  #
  my $pattern = $line_types{&#39;PA&#39;};
  # Remove the PA line type tag(s)
  $pattern =~ s/PA   //g;

  #
  # Calculate the Perl regular expression
  # from the PROSITE pattern
  #
  my $regexp =  PROSITE_2_regexp($pattern);

  #
  # Find the PROSITE regular expression patterns
  # in the protein sequence, and report
  #
  while ($protein =~ /$regexp/g) {
    my $position = (pos $protein) - length($&amp;amp;) +1;
    print &amp;quot;Found $id at position $position\n&amp;quot;;
    print &amp;quot;   match:   $&amp;amp;\n&amp;quot;;
    print &amp;quot;   pattern: $pattern\n&amp;quot;;
    print &amp;quot;   regexp:  $regexp\n\n&amp;quot;;
  }
}

#
# Exit the program
#
exit;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This program is available online as the file &lt;a href=&#34;http://perl.com/2001/11/16/examples/parse_prosite&#34;&gt;parse_prosite&lt;/a&gt;. The tiny example Prosite database is available as the file &lt;a href=&#34;http://perl.com/2001/11/16/examples/prosmall.dat&#34;&gt;prosmall.dat&lt;/a&gt;. If you save these files on your (Unix, Linux, Macintosh, or Windows) computer, you can enter the following command at your command-line prompt (in the same folder in which you saved the two files):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% perl parse_prosite
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and it will produce the following output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Found PKC_PHOSPHO_SITE at position 22
   match:   SSR
   pattern: [ST]-x-[RK].
   regexp:  [ST].[RK]

Found PKC_PHOSPHO_SITE at position 86
   match:   TVK
   pattern: [ST]-x-[RK].
   regexp:  [ST].[RK]

Found CK2_PHOSPHO_SITE at position 76
   match:   SHDE
   pattern: [ST]-x(2)-[DE].
   regexp:  [ST].{2}[DE]

Found MYRISTYL at position 30
   match:   GGVSGQ
   pattern: G-{EDRKHPFYW}-x(2)-[STAGCN]-{P}.
   regexp:  G[^EDRKHPFYW].{2}[STAGCN][^P]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you see, our short program goes through the Prosite database one record at a time, parsing each record according to the types of lines within it. If the record has an ID and a pattern, it then extracts them, creates a Perl regular expression from the pattern, and finally searches in a protein sequence for the regular expression, reporting on the patterns found.&lt;/p&gt;

&lt;h3 id=&#34;the-next-step&#34;&gt;The Next Step&lt;/h3&gt;

&lt;p&gt;This article has shown you how to take biological data from the Prosite database and use it in your own programs. With this ability, you can write programs specific to your particular research needs.&lt;/p&gt;

&lt;p&gt;Many kinds of data discovery are possible: you could combine searches for Prosite patterns with some other computation. For instance, you may want to also search the associated genomic DNA or cDNA for restriction sites surrounding a particular Prosite pattern in the translated protein, in preparation for cloning.&lt;/p&gt;

&lt;blockquote&gt;
&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;James Tisdall has also written &lt;a href=&#34;http://www.oreilly.com/news/perlbio_1001.html&#34;&gt;Why Biologists Want to Program Computers&lt;/a&gt; for &lt;em&gt;oreilly.com&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;/blockquote&gt;

&lt;p&gt;While such programs are interesting in their own right, their importance in laboratory research really lies in the fact that their use can save enormous amounts of time; time which can then be used for other, less routine, tasks on which biological research critically depends.&lt;/p&gt;

&lt;p&gt;This article gives an example of using Perl to extract and use data from a flat file database, of which there are many in biological research. In fact, some of the most important biological databases are in flat file format, including GenBank and PDB, the primary databases for DNA sequence information and for protein structures.&lt;/p&gt;

&lt;p&gt;With the ability to write your own programs, the true power of bioinformatics can be applied in your lab. Learning the Perl programming language can give you a direct entry into this valuable new laboratory technique.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;O&amp;rsquo;Reilly &amp;amp; Associates recently released (October 2001) &lt;a href=&#34;http://oreilly.com/catalog/begperlbio/&#34;&gt;Beginning Perl for Bioinformatics&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.oreilly.com/catalog/begperlbio/chapter/ch10.html&#34;&gt;Sample Chapter 10, GenBank&lt;/a&gt;, is available free online.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can also look at the &lt;a href=&#34;http://www.oreilly.com/catalog/begperlbio/toc.html&#34;&gt;Table of Contents&lt;/a&gt;, the &lt;a href=&#34;http://www.oreilly.com/catalog/begperlbio/toc.html&#34;&gt;Index&lt;/a&gt;, and the &lt;a href=&#34;http://www.oreilly.com/catalog/begperlbio/desc.html&#34;&gt;Full Description&lt;/a&gt; of the book.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;For more information, or to order the book, &lt;a href=&#34;http://oreilly.com/catalog/begperlbio/&#34;&gt;click here&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>

