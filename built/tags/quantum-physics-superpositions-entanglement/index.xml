<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Quantum Physics Superpositions Entanglement on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/quantum-physics-superpositions-entanglement/</link>
    <description>Recent content in Quantum Physics Superpositions Entanglement on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 08 Aug 2001 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/quantum-physics-superpositions-entanglement/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Quantum::Entanglement</title>
      <link>http://localhost:1313/pub/2001/08/08/quantum.html/</link>
      <pubDate>Wed, 08 Aug 2001 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2001/08/08/quantum.html/</guid>
      <description>

&lt;h3 id=&#34;span-id-there-is-more-than-one-world-in-which-to-do-it-there-is-more-than-one-world-in-which-to-do-it-span&#34;&gt;&lt;span id=&#34;there is more than one world (in which) to do it&#34;&gt;There Is More Than One World (In Which) To Do It&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;With the possible exception of many physicists, quantum mechanics is one of the stranger things to have emerged from science over the last hundred years. It has led the way to new understanding of a diverse range of fundamental physical phenomena and, should recent developments prove fruitful, could also lead to an entirely new mode of computation where previously intractable problems find themselves open to easy solution.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Quantum::Entanglement&lt;/code&gt; module attempts to port some of the functionality of the universe into Perl. Variables can be prepared in a superposition of states, where they take many values at once, and when observed during the course of a program, will collapse to have a single value. If variables interact then their fates are linked so that when one is observed and forced to collapse the others will also collapse at the moment of observation.&lt;/p&gt;

&lt;p&gt;It is quite hard to provide a complete version of quantum mechanics in Perl, so we need to make some simplifications. Instead of solving thousands of equations each time we want to do something, we will forget entirely about eigen-functions, Hermitian operators and other mathematical hurdles. This still leaves us with plenty of ways to make Perl behave in a thoroughly unpredictable fashion.&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-entangle-function-the-entangle-function-span&#34;&gt;&lt;span id=&#34;the entangle() function&#34;&gt;The &lt;code&gt;entangle()&lt;/code&gt; function&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;Quantum::Entanglement&lt;/code&gt; module adds an &lt;code&gt;entangle()&lt;/code&gt; function to Perl, this takes a list of amplitudes and values and returns a scalar in a superposition of values; saying&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $die = entangle( 1=&amp;gt;1, 1=&amp;gt;2, 1=&amp;gt;3, 1=&amp;gt;4, 1=&amp;gt;5, 1=&amp;gt;6);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;creates a superposition of the values &lt;code&gt;1..6&lt;/code&gt;. From now on, &lt;code&gt;$die&lt;/code&gt; acts as if it has every one of those values at the same time as long as we do not try to find out exactly which one.&lt;/p&gt;

&lt;h3 id=&#34;span-id-observation-and-collapse-in-perl-observation-and-collapse-in-perl-span&#34;&gt;&lt;span id=&#34;observation and collapse in perl&#34;&gt;Observation and Collapse in Perl&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;We now need to decide what happens when we observe our variable, and what we mean by &lt;em&gt;observe&lt;/em&gt;? Taking a broad definition as being ``anything that reveals the values which a variable has&amp;rdquo; seems about right. Perl provides us with many ways of doing this, there are the obvious acts of printing out a variable or testing it for truth, but even operators such as &lt;code&gt;eq&lt;/code&gt; or &lt;code&gt;&amp;lt;=&lt;/code&gt; tell us something.&lt;/p&gt;

&lt;p&gt;How do we decide which way a variable collapses? Well, each possible value has an associated probability amplitude, so all we need to do is build up a list of distinct outcomes, add up the amplitudes for each one, square the result, then use this to bias the value (or values) to which the variable collapses.&lt;/p&gt;

&lt;p&gt;As every coefficient of the superposition in &lt;code&gt;$die&lt;/code&gt; is equal to 1,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; print &amp;quot;You rolled a $die.\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will output &lt;code&gt;You rolled a 1.&lt;/code&gt; or &lt;code&gt;You rolled a 2.&lt;/code&gt; and so on, each for one sixth of the time.&lt;/p&gt;

&lt;h3 id=&#34;span-id-entanglement-and-simple-complex-logic-entanglement-and-simple-complex-logic-span&#34;&gt;&lt;span id=&#34;entanglement and simple complex logic&#34;&gt;Entanglement and Simple Complex Logic&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Whenever superposed variables interact, or are involved in calculations, the results of these as well as the variables themselves become entangled. This means that they will all collapse at the same time, so as to remain consistent with their history. This emulates the entanglement, or ``spooky action at a distance&amp;rdquo;, which so worried Einstein.&lt;/p&gt;

&lt;h3 id=&#34;span-id-complex-amplitudes-and-entanglement-in-perl-complex-amplitudes-and-entanglement-in-perl-span&#34;&gt;&lt;span id=&#34;complex amplitudes and entanglement in perl&#34;&gt;Complex Amplitudes and Entanglement in Perl&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;If we can have plain numbers as the coefficients of our superpositions it seems sensible that we could also use complex numbers. Although instead of just squaring the number when working out our probability, we need to square the &lt;em&gt;size&lt;/em&gt; of the number. (eg. &lt;code&gt;|1+2i|**2 == 5 == |1-2i|**2&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Quantum::Entanglement&lt;/code&gt; module allows subroutines to create new states (amplitude-value pairs) based on the current set of states by using the function &lt;code&gt;q_logic&lt;/code&gt;. This takes as an argument a subroutine which is presented each state in turn and must return a new set of states constructed from these.&lt;/p&gt;

&lt;p&gt;Starting our program with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; #!/usr/bin/perl -w

 use Quantum::Entanglement qw(:DEFAULT :complex);

 $Quantum::Entanglement::destroy = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;so that we have access to the constants defined by &lt;code&gt;Math::Complex&lt;/code&gt; and turn off the memory management performed by the module (as this causes some information to be lost, which will be important later). We then define a subroutine to return the value it receives and its logical negation, their coefficients are those of the original state multiplied by &lt;code&gt;i/sqrt(2)&lt;/code&gt; and &lt;code&gt;1/sqrt(2)&lt;/code&gt; respectively:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; sub root_not {

   my ($prob, $val) = @_;

   return( $prob * i / sqrt(2) , $val,

               $prob / sqrt(2) , !$val );

 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We then create a superposition which we &lt;em&gt;know&lt;/em&gt; is equal to 0 and feed it through our &lt;code&gt;root_not()&lt;/code&gt; once:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; my $var = entangle(1 =&amp;gt; 0);

 $var = q_logic(\&amp;amp;root_not, $var);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the variable is now in a superposition of two possible values, 0 and 1, with coefficients of &lt;code&gt;i/sqrt(2)&lt;/code&gt; and &lt;code&gt;1/sqrt(2)&lt;/code&gt; respectively. We now make our variable interact, storing the result in &lt;code&gt;$peek&lt;/code&gt;. As &lt;code&gt;$var&lt;/code&gt; is in a superposition, every possible value it has participates in the calculation and contributes to the result.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; my $peek  = 12*$var;   # $peek and $var become entangled

 $var = q_logic(\&amp;amp;root_not, $var);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We then feed &lt;code&gt;$var&lt;/code&gt; through &lt;code&gt;root_not()&lt;/code&gt; one more time and test it for truth. What will happen and what will be the value of &lt;code&gt;$peek&lt;/code&gt;?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; if ($var) { print &amp;quot;\$var is true!\n&amp;quot;; }

 else      { print &amp;quot;\$var is false\n&amp;quot;; }




 print &amp;quot;\$peek is equal to: $peek.\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output is always &lt;code&gt;$var is true!&lt;/code&gt; as &lt;code&gt;$var&lt;/code&gt; is in a final superposition of &lt;code&gt;(1/2=&lt;/code&gt;0, i/2=&amp;gt;1, -&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;=&amp;gt;0, i/2=&amp;gt;1)&amp;gt;. You can convince yourself of this by running through the math. What about &lt;code&gt;$peek&lt;/code&gt;? Well, because it interacted with &lt;code&gt;$var&lt;/code&gt; before $&amp;lt;var&amp;gt; collapsed and both possible values that &lt;code&gt;$var&lt;/code&gt; had at that time contributed to its eventual truthfulness, both values of &lt;code&gt;$peek&lt;/code&gt; are still present, we get 0 or 12 each for half the time.&lt;/p&gt;

&lt;p&gt;If we reverse the order in which we examine the variables:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; print &amp;quot;\$peek is equal to: $peek.\n&amp;quot;;




 if ($var) { print &amp;quot;\$var is true!\n&amp;quot;; }

 else      { print &amp;quot;\$var is false\n&amp;quot;; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we still see &lt;code&gt;peek&lt;/code&gt; being &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;12&lt;/code&gt; but as we collapsed &lt;code&gt;$peek&lt;/code&gt; we must also collapse &lt;code&gt;$var&lt;/code&gt; at the same time. This causes &lt;code&gt;$var&lt;/code&gt; to be in a superposition of &lt;code&gt;(1/2=&lt;/code&gt;0,i/2=&amp;gt;1)&amp;gt; or a superposition of &lt;code&gt;(-1/2=&lt;/code&gt;0,i/2=&amp;gt;1)&amp;gt;, both of which will collapse to 0 half of the time and 1 the other half of the time so that (on average) we see both phrases printed.&lt;/p&gt;

&lt;p&gt;If we try to find the value that &lt;code&gt;$var&lt;/code&gt; had while it was `between&amp;rsquo; the subroutines we force it to have a single value so that after two passes though &lt;code&gt;root_not()&lt;/code&gt; we get random noise, even if we test this after the event. If, on the other hand, we leave it alone it emerges from repeated application of &lt;code&gt;root_not()&lt;/code&gt; as the logical negation of its original value, thus the name of our subroutine.&lt;/p&gt;

&lt;h3 id=&#34;span-id-beneath-the-veil-beneath-the-veil-span&#34;&gt;&lt;span id=&#34;beneath the veil&#34;&gt;Beneath the Veil&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Although the module is intended to be used as a black box which does the Right Thing (or some close approximation to it), the internals of the code are interesting and reveal many features of Perl which may be useful elsewhere.&lt;/p&gt;

&lt;p&gt;Writing entangled behaviour into Perl presents an interesting challenge; a means of representing a superposition is required, as is some way of allowing different variables to know about each other without creating a twisty maze of references which would stand in the way of garbage collection and lead to a certain programming headache. We also need a means to cause collapse, as well as a robust mechanism for dealing with both real and complex numbers. Thankfully Perl provides a rich set of ingredients which can more than satisfy these requirements without making the job so hard that it becomes impossible.&lt;/p&gt;

&lt;h3 id=&#34;span-id-objective-reality-objective-reality-span&#34;&gt;&lt;span id=&#34;objective reality&#34;&gt;Objective Reality&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;We want to represent something which has many values (and store these somewhere) while making it look like there&amp;rsquo;s only one value present. Objects in Perl are nothing more than scalars that know slightly more than usual. When a new entanglement is created, we create a new object, and return that to the calling program. Deep within the module we have a routine which is similar to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; sub entangle {

   my $self = [ ~ data goes in here ~ ];

   return bless $self, &#39;Quantum::Entanglement&#39;;

 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;exactly how we store the data is covered below. We then turn this into a &amp;lsquo;core&amp;rsquo; function by importing it into the namespace which asked for it.&lt;/p&gt;

&lt;h3 id=&#34;span-id-when-worlds-collide-when-worlds-collide-span&#34;&gt;&lt;span id=&#34;when worlds collide&#34;&gt;When Worlds Collide&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ve created a superposition of values and sent it back to our user. What needs to happen when they write something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $talk = entangle( 1=&amp;gt;&#39;Ships&#39;,    1=&amp;gt;&#39;Sealing Wax&#39;,
                   1=&amp;gt;&#39;Cabbages&#39;, 1=&amp;gt;&#39;Kings&#39;        );
 $more = $talk . &#39; yada yada yada&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We want to redefine the meaning of concatenation when an entangled object is involved. Perl lets us do this using the &lt;code&gt;overload&lt;/code&gt; module. Within the &lt;code&gt;Quantum::Entanglement&lt;/code&gt; module we say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; use overload
        &#39;+&#39;  =&amp;gt; sub { binop(@_, sub{$_[0] + $_[1]} ) },
     # more ...
        &#39;.&#39;  =&amp;gt; sub { binop(@_, sub{$_[0] . $_[1]} ) },
     # yet more ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whenever someone applies the &amp;lsquo;.&amp;rsquo; operator to our object, a subroutine (in this case an anonymous one) is called to handle the operation, the result of this subroutine is then used as the result of the operation. Because the module provides new behaviours for all of Perl&amp;rsquo;s operations, we write a generic routine to handle &lt;strong&gt;Bi&lt;/strong&gt;nary &lt;strong&gt;N&lt;/strong&gt;on-observational &lt;strong&gt;Op&lt;/strong&gt;erations and pass this the values to operate on along with another anonymous routine (which it will see as a code-ref) so that it knows which operation to perform. This allows us to re-use the code which works out if both operands are objects and if they are reversed and pieces together the data structures we use. &lt;code&gt;binop&lt;/code&gt; is described below.&lt;/p&gt;

&lt;h2 id=&#34;span-id-data-structures-with-hair-data-structures-with-hair-span&#34;&gt;&lt;span id=&#34;data structures with hair&#34;&gt;Data Structures with Hair&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;This module lives and dies on the strength of its data structures. We need to ensure that every variable (or, more correctly, object) knows about all the other superpositions it has been involved with throughout the course of the program without having any direct pointers between them.&lt;/p&gt;

&lt;p&gt;When we create a new variable, we give it the following structure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; sub entangle {
   my $universe = [ [ @_[0,1] ], # amp1, val1
                    [ @_[2,3] ], ...  ];
   my $offsets  = [];
   $var = [ \$universe, 1, \$offsets];
   $offsets-&amp;gt;[0] = \ $var-&amp;gt;[1];
   return bless $var, &#39;Quantum::Entanglement&#39;;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;there&amp;rsquo;s a lot going on here, so pay attention. &lt;code&gt;$universe&lt;/code&gt; is a list of lists (lol), essentially a two dimensional table with the first two columns holding the amplitudes and values of our superposition. &lt;code&gt;$var&lt;/code&gt; contains a reference which points at a scalar which then points at the universe, rather like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ($var-&amp;gt;[0]) ---&amp;gt; (anonymous scalar) ---&amp;gt; $universe
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second value in &lt;code&gt;$var&lt;/code&gt; is a number which indicates the column in the universe that we need to look at to find the values of our superposition. The last field of &lt;code&gt;$var&lt;/code&gt; again points to a pointer to an array. This array though contains a scalar which points directly at the scalar which holds the number representing the offset of the values in the universe, something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $var[ (-&amp;gt;X-&amp;gt;universe), (number), (-&amp;gt;Y-&amp;gt;offsets[  ])  ]
                            \------&amp;lt;----&amp;lt;-------/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, when we want this object to interact with another object, all we need to do is make &lt;code&gt;$var-&amp;gt;[0]&lt;/code&gt; and &lt;code&gt;$var-&amp;gt;[1]&lt;/code&gt; for each object end up refering to the same universe. Easy, you might say, given that we have both objects around. But what if one had already interacted with another variable, which we cannot directly access anymore? This is where our extra level of indirection is required. Because each variable contains something which points at something else which then points at their set of values, we merely need to make sure that the &amp;lsquo;something else&amp;rsquo; ends up pointing at the same thing for everything. So, we delve into each object&amp;rsquo;s universe, choosing one which will contain the data for both objects (and thus for all those which have interacted in the past) and move all the data from the other object&amp;rsquo;s universe into it. We then make our middle reference the same for each object.&lt;/p&gt;

&lt;p&gt;Initially,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; universe1 = [[a1,av1],      [a2,av2]      ,... ]

 universe2 = [[b1,bv1,c1,cv1],[b2,bv2,c1,cv1],... ] 

 $var1[ (-&amp;gt;X-&amp;gt;universe1), 1,... ] # we have this object

 $var2[ (-&amp;gt;Y-&amp;gt;universe2), 1,... ] #  and this object

 $var3[ (-&amp;gt;Y-&amp;gt;universe2), 3,... ] # but not this one
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then by pointing Y at universe1 the whole structure of our objects becomes&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; universe1 = [[a1,av1,b1,bv1,c1,cv1],[a2,v2,b1,bv1,c1,cv1] ,... ]

 $var1[ (-&amp;gt;X-&amp;gt;universe1), 1,... ] # we have this object

 $var2[ (-&amp;gt;Y-&amp;gt;universe1), 3,... ] #  and this object

 $var3[ (-&amp;gt;Y-&amp;gt;universe1), 5,... ] # but not this one
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To allow every possible value of one variable to interact with every possible value of our other variables, we need to follow a crossing rule so that the rows of our merged universe look like this:&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;pre&gt;&lt;code&gt;
 universe1   universe2            result

 a1 av1      b1 bv1 c1 cv1      a1 av9  ]

                            \------&amp;lt;----&amp;lt;-------/&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Now, when we want this object to interact with another object, all we need to do is make &lt;code&gt;$var-&amp;gt;[0]&lt;/code&gt; and &lt;code&gt;$var-&amp;gt;[1]&lt;/code&gt; for each object end up refering to the same universe. Easy, you might say, given that we have both objects around. But what if one had already interacted with another variable, which we cannot directly access anymore? This is where our extra level of indirection is required. Because each variable contains something which points at something else which then points at their set of values, we merely need to make sure that the &amp;lsquo;something else&amp;rsquo; ends up pointing at the same thing for everything. So, we delve into each object&amp;rsquo;s universe, choosing one which will contain the data for both objects (and thus for all those which have interacted in the past) and move all the data from the other object&amp;rsquo;s universe into it. We then make our middle reference the same for each object.&lt;/p&gt;

&lt;p&gt;Initially,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; universe1 = [[a1,av1],      [a2,av2]      ,... ]

 universe2 = [[b1,bv1,c1,cv1],[b2,bv2,c1,cv1],... ] 

 $var1[ (-&amp;gt;X-&amp;gt;universe1), 1,... ] # we have this object

 $var2[ (-&amp;gt;Y-&amp;gt;universe2), 1,... ] #  and this object

 $var3[ (-&amp;gt;Y-&amp;gt;universe2), 3,... ] # but not this one
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then by pointing Y at universe1 the whole structure of our objects becomes&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; universe1 = [[a1,av1,b1,bv1,c1,cv1],[a2,v2,b1,bv1,c1,cv1] ,... ]

 $var1[ (-&amp;gt;X-&amp;gt;universe1), 1,... ] # we have this object

 $var2[ (-&amp;gt;Y-&amp;gt;universe1), 3,... ] #  and this object

 $var3[ (-&amp;gt;Y-&amp;gt;universe1), 5,... ] # but not this one
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To allow every possible value of one variable to interact with every possible value of our other variables, we need to follow a crossing rule so that the rows of our merged universe look like this:&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;pre&gt;&lt;code&gt;
 universe1   universe2            result

 a1 av1      b1 bv1 c1 cv1      a1 av1  b1 bv1  c1 cv1

 a2 av2    * b1 bv1 c2 cv2  ==&amp;gt; a1 av1  b1 bv1  c2 cv2

                                a2 av2  b1 bv1  c1 cv1

                                a2 av2  b1 bv1  c2 cv2&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;so that every row in the first universe is paired with every row of the second. We then need to update the offsets for each variable which has had data moved from one universe to another. As the offsets array contains pointers back to these values, it is easy to increase each one by the correct amount. So, given two entanglements in @_, and a bit of cheating with &lt;code&gt;map&lt;/code&gt;, we can say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my $offsets1 = ${$_[0]-&amp;gt;[2]}; # middle-man reference

  my $offsets2 = ${$_[1]-&amp;gt;[2]};

  my $extra = scalar(@{ ${$_[0]-&amp;gt;[0]} });

  push @$offsets1, map {$$_+=$extra; $_} @$offsets2;

  ${$_[1]-&amp;gt;[2]} = $offsets1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and you can&amp;rsquo;t get clearer than that.&lt;/p&gt;

&lt;p&gt;So &lt;code&gt;binop&lt;/code&gt; is written like so (assuming that we can only be given two entangled variables in the correct order, for the full story, read the source):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; sub binop {

    my ($obj1,$obj2,$r,$code) = @_;

    _join($obj1,$obj2);   # ensure universes shared

    my ($os1, $os2) = ($obj1-&amp;gt;[1],$obj2-&amp;gt;[1]);

    my $new = $obj1-&amp;gt;_add(); # new var also shares universe

    foreach my $state (@{${$obj1-&amp;gt;[0]}}) {

       push( @$state, $state-&amp;gt;[$os1-1]*$state-&amp;gt;[$os2-1],

                      &amp;amp;$code( $state-&amp;gt;[$os1], $state-&amp;gt;[$os2] );

    }

    return $new;

 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or, in English: make sure each variable is in the same universe then create a new variable in the same universe. For every row of the universe: add two extra values, the first is the product of the two input amplitudes, the second is the result of our operation on our two input values. Here you see the tremendous value of code reuse, no sane man would write such a routine more than once. Or, more correctly, no man would remain sane if they tried.&lt;/p&gt;

&lt;h3 id=&#34;span-id-london-bridge-is-falling-down-london-bridge-is-falling-down-span&#34;&gt;&lt;span id=&#34;london bridge is falling down&#34;&gt;London Bridge is Falling Down&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;How do we collapse our superpositions so that every entangled variable is affected even though we can only access one of them at once? When we perform an observational operation (&lt;code&gt;if ($var){...}&lt;/code&gt;, say) we simply need to split our universe (table of values) into two groups, those which lead to our operator returning a true value and those that do not. We add up the probability amplitudes for each value in each group, square these to get two numbers and use these to decide which group to keep. To cause our collapse we merely need to delete all the rows of the universe which form the other group which will remove any value of any variable in that row.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-getting-the-module-getting-the-module-span&#34;&gt;&lt;span id=&#34;getting the module&#34;&gt;Getting the Module&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The module distribution, like all good things, is available from the CPAN and includes a few short demonstrations of what the module can do, along with plenty of explanation (including Shor&amp;rsquo;s algorithm and the square root of NOT gate outlined above). The source of this, and any other module on the CPAN, is available for inspection. If you have a burning desire to find out how the mystical wheel was first invented, Perl, and its community, will gladly show you.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

