<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ide on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/ide/</link>
    <description>Recent content in Ide on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 25 Aug 2005 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/ide/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Perl Needs Better Tools</title>
      <link>http://localhost:1313/pub/2005/08/25/tools.html/</link>
      <pubDate>Thu, 25 Aug 2005 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2005/08/25/tools.html/</guid>
      <description>

&lt;p&gt;Perl is in danger of becoming a fading language&amp;ndash;new programmers are learning Java and Python in college, and companies like Google hardly use Perl at all. If you are afraid that Perl may be in danger of becoming irrelevant for medium-to-large projects, then read on.&lt;/p&gt;

&lt;h3 id=&#34;the-scary-part&#34;&gt;The Scary Part&lt;/h3&gt;

&lt;p&gt;I have discussed the future of Perl with managers from companies that currently use it and find that they worry about the future of Perl. One company I spoke with here in San Francisco is rewriting their core application in Java. Another company worries they will not be able to find new Perl programmers down the road. Yet another uses Perl for major projects, but suffers from difficulty in refactoring their extensive code base.&lt;/p&gt;

&lt;p&gt;There are many reasons why companies care about the future of Perl. I offer a part of a solution: better tools for Perl can be a major part of keeping Perl relevant and effective as the primary language for medium and large projects.&lt;/p&gt;

&lt;p&gt;When measuring the effectiveness of a development environment (people, language, tools, processes, etc.), a key measure is how expensive and painful it is to make changes to existing code. Once a project or system has grown to thousands of lines of code in dozens (or hundreds) of modules, the cost of making changes can escalate to the point where the team is afraid to make any significant change. Excellent tools are one of the ways to avoid this unhappy situation, or at least reduce its impact. Other factors are excellent processes and, of course, excellent people.&lt;/p&gt;

&lt;h3 id=&#34;21st-century-integrated-development-environments-for-perl&#34;&gt;21st-Century Integrated Development Environments for Perl&lt;/h3&gt;

&lt;p&gt;I propose that more, high-quality development tools will help keep Perl relevant and alive in medium and large project environments. My focus in this article is on IDEs, or Integrated Development Environments, and primarily those with a graphical interface.&lt;/p&gt;

&lt;p&gt;An IDE is an integrated set of tools for programming, combining a source code editor with a variety of other tools into a single package. Common features of modern IDEs include refactoring support, version control, real-time syntax checking, and auto-completion of code while typing.&lt;/p&gt;

&lt;p&gt;I want to make it clear right at the outset that a team of highly skilled Perl programmers, using only tools that have been around for years (such as &lt;code&gt;emacs&lt;/code&gt;, &lt;code&gt;vi&lt;/code&gt;, &lt;code&gt;cvs&lt;/code&gt;, and &lt;code&gt;make&lt;/code&gt;) can and do build large, sophisticated, and successful projects. I am not worried about those programmers. I am worried about the larger population of programmers with one to five years of experience, and those who have not yet begun to program: the next generation of Perl programmers.&lt;/p&gt;

&lt;p&gt;Great tools will not make a bad programmer into a good programmer, but they will certainly make a good programmer better. Unfortunately, the tools for Perl are years behind what is available for other languages, particularly Java.&lt;/p&gt;

&lt;p&gt;One powerful example is the lack of graphical IDEs for Perl with excellent support for refactoring. Several IDEs for Java have extensive refactoring support. Only one for Perl, the &lt;a href=&#34;http://e-p-i-c.sf.net/&#34;&gt;EPIC plugin for Eclipse&lt;/a&gt;, supports even a single refactoring action.&lt;/p&gt;

&lt;p&gt;For an example of how good IDEs have inspired at least one Perl developer, see &lt;a href=&#34;http://localhost:1313/authors/adam-kennedy&#34;&gt;Adam Kennedy&lt;/a&gt;&amp;rsquo;s &lt;a href=&#34;http://localhost:1313/pub/2005/06/09/ppi.html&#34;&gt;Perl.com article on his new PPI module&lt;/a&gt; and &lt;a href=&#34;https://metacpan.org/pod/Devel::Refactor&#34;&gt;Scott Sotka&amp;rsquo;s Devel::Refactor module&lt;/a&gt; (used in EPIC).&lt;/p&gt;

&lt;p&gt;I acknowledge that a graphical IDE is not the be-all of good tools. Just as some writers reject word processors in favor of typewriters or hand-written manuscripts, some programmers reject graphical IDEs and would refuse a job that required them to use one. Not everyone has (nor should have) the same tool set, and there are things a pencil can do that &lt;code&gt;vi&lt;/code&gt; and &lt;code&gt;emacs&lt;/code&gt; will never do. That said, IDEs have wide use in businesses doing larger projects, and for many programmers and teams they provide major increases in productivity.&lt;/p&gt;

&lt;p&gt;Another important point is that while this article discusses over a dozen specific tools or features, having all the tools in a single package produces the biggest value. An IDE that provides all of these features in a single package that people can easily install, easily extend, and easily maintain across an entire development team has far more value than the sum of its parts.&lt;/p&gt;

&lt;p&gt;There is a big win when the features provided by an IDE immediately upon installation include all or almost all of the tools and features discussed here and where the features &amp;ldquo;know&amp;rdquo; about each other. For example, it is good if you enter the name of a non-existent subroutine and the real-time syntax checker catches this. It is much better if the code-assist feature then pops up a context menu offering to create a stub for the subroutine or to correct the name to that of an existing similar subroutine or method from another class that is available to the current file. (This is standard behavior for some Java IDEs.)&lt;/p&gt;

&lt;h3 id=&#34;what-would-a-21st-century-perl-tool-set-contain&#34;&gt;What Would a 21st-Century Perl Tool Set Contain?&lt;/h3&gt;

&lt;p&gt;Perl needs a few great IDEs&amp;ndash;not just one, but more than one so that people have a diverse set to choose from. Perl deserves and needs a few great IDEs that lead the pack and set the standard for IDEs in other languages.&lt;/p&gt;

&lt;p&gt;I am well aware that the dynamic nature of Perl makes it harder to have a program that can read and understand a Perl program, especially a large and complex one, but the difficulty in comprehending a Perl program makes the value of such a tool all the greater, and I have faith that the Perl community can overcome some of the built-in challenges of Perl. Indeed, it is among the greatest strengths of Perl that Perl users can adapt the language to their needs.&lt;/p&gt;

&lt;p&gt;A great Perl IDE will contain at least the following, plus other features I haven&amp;rsquo;t thought of. (And, of course, there must be many of those!)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A &lt;a href=&#34;#Syntax-coloring_text_editor&#34;&gt;syntax-coloring text editor.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#Syntax-checking&#34;&gt;Real-time syntax-checking&lt;/a&gt; to catch and display syntax errors as you type.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#Version_control_integration&#34;&gt;Version control integration&lt;/a&gt; to check out and compare code using CVS, Subversion, etc.&lt;/li&gt;
&lt;li&gt;A &lt;a href=&#34;#Code-assist&#34;&gt;code-assist editor&lt;/a&gt;, to provide a list of methods when you type in an object reference, for example.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#refactoring_support&#34;&gt;Excellent refactoring support&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;A &lt;a href=&#34;#Tree_view_of_source&#34;&gt;tree view of source files and resources&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#support_for_unit_tests&#34;&gt;Support for creating and running unit tests&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#Language-specific_help&#34;&gt;Language-specific help&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#Debugger&#34;&gt;Real-time display of debugging results&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#Automatic_reformatting&#34;&gt;Automatic code reformatting&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Seamless &lt;a href=&#34;#handling_of_multiple_languages&#34;&gt;handling of multiple languages&lt;/a&gt; (such as Perl and C, Perl and Java, Perl and PHP, or Perl and Python).&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#Automated_build_and_test&#34;&gt;Automated build and test support&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Most of the screen shot examples in this article use the EPIC Perl IDE. At present, it has the largest amount of the features on my list (although it certainly doesn&amp;rsquo;t have all of them).&lt;/p&gt;

&lt;h4 id=&#34;span-id-syntax-coloring-text-editor-syntax-coloring-text-editor-span&#34;&gt;&lt;span id=&#34;Syntax-coloring_text_editor&#34;&gt;Syntax-Coloring Text Editor&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Most of you have probably seen this. It is available under &lt;code&gt;vim&lt;/code&gt;, &lt;code&gt;emacs&lt;/code&gt;, BBEdit, and TextPad. Just about every decent text editor will colorize source code so that keywords, operators, variables, etc., each have their own color, making it easier to spot syntax errors such as forgetting to close a quote pair.&lt;/p&gt;

&lt;h4 id=&#34;span-id-syntax-checking-real-time-syntax-checking-span&#34;&gt;&lt;span id=&#34;Syntax-checking&#34;&gt;Real-Time Syntax Checking&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_08_25_tools/syntax_check.gif&#34; alt=&#34;real-time syntax check example&#34; width=&#34;309&#34; height=&#34;135&#34; /&gt;
&lt;em&gt;Figure 1. Real-time syntax checking&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The IDE in Figure 1 shows that line 4 has an error because of the missing &lt;code&gt;)&lt;/code&gt; and that line 5 has an error because there is no declaration of &lt;code&gt;$naame&lt;/code&gt; (and &lt;code&gt;use strict&lt;/code&gt; is in effect).&lt;/p&gt;

&lt;p&gt;A key point here is that the IDE shows these errors right away, before you save and compile the code. (In this example, the EPIC IDE lets you specify how often to run the syntax check, from 0.01 to 10.00 seconds of idle time, or only on demand.)&lt;/p&gt;

&lt;p&gt;As nice as this is, it would be even better if the IDE also offered ways to fix the problem, for example, offering to change &lt;code&gt;$naame&lt;/code&gt; to &lt;code&gt;$name&lt;/code&gt;. Figure 2 shows an IDE that does exactly that; unfortunately, for Java, not Perl.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_08_25_tools/syntax_help.gif&#34; alt=&#34;syntax help from the IDE&#34; width=&#34;427&#34; height=&#34;150&#34; /&gt;
&lt;em&gt;Figure 2. Syntax help from the IDE&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;It would be great if Perl IDEs offered this kind of help.&lt;/p&gt;

&lt;h4 id=&#34;span-id-version-control-integration-version-control-integration-span&#34;&gt;&lt;span id=&#34;Version_control_integration&#34;&gt;Version Control Integration&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;All non-insane large projects use version control software. The most common version control software systems are probably CVS, Perforce, Subversion, and Visual SourceSafe. Figure 3 shows an IDE comparing the local version of a file to an older version from the CVS repository.&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2005_08_25_tools/cvs_compare.gif&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_08_25_tools/cvs_compare_sm.gif&#34; alt=&#34;Figure 3&#34; width=&#34;220&#34; height=&#34;143&#34; /&gt;&lt;/a&gt;&lt;br /&gt;
Figure 3. Comparing a local file to an older version in CVS--click image for full-size screen shot&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;CVS integration is available in many modern code editors, including &lt;code&gt;emacs&lt;/code&gt;, &lt;code&gt;vim&lt;/code&gt;, and BBEdit, as well as graphical IDEs such as Eclipse and Komodo Pro. Subversion integration is available as a plugin for Eclipse; Komodo Pro supports Perforce and Subversion.&lt;/p&gt;

&lt;h4 id=&#34;span-id-code-assist-a-code-assist-editor-span&#34;&gt;&lt;span id=&#34;Code-assist&#34;&gt;A Code-Assist Editor&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Suppose that you have just typed in an object reference and want to call a method on the object, but you are not sure what the method name is. Wouldn&amp;rsquo;t it be nice if the editor popped up a menu listing all of the methods available for that object? It might look something like Figure 4.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_08_25_tools/auto_completion.gif&#34; alt=&#34;automatic code completion&#34; width=&#34;399&#34; height=&#34;335&#34; /&gt;
&lt;em&gt;Figure 4. Automatic code completion&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;In this example, the IDE is able to figure out which class the object &lt;code&gt;$q&lt;/code&gt; is an instance of and lists the names of the available methods. If you type a &lt;code&gt;p&lt;/code&gt;, then the list shows only the method names beginning with &lt;code&gt;p&lt;/code&gt;. If you type &lt;code&gt;pa&lt;/code&gt;, then the list shows only the &lt;code&gt;param()&lt;/code&gt; and &lt;code&gt;parse_params()&lt;/code&gt; methods.&lt;/p&gt;

&lt;h4 id=&#34;span-id-refactoring-support-excellent-refactoring-support-span&#34;&gt;&lt;span id=&#34;refactoring_support&#34;&gt;Excellent Refactoring Support&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The easier it is to do refactoring, the more often people will do it. The following list contains the most common refactorings. Your personal list will probably be a little different. All of these are things you can do &amp;ldquo;manually,&amp;rdquo; but the idea is to make them into one or two-click operations so that you will do them much more often. (For a extensive list of refactoring operations, see &lt;a href=&#34;http://www.refactoring.com/catalog/&#34;&gt;Martin Fowler&amp;rsquo;s alphabetical list of refactorings&lt;/a&gt;.)&lt;/p&gt;

&lt;h5 id=&#34;span-id-extract-subroutinemethod-extract-subroutine-method-span&#34;&gt;&lt;span id=&#34;Extract_SubroutineMethod&#34;&gt;Extract Subroutine/Method&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;The IDE should create a new subroutine using the selected code and replace the selected code with a call to the new subroutine, with the proper parameters. Here&amp;rsquo;s an example of using the Extract Subroutine refactoring from Eclipse/EPIC (which uses the &lt;a href=&#34;https://metacpan.org/pod/Devel::Refactor&#34;&gt;Devel::Refactor&lt;/a&gt; module).&lt;/p&gt;

&lt;p&gt;First, you select a chunk of code to turn into a new subroutine, and then select Extract Subroutine from a context menu. You then get the a dialog box asking for the name of the new subroutine (shown in Figure 5).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_08_25_tools/extract_subroutine_before.gif&#34; alt=&#34;code before Extract Subroutine refactoring&#34; width=&#34;500&#34; height=&#34;329&#34; /&gt;
&lt;em&gt;Figure 5. Code before Extract Subroutine refactoring&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The IDE replaces the selected code with a call to the new subroutine, making reasonable guesses about the parameters and return values (Figure 6). You may need to clean up the result manually.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_08_25_tools/extract_subroutine_after.gif&#34; alt=&#34;code after Extract Subroutine refactoring&#34; width=&#34;500&#34; height=&#34;45&#34; /&gt;
&lt;em&gt;Figure 6. Code after Extract Subroutine&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Figure 7 shows the new subroutine created by the IDE. In this case, it needs no changes, but sometimes you will need to adjust the parameters and/or return value(s).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_08_25_tools/extract_subroutine_newsub.gif&#34; alt=&#34;the new subroutine created by Extract Subroutine&#34; width=&#34;314&#34; height=&#34;241&#34; /&gt;
&lt;em&gt;Figure 7. The new subroutine created by Extract Subroutine&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Ideally, the editor should prompt you to replace similar chunks of code with calls to the new subroutine.&lt;/p&gt;

&lt;h5 id=&#34;span-id-rename-subroutinemethod-rename-subroutine-method-span&#34;&gt;&lt;span id=&#34;Rename_SubroutineMethod&#34;&gt;Rename Subroutine/Method&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;The IDE should find all the calls to the subroutine throughout your project and offer to change them for you. You should be able to see a preview of all of the places a change could occur, and to accept or reject each one on a case-by-case basis. The action should be undoable.&lt;/p&gt;

&lt;h5 id=&#34;span-id-rename-variable-rename-variable-span&#34;&gt;&lt;span id=&#34;Rename_Variable&#34;&gt;Rename Variable&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;Like Rename Subroutine, this feature should find all occurrences throughout the project and offer to make the changes for you.&lt;/p&gt;

&lt;h5 id=&#34;span-id-change-subroutinemethod-signature-change-subroutine-method-signature-span&#34;&gt;&lt;span id=&#34;Change_SubroutineMethod_signature&#34;&gt;Change Subroutine/Method Signature&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;The IDE should be able to make reasonable guesses about whether each subroutine or method call is supplying the proper parameters. Partly this is to enable the &lt;a href=&#34;?page=2#Syntax-checking&#34;&gt;real-time syntax checking mentioned above&lt;/a&gt;, and partly this is to enable you to select a subroutine declaration and tell the IDE you want to refactor it by adding or removing a parameter. The IDE should then prompt you for the change(s) you want to make, do its best to find all of the existing calls to the subroutine, and offer to correct the subroutine calls to supply the new parameters.&lt;/p&gt;

&lt;p&gt;Obviously, this is an especially tricky thing to do in Perl, where subroutines fish their parameters out of &lt;code&gt;@_&lt;/code&gt;. So the IDE would have to look carefully at how the code uses &lt;code&gt;shift&lt;/code&gt;, &lt;code&gt;@_&lt;/code&gt;, and &lt;code&gt;$_[]&lt;/code&gt; in order to have a reasonable guess about the parameters the subroutine is expecting. In many common cases, though, a Perl IDE could make a reasonable guess about the parameters, such as in the following two examples, so that if you added or removed one, it could immediately prompt you about making corrections throughout the project:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub doSomething {
    my $gender = shift;
    my $age    = shift;
    # Not too terribly hard to guess that $gender and $age are params
}

sub anotherThing {
    my ($speed,$direction) = @_;
    # No magic needed to guess $speed and $direction are params.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;span-id-move-subroutinemethod-to-different-move-subroutine-method-span&#34;&gt;&lt;span id=&#34;Move_SubroutineMethod_to_different&#34;&gt;Move Subroutine/Method&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;This refactoring operation should give you a list or dialog box to choose the destination file in your project. The IDE should allow you to preview all of the changes that it would make to accomplish the move, which will include updating a call to the subroutine/method to use the proper class. At a minimum, the IDE should show you or list all of the calls to the subroutine so you can make the appropriate changes yourself. Ideally, the IDE should make a guess about possible destinations; for example, if &lt;code&gt;$self&lt;/code&gt; is a parameter to the method being moved, then the IDE might try assuming the method is an object (instance) method and initially only list destination classes that inherit from the source class, or from which the source class inherits.&lt;/p&gt;

&lt;h5 id=&#34;span-id-change-package-name-change-a-package-name-span&#34;&gt;&lt;span id=&#34;Change_package_name&#34;&gt;Change a Package Name&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;As with Rename Subroutine and Rename Variable, when changing a package name, the IDE should offer to update all existing references throughout your project.&lt;/p&gt;

&lt;h4 id=&#34;span-id-tree-view-of-source-tree-view-and-navigation-of-source-files-and-resources-span&#34;&gt;&lt;span id=&#34;Tree_view_of_source&#34;&gt;Tree View and Navigation of Source Files and Resources&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Another useful feature of good IDEs is being able to view all of the code for a project, or multiple projects, in a tree format, where you can &amp;ldquo;fold&amp;rdquo; and &amp;ldquo;unfold&amp;rdquo; the contents of folders. All of the modern graphical IDEs support this, even with multiple projects in different languages.&lt;/p&gt;

&lt;p&gt;Being able to view your project in this manner gives you both a high-level overview and the ability to drill down into specific files, and to mix levels of detail by having some folders show their contents and some not.&lt;/p&gt;

&lt;p&gt;For example, Figure 8 shows a partial screen shot from ActiveState&amp;rsquo;s Komodo IDE.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_08_25_tools/komodo_code_tree.gif&#34; alt=&#34;tree view of code in Komodo&#34; width=&#34;204&#34; height=&#34;318&#34; /&gt;
&lt;em&gt;Figure 8. Tree view of code in Komodo&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-support-for-unit-tests-support-for-creating-and-running-unit-tests-span&#34;&gt;&lt;span id=&#34;support_for_unit_tests&#34;&gt;Support for Creating and Running Unit Tests&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Anyone who has installed Perl modules from CPAN has seen unit tests&amp;ndash;these are the various, often copious, tests that run when you execute the &lt;code&gt;make test&lt;/code&gt; part of the installation process. The vast majority of CPAN modules include a suite of tests, often using the &lt;a href=&#34;https://metacpan.org/pod/Test::Harness&#34;&gt;Test::Harness&lt;/a&gt; and/or &lt;a href=&#34;https://metacpan.org/pod/Test::More&#34;&gt;Test::More&lt;/a&gt; modules. A good IDE will make it very easy to both create and run unit tests as you develop your project.&lt;/p&gt;

&lt;p&gt;The most basic form of support for unit tests in an IDE is simply to make it easy to execute arbitrary scripts from within the IDE. Create a &lt;em&gt;test.pl&lt;/em&gt; for your project and keep adding tests to it or to a &lt;em&gt;t/&lt;/em&gt; subdirectory as you develop, and keep running the script as you make changes. All modern IDEs provide at least this minimal capability.&lt;/p&gt;

&lt;p&gt;A more sophisticated level of support for unit tests might resemble the Java IDE feature for tests written in JUnit, where you can select an existing class file (a &lt;em&gt;.pm&lt;/em&gt; file in Perl) and ask the IDE to create a set of stub tests for every subroutine in the file. (See &lt;a href=&#34;http://www.junit.org/&#34;&gt;JUnit&lt;/a&gt; and the Perl module &lt;code&gt;Test::Unit&lt;/code&gt; for more on unit tests.) Furthermore, the IDE should support running a set of tests and giving simple visual feedback on what passed/failed. The standard approach in the JUnit world is to show either a &amp;ldquo;green bar&amp;rdquo; (all passed) or &amp;ldquo;red bar&amp;rdquo; (something failed) and then allow you to see details on failures. Other nice-to-have features include calculating code-coverage, providing statistical summaries of tests, etc.&lt;/p&gt;

&lt;p&gt;Figure 9 shows a successful run of a Java test suite with Eclipse.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_08_25_tools/unit_tests_success.gif&#34; alt=&#34;JUnit test run, success&#34; width=&#34;339&#34; height=&#34;199&#34; /&gt;
&lt;em&gt;Figure 9. A successful JUnit test run&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Figure 10 shows the same test run, this time with a failure.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_08_25_tools/unit_tests_failure.gif&#34; alt=&#34;JUnit test run, with a failure.&#34; width=&#34;339&#34; height=&#34;222&#34; /&gt;
&lt;em&gt;Figure 10. A JUnit test run with a failure&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A stack trace of the failure message appears in another part of the window (cropped out here to save space). If you double-click on the test that failed (&lt;code&gt;testInflate&lt;/code&gt;), the IDE will open the file (&lt;code&gt;BalloonTest&lt;/code&gt;, in this case) and navigate to the test function.&lt;/p&gt;

&lt;p&gt;The central idea is that the IDE should make it as painless as possible to add and modify and run tests, so you will do more of it during development.&lt;/p&gt;

&lt;h4 id=&#34;span-id-language-specific-help-language-specific-help-span&#34;&gt;&lt;span id=&#34;Language-specific_help&#34;&gt;Language-Specific Help&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;This is a fairly straightforward idea&amp;ndash;the IDE should be able to find and display the appropriate documentation for any keyword in your code, so if you highlight &lt;code&gt;push&lt;/code&gt; and ask for help, you should see the &lt;code&gt;push&lt;/code&gt; entry from the Perl documentation. If you highlight a method or subroutine or other symbol name from an imported module, the IDE should display the module&amp;rsquo;s documentation for the selected item. Of course, this requires that the documentation be available in a consistent, machine-readable form, which is only sometimes true.&lt;/p&gt;

&lt;h4 id=&#34;span-id-debugger-debugger-with-real-time-display-of-results-span&#34;&gt;&lt;span id=&#34;Debugger&#34;&gt;Debugger with Real-Time Display of Results&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;All modern IDEs offer support for running your code under a debugger, usually with visual display of what&amp;rsquo;s going on, including the state of variables. The &lt;a href=&#34;http://aspn.activestate.com/ASPN/docs/Komodo/3.1/komodo-doc-debugperl.html#debugperl_top&#34;&gt;Komodo IDE supports debugging Perl that is running either locally or remotely&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Typical support for debugging in an IDE includes the ability to set breakpoints, monitor the state of variables, etc. Basically, the IDE should provide support for all of the features of the debugger itself. Graphical IDEs should provide a visual display of what is going on.&lt;/p&gt;

&lt;h4 id=&#34;span-id-automatic-reformatting-automatic-code-reformatting-span&#34;&gt;&lt;span id=&#34;Automatic_reformatting&#34;&gt;Automatic Code Reformatting&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;This means automatically or on-demand re-indenting and other reformatting of code. For example, when you cut and paste a chunk of code, the IDE should support reformatting the chunk to match the indentation of its new location. If you change the number of spaces or tabs for each level of indentation, or your convention for the placement of curly braces, then the IDE should support adjusting an entire file or all files in your project.&lt;/p&gt;

&lt;h4 id=&#34;span-id-handling-of-multiple-languages-seamless-handling-of-multiple-languages-span&#34;&gt;&lt;span id=&#34;handling_of_multiple_languages&#34;&gt;Seamless Handling of Multiple Languages&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Many large software projects involve multiple languages. This is almost universally true in the case of web applications, where the user interface typically uses HTML, CSS, and JavaScript, and the back end uses one or more of Perl, PHP, Java, Python, Ruby, etc. It is very helpful to have development tools that seamlessly integrate work done in all of the languages. This is becoming quite common. For example, both Komodo and Eclipse support multiple languages.&lt;/p&gt;

&lt;h4 id=&#34;span-id-automated-build-and-test-automated-building-and-testing-span&#34;&gt;&lt;span id=&#34;Automated_build_and_test&#34;&gt;Automated Building and Testing&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;This feature can be very basic by making it easy to run an arbitrary script from within the IDE and to see its output. This could be as simple as having the IDE configured to have a one-click way of running the traditional Perl module build-and-test commands:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl Makefile.PL
$ make
$ make test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A more advanced version of this feature might involve having the IDE create stub code to test all of the subroutines in an existing file, or to run all of the scripts in a specified directory under &lt;code&gt;Test::Harness&lt;/code&gt;, or to run a set of tests using &lt;a href=&#34;https://metacpan.org/pod/Test::Unit::TestRunner&#34;&gt;Test::Unit::TestRunner&lt;/a&gt; or &lt;a href=&#34;https://metacpan.org/pod/Test::Unit::TkTestRunner&#34;&gt;Test::Unit::TkTestRunner&lt;/a&gt;. (The latter provides a GUI testing framework.)&lt;/p&gt;

&lt;h3 id=&#34;conclusion-and-recommendations&#34;&gt;Conclusion and Recommendations&lt;/h3&gt;

&lt;p&gt;While there are many tools for helping Perl development, the current state of the Perl toolbox is still years behind those of other languages&amp;ndash;perhaps three to five years behind, when compared to Java tools. While there are several tools for Java that have all the features described above, virtually none for Perl have all of them. On the other hand, things are looking up; they are better now than a year ago. It&amp;rsquo;s possible to close that gap in a year or two.&lt;/p&gt;

&lt;p&gt;A couple of obvious areas where improvements could be somewhat easy are adding more features to EPIC and Komodo. EPIC is open source, so there is potentially a wider pool of talent that could contribute. On the other hand, Komodo has a company with money behind it, so people actually get paid to improve it. Hopefully both tools will get better with time.&lt;/p&gt;

&lt;p&gt;Another interesting possibility is the development of new IDEs or adding to existing ones by using &lt;a href=&#34;http://localhost:1313/pub/2005/06/09/ppi.html&#34;&gt;Adam Kennedy&amp;rsquo;s PPI module&lt;/a&gt;, which provides the ability to parse Perl documents into a reasonable abstract syntax tree and to manipulate the elements and re-compose the document. There is a &lt;a href=&#34;https://metacpan.org/pod/Text::Editor::Vip&#34;&gt;new Perl editor project, VIP, that is in the design stages&lt;/a&gt; and is intended to be &amp;ldquo;pluggable&amp;rdquo; and to have special features to support pair programming.&lt;/p&gt;

&lt;p&gt;Finally, I&amp;rsquo;ve gathered a couple of lists of links for related material. The first list below consist of IDEs and graphical editors for Perl, and the second list consists of various related articles and websites. I hope this is all inspirational and helpful.&lt;/p&gt;

&lt;h3 id=&#34;current-ides-for-perl&#34;&gt;Current IDEs for Perl&lt;/h3&gt;

&lt;p&gt;The listed IDEs support Perl. The list is undoubtedly incomplete, but should form a good starting point for anyone wishing to look into this further.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.latenightsw.com/affrus/&#34;&gt;Affrus&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Perl only, Mac OS X only. Closed source (and hence not extensible by users). Primarily designed for CGI and standalone scripts. Free demo available. $99 to purchase. (See the &lt;a href=&#34;http://localhost:1313/pub/2004/05/14/affrus.html&#34;&gt;Perl.com review of Affrus&lt;/a&gt; to learn more.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://e-p-i-c.sf.net/&#34;&gt;Eclipse/EPIC&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;EPIC is a plugin for the &lt;a href=&#34;http://www.eclipse.org/&#34;&gt;Eclipse platform&lt;/a&gt;. Eclipse is open-source and cross platform (Windows/Mac/Linux/Solaris, etc.). Once you have Eclipse installed, &lt;a href=&#34;http://e-p-i-c.sf.net/updates&#34;&gt;install the EPIC plugin from within the Eclipse application&lt;/a&gt; using the &lt;a href=&#34;http://e-p-i-c.sf.net/updates/&#34;&gt;EPIC update URL&lt;/a&gt;. Eclipse supports Java, and with plugins, C/C++, COBOL, Perl, PHP, UML2, Python, Ruby, XML, and more. There is a large and active community around Eclipse.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Emacs is the mother of all text-editor/development-environment/adventure-game/all-in-one tools. Expert programmers use it widely and there are numerous enhancements for working with particular languages, including, of course, Perl. &lt;a href=&#34;http://www.emacswiki.org/cgi-bin/wiki/CPerlMode&#34;&gt;Emacs, with CPerlMode&lt;/a&gt;, is a richly featured IDE for Perl, albeit a non-GUI IDE (which, for some people, makes it even better). &lt;a href=&#34;http://groups.yahoo.com/group/extremeperl/files/&#34;&gt;A set of extensions for CPerlMode are available&lt;/a&gt; but you need to join the Yahoo Extreme Perl group to get to them.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.activestate.com/Products/Komodo/&#34;&gt;Komodo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This runs on Linux, Solaris, and Windows. Free demo; $29.95 for personal and student use, $295 for commercial use. It supports Perl, PHP, Python, Tcl, and XSLT.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.elora.hostings.com/SOFTWARE/page/&#34;&gt;PAGE&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;PAGE runs only on Windows (9x/ME/NT/2000/XP). It is a Rapid Application Development tool for Perl and comes in three versions: Free, Standard ($10), and Enterprise ($50). PAGE provides a several &amp;ldquo;wizards&amp;rdquo; for creating scripts, modules (packages), web forms, and even database applications.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.enginsite.com/Perl.htm&#34;&gt;Perl Editor&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This closed source program runs only on Windows (9x/NT/2000/XP). It has a GUI code profiler, and the Pro version has a regular expression tester and built-in web server (for CGI testing, etc.). Perl Editor claims to have the best debugger on the market. It also comes with GUI tools for managing MySQL databases. $69.95 to purchase.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.vim.org&#34;&gt;&lt;code&gt;vim&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The well-known descendent of &lt;code&gt;vi&lt;/code&gt; is a powerful and flexible text editor with many plugins and extensions. Have a look at the &lt;a href=&#34;https://www.vim.org&#34;&gt;&lt;code&gt;vim&lt;/code&gt; scripts&lt;/a&gt;; for example, &lt;a href=&#34;https://www.vim.org/scripts/script.php?script_id=556&#34;&gt;Perl-Support&lt;/a&gt; and &lt;a href=&#34;https://github.com/vim-scripts/ExecPerl&#34;&gt;ExecPerl&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.helpconsulting.net/visiperl/&#34;&gt;visiPerl&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This is a closed source application that runs on Win9x/NT/2000. It handles Perl and HTML and has code templates, being designed for website building. visiPerl includes a built-in web server for testing and an FTP client for code deployment. There is a free demo, or you can purchase it for $59.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;related-topics&#34;&gt;Related Topics&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.artima.com/intv/testdriven.html&#34;&gt;A conversation about Test-Driven Development&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;&lt;a href=&#34;http://www.petdance.com/perl/automated-testing/&#34;&gt;Automated Testing With Perl&lt;/a&gt;,&amp;rdquo; Andy Lester&amp;rsquo;s presentation on doing automated testing in Perl&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.extremeperl.org/bk/home&#34;&gt;Extreme Perl book&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://groups.yahoo.com/group/extremeperl/&#34;&gt;Extreme Perl mailing list&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jera.com/techinfo/xpfaq.html&#34;&gt;eXtreme Programming FAQ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://agilemanifesto.org/&#34;&gt;Manifesto for Agile Software Development&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;&lt;a href=&#34;http://localhost:1313/pub/2005/06/09/ppi.html&#34;&gt;Parse Perl Independently&lt;/a&gt;,&amp;rdquo; an article about Adam Kennedy&amp;rsquo;s PPI module&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.testdriven.com/&#34;&gt;testdriven.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.junit.org/&#34;&gt;JUnit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Jon Udell&amp;rsquo;s article on &amp;ldquo;&lt;a href=&#34;http://weblog.infoworld.com/udell/2005/05/23.html#a1236&#34;&gt;Tools for Dynamic Languages&lt;/a&gt;&amp;ldquo;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.refactoring.com/&#34;&gt;Refactoring home page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.xprogramming.com/&#34;&gt;XProgramming.com&lt;/a&gt;: Resources for and about Agile Software Development&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Affrus: An OS X Perl IDE</title>
      <link>http://localhost:1313/pub/2004/05/14/affrus.html/</link>
      <pubDate>Fri, 14 May 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/05/14/affrus.html/</guid>
      <description>&lt;p&gt;When I &lt;a href=&#34;http://localhost:1313/pub/2002/10/09/komodo.html&#34;&gt;last reviewed&lt;/a&gt; a Perl IDE, ActiveState&amp;rsquo;s Komodo, I was nearly convinced; the only problem was that I use Mac OS X. Now, &lt;a href=&#34;http://www.latenightsw.com/&#34;&gt;Late Night Software&lt;/a&gt;, more commonly known for their AppleScript tools, have taken their Mac programming experience and applied it to create &lt;a href=&#34;http://www.latenightsw.com/affrus/index.html&#34;&gt;Affrus&lt;/a&gt;, a Perl IDE for the Mac. And I&amp;rsquo;m a little closer to being convinced.&lt;/p&gt;

&lt;p&gt;Affrus differs from Komodo in some substantial ways. Where Komodo couples its editor tightly with a Perl interpreter to allow background syntax checking and on-the-fly warnings highlighting, Affrus takes a more traditional, detached approach: syntax checks are performed on demand, with errors and warnings placed in a separate panel. Fans of &lt;code&gt;emacs&lt;/code&gt;&amp;rsquo;s debugging modes will be happier to see this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2004_05_14_affrus/affrus-stricterror.jpg&#34; width=&#34;500&#34; height=&#34;280&#34; /&gt;
It took me quite awhile to discover the control-click contextual menu &amp;ndash; since the downside of &amp;ldquo;intuitive&amp;rdquo; applications is that we don&amp;rsquo;t get a nice manual to read any more &amp;ndash; but when I did I was amazingly impressed. Right-clicking on a package name does just what you want; it allows you to edit that package&amp;rsquo;s file, or to view its documentation with perldoc. Similarly, right-clicking on a built-in offers to bring up perldoc for that function.&lt;/p&gt;

&lt;p&gt;Right-clicking on the name of a subroutine lets you navigate to the definition of that routine &amp;ndash; even doing a remarkably good job at working out what class a method will come from. And right-clicking on a variable name takes you to where that variable was declared. Right-clicking on the navigation bar at the bottom of the window brings up a &amp;ldquo;table of contents&amp;rdquo; for the program, allowing you to navigate to any of the modules it uses and any of the subroutines it defines. If you right-click on empty space, however, you get a listing of variables and subroutine names that can be inserted at that location. Full marks for this, and the more time I spend with the Affrus editor, the more neat things like this I find.&lt;/p&gt;

&lt;p&gt;On the whole, though, the Affrus editor is relatively basic. While its syntax highlighting is more sophisticated than most, distinguishing between package, lexical, and special variables, for instance, it does not handle code folding, nor does it have &amp;ldquo;smart&amp;rdquo; auto-indenting. It&amp;rsquo;s quite comparable to the original &lt;code&gt;emacs&lt;/code&gt; &lt;code&gt;perl-mode&lt;/code&gt;. However, this isn&amp;rsquo;t necessarily a problem, due to Affrus&amp;rsquo; integration with other editors such as BBEdit and TextWrangler; additionally, Late Night&amp;rsquo;s AppleScript experience has enabled them to design Affrus to be extensible and scriptable. Script plugins provided with Affrus allow it to reformat code with &lt;code&gt;perltidy&lt;/code&gt;, as well as to insert control structures and other snippets into the current file.&lt;/p&gt;

&lt;p&gt;As well as its scriptability, the real boon in Affrus is in its debugging console; on top of the usual debugging actions of stepping over a script, jumping in and out of subroutines, setting breakpoints, and so on, it presents at every step a detailed listing of all the variables in play, allowing you to look inside complex data structures with OS X&amp;rsquo;s familiar disclosure triangles:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2004_05_14_affrus/affrus-debug.jpg&#34; width=&#34;500&#34; height=&#34;337&#34; /&gt;
As one would expect, it automatically loads up modules and other external Perl code while debugging, allowing you to step over their code, too. You can also change the value of variables during debugging, as well as enter arbitrary Perl expressions in the &amp;ldquo;Expressions&amp;rdquo; pane.&lt;/p&gt;

&lt;p&gt;Affrus offers a few other interesting little features, such as the debugger&amp;rsquo;s ability to detect and highlight circular references, and the bundled command line tool. This utility enables you to debug a Perl program in Affrus while having complete control over the environment and standard IO redirections &amp;ndash; a major bridge between GUI-based debugging and the &amp;ldquo;real world&amp;rdquo; of complex Perl program deployments.&lt;/p&gt;

&lt;p&gt;There are a few things Affrus doesn&amp;rsquo;t do which I&amp;rsquo;d like, but to be honest they&amp;rsquo;re a part of the way I use Perl &amp;ndash; an IDE with integrated debugger and Perl-aware editor is a great environment for creating standalone Perl scripts where you&amp;rsquo;re running through a process, breaking at significant moments, inspecting the control flow and the state of the variables. However, when you work primarily at the level of Perl modules and Apache handlers, there is no real top-level &amp;ldquo;process&amp;rdquo; to step through, and a traditional debugging environment becomes much less useful.&lt;/p&gt;

&lt;p&gt;That said, in such a debugging environment, I&amp;rsquo;d love to see Affrus have a Perl debugger pane at which one could execute Perl code during a debugger run; inspecting the variables is great, but there ought to be a way to change them, too! There are other changes I&amp;rsquo;d like to see in the future, ranging from something as trivial as a color scheme palette &amp;ndash; the first thing I did on running Affrus was to spend 10 minutes configuring it with a set of colors that look nice on a black background instead of a white one! &amp;ndash; to full-blown integration with either CVS or even Apple&amp;rsquo;s Xcode IDE.&lt;/p&gt;

&lt;p&gt;On the whole, however, I&amp;rsquo;m very impressed by Affrus, and I&amp;rsquo;m convinced that, even if it&amp;rsquo;s not to your taste yet, it is certain to grow into a mature and powerful Perl IDE for OS X.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Perl Builder IDE Debuts</title>
      <link>http://localhost:1313/pub/1998/07/review.html/</link>
      <pubDate>Wed, 22 Jul 1998 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/1998/07/review.html/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Overview:&lt;/strong&gt;
Perl Builder, by &lt;a href=&#34;http://www.solutionsoft.com&#34;&gt;Solutionsoft&lt;/a&gt;, is the first integrated development environment (IDE) for Perl. It allows you to develop and test Perl applications in a Windows 95/98/NT environment.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Test Equipment:&lt;/strong&gt;
I tested Perl Builder on a machine with a Cyrix 6x86/200MHz processor and 48Mb RAM using Windows 95 and then the same machine using Windows 98. Both of these test machines used the ActiveState Perl port. I also tested Perl Builder on a Pentium 166 with 96Mb RAM running Windows NT. This machine used the latest Gurusamy Sarathy port of Perl.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Installation:&lt;/strong&gt;
Installing Perl Builder took about 5 minutes. It was very simple and I had no installation problems. I was surprised by the nice, clean interface and yet the program was only around 750kb in size before installation! To me, this is remarkable in an age where IDE&amp;rsquo;s can easily take over 100Mb of space. Granted, Perl Builder is really just a text editor that integrates with Perl so there are no libraries or any Perl-related files included with the program.&lt;/p&gt;

&lt;p&gt;To use Perl Builder, you need to have Perl installed on your system. You can use either the ActiveState Perl port or the &amp;ldquo;Gurusamy Sarathy&amp;rdquo; port of Perl. Neither of which come with Perl Builder, but Solutionsoft does provide links so that you can easily download them. I recommend the &amp;ldquo;Gurusamy Sarathy&amp;rdquo; version.&lt;/p&gt;

&lt;p&gt;Once installed, my first task was to run through the tutorial provided. The tutorial walks you through creating a &amp;ldquo;mailto&amp;rdquo; form using an HTML form that they provide. It worked as advertised and was an easy-to-follow tutorial that provides you with a good overview of the IDE.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Programming Environment&lt;/strong&gt;
Perl Builder is basically a text editor that has been written specifically for writing Perl scripts. Perl Builder provides a simple programming environment that is easy to get comfortable with. The different windows in the IDE are &amp;ldquo;tabbed&amp;rdquo; for easy access. The normal tabs are &lt;em&gt;Main Script, Input Values,&lt;/em&gt; and &lt;em&gt;Output: HTML/Text&lt;/em&gt;. Other tabs, like &lt;em&gt;errors,&lt;/em&gt; are added as needed.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1998_07_review/perlbuilder.gif&#34; alt=&#34;The Perl Builder Window&#34; width=&#34;450&#34; height=&#34;327&#34; /&gt;
&lt;strong&gt;Figure 1: Perl Builder&amp;rsquo;s visual editor&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;Main Script&lt;/em&gt; tab is the area where you actually write the script. The code that you write is automatically color-coded by Perl Builder and the colors are user-customizeable Having color-coded Perl code makes viewing the code much easier. I found that once you get accustomed to the colors, you can quickly scan the code for what you are looking for.&lt;/p&gt;

&lt;p&gt;The *Input Values*tab allows you to specify either the values that you would have sent from an HTML form if you are writing a CGI script. Or, from STDIN if you are writing a non-CGI script.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;Output&lt;/em&gt; tab shows you what output your Perl application produced. If you are writing a CGI script, there is a button on this tab that allows you to view the code in a web browser. Perl Builder actually takes the output from your script, and produces a local HTML file for the browser view.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;Errors&lt;/em&gt; tab does exactly what you would expect it to do, it shows you any errors that were generated by your script. The feature I liked here is that you can double-click on the error, and you are taken right to that line of code on the &lt;em&gt;Main Script&lt;/em&gt; tab.&lt;/p&gt;

&lt;p&gt;When a CGI script generates one or more e-mail messages, Perl Builder also provides a tab that shows you what the e-mail(s) would look like.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Debugging&lt;/strong&gt;
Perl Builder includes some great features for debugging your code. You can set breakpoints, watches, step through your code or do just about anything that an IDE debugger should do. You can also run with &amp;ldquo;strict&amp;rdquo; or evaluate your code with the -w flag.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Nice Features&lt;/strong&gt;
Perl Builder has many nice features. My favorites were:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;*Editor-scripts
*The &lt;em&gt;Editor-scripts&lt;/em&gt; menu item, my favorite tool, allows you to write Perl scripts that will be performed on your code. Solutionsoft includes a few like block-comment and block-uncomment. I wrote a quick one that allows me to add line-numbers to my code and replace all of the &amp;lt; and &amp;gt;&amp;rsquo;s in my code with their HTML equivalents. This saves me a great deal of time when I write code for articles. Now I just highlight the code, and let Perl Builder do everything for me.&lt;/p&gt;

&lt;p&gt;To use the editor scripts, all you do is highlight the code you want to perform the action on, and choose the appropriate item from the menu. The code is executed only on the part of your script that you highlighted. Plus, you don&amp;rsquo;t have to learn any new &amp;ldquo;scripting languages&amp;rdquo;, it is all customized with Perl code.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;*Regular Expression Search/Replace&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;This feature allows you to use the power of Perl and create complex search/replace regular expressions that are executed on your script.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;*CGI Wizard&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The CGI Wizard in Perl Builder allows even non-programmers to write CGI scripts that can accept HTML form data, validate the entries, e-mail multiple messages to multiple recipients and generate response pages on-the-fly. The CGI Wizard steps you through the process and does 99% of the work for you. All you have to do is choose an HTML form, the wizard imports the variables and then steps you through the rest of the process.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Weaknesses&lt;/strong&gt;
Perl Builder is a great product, but there were a few items that I&amp;rsquo;d like to see addressed.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The menu bar at the top of the IDE did not have a &lt;em&gt;print&lt;/em&gt; button. I like to print my code out and draw all over it, while this is just a minor detail, I&amp;rsquo;d like to see it added.&lt;/li&gt;
&lt;li&gt;When generating forms on-the-fly, Perl Builder only allows you to create and test the first form. You cannot test scripts on code that was dynamically generated. The ability to test the dynamically generated forms would add to the complexity of the program, but it is needed to fully test CGI scripts. I write many scripts that dynamically generate HTML forms and call themselves with these new forms.&lt;/li&gt;
&lt;li&gt;When using the watch portion of the debugger, I found that when I closed the watch window I began getting errors from Perl even though none of the code had changed. I found that if I closed Perl Builder and restarted it, all was well again.&lt;/li&gt;
&lt;li&gt;I also ran into a few graphic glitches while using the program. The graphic problems were much better than in the beta that I had tested previously but they were still annoying. I am confident that as this program evolves, this is still version 1.0 of the program, these glitches will be worked out.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Wrapping It Up&lt;/strong&gt;
Overall, Perl Builder is a great program and is something that should have been developed a long time ago. It is a great tool for both beginning Perl programmers, and experienced Perl programmers. Perl Builder&amp;rsquo;s clean interface and powerful features take much of the unnecessary work out of Perl programming.&lt;/p&gt;

&lt;p&gt;While it is not perfect, and can&amp;rsquo;t handle some of the more complex Perl programs, it is a great environment for developing most of your CGI scripts. The ability to easily test your scripts locally is something that makes CGI programming much easier.&lt;/p&gt;

&lt;p&gt;The price for Perl Builder is $149. Although I think that the price is reasonable, I think it would do better if the price was around the $99 range. Perl developers have become accustomed to free software and I think that they may have a hard time spending almost $150 for a &amp;ldquo;helper&amp;rdquo; program.&lt;/p&gt;

&lt;p&gt;Overall, I give Perl Builder a 4.5 out of 5 camel rating.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Author&amp;rsquo;s note: I was contacted by Solutionsoft and told that a version 1.0a would be released sometime this week. Version 1.0a is supposed to fix many of the bugs that we found in version 1.0. An update to this article will be added when I have had a chance to evaluate the new version.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

