<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dropbox on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/dropbox/</link>
    <description>Recent content in Dropbox on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 06 Feb 2018 08:35:11 +0000</lastBuildDate>
    <atom:link href="/tags/dropbox/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>How strong is your password?</title>
      <link>http://localhost:1313/article/how-strong-is-your-password-/</link>
      <pubDate>Tue, 06 Feb 2018 08:35:11 +0000</pubDate>
      
      <guid>http://localhost:1313/article/how-strong-is-your-password-/</guid>
      <description>

&lt;p&gt;In the latest &lt;a href=&#34;http://localhost:1313/article/what-s-new-on-cpan---january-2018/&#34;&gt;what-s new on CPAN&lt;/a&gt;, I linked to &lt;a href=&#34;https://metacpan.org/pod/Data::Password::zxcvbn&#34;&gt;Data::Password::zxcvbn&lt;/a&gt;, a new module which estimates the difficulty of cracking a given password. Developed by Gianni Ceccarelli, it&amp;rsquo;s a port of Dropbox&amp;rsquo;s JavaScript implementation by Dan Wheeler.&lt;/p&gt;

&lt;h3 id=&#34;how-it-works&#34;&gt;How it works&lt;/h3&gt;

&lt;p&gt;Dan Wheeler&amp;rsquo;s original blog &lt;a href=&#34;https://blogs.dropbox.com/tech/2012/04/zxcvbn-realistic-password-strength-estimation/&#34;&gt;post&lt;/a&gt; explains this in detail, but here&amp;rsquo;s a quick summary. To estimate a password&amp;rsquo;s strength we measure its &lt;a href=&#34;https://en.wikipedia.org/wiki/Password_strength#Entropy_as_a_measure_of_password_strength&#34;&gt;entropy&lt;/a&gt;. The zxcvbn algorithm estimates a password&amp;rsquo;s entropy in three stages:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;match - matches parts of a password against patterns like: known words, sequences, dates etc&lt;/li&gt;
&lt;li&gt;score - for every matched pattern, calculate its entropy&lt;/li&gt;
&lt;li&gt;search - find the lowest entropy sequence of non-overlapping matches&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Imagine the password &amp;ldquo;baseball2005-59xH}&amp;rdquo;; zxcvbn will match &amp;ldquo;baseball&amp;rdquo; in its popular words dictionary, so its entropy is quite low. Similarly, &amp;ldquo;2005&amp;rdquo; will match the year pattern. On the other hand, the last part &amp;ldquo;-59xH}&amp;rdquo; isn&amp;rsquo;t in our word list, nor does it match any of zxcvbn&amp;rsquo;s common patterns and would require brute-force guessing, which has a very high entropy. Thus zxcvbn&amp;rsquo;s entropy for the password would be in pseudo code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dictionary_entropy(&amp;quot;baseball&amp;quot;) + year_entropy(&amp;quot;2005&amp;quot;) + brute_force_entropy(&amp;quot;59xH{&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once it has calculated the entropy of a password, zxcvbn estimates other statistics like how many guesses it would take to crack the password, and the password cracking time.&lt;/p&gt;

&lt;h3 id=&#34;installation&#34;&gt;Installation&lt;/h3&gt;

&lt;p&gt;Data::Password::zxcvbn is on CPAN, so installation can be done with your favorite CPAN client, like &lt;a href=&#34;https://metacpan.org/pod/App::CPAN&#34;&gt;cpan&lt;/a&gt; or &lt;a href=&#34;https://metacpan.org/pod/App::cpanminus&#34;&gt;cpanm&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cpanm Data::Password::zxcvbn
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;how-to-use-it&#34;&gt;How to use it&lt;/h3&gt;

&lt;p&gt;Data::Password::zxcvbn is easy to use. It exports a function called &lt;code&gt;password_strength&lt;/code&gt; which accepts a password string parameter. It then returns a hashref containing useful &lt;a href=&#34;https://metacpan.org/pod/Data::Password::zxcvbn#Return-value&#34;&gt;information&lt;/a&gt; about the strength of the password.&lt;/p&gt;

&lt;p&gt;For example, this quick script accepts a password argument, and prints how strong it&amp;rsquo;s estimated to be:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#!/usr/bin/env perl&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Data::Password::zxcvbn &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;password_strength&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $est_strength &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; password_strength(shift @ARGV);
printf &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Password strength [0-4]: %d, # guesses needed: %d\n&amp;#34;&lt;/span&gt;,
       $est_strength&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{score},
       $est_strength&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{guesses},&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;score&lt;/code&gt; is a value between 0 and 4, indicating the estimated password strength, with 0 being ridiculously easy, and 4 being super strong. The &lt;code&gt;guesses&lt;/code&gt; value is an estimated number of guesses needed to correctly guess the password. Keep in mind that depending on how the password is encrypted, and where it is stored, attackers might be able to make billions of guesses per second. So the &lt;code&gt;guesses&lt;/code&gt; number needs to be really large to be considered secure. Saving the script as &lt;code&gt;password-strength&lt;/code&gt;, I can run it as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./password_strength foobar
Password strength [0-4]: 0, # guesses needed: 915
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oh no! My password &amp;ldquo;foobar&amp;rdquo; was rated 0. I suppose it&amp;rsquo;s not very strong. Let&amp;rsquo;s try another favorite example password of mine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./password_strength itsasecret
Password strength [0-4]: 1, # guesses needed: 29445
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hmm &amp;ldquo;itsasecret&amp;rdquo; was rated a little stronger, but not by much. Let&amp;rsquo;s try a UUID (generated by &lt;a href=&#34;https://metacpan.org/pod/Data::UUID&#34;&gt;Data::UUID&lt;/a&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./password_strength 7E943948-0C75-11E8-A90E-9860F82DAED4
Password strength [0-4]: 4, # guesses needed: -1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ding ding ding, we have a winner. The UUID was given the highest score of 4, and the estimated number of guesses was infinite (-1). I&amp;rsquo;ll never remember it though: I should probably use a password manager.&lt;/p&gt;

&lt;h3 id=&#34;detecting-fragile-passwords&#34;&gt;Detecting fragile passwords&lt;/h3&gt;

&lt;p&gt;Some passwords appear strong, but contain data associated with its user, making them fragile. Like my employer&amp;rsquo;s domain name:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./password_strength ziprecruiter.com
Password strength [0-4]: 4, # guesses needed: 949660000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So &lt;a href=&#34;https://ziprecruiter.com&#34;&gt;ziprecruiter.com&lt;/a&gt; is considered a strong password, but it&amp;rsquo;s not a strong password for &lt;em&gt;me&lt;/em&gt;. How can we detect these instances of fragile passwords?&lt;/p&gt;

&lt;p&gt;Data::Password::zxcvbn&amp;rsquo;s &lt;code&gt;password_strength&lt;/code&gt; function accepts a hashref of options as a second parameter. One option is called &amp;ldquo;user_input&amp;rdquo;, which can be used to supply data known about the user, such as their name, date of birth etc. I&amp;rsquo;ve updated the script to read this from the command line:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#!/usr/bin/env perl&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Data::Password::zxcvbn &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;password_strength&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $est_strength &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; password_strength(shift @ARGV, { user_input &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; { @ARGV }});
printf &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Password strength [0-4]: %d, # guesses needed: %d\n&amp;#34;&lt;/span&gt;,
       $est_strength&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{score},
       $est_strength&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{guesses};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Running the script and including my employer data, you can see the password&amp;rsquo;s strength is now rated much lower:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./password_strength ziprecruiter.com employer ziprecruiter
Password strength [0-4]: 2, # guesses needed: 1010000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you were using Data::Password::zxcvbn in a web application as part of a user registration form (or a password reset feature), you could pass the user&amp;rsquo;s details to &lt;code&gt;password_strength&lt;/code&gt; to catch these instances of fragile passwords. For users with admin privileges, you might require that their zxcvbn password score is the highest (4). This seems more secure than developing your own password validation function to check a password is of a minimum length, with a certain combinations of characters.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;CPAN: &lt;a href=&#34;https://metacpan.org/pod/Data::Password::zxcvbn&#34;&gt;Data::Password::zxcvbn&lt;/a&gt; and Bitbucket &lt;a href=&#34;https://bitbucket.org/broadbean/p5-data-password-zxcvbn/&#34;&gt;repo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Original Dropbox blog &lt;a href=&#34;https://blogs.dropbox.com/tech/2012/04/zxcvbn-realistic-password-strength-estimation/&#34;&gt;post&lt;/a&gt; discussing zxcvbn&lt;/li&gt;
&lt;li&gt;The Usenix Symposium zxcvbn talk &lt;a href=&#34;https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/wheeler&#34;&gt;page&lt;/a&gt; with video and paper&lt;/li&gt;
&lt;li&gt;The zxcvbn &lt;a href=&#34;https://github.com/dropbox/zxcvbn&#34;&gt;repo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
Cover image by &lt;a href=&#34;https://www.freepik.com/free-vector/red-lock-with-password_715015.htm&#34;&gt;freepik&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Simple, secure backups with Perl</title>
      <link>http://localhost:1313/article/185/2015/8/27/Simple--secure-backups-with-Perl/</link>
      <pubDate>Thu, 27 Aug 2015 13:09:11 +0000</pubDate>
      
      <guid>http://localhost:1313/article/185/2015/8/27/Simple--secure-backups-with-Perl/</guid>
      <description>

&lt;p&gt;Recently I was searching for a backup solution, and ended up rolling my own. The result is &lt;a href=&#34;https://github.com/dnmfarrell/Stasis&#34;&gt;Stasis&lt;/a&gt; a Perl program that uses &lt;code&gt;tar&lt;/code&gt; and &lt;code&gt;gpg&lt;/code&gt; to compress and encrypt files.&lt;/p&gt;

&lt;h3 id=&#34;how-it-works&#34;&gt;How it works&lt;/h3&gt;

&lt;p&gt;Stasis takes a list of file and directory paths and builds a temporary compressed gzip archive using &lt;code&gt;tar&lt;/code&gt;. It then encrypts the temporary archive with &lt;code&gt;gpg&lt;/code&gt; using &lt;a href=&#34;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&#34;&gt;AES 256-bit&lt;/a&gt;, saving it to a new location and removes the temporary archive. Stasis supports backups using a passphrase or a GPG key.&lt;/p&gt;

&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s say I wanted to backup all files in my main home directories. I&amp;rsquo;d create a text file called &lt;code&gt;files_to_backup.txt&lt;/code&gt;, that contains:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/home/dfarrell/Documents
/home/dfarrell/Downloads
/home/dfarrell/Music
/home/dfarrell/Pictures
/home/dfarrell/Videos
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I can save all of these directories and files to Dropbox:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ stasis --destination ~/Dropbox --files files_to_backup.txt --passphrase mysecretkey
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or more tersely:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ stasis -de ~/Dropbox -f files_to_backup.txt --passphrase mysecretkey
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Use passfile instead of passphrase:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ stasis -de ~/Dropbox -f files_to_backup.txt --passfile /path/to/passfile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Use the &amp;ldquo;referrer&amp;rdquo; argument to provide a GPG key instead of a passphrase:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ stasis -de ~/Dropbox -f files_to_backup.txt -r keyname@example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ignore the files matching patterns in &lt;code&gt;.stasisignore&lt;/code&gt;. This is useful if I wanted to ignore certain types of files, like OSX &lt;code&gt;.DS_Store&lt;/code&gt; index files or more broadly, all hidden files: &lt;code&gt;.*&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ stasis -de ~/Dropbox -f files_to_backup.txt -r keyname@example.com -i .stasisignore
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;limiting-the-number-of-backups&#34;&gt;Limiting the number of backups&lt;/h3&gt;

&lt;p&gt;Stasis accepts the &lt;code&gt;--limit&lt;/code&gt; option to only retain the most recent x backups:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ stasis -de ~/Dropbox -f files_to_backup.txt -r mygpgkey@email.com --limit 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It works really nicely with the &lt;code&gt;--days&lt;/code&gt; option, which tells stasis to only create a new archive if one deosn&amp;rsquo;t already exist within x days. So to keep a months&amp;rsquo; worth of weekly archives, I can do this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ stasis -de ~/Dropbox -f files_to_backup.txt -r mygpgkey@email.com --limit 4 --days 7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now stasis will only retain the last 4 archives, and only create one new archive a week. My personal laptop isn&amp;rsquo;t always on, so I have a cron job that checks for this every 30 minutes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*/30 * * * * stasis -de ~/Dropbox -f files_to_backup.txt -r mygpgkey@email.com -l 4 -da 7
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;restoring-a-backup&#34;&gt;Restoring a backup&lt;/h3&gt;

&lt;p&gt;First decrypt the the backup with &lt;code&gt;gpg&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gpg -d /path/to/backup.tar.gz.gpg &amp;gt; /path/to/output.tar.gz
gpg: AES256 encrypted data
gpg: encrypted with 1 passphrase
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GPG will ask for the passphrase or GPG key passphrase to unlock the data. You can then inspect the decrypted archive&amp;rsquo;s files with &lt;code&gt;tar&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tar --list -f /path/to/output.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tar -zvtf /path/to/output.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To unzip the archive:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tar -zvxf /path/to/output.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;disadvantages-of-stasis&#34;&gt;Disadvantages of Stasis&lt;/h3&gt;

&lt;p&gt;Stasis suits my needs but it has several drawbacks which mean it might not be ideal for you. For one thing, it creates a standalone, encrypted archive every time it runs instead of incremental backups. Although this is simple, it also wastes space, so consider the implications if you intend to keep many backup copies. Because Stasis creates a temporary copy of the data it archives, it also requires enough disk space to create two compressed archives of the data.&lt;/p&gt;

&lt;p&gt;As Stasis creates a new archive every time, it can be a resource intensive process to backup. On my ultrabook, it takes Stasis about 20 seconds to create a new 400MB new archive. If you are intending to archive large amounts of data, you may need another solution.&lt;/p&gt;

&lt;p&gt;Archive names are fixed and should not be changed. Stasis creates encrypted archives with the ISO 8601 datetime in the filename like:&lt;code&gt;stasis-0000-00-00T00:00:00.tar.gz.gpg&lt;/code&gt;. To detect previous backup files, Stasis looks for files matching this pattern in the backup directory. This comes into play of you use the &lt;code&gt;--limit&lt;/code&gt; option.&lt;/p&gt;

&lt;h3 id=&#34;stasis-cheatsheet&#34;&gt;Stasis cheatsheet&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;stasis [options]

Options:

  --destination -de destination directory to save the encrypted archive to
  --days        -da only create an archive if one doesn&#39;t exist within this many days (optional)
  --files       -f  filepath to a text file of filepaths to backup
  --ignore      -i  filepath to a text file of glob patterns to ignore (optional)
  --limit       -l  limit number of stasis backups to keep in destination directory (optional)
  --passphrase      passphrase to use
  --passfile        filepath to a textfile containing the password to use
  --referrer    -r  name of the gpg key to use (instead of a passphrase or passfile)
  --temp        -t  temp directory path, uses /tmp by default
  --verbose     -v  verbose, print progress statements (optional)
  --help        -h  print this documentation (optional)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Updated&lt;/strong&gt;:&lt;em&gt;Added new section covering &amp;ndash;days options, removed scripting section 2016-04-02&lt;/em&gt;
&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

