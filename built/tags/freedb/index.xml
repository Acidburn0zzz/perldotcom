<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Freedb on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/freedb/</link>
    <description>Recent content in Freedb on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 03 Oct 2003 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/freedb/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Identifying Audio Files with MusicBrainz</title>
      <link>http://localhost:1313/pub/2003/10/03/musicbrainz.html/</link>
      <pubDate>Fri, 03 Oct 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/10/03/musicbrainz.html/</guid>
      <description>

&lt;p&gt;It&amp;rsquo;s quite possible to end up with digital music files that don&amp;rsquo;t have good information about what they are. Files that don&amp;rsquo;t have ID3 information can rely on paths for album information, for example, and that is lost easily. M3U files describing track order can be deleted or ignored by naive archiving.&lt;/p&gt;

&lt;p&gt;Wouldn&amp;rsquo;t it be nice if, once you had a music file, you could use Perl to take what information you did have about a track, send it to the Internet, and get back the data you were missing? Well, you can.&lt;/p&gt;

&lt;h3 id=&#34;span-id-a-step-through-history-a-step-through-history-span&#34;&gt;&lt;span id=&#34;a_step_through_history&#34;&gt;A Step Through History&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In the beginning (well, more or less), music was on CDs. People started listening to CDs on computers shortly after that, and they found that it would be nice to know the track&amp;rsquo;s name, not just the number. Applications were developed that could store the CD metadata locally. Still, it was tedious to type in all those CD lists, so people shared the metadata in a single index file on the Internet.&lt;/p&gt;

&lt;p&gt;As with most other single-file data stores in Internet history, soon it became sensible to turn this into a proper database. And so the CDDB was born. Clients could upload a description of the disc (the Table of Contents, which described how long each track is) and either download the information for that CD, or contribute it if it wasn&amp;rsquo;t in the database.&lt;/p&gt;

&lt;p&gt;During 1999 and 2000, however, the CDDB (after its acquisition by Gracenote) moved from an open position (with GPLed downloads of its data files) to a proprietary one. During this time it stopped access to clients speaking the first version of the CDDB protocol, and instead moved to licensing &amp;ndash; at some cost &amp;ndash; CDDB2 clients, and stopped offering downloads of its data.&lt;/p&gt;

&lt;p&gt;However, a few projects started up, taking advantage of the data that had been freely available until this point. One of these was FreeDB, which quickly established an open replacement for the CDDB. The other is MusicBrainz, which is much more interesting.&lt;/p&gt;

&lt;h3 id=&#34;span-id-freedb-freedb-span&#34;&gt;&lt;span id=&#34;freedb&#34;&gt;FreeDB&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;FreeDB replicates the structure of the old CDDB very faithfully. This means that a number of Perl modules for handling CDDB data are applicable to the FreeDB as well.&lt;/p&gt;

&lt;p&gt;However, despite the large number of FreeDB modules on CPAN, it&amp;rsquo;s not really well suited to the task of finding or correcting digital music file metadata. FreeDB grew out of CDDB, which was designed around the task of identifying entire CDs, not merely single tracks, and that is still reflected in the way most of the modules work; they require you to either have or fake the CD&amp;rsquo;s table of contents to get results.&lt;/p&gt;

&lt;p&gt;FreeDB also has a search form on its web site, and there&amp;rsquo;s a Perl module &amp;ndash; &lt;code&gt;Webservice::FreeDB&lt;/code&gt; &amp;ndash; that you can use to find out information on a per-track basis. However, wherever possible a web service is probably preferable to using a screen scraper, and thankfully such a service is available.&lt;/p&gt;

&lt;h3 id=&#34;span-id-musicbrainz-musicbrainz-span&#34;&gt;&lt;span id=&#34;musicbrainz&#34;&gt;MusicBrainz&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;MusicBrainz has similar origins to FreeDB in the post-Gracenote era. Unlike FreeDB, MB was much more ambitious; as the description says, `&amp;ldquo;MusicBrainz is a community music metadatabase that attempts to create a comprehensive music information site.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;In addition to taking the FreeDB data and making it available (in fact, the FreeDB changes appear to be regularly merged into MusicBrainz), MB takes care to make sure that their data is moderated regularly. FreeDB&amp;rsquo;s discid-based system didn&amp;rsquo;t always make sure that different versions CDs were recognized as duplicates, for example, whereas the MB volunteers attempt to consolidate such data. They also offer fairly powerful searches of the data from a web-based front end.&lt;/p&gt;

&lt;p&gt;More importantly for our purposes, MusicBrainz has a web services API. Rather than using SOAP, it&amp;rsquo;s a REST-based service based on RDF.&lt;/p&gt;

&lt;p&gt;You can see an example of this by downloading the data at a URL like &lt;a href=&#34;http://mm.musicbrainz.org/mm-2.1/album/1073abfc-768e-455b-9937-9b41b923c746/4&#34;&gt;http://mm.musicbrainz.org/mm-2.1/album/1073abfc-768e-455b-9937-9b41b923c746/4&lt;/a&gt;. This returns RDF for the Underworld album &lt;em&gt;Beaucoup Fish&lt;/em&gt;. The long hex string is the album&amp;rsquo;s unique identifier within MusicBrainz, and the number at the end (4) tells MusicBrainz how deeply to go when building the RDF graph. This level of depth means that as well as merely getting a track listing as references to other RDF documents (like &lt;a href=&#34;http://musicbrainz.org/track/55ef9194-bb58-4397-a8a2-e0d41d2e1435&#34;&gt;http://musicbrainz.org/track/55ef9194-bb58-4397-a8a2-e0d41d2e1435&lt;/a&gt;), you get the name of the track inlined in the document.&lt;/p&gt;

&lt;h4 id=&#34;span-id-using-musicbrainz-client-using-musicbrainz-client-span&#34;&gt;&lt;span id=&#34;using_musicbrainz::client&#34;&gt;Using MusicBrainz::Client&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;However, requesting that URL directly requires you know the MusicBrainz ID for that album, track, or artist, and that you can parse RDF. Unsurprisingly, there&amp;rsquo;s code out there that can do both from a given piece of information.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;the MusicBrainz::Client manpage&lt;/code&gt; is a Perl interface to the C client library for MB, and is available as part of the &lt;a href=&#34;http://musicbrainz.org/products/client/download.html&#34;&gt;Client SDK download&lt;/a&gt;, as well as on CPAN.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a small example of using one of the more useful queries provided, the snappily-entitled &lt;code&gt;MBQ_FileInfoLookup&lt;/code&gt;. This takes up to 10 parameters, as documented in the &lt;a href=&#34;http://musicbrainz.org/docs/mb_client/queries_h.html#a84&#34;&gt;Query reference&lt;/a&gt;. However, you can provide as many or as few items as you wish, and in this example, merely two pieces of information are provided: an artist, and a track name.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #!/usr/bin/perl -w
  use strict;

  use MusicBrainz::Client;
  use MusicBrainz::Queries qw(:all);

  my $mb = MusicBrainz::Client-&amp;gt;new();
  my $query = [ &#39;&#39;, &#39;Underworld&#39;, &#39;&#39;, &#39;Air Towel&#39; ];
  my $result;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we&amp;rsquo;ve set up the script, and initialized a client object, let&amp;rsquo;s actually talk to the server.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  if (!$mb-&amp;gt;query_with_args( MBQ_FileInfoLookup, $query )) {
    die &amp;quot;Query failed &amp;quot;.$mb-&amp;gt;get_query_error();
  }

  if (!$mb-&amp;gt;select1(MBS_SelectLookupResult, 1)) {
    die &amp;quot;No lookup result&amp;quot;;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This sends off a query to the MusicBrainz server, and does two checks to see if it&amp;rsquo;s worth continuing. If there&amp;rsquo;s no return value from query_with_args, the script dies with the error returned. If there&amp;rsquo;s not at least one result in the returned data, it also dies.&lt;/p&gt;

&lt;p&gt;The exact arguments that &lt;code&gt;MBQ_FileInfoLookUp&lt;/code&gt; take are documented in the query reference above. Notably, the first argument is the TRM ID. This is a generated, unique identifier for the file, based on a number of weighted checks, including wavelet analysis. Generally I&amp;rsquo;ve found it&amp;rsquo;s still possible to get good results without including it, though.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my $type = $mb-&amp;gt;get_result_data(MBE_LookupGetType);
  my $frag = $mb-&amp;gt;get_fragment_from_url($type);

  if ($frag eq &#39;AlbumTrackResult&#39;) {
    $result = handle_album_track_list($mb);
  }
  else {
    die &amp;quot;Not an AlbumTrackResult; instead of type &#39;$frag&#39;&amp;quot;;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;MBQ_FileInfoLookup&lt;/code&gt; can return different types of result. This code uses two more functions from MusicBrainz to find out the type of the result (the LookupGetType function) and then to parse out from the URL what type of result that is. We&amp;rsquo;re only interested in AlbumTrackResult type, so we die if that&amp;rsquo;s not what&amp;rsquo;s found. If it is of that type, it&amp;rsquo;s handled by a subroutine, which we&amp;rsquo;ll look at now.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  sub handle_album_track_list {
    my $mb = shift;
    my $result;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, we get the MusicBrainz client object and pre-declare our result variable.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for (my $i = 1;; $i++) {
      $mb-&amp;gt;select(MBS_Rewind);

      if (!$mb-&amp;gt;select1(MBS_SelectLookupResult, $i)) {
        last;
      }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MusicBrainz results sets are a lot like database rows. You loop over them, and pull out the data you want.&lt;/p&gt;

&lt;p&gt;However, the interface to the results is somewhat C-like. As you can see, we loop over the results one by one, stopping only when there isn&amp;rsquo;t a result in the set.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      my $relevance = $mb-&amp;gt;get_result_int(MBE_LookupGetRelevance);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, once there is a result, we can pull out information from it, like the relevance of that data.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      # get track info
      $mb-&amp;gt;select(MBS_SelectLookupResultTrack);
      my $track   = $mb-&amp;gt;get_result_data(MBE_TrackGetTrackName);
      my $length  = $mb-&amp;gt;get_result_data(MBE_TrackGetTrackDuration);     
      my $artist  = $mb-&amp;gt;get_result_data(MBE_TrackGetArtistName);
      $mb-&amp;gt;select(MBS_Back);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To get the information about the track, you select the track portion of that result, then issue get_result_data calls for each of the pieces of information you want (such as the artist name, track name and so on).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      # get album info
      $mb-&amp;gt;select(MBS_SelectLookupResultAlbum);
      my $album   = $mb-&amp;gt;get_result_data(MBE_AlbumGetAlbumName);
      my $trackct = $mb-&amp;gt;get_result_int(MBE_AlbumGetNumTracks);
      $mb-&amp;gt;select(MBS_Back);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Similarly, you select the album data, and then select the information about the album you want to return.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      $result-&amp;gt;[$i-1] = { relevance =&amp;gt; $relevance,
                          track     =&amp;gt; $track,
                          album     =&amp;gt; $album,
                          artist    =&amp;gt; $artist,
                          total     =&amp;gt; $trackct,
                          time      =&amp;gt; $length,
                        };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is stored in a hash reference, itself stored in the list of results. (Note we move from MusicBrainz offset of 1 to the Perl offset of 0 here.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    }
    return $result;
  }

  use Data::Dumper;
  print Dumper($result);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally the result is returned and (crudely) inspected. Of course, you could instead take the result with the highest relevance and tag a file here, or offer the choice via some user interface of which result is more likely to be appropriate.&lt;/p&gt;

&lt;h4 id=&#34;span-id-using-audiofile-identify-musicbrainz-using-audiofile-identify-musicbrainz-span&#34;&gt;&lt;span id=&#34;using_audiofile::identify::musicbrainz&#34;&gt;Using AudioFile::Identify::MusicBrainz&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;As you can see, returning the data from MusicBrainz::Client is a fairly verbose procedure. In addition, it&amp;rsquo;s not a pure Perl implementation, so installing the module isn&amp;rsquo;t as easy as it could be, and in some places it&amp;rsquo;s not possible at all.&lt;/p&gt;

&lt;p&gt;Given that the REST interface is open, Tom Insam and I decided to play with getting the RDF results and parsing them, putting together Perl modules along the way to help. The result is &lt;code&gt;the AudioFile::Identify::MusicBrainz manpage&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #!/usr/bin/perl -w
  use strict;

  use AudioFile::Identify::MusicBrainz::Query;
  my $query = { artist =&amp;gt; &#39;Underworld&#39;, 
                track  =&amp;gt; &#39;Air Towel&#39;,
              };
  my $result;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, this is simple setup stuff. You&amp;rsquo;ll note that instead of a list, AIM takes a hash reference with named fields, which is hopefully a little easier to use.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my $aim = AudioFile::Identify::MusicBrainz::Query-&amp;gt;new()
            or die &amp;quot;Can&#39;t make query&amp;quot;;

  $aim-&amp;gt;FileInfoLookup($query);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This block of code instantiates the AIM object and sends off the query.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  for my $record (@{ $aim-&amp;gt;results }) {
    push @{ $result }, {  relevance =&amp;gt; $record-&amp;gt;relevance,
                          track     =&amp;gt; $record-&amp;gt;track-&amp;gt;title,
                          album     =&amp;gt; $record-&amp;gt;album-&amp;gt;title,
                          artist    =&amp;gt; $record-&amp;gt;track-&amp;gt;artist-&amp;gt;title,
                          tracknum  =&amp;gt; $record-&amp;gt;track-&amp;gt;trackNum,
                          total     =&amp;gt; scalar @{$record-&amp;gt;album-&amp;gt;tracks},
                          time      =&amp;gt; $record-&amp;gt;track-&amp;gt;duration,
                       };
  };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This manipulates the results from AIM such that they match the result list that we created from MusicBrainz::Client. Each of them is a method on the returned object. Some, such as the artist name, are objects referenced from other objects.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use Data::Dumper;
  print Dumper($result);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, we crudely inspect the output, which is identical but for the addition of the track number.&lt;/p&gt;

&lt;h3 id=&#34;span-id-inside-audofile-identify-musicbrainz-inside-audofile-identify-musicbrainz-span&#34;&gt;&lt;span id=&#34;inside_audofile::identify::musicbrainz&#34;&gt;Inside AudoFile::Identify::MusicBrainz&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;As you&amp;rsquo;d expect, Perl (and its retinue of modules) made writing this module fairly straightforward. Firstly, LWP makes requesting data from the MusicBrainz server pretty easy. (This code is in &lt;code&gt;the AudioFile::Identify::MusicBrainz::Query manpage, for the curious.)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use LWP;
  use LWP::UserAgent;

  # ...

  my $ua = LWP::UserAgent-&amp;gt;new();

  my $req = HTTP::Request-&amp;gt;new(POST =&amp;gt; $self-&amp;gt;url,);
  $req-&amp;gt;content($rdf);

  my $res = $ua-&amp;gt;request($req);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This sets up an LWP user agent, and sends the RDF query (more on that later) to a URL (returned by another method in the module). That&amp;rsquo;s all you need to get the returned result into the string $res. (The real module has a custom UserAgent string that I&amp;rsquo;ve omitted to save space.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  # Check the outcome of the response
  if ($res-&amp;gt;is_success) {
    $self-&amp;gt;response($res-&amp;gt;content);
    return $self-&amp;gt;parse();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As long as there&amp;rsquo;s a result, it gets stored and then parsed. (Don&amp;rsquo;t worry; the real module also handles errors.) So, what does the parser do?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my $parser = new XML::DOM::Parser;
  my $doc = $parser-&amp;gt;parse($self-&amp;gt;response);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MusicBrainz returns results in RDF, but that RDF is itself encapsulated in XML. Although it&amp;rsquo;s not ideal to use XML tools on RDF, it works well enough in this case.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my $result_nodes = $doc-&amp;gt;getElementsByTagName(&#39;mq:AlbumTrackResult&#39;);

  $n = $result_nodes-&amp;gt;getLength;
  for (my $i = 0; $i &amp;lt; $n; $i++) {
    my $node = $result_nodes-&amp;gt;item($i);
    my $result =
      AudioFile::Identify::MusicBrainz::Result-&amp;gt;new()
                                              -&amp;gt;store($self-&amp;gt;store)
                                              -&amp;gt;type(&#39;Track&#39;)
                                              -&amp;gt;parse($node);
    push @$results, $result;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This block of code is a good example of how the XML is parsed. Firstly, all elements with the name mq:AlbumTrackResult are found. These are progressively looped over, and stored in a new Result object (of type Track), and parsed. So, what happens within the parser?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my $child = $node-&amp;gt;getFirstChild();
  while($child) {
    if ($child-&amp;gt;getNodeType == 1) {
      my $tag = $child-&amp;gt;getTagName;
      $tag =~ s/.*://;
      if ($self-&amp;gt;can($tag)) {
        $self-&amp;gt;$tag($child);
      }
    }
    $child = $child-&amp;gt;getNextSibling();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The node (as passed in above) is examined, and the first child node is examined. While we have a child node to examine, the program checks that it&amp;rsquo;s an element (of node type 1), gets the tag name and removes the namespace, then calls the appropriate get/set method with the appropriate XML node, before moving on to the next child. (This is a somewhat simplified version, with the error checking removed.)&lt;/p&gt;

&lt;p&gt;What happens in an example get/set method? Here&amp;rsquo;s part of the title method from the Track package.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  if (defined($set)) {
    if ($set-&amp;gt;isa(&#39;XML::DOM::Element&#39;) and $set-&amp;gt;getFirstChild) {
      $self-&amp;gt;{title} = $set-&amp;gt;getFirstChild-&amp;gt;toString;
    } else {
      $self-&amp;gt;{title} = $set;
    }
    return $self;
  } else {
    return $self-&amp;gt;{title};
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the method is called with some data, the program makes sure it&amp;rsquo;s an XML::DOM element, then parses it and stores the string within that element, or stores the data that was passed in. Otherwise, it returns the data that was previously stored.&lt;/p&gt;

&lt;p&gt;One point to note is that MusicBrainz doesn&amp;rsquo;t return all the track information you might need in the initial FileInfoLookup query. Therefore the Result package uses another method, called getData in the Track package, to download the RDF for the track from MusicBrainz. This is then parsed and stored in the same way as the RDF above.&lt;/p&gt;

&lt;h3 id=&#34;span-id-conclusion-conclusion-span&#34;&gt;&lt;span id=&#34;conclusion&#34;&gt;Conclusion&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In this article I&amp;rsquo;ve shown you how to connect to MusicBrainz and retrieve information from their web services API with both the MusicBrainz::Client and AudioFile::Identify::MusicBrainz modules, and a little of the internal workings of the latter. This should allow you to find out all those niggling missing pieces of information about the tracks at the bottom of your music collection.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

