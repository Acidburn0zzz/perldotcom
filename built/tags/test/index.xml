<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Test on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/test/</link>
    <description>Recent content in Test on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 09 Jun 2015 12:59:02 +0000</lastBuildDate>
    <atom:link href="/tags/test/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Get to grips with Prove, Perl&#39;s test workhorse</title>
      <link>http://localhost:1313/article/177/2015/6/9/Get-to-grips-with-Prove--Perl-s-test-workhorse/</link>
      <pubDate>Tue, 09 Jun 2015 12:59:02 +0000</pubDate>
      
      <guid>http://localhost:1313/article/177/2015/6/9/Get-to-grips-with-Prove--Perl-s-test-workhorse/</guid>
      <description>

&lt;p&gt;Prove is a test running tool that ships with Perl. It has a ton of options, which can make it confusing for a beginner to use. If you have never used prove, or are not confident using it, do not despair! This article will get you up to speed with prove and it&amp;rsquo;s most common options.&lt;/p&gt;

&lt;h3 id=&#34;basics&#34;&gt;Basics&lt;/h3&gt;

&lt;p&gt;If you have Perl installed, you should already have Prove installed as well. To demo the features of Prove, I&amp;rsquo;m going to clone the Mojolicious repo using Git. I like demoing Prove with Mojolicious as it has a large test suite. At the command line:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ git clone https:&lt;span style=&#34;color:#e6db74&#34;&gt;//gi&lt;/span&gt;thub&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;com&lt;span style=&#34;color:#e6db74&#34;&gt;/kraih/mo&lt;/span&gt;jo
$ cd mojo&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So I&amp;rsquo;ve cloned the Mojolicious repo and changed into the project directory. Now I&amp;rsquo;m ready to run some tests with Prove!&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ prove &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;l t&lt;span style=&#34;color:#e6db74&#34;&gt;/mojo/&lt;/span&gt;asset&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;t&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I executed Prove using the &lt;code&gt;prove&lt;/code&gt; command. I included the &lt;code&gt;-l&lt;/code&gt; option so that Prove would load the Mojolicious code beneath the &lt;code&gt;lib&lt;/code&gt; directory. If I didn&amp;rsquo;t do this, Perl would not find the Mojolicious code referenced in &lt;code&gt;t/mojo/asset.t&lt;/code&gt; and raise an error, or perhaps worse, it might run the tests against an older version of Mojolicious I already had installed on my system.&lt;/p&gt;

&lt;p&gt;Sometimes the code to include is not directly in the &lt;code&gt;lib&lt;/code&gt; directory. For these cases Prove has the &lt;code&gt;-I&lt;/code&gt; option for &amp;ldquo;include&amp;rdquo;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;prove &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;I&lt;span style=&#34;color:#e6db74&#34;&gt;/path/&lt;/span&gt;to&lt;span style=&#34;color:#e6db74&#34;&gt;/lib /&lt;/span&gt;path&lt;span style=&#34;color:#e6db74&#34;&gt;/to/&lt;/span&gt;test_file&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Prove can run a single test file, or if given a directory containing multiple test files, with will execute them all:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ prove &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;l t&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;mojo&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This runs all the test files in &lt;code&gt;t/mojo&lt;/code&gt; directory.&lt;/p&gt;

&lt;h3 id=&#34;recursively-execute-test-files-with-r&#34;&gt;Recursively execute test files with &amp;ldquo;r&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;The Mojolicious project has test files in several different directories beneath the &lt;code&gt;t&lt;/code&gt; directory. It would be tiresome to locate all of these directory paths and give them to Prove. Instead, Prove provides the &lt;code&gt;-r&lt;/code&gt; option to recursively search for test files.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ prove &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;lr&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This option executed every test file under the &lt;code&gt;t&lt;/code&gt; directory, about 10,000 tests across 85 different files. Pretty convenient huh? Note that I didn&amp;rsquo;t provide the &lt;code&gt;t&lt;/code&gt; directory as an argument, because Prove searches the &lt;code&gt;t&lt;/code&gt; directory by default. Now that&amp;rsquo;s convenience!&lt;/p&gt;

&lt;h3 id=&#34;run-tests-in-parallel-using-j&#34;&gt;Run tests in parallel using &amp;ldquo;j&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;The ability to run lots of test files is useful, but it can take a long time to run all of the tests. On my machine, executing the Mojolicious test suite takes 32 seconds. To speed things up, Prove can run test files in parallel, to share the work across multiple processes. To do this I just add the &lt;code&gt;-j&lt;/code&gt; option plus the number of processes I want to use. I have a quad core machine, so I&amp;rsquo;m going to use 4 different processes:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ prove &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;lr &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;j &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This time, prove executed all the tests in 12 seconds. That&amp;rsquo;s a 266% speed-up, not bad!&lt;/p&gt;

&lt;h3 id=&#34;get-more-detail-with-v-for-verbose&#34;&gt;Get more detail with &amp;ldquo;v&amp;rdquo; for verbose&lt;/h3&gt;

&lt;p&gt;To minimize line noise, by default Prove provides summary-level statistics and low-level detail for test failures. Sometimes it&amp;rsquo;s useful to see the output for each test. I can see this detail by adding the &lt;code&gt;-v&lt;/code&gt; option for &amp;ldquo;verbose&amp;rdquo;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ prove &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;lrv&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;running-perl-6-tests&#34;&gt;Running Perl 6 tests&lt;/h3&gt;

&lt;p&gt;Prove can run tests for other languages, as long as the tests follow the Test Anything Protocol. Perl 6 unit tests follow TAP, so we can use Prove to run Perl 6 tests too! I can demo this on my Perl 6 module, &lt;a href=&#34;https://github.com/dnmfarrell/URI-Encode&#34;&gt;URI::Encode&lt;/a&gt;. To follow along, just clone the repo with Git:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ git clone https:&lt;span style=&#34;color:#e6db74&#34;&gt;//gi&lt;/span&gt;thub&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;com&lt;span style=&#34;color:#e6db74&#34;&gt;/dnmfarrell/&lt;/span&gt;URI&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;Encode
$ cd URI&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;Encode&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To run non Perl tests with Prove, we need to pass the &lt;code&gt;--exec&lt;/code&gt; option, with a program name. That tells Prove which program to execute the tests with. Like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ prove &lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;exec perl6&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that I didn&amp;rsquo;t have to pass the filepath of which tests to run. It&amp;rsquo;s just lucky that by convention Perl6 modules have their tests in the &lt;code&gt;t&lt;/code&gt; directory, usually with a &lt;code&gt;.t&lt;/code&gt; extension. For other languages, you&amp;rsquo;ll need to specify the test filepath:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ prove &lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;exec some_program &lt;span style=&#34;color:#e6db74&#34;&gt;/path/&lt;/span&gt;to&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;testfile&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;documentation&#34;&gt;Documentation&lt;/h3&gt;

&lt;p&gt;You can get a summary of the options Prove accepts by using the &lt;code&gt;-h&lt;/code&gt; option for help:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ prove &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;h&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For more detailed documentation, use &lt;code&gt;perldoc&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ perldoc prove&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Perldoc is another useful Perl tool, if you&amp;rsquo;d like to know more about it, have a look at our introductory &lt;a href=&#34;http://perltricks.com/article/155/2015/2/26/Hello-perldoc--productivity-booster&#34;&gt;article&lt;/a&gt;. Prove also has a man page entry (if you&amp;rsquo;re on Unix/BSD based systems).&lt;/p&gt;

&lt;h3 id=&#34;prove-cheat-sheet&#34;&gt;Prove Cheat sheet&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;prove [options] [filepath]

Options
-------
l       Include the &amp;quot;lib&amp;quot; dir
I       Include a dir: -I/path/to/lib
r       Recursively search and run test files
j       Parallel, specify # procs: -j 4
v       Verbose test output
h       Help, summary of options
exec    Exec tests in another program: --exec perl6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to test for exceptions in Perl</title>
      <link>http://localhost:1313/article/157/2015/3/5/How-to-test-for-exceptions-in-Perl/</link>
      <pubDate>Thu, 05 Mar 2015 13:27:17 +0000</pubDate>
      
      <guid>http://localhost:1313/article/157/2015/3/5/How-to-test-for-exceptions-in-Perl/</guid>
      <description>

&lt;p&gt;Most Perl programmers are familiar with &lt;a href=&#34;https://metacpan.org/pod/Test::More&#34;&gt;Test::More&lt;/a&gt;; it&amp;rsquo;s the go-to library for writing unit tests in Perl. But Test::More doesn&amp;rsquo;t provide functions for testing exceptions. For that you&amp;rsquo;ll need &lt;a href=&#34;https://metacpan.org/pod/Test::Exception&#34;&gt;Test::Exception&lt;/a&gt;. And good code throws exceptions - Paul Fenwick &lt;a href=&#34;http://perltraining.com.au/tips/2008-08-20.html&#34;&gt;once&lt;/a&gt; summed this approach nicely:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bIlujDI&#39; yIchegh()Qo&#39;; yIHegh()!

It is better to die() than to return() in failure.

    -- Klingon programming proverb.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The simplest way to throw an exception is with Perl&amp;rsquo;s built-in &lt;code&gt;die&lt;/code&gt; function. Just like Test::More makes it easy to test that subroutines return the right values, Test::Exception makes it easy to check the code is &lt;em&gt;dying&lt;/em&gt; in the right way (and &lt;a href=&#34;https://metacpan.org/pod/Test::Fatal&#34;&gt;Test::Fatal&lt;/a&gt; is a good alternative).&lt;/p&gt;

&lt;h3 id=&#34;did-my-code-die-ok&#34;&gt;Did my code die ok?&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s say we&amp;rsquo;re writing unit tests for the following package which exports the &lt;code&gt;double_integer&lt;/code&gt; subroutine:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;package&lt;/span&gt; Double;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Exporter;
@ISA &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Exporter&amp;#39;&lt;/span&gt;;
@EXPORT &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;double_integer&lt;/span&gt;
{
  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; ($number) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; @_;
  die &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer() requires a positive integer as an argument&amp;#39;&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;unless&lt;/span&gt; defined $number &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; $number &lt;span style=&#34;color:#f92672&#34;&gt;=~&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;/^\d+$/&lt;/span&gt;;

  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; $number &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
}

&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This code will &lt;code&gt;die&lt;/code&gt; unless the double_integer subroutine is called with a positive integer. I&amp;rsquo;ll save this package as &lt;code&gt;Double.pm&lt;/code&gt;. Let&amp;rsquo;s write a test script for this package. Test::Exception exports the &lt;code&gt;dies_ok&lt;/code&gt; function that checks the code dies as expected:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Test::Exception tests &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Double;

dies_ok { double_integer() } &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer() dies with no number&amp;#39;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;dies_ok&lt;/code&gt; is clever, it won&amp;rsquo;t actually let your code die and the program exit, as that would interrupt testing! Instead it catches any thrown exceptions so testing can continue. My program should also die if &lt;code&gt;double_integer&lt;/code&gt; is called with a non-number as an argument. I can add more tests for some common scenarios:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Test::Exception test &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Double;

dies_ok { double_integer() } &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer() dies with no number&amp;#39;&lt;/span&gt;;
dies_ok { double_integer(undef) } &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer() dies with undef&amp;#39;&lt;/span&gt;;
dies_ok { double_integer(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;abc&amp;#39;&lt;/span&gt;) } &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer() dies with text&amp;#39;&lt;/span&gt;;
dies_ok { double_integer(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;1 two&amp;#39;&lt;/span&gt;) } &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer() dies with mixed&amp;#39;&lt;/span&gt;;
dies_ok { double_integer(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;-7&amp;#39;&lt;/span&gt;) } &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer() dies with a negative&amp;#39;&lt;/span&gt;;
dies_ok { double_integer(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2.5&amp;#39;&lt;/span&gt;) } &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer() dies with a decimal&amp;#39;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I can also check the code throws the right exception with &lt;code&gt;throws_ok&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Test::Exception tests &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Double;

throws_ok { double_integer() } &lt;span style=&#34;color:#e6db74&#34;&gt;qr/requires a positive integer/&lt;/span&gt;, 
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer() requires a positive integer&amp;#39;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;throws_ok&lt;/code&gt; function checks that the code throws an exception, but also that the exception message matches a regex. This is useful if you have several different conditions that may throw different types of exceptions: imagine with a web application, you&amp;rsquo;d want to throw a different exception code if the user requested a page they didn&amp;rsquo;t have permission to access (403) versus requesting a non-existent page (404).&lt;/p&gt;

&lt;p&gt;Test::Exception is fully compatible with Test::More so you can combine functions from both libraries in the same file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Test::More;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Test::Exception;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Double;

&lt;span style=&#34;color:#75715e&#34;&gt;# test arg validation works&lt;/span&gt;
dies_ok { double_integer() } &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer() dies with no number&amp;#39;&lt;/span&gt;;
dies_ok { double_integer(undef) } &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer() dies with undef&amp;#39;&lt;/span&gt;;
dies_ok { double_integer(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;abc&amp;#39;&lt;/span&gt;) } &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer() dies with text&amp;#39;&lt;/span&gt;;
dies_ok { double_integer(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;1 two&amp;#39;&lt;/span&gt;) } &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer() dies with mixed&amp;#39;&lt;/span&gt;;
dies_ok { double_integer(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;-7&amp;#39;&lt;/span&gt;) } &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer() dies with a negative&amp;#39;&lt;/span&gt;;
dies_ok { double_integer(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2.5&amp;#39;&lt;/span&gt;) } &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer() dies with a decimal&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#75715e&#34;&gt;# test exception message&lt;/span&gt;
throws_ok { double_integer() } &lt;span style=&#34;color:#e6db74&#34;&gt;qr/requires a positive integer/&lt;/span&gt;, 
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer() requires a positive integer&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#75715e&#34;&gt;# test double_integer works&lt;/span&gt;
lives_ok { double_integer(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) } &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;calling double() with a number lives&amp;#39;&lt;/span&gt;;
is double_integer(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;), &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;zero doubled is zero&amp;#39;&lt;/span&gt;;
is double_integer(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;), &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;two doubled is four&amp;#39;&lt;/span&gt;;
is double_integer(&lt;span style=&#34;color:#ae81ff&#34;&gt;999&lt;/span&gt;), &lt;span style=&#34;color:#ae81ff&#34;&gt;1998&lt;/span&gt;, 
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;nine nine nine doubled is one nine nine eight&amp;#39;&lt;/span&gt;;

done_testing();&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now the test script checks both that the function throws the appropriate exception when the argument is wrong, and it returns the argument doubled when the argument is valid. If I save this test file as &lt;code&gt;Double.t&lt;/code&gt; I can run the tests at the terminal:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ perl Double&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;t
ok &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; double_integer() dies with &lt;span style=&#34;color:#66d9ef&#34;&gt;no&lt;/span&gt; number
ok &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; double_integer() dies with undef
ok &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; double_integer() dies with text
ok &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; double_integer() dies with mixed
ok &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; double_integer() dies with a negative
ok &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; double_integer() dies with a decimal
ok &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; double_integer() requires a positive integer
ok &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; calling double() with a number lives
ok &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; zero doubled is zero
ok &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; two doubled is four
ok &lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; nine nine nine doubled is one nine nine eight
&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;All the tests pass. &lt;a href=&#34;https://metacpan.org/pod/Test::Exception&#34;&gt;Test::Exception&lt;/a&gt; has great documentation and is easy to use, so add exception testing to your code today!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Updated:&lt;/strong&gt; &lt;em&gt;Added Test::Fatal reference 2015-03-10&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building Testing Libraries</title>
      <link>http://localhost:1313/pub/2004/05/07/testing.html/</link>
      <pubDate>Fri, 07 May 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/05/07/testing.html/</guid>
      <description>

&lt;p&gt;Testing is an important step in developing any important body of work. In today&amp;rsquo;s pragmatic culture, we&amp;rsquo;re taught to test first, test often, and design with tests. The expectation is that chanting &amp;ldquo;test test test&amp;rdquo; forgives all sins. To a large extent, this is true. Testing helps us produce quality software at all scales.&lt;/p&gt;

&lt;p&gt;The extreme code produced by this extreme lifestyle hides in the test suite itself. Often the ugliest code we write resides in files with a .t extension. Riddled with redundant, ghastly expressions, the test suite is the collateral damage on our road to beautiful production code.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s review some common pitfalls made when testing. Many of these testing procedures may be new to you. Serious headway has been made in recent history with the testing libraries on the CPAN.&lt;/p&gt;

&lt;h3 id=&#34;span-id-a-test-file-is-just-a-program-a-test-file-is-just-a-program-span&#34;&gt;&lt;span id=&#34;A_Test_File_is_Just_a_Program&#34;&gt;A Test File is Just a Program&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Each test file is a program, just as important as any other program you&amp;rsquo;d write that uses software being tested. It must be treated with the same care. If you plan to use &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;warnings&lt;/code&gt; in a program related to the code you&amp;rsquo;re testing, be sure to do the same in your tests.&lt;/p&gt;

&lt;p&gt;Each test file should start with these three lines.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #!/path/to/perl
  use strict;
  use warnings;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you plan to run your software in a taint-checked environment, which is considered a good idea, then supply the &lt;code&gt;-T&lt;/code&gt; command-line option to the &lt;code&gt;#!&lt;/code&gt; line.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #!/path/to/perl -T
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will ensure that you won&amp;rsquo;t make syntactic mistakes in your test files. It will also require your software to work correctly in a restricted environment.&lt;/p&gt;

&lt;h3 id=&#34;span-id-be-compatible-with-test-harness-be-compatible-with-test-harness-span&#34;&gt;&lt;span id=&#34;Be_Compatible_with_Test::Harness&#34;&gt;Be Compatible with &lt;code&gt;Test::Harness&lt;/code&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Test::Harness&lt;/code&gt; is a very useful Perl module for running test suites. If you are building a Perl module yourself, and using &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; or &lt;code&gt;Module::Build&lt;/code&gt; for the build process, you&amp;rsquo;re using &lt;code&gt;Test::Harness&lt;/code&gt;. If you aren&amp;rsquo;t using any of these mechanisms, do try to be compatible with it. This will help other users and developers of your software who are used to dealing with &lt;code&gt;Test::Harness&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Compatibility comes in the form of the test file&amp;rsquo;s output. &lt;code&gt;Test::Harness&lt;/code&gt; will run your program and record its output to &lt;code&gt;STDOUT&lt;/code&gt;. Anything sent to &lt;code&gt;STDERR&lt;/code&gt; is ignored, silently passed on to the user. There are particulars about testing under the harness that should be observed. The basics are simple.&lt;/p&gt;

&lt;p&gt;When a test passes, it outputs a line containing &lt;code&gt;ok $N&lt;/code&gt;, where &lt;code&gt;$N&lt;/code&gt; is the test number. When a test fails, the line contains &lt;code&gt;not ok $N&lt;/code&gt;. Test numbers are optional but recommended. Tests may be named. Anything after the number, &lt;code&gt;$N&lt;/code&gt;, is considered the test name, up to a hash (&lt;code&gt;#&lt;/code&gt;). Anything following the hash is a comment.&lt;/p&gt;

&lt;p&gt;Furthermore, you are encouraged to supply a header. The header tells &lt;code&gt;Test::Harness&lt;/code&gt; how many tests you expect to run and should be the first thing you output. If you&amp;rsquo;re unsure of the number of tests, the header may be the very last thing output. Its format is also simple: &lt;code&gt;1..$M&lt;/code&gt;, where &lt;code&gt;$M&lt;/code&gt; is the total number of tests to run. The header helps the harness figure out how well your tests did.&lt;/p&gt;

&lt;p&gt;Any other output should be commented on lines beginning with a hash (&lt;code&gt;#&lt;/code&gt;). Here is an example of prototypical output understood by &lt;code&gt;Test::Harness&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  1..4
  ok 1 - use Software::Module
  ok 2 - object isa Software::Module
  not ok 3 - $object-&amp;gt;true() should return true
  #     Failed test (test.t)
  #          got: undef
  #     expected: 1
  ok 4 # skip Net::DNS required for this test
  # Looks like you failed 1 tests of 4.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-use-a-testing-module-use-a-testing-module-span&#34;&gt;&lt;span id=&#34;Use_a_Testing_Module&#34;&gt;Use a Testing Module&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;A simple way to achieve &lt;code&gt;Test::Harness&lt;/code&gt; compatibility is to use a testing module from the CPAN. Many test suites over the years have reinvented the &lt;code&gt;ok()&lt;/code&gt; function, for example.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  {
    my $N = 1;
    sub ok($;$) {
        my ($test, $name) = @_;
        print &amp;quot;not &amp;quot; unless $test;
        print &amp;quot;ok $N - $name\n&amp;quot;;
        $N++;
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is no need to do this, however. The standard Perl distribution comes with testing modules. Two great options are &lt;code&gt;Test::Simple&lt;/code&gt; and &lt;code&gt;Test::More&lt;/code&gt;. &lt;code&gt;Test::Simple&lt;/code&gt; is a great way to get your feet wet; it implements only the &lt;code&gt;ok()&lt;/code&gt; function. &lt;code&gt;Test::More&lt;/code&gt; has more features and is recommended when you write your test suites.&lt;/p&gt;

&lt;p&gt;Using &lt;code&gt;Test::More&lt;/code&gt; is very simple; many have written on the subject. This is how you would achieve the output described in the previous section.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #!/usr/bin/perl -T
  use strict;
  use warnings;
  use Test::More tests =&amp;gt; 4;

  use_ok &#39;Software::Module&#39;;
  my $object = Software::Module-&amp;gt;new;
  isa_ok $object, &#39;Software::Module&#39;, &#39;object&#39;;
  cmp_ok $object-&amp;gt;true, 1, &#39;$object-&amp;gt;true() should return true&#39;;

  SKIP: {
      skip 1, &amp;quot;Net::DNS required for this test&amp;quot;
        unless eval &#39;require Net::DNS&#39;;

      ok $object-&amp;gt;network(), &amp;quot;run over network&amp;quot;;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-don-t-iterate-compare-don-t-iterate-compare-span&#34;&gt;&lt;span id=&#34;Don&#39;t_Iterate,_Compare&#34;&gt;Don&amp;rsquo;t Iterate, Compare&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;ve often seen tests that loop over a list and check each item to be sure the list is correct. While this approach makes you feel good, artificially adding to the number of tests you&amp;rsquo;ve written, it can be sloppy and long-winded. Here is an example.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my @fruits = qw[apples oranges grapes];
  my @result = get_fruits();
  foreach my $n ( 0 .. $#fruits ) {
      is $result[$n], $fruits[$n], &amp;quot;$fruits[$n] in slot $n&amp;quot;;
  }
  is scalar(@result), scalar(@fruits), &amp;quot;fruits the same size&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It looks like four tests were written; the reality is that one test was written poorly. &lt;code&gt;Test::More&lt;/code&gt; has several utility functions to get the job done. In this test, &lt;code&gt;@fruits&lt;/code&gt; represents a set of non-repeatable &lt;code&gt;fruits&lt;/code&gt; I expect to get back from &lt;code&gt;get_fruits()&lt;/code&gt;. As such, I can use &lt;code&gt;eq_set()&lt;/code&gt; to test this function in one quick try.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my @fruits = qw[apples oranges grapes];
  my @result = get_fruits();
  ok eq_set(\@result, \@fruits), &amp;quot;got [@fruits]&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That was easy and short. But what happens when you have a deep data structure that you&amp;rsquo;re dying to test? That&amp;rsquo;s where &lt;code&gt;Test::Deep&lt;/code&gt; comes in. Downloadable from the CPAN, this module provides the &lt;code&gt;cmp_deeply()&lt;/code&gt; function. Here is a simple example.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use Test::Deep;
  my $people = [
    {
      name     =&amp;gt; &amp;quot;Casey West&amp;quot;,
      employer =&amp;gt; &amp;quot;pair Networks&amp;quot;,
    },
    {
      name     =&amp;gt; &amp;quot;Larry Wall&amp;quot;,
      employer =&amp;gt; &amp;quot;The Perl Foundation&amp;quot;,
    },
  ];

  my $result = $dude-&amp;gt;contacts-&amp;gt;retrieve_all;

  cmp_deeply $result, $people, &#39;contacts match&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example scratched the surface of what &lt;code&gt;Test::Deep&lt;/code&gt; is capable of. When you&amp;rsquo;ve got to test a complex data structure, especially in a complex way, use this module. Here is a more difficult example made testable by this module. In this example, &lt;code&gt;$dude-&amp;gt;contacts-&amp;gt;retrieve_all&lt;/code&gt; returns an unordered list of contacts with various bits of information associated with each of them.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use Test::Deep;
  my $person = {
    name     =&amp;gt; re(&amp;quot;^[\w\s]+$&amp;quot;),
    employer =&amp;gt; ignore(),
    age      =&amp;gt; code(sub { shift &amp;gt; 18 }),
  };
  my $people = array_each($person);
  my $result = $dude-&amp;gt;contacts-&amp;gt;retrieve_all;

  cmp_deeply $result, $people, &#39;contacts match&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code, using only functions exported by &lt;code&gt;Test::Deep&lt;/code&gt;, does a lot of work. Each person has a definition that should match &lt;code&gt;$person&lt;/code&gt;. Every person in the &lt;code&gt;$result&lt;/code&gt; list is a hash reference containing three elements. &lt;code&gt;name&lt;/code&gt; must match the regular expression &lt;code&gt;/^[\w\s]+$/&lt;/code&gt;, &lt;code&gt;employer&lt;/code&gt; must exist and its value is ignored, and &lt;code&gt;age&lt;/code&gt; should be over &lt;code&gt;18&lt;/code&gt; or it will fail. &lt;code&gt;array_each()&lt;/code&gt; returns an object that instructs &lt;code&gt;cmp_deeply&lt;/code&gt; that every value in a list must match the definition provided.&lt;/p&gt;

&lt;p&gt;This small amount of code accomplishes quite a lot. &lt;code&gt;Test::Deep&lt;/code&gt; has saved us from wasting time and working hard to solve a difficult problem. It has made the hard things possible.&lt;/p&gt;

&lt;h3 id=&#34;span-id-don-t-let-pod-go-unchecked-don-t-let-pod-go-unchecked-span&#34;&gt;&lt;span id=&#34;Don&#39;t_Let_POD_go_Unchecked&#34;&gt;Don&amp;rsquo;t Let POD go Unchecked&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Documentation is just as important as code, or tests. There are several ways to care for POD in your test suite. First, it&amp;rsquo;s important to keep it well-formed. For this, we turn to &lt;code&gt;Test::Pod&lt;/code&gt;. This Perl module takes all the work out of testing POD with a useful function &lt;code&gt;all_pod_files_ok()&lt;/code&gt;. Simply create a new test program with the following contents.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use Test::More;
  plan skip_all =&amp;gt; &amp;quot;Test::Pod 1.00 required for testing POD&amp;quot;
    unless eval &amp;quot;use Test::Pod 1.00&amp;quot;;
  all_pod_files_ok();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yes, it really is that simple. When you run this program, it will test all the POD it finds in your &lt;em&gt;blib&lt;/em&gt; directory.&lt;/p&gt;

&lt;p&gt;Another simple test we can run on the documentation is coverage analysis. What good is documentation if it doesn&amp;rsquo;t document completely? &lt;code&gt;Test::Pod::Coverage&lt;/code&gt; is the right module for the job, yet another gem that hides all the hard work from us with a simple function, &lt;code&gt;all_pod_coverage_ok()&lt;/code&gt;. Again, we&amp;rsquo;ll create a new test program.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use Test::More;
  plan skip_all =&amp;gt; &amp;quot;Test::Pod::Coverage 1.08 required for testing POD coverage&amp;quot;
    unless eval &amp;quot;use Test::Pod::Coverage 1.08&amp;quot;;
  all_pod_coverage_ok();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Coverage is only half of the battle. Remember, &lt;code&gt;Test::Pod::Coverage&lt;/code&gt; can&amp;rsquo;t tell you if your documentation is actually correct and thorough.&lt;/p&gt;

&lt;p&gt;In both of these examples, we use the &lt;code&gt;plan&lt;/code&gt; function exported from &lt;code&gt;Test::More&lt;/code&gt; to allow us to &amp;ldquo;bail out&amp;rdquo; of our tests if the appropriate Perl module isn&amp;rsquo;t installed. This makes our POD tests optional. If you don&amp;rsquo;t want them to be optional, remove that line and be sure to list them as prerequisites for building and installing your software.&lt;/p&gt;

&lt;h3 id=&#34;span-id-know-what-you-re-testing-know-what-you-re-testing-span&#34;&gt;&lt;span id=&#34;Know_What_You&#39;re_Testing&#34;&gt;Know What You&amp;rsquo;re Testing&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;One of the biggest testing mistakes is to assume that you know what you&amp;rsquo;re testing. Tests are designed to exercise your software. Let your test exercise the good and bad portions of your software. Make it succeed and, most importantly, make it fail. Superior test coverage digs deep into every line of code you&amp;rsquo;ve written. How do you know if your tests are amazing? Coverage analysis.&lt;/p&gt;

&lt;p&gt;Code coverage isn&amp;rsquo;t something you can guess; you need good tools. Perl has a good tool: &lt;code&gt;Devel::Cover&lt;/code&gt;. This module creates a database that maps actual execution to your source code. It analyzes statements, branches, conditions, subroutines, and even POD and execution time. It then provides a total for all of these areas, as well as a total for each Perl module. It&amp;rsquo;s very simple to use, adding just a little to your &lt;code&gt;make test&lt;/code&gt; process.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;gt; cover -delete
  &amp;gt; HARNESS_PERL_SWITCHES=-MDevel::Cover make test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first command deletes any existing coverage database. On the second line we set an environment variable for &lt;code&gt;Test::Harness&lt;/code&gt;, &lt;code&gt;HARNESS_PERL_SWITCHES&lt;/code&gt; to a Perl command-line switch that imports &lt;code&gt;Devel::Caller&lt;/code&gt;. This is all that&amp;rsquo;s required of you. Each of your test programs will now run with &lt;code&gt;Devel::Caller&lt;/code&gt; loaded and analyzing execution in the background.&lt;/p&gt;

&lt;p&gt;To see your coverage database on the command line, issue one command.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;gt; cover
  ---------------------------- ------ ------ ------ ------ ------ ------ ------
  File                           stmt branch   cond    sub    pod   time  total
  ---------------------------- ------ ------ ------ ------ ------ ------ ------
  blib/lib/List/Group.pm         94.7   66.7   33.3  100.0  100.0  100.0   81.6
  Total                          94.7   66.7   33.3  100.0  100.0  100.0   81.6
  ---------------------------- ------ ------ ------ ------ ------ ------ ------

  Writing HTML output to ~/cvs/perl/modules/List-Group/cover_db/coverage.html ...
  done.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, I could&amp;rsquo;ve done better. But what did I fail to test? Notice that &lt;code&gt;cover&lt;/code&gt; wrote some HTML output. That is the diamond in the rough; the HTML output details everything. Each module has its own series of web pages detailing each of the coverage groups. I did particularly poorly on the conditional coverage &amp;ndash; let&amp;rsquo;s see how.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2004_05_07_testing/figure1.jpg&#34; width=&#34;405&#34; height=&#34;290&#34; /&gt;
Now it&amp;rsquo;s become clear. My tests never allow either of the two statements in this condition to succeed. All of my tests make the first statement fail; the second is never executed. I need to update my tests with at least two more for &lt;code&gt;100.0&lt;/code&gt; conditional coverage. The first test will supply a non-number for the &lt;code&gt;$number&lt;/code&gt; variable. The second will supply a value for the &lt;code&gt;$group_by&lt;/code&gt; variable that doesn&amp;rsquo;t exist in the list for which &lt;code&gt;grep&lt;/code&gt; is looking.&lt;/p&gt;

&lt;p&gt;Testing for coverage is a noble goal. I find this method very useful when writing tests for existing software. There are many situations you may think you&amp;rsquo;re testing well. Don&amp;rsquo;t guess; know. Coverage analysis is equally useful for new development. If you&amp;rsquo;ve adopted the &amp;ldquo;test first&amp;rdquo; method and your coverage isn&amp;rsquo;t 100 percent, something is wrong. Either your tests need help, or you&amp;rsquo;ve written more code than originally required.&lt;/p&gt;

&lt;h3 id=&#34;span-id-keep-test-files-organized-keep-test-files-organized-span&#34;&gt;&lt;span id=&#34;Keep_Test_Files_Organized&#34;&gt;Keep Test Files Organized&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Perl software distributions follow several widely adopted guidelines concerning tests. The rules are simple: test files should reside in a &lt;em&gt;t/&lt;/em&gt; directory, and each test file ends in a .t extension. &lt;code&gt;Test::Harness&lt;/code&gt; understands these rules and &lt;code&gt;make test&lt;/code&gt; will run every file that abides by them.&lt;/p&gt;

&lt;p&gt;The filename can be anything you like. It&amp;rsquo;s a good idea to use descriptive filenames instead of just digits or numerical words. Good examples are &lt;em&gt;pod-coverage.t&lt;/em&gt;, &lt;em&gt;software-class-api.t&lt;/em&gt;, and &lt;em&gt;compile.t&lt;/em&gt;. Sometimes it&amp;rsquo;s desirable to determine the order in which your test files will be run. In these cases, prefix the filename with a number. If you want compilation tests to run first and POD tests last, name them accordingly as &lt;em&gt;00-compile.t&lt;/em&gt; and &lt;em&gt;99-pod-coverage.t&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-looking-ahead-looking-ahead-span&#34;&gt;&lt;span id=&#34;Looking_Ahead&#34;&gt;Looking Ahead&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Testing can be a tedious, difficult job. By this point, you have a number of helpful tools to make the task easier. There are many more testing modules on the CPAN that could have been covered here; I encourage you to explore them all.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

