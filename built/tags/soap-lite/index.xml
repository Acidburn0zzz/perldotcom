<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Soap Lite on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/soap-lite/</link>
    <description>Recent content in Soap Lite on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 26 Mar 2003 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/soap-lite/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Five Tips for .NET Programming in Perl</title>
      <link>http://localhost:1313/pub/2003/03/26/perlanddotnet.html/</link>
      <pubDate>Wed, 26 Mar 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/03/26/perlanddotnet.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Randy Ray is coauthor of &lt;a href=&#34;http://www.oreilly.com/catalog/pwebserperl/&#34;&gt;Programming Web Services with Perl&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Abstract: One of the most common categories of questions on the &lt;code&gt;SOAP::Lite&lt;/code&gt; mailing list is how to get Perl SOAP applications to work with .NET services. It&amp;rsquo;s not that Perl and &lt;code&gt;SOAP::Lite&lt;/code&gt; are not suited to the job, but rather that there are easy traps to fall into. Add to that the fact that .NET has its own distinct philosophy toward applications, and the confusion is understandable. This article will cover some of the most common traps and considerations that trip up Perl developers.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;the-net-attraction&#34;&gt;The .NET Attraction&lt;/h3&gt;

&lt;p&gt;When Microsoft first announced its .NET initiative and the variety of technologies that would be created to support it, it was met with some skepticism. Reactions ranged from &amp;ldquo;they&amp;rsquo;re at it again&amp;rdquo; to &amp;ldquo;this could potentially be really powerful.&amp;rdquo; Right now, the reality is sitting somewhere in between, but it is gradually moving from the realm of &amp;ldquo;just another Microsoft gimmick&amp;rdquo; to widespread acceptance. Whatever else the .NET concept accomplishes, it is already bringing Web services to the general desktop arena.&lt;/p&gt;

&lt;p&gt;One of the limiting factors to the larger acceptance of .NET has been the limited set of fully supported languages. Microsoft promotes its C# language, while also providing .NET-enabled development tools and environments for the other languages that its Visual Studio product supports&amp;ndash;Java, C++, and Visual Basic. Because .NET is based on several published standards, other tools that are not generally .NET-centric are still useful, and provide alternatives to the Microsoft tools for some languages, primarily Java.&lt;/p&gt;

&lt;p&gt;The main XML concepts to keep in mind when dealing with a .NET service are XML Schema and WSDL, the Web Services Definition Language. A .NET service automatically generates a WSDL description of itself as a part of the tool environment that Microsoft provides. This is a powerful feature, and the key to interoperability with other languages. WSDL itself defers the definition of complex datatypes to the XML Schema application, which describes both document structure and the nature of the content itself.&lt;/p&gt;

&lt;p&gt;Unfortunately, Perl has been largely overlooked in the tools arena where .NET is concerned. Even though the purpose of basing .NET on open standards was to enable wider integration with other tools, systems, and languages, the only .NET product for Perl currently available is a Visual Studio plug-in for Perl that runs on only Microsoft-based platforms. As the number of .NET services grows, so will the desire to access these services from Perl clients, often on platforms that don&amp;rsquo;t support Visual Studio. The key to doing this lies in the fact that .NET services natively support SOAP as an interface, through the WSDL descriptions.&lt;/p&gt;

&lt;h3 id=&#34;the-tips-tricks&#34;&gt;The Tips &amp;amp; Tricks&lt;/h3&gt;

&lt;p&gt;The rest of this article offers five hints and help on writing these clients in Perl, using the &lt;code&gt;SOAP::Lite&lt;/code&gt; toolkit.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Identify and Qualify&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The first, and most common, mistake that Perl clients make is to forget that .NET interfaces are strongly typed and use named arguments. Perl does neither of these things by default. In fact, when dealing with a SOAP service that is written in Perl, most of the time a client doesn&amp;rsquo;t have to worry about things such as parameter name or type. A .NET service is strict about the names and types (and namespace URIs) of the arguments.&lt;/p&gt;

&lt;p&gt;For example, imagine a service that provides the current time, possibly adjusted for time zone. The call, &lt;code&gt;getCurrentTime&lt;/code&gt;, may be called with no arguments for the time in UTC (Universal Coordinated Time), or it may be passed a single argument, &lt;code&gt;zone&lt;/code&gt;, the specified time zone for which the time should be adjusted. It expects this argument to be of type &lt;code&gt;string&lt;/code&gt; (using the definition of that basic type from the XML Schema specification). But simply passing the argument to a call won&amp;rsquo;t get the name right. Instead, &lt;code&gt;SOAP::Lite&lt;/code&gt; will create a generic name for the parameter when it creates the actual XML, and .NET will reject it.&lt;/p&gt;

&lt;p&gt;To get around this, use the &lt;code&gt;SOAP::Data&lt;/code&gt; class that is a part of &lt;code&gt;SOAP::Lite&lt;/code&gt; (it is in the same module, so you don&amp;rsquo;t have to load a second library):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $arg = SOAP::Data-&amp;gt;new(name =&amp;gt; &#39;zone&#39;, value =&amp;gt; &#39;PST&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;SOAP::Lite&lt;/code&gt; will properly identify values like &amp;ldquo;PST&amp;rdquo; (Pacific Standard Time) or &amp;ldquo;CDT&amp;rdquo; (Central Daylight Time) as being strings. But what if the interface also accepts numerical offsets like &amp;ldquo;-0800&amp;rdquo; or &amp;ldquo;+1100&amp;rdquo;? Without explicit casting as strings, those values would be encoded as &lt;code&gt;int&lt;/code&gt; values. And the service would reject them.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;SOAP::Data&lt;/code&gt; class covers this as well:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $arg = SOAP::Data-&amp;gt;new(name =&amp;gt; &#39;zone&#39;, value =&amp;gt; &#39;PST&#39;, type =&amp;gt; &#39;xsi:string&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(The &lt;em&gt;xsi:&lt;/em&gt; prefix on the type refers to the XML Schema Instance namespace, which &lt;code&gt;SOAP::Lite&lt;/code&gt; always defines and associates with that specific identifier.)&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;SOAP::Data&lt;/code&gt; class provides methods for all aspects of the data item: &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, and so on. It also provides &lt;code&gt;uri&lt;/code&gt; to specify the namespace URI (when needed), and &lt;code&gt;encodingStyle&lt;/code&gt; to specify the URI that identifies an alternative encoding from that being used in the rest of the request.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Be Careful About Namespaces&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The XML namespaces used on elements are just as important in a .NET service as the name and type are. SOAP relies on namespaces to distinguish parts from each other, but again the relaxed nature of Perl can mean that Perl-based services lure you into a false sense of ease that .NET doesn&amp;rsquo;t share.&lt;/p&gt;

&lt;p&gt;Unfortunately, &lt;code&gt;SOAP::Lite&lt;/code&gt; makes this harder for .NET applications by defaulting to no namespace for elements when none is explicitly given. Luckily, the &lt;code&gt;SOAP::Data&lt;/code&gt; class includes a method for defining the namespace as well:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $arg-&amp;gt;url(&#39;http://use.perl.org/Slash/Journal/SOAP&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Explicitly providing the namespace gets even more important when encoding complex types such as hashes and arrays.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Use Classes and Objects to Control Encoding&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The default methods that &lt;code&gt;SOAP::Lite&lt;/code&gt; uses to encode arrays and hash tables will not produce the style of XML that a .NET service is expecting. &lt;code&gt;SOAP::Lite&lt;/code&gt; will base things on the plainest, most vanilla-type descriptions in the SOAP specification itself, while .NET uses complex types as defined in XML Schema for elements that are not basic data.&lt;/p&gt;

&lt;p&gt;Suppose a .NET interface defines a complex type it called &lt;strong&gt;CodeModuleDef&lt;/strong&gt;. This type has (for now) three simple elements: the &lt;em&gt;name&lt;/em&gt; of the module, the &lt;em&gt;language&lt;/em&gt; it is in, and the &lt;em&gt;lines&lt;/em&gt; of code. Now imagine the remote method &lt;strong&gt;registerModule&lt;/strong&gt; expects one such object as an argument. This &lt;em&gt;won&amp;rsquo;t&lt;/em&gt; work:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $soap-&amp;gt;registerModule(SOAP::Data-&amp;gt;name(&#39;module&#39;)-&amp;gt;uri-&amp;gt;(&#39;http://...&#39;)-&amp;gt;
                       value({ name =&amp;gt; &#39;SOAP::Lite&#39;, language =&amp;gt; &#39;perl&#39;,
                               lines =&amp;gt; 4973 }));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The receiving server will get an element typed as &amp;ldquo;SOAPStruct&amp;rdquo; in the default namespace for unknown types (&lt;a href=&#34;http://xml.apache.org/xml-soap&#34;&gt;http://xml.apache.org/xml-soap&lt;/a&gt;). While setting the name and URI were OK, the type will still stop things dead in their tracks. Instead, do this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $soap-&amp;gt;registerModule(SOAP::Data-&amp;gt;name(&#39;module&#39;)-&amp;gt;uri-&amp;gt;(&#39;http://...&#39;)-&amp;gt;
                       value(bless { name =&amp;gt; &#39;SOAP::Lite&#39;,
                                     language =&amp;gt; &#39;perl&#39;,
                                     lines =&amp;gt; 4973 }, &#39;CodeModuleDef&#39;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The resulting structure will have the correct type attribute set. The same approach can be used for array references and scalars that are types other than the basic types.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Oops &amp;hellip; Watch Out for Element Order and Namespaces&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This actually won&amp;rsquo;t quite bridge the gap all the way. There are two problems with it. One is a general Perl feature, the other may be a bug with &lt;code&gt;SOAP::Lite&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The first problem is that XML Schema generally requires the elements of a complex type to be in a well-defined order (there&amp;rsquo;s one type of compound structure that doesn&amp;rsquo;t require this, but it isn&amp;rsquo;t a commonly used). Perl, by nature, doesn&amp;rsquo;t preserve a specific order to hash keys. You can use the &lt;strong&gt;Tie::IxHash&lt;/strong&gt; module, if you know you will always insert the keys in the correct order. Or, you can provide your own serialization code for &lt;code&gt;SOAP::Lite&lt;/code&gt; to use. As it happens, this will allow you to fix the second problem, too. The second problem stems from the fact that &lt;code&gt;SOAP::Lite&lt;/code&gt; assigns the correct namespace to the outer element of the structure, but not to the inner elements. In a schema-based type, all the elements must be in the same namespace. This may be a bug in &lt;code&gt;SOAP::Lite&lt;/code&gt;, but that hasn&amp;rsquo;t been determined for certain (it seems like an unusual feature). The inner elements are in fact given no namespace at all.&lt;/p&gt;

&lt;p&gt;What is needed is a function that can be given to the serializer to use when it encounters an object of any of the special classes. This routine won&amp;rsquo;t have to actually produce XML, &lt;code&gt;SOAP::Lite&lt;/code&gt; will still take care of that. This routine will only have to produce a structure that the serializer will understand from the object it is given. A filter, in other words. To do that, two things are needed: an explicit declaration of the field-order, and an understanding of how the serializer expects to call this filter, and what it expects to be returned by it.&lt;/p&gt;

&lt;p&gt;The explicit ordering is simple; it can be an array declared in the class namespace, or a &amp;ldquo;private&amp;rdquo; key on the hash itself. Unlocking the second piece took some digging around into the internals of the &lt;code&gt;SOAP::Lite&lt;/code&gt; source code. Connecting the two took even more digging.&lt;/p&gt;

&lt;p&gt;For the example approach below, assume that any class that will use this generic serialization filter defines an array called &lt;code&gt;@FIELDS&lt;/code&gt; as a package-global value. Warning: This approach may be a little hard to wrap one&amp;rsquo;s brain around at first. We&amp;rsquo;ll explain it after the code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; sub serialize_complex_type {
   my ($soap, $obj, $name, $type, $attr) = @_;

   my @fields = do { no strict &#39;refs&#39;; @{ref($obj) . &#39;::FIELDS&#39;} };
   if ($name =~ /^(\w+):(\w+)$/) {
     $name = $2;
     $attr-&amp;gt;{xmlns} = $attr-&amp;gt;{&amp;quot;xmlns:$1&amp;quot;};
     delete $attr-&amp;gt;{&amp;quot;xmlns:$1&amp;quot;};
   } else {
     $attr-&amp;gt;{xmlns} = $attr-&amp;gt;{uri};
   }

   [ $name, $attr,
   [ map { defined($obj-&amp;gt;{$_}) ?
           $soap-&amp;gt;encode_object($obj-&amp;gt;{$_}, $_) : () }
     @fields ] ];
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Additionally, every package that plans to use it to serialize their objects will have to make it visible to the &lt;code&gt;SOAP::Serializer&lt;/code&gt; package:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; *SOAP::Serializer::as_Some__Class = \&amp;amp;main::serialize_complex_type;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, we assumed a class name of &lt;code&gt;Some::Class&lt;/code&gt;, and that the earlier code was declared in the main namespace. So what does it all do?&lt;/p&gt;

&lt;p&gt;The serializing routine is called by an object derived from &lt;code&gt;SOAP::Serializer&lt;/code&gt; (or a subclass of it), as a method with the object to serialize, its name, its type, and the hash table of attributes as arguments. It expects to get back an array reference with three or four values. The first is the tag name to use. The second is the hash reference of attributes to add to the opening tag, and the third is either an array reference of nested content, or a simple scalar value to be put inside the opening and closing tag pair. The fourth element, should you include it, is a value for an &amp;ldquo;ID&amp;rdquo; attribute. This is used to uniquely identify an element, for the sake of multiple references and such. We don&amp;rsquo;t worry about it here.&lt;/p&gt;

&lt;p&gt;So we take the arguments as they are given, and the first thing the routine does is check for a name that includes a namespace. Since the style of &lt;code&gt;SOAP::Lite&lt;/code&gt; will leave any child elements unqualified, the namespace label is stripped and the URI itself is assigned to the simple &lt;code&gt;xmlns&lt;/code&gt; attribute. This will make it apply to any child elements of this object. If the object contains other objects as children, then they too will be run through this serializer, so they will have the chance to declare a namespace in the same way. If there was no label, then we take the value of the &lt;code&gt;uri&lt;/code&gt; attribute, which would have been set by calling the &lt;code&gt;SOAP::Data&lt;/code&gt; method of the same name. Finally, we build the array reference using the (possibly modified) &lt;code&gt;$name&lt;/code&gt;, the modified attribute hash reference and an array reference of the object&amp;rsquo;s elements, in field order.&lt;/p&gt;

&lt;p&gt;We got the field order by using a symbolic reference to the &lt;code&gt;@FIELDS&lt;/code&gt; array for the object&amp;rsquo;s class. Much the same sort of trick is needed to get the &lt;code&gt;SOAP::Serializer&lt;/code&gt; class to use this code. When handed a blessed object, the serializer takes the class name, changes all &amp;ldquo;::&amp;rdquo; to &amp;ldquo;__&amp;rdquo;, and prepends &amp;ldquo;as_&amp;rdquo; to the result. It then looks for a method by that name. It searches using the serialization object itself, so the method has to be visible to that class. Right now, there isn&amp;rsquo;t a way in &lt;code&gt;SOAP::Lite&lt;/code&gt; to do this more directly. To hook this serialization into place, we directly alias &amp;ldquo;as_Some__Class&amp;rdquo; into the needed package, as shown above.&lt;/p&gt;

&lt;p&gt;Note that the recursive encoding of the object&amp;rsquo;s contents (which may be objects themselves) is handled by a &lt;code&gt;SOAP::Serializer&lt;/code&gt; method called &amp;ldquo;&lt;code&gt;encode_object&lt;/code&gt;.&amp;rdquo; This is an undocumented part of the serializer that was the source of much of the logic for the code snippet above. It was by examining this routine that the above code (in a slightly different form) was used in writing a complex client to use the MapPoint.NET service, one of Microsoft&amp;rsquo;s commercial .NET services.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Play with &lt;code&gt;stubmaker.pl&lt;/code&gt; and &lt;code&gt;SOAPsh.pl&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;For the last tip, a more simple piece of advice. The &lt;code&gt;SOAP::Lite&lt;/code&gt; package comes with a number of utility scripts. Among these are a &amp;ldquo;shell&amp;rdquo; for testing SOAP services, called &lt;code&gt;SOAPsh.pl&lt;/code&gt;, and a code-generation tool for generating classes from WSDL description files, called &lt;code&gt;stubmaker.pl&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As was mentioned earlier, WSDL plays a major role in the definition and the documentation of .NET services. The &lt;code&gt;stubmaker.pl&lt;/code&gt; tool tries to create Perl classes based on a WSDL document. It does a fairly good job, but it lacks in support for XML Schema. If a service uses any nonbasic types, then the template that &lt;code&gt;stubmaker.pl&lt;/code&gt; generates would not handle it as well.&lt;/p&gt;

&lt;p&gt;This should not prevent you from using the tool. It does a lot of the heavy lifting by extracting the proper namespace URLs, actual server URLs, and remote method names. Even if the code template itself cannot be used directly, then it could still save you work.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;summary&#34;&gt;Summary&lt;/h3&gt;

&lt;p&gt;There is much more to properly dealing with .NET services than can be addressed in a single article. The goal here is to head off some of the more frequently encoutered problems, and let you as the developer focus on more important issues.&lt;/p&gt;

&lt;p&gt;One of the biggest drawbacks to using Perl for .NET is that there is only limited support at present for WSDL and XML Schema. Some new CPAN modules are working to fill these gaps, but they are in early stages of functionality. For now, it is still necessary to do some of the core steps manually. This situation should improve over time.&lt;/p&gt;

&lt;p&gt;As a last &amp;ldquo;bonus&amp;rdquo; tip, remember this: Much of the advice here is just as important for writing .NET services, as it is for writing .NET clients. For the next Web service you write, consider the additional client base you would have access to if you wrote it to be compatible with .NET.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;O&amp;rsquo;Reilly &amp;amp; Associates recently released (December 2002) &lt;a href=&#34;http://www.oreilly.com/catalog/pwebserperl/&#34;&gt;Programming Web Services with Perl&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.oreilly.com/catalog/pwebserperl/chapter/index.html&#34;&gt;Sample Chapter 6, Programming SOAP&lt;/a&gt;, is available free online.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can also look at the &lt;a href=&#34;http://www.oreilly.com/catalog/pwebserperl/toc.html&#34;&gt;Table of Contents&lt;/a&gt;, the &lt;a href=&#34;http://www.oreilly.com/catalog/pwebserperl/inx.html&#34;&gt;Index&lt;/a&gt;, and the &lt;a href=&#34;http://www.oreilly.com/catalog/pwebserperl/desc.html&#34;&gt;Full Description&lt;/a&gt; of the book.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;For more information, or to order the book, &lt;a href=&#34;http://www.oreilly.com/catalog/pwebserperl/&#34;&gt;click here&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>

