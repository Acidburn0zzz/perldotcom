<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Apocalypse on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/apocalypse/</link>
    <description>Recent content in Apocalypse on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 04 Jun 2002 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/apocalypse/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Apocalypse 5</title>
      <link>http://localhost:1313/pub/2002/06/04/apo5.html/</link>
      <pubDate>Tue, 04 Jun 2002 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2002/06/04/apo5.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This is the Apocalypse on Pattern Matching, generally having to do with what we call &amp;ldquo;regular expressions&amp;rdquo;, which are only marginally related to real regular expressions. Nevertheless, the term has grown with the capabilities of our pattern matching engines, so I&amp;rsquo;m not going to try to fight linguistic necessity here. I will, however, generally call them &amp;ldquo;regexes&amp;rdquo; (or &amp;ldquo;regexen&amp;rdquo;, when I&amp;rsquo;m in an Anglo-Saxon mood).&lt;/p&gt;

&lt;p&gt;Here are the RFCs covered in this Apocalypse. PSA stands for &amp;ldquo;problem, solution, acceptance&amp;rdquo;, my private rating of how this RFC will fit into Perl 6. Doubtless I have misclassified &lt;em&gt;your&lt;/em&gt; RFC, though the other ratings are pretty accurate. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    RFC   PSA   Title
    ---   ---   -----
    072   aaa   Variable-length lookbehind. 
    093   abb   Regex: Support for incremental pattern matching
    110   bbb   counting matches
    112   acc   Assignment within a regex
    135   acr   Require explicit m on matches, even with ?? and // as delimiters.
    144   aaa   Behavior of empty regex should be simple
    145   acr   Brace-matching for Perl Regular Expressions
    150   acc   Extend regex syntax to provide for return of a hash of matched subpatterns
    156   aaa   Replace first match function (C&amp;lt;?...?&amp;gt;) with a flag to the match command.
    164   ccr   Replace =~, !~, m//, s///, and tr// with match(), subst(), and trade()
    165   acc   Allow Variables in tr///
    166   abc   Alternative lists and quoting of things
    191   bbc   smart container slicing
    197   cdr   Numeric Value Ranges In Regular Expressions
    198   adr   Boolean Regexes
    261   dbr   Pattern matching on perl values
    274   acc   Generalised Additions to Regexs
    276   aaa   Localising Paren Counts in qr()s.
    308   dar   Ban Perl hooks into regexes
    316   bcr   Regex modifier for support of chunk processing and prefix matching
    317   aaa   Access to optimisation information for regular expressions
    331   acc   Consolidate the $1 and \1 notations
    332   abc   Regex: Make /$/ equivalent to /\z/ under the &#39;/s&#39; modifier
    348   bcc   Regex assertions in plain Perl code
    360   acb   Allow multiply matched groups in regexes to return a listref of all matches
    361   abb   Simplifying split()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Interestingly, there were no withdrawn RFCs for pattern matching. That means either that there were no cork-brained ideas proposed, or that regex culture is so cork-brained already that the cork-brained ideas blend right in. I know where my money is&amp;hellip; &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;In fact, regular expression culture is a mess, and I share some of the blame for making it that way. Since my mother always told me to clean up my own messes, I suppose I&amp;rsquo;ll have to do just that.&lt;/p&gt;

&lt;p&gt;For prior Apocalypses, I&amp;rsquo;ve used the RFCs as a springboard for discussion of my thinking, but this one is special, because none of the RFCs were courageous enough (or foolhardy enough) to look at the big picture and propose radical change where it&amp;rsquo;s needed. But Perl has often been tagged as a language in which it&amp;rsquo;s easy to write programs that are difficult to read, and it&amp;rsquo;s no secret that regular expression syntax that has been the chief culprit. Funny that other languages have been borrowing Perl&amp;rsquo;s regular expressions as fast as they can&amp;hellip;&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s primarily because we took several large steps in Perl 5 to enhance regex capabilities. We took one large step forwards with the &lt;code&gt;/x&lt;/code&gt; option, which allowed whitespace between regex tokens. But we also took several large steps sideways with the &lt;code&gt;(?...)&lt;/code&gt; extension syntax. I call them steps sideways, but they were simultaneously steps forward in terms of functionality and steps backwards in terms of readability. At the time, I rationalized it all in the name of backward compatibility, and perhaps that approach was correct for that time and place. It&amp;rsquo;s not correct now, since the Perl 6 approach is to break everything that needs breaking all at once.&lt;/p&gt;

&lt;p&gt;And unfortunately, there&amp;rsquo;s a lot of regex culture that needs breaking.&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;header&#34;&gt; &lt;/span&gt;&lt;/strong&gt;
Table of Contents&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;span class=&#34;secondary&#34;&gt; &lt;strong&gt;â€¢&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=17#accepted%20rfcs&#34;&gt;Accepted RFCs&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br /&gt;
&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=17#rfc%20072:%20variablelength%20lookbehind.&#34;&gt;RFC 072: Variable-length lookbehind&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=17#rfc%20093:%20regex:%20support%20for%20incremental%20pattern%20matching&#34;&gt;RFC 093: Regex: Support for incremental pattern matching&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=18#rfc%20110:%20counting%20matches&#34;&gt;RFC 110: counting matches&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=18#rfc%20112:%20assignment%20within%20a%20regex&#34;&gt;RFC 112: Assignment within a regex&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=19#rfc%20144:%20behavior%20of%20empty%20regex%20should%20be%20simple&#34;&gt;RFC 144: Behavior of empty regex should be simple&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=19#rfc%20150:%20extend%20regex%20syntax%20to%20provide%20for%20return%20of%20a%20hash%20of%20matched%20subpatterns&#34;&gt;RFC 150: Extend regex syntax to provide for return of a hash of matched subpatterns&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=19#rfc%20156:%20replace%20first%20match%20function%20(...)%20with%20a%20flag%20to%20the%20match%20command.&#34;&gt;RFC 156: Replace first match function (?...?) with a flag to the match command&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=19#rfc%20165:%20allow%20variables%20in%20tr///&#34;&gt;RFC 165: Allow Variables in tr///&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=20#rfc%20166:%20alternative%20lists%20and%20quoting%20of%20things&#34;&gt;RFC 166: Alternative lists and quoting of things&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=20#rfc%20191:%20smart%20container%20slicing&#34;&gt;RFC 191: smart container slicing&amp;quot;&amp;gt;RFC 191: smart container slicing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=21#rfc%20274:%20generalized%20additions%20to%20regexs&#34;&gt;RFC 274: Generalized Additions to Regexs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=21#rfc%20276:%20localising%20paren%20counts%20in%20qr()s.&#34;&gt;RFC 276: Localising Paren Counts in qr()s.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=21#rfc%20317:%20access%20to%20optimisation%20information%20for%20regular%20expressions&#34;&gt;RFC 317: Access to optimisation information for regular expressions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=21#rfc%20331:%20consolidate%20the%20$1%20and%20\1%20notations&#34;&gt;RFC 331: Consolidate the $1 and \1 notations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=21#rfc%20332:%20regex:%20make%20/$/%20equivalent%20to%20/\z/%20under%20the%20&amp;#39;/s&amp;#39;%20modifier&#34;&gt;RFC 332: Regex: Make /$/ equivalent to /\z/ under the &#39;/s&#39; modifier&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=22#rfc%20348:%20regex%20assertions%20in%20plain%20perl%20code&#34;&gt;RFC 348: Regex assertions in plain Perl code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=22#rfc%20360:%20allow%20multiply%20matched%20groups%20in%20regexes%20to%20return%20a%20listref%20of%20all%20matches&#34;&gt;RFC 360: Allow multiply matched groups in regexes to return a listref of all matches&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=23#rfc%20361:%20simplifying%20split()&#34;&gt;RFC 361: Simplifying split()&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;span class=&#34;secondary&#34;&gt; &lt;strong&gt;â€¢&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=24#rejected%20rfcs&#34;&gt;Rejected RFCs&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=24#rfc%20135:%20require%20explicit%20m%20on%20matches,%20even%20with%20%20and%20//%20as%20delimiters.&#34;&gt;RFC 135: Require explicit m on matches, even with ?? and // as delimiters.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=24#rfc%20145:%20bracematching%20for%20perl%20regular%20expressions&#34;&gt;RFC 145: Brace-matching for Perl Regular Expressions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=24#rfc%20164:%20replace%20=~,%20!~,%20m//,%20s///,%20and%20tr//%20with%20match(),%20subst(),%20and%20trade()&#34;&gt;RFC 164: Replace =~, !~, m//, s///, and tr// with match(), subst(), and trade()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=24#rfc%20197:%20numeric%20value%20ranges%20in%20regular%20expressions&#34;&gt;RFC 197: Numeric Value Ranges In Regular Expressions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=24#rfc%20198:%20boolean%20regexes&#34;&gt;RFC 198: Boolean Regexes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=24#rfc%20261:%20pattern%20matching%20on%20perl%20values&#34;&gt;RFC 261: Pattern matching on perl values&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=24#rfc%20308:%20ban%20perl%20hooks%20into%20regexes&#34;&gt;RFC 308: Ban Perl hooks into regexes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=24#rfc%20316:%20regex%20modifier%20for%20support%20of%20chunk%20processing%20and%20prefix%20matching&#34;&gt;RFC 316: Regex modifier for support of chunk processing and prefix matching&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;span class=&#34;secondary&#34;&gt; â€¢ &lt;a href=&#34;http://localhost:1313/pub/2001/04/02/wall.html&#34;&gt;Apocalypse One&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
â€¢ &lt;a href=&#34;http://localhost:1313/pub/2001/05/03/wall.html&#34;&gt;Apocalypse Two&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
â€¢ &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html&#34;&gt;Apocalypse Three&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
â€¢ &lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html&#34;&gt;Apocalypse Four&lt;/a&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Â &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;
&lt;a href=&#34;http://conferences.oreilly.com/oscon/&#34;&gt;O&amp;#39;Reilly Open Source Convention -- July 22-26, San Diego, CA.&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;From the Frontiers of Research to the Heart of the Enterprise&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Don&#39;t miss Larry Walls&#39;s presentation, &lt;a href=&#34;http://conferences.oreillynet.com/cs/os2002/view/e_sess/2642&#34;&gt;Introducing The Perl 6 Language&lt;/a&gt; at the O&#39;Reilly Open Source Convention in July. The conference includes many &lt;a href=&#34;http://conferences.oreillynet.com/pub/w/15/track_perl.html&#34;&gt;sessions&lt;/a&gt; and &lt;a href=&#34;http://conferences.oreillynet.com/pub/w/15/tutorial_perl.html&#34;&gt;tutorials&lt;/a&gt; of interest to Perl developers.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Regex culture has gone wrong in a variety of ways, but it&amp;rsquo;s not my intent to assign blame&amp;ndash;there&amp;rsquo;s plenty of blame to go around, and plenty of things that have gone wrong that are nobody&amp;rsquo;s fault in particular. For example, it&amp;rsquo;s nobody&amp;rsquo;s fault that you can&amp;rsquo;t realistically complement a character set anymore. It&amp;rsquo;s just an accident of the way Unicode defines combining characters. The whole notion of character classes is mutating, and that will have some bearing on the future of regular expression syntax.&lt;/p&gt;

&lt;p&gt;Given all this, I need to warn you that this Apocalypse is going to be somewhat radical. We&amp;rsquo;ll be proposing changes to certain &amp;ldquo;sacred&amp;rdquo; features of regex culture, and this is guaranteed to result in future shock for some of our more conservative citizens. Do not be alarmed. We will provide ways for you to continue programming in old-fashioned regular expressions if you desire. But I hope that once you&amp;rsquo;ve thought about it a little and worked through some examples, you&amp;rsquo;ll like most of the changes we&amp;rsquo;re proposing here.&lt;/p&gt;

&lt;p&gt;So although the RFCs did contribute greatly to my thinking for this Apocalypse, I&amp;rsquo;m going to present my own vision first for where regex culture should go, and then analyze the RFCs with respect to that vision.&lt;/p&gt;

&lt;p&gt;First, let me enumerate some of the things that are wrong with current regex culture.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Too much history&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Too compact and &amp;ldquo;cute&amp;rdquo;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Poor Huffman coding&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Too much reliance on too few metacharacters&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Different things look too similar&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Poor end-weight design&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Too much reliance on modifiers&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Too many special rules and boobytraps&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Backreferences not useful enough&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Too hard to match a literal string&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Two-level interpretation is problematic&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Too little abstraction&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Little support for named captures&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Difficult to use nested patterns&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Little support for grammars&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Inability to define variants&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Poor integration with &amp;ldquo;real&amp;rdquo; language&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Missing backtracking controls&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Difficult to define assertions&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I&amp;rsquo;m sure there are other problems, but that&amp;rsquo;ll do for starters. Let&amp;rsquo;s look at each of these in more detail.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-too-much-history-too-much-history-span&#34;&gt;&lt;span id=&#34;too much history&#34;&gt;Too much history&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Most of the other problems stem from trying to deal with a rich history. Now there&amp;rsquo;s nothing wrong with history per se, but those of us who are doomed to repeat it find that many parts of history are suboptimal and contradictory. Perl has always tried to err on the side of incorporating as much history as possible, and sometimes Perl has succeeded in that endeavor.&lt;/p&gt;

&lt;p&gt;Cultural continuity has much to be said for it, but what can you do when the culture you&amp;rsquo;re trying to be continuous with is itself discontinuous? As it says in Ecclesiastes, there&amp;rsquo;s a time to build up, and a time to tear down. The first five versions of Perl mostly built up without tearing down, so now we&amp;rsquo;re trying to redress that omission.&lt;/p&gt;

&lt;h3 id=&#34;span-id-too-compact-and-cute-too-compact-and-cute-span&#34;&gt;&lt;span id=&#34;too compact and cute&#34;&gt;Too compact and &amp;ldquo;cute&amp;rdquo;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Regular expressions were invented by computational linguists who love to write examples like &lt;code&gt;/aa*b*(cd)*ee/&lt;/code&gt;. While these are conducive to reasoning about pattern matching in the abstract, they aren&amp;rsquo;t so good for pattern matching in the concrete. In real life, most atoms are longer than &amp;ldquo;&lt;code&gt;a&lt;/code&gt;&amp;rdquo; or &amp;ldquo;&lt;code&gt;b&lt;/code&gt;&amp;rdquo;. In real life, tokens are more recognizable if they are separated by whitespace. In the abstract, &lt;code&gt;/a+/&lt;/code&gt; is reducible to &lt;code&gt;/aa*/&lt;/code&gt;. In real life, nobody wants to repeat a 15 character token merely to satisfy somebody&amp;rsquo;s idea of theoretical purity. So we have shortcuts like the &lt;code&gt;+&lt;/code&gt; quantifier to say &amp;ldquo;one or more&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Now, you may rightly point out that &lt;code&gt;+&lt;/code&gt; is something we already have, and we already introduced &lt;code&gt;/x&lt;/code&gt; to allow whitespace, so why is this bullet point here? Well, there&amp;rsquo;s a lot of inertia in culture, and the problem with &lt;code&gt;/x&lt;/code&gt; is that it&amp;rsquo;s not the default, so people don&amp;rsquo;t think to turn it on when it would probably do a lot of good. The culture is biased in the wrong direction. Whitespace around tokens should be the norm, not the exception. It should be acceptable to use whitespace to separate tokens that could be confused. It should not be considered acceptable to define new constructs that contain a plethora of punctuation, but we&amp;rsquo;ve become accustomed to constructs like &lt;code&gt;(?&amp;lt;=...)&lt;/code&gt; and &lt;code&gt;(??{...})&lt;/code&gt; and &lt;code&gt;[\r\n\ck\p{Zl}\p{Zp}]&lt;/code&gt;, so we don&amp;rsquo;t complain. We&amp;rsquo;re frogs who are getting boiled in a pot full of single-character morphemes, and we don&amp;rsquo;t notice.&lt;/p&gt;

&lt;h3 id=&#34;span-id-poor-huffman-coding-poor-huffman-coding-span&#34;&gt;&lt;span id=&#34;poor huffman coding&#34;&gt;Poor Huffman coding&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Huffman invented a method of data compaction in which common characters are represented by a small number of bits, and rarer characters are represented by more bits. The principle is more general, however, and language designers would do well to pay attention to the &amp;ldquo;other&amp;rdquo; Perl slogan: Easy things should be easy, and hard things should be possible. However, we haven&amp;rsquo;t always taken our own advice. Consider those two regex constructs we just saw:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (?&amp;lt;=...)
    (??{...})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which one do you think is likely to be the most common in everyday use? Guess which one is longer&amp;hellip;&lt;/p&gt;

&lt;p&gt;There are many examples of poor Huffman coding in current regexes. Consider these:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (...)
    (?:...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Is it really the case that grouping is rarer than capturing? And by two gobbledygooky character&amp;rsquo;s worth? Likewise there are many constructs that are the same length that shouldn&amp;rsquo;t be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (?:...)
    (?#...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Grouping is much more important than the ability to embed a comment. Yet they&amp;rsquo;re the same length currently.&lt;/p&gt;

&lt;h3 id=&#34;span-id-too-much-reliance-on-too-few-metacharacters-too-much-reliance-on-too-few-metacharacters-span&#34;&gt;&lt;span id=&#34;too much reliance on too few metacharacters&#34;&gt;Too much reliance on too few metacharacters&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;A lot of our Huffman troubles came about because we were trying to shoehorn new capabilities into an old syntax without breaking anything. The &lt;code&gt;(?...)&lt;/code&gt; construct succeeded at that goal, but it was new wine in old wineskins, as they say. More successful was the &lt;code&gt;*?&lt;/code&gt; minimal matching hack, but it&amp;rsquo;s still symptomatic of the problem that we only had three characters to choose from that would have worked at that point in the grammar. We&amp;rsquo;ve pretty nearly exhausted the available backslash sequences.&lt;/p&gt;

&lt;p&gt;The waterbed theory of linguistic complexity says that if you push down one place, it goes up somewhere else. If you arbitrarily limit yourself to too few metacharacters, the complexity comes out somewhere else. So it seems obvious to me that the way out of this mess is to grab a few more metacharacters. And the metacharacters I want to grab are&amp;hellip;well, we&amp;rsquo;ll see in a moment.&lt;/p&gt;

&lt;h3 id=&#34;span-id-different-things-look-too-similar-different-things-look-too-similar-span&#34;&gt;&lt;span id=&#34;different things look too similar&#34;&gt;Different things look too similar&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Consider these constructs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (??{...})
    (?{...})
    (?#...)
    (?:...)
    (?i:...)
    (?=...)
    (?!...)
    (?&amp;lt;=...)
    (?&amp;lt;!...)
    (?&amp;gt;...)
    (?(...)...|...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These all look quite similar, but some of them do radically different things. In particular, the &lt;code&gt;(?&amp;lt;...)&lt;/code&gt; does not mean the opposite of the &lt;code&gt;(?&amp;gt;...)&lt;/code&gt;. The underlying visual problem is the overuse of parentheses, as in Lisp. Programs are more readable if different things look different.&lt;/p&gt;

&lt;h3 id=&#34;span-id-poor-endweight-design-poor-end-weight-design-span&#34;&gt;&lt;span id=&#34;poor endweight design&#34;&gt;Poor end-weight design&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In linguistics, the notion of end-weight is the idea that people tend to prefer sentences where the short things come first and the long things come last. That minimizes the amount of stuff you have to remember while you&amp;rsquo;re reading or listening. Perl violates this with regex modifiers. It&amp;rsquo;s okay when you say something short like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s/foo/bar/g
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But when you say something like we find in RFC 360:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    while ($text =~ /name:\s*(.*?)\n\s*
                    children:\s*(?:(?@\S+)[, ]*)*\n\s*
                    favorite\ colors:\s*(?:(?@\S+)[, ]*)*\n/sigx) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it&amp;rsquo;s not until you read the &lt;code&gt;/sigx&lt;/code&gt; at the end that you know how to read the regex. This actually causes problems for the Perl 5 parser, which has to defer parsing the regular expression till it sees the &lt;code&gt;/x&lt;/code&gt;, because that changes how whitespace and comments work.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-too-much-reliance-on-modifiers-too-much-reliance-on-modifiers-span&#34;&gt;&lt;span id=&#34;too much reliance on modifiers&#34;&gt;Too much reliance on modifiers&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;/s&lt;/code&gt; modifier in the previous example changes the meaning of the &lt;code&gt;.&lt;/code&gt; metacharacter. We could, in fact, do away with the &lt;code&gt;/s&lt;/code&gt; modifier entirely if we only had two different representations for &amp;ldquo;any character&amp;rdquo;, one of which matched a newline, and one which didn&amp;rsquo;t. A similar argument applies to the &lt;code&gt;/m&lt;/code&gt; modifier. The whole notion of something outside the regex changing the meaning of the regex is just a bit bogus, not because we&amp;rsquo;re afraid of context sensitivity, but because we need to have better control within the regex of what we mean, and in this case the context supplied outside the regex is not precise enough. (Perl 5 has a way to control the inner contexts, but it uses the self-obfuscating &lt;code&gt;(?...)&lt;/code&gt; notation.)&lt;/p&gt;

&lt;p&gt;Modifiers that control how the regex is used as a whole do make some sense outside the regex. But they still have the end-weight problem.&lt;/p&gt;

&lt;h3 id=&#34;span-id-too-many-special-rules-and-boobytraps-too-many-special-rules-and-boobytraps-span&#34;&gt;&lt;span id=&#34;too many special rules and boobytraps&#34;&gt;Too many special rules and boobytraps&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Without knowing the context, you cannot know what the pattern &lt;code&gt;//&lt;/code&gt; will do. It might match a null string, or it might match the previously successful match.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;local&lt;/code&gt; operator behaves differently inside regular expressions than it does outside.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s too easy to write a null pattern accidentally. For instance, the following will never match anything but the null string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /
    | foo
    | bar
    | baz
    /x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Even when it&amp;rsquo;s intentional, it may not look intentional:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (a|b|c|)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s hard to read because it&amp;rsquo;s difficult to make the absence of something visible.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s too easy to confuse the multiple meanings of dot. Or the multiple meanings of &lt;code&gt;^&lt;/code&gt;, and &lt;code&gt;$&lt;/code&gt;. And the opposite of &lt;code&gt;\A&lt;/code&gt; is frequently not &lt;code&gt;\Z&lt;/code&gt;, but &lt;code&gt;\z&lt;/code&gt;. Tell me again, when do I say &lt;code&gt;\1&lt;/code&gt;, and when do I say &lt;code&gt;$1&lt;/code&gt;? Why are they different?&lt;/p&gt;

&lt;h3 id=&#34;span-id-backreferences-not-useful-enough-backreferences-not-useful-enough-span&#34;&gt;&lt;span id=&#34;backreferences not useful enough&#34;&gt;Backreferences not useful enough&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Speaking of &lt;code&gt;\1&lt;/code&gt;, backreferences have a number of shortcomings. The first is actually getting ahold of the right backreference. Since captures are numbered from the beginning, you have to count, and you can easily count wrong. For many purposes it would be better if you could ask for the last capture, or the one before that. Or perhaps if there were a way to restart the numbering part way through&amp;hellip;&lt;/p&gt;

&lt;p&gt;Another major problem with backreferences is that you can&amp;rsquo;t easily modify one to search for a variant. Suppose you match an opening parenthesis, bracket, or curly. You&amp;rsquo;ll like to search for everything up to the corresponding closing parenthesis, bracket, or curly, but there&amp;rsquo;s no way to transmogrify the opening version to the closing version, because the backref search is hardwired independently of ordinary variable matching. And that&amp;rsquo;s because Perl doesn&amp;rsquo;t instantiate &lt;code&gt;$1&lt;/code&gt; soon enough. And that&amp;rsquo;s because Perl relies on variable interpolation to get subexpressions into regexes. Which leads us to&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;span-id-too-hard-to-match-a-literal-string-too-hard-to-match-a-literal-string-span&#34;&gt;&lt;span id=&#34;too hard to match a literal string&#34;&gt;Too hard to match a literal string&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Since regexes undergo an interpolation pass before they&amp;rsquo;re compiled, anything you interpolate is forced to be treated as a regular expression. Often that&amp;rsquo;s not what you want, so we have the klunky &lt;code&gt;\Q$string\E&lt;/code&gt; mechanism to hide regex metacharacters. And that&amp;rsquo;s because&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;span-id-twolevel-interpretation-is-problematic-two-level-interpretation-is-problematic-span&#34;&gt;&lt;span id=&#34;twolevel interpretation is problematic&#34;&gt;Two-level interpretation is problematic&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The problem with &lt;code&gt;\Q$string\E&lt;/code&gt; arises because of the fundamental mistake of using interpolation to build regexes instead of letting the regex control how it treats the variables it references. Regexes aren&amp;rsquo;t strings, they&amp;rsquo;re programs. Or, rather, they&amp;rsquo;re strings only in the sense that any piece of program is a string. Just as you have to work to eval a string as a program, you should have to work to eval a string as a regular expression. Most people tend to expect a variable in a regular expression to match its contents literally. Perl violates that expectation. And because it violates that expectation, we can&amp;rsquo;t make &lt;code&gt;$1&lt;/code&gt; synonymous with &lt;code&gt;\1&lt;/code&gt;. And interpolated parentheses throw off the capture count, so you can&amp;rsquo;t easily use interpolation to call subrules, so we invented &lt;code&gt;(??{$var})&lt;/code&gt; to get around that. But then you can&amp;rsquo;t actually get at the parentheses captured by the subrule. The ramifications go on and on.&lt;/p&gt;

&lt;h3 id=&#34;span-id-too-little-abstraction-too-little-abstraction-span&#34;&gt;&lt;span id=&#34;too little abstraction&#34;&gt;Too little abstraction&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Historically, regular expressions were considered a very low-level language, a kind of glorified assembly language for the regex engine. When you&amp;rsquo;re only dealing with ASCII, there is little need for abstraction, since the shortest way to say &lt;code&gt;[a-z]&lt;/code&gt; is just that. With the advent of the eighth bit, we started getting into a little bit of trouble, and POSIX started thinking about names like &lt;code&gt;[:alpha:]&lt;/code&gt; to deal with locale difficulties. But as with the problem of conciseness, the culture was still biased away from naming abstractly anything that could be expressed concretely.&lt;/p&gt;

&lt;p&gt;However, it&amp;rsquo;s almost impossible to write a parser without naming things, because you have to be able to name the separate grammar rules so that the various rules can refer to each other.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s difficult to deal with any subset of Unicode without naming it. These days, if you see &lt;code&gt;[a-z]&lt;/code&gt; in a program, it&amp;rsquo;s probably an outright bug. It&amp;rsquo;s much better to use a named character property so that your program will work right in areas that don&amp;rsquo;t just use ASCII.&lt;/p&gt;

&lt;p&gt;Even where we do allow names, it tends to be awkward because of the cultural bias against it. To call a subrule by name in Perl 5 you have to say this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (??{$rule})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That has 4 or 5 more characters than it ought to. Dearth of abstraction produces bad Huffman coding.&lt;/p&gt;

&lt;h3 id=&#34;span-id-little-support-for-named-captures-little-support-for-named-captures-span&#34;&gt;&lt;span id=&#34;little support for named captures&#34;&gt;Little support for named captures&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Make that &amp;ldquo;no support&amp;rdquo; in Perl, unless you include assignment to a list. This is just a part of the bias against naming things. Instead we are forced to number our capturing parens and count. That works okay for the top-level regular expression, when we can do list assignment or assign &lt;code&gt;$1&lt;/code&gt; to &lt;code&gt;$foo&lt;/code&gt;. But it breaks down as soon as you start trying to use nested regexes. It also breaks down when the capturing parentheses match more than once. Perl handles this currently by returning only the last match. This is slightly better than useless, but not by much.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-difficult-to-use-nested-patterns-difficult-to-use-nested-patterns-span&#34;&gt;&lt;span id=&#34;difficult to use nested patterns&#34;&gt;Difficult to use nested patterns&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;For many of the reasons we&amp;rsquo;ve mentioned, it&amp;rsquo;s difficult to make regexes refer to each other, and even if you do, it&amp;rsquo;s almost impossible to get the nested information back out of them. And there are entire classes of parsing problems that are not solvable without recursive definitions.&lt;/p&gt;

&lt;h3 id=&#34;span-id-little-support-for-grammars-little-support-for-grammars-span&#34;&gt;&lt;span id=&#34;little support for grammars&#34;&gt;Little support for grammars&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Even if it were easier for regexes to refer to other regexes, we&amp;rsquo;d still have the problem that those other regexes aren&amp;rsquo;t organized in any meaningful way. They might be off in variables that come and go at the whim of the surrounding context.&lt;/p&gt;

&lt;p&gt;When we have an organized system of parsing rules, we call it a grammar. One advantage of having a grammar is that you can optimize based on the assumption that the rules maintain their relationship to each other. For instance, if you think of grammar rules as a funny kind of subroutine, you can write an optimizer to inline some of the subrules&amp;ndash;but only if you know the subrule is fixed in the grammar.&lt;/p&gt;

&lt;p&gt;Without support for grammar classes, there&amp;rsquo;s no decent way to think of deriving one grammar from another. And if you can&amp;rsquo;t derive one grammar from another, you can&amp;rsquo;t easily evolve your language to handle new kinds of problems.&lt;/p&gt;

&lt;h3 id=&#34;span-id-inability-to-define-variants-inability-to-define-variants-span&#34;&gt;&lt;span id=&#34;inability to define variants&#34;&gt;Inability to define variants&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;If we want to have variant grammars for Perl dialects, then what about regex dialects? Can regexes be extended either at compile time or at run time? Perl 5 has some rudimentary overloading magic for rewriting regex strings, but that&amp;rsquo;s got the same problems as source filters for Perl code; namely that you just get the raw regex source text and have to parse it yourself. Once again the fundamental assumption is that a regex is a funny kind of string, existing only at the behest of the surrounding program.&lt;/p&gt;

&lt;p&gt;Do we think of regexes as a real, living language?&lt;/p&gt;

&lt;h3 id=&#34;span-id-poor-integration-with-rich-languages-poor-integration-with-rich-languages-span&#34;&gt;&lt;span id=&#34;poor integration with rich languages&#34;&gt;Poor integration with rich languages&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s face it, in the culture of computing, regex languages are mostly considered second-class citizens, or worse. &amp;ldquo;Real&amp;rdquo; languages like C and C++ will exploit regexes, but only through a strict policy of apartheid. Regular expressions are our servants or slaves; we tell them what to do, they go and do it, and then they come back to say whether they succeeded or not.&lt;/p&gt;

&lt;p&gt;At the other extreme, we have languages like Prolog or Snobol where the pattern matching is built into the very control structure of the language. These languages don&amp;rsquo;t succeed in the long run because thinking about that kind of control structure is rather difficult in actual fact, and one gets tired of doing it constantly. The path to freedom is not to make everyone a slave.&lt;/p&gt;

&lt;p&gt;However, I would like to think that there is some happy medium between those two extremes. Coming from a C background, Perl has historically treated regexes as servants. True, Perl has treated them as trusted servants, letting them move about in Perl society better than any other C-like language to date. Nevertheless, if we emancipate regexes to serve as co-equal control structures, and if we can rid ourselves of the regexist attitudes that many of us secretly harbor, we&amp;rsquo;ll have a much more productive society than we currently do. We need to empower regexes with a sense of control (structure). It needs to be just as easy for a regex to call Perl code as it is for Perl code to call a regex.&lt;/p&gt;

&lt;h3 id=&#34;span-id-missing-backtracking-controls-missing-backtracking-controls-span&#34;&gt;&lt;span id=&#34;missing backtracking controls&#34;&gt;Missing backtracking controls&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Perl 5 started to give regexes more control of their own destiny with the &amp;ldquo;grab&amp;rdquo; construct, &lt;code&gt;(?&amp;gt;...)&lt;/code&gt;, which tells the regex engine that when it fails to match the rest of the pattern, it should not backtrack into the innards of the grab, but skip back to before it. That&amp;rsquo;s a useful notion, but there are problems. First, the notation sucks, but you knew that already. Second, it doesn&amp;rsquo;t go far enough. There&amp;rsquo;s no way to backtrack out of just the current grouping. There&amp;rsquo;s no way to backtrack out of just the current rule. Both of these are crucial for giving first-class status to the control flow of regexes.&lt;/p&gt;

&lt;h3 id=&#34;span-id-difficult-to-define-assertions-difficult-to-define-assertions-span&#34;&gt;&lt;span id=&#34;difficult to define assertions&#34;&gt;Difficult to define assertions&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Notionally, a regex is an organization of assertions that either succeed or fail. Some assertions are easily expressed in traditional regex language, while others are more easily expressed in a procedural language like Perl.&lt;/p&gt;

&lt;p&gt;The natural (but wrong) solution is to try to reinvent Perl expressions within regex language. So, for instance, I&amp;rsquo;m rejecting those RFCs that propose special assertion syntax for numerics or booleans. The better solution is to make it easier to embed Perl assertions within regexes.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-brave-new-world-brave-new-world-span&#34;&gt;&lt;span id=&#34;brave new world&#34;&gt;Brave New World&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;ve just made a ton of negative assertions about the current state of regex culture. Now I&amp;rsquo;d like you to perform a cool mental trick and turn all those negatives assertions into positive assertions about what I&amp;rsquo;m going to say, because I&amp;rsquo;m not intending to give the rationale again, but just present the design as it stands. Damian will discuss an extended example in his Exegesis 5, which will show the big picture of how these various features work together to produce a much more readable whole.&lt;/p&gt;

&lt;p&gt;So anyway, here&amp;rsquo;s what&amp;rsquo;s new.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-metacharacter-reform-metacharacter-reform-span&#34;&gt;&lt;span id=&#34;metacharacter reform&#34;&gt;Metacharacter Reform&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Some things stay the same: &lt;code&gt;(...)&lt;/code&gt; captures text just as it did before, and the quantifiers &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, and &lt;code&gt;?&lt;/code&gt; are also unchanged. The vertical bar &lt;code&gt;|&lt;/code&gt; still separates alternatives. The backslash &lt;code&gt;\&lt;/code&gt; still protects the following character from its ordinary interpretation. The &lt;code&gt;?&lt;/code&gt; suffix character still does minimal matching. (Note that these are by far the most commonly used metacharacters, so many ordinary regexes will look nearly identical in Perl 5 and Perl 6.)&lt;/p&gt;

&lt;p&gt;Since &lt;code&gt;/x&lt;/code&gt; extended syntax is now the default, &lt;code&gt;#&lt;/code&gt; is now always a metacharacter indicating a comment, and whitespace is now always &amp;ldquo;meta&amp;rdquo;. Whitespace is now the standard way to separate regex tokens that would otherwise be confused as a single token.&lt;/p&gt;

&lt;p&gt;Even in character classes, whitespace is not taken literally any more. Backwhack the space if you mean it literally, or use &lt;code&gt;&amp;lt;sp&lt;/code&gt;&amp;gt;, or &lt;code&gt;\040&lt;/code&gt;, or &lt;code&gt;\x20&lt;/code&gt;, or &lt;code&gt;\c[SPACE]&lt;/code&gt;. But speaking of character classes&amp;hellip;&lt;/p&gt;

&lt;p&gt;Perhaps the most radical change is that I&amp;rsquo;ve taken &lt;code&gt;[...]&lt;/code&gt; away from character classes and made it the non-capturing grouping operator, because grouping is more fundamental than character classes, and explicit character classes are becoming less common than named character classes. (You can still do character classes, just not with bare square brackets.)&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve also stolen &lt;code&gt;{...}&lt;/code&gt; from generalized quantifiers and made them into closure delimiters. (Use &lt;code&gt;&amp;lt;n,m&amp;gt;&lt;/code&gt; for the generalized quantifier now.)&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve stolen three new metacharacters. The new extensible metasyntax for assertions uses angle brackets, &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt;. And the colon &lt;code&gt;:&lt;/code&gt; is now used for declaration and backtracking control. (Recall Larry&amp;rsquo;s 2nd Law of Language Redesign: Larry gets the colon.) The colon always introduces a token that controls the meaning of what is around it. The nature of the token depends on what follows the colon. Both the colon syntax and angle syntax are extensible. (Backslash syntax is also extensible.)&lt;/p&gt;

&lt;p&gt;This may sound like we&amp;rsquo;re complexifying things, but we&amp;rsquo;re really simplifying. We now have the following regex invariants:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (...)       # always delimits a capturing group
    [...]       # always delimits a non-capturing group
    {...}       # always delimits a closure
    &amp;lt;...&amp;gt;       # always delimits an assertion
    :...        # always introduces a metasyntactic token
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Note that we&amp;rsquo;re using &amp;ldquo;assertion&amp;rdquo; here in the broad sense of anything that either matches or fails, whether or not it has a width.)&lt;/p&gt;

&lt;p&gt;The nature of the angle assertion is controlled by the first character inside it. If the first character is alphabetic, it&amp;rsquo;s a grammatical assertion, and the entire first word controls the meaning. The word is first looked up in the current grammar, if any. If not found there, it is checked to see if it is one of the built-in grammar rules such as those defined by the Unicode property classes. If the first character is not alphabetic, there will be special rules in the current grammar or in the Perl grammar for looking up the parse rule. For instance, by default, any assertion that begins with &lt;code&gt;!&lt;/code&gt; is simply negated. Assertions that start with a digit are assumed to be a range assertion (&lt;code&gt;&amp;lt;n,m&amp;gt;&lt;/code&gt;) regarding the previous atom. (Taking the last two together, you can say &lt;code&gt;&amp;lt;!n,m&amp;gt;&lt;/code&gt; to exclude a range.) Assertions that start with &lt;code&gt;$&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, or &lt;code&gt;&amp;amp;&lt;/code&gt; are assumed to interpolate an indirect regex rule stored in a variable or returned by a subroutine. An assertion that starts with a parenthesis is a closure being used as an assertion. An assertion that starts with a square bracket or another angle bracket is a character class. An assertion that starts with a quote asserts the match of a literal string. And so on.&lt;/p&gt;

&lt;p&gt;Some metacharacters are still used but have a slightly different meaning, in part to get rid of the &lt;code&gt;/s&lt;/code&gt; and &lt;code&gt;/m&lt;/code&gt; modifiers, and in part because most strings in Perl 6 will come from the filehandle pre-chomped. So anchors &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; now always mean the &lt;em&gt;real&lt;/em&gt; beginning and ending of the string. Use &lt;code&gt;^^&lt;/code&gt; and &lt;code&gt;$$&lt;/code&gt; to match the beginnings and endings of lines &lt;em&gt;within&lt;/em&gt; a string. (They&amp;rsquo;re doubled because they&amp;rsquo;re &amp;ldquo;fancier&amp;rdquo;, because they can match in multiple places, and because they&amp;rsquo;ll be rarer, so Huffman says they should be longer.) The &lt;code&gt;^^&lt;/code&gt; and &lt;code&gt;$$&lt;/code&gt; also match where &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; would.&lt;/p&gt;

&lt;p&gt;The dot &lt;code&gt;.&lt;/code&gt; now always matches any character including newline. (Use &lt;code&gt;\N&lt;/code&gt; to match a non-newline. Or better, use an autochomping filehandle, if you&amp;rsquo;re processing line-by-line.)&lt;/p&gt;

&lt;p&gt;In a sense, the sigils &lt;code&gt;$&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, and &lt;code&gt;&amp;amp;&lt;/code&gt; are different metacharacters because they don&amp;rsquo;t interpolate, but are now subject to the interpretation of the regex engine. This allows us to change the default behavior of ordinary &amp;ldquo;interpolation&amp;rdquo; to a literal match, and also lets us put in lvalue-ish constructs like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / $name := (\S+) /
    / @kids := [(\S+) \s+]* /
    / %pets := [(\S+) \: (\S+) \s+]* /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Notice also the delicate interplay of quantified non-capturing brackets with capturing parens, particularly for gathering multiple values or even multiple key/value pairs.)&lt;/p&gt;

&lt;p&gt;Here are some of the metacharacter differences in table form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Old                   New
    ---                   ---
    /pat pat #text        /pat pat #text
        pat/x                 pat/              # Look Ma, no /x!
    /patpat(?#text)/       /pat pat &amp;lt;(&#39;text&#39;)&amp;gt;/ # can always use whitespace

    /pat pat/             / pat\ pat /          # match whitespace literally
                          / pat \s* pat /       # or generically
                          / pat \h* pat /       # or horizontally
                          / pat &amp;lt;&#39; &#39;&amp;gt; pat /     # or as a literal string
                          / pat &amp;lt;sp&amp;gt; pat /      # or by explicit rule
                          /:w pat pat/          # or by implicit rule

    /^pat$/               /^pat\n?$/            # ^ and $ mean string
    /^pat$/m              /^^pat$$/             # no more /m
    /\A...(^pat$)*...\z/m /^...(^^pat$$)*...$/  # no more \A or \z
    /.*\n/                /\N*\n/               # \N is negated \n
                          /.*?\n/               # this still works
    /.*/s                 /.*/                  # . always matches &amp;quot;any&amp;quot;

    \Q$string\E           $string               # interpret literally

    (?{ code })           { code }              # call code, ignore return
                          { code or fail }      # use code as an assertion

    (??{$rule})           &amp;lt;$var&amp;gt;                # call $var as regex
                          &amp;lt;name&amp;gt;                # call rule from current grammar
                          &amp;lt;Other::rule&amp;gt;         # call rule from some Other grammar
                          &amp;lt;*rule&amp;gt;               # bypass local rule to call built-in
                          &amp;lt;@array&amp;gt;              # call array of alternate rules
                          &amp;lt;%hash&amp;gt;               # parse keyword as key to rule
                          &amp;lt;@array[1]&amp;gt;           # call a rule from an array
                          &amp;lt;%hash{&amp;quot;x&amp;quot;}&amp;gt;          # call a rule from a hash
                          &amp;lt;&amp;amp;sub(1,2,3)&amp;gt;         # call a rule returned by a sub
                          &amp;lt;{ code }&amp;gt;            # call return value as anonymous rule
                          &amp;lt;( code )&amp;gt;            # call code as boolean assertion

                          &amp;lt;name(expr)&amp;gt;          # call rule, passing Perl args
                          { .name(expr) }       # same thing.

                          &amp;lt;$var(expr)&amp;gt;          # call rule indirectly by name
                          { .$var(expr) }       # same thing.

                          &amp;lt;name pat&amp;gt;            # call rule, passing regex arg
                          { .name(/pat/) }      # same thing.

                          # maybe...
                          &amp;lt;name: text&amp;gt;          # call rule, passing string
                          { .name(q&amp;lt;text&amp;gt;) }    # same thing.

    [\040\t\p{Zs}]        \h                    # horizontal whitespace
    [\r\n\ck\p{Zl}\p{Zp}] \v                    # vertical whitespace
    [a-z]                 &amp;lt;[a-z]&amp;gt;               # equivalently non-international
                          &amp;lt;alpha&amp;gt;               # more international
    [[:alpha:][:digit:]   &amp;lt;&amp;lt;alpha&amp;gt;&amp;lt;digit&amp;gt;&amp;gt;      # POSIX classes are built-in rules

    {n,m}                 &amp;lt;n,m&amp;gt;                 # assert repeat count
    {$n,$m}               &amp;lt;$n,$m&amp;gt;               # indirect repeat counts

    (?&amp;gt;.*)                [.*]:                 # don&#39;t backtrack through [.*]
                          .*:                   # brackets not necessary on atom
                          (.*):                 # same, but capture
                          &amp;lt;xyz&amp;gt;:                # don&#39;t backtrack into subrule

                          :                     # skip previous atom when backtracking
                          ::                    # fail all |&#39;s when backtracking
                          :::                   # fail current rule when backtracking

                          :=                    # bind a name to following atom
    my ($x) = /(.*)/      my $x; / $x:=(.*) /   # may now bind it inside regex

    (?i)                  :i                    # ignore case in the following
                          :ignorecase           # same thing, self-documenting form
    (?i:...)              [:i ...]              # can limit scope without capture
                          (:i ...)              # can limit scope with capture
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Declarations like &lt;code&gt;:i&lt;/code&gt; are lexically scoped and do not pass to any subrules. Each rule maintains its own sensitivity. There is no built-in operator to turn case ignorance back off&amp;ndash;just call a different rule and it&amp;rsquo;s automatically case sensitive again. (If you want a parameterized subrule, that can be arranged. It&amp;rsquo;s just a method, after all. Proof of this assertion is left to future generations of hackers.)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-backslash-reform-backslash-reform-span&#34;&gt;&lt;span id=&#34;backslash reform&#34;&gt;Backslash Reform&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;There are some changes to backslash sequences. Character properties &lt;code&gt;\p&lt;/code&gt; and &lt;code&gt;\P&lt;/code&gt; are no longer needed&amp;ndash;predefined character classes are just considered intrinsic grammar rules. (You can negate any &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; assertion by using &lt;code&gt;&amp;lt;!...&amp;gt;&lt;/code&gt; instead.) As mentioned in a previous Apocalypse, the &lt;code&gt;\L&lt;/code&gt;, &lt;code&gt;\U&lt;/code&gt;, and &lt;code&gt;\Q&lt;/code&gt; sequences no longer use &lt;code&gt;\E&lt;/code&gt; to terminate&amp;ndash;they now require bracketing characters of some sort. And &lt;code&gt;\Q&lt;/code&gt; will rarely be needed due to regex policy changes. In fact, they may all go away since it&amp;rsquo;s easy to say things like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $(lc $foo)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For any bracketing construct, square brackets are preferred, but others are allowed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    \x[...]     # preferred, indicates simple bracketing
    \x(...)     # okay, but doesn&#39;t capture.
    \x{...}     # okay, but isn&#39;t a closure.
    \x&amp;lt;...&amp;gt;     # okay, but isn&#39;t an assertion
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;\c&lt;/code&gt; sequence is now a bracketing construct, having been extended from representing control characters to any named character.&lt;/p&gt;

&lt;p&gt;Backreferences such as &lt;code&gt;\1&lt;/code&gt; are gone in favor of the corresponding variable &lt;code&gt;$1&lt;/code&gt;. &lt;code&gt;\A&lt;/code&gt;, &lt;code&gt;\Z&lt;/code&gt;, and &lt;code&gt;\z&lt;/code&gt; are gone with the disappearance of &lt;code&gt;/s&lt;/code&gt; and &lt;code&gt;/m&lt;/code&gt;. The position assertion &lt;code&gt;\G&lt;/code&gt; is gone in favor of a &lt;code&gt;:c&lt;/code&gt; modifier that forces continuation from where the last match left off. That&amp;rsquo;s because &lt;code&gt;\G&lt;/code&gt; was almost never used except at the front of a regex. In the unlikely event that you want to assert that you&amp;rsquo;re at the old final position elsewhere in your regex, you can always test the current position (via the &lt;code&gt;.pos&lt;/code&gt; method) with an assertion:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $oldpos = pos $string;
    $string =~ m/... &amp;lt;( .pos == $oldpos )&amp;gt; .../;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may be thinking of &lt;code&gt;.pos&lt;/code&gt; as the final position of the previous match, but that&amp;rsquo;s not what it is. It&amp;rsquo;s the &lt;em&gt;current&lt;/em&gt; position of the current match. It&amp;rsquo;s just that, between matches, the current position of the current match happens to be the same as the final position of the current match, which happens to be the last match, which happens to be done. But as soon as you start another match, the last match is no longer the current match.&lt;/p&gt;

&lt;p&gt;Note that the &lt;code&gt;:c&lt;/code&gt; continuation is needed only on constructs that ordinarily force the search to start from the beginning. Subrules automatically continue at the current location, since their initial position is controlled by some other rule.&lt;/p&gt;

&lt;p&gt;There are two new backslash sequences, &lt;code&gt;\h&lt;/code&gt; and &lt;code&gt;\v&lt;/code&gt;, which match horizontal and vertical whitespace respectively, including Unicode spacing characters and control codes. Note that &lt;code&gt;\r&lt;/code&gt; is considered vertical even though it theoretically moves the carriage sideways. Finally, &lt;code&gt;\n&lt;/code&gt; matches a logical newline, which is not necessarily a linefeed character on all architectures. After all, that&amp;rsquo;s why it&amp;rsquo;s an &amp;ldquo;n&amp;rdquo;, not an &amp;ldquo;l&amp;rdquo;. Your program should not break just because you happened to run it on a file from a partition mounted from a Windows machine. (Within an interpolated string, &lt;code&gt;\n&lt;/code&gt; still produces whatever is the normal newline for the current architecture.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Old                 New
    ---                 ---
    \x0a                \x0a                    # same
    \x{263a}            \x263a                  # brackets required only if ambiguous
    \x{263a}abc         \x[263a]abc             # brackets required only if ambiguous
    \0123               \0123                   # same (no ambiguity with $123 now)
    \0123               \0[123]                 # can use brackets here too

    \p{prop}            &amp;lt;prop&amp;gt;                  # properties are just grammar rules
    \P{prop}            &amp;lt;!prop&amp;gt;

    [\040\t\p{Zs}]      \h                      # horizontal whitespace
    space               \h                      # not exact, but often more correct
    [\r\n\ck\p{Zl}\p{Zp}] \v                    # vertical whitespace

    \Qstring\E          \q[string]
                        &amp;lt;&#39;string with spaces&#39;&amp;gt;  # match literal string
                        &amp;lt;&#39; &#39;&amp;gt;                   # match literal space

    \E                  gone                    # use \Q[...] instead

    \A                  ^                       # ^ now invariant
    \a                  \c[BEL]                 # alarm (bell)

    \Z                  \n?$                    # clearer
    \z                  $                       # $ now invariant
    \G                  &amp;lt;( .pos == $oldpos )&amp;gt;   # match at particular position
                                                # typically just use m:c/pat/

    \N{CENT SIGN}       \c[CENT SIGN]           # named character
    \c[                 \e                      # escape
    \cX                 \c[^X]                  # control char
    \n                  \c[LF]                  # specifically a linefeed
    \x0a\x0d            \x[0a;0d]               # CRLF
    \x0a\x0d            \c[CR;LF]               # CRLF (conjectural)
    \C                  [:u0 .]                 # forced byte in utf8 (dangerous)
    [^\N[CENT SIGN]]    \C[CENT SIGN]           # match any char but CENT SIGN

    \Q$var\E            $var                    # always assumed literal,
    \1                  $1                      # so $1 is literal backref
    /$1/                my $old1 = $1; /$old1/  # must use temporary here

    \r?\n               \n                      # \n asserts logical newline

    [^\n]               \N                      # not a logical newline
                        \C[LF]                  # not a linefeed

    [^\t]               \T                      # not a tab (these are conjectural)
    [^\r]               \R                      # not a return
    [^\f]               \F                      # not a form feed
    [^\e]               \E                      # not an escape
    [^\x1B]             \X1B                    # not specified hex char
    [^\x{263a}]         \X[263a]                # not a Unicode SMILEY

    \X                  &amp;lt;.&amp;gt;                     # a grapheme (combining char seq)
                        [:u2 .]                 # At level 2+, dot means grapheme
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Under level 2 Unicode support, a character is assumed to mean a grapheme, that is, a sequence consisting of a base character followed by 0 or more combining characters. That not only affects the meaning of the &lt;code&gt;.&lt;/code&gt; character, but also any negated character, since a negated character is really a negative lookahead assertion followed by the traversal of a single character. For instance, &lt;code&gt;\N&lt;/code&gt; really means:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [&amp;lt;!before \n&amp;gt; . ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So it doesn&amp;rsquo;t really matter how many characters &lt;code&gt;\n&lt;/code&gt; actually matches. &lt;code&gt;\N&lt;/code&gt; always matches a single character&amp;ndash;whatever that is&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-modifier-reform-modifier-reform-span&#34;&gt;&lt;span id=&#34;modifier reform&#34;&gt;Modifier Reform&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;You can&amp;rsquo;t use colon for a regex delimiter any more. That&amp;rsquo;s because regex modifiers may now be placed in front of a regex construct:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s:w:i:e /foo/bar/           # :words :ignorecase :each
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That can also be written:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s/:w:i:e foo/bar/           # :words :ignorecase :each
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Single character modifiers may be bundled like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s:wie /foo/bar/             # :words :ignorecase :each
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;but only if the sequence as a whole is not already defined as a long modifier, since ambiguity will be resolved in favor of the long modifier. Long modifiers may &lt;em&gt;not&lt;/em&gt; be bundled with any other modifier. So this is legal:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s:once:wie /foo/bar/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but not these (unless you&amp;rsquo;ve defined them):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s:wieonce /foo/bar/
    s:oncewie /foo/bar/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not only is colon disallowed as a regex delimiter, but you may no longer use parentheses as the delimiters either. This will allow us to parameterize modifiers:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s:myoption($x) /foo/bar/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This rule also allows us to differentiate &lt;code&gt;s///&lt;/code&gt; from an &lt;code&gt;s()&lt;/code&gt; function, &lt;code&gt;tr///&lt;/code&gt; from &lt;code&gt;tr()&lt;/code&gt;, etc. If you want matching brackets for the delimiters I&amp;rsquo;d suggest that you use square brackets, since they now mean grouping without capturing.&lt;/p&gt;

&lt;p&gt;Several modifiers, &lt;code&gt;/x&lt;/code&gt;, &lt;code&gt;/s&lt;/code&gt;, and &lt;code&gt;/m&lt;/code&gt;, are no longer needed and have been retired. It&amp;rsquo;s unclear whether &lt;code&gt;/o&lt;/code&gt; is necessary any more. We will assume it&amp;rsquo;s gone unless it&amp;rsquo;s shown that caching can&amp;rsquo;t handle the problem. Note that the regex now has more control over when to cache subrules because it is no longer subject to the vagaries of standard interpolation.&lt;/p&gt;

&lt;p&gt;The old &lt;code&gt;/c&lt;/code&gt; modifier is gone because regexes never reset the position on failure any more. To do that, set &lt;code&gt;$string.pos = 0&lt;/code&gt; explicitly. But note also that assigning to a string automatically resets its position to &lt;code&gt;0&lt;/code&gt;, so any string in your typical loop is going to start with its current search position already set &lt;code&gt;0&lt;/code&gt;. Modifying a string in place causes the position to move to the end of the replacement section by default, if the position was within the span replaced. (This is consistent with &lt;code&gt;s///&lt;/code&gt; semantics.)&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;/e&lt;/code&gt; modifier is also gone, since it did reverse parsing magic, and &lt;code&gt;:e&lt;/code&gt; will be short for &lt;code&gt;:each&lt;/code&gt;&amp;ndash;see below. It&amp;rsquo;s still easy to substitute the value of an expression though:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s/pat/$( code )/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or even&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s(/pat/, { code });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s a new modifier, &lt;code&gt;:once&lt;/code&gt;, that causes a match to succeed only once (like the old &lt;code&gt;?...?&lt;/code&gt; construct). To reset it, use the &lt;code&gt;.reset&lt;/code&gt; method on the regex object. (If you haven&amp;rsquo;t named the regex object, too bad&amp;hellip;)&lt;/p&gt;

&lt;p&gt;Another new modifier is &lt;code&gt;:w&lt;/code&gt;, which causes an implicit match of whitespace wherever there&amp;rsquo;s literal whitespace in a pattern. In other words, it replaces every sequence of actual whitespace in the pattern with a &lt;code&gt;\s+&lt;/code&gt; (between two identifiers) or a &lt;code&gt;\s*&lt;/code&gt; (between anything else). So&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    m:w/ foo bar \: ( baz )*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;really means (expressed in Perl 5 form):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    m:p5/\s*foo\s+bar\s*:(\s*baz\s*)*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can still control the handling of whitespace under &lt;code&gt;:w&lt;/code&gt;, since we extend the rule to say that any explicit whitespace-matching token can&amp;rsquo;t match whitespace implicitly on either side. So:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    m:w/ foo\ bar \h* \: (baz)*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;really means (expressed in Perl 5 form):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    m:p5/\s*foo bar[\040\t\p{Zs}]*:\s*(baz)*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first space in&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /[:w foo bar]/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;matches &lt;code&gt;\s*&lt;/code&gt; before &amp;ldquo;&lt;code&gt;foo&lt;/code&gt;&amp;rdquo;. That&amp;rsquo;s usually what you want, but if it&amp;rsquo;s not what you want, you have a little problem. Unfortunately you can&amp;rsquo;t just say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /[:wfoo bar]/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That won&amp;rsquo;t work because it&amp;rsquo;ll look for the &lt;code&gt;:wfoo&lt;/code&gt; modifier. However, there are several ways to get the effect you want:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /[:w()foo bar]/ 
    /[:w[]foo bar]/ 
    /[:w\bfoo bar]/ 
    /[:w::foo bar]/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That last one is just our friend the &lt;code&gt;::&lt;/code&gt; operator in disguise. If you backtrack into it, you&amp;rsquo;re leaving the brackets anyway, so it&amp;rsquo;s essentially a no-op.&lt;/p&gt;

&lt;p&gt;The new &lt;code&gt;:c&lt;/code&gt;/&lt;code&gt;:cont&lt;/code&gt; modifier forces the regex to continue at the current &amp;ldquo;pos&amp;rdquo; of the string. It may only be used outside the regex. (Well, it could be used inside but it&amp;rsquo;d be redundant.) The modifier also forces the regex to match only the next available thing. That&amp;rsquo;s not quite the same as the &lt;code&gt;^&lt;/code&gt; anchor, though, because it not only disables the implicit scanning done by &lt;code&gt;m//&lt;/code&gt; and &lt;code&gt;s///&lt;/code&gt;, but it also works on more than the first iteration. It forces all matches to be contiguous, in other words. So &lt;code&gt;:c&lt;/code&gt; is short for both &amp;ldquo;continue&amp;rdquo; and &amp;ldquo;contiguous&amp;rdquo;. If you say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $_ = &amp;quot;foofoofoo foofoofoo&amp;quot;;
    s:each:cont/foo/FOO/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    FOOFOOFOO foofoofoo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This may seem odd, but it&amp;rsquo;s precisely the semantics of any embedded regex:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $_ = &amp;quot;foofoofoo foofoofoo&amp;quot;;
    $rx = rx/foo/;
    m/&amp;lt;$rx&amp;gt;*/;          # matches &amp;quot;foofoofoo&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A modifier that starts with a number causes the pattern to match that many times. It may only be used outside the regex. It may not be bundled, because ordinals are distinguished from cardinals. That is, how it treats those multiple matches depends on the next character. If you say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s:3x /foo/bar/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then it changes the first 3 instances. But if you say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s:3rd /foo/bar/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it changes only the 3rd instance. You can say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s:1st /foo/bar/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but that&amp;rsquo;s just the default, and should not be construed as equivalent to &lt;code&gt;:once&lt;/code&gt;, which matches only once, ever. (Unless you &lt;code&gt;.reset&lt;/code&gt; it, of course.)&lt;/p&gt;

&lt;p&gt;You can combine cardinals and ordinals:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s:3x:3rd /foo/bar/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That changes the 3rd, 6th, and 9th occurrences. To change every other quote character, say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s:each:2nd /&amp;quot;/\&amp;amp;rquot;/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;:each&lt;/code&gt; is synonymous with &lt;code&gt;:3x&lt;/code&gt; (for large values of &lt;code&gt;3&lt;/code&gt;). Note that &lt;code&gt;:each&lt;/code&gt; does not, in fact, generate every possible match, because it disallows overlaps. To get every possible match, use the &lt;code&gt;:any&lt;/code&gt; modifier. Saying:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $_ = &amp;quot;abracadabra&amp;quot;;
    @all = m:any /a[^a]+a/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;produces:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    abra aca ada abra
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It can even match multiple times at the same spot as long as the rest of the regex progresses somehow. Saying:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @all = m:any /a.*?a/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;produces:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    abra abraca abracada abracadabra aca acada acadabra ada adabra abra
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $sentence.m:any /^ &amp;lt;english&amp;gt; $/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you&amp;rsquo;ll get every possible parsing of the sentence according to the rules of &lt;code&gt;english&lt;/code&gt; (not to be confused with the rules of English, which are already confusing enough, except when they aren&amp;rsquo;t).&lt;/p&gt;

&lt;p&gt;To indicate varying levels of Unicode support we have these modifiers, which may be used either inside or outside a regex:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    :u0         # use bytes       (. is byte)
    :u1         # level 1 support (. is codepoint)
    :u2         # level 1 support (. is grapheme)
    :u3         # level 1 support (. is language dependent)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These modifiers say nothing about the state of the data, but in general internal Perl data will already be in Normalization Form C, so even under &lt;code&gt;:u1&lt;/code&gt;, the precomposed characters will usually do the right thing. Note that these modifiers are for overriding the default support level, which was probably set by pragma at the top of the file.&lt;/p&gt;

&lt;p&gt;Finally, there&amp;rsquo;s the &lt;code&gt;:p5&lt;/code&gt; modifier, which causes the rest of the regex (or group) to be parsed as a Perl 5 regular expression, including any interpolated strings. (But it still doesn&amp;rsquo;t enable Perl 5&amp;rsquo;s trailing modifiers.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Old                 New
    ---                 ---
    ?pat?               m:once/pat/             # match once only
    /pat/i              m:i/pat/                # ignorecase
                        /:i pat/                # ignorecase
    /pat/x              /pat/                   # always extended
    /pat\s*pat/         /:w pat pat/            # match word sequence
    /(?i)$p5pat/        m:p5/(?i)$p5pat/        # use Perl 5 syntax
    $n = () = /.../g    $n = +/.../;            # count occurrences
    for $i (1..3){s///} s:3///;                 # do 3 times
    /^pat$/m            /^^pat$$/               # no more /m
    /./s                /./                     # no more /s
    /./                 /\N/                    # . now works like /s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-keyword-and-context-reform-keyword-and-context-reform-span&#34;&gt;&lt;span id=&#34;keyword and context reform&#34;&gt;Keyword and Context Reform&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Deferred regex rules are now defined with &lt;code&gt;rx//&lt;/code&gt; rather than &lt;code&gt;qr//&lt;/code&gt;, because a regular expression is no longer a kind of quoted string.&lt;/p&gt;

&lt;p&gt;Actually, just as you can define closures without an explicit &lt;code&gt;sub&lt;/code&gt;, any &lt;code&gt;//&lt;/code&gt; or &lt;code&gt;rx//&lt;/code&gt; declares a deferred regex if it&amp;rsquo;s not in a context that executes it immediately. A regex is executed automatically if it&amp;rsquo;s in a boolean, numeric, or string context. But assignment to an untyped variable is not such a context, nor is passing the regex as an untyped parameter to a function. (Of course, an explicitly declared RULE parameter doesn&amp;rsquo;t provide an evaluating context either.)&lt;/p&gt;

&lt;p&gt;So these are equivalent:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $foo = /.../;            # create regex object
    my $foo = rx[...];          # create regex object
    my $foo = rule {...};       # create regex object
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Likewise, these are equivalent:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @x = split /.../;
    @x = split rx[...];
    @x = split rule {...};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &amp;ldquo;rule&amp;rdquo; syntax is just a way of declaring a deferred regex as if it were a subroutine or method. More on that later.&lt;/p&gt;

&lt;p&gt;To force an immediate evaluation of a deferred regex where it wouldn&amp;rsquo;t ordinarily be, you can use the appropriate unary operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $foo = ?/.../;   # boolean context, return whether matched, 
    my $foo = +/.../;   # numeric context, return count of matches
    my $foo = _/.../;   # string context, return captured/matched string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The standard match and substitution forms also force immediate evaluation regardless of context:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $result = m/.../;           # do match on topic string
    $result = s/.../.../;       # do substitution on topic string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These forms also force the regex to start matching at the beginning of the string in question and scan forward through the string for the match, as if there were an implicit &lt;code&gt;.*?&lt;/code&gt; in front of every iteration. (Both of these behaviors are suppressed if you use the &lt;code&gt;:c&lt;/code&gt;/&lt;code&gt;:cont&lt;/code&gt; modifier). In contrast, the meaning of the deferred forms is dependent on context. In particular, a deferred regex naturally assumes &lt;code&gt;:c&lt;/code&gt; when used as a subrule. That is, it continues where the last match left off, and the next thing has to match right there at the head of the string.&lt;/p&gt;

&lt;p&gt;In any other context, including list context, a deferred regex is &lt;em&gt;not&lt;/em&gt; immediately evaluated, but produces a reference to the regex object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $rx = /.../;     # not evaluated
    my @foo = $rx;      # ERROR: type mismatch.
    my @foo = ($rx);    # One element, a regex object.
    my @foo = (/.../);  # Same thing.
    my @foo := $rx;     # Set autogrow rule for @foo.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To evaluate repeatedly in list context, treat the regex object as you would any other iterator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @foo = &amp;lt;$rx&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also use the more explicit form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @foo = m/&amp;lt;$rx&amp;gt;/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Those aren&amp;rsquo;t identical, since the former assumes &lt;code&gt;:c&lt;/code&gt; and starts up at the current position of the unmentioned topic, while the latter explicitly resets the position to the beginning before scanning. Also, since the deferred regex assumes a &lt;code&gt;:c&lt;/code&gt; modifier, &lt;code&gt;&amp;lt;$rx&amp;gt;&lt;/code&gt; won&amp;rsquo;t scan through the string like &lt;code&gt;m//&lt;/code&gt;. It can return multiple values to the list, but they have to be contiguous. You can get the scanning effect of &lt;code&gt;m//&lt;/code&gt; by prepending the pattern with &lt;code&gt;.*?&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But it&amp;rsquo;s vitally important to understand this fundamental change, that &lt;code&gt;//&lt;/code&gt; is no longer a short form of &lt;code&gt;m//&lt;/code&gt;, but rather a short form of &lt;code&gt;rx//&lt;/code&gt;. If you want to add modifiers to a &lt;code&gt;//&lt;/code&gt;, you have to turn it into an &lt;code&gt;rx//&lt;/code&gt;, not an &lt;code&gt;m//&lt;/code&gt;. It&amp;rsquo;s now &lt;em&gt;wrong&lt;/em&gt; to call &lt;code&gt;split&lt;/code&gt; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    split m/.../
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(That is, it&amp;rsquo;s wrong unless you actually want the return value of the pattern match to be used as the literal split delimiter.)&lt;/p&gt;

&lt;p&gt;The old &lt;code&gt;?...?&lt;/code&gt; syntax is gone. Indeed, it has to go for us to get the unary &lt;code&gt;?&lt;/code&gt; operator.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Old                 New
    ---                 ---
    ?pat?               m:once/pat/
    qr//                rx//
                        rule { }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-null-string-reform-null-string-reform-span&#34;&gt;&lt;span id=&#34;null string reform&#34;&gt;Null String Reform&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The null pattern is now illegal. To match whatever you used to match with a null pattern, use one of these:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Old                 New
    ---                 ---
    //                  /&amp;lt;prior&amp;gt;/       # match what prior match did
    //                  /&amp;lt;null&amp;gt;/        # match the null string between chars
    (a|b|)              (a|b|&amp;lt;null&amp;gt;)    # match a null alternative
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that, as an assertion, &amp;lt;null&amp;gt; always succeeds. You never want to say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / &amp;lt;null&amp;gt; | single | double | triple | home run /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;because you&amp;rsquo;ll never get to first base.&lt;/p&gt;

&lt;h3 id=&#34;span-id-extension-syntax-reform-extension-syntax-reform-span&#34;&gt;&lt;span id=&#34;extension syntax reform&#34;&gt;Extension Syntax Reform&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;There are no longer any &lt;code&gt;(?...)&lt;/code&gt; sequences, because parens now always capture. Some of the replacement sequences take their intrinsic scoping from &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt;, while others are associated with other bracketing characters, or with any arbitrary atom that could be a bracketed construct. Looking at the metasyntax problem from the perspective of a Perl5-to-Perl6 translator, here&amp;rsquo;s what the various Perl 5 extension constructs translate to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Old                 New
    ---                 ---
    (??{$rule})         &amp;lt;$rule&amp;gt;         # call regex in variable
    (?{ code })         { code }        # call Perl code, ignore result
    (?#...)             &amp;lt;(&#39;...&#39;)&amp;gt;       # in-line comment, rarely needed
    (?:...)             [...]           # non-capturing brackets
    (?=...)             &amp;lt;before ...&amp;gt;    # positive lookahead
    (?!...)             &amp;lt;!before ...&amp;gt;   # negative lookahead
    (?&amp;lt;=...)            &amp;lt;after ...&amp;gt;     # positive lookbehind
    (?&amp;lt;!...)            &amp;lt;!after ...&amp;gt;    # negative lookbehind
    (?&amp;gt;...)             [...]:          # grab (any atom)

    (?(cond)yes|no)     [ cond :: yes | no ]
    (?(1)yes|no)        [ &amp;lt;(defined $1)&amp;gt; :: yes | no ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;&amp;lt;$rule&amp;gt;&lt;/code&gt; construct does a &amp;ldquo;delayed&amp;rdquo; call of another regular expression stored in the &lt;code&gt;$rule&lt;/code&gt; variable. If it is a regex object, it&amp;rsquo;s just called as if it were a subroutine, so there&amp;rsquo;s no performance problem. If it&amp;rsquo;s a string, it is compiled as a regex and executed. The compiled form is cached as a property of the string, so it doesn&amp;rsquo;t have to be recompiled unless the string changes. (This implies that we can have properties that invalidate themselves when their base object is modified.) In either case, the evaluated regex is treated as a subrule, and any captures it does are invisible to the outer regex unless the outer regex takes steps to retrieve them. In any event, subrule parens never change the paren count of the outer rule.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;{code}&lt;/code&gt; form doesn&amp;rsquo;t return anything meaningful&amp;ndash;it is used for its side effects. Any such closure may behave as an assertion. It merely has to throw an exception in order to fail. To throw such an exception (on purpose) one may use &lt;code&gt;fail&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $_ = &amp;quot;666&amp;quot;;
    / (\d+) { $1 &amp;lt; 582 or fail }/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As with any assertion, the failing closure starts backtracking at the location of the closure. In this case, it backtracks into the &lt;code&gt;\d+&lt;/code&gt; and ends up matching &amp;ldquo;&lt;code&gt;66&lt;/code&gt;&amp;rdquo; rather than &amp;ldquo;&lt;code&gt;666&lt;/code&gt;&amp;rdquo;. If you didn&amp;rsquo;t want that, use &lt;code&gt;\d+:&lt;/code&gt; instead.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s more succinct, however, to use the code assertion syntax. Just put angles around a parenthesized Perl expression:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / (\d+) &amp;lt;( $1 &amp;lt; 582 )&amp;gt; /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I find the parens to be vaguely reminiscent of the parentheses you have to put around conditionals in C (but not Perl (anymore)). Also, the parentheses are meant to remind you that you only want to put an expression there, not a full statement.&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t use a bare closure to try to interpolate a calculated regex, since the result will be ignored. Instead, use the &lt;code&gt;&amp;lt;{expr}&amp;gt;&lt;/code&gt; form to do that. As with &lt;code&gt;&amp;lt;&amp;amp;rule()&amp;gt;&lt;/code&gt;, the result will be interpreted as a subrule, not as if it were interpolated.&lt;/p&gt;

&lt;p&gt;Since a string is usually true, you can just assert it to get the effect of an inline comment: &lt;code&gt;&amp;lt;(&amp;quot;this is a comment&amp;quot;)&amp;gt;&lt;/code&gt;. But I&amp;rsquo;ve never used one except to show it as an example. Line ending comments are usually much clearer. (Just bear in mind you can&amp;rsquo;t put the final regex delimiter on the same line, because it won&amp;rsquo;t be seen in the comment.) You could also use the &lt;code&gt;{&#39;...&#39;}&lt;/code&gt; construct for comments, but then you risk warnings about &amp;ldquo;useless use of a string in void context&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;[...]&lt;/code&gt; is the new non-capturing bracket notation. It seems to work very well for this purpose&amp;ndash;I tried the other brackets and they tend to &amp;ldquo;disappear&amp;rdquo; faster than square brackets. So we reserve &lt;code&gt;(...)&lt;/code&gt; and &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; for constructs where the visual distance between opening and closing is typically shorter than for square brackets or curlies. The square brackets also work nicely when lined up vertically with vertical bars. Here&amp;rsquo;s a declaration of a named rule from the class Perl6Grammar. It parses Perl 6 statements. (Think of it as a funny looking method declaration.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule state  { &amp;lt;label&amp;gt;
                    [ &amp;lt;control&amp;gt;          {.control}
                    | &amp;lt;sideff&amp;gt; &amp;lt;eostate&amp;gt; {.sideff}
                    | &amp;lt;@other_statements&amp;gt;
                    ]
                };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Huffman coding says that rarer forms should be longer, and that&amp;rsquo;s the case with the lookahead and lookbehind assertions, &lt;code&gt;&amp;lt;before ...&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;after ...&amp;gt;&lt;/code&gt;. (The negations are formed via the general &lt;code&gt;&amp;lt;!...&amp;gt;&lt;/code&gt; rule.) Note that these prepositions are interpreted as assertions, not operations. For example, &lt;code&gt;&amp;lt;before X&amp;gt;&lt;/code&gt; is to be read &amp;ldquo;Assert that we are before X&amp;rdquo; rather than &amp;ldquo;Look before where we are for X&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The new &lt;code&gt;:&lt;/code&gt; operator replaces the &lt;code&gt;(?&amp;gt;...)&lt;/code&gt; construct. It modifies whatever comes before it, much like &lt;code&gt;*&lt;/code&gt; does, so it&amp;rsquo;s naturally scoped if the preceding atom (or quantified atom) is a bracketed construct. Parsers can use this every time they commit to the parsing of a token or phrase to tell the regex engine that there&amp;rsquo;s no point in backtracking through the atom in question, so backtracking will skip backwards over the atom and continue with some earlier branch point. The following takes a long time to fail if it has to look at every sequence of &amp;ldquo;&lt;code&gt;a&lt;/code&gt;&amp;rdquo; to see if there is a &amp;ldquo;&lt;code&gt;b&lt;/code&gt;&amp;rdquo; after it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaac&amp;quot; =~ /^ a* b /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But we already know that the only possible match is the longest one. So if you put in the colon, it fails in one pass because the &lt;code&gt;*&lt;/code&gt; grabs everything and gives nothing back on backtracking.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaac&amp;quot; =~ /^ a*: b /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can use colon on a longer sequence too. The following might match a list of expressions separated by comma:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / &amp;lt;expr&amp;gt; [ , &amp;lt;expr&amp;gt; ]*: /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is an error to use &lt;code&gt;:&lt;/code&gt; on any atom that does no backtracking. This will help to catch errors where you&amp;rsquo;ve forgotten to backslash a literal colon in things like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /^From: (.*)/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perl 6 has no need for a special conditional construct like Perl 5&amp;rsquo;s &lt;code&gt;(?(cond)yes|no)&lt;/code&gt;. That&amp;rsquo;s because with a slight tweak, ordinary alternation can do the same thing. That tweak is our next backtracking modifier, the &lt;code&gt;::&lt;/code&gt; operator. If you backtrack across it, it fails all the way out of the current list of alternatives. Consider an ordinary list of alternatives:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [ &amp;lt;A&amp;gt; &amp;lt;X&amp;gt; | &amp;lt;B&amp;gt; &amp;lt;Y&amp;gt; | &amp;lt;C&amp;gt; &amp;lt;Z&amp;gt; ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The way the rules of backtracking work, if either &lt;code&gt;&amp;lt;A&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;X&amp;gt;&lt;/code&gt; fail, it backtracks to the next alternative. Likewise for &lt;code&gt;&amp;lt;B&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;Y&amp;gt;&lt;/code&gt;. In the case of &lt;code&gt;&amp;lt;C&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;Z&amp;gt;&lt;/code&gt;, there is no next alternative, so it naturally fails out of the entire construct. That&amp;rsquo;s not how a conditional is supposed to work, because in the conditional, only the condition determines which case is executed. Once you&amp;rsquo;ve committed to a particular case, it has to stand or fall as if the conditional hadn&amp;rsquo;t been there. So all we need for our purposes is to have is something that separates the assertions that matter from those that don&amp;rsquo;t. That&amp;rsquo;s what &lt;code&gt;::&lt;/code&gt; does, and it reads rather well as a &amp;ldquo;then&amp;rdquo;, or as a &amp;ldquo;corresponds to&amp;rdquo;. If you write&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [ &amp;lt;A&amp;gt; :: &amp;lt;X&amp;gt;
    | &amp;lt;B&amp;gt; :: &amp;lt;Y&amp;gt;
    | &amp;lt;C&amp;gt; :: &amp;lt;Z&amp;gt;
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then the failure of &lt;code&gt;&amp;lt;A&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;B&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;lt;C&amp;gt;&lt;/code&gt; proceeds to the next case (if any), while any failure in &lt;code&gt;&amp;lt;X&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;Y&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;lt;Z&amp;gt;&lt;/code&gt; is guaranteed to backtrack out of the front of the alternative list and revise a former choice (just as the success of &lt;code&gt;&amp;lt;X&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;Y&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;lt;Z&amp;gt;&lt;/code&gt; is guaranteed to &amp;ldquo;forward track&amp;rdquo; out of the end of the alternative list and try to match more). It&amp;rsquo;s a natural mapping to existing regex semantics. Here&amp;rsquo;s a more realistic example from the Perl 6 grammar. It parses statement modifiers. (The &lt;code&gt;&amp;lt;ws&amp;gt;&lt;/code&gt; rule parses optional whitespace.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule modifier { if     &amp;lt;ws&amp;gt; :: &amp;lt;expr&amp;gt; { .new_cond(0,$expr) }
                  | unless &amp;lt;ws&amp;gt; :: &amp;lt;expr&amp;gt; { .new_cond(1,$expr) }
                  | while  &amp;lt;ws&amp;gt; :: &amp;lt;expr&amp;gt; { .new_loop(0,$expr) }
                  | until  &amp;lt;ws&amp;gt; :: &amp;lt;expr&amp;gt; { .new_loop(1,$expr) }
                  | for    &amp;lt;ws&amp;gt; :: &amp;lt;expr&amp;gt; { .new_for($expr)   }
                  | &amp;lt;@other_modifiers&amp;gt;  # user defined
                  | &amp;lt;null&amp;gt;              # no modifier
                  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In each case, once we recognize a keyword (and its following whitespace), we need to look for an expression, and then call a closure that builds the syntax tree. If either of those fails, the entire modifier rule fails. We only get to the last two alternatives on failure of assertions before the &lt;code&gt;::&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note that the &lt;code&gt;::&lt;/code&gt; only says that we can&amp;rsquo;t backtrack from the &amp;ldquo;then&amp;rdquo; into the &amp;ldquo;if&amp;rdquo;. It says nothing about backtracking into the alternative list as a whole. The alternatives are still choice points, so the regex engine is allowed to backtrack into the alternative list and try another alternative. (To disable that, simply put a &lt;code&gt;:&lt;/code&gt; after the closing bracket of the alternative list.)&lt;/p&gt;

&lt;p&gt;There is nothing in Perl 5 corresponding to the &lt;code&gt;:::&lt;/code&gt; operator, but it works just like &lt;code&gt;::&lt;/code&gt;, only more so. If you backtrack across it, it fails all the way out of the current rule definition (though not out of any rule invoking this definition). That is, it fails all the way out of the innermost lexically enclosing &lt;code&gt;/.../&lt;/code&gt;, &lt;code&gt;m/.../&lt;/code&gt;, &lt;code&gt;s/...//&lt;/code&gt;, &lt;code&gt;rx/.../&lt;/code&gt;, or &lt;code&gt;rule {...}&lt;/code&gt;, skipping out through any enclosing nestings of &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt;, &lt;code&gt;[...]&lt;/code&gt;, or &lt;code&gt;(...)&lt;/code&gt;. (A pattern nested within a closure is classified as its own rule, however, so it never gets the chance to pass out of a &lt;code&gt;{...}&lt;/code&gt; closure.)&lt;/p&gt;

&lt;p&gt;Since the alternatives in our last example are at the top level of the regex, we could have used the &lt;code&gt;:::&lt;/code&gt; operator to get the same effect as &lt;code&gt;::&lt;/code&gt;, because terminating the rule and terminating the alternation amount to the same thing in that case. You can think of all of these as variants on Prolog&amp;rsquo;s &amp;ldquo;cut&amp;rdquo; operator.&lt;/p&gt;

&lt;p&gt;If you backtrack over the &lt;code&gt;::::&lt;/code&gt; operator, it will delete your program from the disk. &lt;code&gt;;-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Actually, the real name of the real &lt;code&gt;::::&lt;/code&gt; operator is &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;. It fails the entire match if you backtrack over it, not just the current rule. That is, it fails all the way out of the &lt;em&gt;outermost&lt;/em&gt; dynamically enclosing &lt;code&gt;/.../&lt;/code&gt;, &lt;code&gt;m/.../&lt;/code&gt;, &lt;code&gt;s/...//&lt;/code&gt;, &lt;code&gt;rx/.../&lt;/code&gt;, or &lt;code&gt;rule {...}&lt;/code&gt; that is executing on the current string.&lt;/p&gt;

&lt;p&gt;There is one &amp;ldquo;cut&amp;rdquo; operator that is beyond &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;; it is appropriately named &lt;code&gt;&amp;lt;cut&amp;gt;&lt;/code&gt;, for two reasons. First of all, it&amp;rsquo;s a real cut operator in that, if you backtrack over it, the current match fails completely, just like &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;. But that&amp;rsquo;s just a side effect of the other reason, which is that &lt;code&gt;&amp;lt;cut&amp;gt;&lt;/code&gt; cuts off the front of the string that you&amp;rsquo;re currently matching on, turning the current position into the new beginning of the string. When you&amp;rsquo;re matching on a potentially infinite string, it&amp;rsquo;s important that you have a way of discarding that part of the match that you&amp;rsquo;ve already committed to. In Perl 5, the only way to do that was with a coordinated system of &lt;code&gt;s/^pat//&lt;/code&gt; operations. With the &lt;code&gt;&amp;lt;cut&amp;gt;&lt;/code&gt; assertion, however, you can just match normally, and cut at one spot in your top-level rule when you reach an &amp;ldquo;accept&amp;rdquo; state.&lt;/p&gt;

&lt;p&gt;In the realm of idle speculation, we could go as far as to define a variant of &lt;code&gt;&amp;lt;cut&amp;gt;&lt;/code&gt; that would render &lt;code&gt;s///&lt;/code&gt; slightly redundant:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s/foo/bar/;
    m/foo &amp;lt;replace(&amp;quot;bar&amp;quot;)&amp;gt; /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that we don&amp;rsquo;t need any special forms for controlling the scope of a &amp;ldquo;fail&amp;rdquo; in a closure. Just prefix the closure with the appropriate backtracking operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / pattern ::: { code() or fail } /  # fails entire rule
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-character-class-reform-character-class-reform-span&#34;&gt;&lt;span id=&#34;character class reform&#34;&gt;Character Class Reform&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;As we mentioned earlier, character classes are becoming more like standard grammar rules, because the definition of &amp;ldquo;character&amp;rdquo; is getting fuzzier. This is part of the motivation for demoting enumerated character classes and stealing the square brackets for another purpose. Actually, for old times&amp;rsquo; sake you still use square brackets on enumerated character classes, but you have to put an extra set of angles around it. But this actually tends to save keystrokes when you want to use any named character classes or Unicode properties, particularly when you want to combine them:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Old                 New
    ---                 ---
    [a-z]               &amp;lt;[a-z]&amp;gt;
    [[:alpha:]]         &amp;lt;alpha&amp;gt;
    [^[:alpha:]]        &amp;lt;-alpha&amp;gt;
    [[:alpha:][:digit]] &amp;lt;&amp;lt;alpha&amp;gt;&amp;lt;digit&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The outer &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; also naturally serves as a container for any extra syntax we decide to come up with for character set manipulation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;[_]+&amp;lt;alpha&amp;gt;+&amp;lt;digit&amp;gt;-&amp;lt;Swedish&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-state-state-span&#34;&gt;&lt;span id=&#34;state&#34;&gt;State&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;[This section gets pretty abstruse. It&amp;rsquo;s okay if your eyes glaze over.]&lt;/p&gt;

&lt;p&gt;Every regex match maintains a state object, and any closure within the regex is actually an anonymous method of that object, which means in turn that the closure&amp;rsquo;s topic is the current state object. Since a unary dot introduces a method call on the current topic, it follows that you can call any method in the state object that way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /(.*) { print .pos }/       # print current position
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The state object may in fact be an instance of a grammar class. A grammar object has additional methods that know how to build a parse tree. Its rules also know how to refer to each other or to rules of related grammars.&lt;/p&gt;

&lt;p&gt;Note that &lt;code&gt;$_&lt;/code&gt; within the closure refers to this state object, not the original search string. If you search on the state object, however, it pretends that you wanted to continue the search on the original string. If the internal search succeeds, the position of the external state is updated as well, just as if the internal search had been a rule invoked directly from the outer regex.&lt;/p&gt;

&lt;p&gt;Because the state object is aware of how the tree is being built, when backtracking occurs the object can destroy parts of the parse tree that were conjectured in error. Because the grammar&amp;rsquo;s action methods have control of the regex state, they can access named fields in the regex without having to explicitly pass them to the method call.&lt;/p&gt;

&lt;p&gt;For instance, in our earlier example we passed &lt;code&gt;$expr&lt;/code&gt; explicitly to build the parse tree, but the method can actually figure that out itself. So we could have just written:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule modifier { if     &amp;lt;ws&amp;gt; :: &amp;lt;expr&amp;gt; { .new_cond(0) }
                  | unless &amp;lt;ws&amp;gt; :: &amp;lt;expr&amp;gt; { .new_cond(1) }
                  | while  &amp;lt;ws&amp;gt; :: &amp;lt;expr&amp;gt; { .new_loop(0) }
                  | until  &amp;lt;ws&amp;gt; :: &amp;lt;expr&amp;gt; { .new_loop(1) }
                  | for    &amp;lt;ws&amp;gt; :: &amp;lt;expr&amp;gt; { .new_for }
                  | &amp;lt;@other_modifiers&amp;gt;  # user defined
                  | &amp;lt;null&amp;gt;              # no modifier
                  },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See Variable Scoping below for where &lt;code&gt;@other_modifiers&lt;/code&gt; gets looked up.&lt;/p&gt;

&lt;p&gt;Within a closure, &lt;code&gt;$_&lt;/code&gt; represents the current state of the current regex, and by extension, the current state of all the regexes participating in the current match. (The type of the state object is the current grammar class, which may be an anonymous type if the current grammar has no name. If the regex is not a member of a grammar, it&amp;rsquo;s of type RULE.) Part of the state of the current regex is the current node of the parse tree that is being built. When the current regex succeeds, the state object becomes a result object, and is returned to the calling regex. The calling regex can refer to the returned object as a &amp;ldquo;hypothetical&amp;rdquo; variable, the name of which is either implicitly generated from the name of the rule, or explicitly bound using &lt;code&gt;:=&lt;/code&gt;. Through that variable you can get at anything captured by the subrule. (That is what &lt;code&gt;$expr&lt;/code&gt; was doing earlier.)&lt;/p&gt;

&lt;p&gt;When the entire match succeeds, the top-level node is returned as a result object that has various values in various contexts, whether boolean, numeric, or string context. The name of the result object is &lt;code&gt;$0&lt;/code&gt;. The result object contains all the other information, such as &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, etc. Unlike &lt;code&gt;$&amp;amp;&lt;/code&gt; in Perl 5, &lt;code&gt;$0&lt;/code&gt; is lexically scoped to the enclosing block. By extension, &lt;code&gt;$1&lt;/code&gt;, etc. are also lexically scoped.&lt;/p&gt;

&lt;p&gt;As a kind of iterator, a regex stored in a variable doesn&amp;rsquo;t expand in list context unless you put angles around it or use it with &lt;code&gt;m//&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $rx = /(xxx)/;
    print 1,2,&amp;lt;$rx($_)&amp;gt;;

    print 1,2,&amp;lt;/(xxx)/&amp;gt;;

    my &amp;amp;rx := /(xxx)/;
    print 1,2,&amp;lt;rx($_)&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$0&lt;/code&gt;, &lt;code&gt;$1&lt;/code&gt;, etc. are not set in iterated cases like this. Each list item is a result object, though, and you can still get at the internal values that way.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-hypothetical-variables-er-values-hypothetical-variables-er-values-span&#34;&gt;&lt;span id=&#34;hypothetical variables, er values&#34;&gt;Hypothetical Variables, er Values&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Values that are determined within a regular expression should usually be viewed as speculative, subject to cancellation if backtracking occurs. This applies not only to the values captured by &lt;code&gt;(...)&lt;/code&gt; within the regex, but also to values determined within closures embedded in the regex. The scope of these values is rather strange, compared to ordinary variables. They are dynamically scoped, but not like &lt;code&gt;temp&lt;/code&gt; variables. A temporary variable is restored at the end of the current block. A hypothetical variable keeps its value after the current block exits, and in fact keeps that value clear to the end of its natural lifetime if the regex succeeds (where the natural lifetime depends on where it&amp;rsquo;s declared). But if failure causes backtracking over where the variable was set, then it is restored to its previous state. Perl 5 actually coerced the &lt;code&gt;local&lt;/code&gt; operator into supporting this behavior, but that was a mistake. In Perl 6 &lt;code&gt;temp&lt;/code&gt; will keep consistent semantics, and restore values on exit from the current block. A new word, &lt;code&gt;let&lt;/code&gt;, will indicate the desire to set a variable to a hypothetical value. (I was tempted to use &amp;ldquo;suppose&amp;rdquo;, but &amp;ldquo;let&amp;rdquo; is shorter, and tends to mean the same thing, at least to mathematicians.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $x;
    / (\S*) { let $x = .pos } \s* foo /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After this pattern, &lt;code&gt;$x&lt;/code&gt; will be set to the ending position of &lt;code&gt;$1&lt;/code&gt;&amp;ndash;but only if the pattern succeeds. If it fails, &lt;code&gt;$x&lt;/code&gt; is restored to &lt;code&gt;undef&lt;/code&gt; when the closure is backtracked. It&amp;rsquo;s possible to do things in a closure that the regex engine doesn&amp;rsquo;t know how to backtrack, of course, but a hypothetical value doesn&amp;rsquo;t fall into that category. For things that do fall into that category, perhaps we need to define a &lt;code&gt;BACK&lt;/code&gt; block that is like &lt;code&gt;UNDO&lt;/code&gt;, but scoped to backtracking.&lt;/p&gt;

&lt;p&gt;Sometimes we&amp;rsquo;ll talk about declaring a hypothetical variable, but as with &lt;code&gt;temp&lt;/code&gt; variables, we&amp;rsquo;re not actually declaring the variable itself, but the dynamic scope of its new value. In Perl 6, you can in fact say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $x = 0;
    ...
    {
        temp $x = 1;    # temporizes the lexical variable
        ...
    }
    # $x restored to 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(This is primarily useful for dynamically scoping a file-scoped lexical, which is slightly safer than temporizing a package variable since nobody can see it outside the file.)&lt;/p&gt;

&lt;p&gt;You may declare a hypothetical variable only when the topic is a regex state. This is not as much of a hardship as it might seem. Suppose your closure calls out to some other routine, and passes the regex state as an argument, &lt;code&gt;$rx_state&lt;/code&gt;. It suffices to say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    given $rx_state { let $x = .pos }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As it happens, &lt;code&gt;$1&lt;/code&gt; and friends are all simply hypothetical variables. When we say &amp;ldquo;hypothetical variable&amp;rdquo;, we aren&amp;rsquo;t speaking of where the variable is stored, but rather how its contents are treated dynamically. If a regex sets a hypothetical variable that was declared with either &lt;code&gt;my&lt;/code&gt; or &lt;code&gt;our&lt;/code&gt; beforehand, then the regex modifies that lexical or package variable, and &lt;code&gt;let&lt;/code&gt; is purely a run-time operation.&lt;/p&gt;

&lt;p&gt;On the other hand, if the variable is not pre-declared, it&amp;rsquo;s actually stored in the regex state object. In this case, the &lt;code&gt;let&lt;/code&gt; also serves to declare the variable as lexically scoped to the rest of the regex, in addition to its run-time action. Such a variable is not directly visible outside the regex, but you can get at it through the &lt;code&gt;$0&lt;/code&gt; object (always presuming the match succeeded). For a regex variable named &lt;code&gt;$maybe&lt;/code&gt;, its external name is &lt;code&gt;$0._var_{&#39;maybe&#39;}&lt;/code&gt;. The &lt;code&gt;$0&lt;/code&gt; object can behave as a hash, so &lt;code&gt;$0{maybe}&lt;/code&gt; is the short way to say that.&lt;/p&gt;

&lt;p&gt;All other variable names are stored with their sigil, so the external name for &lt;code&gt;@maybe&lt;/code&gt; is &lt;code&gt;$0{&#39;@maybe&#39;}&lt;/code&gt;, and for &lt;code&gt;%maybe&lt;/code&gt; is &lt;code&gt;$0{&#39;%maybe&#39;}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$1&lt;/code&gt; is a special case&amp;ndash;it&amp;rsquo;s visible outside the regex, not because it&amp;rsquo;s predeclared, but because Perl already knows that the numbered variable &lt;code&gt;$1&lt;/code&gt; is really stored as a subarray of the $0 object: &lt;code&gt;$0[1]&lt;/code&gt;. The numbered variables are available only through the array, not the hash.&lt;/p&gt;

&lt;p&gt;Since &lt;code&gt;$0&lt;/code&gt; represents the state of the currently executing regex, you can&amp;rsquo;t use it within a rule to get at the result of a completed subrule. When you successfully call a subrule named &lt;code&gt;&amp;lt;somerule&amp;gt;&lt;/code&gt;, the regex state is automatically placed in a hypothetical variable named &lt;code&gt;$somerule&lt;/code&gt;. (Rules accessed indirectly must be captured explicitly, or they won&amp;rsquo;t have a name by which you can get to them. More on that in the next section.)&lt;/p&gt;

&lt;p&gt;As the current recursive regex executes, it automatically builds a tree of hashes corresponding to all captured hypothetical variables. So from outside the regex, you could get at the &lt;code&gt;$1&lt;/code&gt; of the subrule &lt;code&gt;&amp;lt;somerule&amp;gt;&lt;/code&gt; by saying &lt;code&gt;$0{somerule}[1]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-named-captures-named-captures-span&#34;&gt;&lt;span id=&#34;named captures&#34;&gt;Named Captures&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Suppose you want to use a hypothetical variable to bind a name to a capture:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / (\S+) { let $x := $1 } /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A shorthand for that is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / $x:=(\S+) /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The parens are numbered independently of any name, so &lt;code&gt;$x&lt;/code&gt; is an alias for &lt;code&gt;$1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You may also use arrays to capture appropriately quantified patterns:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / @x := (\S+ \s*)* /                # including space
    / @x := [ (\S+) \s* ]* /            # excluding space
    / @x := [ (\S+) (\s*) ]* /          # each element is [word, space]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that in general, naming square brackets doesn&amp;rsquo;t cause the square brackets to capture, but rather provides a destination for the parens within the square brackets. Only parens and rules can capture. It&amp;rsquo;s illegal to name square brackets that don&amp;rsquo;t capture something inside.&lt;/p&gt;

&lt;p&gt;You can also capture to a hash:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / %x := [ (\S+)\: \s* (.*) ]* /     # key/value pairs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After that match, &lt;code&gt;$1&lt;/code&gt; returns a list of keys, and &lt;code&gt;$2&lt;/code&gt; returns a list of values. You can capture just the keys:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / %x := [ (\S+) \s* ]* /            # just enter keys, values are undef
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can capture a closure&amp;rsquo;s return value too:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / $x := { &amp;quot;I&#39;m in scalar context&amp;quot; } /
    / @x := { &amp;quot;I&amp;quot;, &amp;quot;am&amp;quot;, &amp;quot;in&amp;quot;, &amp;quot;list&amp;quot;, &amp;quot;context&amp;quot; } /
    / %x := { &amp;quot;I&amp;quot; =&amp;gt; &amp;quot;am in hash context&amp;quot; } /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that these do not use parens. If you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / $x := ({ code }) /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it would capture whatever text was traversed by the closure, but ignore the closure&amp;rsquo;s actual return value.&lt;/p&gt;

&lt;p&gt;You can reorder paren groups by naming them with numeric variables:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / $2:=(.*?), \h* $1:=(.*) /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you use a numeric variable, the numeric variables will start renumbering from that point, so subsequent captures can be of a known number (which clobbers any previous association with that number). So for instance you can reset the numbers for each alternative:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / $1 := (.*?) (\:)  (.*) { process $1, $2, $3 }
    | $1 := (.*?) (=\&amp;gt;) (.*) { process $1, $2, $3 }
    | $1 := (.*?) (-\&amp;gt;) (.*) { process $1, $2, $3 }
    /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s also possible to refer to captures relative to the current location. &lt;code&gt;$-1&lt;/code&gt; refers to the immediately preceding capture (what used to be known as &lt;code&gt;$+&lt;/code&gt;). &lt;code&gt;$-2&lt;/code&gt; refers to the one before that. If you use anything above &lt;code&gt;$-3&lt;/code&gt; we&amp;rsquo;ll come and take you away to the insane asylum.&lt;/p&gt;

&lt;p&gt;Subrules called via &lt;code&gt;&amp;lt;rule&amp;gt;&lt;/code&gt; also capture their result in hypothetical variables. It&amp;rsquo;s possible to name the results of any &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt;, but grammar rules already have a name by default, so you don&amp;rsquo;t have to give them names unless you call the same rule more than once. So, presuming you have grammar rules defining &amp;ldquo;key&amp;rdquo; and &amp;ldquo;value&amp;rdquo;, you can say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / &amp;lt;key&amp;gt; \: &amp;lt;value&amp;gt; { let %hash{$key} = $value } /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, in a typical grammar the typical rule may not return a string, but a reference to an anonymous object representing a node of the parse tree. But that depends on what the subrule decides to capture. If the only thing captured in the subrule is a single string, that&amp;rsquo;s what you get. (If nothing is captured, you get the entire match.)&lt;/p&gt;

&lt;p&gt;Any capture that will capture multiple items will, if asked to put it into a scalar variable, produce an anonymous list automatically. This should rarely be a surprise, since it&amp;rsquo;s obvious by inspection whether you&amp;rsquo;ve quantified the capture or not. So if you say any of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / $x := &amp;lt;word&amp;gt;*/
    / $x := &amp;lt;word&amp;gt;+/
    / $x := &amp;lt;word&amp;gt;&amp;lt;1,3&amp;gt;/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then you&amp;rsquo;ve &amp;ldquo;pluralized&amp;rdquo; the naming, and you can expect to get some number of values in &lt;code&gt;$x&lt;/code&gt; as an anonymous list. However, the &lt;code&gt;?&lt;/code&gt; quantifier specifically doesn&amp;rsquo;t pluralize. If you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / $x := &amp;lt;word&amp;gt;?/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then &lt;code&gt;$x&lt;/code&gt; will either be the result of the subrule or &lt;code&gt;undef&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can name the results of a zero-width assertion, but you&amp;rsquo;d typically only get the null string out of it. This can still be useful, since it contrasts with the undefined value you&amp;rsquo;d have if the assertion fails. (It is possible with an explicit capture to return a non-zero-width string from a zero-width assertion, however.)&lt;/p&gt;

&lt;h3 id=&#34;span-id-variable-scoping-variable-scoping-span&#34;&gt;&lt;span id=&#34;variable scoping&#34;&gt;Variable Scoping&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;When you refer to a variable &lt;code&gt;@foo&lt;/code&gt; as an rvalue in a regex, it searches for an existing variable in the following places:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;We first look to see if the variable is already declared lexically with either &lt;code&gt;my @foo&lt;/code&gt; or &lt;code&gt;our @foo&lt;/code&gt;. If so declared, we&amp;rsquo;re done.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Next we look for &lt;code&gt;@foo&lt;/code&gt; in the current regex&amp;rsquo;s name table. The name of the variable is really &lt;code&gt;$0{&#39;@foo&#39;}&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If the regex belongs to a grammar, we next look for &lt;code&gt;@foo&lt;/code&gt; in the grammar object. If there, its real name is &lt;code&gt;@.foo&lt;/code&gt;, or some such. (It might be objected that the grammar object is not yet constructed when the regex is compiled. After all, the regex is probably being passed to the grammar object&amp;rsquo;s constructor. But I think if such a variable is declared as an object attribute we know that there &lt;em&gt;will&lt;/em&gt; be such a variable/accessor later when we have finished constructing, and that seems like enough info to know how to compile the regex.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Next we look for &lt;code&gt;@foo&lt;/code&gt; as a declared core global variable &lt;code&gt;@*foo&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Finally, if &amp;ldquo;strict vars&amp;rdquo; is not in effect, we assume that &lt;code&gt;@foo&lt;/code&gt; is stored in the current package. Otherwise it&amp;rsquo;s a stricture error.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-variable-interpretation-variable-interpretation-span&#34;&gt;&lt;span id=&#34;variable interpretation&#34;&gt;Variable Interpretation&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;As we mentioned earlier, bare scalars match their contents literally. (Use &lt;code&gt;&amp;lt;$var&amp;gt;&lt;/code&gt; instead to match a regex defined in &lt;code&gt;$var&lt;/code&gt;.) Subscripted arrays and hashes behave just like a scalar as long as the subscripts aren&amp;rsquo;t slices.&lt;/p&gt;

&lt;p&gt;If you use a bare array (unsubscripted), it will match if &lt;em&gt;any&lt;/em&gt; element of the array matches literally at that point. (A slice of an array or hash also behaves this way.) If you say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @array = (&amp;quot;^&amp;quot;, &amp;quot;$&amp;quot;, &amp;quot;.&amp;quot;);
    / @array /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it&amp;rsquo;s as if you said&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / \^ | \$ | \. /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But if you you slice it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / @array[0..1] /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it won&amp;rsquo;t match the dot.&lt;/p&gt;

&lt;p&gt;If you want the array to be considered as a set of regex alternatives, enclose in angles:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @array = (&amp;quot;^foo$&amp;quot;, &amp;quot;^bar$&amp;quot;, &amp;quot;^baz$&amp;quot;);
    / &amp;lt;@array&amp;gt; /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bare hashes in a regex provide a sophisticated match-via-lookup mechanism. Bare hashes are matched as follows:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Match a key at the current point in the string.&lt;/p&gt;

&lt;p&gt;1a. If the hash has its &lt;code&gt;keymatch&lt;/code&gt; property set to some regex, use that regex to match the key.&lt;/p&gt;

&lt;p&gt;1b. Otherwise, use &lt;code&gt;/\w+:/&lt;/code&gt; to match the key.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If a key isn&amp;rsquo;t found at the current position in the string, the match fails.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Otherwise, get the value in the hash corresponding to the matched key.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If the is no entry for that key, the match fails.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If the hash doesn&amp;rsquo;t have a &lt;code&gt;valuematch&lt;/code&gt; property, the match succeeds immediately.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Otherwise use the hash&amp;rsquo;s &lt;code&gt;valuematch&lt;/code&gt; property (typically itself a regex) to extract the value at the current point in the string.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If no value can be extracted, matching of the hash fails.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If the extracted value string is &lt;code&gt;eq&lt;/code&gt; to the key&amp;rsquo;s actual value, matching of the original hash immediately succeeds.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Otherwise, matching of the original hash fails.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So matching a bare hash is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule {
        $key := &amp;lt;{ %hash.prop{keymatch} // /\w+:/ }&amp;gt;    # find key
        &amp;lt;( exists %hash{$key} )&amp;gt;                        # if exists
        [ &amp;lt;( not defined %hash.prop{valuematch} )&amp;gt; ::   # done?
            &amp;lt;null&amp;gt;                                      # succeed
        |                                               # else
            $val := &amp;lt;%hash.prop{valuematch}&amp;gt;            # find value
                &amp;lt;( $val eq %hash{$val} )&amp;gt;               # assert eq
        ]
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A typical &lt;code&gt;valuematch&lt;/code&gt; might look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule {
        \s* =\&amp;gt; \s*             # match =&amp;gt; 
        $q:=(&amp;lt;[&amp;quot;&#39;]&amp;gt;)            # match initial quote 
        $0:=( [ \\. | . ]*? )   # return matched value
        $q                      # match trailing quote 
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In essence, the presence or absence of the &lt;code&gt;valuematch&lt;/code&gt; property controls whether the hash tries to match only keys, or both keys and values.&lt;/p&gt;

&lt;p&gt;A hash may be used inside angles as well. In that case, it finds the key by the same method (steps 1 and 2 above), but always treats the corresponding hash value as a regex (regardless of any properties the hash might have). The parse then continues according to the rule found in the hash. For example, we could parse a set of control structures with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule { &amp;lt;%controls&amp;gt; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;%controls&lt;/code&gt; hash can have keys like &amp;ldquo;&lt;code&gt;if&lt;/code&gt;&amp;rdquo; and &amp;ldquo;&lt;code&gt;while&lt;/code&gt;&amp;rdquo; in it. The corresponding entry says how to parse the rest of an &lt;code&gt;if&lt;/code&gt; or a &lt;code&gt;while&lt;/code&gt; statement. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        %controls = ( 
            if     =&amp;gt; / &amp;lt;condition&amp;gt;      &amp;lt;closure&amp;gt; /,
            unless =&amp;gt; / &amp;lt;condition&amp;gt;      &amp;lt;closure&amp;gt; /,
            while  =&amp;gt; / &amp;lt;condition&amp;gt;      &amp;lt;closure&amp;gt; /,
            until  =&amp;gt; / &amp;lt;condition&amp;gt;      &amp;lt;closure&amp;gt; /,
            for    =&amp;gt; / &amp;lt;list_expr&amp;gt;      &amp;lt;closure&amp;gt; /,
            loop   =&amp;gt; / &amp;lt;loop_controls&amp;gt;? &amp;lt;closure&amp;gt; /,
        );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So saying:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;%controls&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is really much as if we&amp;rsquo;d said:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [ if     \b &amp;lt;%controls{if}&amp;gt;
    | unless \b &amp;lt;%controls{unless}&amp;gt; 
    | while  \b &amp;lt;%controls{while}&amp;gt;
    | until  \b &amp;lt;%controls{until}&amp;gt; 
    | for    \b &amp;lt;%controls{for}&amp;gt; 
    | loop   \b &amp;lt;%controls{loop}&amp;gt;
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Only it actually works more like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / $k=&amp;lt;{ %controls.prop{keymatch} // /\w+:/ }&amp;gt; &amp;lt;%controls{$k}&amp;gt; /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that in Perl 6 it&amp;rsquo;s perfectly valid to use &lt;code&gt;//&lt;/code&gt; inside an expression embedded in a regex delimited by slashes. That&amp;rsquo;s because a regex is no longer considered a string, so we don&amp;rsquo;t have to find the end of it before we parse it. Since we can parse it in one pass, the expression parser can handle the &lt;code&gt;//&lt;/code&gt; when it gets to it without worrying about the outer slash, and the final slash is recognized as the terminator by the regex parser without having to worry about anything the expression parser saw.&lt;/p&gt;

&lt;p&gt;A bare subroutine call may be used in a regex, provided it starts with &lt;code&gt;&amp;amp;&lt;/code&gt; and uses parentheses around the arguments. The return value of the subroutine is matched literally. The subroutine may have side effects, and may throw an exception to fail.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-defining-your-own-rules-defining-your-own-rules-span&#34;&gt;&lt;span id=&#34;defining your own rules&#34;&gt;Defining Your Own Rules&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Suppose your name is Hugo and you don&amp;rsquo;t like to use &lt;code&gt;!&lt;/code&gt; to negate an assertion. You can define your own assertion like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my rule not (str $rx) { &amp;lt;!&amp;lt;{&amp;quot;&amp;lt;$rx&amp;gt;&amp;quot;}&amp;gt;&amp;gt; }            # define Hugo not
    / &amp;lt;not [a-z]&amp;gt; /     # same as &amp;lt;![a-z]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That rule would be lexically scoped because of the &lt;code&gt;my&lt;/code&gt;. If you think it looks like a &lt;code&gt;sub&lt;/code&gt; declaration, you&amp;rsquo;re right. In fact, it&amp;rsquo;s possible you could even declare it anonymously like a closure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $not = rule (str $rx) { &amp;lt;!&amp;lt;{&amp;quot;&amp;lt;$rx&amp;gt;&amp;quot;}&amp;gt;&amp;gt; };
    / &amp;lt;$not tonight dear&amp;gt; /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But maybe you don&amp;rsquo;t want it lexically scoped because you&amp;rsquo;re writing a grammar for general use:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    grammar HugoGrammar {
         rule not ($rx) { &amp;lt;!$rx&amp;gt; }
         rule identifier { &amp;lt;not before \d&amp;gt; \w+ }
         rule \j { \c[LF] }
         rule parse { ^ &amp;lt;identifier&amp;gt; \j $ }
    }

    HugoGrammar.parse($line);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case a rule is simply a method in a grammar class, and a grammar class is any class derived implicitly or explicitly from the universal RULE grammar class. The built-in regex assertions like &lt;code&gt;&amp;lt;before \w&amp;gt;&lt;/code&gt; are really just calls to methods in the RULE class. The namespace of a grammar is simply the method namespace of the current class, which is the class&amp;rsquo;s methods plus all inherited methods.&lt;/p&gt;

&lt;p&gt;In addition to normal subrules, we allow some funny looking method names like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule :a { ... }
    rule \a { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Modules that mutate Perl&amp;rsquo;s grammar on the fly can do so by deriving an anonymous grammar class from the default Perl6Grammar, and installing extra rules on the fly. The current regex state then continues parsing the rest of the lexical scope using some rule from the new rule set. Subsequent grammatical mutations will be derived from the current anonymous grammar unless you switch explicitly to an entirely different grammar.&lt;/p&gt;

&lt;p&gt;Since we&amp;rsquo;re writing grammar rules as if they were methods, we have access to the full syntax of method declaration, including formal parameter lists and compile-time properties. So we can easily annotate rules with pragmatic information such as operator precedence levels when you don&amp;rsquo;t want to write a strictly recursive-descent parser, for instance. (And we don&amp;rsquo;t want to, for Perl.)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-accepted-rfcs-accepted-rfcs-span&#34;&gt;&lt;span id=&#34;accepted rfcs&#34;&gt;Accepted RFCs&lt;/span&gt;&lt;/h3&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-72-html-id-rfc-072-variablelength-lookbehind-rfc-072-variable-length-lookbehind-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/72.html&#34; id=&#34;rfc 072: variablelength lookbehind.&#34;&gt;RFC 072: Variable-length lookbehind.&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;This seems good to me. It&amp;rsquo;s just a SMOP to reverse the ordering of nodes in the syntax tree, and I think we can pretty well determine when it&amp;rsquo;s impossible to reverse the tree. The operation of a reversed syntax tree will not be totally transparent, however, so it will be necessary to document that quantifiers will actually be working right-to-left rather than left-to-right. (It&amp;rsquo;s probably also a good idea to document that many syntactic constructs can&amp;rsquo;t actually be reliably recognized in reverse. An attempt to do so probably means you needed to do a lookahead earlier, rather than a lookbehind later.)&lt;/p&gt;

&lt;p&gt;The syntax of lookbehind uses the new assertion syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;after ...&amp;gt;         # positive lookbehind
    &amp;lt;!after ...&amp;gt;        # negative lookbehind
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yes, the &lt;code&gt;pos()&lt;/code&gt; function could return multiple values in list context, but I think it&amp;rsquo;s more reasonable for the individual captured elements to know where their positions are. The &lt;code&gt;pos&lt;/code&gt; function is really just a special case of a more general data structure contained in the regex result object from the last successful match. In which case, maybe it really needs to have a better name than &lt;code&gt;pos&lt;/code&gt;. Maybe &lt;code&gt;$0&lt;/code&gt; or something. Then we get &lt;code&gt;$0.beg&lt;/code&gt; and &lt;code&gt;$0.end&lt;/code&gt;, &lt;code&gt;$1.beg&lt;/code&gt;, and &lt;code&gt;$1.end&lt;/code&gt;, etc. Since &lt;code&gt;@$0&lt;/code&gt; returns a list of captures, you can do &lt;code&gt;@$0^.beg&lt;/code&gt; and &lt;code&gt;@$0^.end&lt;/code&gt; if you want a list of beginnings and endings. Did I mention that the magical &lt;code&gt;@+&lt;/code&gt; and &lt;code&gt;@-&lt;/code&gt; arrays are gonna be real dead? Never could remember which one was which anyway&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-93-html-id-rfc-093-regex-support-for-incremental-pattern-matching-rfc-093-regex-support-for-incremental-pattern-matching-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/93.html&#34; id=&#34;rfc 093: regex: support for incremental pattern matching&#34;&gt;RFC 093: Regex: Support for incremental pattern matching&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I don&amp;rsquo;t think this proposal is powerful enough. &amp;ldquo;Infinite&amp;rdquo; strings are a more powerful concept. But I don&amp;rsquo;t think infinite strings are powerful enough either!&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re certainly going to have &amp;ldquo;infinite&amp;rdquo; arrays for which missing elements are defined by a generator (where the action could be as simple as reading more data from some other source). We could do the same thing for strings directly, or we could define strings that are implemented underneath via arrays (of strings or of stringifiable objects), and achieve infinitude that way. This latter approach has the benefit that the array element boundaries could be meaningful as zero-width boundaries between, say, tokens in a token stream. We&amp;rsquo;re thinking that &lt;code&gt;&amp;lt;,&amp;gt;&lt;/code&gt; could match such a boundary.&lt;/p&gt;

&lt;p&gt;But beyond that, such arrays-as-strings could allow us to associate hidden metadata with the tokens, if the abstract string is constructed from a list of objects, or a list of strings with properties. This is typically how a parser would receive data from a lexical analyzer. It&amp;rsquo;s the parser&amp;rsquo;s job to transform the linear stream of objects into a parse tree of objects.&lt;/p&gt;

&lt;p&gt;Matching against such boundaries or metadata would not be possible unless ether the regex engine is aware that it is matching against an array, or the string emulation provides visibility through the abstract string into the underlying array. The latter may be preferable, since (by the rules of the &lt;code&gt;=~&lt;/code&gt; matrix discussed in Apocalypse 4) &lt;code&gt;@array =~ /regex/&lt;/code&gt; is currently interpreted as matching against each element of the array individually rather than sequentially, and there are other uses for a string that&amp;rsquo;s really an array. In fact, &lt;code&gt;@array =~ /regex/&lt;/code&gt; could conceivably be matching against a set of infinite strings in parallel, though that seems a bit scary.&lt;/p&gt;

&lt;p&gt;Even if we don&amp;rsquo;t care about the boundaries between array elements, this approach gives us the ability to read a file in chunks and not worry that the pattern won&amp;rsquo;t match because it happens to span a boundary.&lt;/p&gt;

&lt;p&gt;It might be objected that matching against a subroutine rather than an infinite string or array has the benefit of not promising to keep around the entire string or array in memory. But this is not really a feature, since in general a regex can potentially backtrack all the way to the beginning of the string. And there&amp;rsquo;s nothing to say that the front of the infinite string or array has to stay around anyway. Whether to throw away the head of a string or array should really depend on the programmer, and I don&amp;rsquo;t think there&amp;rsquo;s a more intuitive way to manage that than to simply let the programmer whack off the front of the string or array using operators like &lt;code&gt;substr&lt;/code&gt; or &lt;code&gt;splice&lt;/code&gt;, or the new &lt;code&gt;&amp;lt;cut&amp;gt;&lt;/code&gt; assertion.&lt;/p&gt;

&lt;p&gt;Indeed, the very existence of the string/array precludes the caching problem that RFC 316 complains about.&lt;/p&gt;

&lt;p&gt;The question remains how to declare such a string/array. If we decided to do a magical name identification, we could conceivably declare&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $@array;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then both &lt;code&gt;$array&lt;/code&gt; and &lt;code&gt;@array&lt;/code&gt; refer to the same object, but treated as a string when you say &lt;code&gt;$array&lt;/code&gt; and as an array when you say &lt;code&gt;@array)&lt;/code&gt;. One is tempted to set up the input routine by saying&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $@array is from { &amp;lt;$input&amp;gt; };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Additional lines (or chunks) would then come from the &lt;code&gt;&amp;lt;$input&amp;gt;&lt;/code&gt; iterator.&lt;/p&gt;

&lt;p&gt;But really, the infinite nature of the array is a feature of the underlying object, not the variable. After all, we want to be able to say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @array := 1..Inf;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;even with an ordinary array.&lt;/p&gt;

&lt;p&gt;So we could even make this work:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $@array := &amp;lt;$input&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But I think we need to break the aliasing down, which will give us more flexibility at the expense of more verbiage:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @array := &amp;lt;$input&amp;gt;;              # @array now bound to iterator
    my $array is ArrayString(@array);   # an ordinary tie
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That would let us do cool and/or sick things like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @lines := &amp;lt;$article&amp;gt;;
    my $_ is ArrayString(@lines);

    s/^ .*? \n&amp;lt;2,&amp;gt; //;  # delete header from $_ AND @lines!
    for @lines { ... }  # process remaining lines
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;for&lt;/code&gt; loop potentially runs forever, since &lt;code&gt;@lines&lt;/code&gt; is implicitly extended from an iterator. The array is automatically extended on the end, but it&amp;rsquo;s not automatically shifted on the front. So if you really did want the loop to run forever without exhausting memory, you&amp;rsquo;d need to say something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    substr($_, 0, $_.pos, &amp;quot;&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The same effect can be effected within a regex by asserting &lt;code&gt;&amp;lt;cut&amp;gt;&lt;/code&gt;, which makes the current position the new string beginning. (If you backtrack over &lt;code&gt;&amp;lt;cut&amp;gt;&lt;/code&gt;, the entire match will fail.)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-110-html-id-rfc-110-counting-matches-rfc-110-counting-matches-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/110.html&#34; id=&#34;rfc 110: counting matches&#34;&gt;RFC 110: counting matches&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I think we can avoid using any options if we make a pattern count matches when used in a numeric context. If in doubt, make it explicit:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $count = +/foo/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If it turns out we do need an option, it&amp;rsquo;ll probably be &lt;code&gt;:n&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-112-html-id-rfc-112-assignment-within-a-regex-rfc-112-assignment-within-a-regex-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/112.html&#34; id=&#34;rfc 112: assignment within a regex&#34;&gt;RFC 112: Assignment within a regex&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;This RFC is basically covered by the &lt;code&gt;$foo:=(...)&lt;/code&gt; notation, plus variations. The RFC claims that such assignments are not done till the end, except that they are done ahead of closures. I&amp;rsquo;d rather state it the other way around: it always appears that the current hypothetical binding is assigned if you check, but as long as the optimizer can determine that you aren&amp;rsquo;t looking, it doesn&amp;rsquo;t have to keep up appearances. Contrariwise, if &lt;code&gt;$foo&lt;/code&gt; is just a fancy way of saying &lt;code&gt;$1&lt;/code&gt;, there may in fact be no more overhead in maintaining &lt;code&gt;$foo&lt;/code&gt; than &lt;code&gt;$1&lt;/code&gt;. Either is really just pointing into a table of offsets into the string. That&amp;rsquo;s assuming we get the scoping right on hypothetical variables.&lt;/p&gt;

&lt;p&gt;Some excerpts from the RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The camel and the docs include this example:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       if (/Time: (..):(..):(..)/) {
            $hours = $1;
            $minutes = $2;
            $seconds = $3;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;This then becomes:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      /Time: (?$hours=..):(?$minutes=..):(?$seconds=..)/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      /Time\: $hours:=(..) \: $minutes:=(..) \: $seconds:=(..)/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;It may be appropriate for any assignments made before a code callout to be localized so they can unrolled should the expression finally fail.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Rather than localized (or temporized), they are hypothesized.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The first versions of this RFC did not allow for backrefs. I now think this was a shortcoming. It can be done with &lt;code&gt;(??{quotemeta $foo})&lt;/code&gt;, but I find this clumsy, a better way of using a named back ref might be &lt;code&gt;(?\$foo)&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Backrefs are now unified with hypothetical variables, so the issue doesn&amp;rsquo;t arise. Just use &lt;code&gt;$foo&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Using this method for capturing wanted content, it might be desirable to stop ordinary brackets capturing, and needing to use &lt;code&gt;(?:...)&lt;/code&gt;. I therefore suggest that as an enhancement to regexes that /b (bracket?) ordinary brackets just group, without capture - in effect they all behave as &lt;code&gt;(?:...)&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s no need for a &lt;code&gt;/b&lt;/code&gt; now that we have &lt;code&gt;[...]&lt;/code&gt; for non-capturing brackets.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-144-html-id-rfc-144-behavior-of-empty-regex-should-be-simple-rfc-144-behavior-of-empty-regex-should-be-simple-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/144.html&#34; id=&#34;rfc 144: behavior of empty regex should be simple&#34;&gt;RFC 144: Behavior of empty regex should be simple&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I agree, the behavior should be simple. However, rather than always matching, I propose to make it an error to actually have a null pattern, or a null choice in a list of alternatives. Use an explicit &lt;code&gt;&amp;lt;null&amp;gt;&lt;/code&gt; if that&amp;rsquo;s what you mean. (It&amp;rsquo;s not a problem if &lt;code&gt;$foo&lt;/code&gt; is null in &lt;code&gt;/$foo/&lt;/code&gt;, since variables are now managed by the regex engine and not by interpolation.)&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-150-html-id-rfc-150-extend-regex-syntax-to-provide-for-return-of-a-hash-of-matched-subpatterns-rfc-150-extend-regex-syntax-to-provide-for-return-of-a-hash-of-matched-subpatterns-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/150.html&#34; id=&#34;rfc 150: extend regex syntax to provide for return of a hash of matched subpatterns&#34;&gt;RFC 150: Extend regex syntax to provide for return of a hash of matched subpatterns&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;$foo:=(...)&lt;/code&gt; notation essentially covers that case. One can say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / %hash{foo}:=(...) %hash{bar}:=(...) /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fancier things can be done with closures.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-156-html-id-rfc-156-replace-first-match-function-with-a-flag-to-the-match-command-rfc-156-replace-first-match-function-code-code-with-a-flag-to-the-match-command-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/156.html&#34; id=&#34;rfc 156: replace first match function (...) with a flag to the match command.&#34;&gt;RFC 156: Replace first match function (&lt;code&gt;?&amp;hellip;?&lt;/code&gt;) with a flag to the match command.&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Having a &lt;code&gt;:f&lt;/code&gt; modifier seems like a reasonable way to do it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    m:f/.../
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Though it&amp;rsquo;s vaguely possible we should be having a set of verbs that parse like &lt;code&gt;split&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    split /.../
    count /.../
    first /.../
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s not clear whether those are actually methods, and if so, on which object, the string or the regex. In any event, I don&amp;rsquo;t think we have to nail that down quite yet. I&amp;rsquo;m accepting the basic premise of this RFC that the &lt;code&gt;?...?&lt;/code&gt; construct is going away, one way or another.&lt;/p&gt;

&lt;p&gt;At the moment, it looks like this option is spelled &lt;code&gt;:once&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-165-html-id-rfc-165-allow-variables-in-tr-rfc-165-allow-variables-in-tr-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/165.html&#34; id=&#34;rfc 165: allow variables in tr///&#34;&gt;RFC 165: Allow Variables in tr///&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;If interpolation of patterns by default is wrong, I think extending the &lt;code&gt;tr///&lt;/code&gt; interface via scalar interpolation is doubly wrong. Run-time generated transliterations should be based on mappings that aren&amp;rsquo;t so position dependent. That is, rather than specifying it as two long lists:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    abc12xyz =&amp;gt; ABC34XYZ
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we specify something more like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    abc =&amp;gt; ABC
    12  =&amp;gt; 34
    xyz =&amp;gt; XYZ
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That looks more like a list of pairs of scalars than a pair of scalars. In fact, internally, it&amp;rsquo;s done like a funny parallel substitution:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s:e(/a/A/,
        /b/B/,
        /c/C/,
        /1/3/,
        /2/4/,
        /x/X/,
        /y/Y/,
        /z/Z/)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In any event, it&amp;rsquo;s more like &lt;code&gt;tr/@foo/@bar/&lt;/code&gt; than &lt;code&gt;tr/$foo/$bar/&lt;/code&gt;. But then, why stick with the fake string notation? Why not just say &lt;code&gt;tr(@foo,@bar)&lt;/code&gt; if that&amp;rsquo;s what we mean? Then we&amp;rsquo;re not limited to character substitutions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $string.tr [ &amp;quot; &amp;quot;     , &amp;quot;&amp;lt;&amp;quot;   , &amp;quot;&amp;gt;&amp;quot;   , &amp;quot;\n&amp;quot;   ],
               [ &amp;quot;&amp;amp;nbsp;&amp;quot;, &amp;quot;&amp;amp;lt;&amp;quot;, &amp;quot;&amp;amp;gt;&amp;quot;, &amp;quot;&amp;lt;br&amp;gt;&amp;quot; ];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or how about &lt;code&gt;tr(%trans)&lt;/code&gt;?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %upper = {
        &amp;quot;a-z&amp;quot; =&amp;gt; &amp;quot;A-Z&amp;quot;,
    }
    $string.tr %upper;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or just pair lists of some sort:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $string.tr(&amp;quot;a-c&amp;quot; =&amp;gt; &amp;quot;x-z&amp;quot;,
               &amp;quot;1-2&amp;quot; =&amp;gt; &amp;quot;3-4&amp;quot;,
               &amp;quot;A-C&amp;quot; =&amp;gt; &amp;quot;X-Z&amp;quot;,
              );

    @trans = [
        &amp;quot;a-z&amp;quot; =&amp;gt; &amp;quot;A-Z&amp;quot;,
        @tr_danish,
    ];

    $string.tr(@trans)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-166-html-id-rfc-166-alternative-lists-and-quoting-of-things-rfc-166-alternative-lists-and-quoting-of-things-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/166.html&#34; id=&#34;rfc 166: alternative lists and quoting of things&#34;&gt;RFC 166: Alternative lists and quoting of things&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Alternative lists of literals are included simply by mentioning the array:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /@names/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternative lists of subrules are included with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /&amp;lt;@names&amp;gt;/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s no longer any need for quoting constructs because variables match as literals by default. You have to use angle brackets to get interpretation of a string as a subrule. (But it&amp;rsquo;s still preferable to precompile your regexen.)&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-191-html-id-rfc-191-smart-container-slicing-rfc-191-smart-container-slicing-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/191.html&#34; id=&#34;rfc 191: smart container slicing&#34;&gt;RFC 191: smart container slicing&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;As proposed, this might prevent us from using a regex object as a key to a hash. However, with some tweaking, it&amp;rsquo;ll fit in with how slicing is done in Perl 6.&lt;/p&gt;

&lt;p&gt;Perl 6 will DWIM subscripts based on their appearance. Obviously,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %hash{&amp;quot;foo&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;has a single subscript. And just as obviously,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %hash{&amp;quot;a&amp;quot; .. &amp;quot;z&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;has 26 subscripts or so. In the absence of any scalar guidance, a subscript will be interpreted in list context. So&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %hash{ @array }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will automatically slice on the list of keys in the array. Any function will be called in a list context by default, giving it the opportunity to return multiple values. Perl 6 subscripts are naturally biased toward slicing. To unbias it, here are some of the specifically recognized subscripts:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %hash{&amp;quot;foo&amp;quot;}        # scalar literal
    %hash{bar}          # scalar literal
    %hash{1}            # scalar literal
    %hash{$x}           # scalar variable
    %hash{\$x}          # scalar reference
    %hash{[&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;]}   # array reference
    %hash{{&amp;quot;a&amp;quot; =&amp;gt; &amp;quot;b&amp;quot;}} # hash reference
    %hash{ &amp;quot;a&amp;quot; =&amp;gt; &amp;quot;b&amp;quot; } # pair reference
    %hash{ /pat/ }      # rule reference
    %hash{ _ expr }     # force expr to return a single string
    %hash{ + expr }     # force expr to return a single number
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Boolean expressions and closures look like singular values but cause a match against all possible values of the subscript.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %hash{ ?1 }         # select all subscripts
    %hash{ ?/pat/ }     # select subscripts for which pat matches
    %hash{ $_ =~ /pat/ }# select subscripts for which pat matches
    %hash{ $_ ge &amp;quot;a&amp;quot; }  # select lowercase keys (assuming ASCII)
    %hash{ .ge &amp;quot;a&amp;quot; }    # same thing, maybe
    %hash{ { expr } }   # select subscripts for which closure returns true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Multiple slice subscripts are separated by semicolons, so that you can use commas within each slice subscript for list building. This is more important for multi-dimensional arrays:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @array is dim(9,9,9) = cubic();

    @3d_slice = @array[ @x; @y; @z ];
    @3d_slice = @array[ 0,1,3,8 ; 0,1,3,8; ?1 ];
    @3d_slice = @array[ 0..9 ; 0..9:-1; ?test($_) ];
    @3d_slice = @array[ !($_ % 2) ; 0..9:3; ?test($_) ];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-274-html-id-rfc-274-generalized-additions-to-regexs-rfc-274-generalized-additions-to-regexs-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/274.html&#34; id=&#34;rfc 274: generalized additions to regexs&#34;&gt;RFC 274: Generalized Additions to Regexs&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;This proposal has significant early/late binding issues. A definition that forces run-time overhead is not as useful as it might be. On the other hand, a pure compile-time mechanism is not as general as it might be&amp;ndash;but a compile-time mechanism can always compile in a run-time mechanism if it chooses to defer evaluation.&lt;/p&gt;

&lt;p&gt;So it seems like this is a good place for syntactic warpage of some sort or other. That would make it possible to do both compile-time and run-time bindings. We&amp;rsquo;ll be using the &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; notation for our extensible syntax, and the grammar rules for parsing that particular part of Perl syntax will be just as easy to tweak as any other Perl grammar rule.&lt;/p&gt;

&lt;p&gt;That being said, the very fact that we can associate a grammar with the regex means that it&amp;rsquo;s easy to define any instance of &lt;code&gt;&amp;lt;word&amp;gt;&lt;/code&gt; to mean whatever you want it to. (In a sense, these subrules are the very callbacks that the RFC proposes.) These subrules can be bound either at Perl compile time or at Perl run time. They can be defined to take a string, regex, or Perl expression as an argument. The latter two cases are efficient because they come in as a regex or code reference respectively.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Following on, if (?{&amp;hellip;}) etc code is evaluated in forward match, it would be a good idea to likewise support some code block that is ignored on a forward match but is executed when the code is unwound due to backtracking.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Yes, though hypothetical values take some of the pressure off for this. But if a closure contained a BACK block, it could be automatically fired off on backtracking. As with LAST et al., I suppose there&amp;rsquo;s a corresponding &lt;code&gt;back&lt;/code&gt; property on variables. In a sense, saying&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    let $var = $newval
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is much like saying&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    our $var is back { .set($oldval) } = $newval
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;except that &lt;code&gt;$var&lt;/code&gt; may well be stored in the regex state object rather than in a global symbol table.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-276-html-id-rfc-276-localising-paren-counts-in-qr-s-rfc-276-localising-paren-counts-in-qr-s-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/276.html&#34; id=&#34;rfc 276: localising paren counts in qr()s.&#34;&gt;RFC 276: Localising Paren Counts in qr()s.&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I agree totally. As for the problem of pulling captures out of a subrule, it&amp;rsquo;s up to the subrule to determine what it &amp;ldquo;returns&amp;rdquo;. We could make some intelligent defaults, though different kinds of rules might want different defaults. One approach might be to say that if there is a single capture, that is returned as the result. If there is no capture, it&amp;rsquo;s as if the entire subpattern were captured. If there are multiple captures, they are returned as an anonymous list. So &lt;code&gt;$1&lt;/code&gt; from such a subrule might come through like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / $sub:=&amp;lt;subrule&amp;gt; { print $sub[1] } /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or just:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / &amp;lt;subrule&amp;gt; { print $subrule[1] } /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But named captures and named rules intrude on this idyllic picture. You&amp;rsquo;d also like a default anonymous hash value returned that is keyed by all the named captures or rules. The question is whether that forces numbered captures to come through the hash interface. Or maybe that&amp;rsquo;s just always the case, so to get at &lt;code&gt;$1&lt;/code&gt; of a subrule, you&amp;rsquo;d say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / $sub:=&amp;lt;subrule&amp;gt; { print $sub{&#39;1&#39;} } /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But there are reasons for wanting to treat the result object as an array, so that&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / $sub:=&amp;lt;subrule&amp;gt; { process(@$sub) } /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;processes all the numbered captures from the subrule. So I think the return object behaves either like a hash or an array as appropriate. (Note that such an array might be declared to have an origin at 1 rather than 0.)&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-317-html-id-rfc-317-access-to-optimisation-information-for-regular-expressions-rfc-317-access-to-optimisation-information-for-regular-expressions-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/317.html&#34; id=&#34;rfc 317: access to optimisation information for regular expressions&#34;&gt;RFC 317: Access to optimisation information for regular expressions&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Seems like a no-brainer. All such information is likely to be available to Perl anyway, given that we&amp;rsquo;d like to do the parser, optimizers, and code generators in Perl if at all possible.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-331-html-id-rfc-331-consolidate-the-1-and-1-notations-rfc-331-consolidate-the-code-1-code-and-code-1-code-notations-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/331.html&#34; id=&#34;rfc 331: consolidate the $1 and \1 notations&#34;&gt;RFC 331: Consolidate the &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;\1&lt;/code&gt; notations&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I like the title of this RFC. It fits in with the new &lt;code&gt;my&lt;/code&gt; policy of immediate introduction. However, there are certain difficulties with the proposed implementation. The statement-by-statement setting of the &lt;code&gt;@/&lt;/code&gt; array looks pretty ugly to me. I&amp;rsquo;d rather have a consistent view of hypothetical variables that can live on outside the regex in question without regard to statement boundaries. In the rare event that someone needs to refer to &lt;code&gt;$1&lt;/code&gt; (or anything else) from a prior regex, a temporary variable should be used.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-332-html-id-rfc-332-regex-make-equivalent-to-z-under-the-39-s-39-modifier-rfc-332-regex-make-equivalent-to-z-under-the-s-modifier-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/332.html&#34; id=&#34;rfc 332: regex: make /$/ equivalent to /\z/ under the &amp;#39;/s&amp;#39; modifier&#34;&gt;RFC 332: Regex: Make /$/ equivalent to /\z/ under the &amp;lsquo;/s&amp;rsquo; modifier&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Another RFC that is accepted in principle, but that doesn&amp;rsquo;t go far enough. The &lt;code&gt;/s&lt;/code&gt; modifier is going away, along with &lt;code&gt;/m&lt;/code&gt;. A &lt;code&gt;$&lt;/code&gt; will always mean end-of-string, and &lt;code&gt;$$&lt;/code&gt; will match at the end of any line. (The current process id is now &lt;code&gt;$*PID&lt;/code&gt;, by the way, so there&amp;rsquo;s no conflict there. But how often to you want to write a pattern to match the current process id anyway?)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-348-html-id-rfc-348-regex-assertions-in-plain-perl-code-rfc-348-regex-assertions-in-plain-perl-code-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/348.html&#34; id=&#34;rfc 348: regex assertions in plain perl code&#34;&gt;RFC 348: Regex assertions in plain Perl code&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;This RFC makes some good points, though the code assertion syntax will be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;( code )&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The RFC also makes a case for getting rid of the special behavior of &lt;code&gt;local&lt;/code&gt; in Perl 5, which treated &lt;code&gt;local&lt;/code&gt; differently within a regex. However, something very like the &lt;code&gt;local&lt;/code&gt; behavior will still be needed for making hypotheses, though the RFC is correct that it&amp;rsquo;s not needed in the typical code assertion, In Perl 6, localization is done with &lt;code&gt;temp&lt;/code&gt;, and it will not do the hypothetical variable hack that Perl 5 did. Instead there will be an explicit lvalue modifier, &lt;code&gt;let&lt;/code&gt;, which specifically requests a variable&amp;rsquo;s value to be scoped to the success of the current point in the regex. These hypothetical variables actually have much broader use than this RFC suggests.&lt;/p&gt;

&lt;p&gt;Perl 5&amp;rsquo;s hardwired use of &lt;code&gt;$^R&lt;/code&gt; just translates to an appropriately named hypothetical variable in Perl 6.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-360-html-id-rfc-360-allow-multiply-matched-groups-in-regexes-to-return-a-listref-of-all-matches-rfc-360-allow-multiply-matched-groups-in-regexes-to-return-a-listref-of-all-matches-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/360.html&#34; id=&#34;rfc 360: allow multiply matched groups in regexes to return a listref of all matches&#34;&gt;RFC 360: Allow multiply matched groups in regexes to return a listref of all matches&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I think that parens that can potentially match multiple times will automatically produce a list rather than matching the final one. It&amp;rsquo;s not as if we can&amp;rsquo;t tell whether something&amp;rsquo;s inside a quantifier&amp;hellip;&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the RFC&amp;rsquo;s proposed solution:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    while ($text =~ /name:\s*(.*?)\n\s*
                    children:\s*(?:(?@\S+)[, ]*)*\n\s*
                    favorite\ colors:\s*(?:(?@\S+)[, ]*)*\n/sigx) {
        # now we have:
        #  $1 = &amp;quot;John Abajace&amp;quot;;
        #  $2 = [&amp;quot;Tom&amp;quot;, &amp;quot;Dick&amp;quot;, &amp;quot;Harry&amp;quot;]
        #  $3 = [&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;, &amp;quot;blue&amp;quot;]
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apart from the change in behavior of &lt;code&gt;(...)&lt;/code&gt; within a quantifier, I have the urge to rewrite this example for several reasons:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The C&lt;/x&gt; and C&lt;/s&gt; flags no longer exist.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The C&lt;/i&gt; and C&lt;/g&gt; flags must be pulled out to the front for visibility.
        (And the C&lt;/g&gt; flag is renamed C&amp;lt;:e&amp;gt;).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;There&amp;rsquo;s now a C&amp;lt;\h&amp;gt; for horizontal whitespace, and C&amp;lt;\H&amp;gt; for the negation
        of that.  (Not that RFC is incorrect to use C&amp;lt;\s&amp;gt;.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The negation of C&amp;lt;\n&amp;gt; is now C&amp;lt;\N&amp;gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The C&amp;lt;:&amp;gt; character is now a metacharacter, and so must be backslashed.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Character classes are now represented with C&amp;lt;&amp;lt; &amp;lt;[&amp;hellip;]&amp;gt; &amp;gt;&amp;gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Grouping is now represented with C&amp;lt;[&amp;hellip;]&amp;gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With these changes, and making better use of whitespace, the sample regex ends up looking like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for ($text =~ m:ie[
                            name             \: \h*   (\N*?)            \n
                        \h* children         \: \h* [ (\S+) &amp;lt;[,\h]&amp;gt;* ]* \n
                        \h* favorite\ colors \: \h* [ (\S+) &amp;lt;[,\h]&amp;gt;* ]* \n
                      ]
          )
    {
             # now we have:
             #  $1 = &amp;quot;John Abajace&amp;quot;;
             #  $2 = [&amp;quot;Tom&amp;quot;, &amp;quot;Dick&amp;quot;, &amp;quot;Harry&amp;quot;]
             #  $3 = [&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;, &amp;quot;blue&amp;quot;]
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I think in the long run people will find this more readable once they&amp;rsquo;re used to it. Certainly tabularizing the parallelisms will make any typing errors stand out.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-361-html-id-rfc-361-simplifying-split-rfc-361-simplifying-code-split-code-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/361.html&#34; id=&#34;rfc 361: simplifying split()&#34;&gt;RFC 361: Simplifying &lt;code&gt;split()&lt;/code&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;The RFC makes five suggestions. I&amp;rsquo;ll consider them one by one.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The first argument to split is currently interpreted as a regexp, regardless of whether or not it actually is one. (Yes, &lt;code&gt;split &#39;.&#39;, $foo&lt;/code&gt; doesn&amp;rsquo;t split on dot &amp;ndash; it&amp;rsquo;s currently the same an &lt;code&gt;split /./, $foo&lt;/code&gt;.) I suggest that split be changed to treat only regexps as regexps, and everything else as literals.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Fine, I think. If the first argument to &lt;code&gt;split&lt;/code&gt; is untyped, it should parse correctly, either evaluating a quoted string immediately or deferring interpretation of a regex. One could even do something like split on the first delimiter matched by another pattern:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    split _/(,|;)/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That would split on either all commas or all semicolons, depending on which it found first in the string. The _ forces the regex to return a string, which is whatever was captured by the parens in this case.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Empty trailing fields are currently suppressed (although a -1 as the third argument disables this). I suggest that empty trailing fields be retained by default.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Probably okay, though we need a way to translate old code. It was originally done this way because split on whitespace would typically return an extra field after the newline. But most newlines will be prechomped in Perl 6.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;When not in list context, split currently splits into &lt;code&gt;@_&lt;/code&gt;. I suggest that this side-effect be removed.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Fine. It&amp;rsquo;s easy enough to translate to an explicit assignment.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code&gt;split ?pat?&lt;/code&gt; in any context currently splits into &lt;code&gt;@_&lt;/code&gt;. I suggest that this side-effect be removed.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Fine. I don&amp;rsquo;t think anyone uses that.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code&gt;split &#39; &#39;&lt;/code&gt; (but not &lt;code&gt;split / /&lt;/code&gt;) currently splits on whitespace, but also removes leading empty fields. I suggest that this irregularity be removed.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The question is, what to replace it with, since it&amp;rsquo;s a very handy construct. We could use a different conventional pattern:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @array = split /&amp;lt;ws&amp;gt;/, $string;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or we could say that it&amp;rsquo;s now a split on whitespace only if the split argument is unspecified. That wouldn&amp;rsquo;t work very well with the old syntax, where we often have to supply the second argument. But given that the &lt;code&gt;=~&lt;/code&gt; operator now serves as a topicalizer for any term, we could translate:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @array = split &#39; &#39;, $string;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @array = $string =~ split;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oddly, this probably also works:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $string =~ (@array = split);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or maybe even this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @array = split given $string;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But I think I like the OO notation better here anyway:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @array = $string.split;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, split may not be a function at all. The default split might just be a string method and use unary dot:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @array = .split;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We still have the third argument to deal with, but that&amp;rsquo;s likely to be specified like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @array = $string.split(limit =&amp;gt; 3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We could conceivably make a different method for word splitting, much like REXX does:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @array = .words;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then a limit could be the first argument:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @array = .words(3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But there almost doesn&amp;rsquo;t need to be such a method, since&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @array = m/ [ (\S*) \s* ]* /;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will do the right thing. Admittedly, a &lt;code&gt;.words&lt;/code&gt; method would be much more readable&amp;hellip;&lt;/p&gt;

&lt;p&gt;Fortunately, &lt;code&gt;split&lt;/code&gt; is a function, so I can put off that decision till Apocalypse 29. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-rejected-rfcs-rejected-rfcs-span&#34;&gt;&lt;span id=&#34;rejected rfcs&#34;&gt;Rejected RFCs&lt;/span&gt;&lt;/h3&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-135-html-id-rfc-135-require-explicit-m-on-matches-even-with-and-as-delimiters-rfc-135-require-explicit-m-on-matches-even-with-and-as-delimiters-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/135.html&#34; id=&#34;rfc 135: require explicit m on matches, even with  and // as delimiters.&#34;&gt;RFC 135: Require explicit m on matches, even with ?? and // as delimiters.&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Squish that gnat&amp;hellip; &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A decent Perl parser is still going to have to keep track of whether a term or an operator is expected. And while we&amp;rsquo;re simplifying the grammar in many ways, it&amp;rsquo;s also the case that we&amp;rsquo;re letting users install their own grammar rules to perform syntactic warpage. Besides, people &lt;em&gt;like&lt;/em&gt; to write patterns with &lt;code&gt;/.../&lt;/code&gt;. So rather than impoverishing Perl&amp;rsquo;s syntax artificially, let&amp;rsquo;s make the standard parser more accessible by writing it all in Perl 6 regexes.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-145-html-id-rfc-145-bracematching-for-perl-regular-expressions-rfc-145-brace-matching-for-perl-regular-expressions-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/145.html&#34; id=&#34;rfc 145: bracematching for perl regular expressions&#34;&gt;RFC 145: Brace-matching for Perl Regular Expressions&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Good problem, not-so-good solution from a complexity point of view. I&amp;rsquo;d like to leverage existing character class and backref notations maybe. If there were simply some way to tell a backref to invert any match characters, that might do it. Or maybe reverse them when you remember them, and leave the backref ignorant? (Downside is nested brackets would probably need recursive patterns.)&lt;/p&gt;

&lt;p&gt;Recursion might be advisable anyway&amp;ndash;you can&amp;rsquo;t really pick up the arguments to a function, for instance, without also handling things like quoted strings, which may have different bracketing rules than outside of strings. Certainly matching &lt;code&gt;\&amp;quot;&lt;/code&gt; would be dependent on whether you&amp;rsquo;re inside or outside of a string. Given that recursion is often necessary, I&amp;rsquo;m not sure making this construct recurse itself is all that useful.&lt;/p&gt;

&lt;p&gt;Along the lines of how &lt;code&gt;tr///&lt;/code&gt; works (or ought to work), I think it&amp;rsquo;d be more generally useful to have character remapping facility within a backref generator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (
     &amp;lt;[ \( \[ \{ \&amp;lt; ] =&amp;gt;
      [ \) \] \} \&amp;gt; ]&amp;gt; )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That might match a left bracket of some sort but return the corresponding right bracket as &lt;code&gt;$1&lt;/code&gt;. But maybe we should just use an &amp;ldquo;existing&amp;rdquo; mechanism to translate strings:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my %closing = {
        &#39;[&#39; =&amp;gt; &#39;]&#39;,
        &#39;(&#39; =&amp;gt; &#39;)&#39;,
        &#39;{&#39; =&amp;gt; &#39;}&#39;,
        &#39;&amp;lt;&#39; =&amp;gt; &#39;&amp;gt;&#39;,
    };
    rule balanced {
        &amp;lt;![\[\(\{\&amp;lt;\]\)\}\&amp;gt;]&amp;gt;*  # any non-brackets
        [                       # followed by either
            $                   #   end of string
        |                       # or
            $b := &amp;lt;[[({&amp;lt;]&amp;gt;      #   an opening bracket
            &amp;lt;self&amp;gt;              #   containing a balanced expr
            %closing{$b}        #   followed by corresponding close bracket
            &amp;lt;self&amp;gt;              #   followed by a balanced expr
        ]
     }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-164-html-id-rfc-164-replace-m-s-and-tr-with-match-subst-and-trade-rfc-164-replace-m-s-and-tr-with-match-subst-and-code-trade-code-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/164.html&#34; id=&#34;rfc 164: replace =~, !~, m//, s///, and tr// with match(), subst(), and trade()&#34;&gt;RFC 164: Replace =~, !~, m//, s///, and tr// with match(), subst(), and &lt;code&gt;trade()&lt;/code&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;All operators will have a way to name them, which means it&amp;rsquo;s possible to alias them to any other name. Rearranging the formal order of parameters would be a little harder, however. We need inlining to do that efficiently. Still, now that &lt;code&gt;//&lt;/code&gt; doesn&amp;rsquo;t evaluate in a typeless context, it&amp;rsquo;s relatively straightforward to define a subroutine or method that does&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    subst $string, /foo/, {&amp;quot;bar&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in whatever order you like.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-197-html-id-rfc-197-numeric-value-ranges-in-regular-expressions-rfc-197-numeric-value-ranges-in-regular-expressions-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/197.html&#34; id=&#34;rfc 197: numeric value ranges in regular expressions&#34;&gt;RFC 197: Numeric Value Ranges In Regular Expressions&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;If we go down this road, eventually we reinvent all of Perl syntax in regular expressions. Not that I&amp;rsquo;m against TMTOWTDI, but I&amp;rsquo;d rather have a better way to run Perl code from within a regex and have it &amp;ldquo;succeed&amp;rdquo; or &amp;ldquo;fail&amp;rdquo;, and maybe better ways to test ranges from Perl code. Anything beyond that could be done with syntactic warpage.&lt;/p&gt;

&lt;p&gt;In any event, overloading &lt;code&gt;()&lt;/code&gt; and &lt;code&gt;[]&lt;/code&gt; for this would be mentally treacherous, not to mention completely opaque to non-mathematicians. We&amp;rsquo;ll stick with the standard boolean assertion:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / (\d+) &amp;lt;( $1 =~ 1..10 )&amp;gt; /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Interestingly, that can also be written:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / &amp;lt;( _/\d+/ =~ 1..10 )&amp;gt; /
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-198-html-id-rfc-198-boolean-regexes-rfc-198-boolean-regexes-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/198.html&#34; id=&#34;rfc 198: boolean regexes&#34;&gt;RFC 198: Boolean Regexes&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Again, I&amp;rsquo;m not much in favor of inventing new regex syntax that duplicates ordinary Perl syntax. I think we need richer ways of interconnecting related regexes via ordinary Perl syntax. Certainly it helps to have an easy way to specify a Perl assertion:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / (\w+) &amp;lt;( %count{$1} &amp;gt; 3 )&amp;gt; /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But there&amp;rsquo;s something to be said for forcing submatch assertions to be defined externally to the current regex, much like we discourage inline code where subroutine calls are in order.&lt;/p&gt;

&lt;p&gt;So anyway, I think most of the submatches like onion rings should be handled simply by searching on captured strings within a closure. Booleans can be put into closures as well, but the new &lt;code&gt;::&lt;/code&gt; operator makes it pretty easy to AND and OR assertions together in a more regexly fashion without reinventing the wheel.&lt;/p&gt;

&lt;p&gt;As proposed, there will be a &amp;ldquo;fail&amp;rdquo; token, but it&amp;rsquo;s spelled &lt;code&gt;&amp;lt;fail&amp;gt;&lt;/code&gt;, not &lt;code&gt;\F&lt;/code&gt;. And the &amp;ldquo;true&amp;rdquo; token is spelled &lt;code&gt;&amp;lt;null&amp;gt;&lt;/code&gt;. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-261-html-id-rfc-261-pattern-matching-on-perl-values-rfc-261-pattern-matching-on-perl-values-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/261.html&#34; id=&#34;rfc 261: pattern matching on perl values&#34;&gt;RFC 261: Pattern matching on perl values&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;This reminds me a bit of unification in Prolog. It&amp;rsquo;s not explained very well here, and I&amp;rsquo;m wondering if it will be too hard to explain in general. I think this is probably too powerful a concept for the typical Perl programmer, who is lucky to understand simple lvalues that always do what they&amp;rsquo;re told.&lt;/p&gt;

&lt;p&gt;This sort of matching can probably be provided as syntactic warpage, though I&amp;rsquo;m not sure if that prevents useful optimizations. Anyway, this sort of thing is unlikely to make it into the Perl 6 core unless it generalizes usefully to function argument lists, and it may be too powerful for there too. For that purpose it would resemble a form of overloading, but with the &amp;ldquo;types&amp;rdquo; specified by keys. I suspect real types are more useful.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-308-html-id-rfc-308-ban-perl-hooks-into-regexes-rfc-308-ban-perl-hooks-into-regexes-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/308.html&#34; id=&#34;rfc 308: ban perl hooks into regexes&#34;&gt;RFC 308: Ban Perl hooks into regexes&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;We must be able to call back into Perl code if we want to write parsers conveniently in Perl. Think of how yacc works. Certainly the way that Perl 5 does it is ugly, I&amp;rsquo;ll admit. We can beautify that.&lt;/p&gt;

&lt;p&gt;But the whole point of Perl is to have all the most useful &amp;ldquo;Krakken tentacles&amp;rdquo;. And I don&amp;rsquo;t really care if it makes it hard to put the Perl regex engine into some other language. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-316-html-id-rfc-316-regex-modifier-for-support-of-chunk-processing-and-prefix-matching-rfc-316-regex-modifier-for-support-of-chunk-processing-and-prefix-matching-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/316.html&#34; id=&#34;rfc 316: regex modifier for support of chunk processing and prefix matching&#34;&gt;RFC 316: Regex modifier for support of chunk processing and prefix matching&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Infinite strings (via infinite arrays) seem like a more useful concept. It would be easy for the extension subroutine to fail and produce the results desired in this RFC, but without the necessity of the extra syntax specified by the RFC. A match naturally fails when it gets to the end of its string without finishing the pattern. Incremental matching can also easily be done via infinite strings, and the user interface can be a simple as we like, as long as extension rule is somehow associated with the string in question.&lt;/p&gt;

&lt;p&gt;I think &lt;code&gt;pos()&lt;/code&gt; is rather too low-level a concept for general use. Certainly it needs to be there, but I think we need some way of implying that one regex is a continuation of a previous one, but within some higher-level syntactic construct, so that it&amp;rsquo;s easy to write parsers without invoking &lt;code&gt;pos()&lt;/code&gt; or &lt;code&gt;\g&lt;/code&gt; or &lt;code&gt;/c&lt;/code&gt; all over the place.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-cut-cut-span&#34;&gt;&lt;span id=&#34;&lt;cut&gt;&amp;rdquo;&amp;gt;&lt;code&gt;&amp;lt;cut&amp;gt;&lt;/code&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Well, I could say a lot more, but that&amp;rsquo;s it for this time. I hope you&amp;rsquo;re excited by all this, in a positive sort of way. But if your jaw lost all of its bounce when it hit the table, I expect Damian&amp;rsquo;s upcoming Exegesis 5 will do a better job of showing how this all fits together into a pretty picture.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apocalypse 4</title>
      <link>http://localhost:1313/pub/2002/01/15/apo4.html/</link>
      <pubDate>Tue, 15 Jan 2002 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2002/01/15/apo4.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S04.html&#34;&gt;Synopsis 04&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;header&#34;&gt;&lt;/span&gt;&lt;/strong&gt;
Table of Contents&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;secondary&#34;&gt; &lt;/span&gt;&lt;/strong&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=2#accepted%20rfcs&#34;&gt;Accepted RFCs&lt;/a&gt;
&lt;span class=&#34;smalltext&#34;&gt; &lt;/span&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=2#rfc%20022:%20control%20flow:%20builtin%20switch%20statement&#34;&gt;RFC 022: Control flow: Builtin switch statement&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=2#table%201:%20matching%20a%20switch%20value%20against%20a%20case%20value&#34;&gt;Table 1: Matching a switch value against a case value&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=3#rfc%20088:%20omnibus%20structured%20exception/error%20handling%20mechanism&#34;&gt;RFC 088: Omnibus Structured Exception/Error Handling Mechanism&lt;/a&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=6#rfc%20199:%20shortcircuiting%20builtin%20functions%20and%20userdefined%20subroutines&#34;&gt;RFC 199: Short-circuiting built-in functions and user-defined subroutines&lt;/a&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=6#rfc%20006:%20lexical%20variables%20made%20default&#34;&gt;RFC 006: Lexical variables made default&lt;/a&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=6#rfc%20330:%20global%20dynamic%20variables%20should%20remain%20the%20default&#34;&gt;RFC 330: Global dynamic variables should remain the default&lt;/a&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=6#rfc%20083:%20make%20constants%20look%20like%20variables&#34;&gt;RFC 083: Make constants look like variables&lt;/a&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=6#rfc%20337:%20common%20attribute%20system%20to%20allow%20userdefined,%20extensible%20attributes&#34;&gt;RFC 337: Common attribute system to allow user-defined, extensible attributes&lt;/a&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=7#rfc%20173:%20allow%20multiple%20loop%20variables%20in%20foreach%20statements&#34;&gt;RFC 173: Allow multiple loop variables in foreach statements&lt;/a&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=7#rfc%20019:%20rename%20the%20local%20operator&#34;&gt;RFC 019: Rename the local operator&lt;/a&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=7#rfc%20064:%20new%20pragma%20&amp;#39;scope&amp;#39;%20to%20change%20perl&amp;#39;s%20default%20scoping&#34;&gt;RFC 064: New pragma &#39;scope&#39; to change Perl&#39;s default scoping&lt;/a&gt;
&lt;span class=&#34;secondary&#34;&gt; &lt;strong&gt;&lt;/strong&gt; &lt;/span&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=8#rejected%20rfcs&#34;&gt;Rejected RFCs&lt;/a&gt;
&lt;span class=&#34;smalltext&#34;&gt; &lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=8#rfc%20089:%20controllable%20data%20typing&#34;&gt;RFC 089: Controllable Data Typing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=8#rfc%20106:%20yet%20another%20lexical%20variable%20proposal:%20lexical%20variables%20made%20default&#34;&gt;RFC 106: Yet another lexical variable proposal: lexical variables made default&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=8#rfc%20119:%20object%20neutral%20error%20handling%20via%20exceptions&#34;&gt;RFC 119: Object neutral error handling via exceptions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=8#rfc%20120:%20implicit%20counter%20in%20for%20statements,%20possibly%20$#.&#34;&gt;RFC 120: Implicit counter in for statements, possibly $#.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=8#rfc%20262:%20index%20attribute&#34;&gt;RFC 262: Index Attribute&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=8#rfc%20167:%20simplify%20do%20block%20syntax&#34;&gt;RFC 167: Simplify do BLOCK Syntax&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=8#rfc%20209:%20fuller%20integer%20support%20in%20perl.&#34;&gt;RFC 209: Fuller integer support in Perl.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=8#rfc%20279:%20my()%20syntax%20extensions%20and%20attribute%20declarations&#34;&gt;RFC 279: &lt;code&gt;my()&lt;/code&gt; syntax extensions and attribute declarations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=8#rfc%20297:%20attributes%20for%20compiler%20hints&#34;&gt;RFC 297: Attributes for compiler hints&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=8#rfc%20309:%20allow%20keywords%20in%20sub%20prototypes&#34;&gt;RFC 309: Allow keywords in sub prototypes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=8#rfc%20340:%20with%20takes%20a%20context&#34;&gt;RFC 340: with takes a context&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=8#rfc%20342:%20pascallike%20with&#34;&gt;RFC 342: Pascal-like &amp;quot;with&amp;quot;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;span class=&#34;secondary&#34;&gt; &lt;strong&gt;&lt;/strong&gt; &lt;/span&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=9#withdrawn%20rfcs&#34;&gt;Withdrawn RFCs&lt;/a&gt;
&lt;span class=&#34;smalltext&#34;&gt; &lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=9#rfc%20063:%20exception%20handling%20syntax&#34;&gt;RFC 063: Exception handling syntax&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=9#rfc%20113:%20better%20constants%20and%20constant%20folding&#34;&gt;RFC 113: Better constants and constant folding&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;span class=&#34;secondary&#34;&gt; &lt;strong&gt;&lt;/strong&gt; &lt;/span&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=9#other%20decisions&#34;&gt;Other decisions&lt;/a&gt;
&lt;span class=&#34;smalltext&#34;&gt; &lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=9#cstyle%20for%20loop&#34;&gt;C-style for loop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=9#cstyle%20do%20%7B%7D%20while%20expr%20no%20longer%20supported&#34;&gt;C-style do {} while EXPR no longer supported&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=9#bare%20blocks&#34;&gt;Bare blocks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=9#continue%20block&#34;&gt;continue block&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Â &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;This Apocalypse is all about syntax in the large. The corresponding chapter in the Camel book is entitled &amp;ldquo;Statements and Declarations&amp;rdquo;, but it could just as easily have been entitled, &amp;ldquo;All About Blocks&amp;rdquo;. The basic underlying question is &amp;ldquo;What exactly do those curlies mean?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;For Perl 5 and earlier, the answer to that question was, &amp;ldquo;Too many things&amp;rdquo;. Or rather, too many things with inconsistent rules. We&amp;rsquo;ll continue to use curlies for much of what we&amp;rsquo;ve used them for up till now, but by making a few critical simplifications, the rules will be much more consistent. In particular, built-ins will parse with the same rules as user-defined constructs. It should be possible to make user-extensible syntax look just like built-in syntax. Perl 5 started down this road, but didn&amp;rsquo;t get all the way there. In Perl 6, all blocks operate under the same rules. Effectively, every block is a kind of closure that can be run by user-defined constructs as well as built-ins.&lt;/p&gt;

&lt;p&gt;Associated with block structure are the various constructs that make use of block structure. Compound constructs like loops and conditionals use blocks explicitly, whereas declarations refer to their enclosing block implicitly. This latter feature was also inconsistently applied in Perl 5. In Perl 6, the rule is simple: A lexically scoped declaration is in effect from the declaration to the end of its enclosing block. Since blocks are delimited &lt;em&gt;only&lt;/em&gt; by curlies or by the ends of the current compilation unit (file or string), that implies that we can&amp;rsquo;t allow multi-block constructs in which lexically scoped variables &amp;ldquo;leak&amp;rdquo; or &amp;ldquo;tunnel&amp;rdquo; from the end of one block to the beginning of the next. A right curly (without an intervening left curly) absolutely stops the current lexical scope. This has direct bearing on some of these RFCs. For instance, RFC 88 proposes to let lexical scope leak from a &lt;code&gt;try&lt;/code&gt; block into its corresponding &lt;code&gt;finally&lt;/code&gt; block. This will not be allowed. (We&amp;rsquo;ll find a different way to solve that particular issue.)&lt;/p&gt;

&lt;p&gt;While lexical declarations may not leak out of a block, control flow must be able to leak out of blocks in a controlled fashion. Obviously, falling off the end of a block is the most &amp;ldquo;normal&amp;rdquo; way, but we need to exit blocks in other &amp;ldquo;abnormal&amp;rdquo; ways as well. Perl 5 has several different ways of exiting a block: &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;last&lt;/code&gt;, &lt;code&gt;redo&lt;/code&gt;, and &lt;code&gt;die&lt;/code&gt;, for instance. The problem is that these various keywords are hard-wired to transfer control outward to a particular built-in construct, such as a subroutine definition, a loop, or an &lt;code&gt;eval&lt;/code&gt;. That works against our unifying concept that every block is a closure. In Perl 6, all these abnormal means of block exit are unified under the concept of exceptions. A &lt;code&gt;return&lt;/code&gt; is a funny kind of exception that is trapped by a &lt;code&gt;sub&lt;/code&gt; block. A &lt;code&gt;next&lt;/code&gt; is an exception that is trapped by a loop block. And of course &lt;code&gt;die&lt;/code&gt; creates a &amp;ldquo;normal&amp;rdquo; exception that is trapped by any block that chooses to trap such exceptions. Perl 6 does not require that this block be an &lt;code&gt;eval&lt;/code&gt; or &lt;code&gt;try&lt;/code&gt; block.&lt;/p&gt;

&lt;p&gt;You may think that this generalization implies excessive overhead, since generally exception handling must work its way up the call stack looking for an appropriate handler. But any control flow exception can be optimized away to a &amp;ldquo;goto&amp;rdquo; internally when its target is obvious and there are no user-defined blocks to be exited in between. Most subroutine return and loop control operators will know which subroutine or loop they&amp;rsquo;re exiting from because it&amp;rsquo;ll be obvious from the surrounding lexical scope. However, if the current subroutine contains closures that are being interpreted elsewhere in user-defined functions, it&amp;rsquo;s good to have the general exception mechanism so that all needed cleanup can be automatically accomplished and consistent semantics maintained. That is, we want user-defined closure handlers to stay out of the user&amp;rsquo;s face in the same way that built-ins do. Control flow should pretend to work like the user expects, even when it doesn&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;Here are the RFCs covered in this Apocalypse. PSA stands for &amp;ldquo;problem, solution, acceptance&amp;rdquo;, my private rating of how this RFC will fit into Perl 6. Interestingly, this time I&amp;rsquo;ve rejected more RFCs than I accepted. I must be getting cruel and callous in my old age. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    RFC   PSA    Title
    ---   ---    -----
    006   acc    Lexical variables made default
    019   baa    Rename the C&amp;lt;local&amp;gt; operator
    022   abc    Control flow: Builtin switch statement
    063   rr     Exception handling syntax
    064   bdc    New pragma &#39;scope&#39; to change Perl&#39;s default scoping
    083   aab    Make constants look like variables
    088   bbc    Omnibus Structured Exception/Error Handling Mechanism
    089   cdr    Controllable Data Typing
    106   dbr    Yet another lexical variable proposal: lexical variables made default
    113   rr     Better constants and constant folding
    119   bcr    Object neutral error handling via exceptions
    120   bcr    Implicit counter in for statements, possibly $#   
    167   bcr    Simplify do BLOCK Syntax
    173   bcc    Allow multiple loop variables in foreach statements
    199   abb    Short-circuiting built-in functions and user-defined subroutines
    209   cdr    Fuller integer support in Perl   
    262   cdr    Index Attribute
    279   cdr    my() syntax extensions and attribute declarations
    297   dcr    Attributes for compiler hints
    309   adr    Allow keywords in sub prototypes
    330   acc    Global dynamic variables should remain the default
    337   bcc    Common attribute system to allow user-defined, extensible attributes
    340   dcr    with takes a context
    342   bcr    Pascal-like &amp;quot;with&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S04.html&#34;&gt;Synopsis 04&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-accepted-rfcs-accepted-rfcs-span&#34;&gt;&lt;span id=&#34;accepted rfcs&#34;&gt;Accepted RFCs&lt;/span&gt;&lt;/h3&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;Previous Apocalypses&lt;/p&gt;
&lt;p&gt;â€¢ &lt;a href=&#34;http://localhost:1313/pub/2001/04/02/wall.html&#34;&gt;Apocalypse One&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
â€¢ &lt;a href=&#34;http://localhost:1313/pub/2001/05/03/wall.html&#34;&gt;Apocalypse Two&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
â€¢ &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html&#34;&gt;Apocalypse Three&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Note that, although these RFCs are in the &amp;ldquo;accepted&amp;rdquo; category, most are accepted with major caveats (a &amp;ldquo;&lt;code&gt;c&lt;/code&gt;&amp;rdquo; acceptance rating), or at least some &amp;ldquo;buts&amp;rdquo; (a &amp;ldquo;&lt;code&gt;b&lt;/code&gt;&amp;rdquo; rating). I&amp;rsquo;ll try to list all those caveats here, but where there are systematic changes, I may indicate these generally in this document without attempting to rewrite the RFC in every detail. Those who implement these features must be sensitive to these systematic changes and not just uncritically implement everything the RFC says.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;d like to talk about exceptions first, but before that I have to deal with the switch statement, because I think it&amp;rsquo;s silly not to unify exception handlers with switch statements.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-22-html-id-rfc-022-control-flow-builtin-switch-statement-rfc-022-control-flow-builtin-switch-statement-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/22.html&#34; id=&#34;rfc 022: control flow: builtin switch statement&#34;&gt;RFC 022: Control flow: Builtin switch statement&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Some OO purists say that any time you want to use a switch statement, you ought to make the discriminant of the switch statement into a type, and use method dispatch instead. Fortunately, we are not OO purists here, so forget that argument.&lt;/p&gt;

&lt;p&gt;Another argument against having a switch statement in Perl 6 is that we never had it in the first five versions of Perl. But it would be incorrect to say that we didn&amp;rsquo;t miss it. What actually happened was that every time we started discussing how to add a switch statement, it wasn&amp;rsquo;t obvious how far to go. A switch statement in Perl ought to do more than a switch statement in C (or in most any other language, for that matter). So the fact that we haven&amp;rsquo;t added a switch statement so far says more about how hard it is to design a good one than about how much we wanted a lousy one. Eventually the ever inventive Damian Conway came up with his famous design, with a Perl 5 module as proof of concept, and pretty much everyone agreed that he was on the right track, for some definition of &amp;ldquo;right&amp;rdquo; (and &amp;ldquo;track&amp;rdquo;). This RFC is essentially that design (not surprisingly, since Damian wrote it), so it will be accepted, albeit with several tweaks.&lt;/p&gt;

&lt;p&gt;In the first place, as a quasi-linguist, I loathe the keywords &lt;code&gt;switch&lt;/code&gt; and &lt;code&gt;case&lt;/code&gt;. I would prefer keywords that read better in English. Much as I love verbing nouns, they don&amp;rsquo;t work as well as real verbs or real prepositions when topicalizers are called for. After thrashing over several options with Damian and other folks, we&amp;rsquo;ve settled on using &lt;code&gt;given&lt;/code&gt; instead of &lt;code&gt;switch&lt;/code&gt;, and &lt;code&gt;when&lt;/code&gt; instead of &lt;code&gt;case&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    given EXPR {
        when EXPR { ... }
        when EXPR { ... }
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The other great advantage of using different words is that people won&amp;rsquo;t expect it to work exactly like any other switch statement they may be familiar with.&lt;/p&gt;

&lt;p&gt;That being said, I should point out that it is still called &amp;ldquo;the switch statement&amp;rdquo;, and the individual components are still &amp;ldquo;cases&amp;rdquo;. But you don&amp;rsquo;t have to put &amp;ldquo;switch&amp;rdquo; or &amp;ldquo;case&amp;rdquo; into constant-width font, because they&amp;rsquo;re not keywords.&lt;/p&gt;

&lt;p&gt;Because curlies are so extremely overloaded in Perl 5, I was at first convinced that we would need a separator of some sort between the expression and the block, maybe a &lt;code&gt;:&lt;/code&gt; or &lt;code&gt;=&lt;/code&gt;``&amp;gt; or some such. Otherwise it would be too ambigous to come upon a left curly when expecting an operator&amp;ndash;it would be interpreted as a hash subscript instead. Damian&amp;rsquo;s RFC proposes to require parentheses in certain situations to disambiguate the expression.&lt;/p&gt;

&lt;p&gt;But I&amp;rsquo;ve come to the conclusion that I&amp;rsquo;d rather screw around (a little) with the &amp;ldquo;insignificant whitespace&amp;rdquo; rule than to require an extra unnatural delimiter. If we observe current practice, we note that 99% of the time, when people write a hash subscript they do so without any whitespace before it. And 99% of the time, when they write a block, they do put some whitespace in front of it. So we&amp;rsquo;ll just dwim it using the whitespace. (No, we&amp;rsquo;re not going all the way to whole-hog whitespace dwimmery&amp;ndash;Python will remain the best/worst example of that approach.)&lt;/p&gt;

&lt;p&gt;Subscripts are the only valid use of curlies when an operator is expected. (That is, subscripts are essentially postfix operators.) In contrast, hash composers and blocks are terms, not operators. Therefore, we will make the rule that a left curly that has whitespace in front of it will never be interpreted as a subscript in Perl 6. (If you think this is totally bizarre thing to do, consider that this new approach is actually consistent with how Perl 5 already parses variables within interpolated strings.) If there is any space before the curly, we force it to start a term, not an operator, which means that the curlies in question must delimit either a hash composer or a block. And it&amp;rsquo;s a hash composer only if it contains a &lt;code&gt;=&lt;/code&gt;`&lt;code&gt;&amp;amp;gt; pair constructor at the top level (or an explicit&lt;/code&gt;hash` keyword on the front.) Therefore it&amp;rsquo;s possible to unambiguously terminate an expression by following it with a block, as in the constructs above.&lt;/p&gt;

&lt;p&gt;Interestingly, this one tweak to the whitespace rule also means that we&amp;rsquo;ll be able to simplify the parentheses out of other similar built-in constructs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if $foo { ... }
    elsif $bar { ... }
    else { ... }

    while $more { ... }

    for 1..10 { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I think throwing out two required punctuation characters for one required whitespace is an excellent trade in terms of readability, particularly when it already matches common practice. (You can still put in the parens if you want them, of course, just for old times&amp;rsquo; sake.) This tweak also allows greater flexibility in how user-defined constructs are parsed. If you want to define your own constructs, they should be able to follow the same syntax rules as built-ins.&lt;/p&gt;

&lt;p&gt;By a similar chain of logic (or illogic), I also want to tweak the whitespace rules for the trailing curly. There are severe problems in any C-derived language that allows user-defined constructs containing curlies (as Perl does). Even C doesn&amp;rsquo;t entirely escape the head-scratching puzzle of &amp;ldquo;When do I put a semicolon after a curly?&amp;rdquo; A &lt;code&gt;struct&lt;/code&gt; definition requires a terminating semicolon, for instance, while an &lt;code&gt;if&lt;/code&gt; or a &lt;code&gt;while&lt;/code&gt; doesn&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;In Perl, this problem comes up most often when people say &amp;ldquo;Why do I have to put a semicolon after &lt;code&gt;do {}&lt;/code&gt; or &lt;code&gt;eval {}&lt;/code&gt; when it looks like a complete statement?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Well, in Perl 6, you don&amp;rsquo;t, if the final curly is on a line by itself. That is, if you use an expression block as if it were a statement block, it behaves as one. The win is that these rules are consistent across all expression blocks, whether user-defined or built-in. Any expression block construct can be treated as either a statement or a component of an expression. Here&amp;rsquo;s a block that is being treated as a term in an expression:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $x = do {
        ...
    } + 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, if you write&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $x = do {
        ...
    }
    + 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then the + will be taken erroneously as the start of a new statement. (So don&amp;rsquo;t do that.)&lt;/p&gt;

&lt;p&gt;Note that this special rule only applies to constructs that take a block (that is, a closure) as their last (or only) argument. Operators like &lt;code&gt;sort&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt; are unaffected. However, certain constructs that used to be in the statement class may become expression constructs in Perl 6. For instance, if we change &lt;code&gt;BEGIN&lt;/code&gt; to an expression construct we can now use a &lt;code&gt;BEGIN&lt;/code&gt; block inside an expression to force compile-time evaluation of a non-static expression:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $value = BEGIN { call_me_once() } + call_me_again();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the other hand, a one-line &lt;code&gt;BEGIN&lt;/code&gt; would then have to have a semicolon.&lt;/p&gt;

&lt;p&gt;Anyway, back to switch statements. Damian&amp;rsquo;s RFC proposes various specific kinds of dwimmery, and while some of those dwims are spot on, others may need adjustment. In particular, there is an assumption that the programmer will know when they&amp;rsquo;re dealing with an object reference and when they&amp;rsquo;re not. But everything will be an object reference in Perl 6, at some level or other. The underlying characteristics of any object are most generally determined by the answer to the question, &amp;ldquo;What methods does this object respond to?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Unfortunately, that&amp;rsquo;s a run-time question in general. But in specific, we&amp;rsquo;d like to be able to optimize many of these switch statements at compile time. So it may be necessary to supply typological hints in some cases to do the dwimmery efficiently. Fortunately, most cases are still fairly straightforward. A &lt;code&gt;1&lt;/code&gt; is obviously a number, and a &lt;code&gt;&amp;quot;foo&amp;quot;&lt;/code&gt; is obviously a string. But unary &lt;code&gt;+&lt;/code&gt; can force anything to a number, and unary &lt;code&gt;_&lt;/code&gt; can force anything to a string. Unary &lt;code&gt;?&lt;/code&gt; can force a boolean, and unary &lt;code&gt;.&lt;/code&gt; can force a method call. More complicated thoughts can be represented with closure blocks.&lt;/p&gt;

&lt;p&gt;Another thing that needs adjustment is that the concept of &amp;ldquo;isa&amp;rdquo; matching seems to be missing, or at least difficult to express. We need good &amp;ldquo;isa&amp;rdquo; matching to implement good exception handling in terms of the switch mechanism. This means that we need to be able to say something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    given $! {
        when Error::Overflow { ... }
        when Error::Type { ... }
        when Error::ENOTTY { ... }
        when /divide by 0/ { ... }
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and expect it to check &lt;code&gt;$!.isa(Error::Overflow)&lt;/code&gt; and such, along with more normal pattern matching. In the case of the actual exception mechanism, we won&amp;rsquo;t use the keyword &lt;code&gt;given&lt;/code&gt;, but rather &lt;code&gt;CATCH&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    CATCH {
        when Error::Overflow { ... }
        when Error::Type { ... }
        when Error::ENOTTY { ... }
        when /divide by 0/ { ... }
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;CATCH&lt;/code&gt; is a &lt;code&gt;BEGIN&lt;/code&gt;-like block that can turn any block into a &amp;ldquo;try&amp;rdquo; block from the inside out. But the insides of the &lt;code&gt;CATCH&lt;/code&gt; are an ordinary switch statement, where the discriminant is simply the current exception object, &lt;code&gt;$!&lt;/code&gt;. More on that later&amp;ndash;see RFC 88 below.&lt;/p&gt;

&lt;p&gt;Some of you may recall that I&amp;rsquo;ve stated that Perl 6 will have no barewords. That&amp;rsquo;s still the case. A token like &lt;code&gt;Error::Overflow&lt;/code&gt; is not a bareword because it&amp;rsquo;s a declared class. Perl 6 recognizes package names as symbolic tokens. So when you call a class method as &lt;code&gt;Class::Name.method()&lt;/code&gt;, the &lt;code&gt;Class::Name&lt;/code&gt; is actually a class object (that just happens to stringify to &amp;ldquo;&lt;code&gt;Class::Name&lt;/code&gt;&amp;rdquo;). But the class method can be called without a symbolic lookup on the package name at run time, unlike in Perl 5.&lt;/p&gt;

&lt;p&gt;Since &lt;code&gt;Error::Overflow&lt;/code&gt; is just such a class object, it can be distinguished from other kinds of objects in a switch statement, and an &amp;ldquo;isa&amp;rdquo; can be inferred. It would be nice if we could go as far as to say that any object can be called with any class name as a method name to determine whether it &amp;ldquo;isa&amp;rdquo; member of that class, but that could interfere with use of class name methods to implement casting or construction. So instead, since switch statements are into heavy dwimmery anyway, I think the switch statement will have to recognize any &lt;code&gt;Class::Name&lt;/code&gt; known at compile time, and force it to call &lt;code&gt;$!.isa(Class::Name)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Another possible adjustment will involve the use of switch statements as a means of parallelizing regular expression evaluation. Specifically, we want to be able to write parsers easily in Perl, which means that we need some way of matching a token stream against something like a set of regular expressions. You can think of a token stream as a funny kind of string. So if the &amp;ldquo;given&amp;rdquo; of a switch statement is a token stream, the regular expressions matched against it may have special abilities relating to the current parse&amp;rsquo;s data structure. All the regular expressions of such a switch statement will likely be implicitly anchored to the current parse location, for instance. There may be special tokens referring to terminals and non-terminals. Basically, think of something like a yacc grammar, where alternative pattern/action grammar rules are most naturally expressed via switch statement cases. More on that in the next Apocalypse.&lt;/p&gt;

&lt;p&gt;Another possible adjustment is that the proposed &lt;code&gt;else&lt;/code&gt; block could be considered unnecessary. The code following the final &lt;code&gt;when&lt;/code&gt; is automatically an &amp;ldquo;else&amp;rdquo;. Here&amp;rsquo;s a duodecimal digit converter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $result = given $digit {
        when &amp;quot;T&amp;quot; { 10 }
        when &amp;quot;E&amp;quot; { 11 }
        $digit;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nevertheless, it&amp;rsquo;s probably good documentation to line up all the blocks, which means it would be good to have a keyword. However, for reasons that will become clearer when we talk about exception handlers, I don&amp;rsquo;t want to use &lt;code&gt;else&lt;/code&gt;. Also, because of the identification of &lt;code&gt;when&lt;/code&gt; and &lt;code&gt;if&lt;/code&gt;, it would not be clear whether an &lt;code&gt;else&lt;/code&gt; should automatically supply a &lt;code&gt;break&lt;/code&gt; at the end of its block as the ordinary &lt;code&gt;when&lt;/code&gt; case does.&lt;/p&gt;

&lt;p&gt;So instead of &lt;code&gt;else&lt;/code&gt;, I&amp;rsquo;d like to borrow a bit more from C and use &lt;code&gt;default&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $result = given $digit {
        when &amp;quot;T&amp;quot; { 10 }
        when &amp;quot;E&amp;quot; { 11 }
        default  { $digit }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unlike in C, the &lt;code&gt;default&lt;/code&gt; case must come last, since Perl&amp;rsquo;s cases are evaluated (or at least pretend to be evaluated) in order. The optimizer can often determine which cases can be jumped to directly, but in cases where that can&amp;rsquo;t be determined, the cases are evaluated in order much like cascaded &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;elsif&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; conditions. Also, it&amp;rsquo;s allowed to intersperse ordinary code between the cases, in which case the code must be executed only if the cases above it fail to match. For example, this should work as indicated by the print statements:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    given $given {
        print &amp;quot;about to check $first&amp;quot;;
        when $first { ... }
        print &amp;quot;didn&#39;t match $first; let&#39;s try $next&amp;quot;;
        when $next { ... }
        print &amp;quot;giving up&amp;quot;;
        default { ... }
        die &amp;quot;panic: shouldn&#39;t see this&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can still define &lt;code&gt;when&lt;/code&gt; as a variant of &lt;code&gt;if&lt;/code&gt;, which makes it possible to intermix the two constructs when (or if) that is desirable. So we&amp;rsquo;ll leave that identity in&amp;ndash;it always helps people think about it when you can define a less familiar construct in terms of a more familiar one. However, the &lt;code&gt;default&lt;/code&gt; isn&amp;rsquo;t quite the same as an &lt;code&gt;else&lt;/code&gt;, since &lt;code&gt;else&lt;/code&gt; can&amp;rsquo;t stand on its own. A &lt;code&gt;default&lt;/code&gt; is more like an &lt;code&gt;if&lt;/code&gt; that&amp;rsquo;s always true. So the above code is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    given $given {
        print &amp;quot;about to check $first&amp;quot;;
        if $given =~ $first { ...; break }
        print &amp;quot;didn&#39;t match $first; let&#39;s try $next&amp;quot;;
        if $given =~ $next { ...; break }
        print &amp;quot;giving up&amp;quot;;
        if 1 { ...; break; }
        die &amp;quot;panic: shouldn&#39;t see this&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We do need to rewrite the relationship table in the RFC to handle some of the tweaks and simplifications we&amp;rsquo;ve mentioned. The comparison of bare refs goes away. It wasn&amp;rsquo;t terribly useful in the first place, since it only worked for scalar refs. (To match identities we&amp;rsquo;ll need an explicit &lt;code&gt;.id&lt;/code&gt; method in any event. We won&amp;rsquo;t be relying on the default numify or stringify methods to produce unique representations.)&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve rearranged the table to be applied in order, so that default interpretations come later. Also, the &amp;ldquo;Matching Code&amp;rdquo; column in the RFC gave alternatives that aren&amp;rsquo;t resolved. In these cases I&amp;rsquo;ve chosen the &amp;ldquo;true&amp;rdquo; definition rather than the &amp;ldquo;exists&amp;rdquo; or &amp;ldquo;defined&amp;rdquo; definition. (Except for certain set manipulations with hashes, people really shouldn&amp;rsquo;t be using the defined/undefined distinction to represent true and false, since both true and false are considered defined concepts in Perl.)&lt;/p&gt;

&lt;p&gt;Some of the table entries distinguish an array from a list. Arrays look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    when [1, 3, 5, 7, 9] { &amp;quot;odd digit intersection&amp;quot; }
    when @array          { &amp;quot;array intersection&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;while a list looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    when 1, 3, 5, 7, 9    { &amp;quot;odd digit&amp;quot; }
    when @foo, @bar, @baz { &amp;quot;intersection with at least one array&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ordinarily lists and arrays would mean the same thing in scalar context, but &lt;code&gt;when&lt;/code&gt; is special in differentiating explicit arrays from lists. Within a &lt;code&gt;when&lt;/code&gt;, a list is a recursive disjunction. That is, the comma-separated values are treated as individual cases OR-ed together. We could use some other explicit notation for disjunction such as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    when any(1, 3, 5, 7, 9) { &amp;quot;odd&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But that seems a lot of trouble for a very common case of case, as it were. We could use vertical bars as some languages do, but I think the comma reads better.&lt;/p&gt;

&lt;p&gt;Anyway, here&amp;rsquo;s another simplification. The following table will &lt;em&gt;also&lt;/em&gt; define how the Perl 6 &lt;code&gt;=~&lt;/code&gt; operator works! That allows us to use a recursive definition to handle matching against a disjunctive list of cases. (See the first entry in the table below.) Of course, for precedence reasons, to match a list of things using &lt;code&gt;=~&lt;/code&gt; you&amp;rsquo;ll have to use parens:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $digit =~ (1, 3, 5, 7, 9) and print &amp;quot;That&#39;s odd!&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternatively, you can look at this table as the definition of the &lt;code&gt;=~&lt;/code&gt; operator, and then say that the switch statement is defined in terms of &lt;code&gt;=~&lt;/code&gt;. That is, for any switch statement of the form&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    given EXPR1 {
        when EXPR2 { ... }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it&amp;rsquo;s equivalent to saying this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for (scalar(EXPR1)) {
        if ($_ =~ (EXPR2)) { ... }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-table-1-matching-a-switch-value-against-a-case-value-table-1-matching-a-switch-value-against-a-case-value-span&#34;&gt;&lt;span id=&#34;table 1: matching a switch value against a case value&#34;&gt;Table 1: Matching a switch value against a case value&lt;/span&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;    $a      $b        Type of Match Implied    Matching Code
    ======  =====     =====================    =============

    expr    list      recursive disjunction    match if $a =~ any($b)
    list    list      recursive disjunction*   match if any($a) =~ any($b)

    hash    sub(%)    hash sub truth           match if $b(%$a)
    array   sub(@)    array sub truth          match if $b(@$a)
    expr    sub($)    scalar sub truth         match if $b($a)
    expr    sub()     simple closure truth*    match if $b()

    hash    hash      hash key intersection*   match if grep exists $a{$_}, $b.keys
    hash    array     hash value slice truth   match if grep {$a{$_}} @$b
    hash    regex     hash key grep            match if grep /$b/, keys %$a
    hash    scalar    hash entry truth         match if $a{$b}

    array   array     array intersection*      match if any(@$a) =~ any(@$b)
    array   regex     array grep               match if grep /$b/, @$a
    array   number    array entry truth        match if $a[$b]
    array   expr      array as list            match if any($a) =~ $b

    object  class     class membership         match if $a.isa($b)
    object  method    method truth             match if $a.$b()

    expr    regex     pattern match            match if $a =~ /$b/
    expr    subst     substitution match       match if $a =~ subst
    expr    number    numeric equality         match if $a == $b
    expr    string    string equality          match if $a eq $b
    expr    boolean   simple expression truth* match if $b
    expr    undef     undefined                match unless defined $a

    expr    expr      run-time guessing        match if ($a =~ $b) at runtime
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to facilitate optimizations, these distinctions are made syntactically at compile time whenever possible. For each comparison, the reverse comparison is also implied, so &lt;code&gt;$a&lt;/code&gt;/&lt;code&gt;$b&lt;/code&gt; can be thought of as either given/when or when/given. (We don&amp;rsquo;t reverse the matches marked with * are because it doesn&amp;rsquo;t make sense in those casees.)&lt;/p&gt;

&lt;p&gt;If type of match cannot be determined at compile time, the default is to try to apply the very same rules in the very same order at run time, using the actual types of the arguments, not their compile-time type appearance. Note that there are no run-time types corresponding to &amp;ldquo;method&amp;rdquo; or &amp;ldquo;boolean&amp;rdquo;. Either of those notions can be expressed at runtime as a closure, of course.&lt;/p&gt;

&lt;p&gt;In fact, whenever the default behavior is not what you intend, there are ways to force the arguments to be treated as you intend:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Intent      Natural           Forced
    ======      =======           ======
    array       @foo              [list] or @{expr}
    hash        %bar              {pairlist} or %{expr}
    sub(%)      { %^foo.aaa }     sub (%foo) { ... }
    sub(@)      { @^bar.bbb }     sub (@bar) { ... }
    sub($)      { $^baz.ccc }     sub ($baz) { ... }
    number      numeric literal   +expr int(expr) num(expr)
    string      string literal    _expr str(expr)
    regex       //, m//, qr//     /$(expr)/
    method      .foo(args)        { $_.$method(args) }
    boolean     $a == $b          ?expr or true expr or { expr }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A method must be written with a unary dot to distinguish it from other forms. The method may have arguments. In essence, when you write&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    .foo(1,2,3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it is treated as if you wrote&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    { $_.foo(1,2,3) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then the closure is evaluated for its truth.&lt;/p&gt;

&lt;p&gt;A class match works only if the class name is known at compile time. Use &lt;code&gt;.isa(&amp;quot;Class&amp;quot;)&lt;/code&gt; for more complicated situations.&lt;/p&gt;

&lt;p&gt;Boolean expressions are recognized at compile time by the presence of a top-level operator that is a comparison or logical operator. As the table shows, an argumentless closure (a &lt;code&gt;sub ()&lt;/code&gt;, that is) also functions as a boolean. However, it&amp;rsquo;s probably better documentation to use the &lt;code&gt;true&lt;/code&gt; function, which does the opposite of &lt;code&gt;not&lt;/code&gt;. (Or the unary &lt;code&gt;?&lt;/code&gt; operator, which does the opposite of unary &lt;code&gt;!&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;It might be argued that boolean expressions have no place here at all, and that you should use &lt;code&gt;if&lt;/code&gt; if that&amp;rsquo;s what you mean. (Or use a &lt;code&gt;sub()&lt;/code&gt; closure to force it to ignore the given.) However, the &amp;ldquo;comb&amp;rdquo; structure of a switch is an extremely readable way to write even ordinary boolean expressions, and rather than forcing people to write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    anyblock {
        when { $a == 1 } { ... }
        when { $b == 2 } { ... }
        when { $c == 3 } { ... }
        default          { ... }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;d rather they be able to write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    anyblock {
        when $a == 1 { ... }
        when $b == 2 { ... }
        when $c == 3 { ... }
        default      { ... }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This also fits better into the use of &amp;ldquo;when&amp;rdquo; within &lt;code&gt;CATCH&lt;/code&gt; blocks:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    CATCH {
        when $!.tag eq &amp;quot;foo&amp;quot; { ... }
        when $!.tag eq &amp;quot;bar&amp;quot; { ... }
        default              { die }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To force all the &lt;code&gt;when&lt;/code&gt; clauses to be interpreted as booleans without using a boolean operator on every case, simply provide an empty given, to be read as &amp;ldquo;given nothing&amp;hellip;&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    given () {
        when $a.isa(Ant) { ... }
        when $b.isa(Bat) { ... }
        when $c.isa(Cat) { ... }
        default          { ... }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;when&lt;/code&gt; can be used by other topicalizers than just &lt;code&gt;given&lt;/code&gt;. Just as &lt;code&gt;CATCH&lt;/code&gt; will imply a given of &lt;code&gt;$!&lt;/code&gt;, a &lt;code&gt;for&lt;/code&gt; loop (the &lt;code&gt;foreach&lt;/code&gt; variety) will also imply a given of the loop variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @foo {
        when 1   { ... }
        when 2   { ... }
        when &amp;quot;x&amp;quot; { ... }
        default  { ... }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By symmetry, a &lt;code&gt;given&lt;/code&gt; will by default alias &lt;code&gt;$_&lt;/code&gt; to the &amp;ldquo;given&amp;rdquo;. Basically, the only difference between a &lt;code&gt;given&lt;/code&gt; and a &lt;code&gt;for&lt;/code&gt; is that a &lt;code&gt;given&lt;/code&gt; takes a scalar expression, while a &lt;code&gt;for&lt;/code&gt; takes a pre-flattened list and iterates over it.&lt;/p&gt;

&lt;p&gt;Suppose you want to preserve &lt;code&gt;$_&lt;/code&gt; and alias &lt;code&gt;$g&lt;/code&gt; to the value instead. You can say that like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    given $value -&amp;gt; $g {
        when 1 { /foo/ }
        when 2 { /bar/ }
        when 3 { /baz/ }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the same way, a loop&amp;rsquo;s values can be aliased to one or more loop variables.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @foo -&amp;gt; $a, $b {  # two at a time
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That works a lot like the definition of a subroutine call with two formal parameters, &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt;. (In fact, that&amp;rsquo;s precisely what it is.) You can use modifiers on the formal paramaters just as you would in a subroutine type signature. This implies that the aliases are automatically declared as &lt;code&gt;my&lt;/code&gt; variables. It also implies that you can modify the formal parameter with an &lt;code&gt;rw&lt;/code&gt; property, which allows you to modify the original elements of the array through the variable. The default loop:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @foo { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is really compiled down to this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @foo -&amp;gt; $_ is rw { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since &lt;code&gt;for&lt;/code&gt; and &lt;code&gt;given&lt;/code&gt; work by passing arguments to a closure, it&amp;rsquo;s a small step to generalize that in the other direction. Any method definition is a topicalizer within the body of the method, and will assume a &amp;ldquo;given&amp;rdquo; of its &lt;code&gt;$self&lt;/code&gt; object (or whatever you have named it). Bare closures topicalize their first argument, implicitly aliasing it to &lt;code&gt;$_&lt;/code&gt; unless &lt;code&gt;$^a&lt;/code&gt; or some such is used. That is, if you say this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    grep { $_ eq 3 } @list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it&amp;rsquo;s equivalent to this more explicit use of a curried function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    grep { $^a eq 3 } @list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But even a &lt;code&gt;grep&lt;/code&gt; can use the aliasing syntax above:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    grep -&amp;gt; $x { $x eq 3 } @list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Outside the scope of any topicalizer, a &lt;code&gt;when&lt;/code&gt; will assume that its given was stored in &lt;code&gt;$_&lt;/code&gt; and will test implicitly against that variable. This allows you to use &lt;code&gt;when&lt;/code&gt; in your main loop, for instance, even if that main loop was supplied by Perl&amp;rsquo;s &lt;code&gt;-n&lt;/code&gt; or &lt;code&gt;-p&lt;/code&gt; switch. Whenever a loop is functioning as a switch, the break implied by finishing a case functions as a &lt;code&gt;next&lt;/code&gt;, not a &lt;code&gt;last&lt;/code&gt;. Use &lt;code&gt;last&lt;/code&gt; if that&amp;rsquo;s what you mean.&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;when&lt;/code&gt; is the only defaulting construct that pays attention to the current topicalizer regardless of which variable it is associated with. All other defaulting constructs pay attention to a fixed variable, typically &lt;code&gt;$_&lt;/code&gt;. So be careful what you&amp;rsquo;re matching against if the given is aliased to something other than &lt;code&gt;$_&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $_ = &amp;quot;foo&amp;quot;;
    given &amp;quot;bar&amp;quot; -&amp;gt; $f {
        if /foo/   { ... } # true, matches against $_
        when /bar/ { ... } # true, matches against $f
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oh, one other tweak. The RFC proposes to overload &lt;code&gt;next&lt;/code&gt; to mean &amp;ldquo;fall through to the next case&amp;rdquo;. I don&amp;rsquo;t think this is wise, since we&amp;rsquo;ll often want to use loop controls within a switch statement. Instead, I think we should use &lt;code&gt;skip&lt;/code&gt; to do that. (To be read as &amp;ldquo;Skip to the next statement.&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;Similarly, if we make a word to mean to explicitly break out of a topicalizer, it should not be &lt;code&gt;last&lt;/code&gt;. I&amp;rsquo;d suggest &lt;code&gt;break&lt;/code&gt;! It will, of course, be unnecessary to break out of the end of a &lt;code&gt;when&lt;/code&gt; case because the &lt;code&gt;break&lt;/code&gt; is implied. However, there are times when you might want to break out of a &lt;code&gt;when&lt;/code&gt; block early. Also, since we&amp;rsquo;re allowing &lt;code&gt;when&lt;/code&gt; modifiers that do not implicitly break, we could use an explicit break for that situation. You might see cases like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    given $x {
        warn(&amp;quot;Odd value&amp;quot;)        when !/xxx/;
        warn(&amp;quot;No value&amp;quot;), break  when undef;

        when /aaa/ { break when 1; ... }
        when /bbb/ { break when 2; ... }
        when /ccc/ { break when 3; ... }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So it looks to me like we need a break.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S04.html&#34;&gt;Synopsis 04&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-88-html-id-rfc-088-omnibus-structured-exception-error-handling-mechanism-rfc-088-omnibus-structured-exception-error-handling-mechanism-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/88.html&#34; id=&#34;rfc 088: omnibus structured exception/error handling mechanism&#34;&gt;RFC 088: Omnibus Structured Exception/Error Handling Mechanism&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;This RFC posits some requirements for exception handling (all of which I agree with), but I do have some additional requirements of my own:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The exception-catching syntax must be considered a form of switch statement.&lt;/li&gt;
&lt;li&gt;It should be easy to turn any kind of block into a &amp;ldquo;try&amp;rdquo; block, especially a subroutine.&lt;/li&gt;
&lt;li&gt;Even &lt;code&gt;try&lt;/code&gt;-less try blocks must also be able to specify mandatory cleanup on exit.&lt;/li&gt;
&lt;li&gt;It should be relatively easy to determine how much cleanup is necessary regardless of how a block was exited.&lt;/li&gt;
&lt;li&gt;It must be possible to base the operation of &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;next&lt;/code&gt;, and &lt;code&gt;last&lt;/code&gt; on exception handling.&lt;/li&gt;
&lt;li&gt;The cleanup mechanism should mesh nicely with the notions of post condition processing under design-by-contract.&lt;/li&gt;
&lt;li&gt;The exception-trapping syntax must not violate encapsulation of lexical scopes.&lt;/li&gt;
&lt;li&gt;At the same time, the exception-trapping syntax should not force declarations out of their natural scope.&lt;/li&gt;
&lt;li&gt;Non-linear control flow must stand out visually, making good use of block structure, indentation and even keyword case. &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;END&lt;/code&gt; blocks are to be considered prior art.&lt;/li&gt;
&lt;li&gt;Non-yet-thrown exceptions must be a useful concept.&lt;/li&gt;
&lt;li&gt;Compatibility with the syntax of any other language is specifically NOT a goal.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;RFC 88 is massive, weighing in at more than 2400 lines. Annotating the entire RFC would make this Apocalypse far too big. (&amp;ldquo;Too late!&amp;rdquo; says Damian.) Nonetheless, I will take the approach of quoting various bits of the RFC and recasting those bits to work with my additional requirements. Hopefully this will convey my tweaks most succinctly.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s what the RFC gives as its first example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    exception &#39;Alarm&#39;;

    try {
        throw Alarm &amp;quot;a message&amp;quot;, tag =&amp;gt; &amp;quot;ABC.1234&amp;quot;, ... ;
        }

    catch Alarm =&amp;gt; { ... }

    catch Error::DB, Error::IO =&amp;gt; { ... }

    catch $@ =~ /divide by 0/ =&amp;gt; { ... }

    catch { ... }

    finally { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s how I see that being written in Perl 6:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my class X::Alarm is Exception { }     # inner class syntax?

    try {
        throw X::Alarm &amp;quot;a message&amp;quot;, tag =&amp;gt; &amp;quot;ABC.1234&amp;quot;, ... ;

        CATCH {
            when X::Alarm             { ... }
            when Error::DB, Error::IO { ... }
            when /divide by 0/        { ... }
            default                   { ... }
        }
        POST { ... }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The outer block does not have to be a &lt;code&gt;try&lt;/code&gt; block. It could be a subroutine, a loop, or any other kind of block, including an &lt;code&gt;eval&lt;/code&gt; string or an entire file. We will call such an outer block a try block, whether or not there is an explicit &lt;code&gt;try&lt;/code&gt; keyword.&lt;/p&gt;

&lt;p&gt;The biggest change is that the various handlers are moved inside of the try block. In fact, the &lt;code&gt;try&lt;/code&gt; keyword itself is mere documentation in our example, since the presence of a &lt;code&gt;CATCH&lt;/code&gt; or &lt;code&gt;POST&lt;/code&gt; block is sufficient to signal the need for trapping. Note that the &lt;code&gt;POST&lt;/code&gt; block is completely independent of the &lt;code&gt;CATCH&lt;/code&gt; block. (The &lt;code&gt;POST&lt;/code&gt; block has a corresponding &lt;code&gt;PRE&lt;/code&gt; block for design-by-contract programmers.) Any of these blocks may be placed anywhere in the surrounding block&amp;ndash;they are independent of the surrounding control flow. (They do have to follow any declarations they refer to, of course.) Only one &lt;code&gt;CATCH&lt;/code&gt; is allowed, but any number of &lt;code&gt;PRE&lt;/code&gt; and &lt;code&gt;POST&lt;/code&gt; blocks. (In fact, we may well encourage ourselves to place &lt;code&gt;POST&lt;/code&gt; blocks near the constructors to be cleaned up after.) &lt;code&gt;PRE&lt;/code&gt; blocks within a particular try block are evaluated in order before anything else in the block. &lt;code&gt;POST&lt;/code&gt; blocks will be evaluated in reverse order, though order dependencies between &lt;code&gt;POST&lt;/code&gt; blocks are discouraged. &lt;code&gt;POST&lt;/code&gt; blocks are evaluated after everything else in the block, including any &lt;code&gt;CATCH&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;try {}&lt;/code&gt; without a &lt;code&gt;CATCH&lt;/code&gt; is equivalent to Perl 5&amp;rsquo;s &lt;code&gt;eval {}&lt;/code&gt;. (In fact, &lt;code&gt;eval&lt;/code&gt; will go back to evaluating only strings in Perl 6, and &lt;code&gt;try&lt;/code&gt; will evaluate only blocks.)&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;CATCH&lt;/code&gt; and &lt;code&gt;POST&lt;/code&gt; blocks are naturally in the lexical scope of the try block. They may safely refer to lexically scoped variables declared earlier in the try block, even if the exception is thrown during the elaboration sequence. (The run-time system will guarantee that individual variables test as undefined (and hence false) before they are elaborated.)&lt;/p&gt;

&lt;p&gt;The inside of the &lt;code&gt;CATCH&lt;/code&gt; block is precisely the syntax of a switch statement. The discriminant of the switch statement is the exception object, &lt;code&gt;$!&lt;/code&gt;. Since the exception object stringifies to the error message, the &lt;code&gt;when /divide by 0/&lt;/code&gt; case need not be explicitly compared against &lt;code&gt;$!&lt;/code&gt;. Likewise, explicit mention of a declared class implies an &amp;ldquo;isa&amp;rdquo; lookup, another built-in feature of the new switch statement.&lt;/p&gt;

&lt;p&gt;In fact, a &lt;code&gt;CATCH&lt;/code&gt; of the form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    CATCH { 
        when xxx { ... }          # 1st case
        when yyy { ... }          # 2nd case
        ...                       # other cases, maybe a default
    }

 means something vaguely like:

    BEGIN {
        %MY.catcher = {
            given current_exception() -&amp;gt; $! {

                when xxx { ... }          # 1st case from above
                when yyy { ... }          # 2nd case from above
                ...                       # other cases, maybe a default

                die;            # rethrow $! as implicit default
            }
            $!.markclean;       # handled cleanly, in theory
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The unified &amp;ldquo;current exception&amp;rdquo; is &lt;code&gt;$!&lt;/code&gt;. Everywhere this RFC uses &lt;code&gt;$@&lt;/code&gt;, it should be read as &lt;code&gt;$!&lt;/code&gt; instead. (And the too-precious &lt;code&gt;@@&lt;/code&gt; goes away entirely in favor of an array stored internally to the &lt;code&gt;$!&lt;/code&gt; object that can be accessed as &lt;code&gt;@$!&lt;/code&gt; or &lt;code&gt;$![-1]&lt;/code&gt;.) (For the legacy Perl 5 parser, &lt;code&gt;$@&lt;/code&gt; and &lt;code&gt;$?&lt;/code&gt; will be emulated, but that will not be available to the Perl 6 parser.)&lt;/p&gt;

&lt;p&gt;Also note that the &lt;code&gt;CATCH&lt;/code&gt; block implicitly supplies a rethrow (the &lt;code&gt;die&lt;/code&gt; above) after the cases of the switch statement. This will not be reached if the user has supplied an explicit &lt;code&gt;default&lt;/code&gt; case, since the &lt;code&gt;break&lt;/code&gt; of that default case will always bypass the implicit &lt;code&gt;die&lt;/code&gt;. And if the switch rethrows the exception (either explicitly or implicitly), &lt;code&gt;$!&lt;/code&gt; is not marked as clean, since the &lt;code&gt;die&lt;/code&gt; will bypass the code that marks the exception as &amp;ldquo;cleanly caught&amp;rdquo;. It should be considered an invariant that any &lt;code&gt;$!&lt;/code&gt; in the normal control flow outside of a &lt;code&gt;CATCH&lt;/code&gt; is considered &amp;ldquo;cleanly caught&amp;rdquo;, according to the definition in the RFC. Unclean exceptions should only be seen inside &lt;code&gt;CATCH&lt;/code&gt; blocks, or inside any &lt;code&gt;POST&lt;/code&gt; blocks that have to execute while an exception is propagating to an outer block because the current try block didn&amp;rsquo;t handle it. (If the current try block does successfully handle the exception in its &lt;code&gt;CATCH&lt;/code&gt;, any &lt;code&gt;POST&lt;/code&gt; blocks at the same level see a &lt;code&gt;$!&lt;/code&gt; that is already marked clean.)&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;eval {die &amp;quot;Can&#39;t foo.&amp;quot;}; print $@;&lt;/code&gt; &lt;em&gt;continues to work as before.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;That will instead look like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try { die &amp;quot;Can&#39;t foo&amp;quot; }; print $!;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in Perl 6. A &lt;code&gt;try&lt;/code&gt; with no &lt;code&gt;CATCH&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try { ... CATCH { default { } } }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(And that&amp;rsquo;s another reason I didn&amp;rsquo;t want to use &lt;code&gt;else&lt;/code&gt; for the default case of a switch statement&amp;ndash;an &lt;code&gt;else&lt;/code&gt; without an &lt;code&gt;if&lt;/code&gt; looks really bizarre&amp;hellip;)&lt;/p&gt;

&lt;p&gt;Just as an aside, what I&amp;rsquo;m trying to do here is untangle the exception trapping semantics of &lt;code&gt;eval&lt;/code&gt; from its code parsing and running semantics. In Perl 6, there is no &lt;code&gt;eval {}&lt;/code&gt;. And &lt;code&gt;eval $string&lt;/code&gt; really means something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try { $string.parse.run }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;This RFC does not require core Perl functions to use exceptions for signalling errors.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;However, Perl core functions will by default signal failure using unthrown proto-exceptions (that is, interesting values of undef) that can easily be turned into thrown exceptions via &lt;code&gt;die&lt;/code&gt;. By &amp;ldquo;interesting values of undef&amp;rdquo;, I don&amp;rsquo;t mean undef with properties. I mean full-fledged exception objects that just happen to return false from their &lt;code&gt;.defined&lt;/code&gt; and &lt;code&gt;.true&lt;/code&gt; methods. However, the &lt;code&gt;.str&lt;/code&gt; method successfully returns the error message, and the &lt;code&gt;.int&lt;/code&gt; method returns the error code (if any). That is, they do stringify and numify like &lt;code&gt;$!&lt;/code&gt; ought to. An exception becomes defined and true when it is thrown. (Control exceptions become false when cleanly caught, to avoid spoofing old-style exception handlers.)&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;This means that all exceptions propagate unless they are cleanly caught, just as in Perl 5. To prevent this, use:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try { fragile(); } catch { } # Go on no matter what.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will simply be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try { fragile; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But it means the same thing, and it&amp;rsquo;s still the case that all exceptions propagate unless they are cleanly caught. In this case, the caught exception lives on in &lt;code&gt;$!&lt;/code&gt; as a new proto-exception that could be rethrown by a new &lt;code&gt;die&lt;/code&gt;, much as we used to use &lt;code&gt;$@&lt;/code&gt;. Whether an exception is currently considered &amp;ldquo;cleanly caught&amp;rdquo; can be reflected in the state of the &lt;code&gt;$!&lt;/code&gt; object itself. When &lt;code&gt;$!&lt;/code&gt; passes through the end of a &lt;code&gt;CATCH&lt;/code&gt;, it is marked as clean, so that subsequent attempts to establish a new &lt;code&gt;$!&lt;/code&gt; know that they can clear out the old &lt;code&gt;@$!&lt;/code&gt; stack. (If the current &lt;code&gt;$!&lt;/code&gt; is not clean, it should just add its information without deleting the old information&amp;ndash;otherwise an error in a &lt;code&gt;CATCH&lt;/code&gt; could delete the exception information you will soon be wanting to print out.)&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try { ... } catch &amp;lt;test&amp;gt; =&amp;gt; { ... } finally { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    { ... CATCH { when &amp;lt;test&amp;gt; { ... } } POST { ... } }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(The angle brackets aren&amp;rsquo;t really there&amp;ndash;I&amp;rsquo;m just copying the RFC&amp;rsquo;s metasyntax here.)&lt;/p&gt;

&lt;p&gt;Note that we&amp;rsquo;re assuming a test that matches the &amp;ldquo;boolean&amp;rdquo; entry from the switch dwimmery matrix. If not, you can always wrap closure curlies around the test:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    { ... CATCH { when { &amp;lt;test&amp;gt; } { ... } } POST { ... } }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That will force the test to be called as a subroutine that ignores its argument, which happens to be &lt;code&gt;$!&lt;/code&gt;, the exception object. (Recall that the implied &amp;ldquo;given&amp;rdquo; of a &lt;code&gt;CATCH&lt;/code&gt; statement sets &lt;code&gt;$!&lt;/code&gt; as the given value. That given value is automatically passed to any &amp;ldquo;when&amp;rdquo; cases that look like subroutines or closures, which are free either to ignore the passed value, or access it as &lt;code&gt;$_&lt;/code&gt; or &lt;code&gt;$^a&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;Or you might just prefer to use the unary &lt;code&gt;true&lt;/code&gt; operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    { ... CATCH { when true &amp;lt;test&amp;gt; { ... } } POST { ... } }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I personally find that more readable than the closure.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The test argument of the catch clause is optional, and is described below.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The test argument of a &lt;code&gt;when&lt;/code&gt; clause is NOT optional, since it would be impossible to distinguish a conditional closure from the following block. Use &lt;code&gt;default&lt;/code&gt; for the default case.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code&gt;try&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, and &lt;code&gt;finally&lt;/code&gt; blocks should share the same lexical scope, in the way that &lt;code&gt;while&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; do.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Actually, this is not so&amp;ndash;the &lt;code&gt;while&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; blocks don&amp;rsquo;t share the same lexical scope even in Perl 5. But we&amp;rsquo;ll solve this issue without &amp;ldquo;tunneling&amp;rdquo; in any case. (And we&amp;rsquo;ll change the &lt;code&gt;continue&lt;/code&gt; block into a &lt;code&gt;NEXT&lt;/code&gt; block that goes inside, so we can refer to lexical variables from within it.)&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note that &lt;code&gt;try&lt;/code&gt; is a keyword, not a function. This is so that a &lt;code&gt;;&lt;/code&gt; is not needed at the end of the last block. This is because a &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;/&lt;code&gt;finally&lt;/code&gt; now looks more like an &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;elsif&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;, which does not require such a &lt;code&gt;;&lt;/code&gt;, than like an eval, which does).&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Again, this entire distinction goes away in Perl 6. Any expression block that terminates with a right curly on its own line will be interpreted as a statement block. And &lt;code&gt;try&lt;/code&gt; is such an expression block.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code&gt;$@&lt;/code&gt; contains the current exception, and &lt;code&gt;@@&lt;/code&gt; contains the current exception stack, as defined above under &lt;code&gt;die&lt;/code&gt;. The &lt;code&gt;unshift&lt;/code&gt; rule guarantees that &lt;code&gt;$@ == $@[0]&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Why an &lt;code&gt;unshift?&lt;/code&gt; A stack is most naturally represented in the other direction, and I can easily imagine some kinds of handlers that might well treat it like a stack, stripping off some entries and pushing others.&lt;/p&gt;

&lt;p&gt;Also, &lt;code&gt;@@&lt;/code&gt; is a non-starter because everything about the current exception should all be in a single data structure. Keeping the info all in one place makes it easy to rethrow an exception without losing data, even if the exception was marked as cleanly caught. Furthermore I don&amp;rsquo;t think that the exception stack needs to be Huffman coded that badly.&lt;/p&gt;

&lt;p&gt;So &lt;code&gt;$!&lt;/code&gt; contains the current exception, and &lt;code&gt;$!.stack&lt;/code&gt; accesses the current exception stack. Through the magic of overloading, the &lt;code&gt;$!&lt;/code&gt; object can likely be used as an array even though it isn&amp;rsquo;t one, in which case &lt;code&gt;@$!&lt;/code&gt; refers to that stack member. The &lt;code&gt;push&lt;/code&gt; rule guarantees that &lt;code&gt;$!.id == $![-1].id&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;RFC (speaking of the &lt;code&gt;exception&lt;/code&gt; declaration):&lt;/p&gt;

&lt;p&gt;&lt;em&gt;If the given name matches &lt;code&gt;/::/&lt;/code&gt;, something like this happens:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @MyError::App::DB::Foo::ISA = &#39;MyError::App::DB&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;and all non-existent parent classes are automatically created as inheriting from their parent, or &lt;code&gt;Exception&lt;/code&gt; in the tail case. If a parent class is found to exist and not inherit from &lt;code&gt;Exception&lt;/code&gt;, a run-time error exception is raised.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;If I understand this, I think I disagree. A package ought to able to contain exceptions without being an exception class itself. There certainly ought to be a shorthand for exceptions within the current package. I suspect they&amp;rsquo;re inner classes of some sort, or inner classes of an inner package, or some such.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;If the given name does not match &lt;code&gt;/::/&lt;/code&gt; (say it&amp;rsquo;s just &lt;code&gt;Alarm&lt;/code&gt;), this happens instead:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @Alarm::ISA = &#39;Exception&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;This means that every exception class isa &lt;code&gt;Exception&lt;/code&gt;, even if &lt;code&gt;Exception::&lt;/code&gt; is not used at the beginning of the class name.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Ack! This could be really bad. What if two different modules declare an &lt;code&gt;Alarm&lt;/code&gt; exception with different derivations?&lt;/p&gt;

&lt;p&gt;I think we need to say that unqualified exceptions are created within the current package, or maybe within the X subpackage of the current package. If we have inner classes, they could even be lexically scoped (and hence anonymous exceptions outside the current module). That might or might not be a feature.&lt;/p&gt;

&lt;p&gt;I also happen to think that &lt;code&gt;Exception&lt;/code&gt; is too long a name to prefix most common exceptions, even though they&amp;rsquo;re derived from that class. I think exceptions will be better accepted if they have pithier names like X::Errno that are derived from &lt;code&gt;Exception&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    our class X::Control is Exception;
    our class X::Errno is Exception;
    our class X::NumericError is Exception;

    our class C::NEXT is X::Control;
    our class E::NOSPC is X::Errno;
    our class X::FloatingUnderflow is X::NumericError;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or maybe those could be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    c::NEXT
    e::NOSPC
    x::FloatingUnderflow
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;if we decide uppercase names are too much like user-defined package names. But that looks strange. Maybe we just reserve single letter top-level package names for Perl. Heck, let&amp;rsquo;s just reserve all top-level package names for Perl. Er, no, wait&amp;hellip; &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;RFC 80 suggests that exception objects numerify to the system&amp;rsquo;s &lt;em&gt;errno&lt;/em&gt; number when those are available. That&amp;rsquo;s a possibility, though by the current switch rules we might have to write&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    CATCH {
        when +$ENOSPC { ... }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to force &lt;code&gt;$ENOSPC&lt;/code&gt; to do a numeric comparison. It may well be better to go ahead and make the errno numbers into exception classes, even if we have to write something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    CATCH {
        when X::ENOSPC { ... }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s longer, but I think it&amp;rsquo;s clearer. Possibly that&amp;rsquo;s &lt;code&gt;E::NOSPC&lt;/code&gt; instead. But in any event, I can&amp;rsquo;t imagine getting people to prefix every exception with &amp;ldquo;&lt;code&gt;Exception::&lt;/code&gt;&amp;rdquo;. That&amp;rsquo;s just gonna discourage people from using exceptions. I&amp;rsquo;m quite willing to at least reserve the &lt;code&gt;X&lt;/code&gt; top-level class for exceptions. I think &lt;code&gt;X::&lt;/code&gt; is quite sufficiently distinctive.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try { my $f = open &amp;quot;foo&amp;quot;; ... } finally { $f and close $f; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    {
        my $f = open &amp;quot;foo&amp;quot;; ...
        POST { $f and close $f }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that &lt;code&gt;$f&lt;/code&gt; is naturally in scope and guaranteed to have a boolean value, even if the exception is thrown before the declaration statement is elaborated! (An implementation need not allocate an actual variable before the &lt;code&gt;my&lt;/code&gt;. The code of the &lt;code&gt;POST&lt;/code&gt; block could always be compiled to know that &lt;code&gt;$f&lt;/code&gt; is to be assumed undefined if the allocating code has not yet been reached.)&lt;/p&gt;

&lt;p&gt;We could go as far as to make&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        POST { close $f }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;do something reasonable even without the guard. Maybe an undefined object could &amp;ldquo;emulate&amp;rdquo; any method for you within a &lt;code&gt;POST&lt;/code&gt;. Maybe &lt;code&gt;try&lt;/code&gt; is really a unary operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        POST { try close $f }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or some such. I dunno. This needs more thought along transactional lines&amp;hellip;&lt;/p&gt;

&lt;p&gt;Time passes&amp;hellip;&lt;/p&gt;

&lt;p&gt;Actually, now that I&amp;rsquo;ve thought on it, it would be pretty easy to put wrappers around &lt;code&gt;POST&lt;/code&gt; blocks that could do commit or rollback depending on whether the block exits normally. I&amp;rsquo;d like to call them &lt;code&gt;KEEP&lt;/code&gt; and &lt;code&gt;UNDO&lt;/code&gt;. &lt;code&gt;KEEP&lt;/code&gt; blocks would only be executed if the block succeeded. &lt;code&gt;UNDO&lt;/code&gt; blocks would only be executed if the block failed. One could even envision a syntax that ties the block to particular variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    UNDO $f { close $f }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After all, like the &lt;code&gt;CATCH&lt;/code&gt; block, all of these blocks are just fancy &lt;code&gt;BEGIN&lt;/code&gt; blocks that attach some meaning to some predefined property of the block.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S04.html&#34;&gt;Synopsis 04&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s tempting to make the execution of &lt;code&gt;UNDO&lt;/code&gt; contingent upon whether the block itself was passed during execution, but I&amp;rsquo;m afraid that might leave a window in which a variable could already be set, but subsequent processing might raise an exception before enabling the rollback in question. So it&amp;rsquo;s probably better to tie it to a particular variable&amp;rsquo;s state more directly than just by placing the block at some point after the declaration. In fact, it could be associated directly with the variable in question at declaration time via a property:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $f is undo { close $f } = open $file or die;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the block is truly a closure because it relies on the lexical scoping of &lt;code&gt;$f&lt;/code&gt;. (This form of lexical scoping works in Perl 6 because the name &lt;code&gt;$f&lt;/code&gt; is introduced immediately within the statement. This differs from the Perl 5 approach where the name is not introduced till the end of the current statement.)&lt;/p&gt;

&lt;p&gt;Actually, if the &lt;code&gt;close&lt;/code&gt; function defaults to &lt;code&gt;$_&lt;/code&gt;, we can say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $f is undo { close } = open $file;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;presuming the managing code is smart enough to pass &lt;code&gt;$f&lt;/code&gt; as a parameter to the closure. Likewise one could attach a &lt;code&gt;POST&lt;/code&gt; block to a variable with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $f is post { close } = open $file;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since properties can be combined, you can set multiple handlers on a variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $f is post { close } is undo { unlink $file } = open &amp;quot;&amp;gt;$file&amp;quot; or die;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is, however, no &lt;code&gt;catch&lt;/code&gt; property to go with the &lt;code&gt;CATCH&lt;/code&gt; block.&lt;/p&gt;

&lt;p&gt;I suppose we could allow a &lt;code&gt;pre&lt;/code&gt; property to set a &lt;code&gt;PRE&lt;/code&gt; block on a variable.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub attempt_closure_after_successful_candidate_file_open
    {
        my ($closure, @fileList) = @_; local (*F);
        foreach my $file (@fileList) {
            try { open F, $file; } catch { next; }
            try { &amp;amp;$closure(*F); } finally { close F; }
            return;
            }
        throw Exception &amp;quot;Can&#39;t open any file.&amp;quot;,
               debug =&amp;gt; @fileList . &amp;quot; tried.&amp;quot;;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub attempt_closure_after_successful_candidate_file_open
      (&amp;amp;closure, @fileList)
    {
        foreach my $file (@fileList) {
            my $f is post { close }
                = try { open $file or die; CATCH { next } }
            &amp;amp;closure($f);
            return;
        }
        throw Exception &amp;quot;Can&#39;t open any file.&amp;quot;,
               debug =&amp;gt; @fileList . &amp;quot; tried.&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the &lt;code&gt;next&lt;/code&gt; within the &lt;code&gt;CATCH&lt;/code&gt; refers to the loop, not the &lt;code&gt;CATCH&lt;/code&gt; block. It is legal to &lt;code&gt;next&lt;/code&gt; out of &lt;code&gt;CATCH&lt;/code&gt; blocks, since we won&amp;rsquo;t use &lt;code&gt;next&lt;/code&gt; to fall through switch cases.&lt;/p&gt;

&lt;p&gt;However, &lt;code&gt;X::Control&lt;/code&gt; exceptions (such as &lt;code&gt;X::NEXT&lt;/code&gt;) are a subset of &lt;code&gt;Exceptions&lt;/code&gt;, so&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    CATCH {
        when Exception { ... }   # catch any exception
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will stop returns and loop exits. This could be construed as a feature. When it&amp;rsquo;s considered a bug, you could maybe say something like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    CATCH {
        when X::Control { die }  # propagate control exceptions
        when Exception  { ... }  # catch all others
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to force such control exceptions to propagate outward. Actually, it would be nice to have a name for non-control exceptions. Then we could say (with a tip of the hat to Maxwell Smart):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    CATCH {
        when X::Chaos   { ... }  # catch non-control exceptions
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And any control exceptions will then pass unimpeded (since by default uncaught exceptions are rethrown implicitly by the &lt;code&gt;CATCH&lt;/code&gt;). Fortunately or unfortunately, an explicit &lt;code&gt;default&lt;/code&gt; case will not automatically rethrow control exceptions.&lt;/p&gt;

&lt;p&gt;Following are some more examples of how the expression evaluation of &lt;code&gt;when&lt;/code&gt; can be used. The RFC versions sometimes look more concise, but recall that the &amp;ldquo;try&amp;rdquo; is any block in Perl 6, whereas in the RFC form there would have to be an extra, explicit &lt;code&gt;try&lt;/code&gt; block inside many subroutines, for instance. I&amp;rsquo;d rather establish a culture in which it is expected that subroutines handle their own exceptions.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try { ... } catch $@-&amp;gt;{message} =~ /.../ =&amp;gt; { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try {
        ...
        CATCH {
            when $!.message =~ /.../ { ... }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works because =~ is considered a boolean operator.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    catch not &amp;amp;TooSevere =&amp;gt; { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    when not &amp;amp;TooSevere { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The unary &lt;code&gt;not&lt;/code&gt; is also a boolean operator.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try { ... } catch ref $@ =~ /.../ =&amp;gt; { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try { ... CATCH { when $!.ref =~ /.../ { ... } } }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try { ... } catch grep { $_-&amp;gt;isa(&amp;quot;Foo&amp;quot;) } @@ =&amp;gt; { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try {
        ...
        CATCH {
            when grep { $_.isa(Foo) } @$! { ... }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I suppose we could also assume grep to be a boolean operator in a scalar context. But that&amp;rsquo;s kind of klunky. If we accept Damian&amp;rsquo;s superposition RFC, it could be written this way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try {
        ...
        CATCH {
            when true any(@$!).isa(Foo) { ... }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Actually, by the &amp;ldquo;any&amp;rdquo; rules of the &lt;code&gt;=~&lt;/code&gt; table, we can just say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try {
        ...
        CATCH {
            when @$! =~ Foo { ... }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The RFC proposes the following syntax for finalization:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try { my $p = P-&amp;gt;new; my $q = Q-&amp;gt;new; ... }
    finally { $p and $p-&amp;gt;Done; }
    finally { $q and $q-&amp;gt;Done; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A world of hurt is covered over by that &amp;ldquo;&lt;code&gt;...&lt;/code&gt;&amp;rdquo;, which could move the &lt;code&gt;finally&lt;/code&gt; clauses far, far away from what they&amp;rsquo;re trying to clean up after. I think the intent is much clearer with &lt;code&gt;POST&lt;/code&gt;. And note also that we avoid the &amp;ldquo;lexical tunneling&amp;rdquo; perpetrated by &lt;code&gt;finally&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    {
        my $p = P.new;   POST { $p and $p.Done; }
        my $q = Q.new;   POST { $q and $q.Done; }
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More concisely, we can say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    {
        my $p is post { .Done } = P.new;
        my $q is post { .Done } = Q.new;
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try     { TryToFoo; }
    catch   { TryToHandle; }
    finally { TryToCleanUp; }
    catch   { throw Exception &amp;quot;Can&#39;t cleanly Foo.&amp;quot;; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How I&amp;rsquo;d write that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try {
        try {
            TryToFoo;
            POST    { TryToCleanUp; }
            CATCH   { TryToHandle; }
        }
        CATCH   { throw Exception &amp;quot;Can&#39;t cleanly Foo.&amp;quot;; }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That also more clearly indicates to the reader that the final &lt;code&gt;CATCH&lt;/code&gt; governs the inner try completely, rather than just relying on ordering.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Instances of the actual (non-subclassed) &lt;code&gt;Exception&lt;/code&gt; class itself are used for simple exceptions, for those cases in which one more or less just wants to say &lt;code&gt;throwÂ ExceptionÂ &amp;quot;MyÂ message.&amp;quot;&lt;/code&gt;, without a lot of extra tokens, and without getting into higher levels of the taxonomy of exceptions.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;die &amp;quot;My message.&amp;quot;&lt;/code&gt; has much the same effect. I think &lt;code&gt;failÂ &amp;quot;MyÂ message.&amp;quot;&lt;/code&gt;Â  will also default similarly, though with return-or-throw semantics that depend on the caller&amp;rsquo;s &lt;code&gt;use fatal&lt;/code&gt; settings.&lt;/p&gt;

&lt;p&gt;RFC (regarding &lt;code&gt;on_raise&lt;/code&gt;):&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Derived classes may override this method to attempt to &amp;ldquo;handle&amp;rdquo; an exception or otherwise manipulate it, just before it is raised. If &lt;code&gt;on_raise&lt;/code&gt; throws or returns true the exception is raised, otherwise it is not. An exception can be manipulated or replaced and then propagated in modified form simply by re-raising it in &lt;code&gt;on_raise&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Offhand, I don&amp;rsquo;t see this one. Not only does it seem to be making the &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; mistake all over again, it also makes little sense to me to use &amp;ldquo;throw&amp;rdquo; to do something that doesn&amp;rsquo;t throw. A throw should guarantee termination of control, or you&amp;rsquo;re just going to run user code that wasn&amp;rsquo;t expected to be run. It&amp;rsquo;d be like &lt;code&gt;return&lt;/code&gt; suddenly not returning! Let&amp;rsquo;s please use a different method to generate an unthrown exception. I think a &lt;code&gt;fail&lt;/code&gt; method is the right approach&amp;ndash;it terminates the control flow one way or another, even if just returning the exception as a funny-looking undef.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;on_catch&lt;/code&gt; might be a bit more useful.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;hellip;because the authors are of the opinion that overloading &lt;code&gt;else&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; with unwind semantics not traditionally associated with &lt;code&gt;else&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; can be confusing, especially when intermixed with local flow-control forms of &lt;code&gt;else&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; (which may be present in any &lt;code&gt;{Â ...Â }&lt;/code&gt; block), or when an &lt;code&gt;elseÂ dieÂ $@&lt;/code&gt; is forgotten on a &lt;code&gt;switch&lt;/code&gt; that needs to re-throw.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;CATCH&lt;/code&gt; will rethrow by default (unless there is a user-specified default).&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Some perl6-language-error discussions have suggested leaving out the try altogether, as in simply writing &lt;code&gt;{ } else { }&lt;/code&gt; to indicate non-local flow-control at work. Yikes!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The &lt;code&gt;try&lt;/code&gt; is not for Perl&amp;rsquo;s sake. It&amp;rsquo;s for the developer&amp;rsquo;s sake. It says, watch out, some sort of non-local flow control is going on here. It signals intent to deal with action at a distance (unwinding semantics). It satisfies the first requirement listed under MOTIVATION.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S04.html&#34;&gt;Synopsis 04&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;try {}&lt;/code&gt; is the new spelling of &lt;code&gt;eval {}&lt;/code&gt;, so it can still be used when self-documentation is desired. It&amp;rsquo;s often redundant, however, since I think the all-caps &lt;code&gt;CATCH&lt;/code&gt; and &lt;code&gt;POST&lt;/code&gt; also serve the purpose of telling the developer to &amp;ldquo;watch out&amp;rdquo;. I expect that developers will get used to the notion that many subroutines will end with a &lt;code&gt;CATCH&lt;/code&gt; block. And I&amp;rsquo;m always in favor of reducing the bracket count of ordinary code where practical. (That&amp;rsquo;s why the &lt;code&gt;package&lt;/code&gt; declaration has always had a bracketless syntax. I hope to do the same for classes and modules in Perl 6.)&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The comma or &lt;code&gt;=&lt;/code&gt;``&lt;/em&gt; &lt;em&gt;in a conditional catch clause is required so the expression can be parsed from the block, in the fashion of Perl 5&amp;rsquo;s parsing of: &lt;code&gt;map&lt;/code&gt;&lt;code&gt;&amp;lt;expression&lt;/code&gt;``&lt;/em&gt;&lt;code&gt;, &amp;lt;list&lt;/code&gt;`&lt;code&gt;&amp;amp;gt;; Without the comma, the form&lt;/code&gt;catchÂ $fooÂ {Â &amp;hellip;Â }&lt;code&gt;could be a test for&lt;/code&gt;$foo&lt;code&gt;or a test for&lt;/code&gt;$foo{&amp;hellip;}` (the hash element).&amp;gt;&lt;/p&gt;

&lt;p&gt;We now require whitespace before non-subscript block, so this is not much of a problem.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;How can we subclass &lt;code&gt;Exception&lt;/code&gt; and control the class namespace? For example, if the core can use any &lt;code&gt;Exception::Foo&lt;/code&gt;, where does one connect non-core &lt;code&gt;Exception&lt;/code&gt;s into the taxonomy? Possibly the core exceptions can derive from &lt;code&gt;Exception::CORE&lt;/code&gt;, and everyone else can use the &lt;code&gt;Exception::MyPackage&lt;/code&gt; convention.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t think defining things as core vs non-core is very useful&amp;ndash;&amp;ldquo;core&amp;rdquo; is not a fundamental type of exception. I do think the standard exception taxonomy should be extensible, so that non-standard exceptions can migrate toward being standard over time. I also think that modules and classes should have their own subpackage in which to store exceptions.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;How can we add new instance variables and methods to classes derived from &lt;code&gt;Exception&lt;/code&gt; and control those namespaces? Perhaps this will be covered by some new Perl 6 object technology. Otherwise, we will need yet another naming scheme convention.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Instance variables and methods in a derived class will not interfere with base classes (except by normal hiding of duplicate method names).&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;What should the default values be for &lt;code&gt;Exception&lt;/code&gt; object instance variables not specified to the constructor? For example, &lt;code&gt;tag&lt;/code&gt; could default to file + line number.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Depends on the constructor, I suspect.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;What assertions should be placed on the instance variables, if any?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Probably depends on the class.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;What should stringification return?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I lean towards just the message, with a different method for more info. But this is somewhat dependent on which representational methods we define for all Objects. And that has not been entirely thunk through.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Mixed Flow Control&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Some of the reference texts, when discussing exception handling, refer to the matter that it may be difficult to implement a &lt;code&gt;go to&lt;/code&gt; across an unwinding semantics block, as in:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        try { open F, $f } catch { next; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;This matter will have to be referred to the internals experts. It&amp;rsquo;s ok if this functionality is not possible, it can always be simulated with lexical state variables instead.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;However, the authors would very much prefer that &lt;code&gt;goto&lt;/code&gt;s across unwinding boundaries would dwim. If that is not possible, hopefully some sort of compile-time warning could be produced.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;We can do this with special control exceptions that aren&amp;rsquo;t caught until it makes sense to catch them. (Where exactly control exceptions fit in the class hierarchy is still open to debate.) In any event, there&amp;rsquo;s no problem throwing a control exception from a &lt;code&gt;CATCH&lt;/code&gt;, since any exception thrown in a &lt;code&gt;CATCH&lt;/code&gt; or &lt;code&gt;POST&lt;/code&gt; would propagate outside the current try block in any event.&lt;/p&gt;

&lt;p&gt;Ordinary &lt;code&gt;goto&lt;/code&gt; should work as long as it&amp;rsquo;s leaving the current try scope. Reentering the try somewhere in the middle via &lt;code&gt;goto&lt;/code&gt; is likely not possible, or even desirable. A failed try should be re-entered from the top, once things have been cleared up. (If the try is a loop block, going to the next iteration out of its &lt;code&gt;CATCH&lt;/code&gt; will probably be considered safe, just as if there had been an explicit &lt;code&gt;try&lt;/code&gt; block within the loop. But I could be wrong on that.)&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Use &lt;code&gt;%@&lt;/code&gt; for Errors from Builtins&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;*RFC 151 proposes a mechanism for consolidating the information provided by of &lt;code&gt;$@&lt;/code&gt;, &lt;code&gt;$!&lt;/code&gt;, &lt;code&gt;$?&lt;/code&gt;, and &lt;code&gt;$^E&lt;/code&gt;. In the opinion of the author of RFC 88, merging &lt;code&gt;$@&lt;/code&gt; and &lt;code&gt;$!&lt;/code&gt; should not be undertaken, because &lt;code&gt;$@&lt;/code&gt; should &lt;em&gt;only&lt;/em&gt; be set if an exception is raised.*&lt;/p&gt;

&lt;p&gt;The RFC appears to give no justification for this last assertion. If we unify the error variables, &lt;code&gt;die&lt;/code&gt; with no arguments can simply raise the current value of &lt;code&gt;$!&lt;/code&gt;, and we stay object oriented all the way down. Then &lt;code&gt;$!&lt;/code&gt; indicates the current error whether or not it&amp;rsquo;s being thrown. It keeps track of its own state, as to whether it is currently in an &amp;ldquo;unclean&amp;rdquo; state, and refuses to throw away information unless it&amp;rsquo;s clean.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;%@&lt;/code&gt; &lt;em&gt;should be used to hold this fault-hash, based on the following arguments for symmetry.&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        $@    current exception
        @@    current exception stack
        %@    current core fault information

        $@[0]        same as $@

        $@{type}     &amp;quot;IO::File::NotFound&amp;quot;
        $@{message}  &amp;quot;can&#39;t find file&amp;quot;
        $@{param}    &amp;quot;/foo/bar/baz.dat&amp;quot;
        $@{child}    $?
        $@{errno}    $!
        $@{os_err}   $^E
        $@{chunk}    That chunk thingy in some msgs.
        $@{file}     Source file name of caller.
        $@{line}     Source line number of caller.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;%@&lt;/code&gt; &lt;em&gt;should not contain a severity or fatality classification.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Every call to a core API function should clear &lt;code&gt;%@&lt;/code&gt; if it returns successfully.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Internally, Perl can use a simple structured data type to hold the whole canonical &lt;code&gt;%@&lt;/code&gt;. The code that handles reading from &lt;code&gt;%@&lt;/code&gt; will construct it out of the internal data on the fly.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;If &lt;code&gt;use fatal;&lt;/code&gt; is in scope, then just before returning, each core API function should do something like: &lt;code&gt;%@Â andÂ internal_dieÂ %@;&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The &lt;code&gt;internal_die&lt;/code&gt; becomes the one place where a canonical &lt;code&gt;Exception&lt;/code&gt; can be generated to encapsulate &lt;code&gt;%@&lt;/code&gt; just before raising an exception, whether or not the use of such canonical &lt;code&gt;Exception&lt;/code&gt;s is controlled by a pragma such as&lt;/em&gt; &lt;code&gt;useÂ exceptions;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This &lt;code&gt;%@&lt;/code&gt; proposal just looks like a bunch of unnecessary complication to me. A proto-exception object with methods can be just as easily (and lazily) constructed, and will map straight into a real exception, unlike this hash. And an object can always be used as a hash to access parameterless methods such as instance variable accessors.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;eval&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The semantics of &lt;code&gt;eval&lt;/code&gt; are, &amp;ldquo;clear &lt;code&gt;$@&lt;/code&gt; and don&amp;rsquo;t unwind unless the user re-dies after the &lt;code&gt;eval&lt;/code&gt;&amp;rdquo;. The semantics of &lt;code&gt;try&lt;/code&gt; are &amp;ldquo;unwind after &lt;code&gt;try&lt;/code&gt;, unless any raised exception was cleanly and completely handled, in which case clear &lt;code&gt;$@&lt;/code&gt;&amp;rdquo;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;In the author&amp;rsquo;s opinion, both &lt;code&gt;eval&lt;/code&gt; and &lt;code&gt;try&lt;/code&gt; should exist in Perl 6. This would also mean that the legacy of examples of how to use &lt;code&gt;eval&lt;/code&gt; in Perl will still work.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;And, of course, we still need &lt;code&gt;evalÂ $string&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Discussions on perl6-language-errors have shown that some would prefer the &lt;code&gt;evalÂ {Â ...Â }&lt;/code&gt; form to be removed from Perl 6, because having two exception handling methods in Perl could be confusing to developers. This would in fact be possible, since the same effect can be achieved with:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        try { } catch { } # Clears $@.

        my $e;

        try { ... } catch { $e = $@; }

        # now process $e instead of $@
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;On the other hand, &lt;code&gt;eval&lt;/code&gt; is a convenient synonym for all that, given that it already works that way.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t think the exact semantics of &lt;code&gt;eval {...}&lt;/code&gt; are worth preserving. I think having bare &lt;code&gt;try {...}&lt;/code&gt; assume a &lt;code&gt;CATCH { default {} }&lt;/code&gt; will be close enough. Very few Perl 5 programs actually care whether &lt;code&gt;$@&lt;/code&gt; is set within the eval. Given that and the way we&amp;rsquo;ve defined &lt;code&gt;$!&lt;/code&gt;, the translation from Perl 5 to Perl 6 involves simply changing &lt;code&gt;evalÂ {...}&lt;/code&gt; to &lt;code&gt;tryÂ {...}&lt;/code&gt; and &lt;code&gt;$@&lt;/code&gt; to &lt;code&gt;$!&lt;/code&gt; (which lives on as a &amp;ldquo;clean&amp;rdquo; exception after being caught by the &lt;code&gt;try&lt;/code&gt;). Perhaps some attempt can be made to pull an external handler into an internal &lt;code&gt;CATCH&lt;/code&gt; block.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;catch v/s else + switch&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Some participants in discussions on perl6-language-errors have expressed the opinion that not only should &lt;code&gt;eval&lt;/code&gt; be used instead of &lt;code&gt;try&lt;/code&gt;, but &lt;code&gt;else&lt;/code&gt; should be used instead of multiple &lt;code&gt;catch&lt;/code&gt; blocks. They are of the opinion that an&lt;/em&gt; &lt;code&gt;elseÂ {Â switchÂ ...Â }&lt;/code&gt; &lt;em&gt;should be used to handle multiple catch clauses, as in:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        eval { ... }
        else {
            switch ($@) {
                case $@-&amp;gt;isa(&amp;quot;Exception::IO&amp;quot;) { ... }
                case $@-&amp;gt;my_method { ... }
                }
            }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;This problem with&lt;/em&gt; &lt;code&gt;elseÂ {Â switchÂ ...Â }&lt;/code&gt; &lt;em&gt;is: how should the code implicitly rethrow uncaught exceptions? Many proponents of this model think that uncaught exceptions should not be implicitly rethrown; one suggests that the programmer should &lt;code&gt;undef $@&lt;/code&gt; at the end of *every* successful case block, so that Perl re-raises any &lt;code&gt;$@&lt;/code&gt; still extant at the end of the &lt;code&gt;else&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;This RFC allows a &lt;code&gt;switch&lt;/code&gt; to be used in a&lt;/em&gt; &lt;code&gt;catchÂ {Â ...Â }&lt;/code&gt; &lt;em&gt;clause, for cases where that approach would minimize redundant code in&lt;/em&gt; &lt;code&gt;catch&lt;/code&gt; &lt;code&gt;&amp;lt;expr&lt;/code&gt;`&lt;code&gt;&amp;amp;gt;&lt;/code&gt;{ &amp;hellip; }` &lt;em&gt;clauses, but with the mechanism proposed in this RFC, the switch functionality shown above can be written like this, while still maintaining the automatic exception propagation when no cases match:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        try { ... }
        catch Exception::IO =&amp;gt; { ... }
        catch $@-&amp;gt;my_method =&amp;gt; { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The switch construct works fine, because the implied &lt;code&gt;break&lt;/code&gt; of each handled case jumps over the default rethrow supplied by the &lt;code&gt;CATCH&lt;/code&gt;. There&amp;rsquo;s no reason to invent a parallel mechanism, and lots of reason not to.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Mechanism Hooks&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;In the name of extensibility and debugging, there should be hooks for callbacks to be invoked when a &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, or &lt;code&gt;finally&lt;/code&gt; block is entered or exited, and when a conditional &lt;code&gt;catch&lt;/code&gt; is evaluated. The callbacks would be passed information about what is happening in the context they are being called from.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;In order to scope the effect of the callbacks (rather than making them global), it is proposed that the callbacks be specified as options to the try statement, something like this:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try on_catch_enter =&amp;gt; sub { ... },
        on_catch_exit  =&amp;gt; sub { ... },
    {
        ...
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;The (dynamic, not lexical) scope of these callbacks is from their try down through all trys nested under it (until overridden at a lower level). Nested callbacks should have a way of chaining to callbacks that were in scope when they come into scope, perhaps by including a reference to the outer-scope callback as a parameter to the callback. Basically, they could be kept in &amp;ldquo;global&amp;rdquo; variables overridden with &lt;code&gt;local&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Yuck. I dislike cluttering up the &lt;code&gt;try&lt;/code&gt; syntax with what are essentially &lt;code&gt;temp&lt;/code&gt; assignments to dynamically scoped globals. It should be sufficient to say something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    {
        temp &amp;amp;*on_catch_enter = sub { ... };
        temp &amp;amp;*on_catch_exit  = sub { ... };
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;provided, of course, the implementation is smart enough to look for those hooks when it needs them.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Mixed-Mode Modules&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Authors of modules who wish to provide a public API that respects the current state of &lt;code&gt;useÂ fatal;&lt;/code&gt; if such a mechanism is available, can do so as follows.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Internal to their modules, authors can use lexically scoped &lt;code&gt;useÂ fatal;&lt;/code&gt; to explicitly control whether or not they want builtins to raise exceptions to signal errors.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Then, if and only if they want to support the other style, and only for public API subroutines, they do something like one of these:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Use return internally, now add support for throw at API:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     sub Foo
     {
        my $err_code = ... ; # real code goes here

        # Replace the old return $err_code with this:

        return $err_code unless $FATAL_MODE &amp;amp;&amp;amp; $error_code != $ok;

        throw Error::Code &amp;quot;Couldn&#39;t Foo.&amp;quot;, code =&amp;gt; $err_code;
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;Use throw internally, add support for return at API:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     sub Foo
     {
        try {
            # real code goes here, may execute:

            throw Exception &amp;quot;Couldn&#39;t foo.&amp;quot;, code =&amp;gt; $err_code;
            }
        catch !$FATAL_MODE =&amp;gt; { return $@-&amp;gt;{code}; }

        return $ok;
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Yow. Too much mechanism. Why not just:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    return proto Exception &amp;quot;Couldn&#39;t foo.&amp;quot;, code =&amp;gt; $err_code;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;proto&lt;/code&gt; method can implement the standard &lt;code&gt;use fatal&lt;/code&gt; semantics when that is desired by the calling module, and otherwise set things up so that&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Foo() or die;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ends up throwing the proto-exception. (The current proto-exception can be kept in &lt;code&gt;$!&lt;/code&gt; for use in messages, provided it&amp;rsquo;s in thread-local storage.)&lt;/p&gt;

&lt;p&gt;Actually, this is really important to make simple. I&amp;rsquo;d be in favor of a built-in that clearly says what&amp;rsquo;s going on, regardless of whether it ends in a throw or a return of undef:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    fail &amp;quot;Couldn&#39;t foo&amp;quot;, errno =&amp;gt; 2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just as an aside, it could be argued that all such &amp;ldquo;built-ins&amp;rdquo; are really methods on an implicit class or object. In this case, the &lt;code&gt;Exception&lt;/code&gt; class&amp;hellip;&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;$SIG{__DIE__}&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The try, catch, and finally clauses localize and undef &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; before entering their blocks. This behavior can be removed if &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; is removed.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$SIG{__DIE__}&lt;/code&gt; must die. At least, that name must die&amp;ndash;we may install a similar global hook for debugging purposes.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Legacy&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The only changes in respect of Perl 5 behaviour implied by this RFC are that (1) &lt;code&gt;$@&lt;/code&gt; is now always an &lt;code&gt;Exception&lt;/code&gt; object (which stringifies reasonably), it is now read-only, and it can only be set via &lt;code&gt;die&lt;/code&gt;, and (2) the &lt;code&gt;@@&lt;/code&gt; array is now special, and it is now read-only too.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Perhaps &lt;code&gt;$!&lt;/code&gt; could be implicitly declared to have a type of &lt;code&gt;Exception&lt;/code&gt;. But I see little reason to make &lt;code&gt;$!&lt;/code&gt; readonly by default. All that does is prevent clever people from doing clever things that we haven&amp;rsquo;t thought of yet. And it won&amp;rsquo;t stop stupid people from doing stupid things. In any event, &lt;code&gt;$!&lt;/code&gt; is just a reference to an object, and access to the object will controlled by the class, not by Perl.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S04.html&#34;&gt;Synopsis 04&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-199-html-id-rfc-199-shortcircuiting-builtin-functions-and-userdefined-subroutines-rfc-199-short-circuiting-built-in-functions-and-user-defined-subroutines-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/199.html&#34; id=&#34;rfc 199: shortcircuiting builtin functions and userdefined subroutines&#34;&gt;RFC 199: Short-circuiting built-in functions and user-defined subroutines&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;First I should note in passing that it is likely that&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my ($found) = grep { $_ == 1 } (1..1_000_000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will be smart enough to stop on the first one without additional hints, since the left side will only demand one value of the right side.&lt;/p&gt;

&lt;p&gt;However, we do need to unify the behaviors of built-ins with user-defined control structures. From an internal point of view, all of these various ways of exiting a block will be unified as exceptions.&lt;/p&gt;

&lt;p&gt;It will be easy enough for a user-defined subroutine to catch the appropriate exceptions and do the right thing. For instance, to implement a loop wrapper (ignoring parser issues), you might write something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub mywhile ($keyword, &amp;amp;condition, &amp;amp;block) {
        my $l = $keyword.label;
        while (&amp;amp;condition()) {
            &amp;amp;block();
            CATCH {
                my $t = $!.tag;
                when X::Control::next { die if $t &amp;amp;&amp;amp; $t ne $l); next }
                when X::Control::last { die if $t &amp;amp;&amp;amp; $t ne $l); last }
                when X::Control::redo { die if $t &amp;amp;&amp;amp; $t ne $l); redo }
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remember that those &lt;code&gt;die&lt;/code&gt; calls are just rethrows of the current exception to get past the current try scope (the &lt;code&gt;while&lt;/code&gt; in this case).&lt;/p&gt;

&lt;p&gt;How a block gets a label in general is an interesting question. It&amp;rsquo;s all very well to say that the keyword is the label, but that doesn&amp;rsquo;t help if you have two nested constructs with the same name. In Perl 5, labels are restricted to being at the beginning of the statement, but then how do you label a &lt;code&gt;grep&lt;/code&gt;? Should there be some way of specifying a label on a keyword rather than on a statement? We could end up with something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $found = grep:NUM { $_ == 1 and last NUM: $_ } (1..1_000_000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the other hand, considering how often this feature is (not) going to used, I think we can stick with the tried-and-true statement label:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $found = do { NUM: grep { $_ == 1 and last NUM: $_ } (1..1_000_000) };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This has the advantage of matching the label syntax with a colon on the end in both places. I like that.&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t think every block should implicitly have a way to return, or we&amp;rsquo;ll have difficulty optimizing away blocks that don&amp;rsquo;t do anything blockish. That&amp;rsquo;s because setting up a try environment is always a bit blockish, and does in fact impose some overhead that we&amp;rsquo;d just as soon avoid when it&amp;rsquo;s unnecessary.&lt;/p&gt;

&lt;p&gt;However, it&amp;rsquo;s probably okay if certain constructs that would know how to deal with a label are implicitly labelled by their keyword name when they don&amp;rsquo;t happen to have an explicit label. So I think we can allow something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    last grep: $_
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Despite its appearance, that is not a method call, because &lt;code&gt;grep&lt;/code&gt; is not a predefined class. What we have is a unary operator &lt;code&gt;last&lt;/code&gt; that is taking an adverbial modifier specifying what to return from the loop.&lt;/p&gt;

&lt;p&gt;The interesting policy question as we go on will be whether a given construct responds to a given exception or not. Some exceptions will have to be restricted in their use. For instance, we should probably say that only explicit &lt;code&gt;sub&lt;/code&gt; declarations may respond to a &lt;code&gt;return&lt;/code&gt;. People will expect &lt;code&gt;return&lt;/code&gt; to exit the subroutine they think they&amp;rsquo;re in, even if there are blocks floating around that are actually closures being interpreted elsewhere. It might be considered antisocial for closure interpreters like &lt;code&gt;grep&lt;/code&gt; or &lt;code&gt;map&lt;/code&gt; or &lt;code&gt;sort&lt;/code&gt; to trap X::Control::return sooner than the user expects.&lt;/p&gt;

&lt;p&gt;As for using numbers instead of labels to indicate how many levels to break out of, that would be fine, except that I don&amp;rsquo;t believe in breaking out by levels. If the problem is complex enough that you need to break out more than one level, you need a name, not a number. Then it doesn&amp;rsquo;t matter if you refactor your code to have more block levels or less. I find I frequently have to refactor my code that way.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s possible to get carried away and retrofit &lt;code&gt;grep&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt; with every conceivable variety of abort, retry, accept, reject, reduce, reuse, recycle, or whatever exception. I don&amp;rsquo;t think that&amp;rsquo;s necessary. There has to be some reason for writing your own code occasionally. If we get rid of all the reasons for writing user-defined subroutines, we might as well pack our bags and go home. But it&amp;rsquo;s okay at minimum to treat a looping construct like a loop.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-6-html-id-rfc-006-lexical-variables-made-default-rfc-006-lexical-variables-made-default-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/6.html&#34; id=&#34;rfc 006: lexical variables made default&#34;&gt;RFC 006: Lexical variables made default&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;This RFC proposes that &lt;code&gt;strict vars&lt;/code&gt; should be on by default. This is motivated by the desire that Perl better support (or cajole, in this case) the disciplines that enable successful programming in the large. This goal is laudable.&lt;/p&gt;

&lt;p&gt;However, the programming-in-the-small advocates also have a valid point: they don&amp;rsquo;t want to have to go to all the trouble of turning off strictures merely to write a succinct one-liner, since keystrokes are at a premium in such programming, and in fact the very strictures that increase clarity in large programs tend to decrease clarity in small programs.&lt;/p&gt;

&lt;p&gt;So this is one of those areas where we desire to have it both ways, and in fact, we pretty much can. The only question is where to draw the line. Some discussion suggested that only programs specified on the command line via the &lt;code&gt;-e&lt;/code&gt; switch should be exempt from stricture. But I don&amp;rsquo;t want to force every little file-based script into the large model of programming. And we don&amp;rsquo;t need to.&lt;/p&gt;

&lt;p&gt;Large programming requires the definition of modules and classes. The typical large program will (or should) consist mostly of modules and classes. So modules and classes will assume &lt;code&gt;strict vars&lt;/code&gt;. Small programming does not generally require the definition of modules and classes, though it may depend on existing modules and classes. But even small programs that use a lot of external modules and classes may be considered throw-away code. The very fact that the main code of a program is not typically reused (in the sense that modules and classes are reused) means that there is where we should draw the line. So in Perl 6, the main program will not assume &lt;code&gt;strict vars&lt;/code&gt;, unless you explicitly do something to turn it on, such as to declare &amp;ldquo;class Main&amp;rdquo;.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-330-html-id-rfc-330-global-dynamic-variables-should-remain-the-default-rfc-330-global-dynamic-variables-should-remain-the-default-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/330.html&#34; id=&#34;rfc 330: global dynamic variables should remain the default&#34;&gt;RFC 330: Global dynamic variables should remain the default&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;This is fine for the main program, but modules and classes should be held to the higher standard of &lt;code&gt;use strict&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-83-html-id-rfc-083-make-constants-look-like-variables-rfc-083-make-constants-look-like-variables-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/83.html&#34; id=&#34;rfc 083: make constants look like variables&#34;&gt;RFC 083: Make constants look like variables&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s important to keep in mind the distinction between variables and values. In a pure OO environment, variables are merely references to values, and have no properties of their own&amp;ndash;only the value itself would be able to say whether it is constant. Some values are naturally constant, such as a literal string, while other values could be marked constant, or created without methods that can modify the object, or some such mechanism. In such an environment, there is little use for properties on variables. Any time you put a property on a variable, it&amp;rsquo;s potentially lying about its value.&lt;/p&gt;

&lt;p&gt;However, Perl does not aspire to be a pure OO environment. In Perl-think, a variable is not merely a container for a value. Rather, a variable provides a &amp;ldquo;view&amp;rdquo; of a value. Sometimes that view could even be construed as a lie. That&amp;rsquo;s okay. Lying to yourself is a useful survival skill (except when it&amp;rsquo;s not). We find it necessary to repeat &amp;ldquo;I think I can&amp;rdquo; to ourselves precisely when we think we can&amp;rsquo;t. Conversely, it&amp;rsquo;s often valuable psychologically to treat possible activities as forbidden. Abstinence is easier to practice if you don&amp;rsquo;t have to decide anew every time there&amp;rsquo;s a possible assignation, er, I mean, assignment.&lt;/p&gt;

&lt;p&gt;Constant declarations on variables fall into this category. The value itself may or may not naturally be constant, but we will pretend that it is. We could in theory go farther than that. We could check the associated object to make sure that it is constant, and blow up if it&amp;rsquo;s not, but that&amp;rsquo;s not necessary in this case for consistent semantics. Other properties may be stricter about this. If you have a variable property that asserts a particular shape of multidimensional array, for instance, the object in question had better be able to supply semantics consistent with that view, and it&amp;rsquo;s probably a good idea to blow up sooner rather than later if it can&amp;rsquo;t. This is something like strong typing, except that it&amp;rsquo;s optional, because the variable property itself is optional.&lt;/p&gt;

&lt;p&gt;Nevertheless, the purpose of these variable properties is to allow the compiler to deduce things about the program that it could not otherwise deduce, and based on those deductions, produce both a more robust and more efficient compile-time interpretation of the semantics of the program. That is to say, you can do more optimizations without compromising safety. This is obviously true in the case of inlining constants, but the principle extends to other variable properties as well.&lt;/p&gt;

&lt;p&gt;The proposed syntax is fine, except that we&amp;rsquo;ll be using &lt;code&gt;is&lt;/code&gt; instead of &lt;code&gt;:&lt;/code&gt; for properties, as discussed in Apocalypse 2. (And it&amp;rsquo;s &lt;code&gt;constant&lt;/code&gt;, not &lt;code&gt;const&lt;/code&gt;.)&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-337-html-id-rfc-337-common-attribute-system-to-allow-userdefined-extensible-attributes-rfc-337-common-attribute-system-to-allow-user-defined-extensible-attributes-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/337.html&#34; id=&#34;rfc 337: common attribute system to allow userdefined, extensible attributes&#34;&gt;RFC 337: Common attribute system to allow user-defined, extensible attributes&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;As already revealed in Apocalypse 2, attributes will be known as &amp;ldquo;properties&amp;rdquo; in Perl 6, to avoid confusion with existing OO nomenclature for instance variables. Also, we&amp;rsquo;ll use the &lt;code&gt;is&lt;/code&gt; keyword instead of the colon.&lt;/p&gt;

&lt;p&gt;Setting properties on array and hash elements bothers me, particularly when those properties have names like &amp;ldquo;public&amp;rdquo; and &amp;ldquo;private&amp;rdquo;. This seems to me to be an attempt to paper over the gap of some missing OO functionality. So instead, I&amp;rsquo;d rather keep arrays and hashes mostly for homogenous data structures, and encourage people to use objects to store data of differing types. Then public and private can be properties of object attributes, which will look more like real variables in how they are declared. And we won&amp;rsquo;t have to worry about the meaning of &lt;code&gt;my @foo[2]&lt;/code&gt;, because that still won&amp;rsquo;t be allowed.&lt;/p&gt;

&lt;p&gt;Again, we need to be very clear that the object representing the variable is different than any objects contained by the variable. When we say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Dog @dogpound is loud;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we mean that the individual elements of &lt;code&gt;@dogpound&lt;/code&gt; are of type &lt;code&gt;Dog&lt;/code&gt;, not that the array variable is of type &lt;code&gt;Dog&lt;/code&gt;. But the &lt;code&gt;loud&lt;/code&gt; property applies to the array, not to the dogs in the array. If the array variable needs to have a type, it can be supplied as if it were a property:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Dog @dogpound is DogPound is loud;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is, if a property is the name of a known package/class, it is taken to be a kind of &lt;code&gt;tie&lt;/code&gt;. Given the declaration above, the following is always true:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @dogpound.is.loud
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;since the &lt;code&gt;loud&lt;/code&gt; is a property of the array object, even if it contains no dogs. It turns out that&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @dogpound.is.DogPound
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is also true. This does not do an isa lookup. For that, say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @dogpound.isa(Pound)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that you can use:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @dogpound =~ Dog
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to test the individual elements for Doghood.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S04.html&#34;&gt;Synopsis 04&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-173-html-id-rfc-173-allow-multiple-loop-variables-in-foreach-statements-rfc-173-allow-multiple-loop-variables-in-foreach-statements-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/173.html&#34; id=&#34;rfc 173: allow multiple loop variables in foreach statements&#34;&gt;RFC 173: Allow multiple loop variables in foreach statements&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Unfortunately, the proposed syntax could also be interpreted as parallel traversal:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  foreach ($a, $b) (@a, @b)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also the RFC assumes pairs will be passed as two elements, which is no longer necessarily the case. A hash by itself in list context will return a list of pair objects. We&amp;rsquo;ll need to say something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %hash.kv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to get a flattened list of keys alternating with values. (The same method on arrays produces alternating indices and values.)&lt;/p&gt;

&lt;p&gt;I like the idea of this RFC, but the proposed syntax is not what I&amp;rsquo;d like. There are various possible syntaxes that could also potentially fulfill the intent of RFC 120:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for [$i =&amp;gt; $elem] (@array) { }
    for {$i =&amp;gt; $elem} (@array) { }
    for ($i, $elem) = (@array.kv) { }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But I like the idea of something that feels like repeated binding. We could use the &lt;code&gt;:=&lt;/code&gt; binding operator, but since binding is actually the operation performed by formal parameters of subroutines, and since we&amp;rsquo;d like to keep the list near the &lt;code&gt;for&lt;/code&gt; and the formals near the closure, we&amp;rsquo;ll use a variant of subroutine declaration to declare &lt;code&gt;for&lt;/code&gt; loops:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @list -&amp;gt; $x { ... }         # one value at a time
    for @list -&amp;gt; $a, $b { ... }     # two values at a time
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can un-interleave an array by saying:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @xyxyxy -&amp;gt; $x, $y { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Iterating over multiple lists in parallel needs a syntax much like a multi-dimensional slice. That is, something like a comma that binds looser than a comma. Since we&amp;rsquo;ll be using semicolon for that purpose to delimit the dimensions of multi-dimensional slices, we&amp;rsquo;ll use similar semicolons to delimit a parallel traversal of multiple lists: So parallel arrays could be stepped through like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @xxx; @yyy; @zzz -&amp;gt; $x; $y; $z { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If there are semicolons on the right, there must be the same number as on the left.&lt;/p&gt;

&lt;p&gt;Each &amp;ldquo;stream&amp;rdquo; is considered separately, so you can traverse two arrays each two elements at a time like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @ababab; @cdcdcd -&amp;gt; $a, $b; $c, $d { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If there are no semicolons on the right, the values are taken sequentially across the streams. So you can say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @aaaa; @bbbb -&amp;gt; $a, $b { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and it ends up meaning the same thing as if the comma were a semicolon, but only because the number of variables on the right happens to be the same as the number of streams on the right. That doesn&amp;rsquo;t have to be the case. To get values one at a time across three streams, you can say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @a; @b; @c -&amp;gt; $x { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each semicolon delimited expression on the left is considered to be a list of generated values, so it&amp;rsquo;s perfectly legal to use commas or &amp;ldquo;infinite&amp;rdquo; ranges on the left. The following prints &amp;ldquo;a0&amp;rdquo;, &amp;ldquo;b2&amp;rdquo;, &amp;ldquo;c3&amp;rdquo;, and so on forever (or at least for a very long time):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for 0 .. Inf; &amp;quot;a&amp;quot; .. &amp;quot;z&amp;quot; x 1000 -&amp;gt; $i; $a {
        print &amp;quot;$a$i&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-19-html-id-rfc-019-rename-the-local-operator-rfc-019-rename-the-local-operator-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/19.html&#34; id=&#34;rfc 019: rename the local operator&#34;&gt;RFC 019: Rename the local operator&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ll go with &lt;code&gt;temp&lt;/code&gt; for the temporizing operator.&lt;/p&gt;

&lt;p&gt;In addition, we&amp;rsquo;re going to be storing more global state in objects (such as file objects). So it ought to be possible to temporize (that is, checkpoint/restore) an attribute of an object, or at least any attributes that can be treated as an lvalue.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-64-html-id-rfc-064-new-pragma-39-scope-39-to-change-perl-39-s-default-scoping-rfc-064-new-pragma-scope-to-change-perl-s-default-scoping-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/64.html&#34; id=&#34;rfc 064: new pragma &amp;#39;scope&amp;#39; to change perl&amp;#39;s default scoping&#34;&gt;RFC 064: New pragma &amp;lsquo;scope&amp;rsquo; to change Perl&amp;rsquo;s default scoping&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I can&amp;rsquo;t stop people from experimenting, but I&amp;rsquo;m not terribly interested in performing this experiment myself. I made &lt;code&gt;my&lt;/code&gt; short for a reason. So I&amp;rsquo;m accepting this RFC in principle, but only in principle. Standard Perl declarations will be plainly marked with &lt;code&gt;my&lt;/code&gt; or &lt;code&gt;our&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S04.html&#34;&gt;Synopsis 04&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;span-id-rejected-rfcs-rejected-rfcs-span&#34;&gt;&lt;span id=&#34;rejected rfcs&#34;&gt;Rejected RFCs&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;Just because I&amp;rsquo;ve rejected these RFCs doesn&amp;rsquo;t mean that they weren&amp;rsquo;t addressing at a valid need. Usually an RFC gets rejected simply because I think there&amp;rsquo;s a better way to do it. Often there&amp;rsquo;s little difference between a rejected RFC that I&amp;rsquo;ve borrowed ideas from and an RFC accepted with major caveats.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re already running long, so these descriptions will be terse. Please read the RFC if you don&amp;rsquo;t understand the commentary.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-89-html-id-rfc-089-controllable-data-typing-rfc-089-controllable-data-typing-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/89.html&#34; id=&#34;rfc 089: controllable data typing&#34;&gt;RFC 089: Controllable Data Typing&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;This is pretty close to what we&amp;rsquo;ve been planning for Perl for a long time. However, a number of the specifics are suboptimal.&lt;/p&gt;

&lt;p&gt;If you declare a constant, it&amp;rsquo;s a constant. There&amp;rsquo;s no point in allowing warnings on that by default. It should be fatal to modify a constant. Otherwise you lose all your optimization possibilities.&lt;/p&gt;

&lt;p&gt;For historical reasons, the assignment in&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     my ($a, $b) = new Foo;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will not distribute automatically over &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt;. If you want that, use the &lt;code&gt;^=&lt;/code&gt; hyperassignment instead, maybe.&lt;/p&gt;

&lt;p&gt;Constraint lists are vaguely interesting, but seem to be too much mechanism for the possible benefits. If you really want a data type that can be polymorphic, why not just define a polymorphic type?&lt;/p&gt;

&lt;p&gt;In general, there seems to be a lot of confusion in this RFC between constraints on variables and constraints on values. For constraints to be useful to the compiler, they have to be on the variable, and you can&amp;rsquo;t be &amp;ldquo;pushing&amp;rdquo; constraints at runtime.&lt;/p&gt;

&lt;p&gt;On aliasing via subroutine calls, note that declared parameters will be constant by default.&lt;/p&gt;

&lt;p&gt;So anyway, although I&amp;rsquo;m rejecting this RFC, we&amp;rsquo;ll certainly have a declaration syntax resembling some of the tables in the RFC.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-106-html-id-rfc-106-yet-another-lexical-variable-proposal-lexical-variables-made-default-rfc-106-yet-another-lexical-variable-proposal-lexical-variables-made-default-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/106.html&#34; id=&#34;rfc 106: yet another lexical variable proposal: lexical variables made default&#34;&gt;RFC 106: Yet another lexical variable proposal: lexical variables made default&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Yes, it&amp;rsquo;s true that other widely-admired languages like Ruby do implicit declaration of lexicals, but I think it&amp;rsquo;s a mistake, the results of which don&amp;rsquo;t show up until things start getting complicated. (It&amp;rsquo;s a sign of this weakness that in Ruby you see the workaround of faking up an assignment to force declaration of a variable.)&lt;/p&gt;

&lt;p&gt;I dislike the implicit declaration of lexicals because it tends to defeat the primary use of them, namely, catching typos. It&amp;rsquo;s just too easy to declare additional variable names by accident. It&amp;rsquo;s also too easy to broaden the scope of a variable by accident. You might have a bunch of separate subroutines each with their own lexical, and suddenly find that they&amp;rsquo;re all the same variable because you accidentally used the same variable name in the module initialization code.&lt;/p&gt;

&lt;p&gt;When you think about it, requiring &lt;code&gt;my&lt;/code&gt; on declaration is a form of orthogonality. Otherwise you find your default scoping rules arbitrarily tied to an inner scope, or an outer scope, or a subroutine scope. All of these are suboptimal choices. And I don&amp;rsquo;t buy the notion of using &lt;code&gt;my&lt;/code&gt; optionally to disambiguate when you feel like it. Perl gives you a lot of rope to hang yourself with, but this is the wrong kind of rope, because it obscures a needful visual distinction. Declarations should look like declarations, not just to the programmer, but also to whoever has to read the program after them, whether carbon-based or silicon-based.&lt;/p&gt;

&lt;p&gt;And when it comes down to it, I believe that declarations with &lt;code&gt;my&lt;/code&gt; are properly Huffman encoded. Declaring a lexical ought to be harder than assigning to one. And declaring a global ought to be harder than declaring a lexical (at least within classes and modules).&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-119-html-id-rfc-119-object-neutral-error-handling-via-exceptions-rfc-119-object-neutral-error-handling-via-exceptions-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/119.html&#34; id=&#34;rfc 119: object neutral error handling via exceptions&#34;&gt;RFC 119: Object neutral error handling via exceptions&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Good goals, but I don&amp;rsquo;t want yet another independent system of exception handling. Simplicity comes through unification. Also, the proposed syntax is all just a little too intertwingled for my tastes. Let&amp;rsquo;s see, how can I explain what I mean?&lt;/p&gt;

&lt;p&gt;The out-of-band stuff doesn&amp;rsquo;t stand out visually enough to me, and I don&amp;rsquo;t like thinking about it as control flow. Nevertheless, I think that what we&amp;rsquo;ve ended up with solves a number of the problems pointed out in this RFC. The RFC essentially asks for the functionality of &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;KEEP&lt;/code&gt; and &lt;code&gt;UNDO&lt;/code&gt; at a statement level. Although &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;KEEP&lt;/code&gt;, and &lt;code&gt;UNDO&lt;/code&gt; blocks cannot be attached to any statement, I believe that allowing &lt;code&gt;post&lt;/code&gt;, &lt;code&gt;keep&lt;/code&gt;, and &lt;code&gt;undo&lt;/code&gt; properties in scoped declarations is powerful enough, and gives the compiler something tangible to attach the actions to. There is a kind of precision in attaching these actions to a specific variable&amp;ndash;the state is bound to the variable in a transactionally instantaneous way. I&amp;rsquo;m afraid if we attach transactional actions to statements as the RFC proposes, it won&amp;rsquo;t be clear exactly when the statement&amp;rsquo;s state change is to be considered successful, since the transaction can&amp;rsquo;t &amp;ldquo;know&amp;rdquo; which operation is the crucial one.&lt;/p&gt;

&lt;p&gt;Nonetheless, some ideas from this RFC will live on in the &lt;code&gt;post&lt;/code&gt;, &lt;code&gt;keep&lt;/code&gt;, and &lt;code&gt;undo&lt;/code&gt; property blocks.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-120-html-id-rfc-120-implicit-counter-in-for-statements-possibly-rfc-120-implicit-counter-in-for-statements-possibly-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/120.html&#34; id=&#34;rfc 120: implicit counter in for statements, possibly $#.&#34;&gt;RFC 120: Implicit counter in for statements, possibly $#.&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I am prejudiced against this one, simply because I&amp;rsquo;ve been burned too many times by implicit variables that mandate implicit overhead. I think if you need an index, you should declare one, so that if you don&amp;rsquo;t declare one, the compiler knows not to bother setting up for it.&lt;/p&gt;

&lt;p&gt;Another problem is that people will keep asking what&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for (@foo,@bar) { print $# }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is supposed to mean.&lt;/p&gt;

&lt;p&gt;I expect that we&amp;rsquo;ll end up with something more like what we discussed earlier:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @array.kv -&amp;gt; $i, $elem { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-262-html-id-rfc-262-index-attribute-rfc-262-index-attribute-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/262.html&#34; id=&#34;rfc 262: index attribute&#34;&gt;RFC 262: Index Attribute&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Everyone has a use for &lt;code&gt;:&lt;/code&gt; these days&amp;hellip;&lt;/p&gt;

&lt;p&gt;This one seems not to be of very high utility, suffering from similar problems as the RFC 120 proposal. I don&amp;rsquo;t think it&amp;rsquo;s possible to efficiently track the container of a value within each contained object unless we know at compile time what a looping construct is, which is problematic with user-defined control structures.&lt;/p&gt;

&lt;p&gt;And what if an item is a member of more than one list?&lt;/p&gt;

&lt;p&gt;Again, I&amp;rsquo;d rather have something declared so we know whether to take the overhead. Then we don&amp;rsquo;t have to pessimize whenever we can&amp;rsquo;t do a complete static analysis.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-167-html-id-rfc-167-simplify-do-block-syntax-rfc-167-simplify-do-block-syntax-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/167.html&#34; id=&#34;rfc 167: simplify do block syntax&#34;&gt;RFC 167: Simplify do BLOCK Syntax&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I think the &amp;ldquo;do&amp;rdquo; on a &lt;code&gt;do&lt;/code&gt; block is useful to emphasize that the closure in the braces is to be executed immediately. Otherwise Perl (or the user (or both)) might be confused as to whether someone was trying to write a closure that is to be executed later, particularly if the block is the last item in a subroutine that might be wanting to return a closure. In fact, we&amp;rsquo;ll probably outlaw bare blocks at the statement level as too ambiguous. Use &lt;code&gt;for 1 {}&lt;/code&gt; or some such when you want a one-time loop, and use &lt;code&gt;return&lt;/code&gt; or &lt;code&gt;sub&lt;/code&gt; when you want to return a closure.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll solve the &lt;code&gt;;&lt;/code&gt; problem by jiggering the definition of &lt;code&gt;{...}&lt;/code&gt;, not by fiddling with &lt;code&gt;do&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-209-html-id-rfc-209-fuller-integer-support-in-perl-rfc-209-fuller-integer-support-in-perl-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/209.html&#34; id=&#34;rfc 209: fuller integer support in perl.&#34;&gt;RFC 209: Fuller integer support in Perl.&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;The old &lt;code&gt;use integer&lt;/code&gt; pragma was a hack. I think I&amp;rsquo;d rather use types and representation specs on individual declarations for compile-time selection, or alternate object constructors for run-time selection, particularly when infinite precision is desired. I&amp;rsquo;m not against using pragmas to alter the defaults, but I think it&amp;rsquo;s generally better to be more specific when you have the capability. You can force your programs to be lexically scoped with pragmas, but data wants to flow wherever it likes to go, so your lexically scoped module had better be able to deal rationally with any data thrown at it, even if it isn&amp;rsquo;t in the exact form that you prefer.&lt;/p&gt;

&lt;p&gt;By the way, the RFC is misleading when it asserts that 32-bit integer precision is lost when represented in floating point. That&amp;rsquo;s only true if you use 32-bit floats. Perl has always used 64-bit doubles, which give approximately 15 digits of integer precision. (The issue does arise with 64-bit integers, of course.)&lt;/p&gt;

&lt;p&gt;All that being said, Perl 6 will certainly have better support for integer types of various sorts. I just don&amp;rsquo;t think that a pragma redefining what an &amp;ldquo;integer&amp;rdquo; is will provide good documentation to whoever is trying to understand the program. Better to declare things of type MagicNum, or whatever.&lt;/p&gt;

&lt;p&gt;I could be wrong, of course. If so, write your pragma, and have the appropriate amount of fun.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-279-html-id-rfc-279-my-syntax-extensions-and-attribute-declarations-rfc-279-code-my-code-syntax-extensions-and-attribute-declarations-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/279.html&#34; id=&#34;rfc 279: my() syntax extensions and attribute declarations&#34;&gt;RFC 279: &lt;code&gt;my()&lt;/code&gt; syntax extensions and attribute declarations&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;We already treated this in Apocalypse 2.&lt;/p&gt;

&lt;p&gt;The RFC assumes that the type always distributes over a &lt;code&gt;my&lt;/code&gt; list. This is not what is necessary for function signatures, which need individual types for each formal argument.&lt;/p&gt;

&lt;p&gt;And again, it doesn&amp;rsquo;t make much sense to me to put properties on a variable at run-time.&lt;/p&gt;

&lt;p&gt;It makes even less sense to me to be able to declare the type of an array element lexically. This is the province of objects, not arrays pretending to be structs.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-297-html-id-rfc-297-attributes-for-compiler-hints-rfc-297-attributes-for-compiler-hints-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/297.html&#34; id=&#34;rfc 297: attributes for compiler hints&#34;&gt;RFC 297: Attributes for compiler hints&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Sorry, we can&amp;rsquo;t have the semantics suddenly varying drastically merely because the user decided to run the program through a different translator. I think there&amp;rsquo;s a happy medium in there somewhere where we can have the same semantics for both interpreter and compiler.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-309-html-id-rfc-309-allow-keywords-in-sub-prototypes-rfc-309-allow-keywords-in-sub-prototypes-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/309.html&#34; id=&#34;rfc 309: allow keywords in sub prototypes&#34;&gt;RFC 309: Allow keywords in sub prototypes&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;This RFC is rejected only because it doesn&amp;rsquo;t go far enough. What we&amp;rsquo;ll eventually need is to allow a regex-ish syntax notation for parsing that may be separate from the argument declarations. (Then again, maybe not.) In any event, I think some kind of explicit regex notation is called for, not the promotion of identifiers to token matchers. We may want identifiers in signatures for something else later, so we&amp;rsquo;ll hold them in reserve.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-340-html-id-rfc-340-with-takes-a-context-rfc-340-with-takes-a-context-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/340.html&#34; id=&#34;rfc 340: with takes a context&#34;&gt;RFC 340: with takes a context&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;This seems like a solution in search of a problem. Even if we end up with a context stack as explicit as Perl 5&amp;rsquo;s, I don&amp;rsquo;t think the amount we&amp;rsquo;ll deal with it warrants a keyword. (And I dislike &amp;ldquo;&lt;code&gt;return with;&lt;/code&gt;&amp;rdquo; as a needlessly opaque linguistic construct.)&lt;/p&gt;

&lt;p&gt;That being said, if someone implements (as user-defined code) the Pascalish &lt;code&gt;with&lt;/code&gt; as proposed in RFC 342 (and rejected), and if the &lt;code&gt;caller&lt;/code&gt; function (or something similar) returns sufficient information to build references to the lexical scope associated with the call frame in question, then something like this could also be implemented as user code. I can&amp;rsquo;t decide whether it&amp;rsquo;s not clear that this is a good idea, or it&amp;rsquo;s clear that this is not a good idea. In any event, I would warn anyone doing this that it&amp;rsquo;s likely to be extremely confusing, akin to goto-considered-harmful, and for similar reasons, though in this case by displacing scopes rather than control flow.&lt;/p&gt;

&lt;p&gt;Note that some mechanism resembling this will be necessary for modules to do exportation to a lexical scope (see &lt;code&gt;%MY&lt;/code&gt; in Apocalypse 2). However, lexical scope modification will be allowed only during the compile time of the lexical scope in question, since we need to be careful to preserve the encapsulation that lexical scoping provides. Turning lexical variables back into dynamic variables will tend to destroy that security.&lt;/p&gt;

&lt;p&gt;So I think we&amp;rsquo;ll stick with closures and continuations that don&amp;rsquo;t transport lexical scopes at runtime.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-342-html-id-rfc-342-pascallike-with-rfc-342-pascal-like-quot-with-quot-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/342.html&#34; id=&#34;rfc 342: pascallike with&#34;&gt;RFC 342: Pascal-like &amp;quot;with&amp;quot;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I expect Perl&amp;rsquo;s parsing to be powerful enough that you could write a &amp;ldquo;with&amp;rdquo; if you wanted one.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S04.html&#34;&gt;Synopsis 04&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;span-id-withdrawn-rfcs-withdrawn-rfcs-span&#34;&gt;&lt;span id=&#34;withdrawn rfcs&#34;&gt;Withdrawn RFCs&lt;/span&gt;&lt;/h2&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-63-html-id-rfc-063-exception-handling-syntax-rfc-063-exception-handling-syntax-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/63.html&#34; id=&#34;rfc 063: exception handling syntax&#34;&gt;RFC 063: Exception handling syntax&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-113-html-id-rfc-113-better-constants-and-constant-folding-rfc-113-better-constants-and-constant-folding-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/113.html&#34; id=&#34;rfc 113: better constants and constant folding&#34;&gt;RFC 113: Better constants and constant folding&lt;/a&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;span-id-other-decisions-other-decisions-span&#34;&gt;&lt;span id=&#34;other decisions&#34;&gt;Other decisions&lt;/span&gt;&lt;/h1&gt;

&lt;h3 id=&#34;span-id-cstyle-for-loop-c-style-for-loop-span&#34;&gt;&lt;span id=&#34;cstyle for loop&#34;&gt;C-style for loop&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Due to syntactic ambiguities with the new &lt;code&gt;for&lt;/code&gt; syntax of Perl 6, the generalized C-style &lt;code&gt;for&lt;/code&gt; loop is going to get its keyword changed to &lt;code&gt;loop&lt;/code&gt;. And &lt;code&gt;for&lt;/code&gt; will now always mean &amp;ldquo;foreach&amp;rdquo;. The expression &amp;ldquo;pill&amp;rdquo; is now optional, so instead of writing an infinite loop like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for (;;) {
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you can now write it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    loop {
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-cstyle-do-while-expr-no-longer-supported-c-style-do-while-expr-no-longer-supported-span&#34;&gt;&lt;span id=&#34;cstyle do {} while expr no longer supported&#34;&gt;C-style do {} while EXPR no longer supported&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In Perl 5, when you used a &lt;code&gt;while&lt;/code&gt; statement modifier on a statement consisting of nothing but a &lt;code&gt;do {}&lt;/code&gt;, something magical happened, and the block would be evaluated once before the condition was evaluated. This special-cased construct, seldom used and often misunderstood, will no longer be in Perl 6, and in fact will produce a compile-time error to prevent people from trying to use it. Where Perl 5 code has this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    do {
        ...
    } while CONDITION;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perl 6 code will use a construct in which the control flow is more explicit:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    loop {
        ...
        last unless CONDITION;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-bare-blocks-bare-blocks-span&#34;&gt;&lt;span id=&#34;bare blocks&#34;&gt;Bare blocks&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In Perl 5, bare blocks (blocks used as statements) are once-through loops. In Perl 6, blocks are closures. It would be possible to automatically execute any closure in void context, but unfortunately, when a closure is used as the final statement in an outer block, it&amp;rsquo;s ambiguous as to whether you wanted to return or execute the closure. Therefore the use of a closure at the statement level will be considered an error, whether or not it&amp;rsquo;s in a void context. Use &lt;code&gt;do {}&lt;/code&gt; for a &amp;ldquo;once&amp;rdquo; block, and an explicit &lt;code&gt;return&lt;/code&gt; or &lt;code&gt;sub&lt;/code&gt; when you want to return a reference to the closure.&lt;/p&gt;

&lt;h3 id=&#34;span-id-continue-block-continue-block-span&#34;&gt;&lt;span id=&#34;continue block&#34;&gt;continue block&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;continue&lt;/code&gt; block changes its name to &lt;code&gt;NEXT&lt;/code&gt; and moves inside the block it modifies, to work like &lt;code&gt;POST&lt;/code&gt; blocks. Among other things, this allows &lt;code&gt;NEXT&lt;/code&gt; blocks to refer to lexical variables declared within the loop, provided the &lt;code&gt;NEXT&lt;/code&gt; block is place after them. The generalized loop:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    loop (EXPR1; EXPR2; EXPR3) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;can now be defined as equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    EXPR1;
    while EXPR2 {
        NEXT { EXPR3 }
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(except that any variable declared in &lt;code&gt;EXPR3&lt;/code&gt; would have different lexical scope). The &lt;code&gt;NEXT&lt;/code&gt; block is called only before attempting the next iteration of the loop. It is not called when the loop is done and about to exit. Use a &lt;code&gt;POST&lt;/code&gt; for that.&lt;/p&gt;

&lt;p&gt;Well, that about wraps it up for now. You might be interesting to know that I&amp;rsquo;m posting this from the second sesquiannual Perl Whirl cruise, on board the Veendam, somewhere in the Carribean. If the ship disappears in the Bermuda Triangle, you won&amp;rsquo;t have to worry about the upcoming Exegesis, since Damian is also board. But for now, Perl 6 is cruising along, the weather&amp;rsquo;s wonderful, wish you were here.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

