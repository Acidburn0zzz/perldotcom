<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Language Design on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/language-design/</link>
    <description>Recent content in Language Design on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 27 Oct 2019 12:07:00 +0000</lastBuildDate>
    <atom:link href="/tags/language-design/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>My Perl Wishlist: Invariant Sigils (Part 1)</title>
      <link>http://localhost:1313/article/my-perl-wishlist-invariant-sigils-part-1/</link>
      <pubDate>Sun, 27 Oct 2019 12:07:00 +0000</pubDate>
      
      <guid>http://localhost:1313/article/my-perl-wishlist-invariant-sigils-part-1/</guid>
      <description>

&lt;p&gt;Pop quiz!  Q: What was my mistake in this line?&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;is %HASH{answer}, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;forty-two&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;%HASH properly filled&amp;#39;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A: I had the answer right, but I messed up the sigil on &lt;code&gt;HASH&lt;/code&gt;.  It
should be:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;is $HASH{answer}, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;forty-two&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;%HASH properly filled&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;#  ^ $, not %&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Unfortunately, on Perl v5.20+, both statements work the same way!  I
didn&amp;rsquo;t catch the problem until I shipped this code and
&lt;a href=&#34;http://matrix.cpantesters.org/?dist=vars-i+1.08-TRIAL&#34;&gt;cpantesters&lt;/a&gt;
showed me my mistake.  It was an easy fix, but it reminded me that Perl&amp;rsquo;s
&lt;a href=&#34;http://modernperlbooks.com/books/modern_perl/chapter_03.html#variablenamesandsigils&#34;&gt;variant sigils&lt;/a&gt;
can trip up programmers at any level.  If I could change one thing about
Perl 5, I would change to invariant sigils.&lt;/p&gt;

&lt;h2 id=&#34;the-current-situation&#34;&gt;The current situation&lt;/h2&gt;

&lt;p&gt;In Perl, the sigil tells you
&lt;a href=&#34;https://perldoc.perl.org/perlintro.html#Perl-variable-types&#34;&gt;how many things to expect&lt;/a&gt;.
Scalars such as &lt;code&gt;$foo&lt;/code&gt; are single values.  Any single value in an array
&lt;code&gt;@foo&lt;/code&gt; or hash &lt;code&gt;%foo&lt;/code&gt;, since it is only one thing,
&lt;a href=&#34;https://perldoc.perl.org/perldata.html#Variable-names&#34;&gt;also uses &lt;code&gt;$&lt;/code&gt;&lt;/a&gt;,
so &lt;code&gt;$foo&lt;/code&gt;, &lt;code&gt;@foo&lt;/code&gt;, and &lt;code&gt;%foo&lt;/code&gt; could all refer to different pieces of the
same variable &amp;mdash; or to different variables.
This technique of &amp;ldquo;variant sigils&amp;rdquo; works, but confuses
new Perl users and tripped up yours truly.  To know what you
are accessing in an array or hash, you have to look at both the sigil
and the brackets.  As a reminder:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Sigil&lt;/th&gt;
&lt;th&gt;No brackets&lt;/th&gt;
&lt;th&gt;&lt;code&gt;[ ]&lt;/code&gt; (array access)&lt;/th&gt;
&lt;th&gt;&lt;code&gt;{ }&lt;/code&gt; (hash access)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;$z&lt;/code&gt;: a scalar, i.e., a single value&lt;/td&gt;
&lt;td&gt;&lt;code&gt;$z[0]&lt;/code&gt;: the first element of array &lt;code&gt;@z&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;$z{0}&lt;/code&gt;: the value in hash &lt;code&gt;%z&lt;/code&gt; at key &lt;code&gt;&amp;quot;0&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@z&lt;/code&gt;: An array, i.e., a list of value(s)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@z[0, 1]&lt;/code&gt;: the list &lt;code&gt;($z[0], $z[1])&lt;/code&gt; of two elements from &lt;code&gt;@z&lt;/code&gt; (an &amp;ldquo;array slice&amp;rdquo;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@z{0, &amp;quot;foo&amp;quot;}&lt;/code&gt;: the list &lt;code&gt;($z{0}, $z{foo})&lt;/code&gt; of two elements from hash &lt;code&gt;%z&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%z&lt;/code&gt;: A hash, i.e., a list of key/value pair(s)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%z[0, 1]&lt;/code&gt;: the list &lt;code&gt;(0, $z[0], 1, $z[1])&lt;/code&gt; of keys and two values from array &lt;code&gt;@z&lt;/code&gt; (a &amp;ldquo;hash slice&amp;rdquo;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%z{0, &amp;quot;foo&amp;quot;}&lt;/code&gt;: the list &lt;code&gt;(&amp;quot;0&amp;quot;, $z{0}, &amp;quot;foo&amp;quot;, $z{foo})&lt;/code&gt; of keys and values from hash &lt;code&gt;%z&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;make-the-sigils-part-of-the-name&#34;&gt;Make the sigils part of the name&lt;/h2&gt;

&lt;p&gt;To save myself from repeating my errors, I&amp;rsquo;d like the sigil to be part of a
variable&amp;rsquo;s name.  This is not a new idea; scalars work this way in Perl, bash,
and &lt;a href=&#34;https://docs.perl6.org/language/101-basics#sigil_and_identifier&#34;&gt;Raku&lt;/a&gt;
(&lt;a href=&#34;https://github.com/perl6/problem-solving/blob/master/solutions/language/Path-to-Raku.md&#34;&gt;formerly Perl 6&lt;/a&gt;).
That would make the above table look like:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Sigil&lt;/th&gt;
&lt;th&gt;No brackets&lt;/th&gt;
&lt;th&gt;&lt;code&gt;[ ]&lt;/code&gt; (array access)&lt;/th&gt;
&lt;th&gt;&lt;code&gt;{ }&lt;/code&gt; (hash access)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;$z&lt;/code&gt;: a scalar, i.e., a single value&lt;/td&gt;
&lt;td&gt;&lt;code&gt;$z[0]&lt;/code&gt;: N/A&lt;/td&gt;
&lt;td&gt;&lt;code&gt;$z{0}&lt;/code&gt;: N/A&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@z&lt;/code&gt;: An array, i.e., a list of value(s)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@z[0]&lt;/code&gt;: the first element of &lt;code&gt;@z&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@z{0}&lt;/code&gt;: N/A&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%z&lt;/code&gt;: A hash, i.e., a list of key/value pair(s)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%z[0]&lt;/code&gt;: N/A&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%z{0}&lt;/code&gt;: the value in hash &lt;code&gt;%z&lt;/code&gt; at key &lt;code&gt;0&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Simpler!  Any reference to &lt;code&gt;@z&lt;/code&gt; would always be doing &lt;em&gt;something&lt;/em&gt; with
the array named &lt;code&gt;@z&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;but-what-about-slices&#34;&gt;But what about slices?&lt;/h2&gt;

&lt;p&gt;Slices such as &lt;code&gt;@z[0,1]&lt;/code&gt; and &lt;code&gt;%z{qw(hello there)}&lt;/code&gt; return multiple
values from an array or hash.  If sigils &lt;code&gt;@&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt; are no longer
available for slicing, we need an alternative.
The Perl family currently provides two models: postfix dereferencing
(&amp;ldquo;postderef&amp;rdquo;) syntax and postfix adverbs.&lt;/p&gt;

&lt;p&gt;Perl v5.20+ support
&lt;a href=&#34;https://www.effectiveperlprogramming.com/2014/09/use-postfix-dereferencing/&#34;&gt;postderef&lt;/a&gt;,
which gives us one option.  Postderef separates the name from the slice:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Valid Perl v5.20+&lt;/span&gt;
$hashref&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{a};      &lt;span style=&#34;color:#75715e&#34;&gt;# Scalar, element at index &amp;#34;a&amp;#34; of the hash pointed to by $hashref&lt;/span&gt;
$hashref&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;@{a};     &lt;span style=&#34;color:#75715e&#34;&gt;# List including the &amp;#34;a&amp;#34; element of the hash pointed to by $hashref&lt;/span&gt;
$hashref&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;%{a};     &lt;span style=&#34;color:#75715e&#34;&gt;# List including the key &amp;#34;a&amp;#34; and the &amp;#34;a&amp;#34; element of the hash pointed to by $hashref&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The type of slice comes after the reference, instead of as a sigil
before the reference.  With non-references, that idea would give us slice
syntax such as &lt;code&gt;@array@[1,2,3]&lt;/code&gt; or &lt;code&gt;%hash%{a}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Raku gives us another option: &amp;ldquo;adverbs&amp;rdquo; such as
&lt;a href=&#34;https://docs.perl6.org/language/subscripts#:kv&#34;&gt;&lt;code&gt;:kv&lt;/code&gt;&lt;/a&gt;.  For example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl6&#34; data-lang=&#34;perl6&#34;&gt;# Valid Raku
%hash{&amp;#34;a&amp;#34;}          # Single value, element at index &amp;#34;a&amp;#34; of %hash
%hash{&amp;#34;a&amp;#34;}:v;       # The same --- just the value
%hash{&amp;#34;a&amp;#34;}:kv;      # The list including key &amp;#34;a&amp;#34; and the value of the &amp;#34;a&amp;#34; element of %hash&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The adverb (e.g., &lt;code&gt;:kv&lt;/code&gt;) goes in postfix position, immediately
after the brackets or braces.  Following this model,
slices would look like &lt;code&gt;@array[1,2,3]:l&lt;/code&gt; or &lt;code&gt;%hash{a}:kv&lt;/code&gt;.  (For clarity,
I propose &lt;code&gt;:l&lt;/code&gt;, as in &lt;strong&gt;l&lt;/strong&gt;ist, instead of Raku&amp;rsquo;s &lt;code&gt;:v&lt;/code&gt;.  Raku&amp;rsquo;s &lt;code&gt;:v&lt;/code&gt; can return
a scalar or a list.)&lt;/p&gt;

&lt;p&gt;So, the choices I see are (postderef-inspired / Raku-inspired):&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;What you want&lt;/th&gt;
&lt;th&gt;No subscript&lt;/th&gt;
&lt;th&gt;&lt;code&gt;[ ]&lt;/code&gt; access&lt;/th&gt;
&lt;th&gt;&lt;code&gt;{ }&lt;/code&gt; access&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Scalar&lt;/td&gt;
&lt;td&gt;&lt;code&gt;$z&lt;/code&gt;: a scalar, i.e., a single value&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@z[0]&lt;/code&gt;: a single value from an array&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%z{0}&lt;/code&gt;: the value in hash &lt;code&gt;%z&lt;/code&gt; at key &lt;code&gt;&amp;quot;0&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;List of values&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@z&lt;/code&gt;: an array, i.e., a list of value(s)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@z@[0, 1]&lt;/code&gt; / &lt;code&gt;@z[0, 1]:l&lt;/code&gt;: the list currently written &lt;code&gt;($z[0], $z[1])&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%z@{0, &amp;quot;foo&amp;quot;}&lt;/code&gt; / &lt;code&gt;%z{0, &amp;quot;foo&amp;quot;}:l&lt;/code&gt;: the list currently written &lt;code&gt;($z{0}, $z{foo})&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;List of key/value pairs&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%z&lt;/code&gt;: a hash, i.e., a list of key/value pair(s)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@z%[0, 1]&lt;/code&gt; / &lt;code&gt;@z[0, 1]:kv&lt;/code&gt;: the list currently written &lt;code&gt;(0, $z[0], 1, $z[1])&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%z%{0, &amp;quot;foo&amp;quot;}&lt;/code&gt; / &lt;code&gt;%z{0, &amp;quot;foo&amp;quot;}:kv&lt;/code&gt;: the list currently written &lt;code&gt;(&amp;quot;0&amp;quot;, $z{0}, &amp;quot;foo&amp;quot;, $z{foo})&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;you-can-t-always-get-what-you-want&#34;&gt;You can&amp;rsquo;t always get what you want&lt;/h2&gt;

&lt;p&gt;I prefer the adverb syntax.  It is easy to read, and it draws on
all the expertise that has gone into the design of Raku.
However, my preference has to be implementable.
I&amp;rsquo;m not convinced that it is without major surgery.&lt;/p&gt;

&lt;p&gt;The Perl parser decides how to interpret what is inside the brackets
depending on the context provided by the slice.
The parser interprets the &lt;code&gt;...&lt;/code&gt; in &lt;code&gt;@foo[...]&lt;/code&gt; as
a list (&lt;a href=&#34;https://github.com/Perl/perl5/blob/c58ad1f93e9ad7834d3735683462c07119aa87f5/perly.y#L1143-L1148&#34;&gt;ref&lt;/a&gt;).
In &lt;code&gt;$foo[...]&lt;/code&gt;, the parser sees the &lt;code&gt;...&lt;/code&gt; as a scalar expression
(&lt;a href=&#34;https://github.com/Perl/perl5/blob/c58ad1f93e9ad7834d3735683462c07119aa87f5/perly.y#L958-L960&#34;&gt;ref&lt;/a&gt;).
For any slice syntax, the Perl parser needs to know the desired
type of result while parsing the subscript expression.  The adverb form,
unfortunately, leaves the parser guessing until after the subscript
is parsed.&lt;/p&gt;

&lt;p&gt;You can, in fact, hack the Perl parser to save the subscript
until it sees a postfix adverb.  The parser can then apply the correct
context.  I wrote a
&lt;a href=&#34;https://github.com/Perl/perl5/compare/9786385e68f7f14df6f4dd0f04d2c72c0d9a2511...cxw42:3cd904788536b445c9c3abe9b469e1b569942051&#34;&gt;proof-of-concept&lt;/a&gt;
for &lt;code&gt;@arr[expr]:v&lt;/code&gt;.  It doesn&amp;rsquo;t execute any code, but it does parse
a postfix-adverb slice without crashing!  However, while writing that code,
I ran across a surprise: new syntax isn&amp;rsquo;t tied to a &lt;code&gt;use v5.xx&lt;/code&gt;
directive.&lt;/p&gt;

&lt;p&gt;It turns out the Perl parser lets code written against any Perl version
use the latest syntax.  Both of the following command lines work on Perl v5.30:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ perl -Mstrict -Mwarnings -E &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;my $z; $z-&amp;gt;@* = 10..20&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#                           ^ -E: use all the latest features
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;$ perl -Mstrict -Mwarnings -e &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;my $z; $z-&amp;gt;@* = 10..20&amp;#39;&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;# (!!!)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;#                           ^ -e: not the latest features&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The second command line does not &lt;code&gt;use v5.30&lt;/code&gt;, so you can&amp;rsquo;t use &lt;code&gt;say&lt;/code&gt;
(introduced in v5.10).  However, you can use postderef (from v5.20)!&lt;/p&gt;

&lt;p&gt;Because the parser lets old programs use new syntax, any proposed addition
to Perl&amp;rsquo;s syntax has to be meaningless in all previous Perl versions.
A postfix adverb fails this test.  For example, the following is a valid
Perl program:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;kv&lt;/span&gt; { &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;kv&amp;#34;&lt;/span&gt; }
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @arr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; ? @arr[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]:kv;
        &lt;span style=&#34;color:#75715e&#34;&gt;# ^^^^^^^^^^^^ valid Perl 5 syntax, but not a slice :(&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\n&amp;#34;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;My preferred slice syntax could change the meaning of existing programs,
so it looks like I can&amp;rsquo;t get my first choice.&lt;/p&gt;

&lt;h2 id=&#34;next-steps&#34;&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;This is not the end of the story!  In Part 2, I will dig deeper into
Perl&amp;rsquo;s parser and tokenizer.  I will share some surprises I discovered
while investigating postderef.  I will then describe a possible path
to invariant sigils and the simplicity they can provide.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Programming is Hard, Let&#39;s Go Scripting...</title>
      <link>http://localhost:1313/pub/2007/12/06/soto-11.html/</link>
      <pubDate>Thu, 06 Dec 2007 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2007/12/06/soto-11.html/</guid>
      <description>

&lt;p&gt;I think, to most people, scripting is a lot like obscenity. I can&amp;rsquo;t define it, but I&amp;rsquo;ll know it when I see it. Here are some common memes floating around:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Simple language
    &amp;quot;Everything is a string&amp;quot;
    Rapid prototyping
    Glue language
    Process control
    Compact/concise
    Worse-is-better
    Domain specific
    &amp;quot;Batteries included&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;I don&amp;rsquo;t see any real center here, at least in terms of technology. If I had to pick one metaphor, it&amp;rsquo;d be easy onramps. And a slow lane. Maybe even with some optional fast lanes.&lt;/p&gt;

&lt;h3 id=&#34;easy-onramps&#34;&gt;Easy Onramps&lt;/h3&gt;

&lt;p&gt;But basically, scripting is not a technical term. When we call something a scripting language, we&amp;rsquo;re primarily making a linguistic and cultural judgment, not a technical judgment.&lt;/p&gt;

&lt;p&gt;I see scripting as one of the humanities. It&amp;rsquo;s our linguistic roots showing through. So speaking of roots&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;the-past&#34;&gt;The Past&lt;/h3&gt;

&lt;p&gt;Suppose you went back to Ada Lovelace and asked her the difference between a script and a program. She&amp;rsquo;d probably look at you funny, then say something like: Well, a script is what you give the actors, but a program is what you give the audience. That Ada was one sharp lady&amp;hellip;&lt;/p&gt;

&lt;p&gt;Since her time, we seem to have gotten a bit more confused about what we mean when we say scripting. It confuses even me, and I&amp;rsquo;m supposed to be one of the experts.&lt;/p&gt;

&lt;p&gt;So I&amp;rsquo;m afraid all I can do is give you my own worm&amp;rsquo;s eye view of the past, the present, and the future. Let me warn you that I am not without a few prejudices here and there.&lt;/p&gt;

&lt;h3 id=&#34;basic&#34;&gt;BASIC&lt;/h3&gt;

&lt;p&gt;Now, however it was initially intended, I think BASIC turned out to be one of the first major scripting languages, especially the extended version that DEC put onto its minicomputers called BASIC/PLUS, which happily included recursive functions with arguments. I started out as a BASIC programmer. Some people would say that I&amp;rsquo;m permanently damaged. Some people are undoubtedly right.&lt;/p&gt;

&lt;p&gt;But I&amp;rsquo;m not going to apologize for that. All language designers have their occasional idiosyncracies. I&amp;rsquo;m just better at it than most. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;rsts-basic-plus&#34;&gt;RSTS BASIC/PLUS&lt;/h3&gt;

&lt;p&gt;Anyway, when I was a RSTS programmer on a PDP-11, I certainly treated BASIC as a scripting language, at least in terms of rapid prototyping and process control. I&amp;rsquo;m sure it warped my brain forever. Perl&amp;rsquo;s statement modifiers are straight out of BASIC/PLUS. It even had some cute sigils on the ends of its variables to distinguish string and integer from floating point.&lt;/p&gt;

&lt;p&gt;But you could do extreme programming. In fact, I had a college buddy I did pair programming with. We took a compiler writing class together and studied all that fancy stuff from the dragon book. Then of course the professor announced we would be implementing our own language, called PL/0. After thinking about it a while, we announced that we were going to do our project in BASIC. The professor looked at us like were insane. Nobody else in the class was using BASIC. And you know what? Nobody else in the class finished their compiler either. We not only finished but added I/O extensions, and called it PL 0.5. That&amp;rsquo;s rapid prototyping.&lt;/p&gt;

&lt;h3 id=&#34;unix&#34;&gt;Unix?&lt;/h3&gt;

&lt;p&gt;I remember one day our computer center got a letter from Bell Labs telling us that we could get a tape of Unix V6 for cheap, only $100 because they were coming out shortly with V7. We all looked at each other and said, Why would we ever want to use this thing called Unix? We have RSTS.&lt;/p&gt;

&lt;h3 id=&#34;jam-no-not-that-one&#34;&gt;JAM (no not that one)&lt;/h3&gt;

&lt;p&gt;My first scripting language was written in BASIC. For my job in the computer center I wrote a language that I called JAM, short for Jury-rigged All-purpose Meta-language. Story of my life&amp;hellip;&lt;/p&gt;

&lt;p&gt;JAM was an inside-out text-processing language much like PHP, except that HTML hadn&amp;rsquo;t been invented yet. We mostly used it as a fancy macro processor for BASIC. Unlike PHP, it did not have 3,000 functions in one namespace. We wouldn&amp;rsquo;t have had the memory, for one thing.&lt;/p&gt;

&lt;h3 id=&#34;lisp&#34;&gt;LISP&lt;/h3&gt;

&lt;p&gt;For good or ill, when I went off to grad school, I studied linguistics, so the only computer language I used there was LISP. It was my own personal McCarthy era.&lt;/p&gt;

&lt;p&gt;Is LISP a candidate for a scripting language? While you can certainly write things rapidly in it, I cannot in good conscience call LISP a scripting language. By policy, LISP has never really catered to mere mortals.&lt;/p&gt;

&lt;p&gt;And, of course, mere mortals have never really forgiven LISP for not catering to them.&lt;/p&gt;

&lt;h3 id=&#34;pascal-ada&#34;&gt;Pascal, Ada&lt;/h3&gt;

&lt;p&gt;Once I got into industry, I wrote a compiler in Pascal for a discrete event simulator, and slavered over the forthcoming Ada specs. As a linguist, I don&amp;rsquo;t think of Ada as a big language. Now, English and Japanese, those are big languages. Ada is just a medium-sized language.&lt;/p&gt;

&lt;h3 id=&#34;unix-shell&#34;&gt;Unix, shell&lt;/h3&gt;

&lt;p&gt;After several years I finally became acquainted with Unix and its various scripting languages. OK, to be more precise, BSD, and csh.&lt;/p&gt;

&lt;h3 id=&#34;bsd-csh&#34;&gt;BSD, csh&lt;/h3&gt;

&lt;p&gt;Yeah, yeah, I know. More brain damage&amp;hellip;&lt;/p&gt;

&lt;p&gt;I also learned a little C.&lt;/p&gt;

&lt;h3 id=&#34;c&#34;&gt;C&lt;/h3&gt;

&lt;p&gt;That&amp;rsquo;s because a little C is all there is. I&amp;rsquo;m still learning those libraries though.&lt;/p&gt;

&lt;h3 id=&#34;shell-awk-sed-find-expr&#34;&gt;shell + awk + sed + find + expr&amp;hellip;&lt;/h3&gt;

&lt;p&gt;But the frustrations of Unix shell programming led directly to the creation of Perl, which I don&amp;rsquo;t really have time to tell. But essentially, I found that shell scripting was intrinsically limited by the fact that most of its verbs are not under its control and hence largely inconsistent with each other. And the nouns are impoverished, restricted to strings and files, with who-knows-what typology.&lt;/p&gt;

&lt;h3 id=&#34;c-xor-shell&#34;&gt;C xor shell&lt;/h3&gt;

&lt;p&gt;More destructive was the mindset that it was a one-dimensional universe: you either programmed in C or you programmed in shell, because they&amp;rsquo;re obviously at opposite ends of the One True Continuum. Perl came about when I realized that scripting did not always have to viewed as the opposite of programming, but that a single language could be pretty good for both. That opened up a huge ecological niche. Many of you have seen my old clamshell diagram, with the two dimensions of manipulexity and whipuptitude.&lt;/p&gt;

&lt;h3 id=&#34;tcl&#34;&gt;Tcl&lt;/h3&gt;

&lt;p&gt;After Perl came Tcl, which in a sense is a purer scripting language than Perl. Perl just pretends that everything is a string when it&amp;rsquo;s convenient, but Tcl really believes that as a controlling metaphor. The string metaphor tends to have bad performance ramifications, but that&amp;rsquo;s not why Tcl languished, I think. There were two reasons for that.&lt;/p&gt;

&lt;p&gt;First, Tcl stayed in the Unix mindset that controlling tools was the opposite of creating tools, so they didn&amp;rsquo;t optimize much. The fast parts can always be written in C, after all.&lt;/p&gt;

&lt;p&gt;The second reason was the lack of a decent extension mechanism, so you ended up with separate executables for expect, incr-tcl, etc.&lt;/p&gt;

&lt;p&gt;I must say, though, that I&amp;rsquo;ve always admired Tcl&amp;rsquo;s delegational model of semantics. But it fell into the same trap as LISP by expecting everyone to use the One True Syntax. Speaking of the One True Syntax:&lt;/p&gt;

&lt;h3 id=&#34;python&#34;&gt;Python&lt;/h3&gt;

&lt;p&gt;After Tcl came Python, which in Guido&amp;rsquo;s mind was inspired positively by ABC, but in the Python community&amp;rsquo;s mind was inspired negatively by Perl. I&amp;rsquo;m not terribly qualified to talk about Python however. I don&amp;rsquo;t really know much about Python. I only stole its object system for Perl 5. I have since repented.&lt;/p&gt;

&lt;h3 id=&#34;ruby&#34;&gt;Ruby&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;m much more qualified to talk about Ruby&amp;ndash;that&amp;rsquo;s because a great deal of Ruby&amp;rsquo;s syntax is borrowed from Perl, layered over Smalltalk semantics. I&amp;rsquo;ve always viewed Ruby as a much closer competitor for Perls ecological niche, not just because of the borrowed ideas, but because both Perl and Ruby take their functional programming support rather more seriously that Python does. On the other hand, I think Ruby kind of screwed up on its declaration syntax, among other things.&lt;/p&gt;

&lt;h3 id=&#34;sh&#34;&gt;*sh&lt;/h3&gt;

&lt;p&gt;Meanwhile, the Bourne shell was extended into the Korn shell and bash. I didn&amp;rsquo;t have much to do with those either. Thankfully. I will say that the continued evolution of the shell shows just how crufty a language can get when you just keep adding on ad hoc syntactic features.&lt;/p&gt;

&lt;h3 id=&#34;php&#34;&gt;PHP&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ve also seen the rise of PHP, which takes the worse-is-better approach to dazzling new depths, as it were. By and large PHP seems to be making the same progression of mistakes as early Perl did, only slower. The one thing it does better is packaging. And when I say packaging, I don&amp;rsquo;t mean namespaces.&lt;/p&gt;

&lt;h3 id=&#34;javascript&#34;&gt;JavaScript&lt;/h3&gt;

&lt;p&gt;Then there&amp;rsquo;s JavaScript, a nice clean design. It has some issues, but in the long run JavaScript might actually turn out to be a decent platform for running Perl 6 on. Pugs already has part of a backend for JavaScript, though sadly that has suffered some bitrot in the last year. I think when the new JavaScript engines come out we&amp;rsquo;ll probably see renewed interest in a JavaScript backend.&lt;/p&gt;

&lt;h3 id=&#34;monad-powershell&#34;&gt;Monad/PowerShell&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;ve looked a bit at Microsoft&amp;rsquo;s Monad, and I&amp;rsquo;m pleased to note that it has object pipes like Perl 6. I just hope they don&amp;rsquo;t patent it.&lt;/p&gt;

&lt;h3 id=&#34;lua-applescript&#34;&gt;Lua, AppleScript&lt;/h3&gt;

&lt;p&gt;There are other scripting languages in wide use. Sadly, I must confess I never looked closely at Lua or AppleScript, probably because I&amp;rsquo;m not a game designer with a Mac.&lt;/p&gt;

&lt;p&gt;Actually, I suspect it runs deeper than that, which brings us up to the present time.&lt;/p&gt;

&lt;h3 id=&#34;the-present&#34;&gt;The Present&lt;/h3&gt;

&lt;p&gt;When I look at the present situation, what I see is the various scripting communities behaving a lot like neighboring tribes in the jungle, sometimes trading, sometimes warring, but by and large just keeping out of each other&amp;rsquo;s way in complacent isolation.&lt;/p&gt;

&lt;p&gt;I tend to take an anthropological view of these things. Many of you here are Perl programmers, but some of you come from other programming tribes. And depending on your tribal history, you might think of a string as a pointer to a byte array if you&amp;rsquo;re a C programmer, or as a list if you&amp;rsquo;re a functional programmer, or as an object if you&amp;rsquo;re a Java programmer. I view a string as a Text, with a capital T.&lt;/p&gt;

&lt;h3 id=&#34;text&#34;&gt;Text&lt;/h3&gt;

&lt;p&gt;I read that word from a postmodern perspective. Of course, the term Postmodern is itself context-sensitive. Some folks think Postmodernism means little more than the Empowerment of the Vulgar. Some folks think the same about Perl.&lt;/p&gt;

&lt;p&gt;But I take Postmodernism to mean that a Text, whether spoken or written, is an act of communication requiring intelligence on both ends, and sometimes in the middle too. I don&amp;rsquo;t want to talk to a stupid computer language. I want my computer language to understand the strings I type.&lt;/p&gt;

&lt;p&gt;Perl is a postmodern language, and a lot of conservative folks feel like Postmodernism is a rather liberal notion. So it&amp;rsquo;s rather ironic that my views on Postmodernism were primarily informed by studying linguistics and translation as taught by missionaries, specifically, the Wycliffe Bible Translators. One of the things they hammered home is that there&amp;rsquo;s really no such thing as a primitive human language. By which they mean essentially that all human languages are Turing complete.&lt;/p&gt;

&lt;p&gt;When you go out to so-called primitive tribes and analyze their languages, you find that structurally they&amp;rsquo;re just about as complex as any other human language. Basically, you can say pretty much anything in any human language, if you work at it long enough. Human languages are Turing complete, as it were.&lt;/p&gt;

&lt;p&gt;Human languages therefore differ not so much in what you &lt;em&gt;can&lt;/em&gt; say but in what you &lt;em&gt;must&lt;/em&gt; say. In English, you are forced to differentiate singular from plural. In Japanese, you don&amp;rsquo;t have to distinguish singular from plural, but you do have to pick a specific level of politeness, taking into account not only your degree of respect for the person you&amp;rsquo;re talking to, but also your degree of respect for the person or thing you&amp;rsquo;re talking about.&lt;/p&gt;

&lt;p&gt;So languages differ in what you&amp;rsquo;re forced to say. Obviously, if your language forces you to say something, you can&amp;rsquo;t be concise in that particular dimension using your language. Which brings us back to scripting.&lt;/p&gt;

&lt;p&gt;How many ways are there for different scripting languages to be concise?&lt;/p&gt;

&lt;p&gt;How many recipes for borscht are there in Russia?&lt;/p&gt;

&lt;p&gt;Language designers have many degrees of freedom. I&amp;rsquo;d like to point out just a few of them.&lt;/p&gt;

&lt;h3 id=&#34;early-binding-late-binding&#34;&gt;early binding / late binding&lt;/h3&gt;

&lt;p&gt;Binding in this context is about exactly when you decide which routine you&amp;rsquo;re going to call for a given routine name. In the early days of computing, most binding was done fairly early for efficiency reasons, either at compile time, or at the latest, at link time. You still tend to see this approach in statically typed languages. With languages like Smalltalk, however, we began to see a different trend, and these days most scripting languages are trending towards later binding. That&amp;rsquo;s because scripting languages are trying to be dwimmy (Do What I Mean), and the dwimmiest decision is usually a late decision because you then have more available semantic and even pragmatic context to work with. Otherwise you have to predict the future, which is hard.&lt;/p&gt;

&lt;p&gt;So scripting languages naturally tend to move toward an object-oriented point of view, where the binding doesn&amp;rsquo;t happen &amp;lsquo;til method dispatch time. You can still see the scars of conflict in languages like C++ and Java though. C++ makes the default method type non-virtual, so you have to say virtual explicitly to get late binding. Java has the notion of final classes, which force calls to the class to be bound at compile time, essentially. I think both of those approaches are big mistakes. Perl 6 will make different mistakes. In Perl 6 all methods are virtual by default, and only the application as a whole can tell the optimizer to finalize classes, presumably only after you know how all the classes are going to be used by all the other modules in the program.&lt;/p&gt;

&lt;h3 id=&#34;single-dispatch-multiple-dispatch&#34;&gt;single dispatch / multiple dispatch&lt;/h3&gt;

&lt;p&gt;In a sense, multiple dispatch is a way to delay binding even longer. You not only have to delay binding &amp;lsquo;til you know the type of the object, but you also have to know the types of all rest of the arguments before you can pick a routine to call. Python and Ruby always do single dispatch, while Dylan does multiple dispatch. Here is one dimension in which Perl 6 &lt;em&gt;forces&lt;/em&gt; the caller to be explicit for clarity. I think it&amp;rsquo;s an important distinction for the programmer to bear in mind, because single dispatch and multiple dispatch are philosophically very different ideas, based on different metaphors.&lt;/p&gt;

&lt;p&gt;With single-dispatch languages, you are basically sending a message to an object, and the object decides what to do with that message. With multiple dispatch languages, however, there is no privileged object. All the objects involved in the call have equal weight. So one way to look at multiple dispatch is that the objects are completely passive. But if the objects aren&amp;rsquo;t deciding how to bind, who is?&lt;/p&gt;

&lt;p&gt;Well, it&amp;rsquo;s sort of a democratic thing. All the routines of a given name get together and hold a political conference. (Well, not really, but this is how the metaphor works.) Each of the routines is a delegate to the convention. All the potential candidates put their names in the hat. Then all the routines vote on who the best candidate is, and the next best, and the next best after that. And eventually the routines themselves decide what the best routine to call is.&lt;/p&gt;

&lt;p&gt;So basically, multiple dispatch is like democracy. It&amp;rsquo;s the worst way to do late binding, except for all the others.&lt;/p&gt;

&lt;p&gt;But I really do think that&amp;rsquo;s true, and likely to become truer as time goes on. I&amp;rsquo;m spending a lot of time on this multiple dispatch issue because I think programming in the large is mutating away from the command-and-control model implicit in single dispatch. I think the field of computation as a whole is moving more toward the kinds of decisions that are better made by swarms of insects or schools of fish, where no single individual is in control, but the swarm as a whole has emergent behaviors that are somehow much smarter than any of the individual components.&lt;/p&gt;

&lt;h3 id=&#34;eager-evaluation-lazy-evaluation&#34;&gt;eager evaluation / lazy evaluation&lt;/h3&gt;

&lt;p&gt;Most languages evaluate eagerly, including Perl 5. Some languages evaluate all expressions as lazily as possible. Haskell is a good example of that. It doesn&amp;rsquo;t compute anything until it is forced to. This has the advantage that you can do lots of cool things with infinite lists without running out of memory. Well, at least until someone asks the program to calculate the whole list. Then you&amp;rsquo;re pretty much hosed in any language, unless you have a real Turing machine.&lt;/p&gt;

&lt;p&gt;So anyway, in Perl 6 we&amp;rsquo;re experimenting with a mixture of eager and lazy. Interestingly, the distinction maps very nicely onto Perl 5&amp;rsquo;s concept of scalar context vs. list context. So in Perl 6, scalar context is eager and list context is lazy. By default, of course. You can always force a scalar to be lazy or a list to be eager if you like. But you can say things like &lt;code&gt;for 1..Inf&lt;/code&gt; as long as your loop exits some other way a little bit before you run into infinity.&lt;/p&gt;

&lt;h3 id=&#34;eager-typology-lazy-typology&#34;&gt;eager typology / lazy typology&lt;/h3&gt;

&lt;p&gt;Usually known as static vs. dynamic, but again there are various positions for the adjustment knob. I rather like the gradual typing approach for a number of reasons. Efficiency is one reason. People usually think of strong typing as a reason, but the main reason to put types into Perl 6 turns out not to be strong typing, but rather multiple dispatch. Remember our political convention metaphor? When the various candidates put their names in the hat, what distinguishes them? Well, each candidate has a political platform. The planks in those political platforms are the types of arguments they want to respond to. We all know politicians are only good at responding to the types of arguments they want to have&amp;hellip;&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s another way in which Perl 6 is slightly more lazy than Perl 5. We still have the notion of contexts, but exactly when the contexts are decided has changed. In Perl 5, the compiler usually knows at compile time which arguments will be in scalar context, and which arguments will be in list context. But Perl 6 delays that decision until method binding time, which is conceptually at run time, not at compile time. This might seem like an odd thing to you, but it actually fixes a great number of things that are suboptimal in the design of Perl 5. Prototypes, for instance. And the need for explicit references. And other annoying little things like that, many of which end up as frequently asked questions.&lt;/p&gt;

&lt;h3 id=&#34;limited-structures-rich-structures&#34;&gt;limited structures / rich structures&lt;/h3&gt;

&lt;p&gt;Awk, Lua, and PHP all limit their composite structures to associative arrays. That has both pluses and minuses, but the fact that awk did it that way is one of the reasons that Perl does it differently, and differentiates ordered arrays from unordered hashes. I just think about them differently, and I think a lot of other people do too.&lt;/p&gt;

&lt;h3 id=&#34;symbolic-wordy&#34;&gt;symbolic / wordy&lt;/h3&gt;

&lt;p&gt;Arguably APL is also a kind of scripting language, largely symbolic. At the other extreme we have languages that eschew punctuation in favor of words, such as AppleScript and COBOL, and to a lesser extent all the Algolish languages that use words to indicate blocks where the C-derived languages use curlies. I prefer a balanced approach here, where symbols and identifiers are each doing what theyre best at. I like it when most of the actual words are those chosen by the programmer to represent the problem at hand. I don&amp;rsquo;t like to see words used for mere syntax. Such syntactic functors merely obscure the real words. That&amp;rsquo;s one thing I learned when I switched from Pascal to C. Braces for blocks. It&amp;rsquo;s just right visually.&lt;/p&gt;

&lt;p&gt;Actually, there are languages that do it even worse than COBOL. I remember one Pascal variant that required your keywords to be capitalized so that they would stand out. No, no, no, no, no! You don&amp;rsquo;t want your functors to stand out. It&amp;rsquo;s shouting the wrong words: IF! foo THEN! bar ELSE! baz END! END! END! END!&lt;/p&gt;

&lt;p&gt;Anyway, in Perl 6 we&amp;rsquo;re raising the standard for where we use punctuation, and where we don&amp;rsquo;t. We&amp;rsquo;re getting rid of some of our punctuation that isn&amp;rsquo;t really pulling its weight, such as parentheses around conditional expressions, and most of the punctuational variables. And we&amp;rsquo;re making all the remaining punctuation work harder. Each symbol has to justify its existence according to Huffman coding.&lt;/p&gt;

&lt;p&gt;Oddly, there&amp;rsquo;s one spot where we&amp;rsquo;re introducing new punctuation. After your sigil you can add a twigil, or secondary sigil. Just as a sigil tells you the basic structure of an object, a twigil tells you that a particular variable has a weird scope. This is basically an idea stolen from Ruby, which uses sigils to indicate weird scoping. But by hiding our twigils after our sigils, we get the best of both worlds, plus an extensible twigil system for weird scopes we haven&amp;rsquo;t thought of yet.&lt;/p&gt;

&lt;p&gt;We think about extensibility a lot. We think about languages we don&amp;rsquo;t know how to think about yet. But leaving spaces in the grammar for new languages is kind of like reserving some of our land for national parks and national forests. Or like an archaeologist not digging up half the archaeological site because we know our descendants will have even better analytical tools than we have.&lt;/p&gt;

&lt;p&gt;Really designing a language for the future involves a great deal of humility. As with science, you have to assume that, over the long term, a great deal of what you think is true will turn out not to be quite the case. On the other hand, if you don&amp;rsquo;t make your best guess now, you&amp;rsquo;re not really doing science either. In retrospect, we know APL had too many strange symbols. But we wouldn&amp;rsquo;t be as sure about that if APL hadn&amp;rsquo;t tried it first.&lt;/p&gt;

&lt;h3 id=&#34;compile-time-run-time&#34;&gt;compile time / run time&lt;/h3&gt;

&lt;p&gt;Many dynamic languages can eval code at run time. Perl also takes it the other direction and runs a lot of code at compile time. This can get messy with operational definitions. You don&amp;rsquo;t want to be doing much file I/O in your &lt;code&gt;BEGIN&lt;/code&gt; blocks, for instance. But that leads us to another distinction:&lt;/p&gt;

&lt;h3 id=&#34;declarational-operational&#34;&gt;declarational / operational&lt;/h3&gt;

&lt;p&gt;Most scripting languages are way over there on the operational side. I thought Perl 5 had an oversimplified object system till I saw Lua. In Lua, an object is just a hash, and there&amp;rsquo;s a bit of syntactic sugar to call a hash element if it happens to contain code. Thats all there is. They don&amp;rsquo;t even have classes. Anything resembling inheritance has to be handled by explicit delegation. That&amp;rsquo;s a choice the designers of Lua made to keep the language very small and embeddable. For them, maybe it&amp;rsquo;s the right choice.&lt;/p&gt;

&lt;p&gt;Perl 5 has always been a bit more declarational than either Python or Ruby. I&amp;rsquo;ve always felt strongly that implicit scoping was just asking for trouble, and that scoped variable declarations should be very easy to recognize visually. Thats why we have &lt;code&gt;my&lt;/code&gt;. It&amp;rsquo;s short because I knew we&amp;rsquo;d use it frequently. Huffman coding. Keep common things short, but not too short. In this case, 0 is too short.&lt;/p&gt;

&lt;p&gt;Perl 6 has more different kinds of scopes, so we&amp;rsquo;ll have more declarators like &lt;code&gt;my&lt;/code&gt; and &lt;code&gt;our&lt;/code&gt;. But appearances can be deceiving. While the language looks more declarative on the surface, we make most of the declarations operationally hookable underneath to retain flexibility. When you declare the type of a variable, for instance, you&amp;rsquo;re really just doing a kind of tie, in Perl 5 terms. The main difference is that you&amp;rsquo;re tying the implementation to the variable at compile time rather than run time, which makes things more efficient, or at least potentially optimizable.&lt;/p&gt;

&lt;h3 id=&#34;immutable-classes-mutable-classes&#34;&gt;immutable classes / mutable classes&lt;/h3&gt;

&lt;p&gt;Classes in Java are closed, which is one of the reasons Java can run pretty fast. In contrast, Ruby&amp;rsquo;s classes are open, which means you can add new things to them at any time. Keeping that option open is perhaps one of the reasons Ruby runs so slow. But that flexibility is also why Ruby has Rails.&lt;/p&gt;

&lt;p&gt;Perl 6 will have an interesting mix of immutable generics and mutable classes here, and interesting policies on who is allowed to close classes when. Classes are never allowed to close or finalize themselves, for instance. Sorry, for some reason I keep talking about Perl 6. It could have something to do with the fact that we&amp;rsquo;ve had to think about all of these dimensions in designing Perl 6.&lt;/p&gt;

&lt;h3 id=&#34;class-based-prototype-based&#34;&gt;class-based / prototype-based&lt;/h3&gt;

&lt;p&gt;Here&amp;rsquo;s another dimension that can open up to allow both approaches. Some of you may be familiar with classless languages like Self or JavaScript. Instead of classes, objects just clone from their ancestors or delegate to other objects. For many kinds of modeling, it&amp;rsquo;s actually closer to the way the real world works. Real organisms just copy their DNA when they reproduce. They don&amp;rsquo;t have some DNA of their own, and an &lt;code&gt;@ISA&lt;/code&gt; array telling you which parent objects contain the rest of their DNA.&lt;/p&gt;

&lt;p&gt;The meta-object protocol for Perl 6 defaults to class-based, but is flexible enough to set up prototype-based objects as well. Some of you have played around with &lt;a href=&#34;https://metacpan.org/pod/Moose&#34;&gt;Moose&lt;/a&gt; in Perl 5. Moose is essentially a prototype of Perl 6&amp;rsquo;s object model. On a semantic level, anyway. The syntax is a little different. Hopefully a little more natural in Perl 6.&lt;/p&gt;

&lt;h3 id=&#34;passive-data-global-consistency-active-data-local-consistency&#34;&gt;passive data, global consistency / active data, local consistency&lt;/h3&gt;

&lt;p&gt;Your view of data and control will vary with how functional or object-oriented your brain is. People just think differently. Some people think mathematically, in terms of provable universal truths. Functional programmers don&amp;rsquo;t much care if they strew implicit computation state throughout the stack and heap, as long as everything &lt;em&gt;looks&lt;/em&gt; pure and free from side-effects.&lt;/p&gt;

&lt;p&gt;Other people think socially, in terms of cooperating entities that each have their own free will. And it&amp;rsquo;s pretty important to them that the state of the computation be stored with each individual object, not off in some heap of continuations somewhere.&lt;/p&gt;

&lt;p&gt;Of course, some of us can&amp;rsquo;t make up our minds whether we&amp;rsquo;d rather emulate the logical Sherlock Holmes or sociable Dr. Watson. Fortunately, scripting is not incompatible with either of these approaches, because both approaches can be made more approachable to normal folk.&lt;/p&gt;

&lt;h3 id=&#34;info-hiding-scoping-attachment&#34;&gt;info hiding / scoping / attachment&lt;/h3&gt;

&lt;p&gt;And finally, if you&amp;rsquo;re designing a computer language, there are a couple bazillion ways to encapsulate data. You have to decide which ones are important. What&amp;rsquo;s the best way to let the programmer achieve separation of concerns?&lt;/p&gt;

&lt;h3 id=&#34;object-class-aspect-closure-module-template-trait&#34;&gt;object / class / aspect / closure / module / template / trait&lt;/h3&gt;

&lt;p&gt;You can use any of these various traditional encapsulation mechanisms.&lt;/p&gt;

&lt;h3 id=&#34;transaction-reaction-dynamic-scope&#34;&gt;transaction / reaction / dynamic scope&lt;/h3&gt;

&lt;p&gt;Or you can isolate information to various time-based domains.&lt;/p&gt;

&lt;h3 id=&#34;process-thread-device-environment&#34;&gt;process / thread / device / environment&lt;/h3&gt;

&lt;p&gt;You can attach info to various OS concepts.&lt;/p&gt;

&lt;h3 id=&#34;screen-window-panel-menu-icon&#34;&gt;screen / window / panel / menu / icon&lt;/h3&gt;

&lt;p&gt;You can hide info various places in your GUI. Yeah, yeah, I know, everything is an object. But some objects are more equal than others.&lt;/p&gt;

&lt;h3 id=&#34;syntactic-scope-semantic-scope-pragmatic-scope&#34;&gt;syntactic scope / semantic scope / pragmatic scope&lt;/h3&gt;

&lt;p&gt;Information can attach to various abstractions of your program, including, bizarrely, lexical scopes. Though if you think about it hard enough, you realize lexical scopes are also a funny kind of dynamic scope, or recursion wouldn&amp;rsquo;t work right. A &lt;code&gt;state&lt;/code&gt; variable is actually more purely lexical than a &lt;code&gt;my&lt;/code&gt; variable, because it&amp;rsquo;s shared by all calls to that lexical scope. But even state variables get cloned with closures. Only global variables can be truly lexical, as long as you refer to them only in a given lexical scope. Go figure.&lt;/p&gt;

&lt;p&gt;So really, most of our scopes are semantic scopes that happen to be attached to a particular syntactic scope.&lt;/p&gt;

&lt;p&gt;You may be wondering what I mean by a &lt;em&gt;pragmatic&lt;/em&gt; scope. That&amp;rsquo;s the scope of what the user of the program is storing in their brain, or in some surrogate for their brain, such as a game cartridge. In a sense, most of the web pages out there on the Internet are part of the pragmatic scope. As is most of the data in databases. The hallmark of the pragmatic scope is that you really don&amp;rsquo;t know the lifetime of the container. It&amp;rsquo;s just out there somewhere, and will eventually be collected by that Great Garbage Collector that collects all information that anyone forgets to remember. The Google cache can only last so long. Eventually we will forget the meaning of every URL. But we must not forget the &lt;em&gt;principle&lt;/em&gt; of the URL. That leads us to our next degree of freedom.&lt;/p&gt;

&lt;h3 id=&#34;use-lingua-perligata&#34;&gt;use Lingua::Perligata;&lt;/h3&gt;

&lt;p&gt;If you allow a language to mutate its own grammar within a lexical scope, how do you keep track of that cleanly? Perl 5 discovered one really bad way to do it, namely source filters, but even so we ended up with Perl dialects such as Perligata and Klingon. What would it be like if we actually did it right?&lt;/p&gt;

&lt;p&gt;Doing it right involves treating the evolution of the language as a pragmatic scope, or as a set of pragmatic scopes. You have to be able to name your dialect, kind of like a URL, so there needs to be a universal root language, and ways of warping that universal root language into whatever dialect you like. This is actually near the heart of the vision for Perl 6. We don&amp;rsquo;t see Perl 6 as a single language, but as the root for a family of related languages. As a family, there are shared cultural values that can be passed back and forth among sibling languages as well as to the descendants.&lt;/p&gt;

&lt;p&gt;I hope you&amp;rsquo;re all scared stiff by all these degrees of freedom. I&amp;rsquo;m sure there are other dimensions that are even scarier.&lt;/p&gt;

&lt;p&gt;But&amp;hellip; I think its a manageable problem. I think its possible to still think of Perl 6 as a scripting language, with easy onramps.&lt;/p&gt;

&lt;p&gt;And the reason I think its manageable is because, for each of these dimensions, it&amp;rsquo;s not just a binary decision, but a knob that can be positioned at design time, compile time, or even run time. For a given dimension X, different scripting languages make different choices, set the knob at different locations.&lt;/p&gt;

&lt;h3 id=&#34;you-can-t-even-think-about-x&#34;&gt;You can&amp;rsquo;t even think about X!&lt;/h3&gt;

&lt;p&gt;There&amp;rsquo;s only one way to do X!
There&amp;rsquo;s more than one way to do X!
There are too many ways to do X!&lt;/p&gt;

&lt;p&gt;You may recognize some slogans in here.&lt;/p&gt;

&lt;h3 id=&#34;curling-up&#34;&gt;Curling Up&lt;/h3&gt;

&lt;p&gt;So I&amp;rsquo;m not suggesting that all scripting languages have to take all these dimensions into account, even if Perl 6 tries to. The scripting paradigm is not any one of these dimensions. According to various theories the universe may be laid out in ten or twenty dimensions, but generally we get by with only about three and a half of those dimensions. The rest are said to be curled up. Maybe we live in a scripting universe.&lt;/p&gt;

&lt;p&gt;Most of the scripting languages we call Perl 6 will have most of these dimensions curled up most of the time. But unlike the real universe, where it takes huge machines to uncurl these dimensions, we&amp;rsquo;ll make the dimensions uncurl just by keeping our declarations straight. Well, we&amp;rsquo;ll try. And where that fails, we&amp;rsquo;ll rely on the culture to keep things straight.&lt;/p&gt;

&lt;p&gt;For example, that&amp;rsquo;s exactly what happened already with Perl 5. We have the declarations, &lt;code&gt;use strict; use warnings;&lt;/code&gt;. But it&amp;rsquo;s the culture that decided to enforce the use of them. So much so that we&amp;rsquo;ve decided that they should be the default for most of Perl 6. It was one of those decisions by the hive. In this case the swarm turned out to be smarter than the language designer. And that&amp;rsquo;s as it should be.&lt;/p&gt;

&lt;h3 id=&#34;the-future&#34;&gt;The Future&lt;/h3&gt;

&lt;p&gt;Well, so what&amp;rsquo;s the future of scripting?&lt;/p&gt;

&lt;p&gt;In my completely unbiased opinion, that would be Perl 6. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Seriously though, it&amp;rsquo;s always safe to predict that the ecological landscape will end up with many small languages and a few dominant ones. Some languages like AppleScript have particular ecological niches and are unlikely to grow out of them. Other languages get used outside their original niche. There will always be the generalists, like crows and mockingbirds, and the specialists, like penguins and dodos. (Well, maybe not always the dodos&amp;hellip;)&lt;/p&gt;

&lt;p&gt;Among the generalists, the conventional wisdom is that the worse-is-better approach is more adaptive. Personally, I get a little tired of the argument: My worse-is-better is better than your worse-is-better because I&amp;rsquo;m better at being worser! Is it really true that the worse-is-better approach always wins? With Perl 6 we&amp;rsquo;re trying to sneak one better-is-better cycle in there and hope to come out ahead before reverting to the tried and true worse-is-better approach. Whether that works, only time will tell.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>What Is Perl 6</title>
      <link>http://localhost:1313/pub/2006/01/12/what_is_perl_6.html/</link>
      <pubDate>Thu, 12 Jan 2006 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2006/01/12/what_is_perl_6.html/</guid>
      <description>

&lt;p&gt;Perl 6 is the long-awaited redesign and reimplementation of the popular and venerable Perl programming language. It&amp;rsquo;s not out yet&amp;ndash;nor is there an official release date&amp;ndash;but the design and implementations make continual progress.&lt;/p&gt;

&lt;h3 id=&#34;why-perl-6&#34;&gt;Why Perl 6&lt;/h3&gt;

&lt;p&gt;Innumerable programmers, hackers, system administrators, hobbyists, and dabblers write Perl 5 quite successfully. The language doesn&amp;rsquo;t have the marketing budget of large consulting companies, hardware manufacturers, or tool vendors pushing it, yet people still use it to get their jobs done.&lt;/p&gt;

&lt;p&gt;Why argue with that success? Why redesign a language that&amp;rsquo;s working for so many people and in so many domains? Sure, Perl 5 has some warts, but it does a lot of things very well.&lt;/p&gt;

&lt;h4 id=&#34;what-s-right-with-perl-5&#34;&gt;What&amp;rsquo;s Right with Perl 5&lt;/h4&gt;

&lt;p&gt;As Adam Turoff explained once, &lt;a href=&#34;http://use.perl.org/~ziggy/journal/26131&#34;&gt;Perl has two subtle advantages: &lt;em&gt;manipulexity&lt;/em&gt; and &lt;em&gt;whipuptitude&lt;/em&gt;&lt;/a&gt;. It&amp;rsquo;s very important to be able to solve the problem at hand simply and easily without languages and tools and syntax getting in your way. That&amp;rsquo;s whipuptitude. Manipulexity is the ability to use simple tools and build a sufficiently complex solution to a complex problem.&lt;/p&gt;

&lt;p&gt;Not everyone who starts learning Perl for whipuptitude needs manipulexity right away, if ever, but having a tool that supports both is amazingly useful. That&amp;rsquo;s where Perl&amp;rsquo;s always aimed&amp;ndash;making the easy things easy and the hard things possible, even if you don&amp;rsquo;t traditionally think of yourself as a programmer.&lt;/p&gt;

&lt;p&gt;Many of Perl 5&amp;rsquo;s other benefits fall out from this philosophy. For example, though the popular conception is that Perl 5 is mostly a procedural language, there are plenty of functional programming features available&amp;ndash;iterators, higher-order functions, lexical closures, filters, and more. The (admittedly minimal) object system also has a surprising amount of flexibility. Several CPAN modules provide various types of encapsulation, access control, and dispatch. There are even refinements of the object system itself, exploring such techniques as prototype-based refinement, mixins, and traits.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s more than one way to do it, but many of those ways are freely available and freely usable from the CPAN. The premier repository system of Perl libraries and components contains thousands of modules, from simple packagings of common idioms to huge interfaces to graphical packages, databases, and web servers. With few exceptions, the community of CPAN contributors have solved nearly any common problem you can think of (and many uncommon ones, too).&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s difficult to say whether Perl excels as a glue language because of the CPAN or that CPAN has succeeded because Perl excels as a glue language, but being able to munge data between two other programs, processes, libraries, or machines is highly useful. Perl&amp;rsquo;s text processing powers have few peers. Sure, you &lt;em&gt;can&lt;/em&gt; build the single perfect command-line consisting of several small CLI utilities, but it&amp;rsquo;s rare to do it more cleanly or concisely than with Perl.&lt;/p&gt;

&lt;h4 id=&#34;what-s-wrong-with-perl-5&#34;&gt;What&amp;rsquo;s Wrong with Perl 5&lt;/h4&gt;

&lt;p&gt;Perl 5 isn&amp;rsquo;t perfect, though, and some of its flaws are more apparent the closer Perl 6 comes to completion.&lt;/p&gt;

&lt;p&gt;Perhaps the biggest imperfection of Perl 5 is its internals. Though much of the design is clever, there are also places of obsolescence and interdependence, as well as optimizations that no one remembers, but no one can delete without affecting too many other parts of the system. Refactoring an eleven-plus-year-old software project that runs on seventy-odd platforms and has to retain backwards compatibility with itself on many levels is daunting, and there are few people qualified to do it. It&amp;rsquo;s also exceedingly difficult to recruit new people for such a task.&lt;/p&gt;

&lt;p&gt;Backwards compatibility in general hampers Perl 5 in other ways. Even though stability of interface and behavior is good in many ways, baking in an almost-right idea makes it difficult to sell people on the absolutely right idea later, especially if it takes years to discover what the true solution really is. For example, the long-deprecated and long-denigrated pseudohash feature was, partly, a way to improve object orientation. However, the Perl 6 approach (using opaque objects) solves the same problem without introducing the complexity and performance problems that pseudohashes did.&lt;/p&gt;

&lt;p&gt;As another example, it&amp;rsquo;s much too late to remove formats from Perl 5 without breaking backwards compatibility from Perl 1. However, using formats requires the use of global variables (or scary trickery), with all of the associated maintainability and encapsulation problems.&lt;/p&gt;

&lt;p&gt;This points to one of the most subtle flaws of Perl 5: its single implementation is its specification. Certainly there is a growing test suite that explores Perl&amp;rsquo;s behavior in known situations, but too many of these tests exist to ensure that no one accidentally breaks an obscure feature of a particular implementation that no one really thought about but someone somewhere relies on in an important piece of code. You &lt;em&gt;could&lt;/em&gt; recreate Perl from its tests&amp;ndash;after a fashion.&lt;/p&gt;

&lt;p&gt;Perl 6 will likely also use its test suite as its primary specification, but as Larry Wall puts it, &amp;ldquo;We&amp;rsquo;re just trying to start with the right tests this time.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Even if the Perl 5 codebase &lt;em&gt;did&lt;/em&gt; follow a specification, its design is inelegant in many places. It&amp;rsquo;s also very difficult to expand. Many good ideas that would make code easier to write and maintain are too impractical to support. It&amp;rsquo;s a good prototype, but it&amp;rsquo;s not code that you would want to keep if you had the option to do something different.&lt;/p&gt;

&lt;p&gt;From the language level, there are a few inconsistencies, as well. For example, why should sigils change depending on how you access internal data? (The canonical answer is &amp;ldquo;To specify context of the access,&amp;rdquo; but there are other ways to mark the same.) When is a block a block, and when is it a hash reference? Why does &lt;code&gt;SUPER&lt;/code&gt; method redispatch not respect the currently dispatched class of the invocant, but only the compiled class? How can you tell the indirect object notation&amp;rsquo;s method name barewords from bareword class or function names?&lt;/p&gt;

&lt;p&gt;It can be difficult to decide whether the problem with a certain feature is in the design or the implementation. Consider the desire to replace a built-in data structure with a user-defined object. Perl 5 requires you to use &lt;code&gt;tie&lt;/code&gt; and &lt;code&gt;overload&lt;/code&gt; to do so. To make this work, the internals check special flags on &lt;em&gt;every&lt;/em&gt; data structure in &lt;em&gt;every&lt;/em&gt; opcode to see if the current item has any magical behavior. This is ugly, slow, inflexible, and difficult to understand.&lt;/p&gt;

&lt;p&gt;The Perl 6 solution is to allow multi-method dispatch, which not only removes conceptual complexity (at least, MMD is easier to explain than &lt;code&gt;tie&lt;/code&gt;) but also provides the possibility of a cleaner implementation.&lt;/p&gt;

&lt;p&gt;Perl&amp;rsquo;s flexibility sometimes makes life difficult. In particular, there being multiple more-or-less equivalent ways to create objects gives people plenty of opportunities to do clever things they need to do, but it also means that people tend to choose the easiest (or sometimes cleverest) way to do something, not necessarily the best way to do something. It&amp;rsquo;s not Perlish to allow only one way to perform a task, but there&amp;rsquo;s no reason not to provide one really good and easy way to do something while providing the proper hooks and safety outlets to customize the solution cleanly.&lt;/p&gt;

&lt;p&gt;Also, there are plenty of language optimizations that turned out to be wrong in the long term. Many of them were conventions&amp;ndash;from pre-existing &lt;code&gt;awk&lt;/code&gt;, shell, Unix, and regular expression cultures&amp;ndash;that gave early Perl a familiarity and aided its initial growth. Yet now that Perl stands on its own, they can seem counter-productive.&lt;/p&gt;

&lt;p&gt;Redesigning Perl means asking a lot of questions. Why is the method call operator two characters (one shifted), not a single dot? Why are strictures disabled by default in programs, not one-liners? Why does dereferencing a reference take so many characters? (Perl 5 overloaded curly braces in six different ways. If you can list four, you&amp;rsquo;re doing well.) Why is evaluating a non-scalar container in scalar context so much less useful than it could be?&lt;/p&gt;

&lt;p&gt;Once you accept that backwards compatibility is standing in the way of progress and resolve to change things for the better, you have a lot of opportunities to fix design and implementation decisions that turn out to have been bad&amp;ndash;or at least, not completely correct.&lt;/p&gt;

&lt;h3 id=&#34;advantages-of-perl-6&#34;&gt;Advantages of Perl 6&lt;/h3&gt;

&lt;p&gt;In exchange for breaking backwards compatibility, at least at the language level, Perl 6 offers plenty of high-powered language concepts that Perl 5 didn&amp;rsquo;t support, including:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://c2.com/cgi-bin/wiki?MultiMethods&#34;&gt;Multimethods&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://c2.com/cgi-bin/wiki?CoRoutine&#34;&gt;Coroutines&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Continuation&#34;&gt;Continuations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Useful threading&lt;/li&gt;
&lt;li&gt;Junctions&lt;/li&gt;
&lt;li&gt;Roles&lt;/li&gt;
&lt;li&gt;Hyperoperators&lt;/li&gt;
&lt;li&gt;Macros&lt;/li&gt;
&lt;li&gt;An overridable and reusable grammar&lt;/li&gt;
&lt;li&gt;Garbage collection&lt;/li&gt;
&lt;li&gt;Improved &lt;a href=&#34;http://c2.com/cgi-bin/wiki?ForeignFunctionInterface&#34;&gt;foreign function interface&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Module aliasing and versioning&lt;/li&gt;
&lt;li&gt;Improved introspection&lt;/li&gt;
&lt;li&gt;Extensible and overridable primitives&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;better-internals&#34;&gt;Better Internals&lt;/h4&gt;

&lt;p&gt;The &lt;a href=&#34;http://www.parrotcode.org/&#34;&gt;Parrot project&lt;/a&gt;, led by designer Chip Salzenberg and pumpking Leo Toetsch, is producing the new virtual machine for the official Perl 6 release.&lt;/p&gt;

&lt;p&gt;Parrot is a new design and implementation not specifically tied to Perl 6. Its goal is to run almost any dynamic language efficiently. Because many of the designers have plenty of experience with the Perl 5 internals, Parrot tries to avoid the common mistakes and drawbacks there. One of the first and most important design decisions is extracting the logic of overridden container behavior from opcodes into the containers themselves. That is, where you might have a tied hash in Perl 5, all of the opcodes that deal with hashes have to check that the hash received is tied. In Parrot, each hash has a specific interface and all of the opcodes expect the PMC that they receive to implement that interface. (This is the standard &amp;ldquo;Replace conditional with polymorphism&amp;rdquo; refactoring.)&lt;/p&gt;

&lt;h4 id=&#34;better-object-orientation&#34;&gt;Better Object Orientation&lt;/h4&gt;

&lt;p&gt;The de facto OO technique in Perl 5 is blessing a hash and accessing the hash&amp;rsquo;s members directly as attributes. This is quick and easy, but it has encapsulation, substitutability, and namespace clashing problems. Those problems all have solutions: witness several competing CPAN modules that solve them.&lt;/p&gt;

&lt;p&gt;Perl 6 instead provides opaque objects by default, with language support for creating classes and instances and declaring class and instance attributes. It also provides multiple ways to customize class and object behavior, from instantiation to destruction. Where 95 percent of objects can happily use the defaults, the 5 percent customized classes will still work with the rest of the world.&lt;/p&gt;

&lt;p&gt;Another compelling feature is language support for roles&amp;ndash;this is a different way of describing and encapsulating specific behavior for objects apart from inheritance or mixins. In brief, a role encapsulates behavior that multiple classes can perform, so that a function or method signature can expect an object that does a role, rather than an object that inherits from a particular abstract base class. This has powerful effects on polymorphism and genericity. Having role support in the language and the core library will make large object-oriented systems easier to write and to maintain.&lt;/p&gt;

&lt;h4 id=&#34;improved-consistency&#34;&gt;Improved Consistency&lt;/h4&gt;

&lt;p&gt;Sigils, the funny little markers at the start of variables, are invariant.&lt;/p&gt;

&lt;p&gt;Return codes make sense, especially in exceptional cases.&lt;/p&gt;

&lt;p&gt;Similar things look similar. Different things look different. Weird things look weird.&lt;/p&gt;

&lt;p&gt;All blocks are closures; all closures are first-class data structures on which you can set or query properties, for example.&lt;/p&gt;

&lt;h4 id=&#34;rules-and-grammars&#34;&gt;Rules and Grammars&lt;/h4&gt;

&lt;p&gt;One of Perl 5&amp;rsquo;s most useful features is integrated regular expression support&amp;ndash;except they&amp;rsquo;re not all that regular anymore. Nearly every problem Perl 5 has in the whole (inconsistency, wrong shortcuts, difficult reusability, inflexible and impenetrable internals) shows up in the syntax and implementation of regular expressions.&lt;/p&gt;

&lt;p&gt;Perl 6 simplifies regular expressions while adding more power, producing rules. You can reuse and combine rules to produce a grammar. If you apply a grammar to text (or, perhaps, any type of input including a recursive data structure), you receive a match tree.&lt;/p&gt;

&lt;p&gt;That sounds quite a bit like what a parser and lexer do&amp;ndash;so there&amp;rsquo;s little surprise that Perl 6 has its own locally overridable grammar that allows you to make your own syntax changes and redefine the language when you really need to. Perl 5 supported a similar feature (source filters), but it was fragile, hard to use, and even harder to re-use in serious programs.&lt;/p&gt;

&lt;p&gt;By making a clean break from regular expressions, the designers had the opportunity to re-examine the regex syntax. The new syntax is more consistent, so it&amp;rsquo;s easier to type and to remember the syntaxes of common operations. There&amp;rsquo;s also more consistency, so that similar features look similar.&lt;/p&gt;

&lt;p&gt;Perl 6 has a Perl 5 compatibility layer, if you prefer quick and dirty and familiar&amp;ndash;but give the new syntax a try, especially for projects where quick and dirty regular expressions were intractable (more than usual, anyway).&lt;/p&gt;

&lt;h3 id=&#34;where-is-it-already&#34;&gt;Where is it Already?&lt;/h3&gt;

&lt;p&gt;Larry announced the Perl 6 project at OSCON in 2000. Why is it taking so long? There are several reasons.&lt;/p&gt;

&lt;p&gt;First, Perl 5 isn&amp;rsquo;t going anywhere. If anything, the rate of patches and changes to the code has increased. Cleanups from Ponie and the &lt;a href=&#34;http://qa.perl.org/phalanx/&#34;&gt;Phalanx project&lt;/a&gt; continue to improve the design and implementation, and new features from Perl 6 are making their way into Perl 5.&lt;/p&gt;

&lt;p&gt;Second, the opportunity to do the right thing without fear of breaking backwards compatibility opened up a lot of possibilities for impressive new features. Reinventing regular expressions as rules and grammars, for example, would have been difficult while retaining the flavor and syntax of &lt;code&gt;awk&lt;/code&gt; and Henry Spencer&amp;rsquo;s original implementations. The new power and consistency makes rules well worth the reinvention.&lt;/p&gt;

&lt;p&gt;Third, the project is still a volunteer project. Though other languages and platforms have major corporate support, only a handful of Perl 6 hackers receive any form of funding to work on the project&amp;ndash;and none of them on a full-time basis.&lt;/p&gt;

&lt;p&gt;If you want to write actual, working Perl 6 code, it&amp;rsquo;s possible. Pugs has been able to run quite a bit of the language since last summer. It will soon connect directly to Parrot again. When that happens, watch out!&lt;/p&gt;

&lt;h3 id=&#34;learning-more&#34;&gt;Learning More&lt;/h3&gt;

&lt;p&gt;This article is merely an overview of some of the reasons for and features of Perl 6. There are plenty of details available online in writings of the designers, the mailing lists, and the source code repositories.&lt;/p&gt;

&lt;h4 id=&#34;design-documents&#34;&gt;Design Documents&lt;/h4&gt;

&lt;p&gt;The &lt;a href=&#34;http://dev.perl.org/perl6/&#34;&gt;Perl 6 home page&lt;/a&gt; holds links to most of the design documents for the language. In particular, Larry&amp;rsquo;s &lt;a href=&#34;http://dev.perl.org/perl6/doc/apocalypse.html&#34;&gt;Perl 6 Apocalypses&lt;/a&gt; explore a subject area in depth, identifying the problem and outlining his thinking about what the solution might be. Damian Conway&amp;rsquo;s &lt;a href=&#34;http://dev.perl.org/perl6/doc/exegesis.html&#34;&gt;Perl 6 Exegeses&lt;/a&gt; expand upon the idea, showing concrete examples written in actual Perl 6 code.&lt;/p&gt;

&lt;p&gt;In the past several months, the design team has started to update the &lt;a href=&#34;http://dev.perl.org/perl6/doc/synopsis.html&#34;&gt;Perl 6 Synopses&lt;/a&gt; instead. Perl 6 pumpking Patrick Michaud keeps these fresh with the current design. The Apocalypses and Exegeses remain online as interesting historical documents that take too long to write and revise as changes occur.&lt;/p&gt;

&lt;h4 id=&#34;implementations&#34;&gt;Implementations&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://www.parrotcode.org/&#34;&gt;Parrot&lt;/a&gt; has monthly releases. The Parrot distribution includes the Parrot Grammar Engine (PGE), which is Patrick&amp;rsquo;s implementation of rules and grammars, as well as several languages that target Parrot. The most complete implementation is for Tcl, though the Punie project (Perl 1 on Parrot) shows the entire suite of compiler tools.&lt;/p&gt;

&lt;p&gt;Audrey (nee Autrijus) Tang&amp;rsquo;s &lt;a href=&#34;http://www.pugscode.org/&#34;&gt;Pugs&lt;/a&gt; is an unofficial Perl 6 implementation, optimized for fun. As of the time of the writing, it supported much of Perl 6, including junctions, multimethods, and objects. It targets multiple back-ends, including Haskell, JavaScript, Perl 5, and Parrot, and moves very quickly. Pugs is a great project in which to participate&amp;ndash;it&amp;rsquo;s very easy to get a committer bit and start writing tests and fixing bugs. It&amp;rsquo;s currently the main prototype and reference implementation. Time will tell what its role is in the final release.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.poniecode.org/&#34;&gt;Ponie&lt;/a&gt; is a port of Perl 5 to Parrot. It&amp;rsquo;s a huge refactoring project with little glory but a lot of potential usefulness. C hackers are more than welcome.&lt;/p&gt;

&lt;h4 id=&#34;discussion&#34;&gt;Discussion&lt;/h4&gt;

&lt;p&gt;Most development discussion takes place on several &lt;a href=&#34;http://dev.perl.org/perl6/lists/&#34;&gt;Perl 6 mailing lists&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;discusses Perl 6, the language and features.&lt;/li&gt;
&lt;li&gt;discusses the design and implementation of Parrot and various languages targeting Parrot.&lt;/li&gt;
&lt;li&gt;discusses PGE, Pugs, and the interaction of various components of the compiler tools.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code&gt;#perl6&lt;/code&gt; IRC channel on &lt;a href=&#34;http://irc.freenode.net/&#34;&gt;irc.freenode.net&lt;/a&gt; talks about Pugs and Perl 6, while &lt;code&gt;#parrot&lt;/code&gt; on &lt;a href=&#34;http://irc.perl.org/&#34;&gt;irc.perl.org&lt;/a&gt; concentrates on Parrot. There is almost always someone around in &lt;code&gt;#perl6&lt;/code&gt; to answer questions about Pugs or Perl 6.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://planetsix.perl.org/&#34;&gt;Planet Perl Six&lt;/a&gt; aggregates weblogs from several designers and developers of various related projects.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

