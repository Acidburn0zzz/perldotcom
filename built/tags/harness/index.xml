<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Harness on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/harness/</link>
    <description>Recent content in Harness on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 07 May 2004 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/harness/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Building Testing Libraries</title>
      <link>http://localhost:1313/pub/2004/05/07/testing.html/</link>
      <pubDate>Fri, 07 May 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/05/07/testing.html/</guid>
      <description>

&lt;p&gt;Testing is an important step in developing any important body of work. In today&amp;rsquo;s pragmatic culture, we&amp;rsquo;re taught to test first, test often, and design with tests. The expectation is that chanting &amp;ldquo;test test test&amp;rdquo; forgives all sins. To a large extent, this is true. Testing helps us produce quality software at all scales.&lt;/p&gt;

&lt;p&gt;The extreme code produced by this extreme lifestyle hides in the test suite itself. Often the ugliest code we write resides in files with a .t extension. Riddled with redundant, ghastly expressions, the test suite is the collateral damage on our road to beautiful production code.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s review some common pitfalls made when testing. Many of these testing procedures may be new to you. Serious headway has been made in recent history with the testing libraries on the CPAN.&lt;/p&gt;

&lt;h3 id=&#34;span-id-a-test-file-is-just-a-program-a-test-file-is-just-a-program-span&#34;&gt;&lt;span id=&#34;A_Test_File_is_Just_a_Program&#34;&gt;A Test File is Just a Program&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Each test file is a program, just as important as any other program you&amp;rsquo;d write that uses software being tested. It must be treated with the same care. If you plan to use &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;warnings&lt;/code&gt; in a program related to the code you&amp;rsquo;re testing, be sure to do the same in your tests.&lt;/p&gt;

&lt;p&gt;Each test file should start with these three lines.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #!/path/to/perl
  use strict;
  use warnings;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you plan to run your software in a taint-checked environment, which is considered a good idea, then supply the &lt;code&gt;-T&lt;/code&gt; command-line option to the &lt;code&gt;#!&lt;/code&gt; line.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #!/path/to/perl -T
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will ensure that you won&amp;rsquo;t make syntactic mistakes in your test files. It will also require your software to work correctly in a restricted environment.&lt;/p&gt;

&lt;h3 id=&#34;span-id-be-compatible-with-test-harness-be-compatible-with-test-harness-span&#34;&gt;&lt;span id=&#34;Be_Compatible_with_Test::Harness&#34;&gt;Be Compatible with &lt;code&gt;Test::Harness&lt;/code&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Test::Harness&lt;/code&gt; is a very useful Perl module for running test suites. If you are building a Perl module yourself, and using &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; or &lt;code&gt;Module::Build&lt;/code&gt; for the build process, you&amp;rsquo;re using &lt;code&gt;Test::Harness&lt;/code&gt;. If you aren&amp;rsquo;t using any of these mechanisms, do try to be compatible with it. This will help other users and developers of your software who are used to dealing with &lt;code&gt;Test::Harness&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Compatibility comes in the form of the test file&amp;rsquo;s output. &lt;code&gt;Test::Harness&lt;/code&gt; will run your program and record its output to &lt;code&gt;STDOUT&lt;/code&gt;. Anything sent to &lt;code&gt;STDERR&lt;/code&gt; is ignored, silently passed on to the user. There are particulars about testing under the harness that should be observed. The basics are simple.&lt;/p&gt;

&lt;p&gt;When a test passes, it outputs a line containing &lt;code&gt;ok $N&lt;/code&gt;, where &lt;code&gt;$N&lt;/code&gt; is the test number. When a test fails, the line contains &lt;code&gt;not ok $N&lt;/code&gt;. Test numbers are optional but recommended. Tests may be named. Anything after the number, &lt;code&gt;$N&lt;/code&gt;, is considered the test name, up to a hash (&lt;code&gt;#&lt;/code&gt;). Anything following the hash is a comment.&lt;/p&gt;

&lt;p&gt;Furthermore, you are encouraged to supply a header. The header tells &lt;code&gt;Test::Harness&lt;/code&gt; how many tests you expect to run and should be the first thing you output. If you&amp;rsquo;re unsure of the number of tests, the header may be the very last thing output. Its format is also simple: &lt;code&gt;1..$M&lt;/code&gt;, where &lt;code&gt;$M&lt;/code&gt; is the total number of tests to run. The header helps the harness figure out how well your tests did.&lt;/p&gt;

&lt;p&gt;Any other output should be commented on lines beginning with a hash (&lt;code&gt;#&lt;/code&gt;). Here is an example of prototypical output understood by &lt;code&gt;Test::Harness&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  1..4
  ok 1 - use Software::Module
  ok 2 - object isa Software::Module
  not ok 3 - $object-&amp;gt;true() should return true
  #     Failed test (test.t)
  #          got: undef
  #     expected: 1
  ok 4 # skip Net::DNS required for this test
  # Looks like you failed 1 tests of 4.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-use-a-testing-module-use-a-testing-module-span&#34;&gt;&lt;span id=&#34;Use_a_Testing_Module&#34;&gt;Use a Testing Module&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;A simple way to achieve &lt;code&gt;Test::Harness&lt;/code&gt; compatibility is to use a testing module from the CPAN. Many test suites over the years have reinvented the &lt;code&gt;ok()&lt;/code&gt; function, for example.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  {
    my $N = 1;
    sub ok($;$) {
        my ($test, $name) = @_;
        print &amp;quot;not &amp;quot; unless $test;
        print &amp;quot;ok $N - $name\n&amp;quot;;
        $N++;
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is no need to do this, however. The standard Perl distribution comes with testing modules. Two great options are &lt;code&gt;Test::Simple&lt;/code&gt; and &lt;code&gt;Test::More&lt;/code&gt;. &lt;code&gt;Test::Simple&lt;/code&gt; is a great way to get your feet wet; it implements only the &lt;code&gt;ok()&lt;/code&gt; function. &lt;code&gt;Test::More&lt;/code&gt; has more features and is recommended when you write your test suites.&lt;/p&gt;

&lt;p&gt;Using &lt;code&gt;Test::More&lt;/code&gt; is very simple; many have written on the subject. This is how you would achieve the output described in the previous section.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #!/usr/bin/perl -T
  use strict;
  use warnings;
  use Test::More tests =&amp;gt; 4;

  use_ok &#39;Software::Module&#39;;
  my $object = Software::Module-&amp;gt;new;
  isa_ok $object, &#39;Software::Module&#39;, &#39;object&#39;;
  cmp_ok $object-&amp;gt;true, 1, &#39;$object-&amp;gt;true() should return true&#39;;

  SKIP: {
      skip 1, &amp;quot;Net::DNS required for this test&amp;quot;
        unless eval &#39;require Net::DNS&#39;;

      ok $object-&amp;gt;network(), &amp;quot;run over network&amp;quot;;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-don-t-iterate-compare-don-t-iterate-compare-span&#34;&gt;&lt;span id=&#34;Don&#39;t_Iterate,_Compare&#34;&gt;Don&amp;rsquo;t Iterate, Compare&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;ve often seen tests that loop over a list and check each item to be sure the list is correct. While this approach makes you feel good, artificially adding to the number of tests you&amp;rsquo;ve written, it can be sloppy and long-winded. Here is an example.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my @fruits = qw[apples oranges grapes];
  my @result = get_fruits();
  foreach my $n ( 0 .. $#fruits ) {
      is $result[$n], $fruits[$n], &amp;quot;$fruits[$n] in slot $n&amp;quot;;
  }
  is scalar(@result), scalar(@fruits), &amp;quot;fruits the same size&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It looks like four tests were written; the reality is that one test was written poorly. &lt;code&gt;Test::More&lt;/code&gt; has several utility functions to get the job done. In this test, &lt;code&gt;@fruits&lt;/code&gt; represents a set of non-repeatable &lt;code&gt;fruits&lt;/code&gt; I expect to get back from &lt;code&gt;get_fruits()&lt;/code&gt;. As such, I can use &lt;code&gt;eq_set()&lt;/code&gt; to test this function in one quick try.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my @fruits = qw[apples oranges grapes];
  my @result = get_fruits();
  ok eq_set(\@result, \@fruits), &amp;quot;got [@fruits]&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That was easy and short. But what happens when you have a deep data structure that you&amp;rsquo;re dying to test? That&amp;rsquo;s where &lt;code&gt;Test::Deep&lt;/code&gt; comes in. Downloadable from the CPAN, this module provides the &lt;code&gt;cmp_deeply()&lt;/code&gt; function. Here is a simple example.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use Test::Deep;
  my $people = [
    {
      name     =&amp;gt; &amp;quot;Casey West&amp;quot;,
      employer =&amp;gt; &amp;quot;pair Networks&amp;quot;,
    },
    {
      name     =&amp;gt; &amp;quot;Larry Wall&amp;quot;,
      employer =&amp;gt; &amp;quot;The Perl Foundation&amp;quot;,
    },
  ];

  my $result = $dude-&amp;gt;contacts-&amp;gt;retrieve_all;

  cmp_deeply $result, $people, &#39;contacts match&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example scratched the surface of what &lt;code&gt;Test::Deep&lt;/code&gt; is capable of. When you&amp;rsquo;ve got to test a complex data structure, especially in a complex way, use this module. Here is a more difficult example made testable by this module. In this example, &lt;code&gt;$dude-&amp;gt;contacts-&amp;gt;retrieve_all&lt;/code&gt; returns an unordered list of contacts with various bits of information associated with each of them.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use Test::Deep;
  my $person = {
    name     =&amp;gt; re(&amp;quot;^[\w\s]+$&amp;quot;),
    employer =&amp;gt; ignore(),
    age      =&amp;gt; code(sub { shift &amp;gt; 18 }),
  };
  my $people = array_each($person);
  my $result = $dude-&amp;gt;contacts-&amp;gt;retrieve_all;

  cmp_deeply $result, $people, &#39;contacts match&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code, using only functions exported by &lt;code&gt;Test::Deep&lt;/code&gt;, does a lot of work. Each person has a definition that should match &lt;code&gt;$person&lt;/code&gt;. Every person in the &lt;code&gt;$result&lt;/code&gt; list is a hash reference containing three elements. &lt;code&gt;name&lt;/code&gt; must match the regular expression &lt;code&gt;/^[\w\s]+$/&lt;/code&gt;, &lt;code&gt;employer&lt;/code&gt; must exist and its value is ignored, and &lt;code&gt;age&lt;/code&gt; should be over &lt;code&gt;18&lt;/code&gt; or it will fail. &lt;code&gt;array_each()&lt;/code&gt; returns an object that instructs &lt;code&gt;cmp_deeply&lt;/code&gt; that every value in a list must match the definition provided.&lt;/p&gt;

&lt;p&gt;This small amount of code accomplishes quite a lot. &lt;code&gt;Test::Deep&lt;/code&gt; has saved us from wasting time and working hard to solve a difficult problem. It has made the hard things possible.&lt;/p&gt;

&lt;h3 id=&#34;span-id-don-t-let-pod-go-unchecked-don-t-let-pod-go-unchecked-span&#34;&gt;&lt;span id=&#34;Don&#39;t_Let_POD_go_Unchecked&#34;&gt;Don&amp;rsquo;t Let POD go Unchecked&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Documentation is just as important as code, or tests. There are several ways to care for POD in your test suite. First, it&amp;rsquo;s important to keep it well-formed. For this, we turn to &lt;code&gt;Test::Pod&lt;/code&gt;. This Perl module takes all the work out of testing POD with a useful function &lt;code&gt;all_pod_files_ok()&lt;/code&gt;. Simply create a new test program with the following contents.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use Test::More;
  plan skip_all =&amp;gt; &amp;quot;Test::Pod 1.00 required for testing POD&amp;quot;
    unless eval &amp;quot;use Test::Pod 1.00&amp;quot;;
  all_pod_files_ok();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yes, it really is that simple. When you run this program, it will test all the POD it finds in your &lt;em&gt;blib&lt;/em&gt; directory.&lt;/p&gt;

&lt;p&gt;Another simple test we can run on the documentation is coverage analysis. What good is documentation if it doesn&amp;rsquo;t document completely? &lt;code&gt;Test::Pod::Coverage&lt;/code&gt; is the right module for the job, yet another gem that hides all the hard work from us with a simple function, &lt;code&gt;all_pod_coverage_ok()&lt;/code&gt;. Again, we&amp;rsquo;ll create a new test program.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use Test::More;
  plan skip_all =&amp;gt; &amp;quot;Test::Pod::Coverage 1.08 required for testing POD coverage&amp;quot;
    unless eval &amp;quot;use Test::Pod::Coverage 1.08&amp;quot;;
  all_pod_coverage_ok();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Coverage is only half of the battle. Remember, &lt;code&gt;Test::Pod::Coverage&lt;/code&gt; can&amp;rsquo;t tell you if your documentation is actually correct and thorough.&lt;/p&gt;

&lt;p&gt;In both of these examples, we use the &lt;code&gt;plan&lt;/code&gt; function exported from &lt;code&gt;Test::More&lt;/code&gt; to allow us to &amp;ldquo;bail out&amp;rdquo; of our tests if the appropriate Perl module isn&amp;rsquo;t installed. This makes our POD tests optional. If you don&amp;rsquo;t want them to be optional, remove that line and be sure to list them as prerequisites for building and installing your software.&lt;/p&gt;

&lt;h3 id=&#34;span-id-know-what-you-re-testing-know-what-you-re-testing-span&#34;&gt;&lt;span id=&#34;Know_What_You&#39;re_Testing&#34;&gt;Know What You&amp;rsquo;re Testing&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;One of the biggest testing mistakes is to assume that you know what you&amp;rsquo;re testing. Tests are designed to exercise your software. Let your test exercise the good and bad portions of your software. Make it succeed and, most importantly, make it fail. Superior test coverage digs deep into every line of code you&amp;rsquo;ve written. How do you know if your tests are amazing? Coverage analysis.&lt;/p&gt;

&lt;p&gt;Code coverage isn&amp;rsquo;t something you can guess; you need good tools. Perl has a good tool: &lt;code&gt;Devel::Cover&lt;/code&gt;. This module creates a database that maps actual execution to your source code. It analyzes statements, branches, conditions, subroutines, and even POD and execution time. It then provides a total for all of these areas, as well as a total for each Perl module. It&amp;rsquo;s very simple to use, adding just a little to your &lt;code&gt;make test&lt;/code&gt; process.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;gt; cover -delete
  &amp;gt; HARNESS_PERL_SWITCHES=-MDevel::Cover make test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first command deletes any existing coverage database. On the second line we set an environment variable for &lt;code&gt;Test::Harness&lt;/code&gt;, &lt;code&gt;HARNESS_PERL_SWITCHES&lt;/code&gt; to a Perl command-line switch that imports &lt;code&gt;Devel::Caller&lt;/code&gt;. This is all that&amp;rsquo;s required of you. Each of your test programs will now run with &lt;code&gt;Devel::Caller&lt;/code&gt; loaded and analyzing execution in the background.&lt;/p&gt;

&lt;p&gt;To see your coverage database on the command line, issue one command.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;gt; cover
  ---------------------------- ------ ------ ------ ------ ------ ------ ------
  File                           stmt branch   cond    sub    pod   time  total
  ---------------------------- ------ ------ ------ ------ ------ ------ ------
  blib/lib/List/Group.pm         94.7   66.7   33.3  100.0  100.0  100.0   81.6
  Total                          94.7   66.7   33.3  100.0  100.0  100.0   81.6
  ---------------------------- ------ ------ ------ ------ ------ ------ ------

  Writing HTML output to ~/cvs/perl/modules/List-Group/cover_db/coverage.html ...
  done.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, I could&amp;rsquo;ve done better. But what did I fail to test? Notice that &lt;code&gt;cover&lt;/code&gt; wrote some HTML output. That is the diamond in the rough; the HTML output details everything. Each module has its own series of web pages detailing each of the coverage groups. I did particularly poorly on the conditional coverage &amp;ndash; let&amp;rsquo;s see how.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2004_05_07_testing/figure1.jpg&#34; width=&#34;405&#34; height=&#34;290&#34; /&gt;
Now it&amp;rsquo;s become clear. My tests never allow either of the two statements in this condition to succeed. All of my tests make the first statement fail; the second is never executed. I need to update my tests with at least two more for &lt;code&gt;100.0&lt;/code&gt; conditional coverage. The first test will supply a non-number for the &lt;code&gt;$number&lt;/code&gt; variable. The second will supply a value for the &lt;code&gt;$group_by&lt;/code&gt; variable that doesn&amp;rsquo;t exist in the list for which &lt;code&gt;grep&lt;/code&gt; is looking.&lt;/p&gt;

&lt;p&gt;Testing for coverage is a noble goal. I find this method very useful when writing tests for existing software. There are many situations you may think you&amp;rsquo;re testing well. Don&amp;rsquo;t guess; know. Coverage analysis is equally useful for new development. If you&amp;rsquo;ve adopted the &amp;ldquo;test first&amp;rdquo; method and your coverage isn&amp;rsquo;t 100 percent, something is wrong. Either your tests need help, or you&amp;rsquo;ve written more code than originally required.&lt;/p&gt;

&lt;h3 id=&#34;span-id-keep-test-files-organized-keep-test-files-organized-span&#34;&gt;&lt;span id=&#34;Keep_Test_Files_Organized&#34;&gt;Keep Test Files Organized&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Perl software distributions follow several widely adopted guidelines concerning tests. The rules are simple: test files should reside in a &lt;em&gt;t/&lt;/em&gt; directory, and each test file ends in a .t extension. &lt;code&gt;Test::Harness&lt;/code&gt; understands these rules and &lt;code&gt;make test&lt;/code&gt; will run every file that abides by them.&lt;/p&gt;

&lt;p&gt;The filename can be anything you like. It&amp;rsquo;s a good idea to use descriptive filenames instead of just digits or numerical words. Good examples are &lt;em&gt;pod-coverage.t&lt;/em&gt;, &lt;em&gt;software-class-api.t&lt;/em&gt;, and &lt;em&gt;compile.t&lt;/em&gt;. Sometimes it&amp;rsquo;s desirable to determine the order in which your test files will be run. In these cases, prefix the filename with a number. If you want compilation tests to run first and POD tests last, name them accordingly as &lt;em&gt;00-compile.t&lt;/em&gt; and &lt;em&gt;99-pod-coverage.t&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-looking-ahead-looking-ahead-span&#34;&gt;&lt;span id=&#34;Looking_Ahead&#34;&gt;Looking Ahead&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Testing can be a tedious, difficult job. By this point, you have a number of helpful tools to make the task easier. There are many more testing modules on the CPAN that could have been covered here; I encourage you to explore them all.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

