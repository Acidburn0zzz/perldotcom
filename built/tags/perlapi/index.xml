<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Perlapi on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/perlapi/</link>
    <description>Recent content in Perlapi on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 12 Jan 2018 08:28:40 +0000</lastBuildDate>
    <atom:link href="/tags/perlapi/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Writing your own XS functions</title>
      <link>http://localhost:1313/article/writing-your-own-xs-functions/</link>
      <pubDate>Fri, 12 Jan 2018 08:28:40 +0000</pubDate>
      
      <guid>http://localhost:1313/article/writing-your-own-xs-functions/</guid>
      <description>

&lt;p&gt;In &lt;a href=&#34;http://localhost:1313/article/getting-started-with-xs/&#34;&gt;part one&lt;/a&gt;, we learned the basic components of XS, and integrated
two C functions into Perl. This chapter is going to show you how to define xsubs
that accept multiple parameters, and define your own logic, instead of using XS
as a Foreign Function Interface to a C library.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll need the files from &lt;a href=&#34;http://localhost:1313/article/getting-started-with-xs/&#34;&gt;part one&lt;/a&gt; to execute the code in this article.&lt;/p&gt;

&lt;h3 id=&#34;module-code&#34;&gt;Module Code&lt;/h3&gt;

&lt;p&gt;As before, we&amp;rsquo;ll define the module code to load our XS. This is all that&amp;rsquo;s
required:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;package&lt;/span&gt; XS::Tutorial::Two;
&lt;span style=&#34;color:#66d9ef&#34;&gt;require&lt;/span&gt; XSLoader;

XSLoader::load();
&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That should be saved as &lt;code&gt;lib/XS/Tutorial/Two.pm&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;xs-code&#34;&gt;XS Code&lt;/h3&gt;

&lt;p&gt;The top of the XS file will look similar to the previous chapter:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define PERL_NO_GET_CONTEXT &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// we&amp;#39;ll define thread context if necessary (faster)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;EXTERN.h&amp;#34;         // globals/constant import locations&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;perl.h&amp;#34;           // Perl symbols, structures and constants definition&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;XSUB.h&amp;#34;           // xsubpp functions and macros&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;stdint.h&amp;#34;         // portable integer types&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
MODULE &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; XS&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Tutorial&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Two  PACKAGE &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; XS&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Tutorial&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Two
PROTOTYPES: ENABLE&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Remember to append any XS code after the &lt;code&gt;PROTOTYPES&lt;/code&gt; line. This should be saved
as &lt;code&gt;lib/XS/Tutorial/Two.xs&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;adding-numbers&#34;&gt;Adding numbers&lt;/h3&gt;

&lt;p&gt;Here&amp;rsquo;s a simple declaration of an xsub that adds two integers:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;add_ints&lt;/span&gt; (addend1, addend2)
  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; addend1
  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; addend2
  CODE:
    RETVAL &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; addend1 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; addend2;
  OUTPUT:
    RETVAL&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This declares an xsub called &lt;code&gt;add_ints&lt;/code&gt; which accepts two integers and whose
return type is &lt;code&gt;int&lt;/code&gt;. Note the &lt;a href=&#34;https://stackoverflow.com/questions/1630631/alternative-kr-c-syntax-for-function-declaration-versus-prototypes&#34;&gt;K&amp;amp;R&lt;/a&gt; style of the function definition. This can also be written as:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;add_ints (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; addend1, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; addend2)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But you rarely see it done that way in the wild. I don&amp;rsquo;t know if that&amp;rsquo;s a cargo
cult thing or there are edge cases to the xsub compiler that I&amp;rsquo;m not aware of.
Just to be safe, I&amp;rsquo;ll keep doing it the way everyone else does (the cult
persists!).&lt;/p&gt;

&lt;p&gt;Whereas &lt;a href=&#34;http://localhost:1313/article/getting-started-with-xs/&#34;&gt;before&lt;/a&gt; we were essentially mapping C functions like &lt;code&gt;srand&lt;/code&gt; to Perl,
here we&amp;rsquo;re declaring our own logic: &lt;code&gt;add_ints&lt;/code&gt; isn&amp;rsquo;t imported from anywhere,
we&amp;rsquo;re declaring it as a new function.&lt;/p&gt;

&lt;p&gt;Since &lt;code&gt;add_ints&lt;/code&gt; is a new function, we need to define the logic of it, and
that&amp;rsquo;s where the &lt;code&gt;CODE&lt;/code&gt; section comes in. Here we can write C code which
forms the body of the function. In this example, I add the two subroutine
parameters together and assign the result to &lt;code&gt;RETVAL&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://perldoc.perl.org/perlxs.html#The-RETVAL-Variable&#34;&gt;RETVAL&lt;/a&gt; (&amp;ldquo;RETurn VALue&amp;rdquo;) is a special variable that is declared by the xsub processor
(xsubpp). The &lt;code&gt;OUTPUT&lt;/code&gt; section accepts the return variable for the xsub, placing
it on the stack, so that calling code will receive it.&lt;/p&gt;

&lt;h3 id=&#34;adding-more-than-two-numbers&#34;&gt;Adding more than two numbers&lt;/h3&gt;

&lt;p&gt;Adding two numbers is all well and good, but lists are the lingua franca of
Perl. Let&amp;rsquo;s update the &lt;code&gt;add_ints&lt;/code&gt; xsub to accept n values:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;int32_t
&lt;span style=&#34;color:#a6e22e&#34;&gt;add_ints&lt;/span&gt; (...)
  CODE:
    uint32_t i;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; items; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;SvOK(ST(i)) &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;SvIOK(ST(i)))
        croak(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;requires a list of integers&amp;#34;&lt;/span&gt;);

      RETVAL &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; SvIVX(ST(i));
    }
  OUTPUT:
    RETVAL&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;First off, notice I&amp;rsquo;ve updated the return value. One issue with using &lt;code&gt;int&lt;/code&gt; in
C is it may be a different size on different machine architectures. &lt;code&gt;int32_t&lt;/code&gt;
is from the &lt;code&gt;stdint.h&lt;/code&gt; library, and guaranteed to be a 32 bit signed integer.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve replaced the function parameters with &lt;code&gt;...&lt;/code&gt; which indicates the function
accepts a variable number of arguments, just like in C. In the &lt;code&gt;CODE&lt;/code&gt; section,
I declare a &lt;code&gt;uint32_t&lt;/code&gt; integer called &lt;code&gt;i&lt;/code&gt; (&lt;code&gt;uint32_t&lt;/code&gt; is a 32 bit unsigned
integer).&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;for&lt;/code&gt; loop uses the special variable &lt;code&gt;items&lt;/code&gt; (the number of arguments passed
to the function) to iterate over the arguments. The &lt;code&gt;if&lt;/code&gt; statement calls
the macro &lt;code&gt;ST&lt;/code&gt; to access the stack variable at position &lt;code&gt;i&lt;/code&gt;. This is used to
check that the scalar is defined (&lt;code&gt;SvOK&lt;/code&gt;) and that it is an integer (&lt;code&gt;SvIOK&lt;/code&gt;).
If either test fails, the code calls &lt;code&gt;croak&lt;/code&gt; to throw a fatal exception.&lt;/p&gt;

&lt;p&gt;Otherwise the integer value is extracted from the scalar (&lt;code&gt;SvIVX&lt;/code&gt;) and added
to &lt;code&gt;RETVAL&lt;/code&gt;. If all of these C macros look strange to you, don&amp;rsquo;t worry, they are
weird! They are part of the Perl C API, and they&amp;rsquo;re documented in &lt;a href=&#34;https://perldoc.perl.org/perlapi.html&#34;&gt;perlapi&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;edge-cases&#34;&gt;Edge cases&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s probably a good time to write some tests for this function, here&amp;rsquo;s a
start:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Test::More;

&lt;span style=&#34;color:#66d9ef&#34;&gt;BEGIN&lt;/span&gt; { use_ok &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;XS::Tutorial::Two&amp;#39;&lt;/span&gt; }

cmp_ok XS::Tutorial::Two::add_ints(&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;), &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;==&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
cmp_ok XS::Tutorial::Two::add_ints(&lt;span style=&#34;color:#ae81ff&#34;&gt;1500&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;21000&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;), &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;==&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;21500&lt;/span&gt;;

done_testing;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I saved that file as &lt;code&gt;t/two.t&lt;/code&gt;, and run it by building the distribution with
&lt;code&gt;make&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;perl Makefile.PL &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Do you know what the return value would be if &lt;code&gt;add_ints&lt;/code&gt; was called with no
arguments? Maybe &lt;code&gt;undef&lt;/code&gt;, since if there are no arguments, the for loop will
not have any iterations. Here&amp;rsquo;s a test for that condition:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;ok &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;defined XS::Tutorial::Two::add_ints(), &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;empty list returns undef&amp;#39;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Re-building and running the tests with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make clean &amp;amp;&amp;amp; perl Makefile.PL &amp;amp;&amp;amp;  make &amp;amp;&amp;amp; make test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That test fails, because the return value is zero! This is a quirk of C:
uninitialized integers can be zero. Let&amp;rsquo;s fix the xsub to return &lt;code&gt;undef&lt;/code&gt; when
it doesn&amp;rsquo;t receive any arguments:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;SV &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;add_ints&lt;/span&gt; (...)
  PPCODE:
    uint32_t i;
    int32_t total &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (items &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
      &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; items; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;SvOK(ST(i)) &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;SvIOK(ST(i)))
          croak(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;requires a list of integers&amp;#34;&lt;/span&gt;);

        total &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; SvIVX(ST(i));
      }
      PUSHs(sv_2mortal(newSViv(total)));
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
      PUSHs(sv_newmortal());
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Woah, quite a few changes! First I&amp;rsquo;ve changed the return type to &lt;code&gt;SV *&lt;/code&gt;, from
&lt;code&gt;int32_t&lt;/code&gt;. The reason for this will become clear in a moment.  The &lt;code&gt;CODE&lt;/code&gt; section
is now called &lt;code&gt;PPCODE&lt;/code&gt;, which tells xsubpp that we will be managing the return
value of xsub ourselves, hence the &lt;code&gt;OUTPUT&lt;/code&gt; section is gone.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve declared a new variable called &lt;code&gt;total&lt;/code&gt; to capture the running total of the
arguments as they&amp;rsquo;re added. If we received at least one argument, total is copied
into a new scalar integer value (&lt;code&gt;newSViv&lt;/code&gt;), its reference count is corrected
(&lt;code&gt;sv_2mortal&lt;/code&gt;) and it is pushed onto the stack pointer (&lt;code&gt;PUSHs&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Otherwise a new &lt;code&gt;undef&lt;/code&gt; scalar is declared with &lt;code&gt;sv_newmortal&lt;/code&gt; and that is pushed
onto the stack pointer instead. So in both cases we&amp;rsquo;re returning an &lt;code&gt;SV&lt;/code&gt;. And as
we&amp;rsquo;re returning a Perl type instead of a C type (&lt;code&gt;int32_t&lt;/code&gt;) there is no need for
xsubpp to cast our return value into a Perl scalar, we&amp;rsquo;re already doing it.&lt;/p&gt;

&lt;h3 id=&#34;wrap-up&#34;&gt;Wrap up&lt;/h3&gt;

&lt;p&gt;This tutorial has covered some critical skills for writing xsubs: how to accept
multiple parameters, how to write your own logic, and how to manage the stack
pointer. If you grok all of these, and the content of &lt;a href=&#34;http://localhost:1313/article/getting-started-with-xs/&#34;&gt;part one&lt;/a&gt;
you have enough to get started writing your own XS code.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;This documentation and code is on CPAN (&lt;a href=&#34;https://metacpan.org/pod/XS::Tutorial&#34;&gt;XS::Tutorial&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://perldoc.perl.org/perlxs.html&#34;&gt;perlxs&lt;/a&gt; defines the keywords recognized by &lt;a href=&#34;https://perldoc.perl.org/xsubpp.html&#34;&gt;xsubpp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://perldoc.perl.org/perlapi.html&#34;&gt;perlapi&lt;/a&gt; lists the C macros used to interact with Perl data structures (and the interpreter)&lt;/li&gt;
&lt;li&gt;The &lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdint.h.html&#34;&gt;stdint.h&lt;/a&gt; C library provides sets of portable integer types&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Getting started with XS</title>
      <link>http://localhost:1313/article/getting-started-with-xs/</link>
      <pubDate>Wed, 03 May 2017 20:47:51 +0000</pubDate>
      
      <guid>http://localhost:1313/article/getting-started-with-xs/</guid>
      <description>

&lt;p&gt;eXtendable Subroutines (XS) are subroutines written in C that are callable from
Perl code. There are two common reasons you&amp;rsquo;d want to use XS: there is a C
library you&amp;rsquo;d like to use with Perl, or you want to make a subroutine faster
by processing it in C instead of Perl.&lt;/p&gt;

&lt;p&gt;This tutorial will walk you through all the components needed to get up and
running with a basic XS example. There will be a lot of new terms and concepts:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you want to write XS, you have to learn it. Learning XS is very difficult&lt;/p&gt;

&lt;p&gt;Steven W. McDougall&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Try not to get discouraged if things don&amp;rsquo;t click right away: I promise you that
learning XS can be hugely rewarding: you&amp;rsquo;ll develop the power to write lightning
fast code; get a better understanding of how Perl internals work, and be able to
integrate any C library you choose and use it from Perl.&lt;/p&gt;

&lt;h3 id=&#34;components&#34;&gt;Components&lt;/h3&gt;

&lt;p&gt;There are a few basic components needed to write an xsub. The first is a Perl
module that will provide the namespace for any XS functions. This is all that&amp;rsquo;s
needed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package XS::Tutorial::One;
require XSLoader;

XSLoader::load();
1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This file should be saved as &lt;code&gt;lib/XS/Tutorial/One.pm&lt;/code&gt;. &lt;code&gt;XSLoader::load&lt;/code&gt; by
default searches for XS code that matches the package name it is called from*.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s create a main distribution module too:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package XS::Tutorial;
BEGIN { our $VERSION = 0.01 }
1;

=encoding utf8

=head1 NAME

XS::Tutorial - documentation with examples for learning Perl XS

=cut
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That file should be saved as &lt;code&gt;lib/XS/Tutorial.pm&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The next thing we need is a .xs file which defines the xsubs to be loaded by
&lt;code&gt;XS::Tutorial::One&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define PERL_NO_GET_CONTEXT // we&#39;ll define thread context if necessary (faster)
#include &amp;quot;EXTERN.h&amp;quot;         // globals/constant import locations
#include &amp;quot;perl.h&amp;quot;           // Perl symbols, structures and constants definition
#include &amp;quot;XSUB.h&amp;quot;           // xsubpp functions and macros
#include &amp;lt;stdlib.h&amp;gt;         // rand()

// additional c code goes here

MODULE = XS::Tutorial::One  PACKAGE = XS::Tutorial::One
PROTOTYPES: ENABLE

 # XS code goes here

 # XS comments begin with &amp;quot; #&amp;quot; to avoid them being interpreted as pre-processor
 # directives

unsigned int
rand()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This file should be saved as &lt;code&gt;lib/XS/Tutorial/One.xs&lt;/code&gt;. The top half of the file
is pure C code. The line beginning &lt;code&gt;MODULE = XS::Tutorial::One&lt;/code&gt; indicates the
start of the XS code. This section will be parsed and compiled into C code by
&lt;code&gt;xsubpp&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;MODULE&lt;/code&gt; and &lt;code&gt;PACKAGE&lt;/code&gt; directives define the Perl module and package which
will load any xsubs we define. The line &lt;code&gt;PROTOTYPES: ENABLE&lt;/code&gt; tells &lt;code&gt;xsubpp&lt;/code&gt;
to define subroutine prototypes for any xsubs we create. This is usually what
you want: prototypes can help Perl catch compile time errors.&lt;/p&gt;

&lt;p&gt;The last two lines of the file are an xsub:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unsigned int
rand()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first line defines the return type. The second line does two things: it
indicates the name of the C function to be called &lt;em&gt;and&lt;/em&gt; it defines the
signature of the xsub.&lt;/p&gt;

&lt;p&gt;In this case we&amp;rsquo;re calling &lt;code&gt;rand&lt;/code&gt; and accepting no parameters. This isn&amp;rsquo;t
Perl&amp;rsquo;s built-in rand function, &lt;em&gt;this&lt;/em&gt; rand comes from stdlib.h.&lt;/p&gt;

&lt;p&gt;The final thing we need is a &lt;code&gt;Makefile.PL&lt;/code&gt; script - as XS code is compiled, we
need a tool to build it before we can use it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use 5.008005;
use ExtUtils::MakeMaker 7.12; # for XSMULTI option

WriteMakefile(
  NAME           =&amp;gt; &#39;XS::Tutorial&#39;,
  VERSION_FROM   =&amp;gt; &#39;lib/XS/Tutorial.pm&#39;,
  PREREQ_PM      =&amp;gt; { &#39;ExtUtils::MakeMaker&#39; =&amp;gt; &#39;7.12&#39; },
  ABSTRACT_FROM  =&amp;gt; &#39;lib/XS/Tutorial.pm&#39;,
  AUTHOR         =&amp;gt; &#39;David Farrell&#39;,
  CCFLAGS        =&amp;gt; &#39;-Wall -std=c99&#39;,
  OPTIMIZE       =&amp;gt; &#39;-O3&#39;,
  LICENSE        =&amp;gt; &#39;freebsd&#39;,
  XSMULTI        =&amp;gt; 1,
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The ExtUtils::MakeMaker &lt;a href=&#34;https://metacpan.org/pod/ExtUtils::MakeMaker&#34;&gt;docs&lt;/a&gt; explain these options.&lt;/p&gt;

&lt;p&gt;But let&amp;rsquo;s talk about &lt;code&gt;XSMULTI&lt;/code&gt;. This is a relatively new feature which allows
you to have separate .xs files for modules. By default EUMM assumes the xs
file matches the distribution name. In this case that would mean having a single
Tutorial.xs file, with multiple xs &lt;code&gt;MODULE&lt;/code&gt; and &lt;code&gt;PACKAGE&lt;/code&gt; declarations in it.
By using &lt;code&gt;XSMULTI&lt;/code&gt;, we can have multiple XS files, one for each module in the
distribution instead.&lt;/p&gt;

&lt;p&gt;*Actually it searches for compiled C code but the effect is the same.&lt;/p&gt;

&lt;h3 id=&#34;building&#34;&gt;Building&lt;/h3&gt;

&lt;p&gt;Now we should have four files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lib/XS/Tutorial.pm
lib/XS/Tutorial/One.pm
lib/XS/Tutorial/One.xs
Makefile.PL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following commands will build the distribution:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl Makefile.PL
$ make
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-minor-essay-to-understand-xsubpp-generated-c&#34;&gt;A minor essay to understand xsubpp generated C&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;make&lt;/code&gt; creates a bunch of files, but take a look at &lt;code&gt;lib/XS/Tutorial/One.c&lt;/code&gt;.
This is the output of &lt;code&gt;xsubpp&lt;/code&gt;. If you look closely enough, you can find the
lines of C code from &lt;code&gt;lib/XS/Tutorial/One.xs&lt;/code&gt; in there. But checkout what
happened to our &lt;code&gt;rand&lt;/code&gt; xsub:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;XS_EUPXS(XS_XS__Tutorial__One_rand); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_XS__Tutorial__One_rand)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  &amp;quot;&amp;quot;);
    {
  unsigned int        RETVAL;
  dXSTARG;

  RETVAL = rand();
  XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;xsubpp&lt;/code&gt; has replaced our XS code with some rather ugly C macros! These macros
are part of the Perl interpreter&amp;rsquo;s C API. Many are documented in &lt;a href=&#34;https://perldoc.perl.org/perlapi.html&#34;&gt;perlapi&lt;/a&gt;
and they are usually defined in &lt;code&gt;XSUB.h&lt;/code&gt; or &lt;code&gt;perl.h&lt;/code&gt; in the Perl source code.&lt;/p&gt;

&lt;p&gt;So what are these macros doing? At a high level, &lt;code&gt;dVAR&lt;/code&gt; and &lt;code&gt;dXSARGS&lt;/code&gt; setup
the global pointer stack and some local variables. &lt;code&gt;items&lt;/code&gt; is a count of the
arguments supplied to the xsub. As &lt;code&gt;rand&lt;/code&gt; is a void function, if this isn&amp;rsquo;t
zero, it croaks. &lt;code&gt;croak_xs_usage&lt;/code&gt; takes a coderef and an args string. In this
context &lt;code&gt;cv&lt;/code&gt; is the xsub, and there are no args so the string is empty.&lt;/p&gt;

&lt;p&gt;Next the code declares &lt;code&gt;RETVAL&lt;/code&gt;, the return value of the xsub. &lt;code&gt;dXTARG&lt;/code&gt;
initializes the &lt;code&gt;TARG&lt;/code&gt; pointer. Next &lt;code&gt;rand()&lt;/code&gt; is called its return value
assigned to &lt;code&gt;RETVAL&lt;/code&gt;. &lt;code&gt;XSprePUSH&lt;/code&gt; moves the stack pointer back one,
and &lt;code&gt;PUSHu&lt;/code&gt; copies &lt;code&gt;RETVAL&lt;/code&gt; into &lt;code&gt;TARG&lt;/code&gt; and pushes it onto the global stack
pointer. &lt;code&gt;XSRETURN&lt;/code&gt; returns from the xsub, indicating how many arguments it
added to the stack, which in this case, is one.&lt;/p&gt;

&lt;p&gt;Writing XS, you usually don&amp;rsquo;t need to study the generated C code, but it&amp;rsquo;s
helpful to have an awareness of the process.&lt;/p&gt;

&lt;h3 id=&#34;installing&#34;&gt;Installing&lt;/h3&gt;

&lt;p&gt;Now the code is compiled, install it with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you&amp;rsquo;re using system Perl, you may need to use &lt;code&gt;sudo&lt;/code&gt; to install. Now we can
test the module using a one liner:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl -MXS::Tutorial::One -E &#39;say XS::Tutorial::One::rand()&#39;
1804289383
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It works! Did you try running it twice though?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl -MXS::Tutorial::One -E &#39;say XS::Tutorial::One::rand()&#39;
1804289383
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We get the same pseudorandom sequence each time&amp;hellip; We need to call &lt;code&gt;srand&lt;/code&gt; to
seed the sequence. That function is already provided by &lt;code&gt;stdlib.h&lt;/code&gt;, so all we
need to do is append the following text to &lt;code&gt;lib/XS/Tutorial/One.xs&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void
srand(seed)
  unsigned int seed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This xsub is different to the first one: its return type is &lt;code&gt;void&lt;/code&gt; which
means it returns nothing. It also includes a parameter called &lt;code&gt;seed&lt;/code&gt; in its
signature, and the last line defines it as an unsigned int.&lt;/p&gt;

&lt;p&gt;Rebuild and install the distribution:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can seed the pseudorandom sequence by calling &lt;code&gt;srand&lt;/code&gt; before &lt;code&gt;rand&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl -MXS::Tutorial::One -E &#39;XS::Tutorial::One::srand(777);\
say XS::Tutorial::One::rand()&#39;
947371799
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We used a lucky (777) seed number, and &lt;code&gt;rand&lt;/code&gt; emitted a different number, yay!&lt;/p&gt;

&lt;h3 id=&#34;did-we-beat-perl&#34;&gt;Did we beat Perl?&lt;/h3&gt;

&lt;p&gt;As you know by now, xsubs are often faster than pure Perl code. We&amp;rsquo;ve built two
xsubs for &lt;code&gt;rand&lt;/code&gt; and &lt;code&gt;srand&lt;/code&gt;, which are also available as built-in functions
in Perl. Do you think the xsubs are faster? Here&amp;rsquo;s a benchmark from my machine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;              Rate xs_rand bi_rand
xs_rand 15691577/s      --    -64%
bi_rand 43095739/s    175%      --
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oh no! Despite our &lt;code&gt;rand&lt;/code&gt; xsub directly calling the C &lt;code&gt;stdlib&lt;/code&gt; function, it&amp;rsquo;s
miles slower than Perl&amp;rsquo;s built-in &lt;code&gt;rand&lt;/code&gt;. This isn&amp;rsquo;t because xsubs are slow,
rather that Perl&amp;rsquo;s built-in functions are really fast. There is an overhead
associated with calling xsubs which built-in functions do not pay.&lt;/p&gt;

&lt;h3 id=&#34;tests&#34;&gt;Tests&lt;/h3&gt;

&lt;p&gt;Instead of running one liners to check our code works, we can write unit tests.
Here&amp;rsquo;s a basic script:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/perl
use Test::More;

BEGIN { use_ok &#39;XS::Tutorial::One&#39; }

ok my $rand = XS::Tutorial::One::rand(), &#39;rand()&#39;;
like $rand, qr/^\d+$/, &#39;rand() returns a number&#39;;

ok !defined XS::Tutorial::One::srand(5), &#39;srand()&#39;;
ok $rand ne XS::Tutorial::One::rand(), &#39;after srand, rand returns different number&#39;;
done_testing;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Save this file as &lt;code&gt;t/one.t&lt;/code&gt;. Assuming you built and installed the distribution
already, you can just do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl t/one.t
ok 1 - use XS::Tutorial::One;
ok 2 - rand()
ok 3 - rand() returns a number
ok 4 - srand()
ok 5 - after srand, rand returns different number
1..5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now when building the distribution in the future, you should do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl Makefile.PL &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will rebuild and test the distribution. Because XS code is compiled,
writing tests and using that one liner, you can quickly cycle through coding
and testing.&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t forget to add Test::More to the &lt;code&gt;PREREQ_PM&lt;/code&gt; entry in &lt;code&gt;Makefile.PL&lt;/code&gt;. When
you don&amp;rsquo;t have a specific minimum version, you can just use 0:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PREREQ_PM =&amp;gt; { &#39;Test::More&#39; =&amp;gt; 0, &#39;ExtUtils::MakeMaker&#39; =&amp;gt; &#39;7.12&#39; },
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;cleanup&#34;&gt;Cleanup&lt;/h3&gt;

&lt;p&gt;Building distributions generates a lot of temporary files. ExtUtils::MakeMaker
provides a realclean routine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ make realclean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will delete all the build files and reset the working directory to normal.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;This article and code are on CPAN as &lt;a href=&#34;https://metacpan.org/pod/XS::Tutorial::One&#34;&gt;XS::Tutorial::One&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;XS Mechanics by Steven W. McDougall is my second favorite :) XS &lt;a href=&#34;http://world.std.com/~swmcd/steven/perl/pm/xs/intro/&#34;&gt;tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://perldoc.perl.org/perlxs.html&#34;&gt;perlxs&lt;/a&gt; defines the keywords recognized by &lt;a href=&#34;https://perldoc.perl.org/xsubpp.html&#34;&gt;xsubpp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://perldoc.perl.org/perlapi.html&#34;&gt;perlapi&lt;/a&gt; : C macros used to interact with Perl data structures (and the interpreter)&lt;/li&gt;
&lt;li&gt;The &lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/9699919799/&#34;&gt;stdlib.h&lt;/a&gt; man page defines the C standard library functions and types&lt;/li&gt;
&lt;li&gt;For writing Makefile.PL files: ExtUtils::MakeMaker &lt;a href=&#34;https://metacpan.org/pod/ExtUtils::MakeMaker&#34;&gt;docs&lt;/a&gt; are invaluable&lt;/li&gt;
&lt;li&gt;Perl&amp;rsquo;s built-in &lt;a href=&#34;https://perldoc.perl.org/functions/rand.html&#34;&gt;rand&lt;/a&gt; and &lt;a href=&#34;https://perldoc.perl.org/functions/srand.html&#34;&gt;srand&lt;/a&gt; functions&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

