<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Compile on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/compile/</link>
    <description>Recent content in Compile on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 10 Nov 2014 14:01:51 +0000</lastBuildDate>
    <atom:link href="/tags/compile/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Boost your Perl productivity with auto-compile checking</title>
      <link>http://localhost:1313/article/133/2014/11/10/Boost-your-Perl-productivity-with-auto-compile-checking/</link>
      <pubDate>Mon, 10 Nov 2014 14:01:51 +0000</pubDate>
      
      <guid>http://localhost:1313/article/133/2014/11/10/Boost-your-Perl-productivity-with-auto-compile-checking/</guid>
      <description>

&lt;p&gt;The Perl command line option &lt;code&gt;-c&lt;/code&gt; causes Perl to check the syntax of the program, but not execute it (apart from code in BEGIN, CHECK and UNITCHECK blocks - watch out for those). For example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ perl &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;c lib&lt;span style=&#34;color:#e6db74&#34;&gt;/Devel/&lt;/span&gt;DidYouMean&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pm
lib&lt;span style=&#34;color:#e6db74&#34;&gt;/Devel/&lt;/span&gt;DidYouMean&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pm syntax OK&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is useful but it&amp;rsquo;s kind of clunky to type it every time you want to check the syntax of a program or file.&lt;/p&gt;

&lt;h3 id=&#34;continuous-syntax-checking&#34;&gt;Continuous syntax checking&lt;/h3&gt;

&lt;p&gt;One of my favourite &lt;a href=&#34;https://metacpan.org/pod/Catalyst::Manual::Tutorial::02_CatalystBasics#The-Simplest-Way&#34;&gt;features&lt;/a&gt; when developing Catalyst web apps is using the test server to automatically check the syntax of the web app as I develop it. This saves me time as I know immediately if the web app compiles or not and don&amp;rsquo;t waste time opening up a browser only to get an error. if you&amp;rsquo;re working on a Unix-based operating system you can achieve a similar effect for any Perl program (not just web apps). The &lt;code&gt;watch&lt;/code&gt; program can automatically run the check command. Just start a new terminal, and enter:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ watch &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;perl -c lib/Devel/DidYouMean.pm&amp;#39;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Giving this output:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;Every &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;s perl &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;c lib&lt;span style=&#34;color:#e6db74&#34;&gt;/Devel/&lt;/span&gt;DidYouMean&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pm           Sat Nov  &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2014&lt;/span&gt;

lib&lt;span style=&#34;color:#e6db74&#34;&gt;/Devel/&lt;/span&gt;DidYouMean&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pm syntax OK&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this case I&amp;rsquo;m watching the file &lt;code&gt;lib/Devel/DidYouMean.pm&lt;/code&gt; but you can provide any path to a Perl file that you want to check for syntax errors. By default &lt;code&gt;watch&lt;/code&gt; will run the command every 2 seconds. So if I save a bad update to the file, the watching terminal window will show the error:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;Every &lt;span style=&#34;color:#ae81ff&#34;&gt;2.0&lt;/span&gt;s: perl &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;c lib&lt;span style=&#34;color:#e6db74&#34;&gt;/Devel/&lt;/span&gt;DidYouMean&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pm           Sat Nov  &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2014&lt;/span&gt;

syntax error at lib&lt;span style=&#34;color:#e6db74&#34;&gt;/Devel/&lt;/span&gt;DidYouMean&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pm line &lt;span style=&#34;color:#ae81ff&#34;&gt;122&lt;/span&gt;, near &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;} keys&amp;#34;&lt;/span&gt;

lib&lt;span style=&#34;color:#e6db74&#34;&gt;/Devel/&lt;/span&gt;DidYouMean&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pm had compilation errors&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This enables me to catch the error before running the program, saving time.&lt;/p&gt;

&lt;h3 id=&#34;checking-syntax-in-a-text-editor&#34;&gt;Checking syntax in a text-editor&lt;/h3&gt;

&lt;p&gt;Using &lt;code&gt;watch&lt;/code&gt; is useful, but I find it can be annoying to have to check a separate terminal window to know if my program compiles or not. Another way to do this is to run the command from within your text-editor. I&amp;rsquo;ll show how you how to do this in vim, but it should be possible to do this in any text-editor that has save events which you can hook in to (e.g. examples for &lt;a href=&#34;http://www.klaascuvelier.be/2013/06/sublime-command-on-save/&#34;&gt;Sublime Text&lt;/a&gt; and &lt;a href=&#34;http://flycheck.readthedocs.org/en/latest/&#34;&gt;Emacs&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Add the following line to your .vimrc file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;autocmd BufWritePost &lt;span style=&#34;color:#f92672&#34;&gt;*.&lt;/span&gt;pm,&lt;span style=&#34;color:#f92672&#34;&gt;*.&lt;/span&gt;t,&lt;span style=&#34;color:#f92672&#34;&gt;*.&lt;/span&gt;pl echom system(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;perl -Ilib -c &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#34;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt; expand(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%:p&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#34;&amp;#39;&lt;/span&gt; )&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What this command does is every time a file ending in .pm, .t, or.pl is saved, vim will run the check syntax command on the file, echoing the results to the current window. Reload your .vimrc with this vim command: &lt;code&gt;:so $MYVIMRC&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now you don&amp;rsquo;t have to bother setting up a separate terminal window and watching the file; vim will notify you immediately if any Perl file is saved with compilation errors. Much more convenient!&lt;/p&gt;

&lt;h3 id=&#34;alternative-methods-in-vim&#34;&gt;Alternative Methods in Vim&lt;/h3&gt;

&lt;p&gt;Several readers got in touch to recommend the Syntastic &lt;a href=&#34;https://github.com/scrooloose/syntastic&#34;&gt;plugin&lt;/a&gt; for Vim (&lt;a href=&#34;https://github.com/scrooloose/syntastic&#34;&gt;manual&lt;/a&gt;). One nice thing about Syntastic is you can chain compile checks: first run &lt;code&gt;perl -c&lt;/code&gt;, if it passes, then run &lt;a href=&#34;https://metacpan.org/pod/Perl::Critic&#34;&gt;Perl::Critic&lt;/a&gt; and so on. Syntastic also integrates syntax checkers for many other languages, so if Vim is your editor of choice, you might want to check it out.&lt;/p&gt;

&lt;p&gt;A simpler alternative to Syntastic is to use Vim&amp;rsquo;s built-in compiler support. With a Perl file in the current buffer, type:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;:compiler perl
:make
:cope&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This will run Perl&amp;rsquo;s syntax checks checks on the current buffer. Vim reads the output into an error list, which the &lt;code&gt;:cope&lt;/code&gt; command displays. You can jump to the line referenced by a specific error by pressing the enter key (&lt;a href=&#34;http://vimdoc.sourceforge.net/htmldoc/quickfix.html#quickfix-window&#34;&gt;manual&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Updates:&lt;/strong&gt; &lt;em&gt;BEGIN, CHECK, UNITCHECK blocks caution added. Emacs link and addition Vim methods added. 2014-11-10&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Vim autocmd example updated to handle filepaths containing spaces. Thanks to Henry An for the suggestion. 2015-01-22&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Cover image &lt;a href=&#34;https://creativecommons.org/licenses/by/4.0/&#34;&gt;Â©&lt;/a&gt; &lt;a href=&#34;https://www.flickr.com/photos/runneralan/10092757714/in/photolist--88qSeT-88u7R1-dqTSLE-atoyrp-bD3QaN-93yNyq-8QYfKX-diG9h4-bD3NV9-88u847-gnS2f3-55QWyu-dqTHcF-9AJTkV-88qSdr-7h39AP-7nPgCT-88qSfv-5MyRfE-bRXxYv-bD3PXU-88u7pC-imjBX2-8xz38b-32eo27-a8YVvZ-8WJgFA-93ySDG-57KLMs-oYUnQ1-88qRL4-fturhH-88qRMx-cUx3nS-4GMFL2-88qSrv-5RhqjZ-ftuqAr-ehAoHf-ftJLsq-88u7fU-5R22Pk-5CNDM-bv2wve-9vnwcd-6dyA62-ejP2nf-329MpH-88u7ds&#34;&gt;Alan Kotok&lt;/a&gt; image has been digitally altered&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Why Not Translate Perl to C?</title>
      <link>http://localhost:1313/pub/2001/06/27/ctoperl.html/</link>
      <pubDate>Wed, 27 Jun 2001 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2001/06/27/ctoperl.html/</guid>
      <description>

&lt;p&gt;People often have the idea that automatically translating Perl to C and then compiling the C will make their Perl programs run faster, because &amp;ldquo;C is much faster than Perl.&amp;rdquo; This article explains why this strategy is unlikely to work.&lt;/p&gt;

&lt;h3 id=&#34;short-summary&#34;&gt;Short Summary&lt;/h3&gt;

&lt;p&gt;Your Perl program is being run by the Perl interpreter. You want a C program that does the same thing that your Perl program does. A C program to do what your Perl program does would have to do most of the same things that the Perl interpreter does when it runs your Perl program. There is no reason to think that the C program could do those things faster than the Perl interpreter does them, because the Perl interpreter itself is written in very fast C.&lt;/p&gt;

&lt;p&gt;Some detailed case studies follow.&lt;/p&gt;

&lt;h3 id=&#34;built-in-functions&#34;&gt;Built-In Functions&lt;/h3&gt;

&lt;p&gt;Suppose your program needs to split a line into fields, and uses the Perl &lt;code&gt;split&lt;/code&gt; function to do so. You want to compile this to C so it will be faster.&lt;/p&gt;

&lt;p&gt;This is obviously not going to work, because the &lt;code&gt;split&lt;/code&gt; function is already implemented in C. If you have the Perl source code, you can see the implementation of &lt;code&gt;split&lt;/code&gt; in the file &lt;code&gt;pp.c&lt;/code&gt;; it is in the function named &lt;code&gt;pp_split&lt;/code&gt;. When your Perl program uses &lt;code&gt;split&lt;/code&gt;, Perl calls this &lt;code&gt;pp_split&lt;/code&gt; function to do the splitting. &lt;code&gt;pp_split&lt;/code&gt; is written in C, and it has already been compiled to native machine code.&lt;/p&gt;

&lt;p&gt;Now, suppose you want to translate your Perl program to C. How will you translate your &lt;code&gt;split&lt;/code&gt; call? The only thing you can do is translate it to a call to the C &lt;code&gt;pp_split&lt;/code&gt; function, or some other equivalent function that splits. There is no reason to believe that any C implementation of &lt;code&gt;split&lt;/code&gt; will be faster than the &lt;code&gt;pp_split&lt;/code&gt; that Perl already has. Years of work have gone into making &lt;code&gt;pp_split&lt;/code&gt; as fast as possible.&lt;/p&gt;

&lt;p&gt;You can make the same argument for all of Perl&amp;rsquo;s other built-in functions, such as &lt;code&gt;join&lt;/code&gt;, &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;rand&lt;/code&gt; and &lt;code&gt;readdir&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So much for built-in functions.&lt;/p&gt;

&lt;h3 id=&#34;data-structures&#34;&gt;Data Structures&lt;/h3&gt;

&lt;p&gt;Why is Perl slow to begin with? One major reason is that its data structures are extremely flexible, and this flexibility imposes a speed penalty.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look in detail at an important example: strings. Consider this Perl code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        $x = &#39;foo&#39;;     
        $y = &#39;bar&#39;;
        $x .= $y;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is, we want to append &lt;code&gt;$y&lt;/code&gt; to the end of &lt;code&gt;$x&lt;/code&gt;. In C, this is extremely tricky. In C, you would start by doing something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        char *x = &amp;quot;foo&amp;quot;;
        char *y = &amp;quot;bar&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you have a problem. You would like to insert &lt;code&gt;bar&lt;/code&gt; at the end of the buffer pointed to by &lt;code&gt;x&lt;/code&gt;. But you can&amp;rsquo;t, because there is not enough room; &lt;code&gt;x&lt;/code&gt; only points to enough space for four characters, and you need space for seven. (C strings always have an extra &lt;code&gt;nul&lt;/code&gt; character on the end.) To append &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;, you must allocate a new buffer, and then arrange for &lt;code&gt;x&lt;/code&gt; to point to the new buffer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        char *tmp = malloc(strlen(x) + strlen(y) + 1);
        strcpy(tmp, x);
        strcat(tmp, y);
        x = tmp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works fine if &lt;code&gt;x&lt;/code&gt; is the only pointer to that particular buffer. But if some other part of the program also had a pointer to the buffer, this code does not work. Why not? Here&amp;rsquo;s the picture of what we did:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BEFORE:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2001_06_27_ctoperl/cbef.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Here &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt; are two variables that both contain pointers to the same buffer. We want to append &lt;code&gt;bar&lt;/code&gt; to the end of the string. But the C code we used above doesn&amp;rsquo;t quite work, because we allocated a new region of memory to hold the result, and then pointed &lt;code&gt;x&lt;/code&gt; to it:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AFTER &lt;code&gt;x = tmp&lt;/code&gt;:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2001_06_27_ctoperl/caft.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s tempting to think that we should just point &lt;code&gt;z&lt;/code&gt; to the new buffer also, but in practice this is impossible. The function that is doing the appending cannot know whether there is such a &lt;code&gt;z&lt;/code&gt;, or where it may be. There might be 100 variables like &lt;code&gt;z&lt;/code&gt; all pointing to the old buffer, and there is no good way to keep track of them so that they can all be changed when the array moves.&lt;/p&gt;

&lt;p&gt;Perl does support a transparent string append operation. Let&amp;rsquo;s see how this works. In Perl, a variable like &lt;code&gt;$x&lt;/code&gt; does not point directly at the buffer. Instead, it points at a structure called an SV. (&amp;lsquo;Scalar Value&amp;rsquo;) The SV has the pointer to the buffer, and also some other things that I do not show:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BEFORE &lt;code&gt;$x .= $y&lt;/code&gt;&lt;/strong&gt;
&lt;img src=&#34;http://localhost:1313/images/_pub_2001_06_27_ctoperl/pbef.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;When you ask Perl to append &lt;code&gt;bar&lt;/code&gt; to &lt;code&gt;$x&lt;/code&gt;, it follows the pointers and finds that there is not enough space in the buffer. So, just as in C, it allocates a new buffer and stores the result in the new buffer. Then it fixes the pointer in the SV to point to the new buffer, and it throws away the old buffer:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2001_06_27_ctoperl/paft.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$z&lt;/code&gt; have both changed. If there were any other variables sharing the SV, their values would have changed also. This technique is called &amp;ldquo;double indirection,&amp;lsquo;&amp;rdquo; and it is how Perl can support operations like &lt;code&gt;.=&lt;/code&gt;. A similar principle applies for arrays; this is how Perl can support the &lt;code&gt;push&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;The flexibility comes at a price: Whenever you want to use the value of &lt;code&gt;$x&lt;/code&gt;, Perl must follow two pointers to get the value: The first to find the SV structure, and the second to get to the buffer with the character data. This means that using a string in Perl takes at least twice as long as in C. In C, you follow just one pointer.&lt;/p&gt;

&lt;p&gt;If you want to compile Perl to C, you have a big problem. You would like to support operations like &lt;code&gt;.=&lt;/code&gt; and &lt;code&gt;push&lt;/code&gt;, but C does not support these very well. There are only three solutions:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Don&amp;rsquo;t support &lt;code&gt;.=&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This is a bad solution, because after you disallow all the Perl operations like &lt;code&gt;.=&lt;/code&gt; and &lt;code&gt;push&lt;/code&gt; what you have left is not very much like Perl; it is much more like C, and then you might as well just write the program in C in the first place.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Do something extremely clever&lt;/p&gt;

&lt;p&gt;Cleverness is in short supply this month. &lt;code&gt;:)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use a double-indirection technique in the compiled C code&lt;/p&gt;

&lt;p&gt;This works, but the resulting C code will be slow, because you will have to traverse twice as many pointers each time you want to look up the value of a variable. But that is why Perl is slow! Perl is already doing the double-indirection lookup in C, and the code to do this has already been compiled to native machine code.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So again, it&amp;rsquo;s not clear that you are going to get any benefit from translating Perl to C. The slowness of Perl comes from the flexibility of the data structures. The code to manipulate these structures is already written in C. If you translate a Perl program to C, you have the choice of throwing away the flexibility of the data structure, in which case you are now writing C programs with C structures, or keeping the flexibility with the same speed penalty. You probably cannot speed up the data structures, because if anyone knew how to make the structures faster and still keep them flexible, they would already have made those changes in the C code for Perl itself.&lt;/p&gt;

&lt;h3 id=&#34;possible-future-work&#34;&gt;Possible Future Work&lt;/h3&gt;

&lt;p&gt;It should now be clear that although it might not be hard to translate Perl to C, programs probably will not be faster as a result.&lt;/p&gt;

&lt;p&gt;However, it&amp;rsquo;s possible that a sufficiently clever person could make a Perl-to-C translator that produced faster C code. The programmer would need to give hints to the translator to say how the variables were being used. For example, suppose you have an array &lt;code&gt;@a&lt;/code&gt;. With such an array, Perl is ready for anything. You might do &lt;code&gt;$a[1000000] = &#39;hello&#39;;&lt;/code&gt; or &lt;code&gt;$a[500] .= &#39;foo&#39;;&lt;/code&gt; or &lt;code&gt;$a[500] /= 17;&lt;/code&gt;. This flexibility is expensive. But suppose you know that this array will only hold integers and there will never be more than 1,000 integers. You might tell the translator that, and then instead of producing C code to manage a slow Perl array, the translator can produce&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;int a[&lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;];&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and use a fast C array of machine integers.&lt;/p&gt;

&lt;p&gt;To do this, you have to be very clever and you have to think of a way of explaining to the translator that &lt;code&gt;@a&lt;/code&gt; will never be bigger than 1,000 elements and will only contain integers, or a way for the translator to guess that just from looking at the Perl program.&lt;/p&gt;

&lt;p&gt;People are planning these features for Perl 6 right now. For example, Larry Wall, the author of Perl, plans that you will be able to declare a Perl array as&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; int @a is dim(&lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then a Perl-to-C translator (or Perl itself) might be able to use a fast C array of machine integers rather than a slow Perl array of SVs. If you are interested, you may want to join the perl6-internals mailing list.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

