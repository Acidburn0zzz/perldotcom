<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Epl on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/epl/</link>
    <description>Recent content in Epl on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 13 Mar 2001 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/epl/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Creating Modular Web Pages With EmbPerl</title>
      <link>http://localhost:1313/pub/2001/03/embperl.html/</link>
      <pubDate>Tue, 13 Mar 2001 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2001/03/embperl.html/</guid>
      <description>

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Table of Contents&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;•&lt;a href=&#34;#getting%20started&#34;&gt;Getting Started&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
•&lt;a href=&#34;#Hello%20World&#34;&gt;Hello World&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
•&lt;a href=&#34;#websiteglobal%20variables&#34;&gt;Web Site Global Variables&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
•&lt;a href=&#34;#modular%20files&#34;&gt;Modular Files&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
•&lt;a href=&#34;#modular%20file%20inheritance&#34;&gt;Modular File Inheritance&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
•&lt;a href=&#34;#subroutines%20in%20embperlobject&#34;&gt;Subroutines in EmbperlObject&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
•&lt;a href=&#34;#conclusions&#34;&gt;Conclusions&lt;/a&gt;&lt;br /&gt;
&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;This tutorial is intended as a complement to the Embperl documentation, not a replacement. We assume a basic familiarity with Apache, mod_perl and Perl, and the Embperl documentation. No prior experience with EmbperlObject is assumed. The real purpose is to give a clearer idea of how EmbperlObject can help you build large Web sites. We give example code that can serve as a starting template and hints about the best practices that have come out of real experience using the toolkit. As always, there is more than one way to do it!&lt;/p&gt;

&lt;p&gt;Since EmbperlObject is an evolving tool, it is likely that these design patterns will evolve over time, and it is recommended that the reader check back on the Embperl Web site for new versions.&lt;/p&gt;

&lt;h3 id=&#34;span-id-motivation-constructing-modular-websites-motivation-constructing-modular-web-sites-span&#34;&gt;&lt;span id=&#34;motivation: constructing modular websites&#34;&gt;Motivation: Constructing Modular Web Sites&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Embperl is a tool that allows you to embed Perl code in your HTML documents. As such, it could handle just about everything you need to do with your Web site. So what is the point of EmbperlObject? What does it give us that we don&amp;rsquo;t already get with basic Embperl?&lt;/p&gt;

&lt;p&gt;As often seems to be the case with Perl, the answer has to do with laziness. We would all like the task of building Web sites to be as simple as possible. Anyone who has had to build a non-trivial site using pure HTML will have quickly experienced the irritation of having to copy-and-paste common code between documents - stuff like navigation bars and table formats. We have probably all wished for an ``include&amp;rdquo; HTML tag. EmbperlObject goes a long way toward solving this problem, without requiring the developer to resort to a lot of customized Perl code.&lt;/p&gt;

&lt;p&gt;In a nutshell, EmbperlObject extends Embperl by enabling the construction of Web sites in a modular, or object-oriented, fashion. I am using the term ``object-oriented&amp;rdquo; (OO) loosely here in the context of inheritance and overloading, but you don&amp;rsquo;t really need to know anything about the OO paradigm to benefit from EmbperlObject. As you will see from this short tutorial, it is possible to benefit from using EmbperlObject with even a minimal knowledge of Perl. With just a little instruction, in fact, pure HTML coders can use it to improve their Web site architecture. Having said that, however, EmbperlObject also provides for more advanced OO functionality, as we&amp;rsquo;ll see later.&lt;/p&gt;

&lt;h3 id=&#34;span-id-getting-started-getting-started-span&#34;&gt;&lt;span id=&#34;getting started&#34;&gt;Getting Started&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ll assume that you&amp;rsquo;ve successfully installed the latest Apache, mod_perl and Embperl on your system. That should all be relatively painless - problems normally occur when mixing older versions of one tool with later versions of another. If you can, try to download the latest versions of everything.&lt;/p&gt;

&lt;p&gt;Having done all that, you might want to get going with configuring a Web site. The first thing you need to do is set up the Apache config file, usually called &lt;em&gt;httpd.conf&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-configuring-httpd-conf-configuring-httpd-conf-span&#34;&gt;&lt;span id=&#34;configuring httpd.conf&#34;&gt;Configuring &lt;em&gt;httpd.conf&lt;/em&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The following is an example configuration for a single virtual host to use EmbperlObject. There are, as usual, different ways to do this; but if you are starting from scratch, then it may be useful as a template. It works with the later versions of Apache (1.3.6 and up). Obviously, substitute your own IP address and domain name.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        NameVirtualHost 10.1.1.3:80

        &amp;lt;VirtualHost 10.1.1.3:80&amp;gt;
                ServerName www.mydomain.com
                ServerAdmin webmaster@mydomain.com
                DocumentRoot /www/mydomain/com/htdocs
                DirectoryIndex index.html
                ErrorLog /www/mydomain/com/logs/error_log
                TransferLog /www/mydomain/com/logs/access_log
                PerlSetEnv EMBPERL_ESCMODE 0
                PerlSetEnv EMBPERL_OPTIONS 16
                PerlSetEnv EMBPERL_MAILHOST mail.mydomain.com
                PerlSetEnv EMBPERL_OBJECT_BASE base.epl
                PerlSetEnv EMBPERL_OBJECT_FALLBACK notfound.html
                PerlSetEnv EMBPERL_DEBUG 0
        &amp;lt;/VirtualHost&amp;gt;

        # Set EmbPerl handler for main directory
        &amp;lt;Directory &amp;quot;/www/mydomain/com/htdocs/&amp;quot;&amp;gt;
                &amp;lt;FilesMatch &amp;quot;.*\.html$&amp;quot;&amp;gt;
                        SetHandler  perl-script
                        PerlHandler HTML::EmbperlObject
                        Options     ExecCGI
                &amp;lt;/FilesMatch&amp;gt;
                &amp;lt;FilesMatch &amp;quot;.*\.epl$&amp;quot;&amp;gt;
                        Order allow,deny
                        Deny From all
                &amp;lt;/FilesMatch&amp;gt;
        &amp;lt;/Directory&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that you could change the .html file extension in the FilesMatch directive; this is a personal preference issue. Personally, I use .html for the main document files because I can edit files using my favorite editor (emacs) and it will automatically load html mode. Plus, this may be a minor thing - but using .html rather than a special extension such as .epl adds a small amount of security to your site since it provides no clue that the Web site is using Embperl. If you&amp;rsquo;re careful about the handling of error messages, then there never will be any indication of this. These days, the less the script kiddies can deduce about you, the better &amp;hellip;&lt;/p&gt;

&lt;p&gt;Also, note that we have added a second FilesMatch directive, which denies direct access to files with .epl extensions (again, you could change this extension to another if you like, for example, .obj). This can be helpful for cases where you have Embperl files that contain fragments of code or HTML; you want those files to be in the Apache document tree, but you don&amp;rsquo;t want people to be able to request them directly - these files should only included directly into other documents from within Embperl, using Execute(). This is really a security issue. In the following examples, we name files that are not intended to be requested directly with the .epl extension. Files that are intended to be directly requested are named with the standard .html extension. This can also be helpful when scanning a directory to see which are the main document files and which are the modules. Finally, note that using the Apache FilesMatch directive to restrict access does not prevent us from accessing these files (via Execute) in Embperl.&lt;/p&gt;

&lt;p&gt;So how does all this translate into a real Web site? Let&amp;rsquo;s look at the classic example, Hello World.&lt;/p&gt;

&lt;h3 id=&#34;span-id-hello-world-hello-world-span&#34;&gt;&lt;span id=&#34;hello world&#34;&gt;Hello World&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The file specified by the EMBPERL_OBJECT_BASE apache directive (usually called &lt;em&gt;base.epl&lt;/em&gt;) is the lynchpin of how EmbperlObject operates. Whenever a request comes for any page on this Web site, Emperl will look for &lt;em&gt;base.epl&lt;/em&gt; - first in the same directory as the request, and if it&amp;rsquo;s not found there, then working up the directory tree to the root directory of the Web site. For example, if a request comes for &lt;a href=&#34;http://www.yoursite.com/foo/bar/file.html&#34;&gt;http://www.yoursite.com/foo/bar/file.html&lt;/a&gt;, then Embperl first looks for &lt;em&gt;/foo/bar/base.epl&lt;/em&gt;. If it doesn&amp;rsquo;t find &lt;em&gt;base.epl&lt;/em&gt; there, then it looks in &lt;em&gt;/foo/base.epl&lt;/em&gt;. If there&amp;rsquo;s still no luck, then it finally looks in &lt;em&gt;/base.epl&lt;/em&gt;. (These paths are all relative to the document root for the Web site). What is the point of all this?&lt;/p&gt;

&lt;p&gt;In a nutshell, &lt;em&gt;base.epl&lt;/em&gt; is a template for giving a common look-and-feel to your Web pages. This file is what is used to build the response to any request, regardless of the actual filename that was requested. So even if &lt;em&gt;file.html&lt;/em&gt; was requested, &lt;em&gt;base.epl&lt;/em&gt; is what is actually executed. &lt;em&gt;base.epl&lt;/em&gt; is a normal file containing valid HTML mixed with Perl code, but with a few small differences. Here&amp;rsquo;s a simple &amp;lsquo;Hello World&amp;rsquo; example of this approach:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;/base.epl&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        &amp;lt;HTML&amp;gt;
        &amp;lt;HEAD&amp;gt;
                &amp;lt;TITLE&amp;gt;Some title&amp;lt;/TITLE&amp;gt;
        &amp;lt;/HEAD&amp;gt;
        &amp;lt;BODY&amp;gt;
        Joe&#39;s Website
        &amp;lt;P&amp;gt;
        [- Execute (&#39;*&#39;) -]
        &amp;lt;/BODY&amp;gt;
        &amp;lt;/HTML&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;/hello.html&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        Hello world!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, if the file &lt;a href=&#34;http://www.yoursite.com/hello.html&#34;&gt;http://www.yoursite.com/hello.html&lt;/a&gt; is requested, then &lt;em&gt;base.epl&lt;/em&gt; is what will get executed initially. So where does the file &lt;em&gt;hello.html&lt;/em&gt; come into the picture? Well, the key is the &amp;lsquo;*&amp;rsquo; parameter in the call to Execute(). &amp;lsquo;*&amp;rsquo; is a special filename, only used in &lt;em&gt;base.epl&lt;/em&gt;. It means, literally, ``the filename that was actually requested.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;What you will see if you try this example is something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        Joe&#39;s Website

        Hello world!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see here, the text ``Joe&amp;rsquo;s Web Site&amp;rdquo; is from &lt;em&gt;base.epl&lt;/em&gt; and the ``Hello world!&amp;rdquo; is from &lt;em&gt;hello.html&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This architecture also means that only &lt;em&gt;base.epl&lt;/em&gt; has to have the boilerplate code that each HTML file normally needs to contain - namely the &amp;lt;HTML&amp;gt; &amp;lt;BODY&amp;gt;, &amp;lt;/HTML&amp;gt; and so on. Since the &amp;lsquo;*&amp;rsquo; file is simply inserted into the code, all it needs to contain is the actual content that is specific to that file. Nothing else is necessary, because &lt;em&gt;base.epl&lt;/em&gt; has all the standard HTML trappings. Of course, you&amp;rsquo;ll probably have more interesting content, but you get the point.&lt;/p&gt;

&lt;h3 id=&#34;span-id-websiteglobal-variables-web-site-global-variables-span&#34;&gt;&lt;span id=&#34;websiteglobal variables&#34;&gt;Web Site Global Variables&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s look at a more interesting example. When you create Perl variables in Embperl usually their scope is the current file; so they are effectively ``local&amp;rdquo; to that file. When you split your Web site into modules, however, it quickly becomes apparent that it is useful to have variables that are global to the Web site, i.e., shared between multiple files.&lt;/p&gt;

&lt;p&gt;To achieve this, EmbperlObject has a special object that is automatically passed to each page as it is executed. This object is usually referred to as the ``Request&amp;rdquo; object, because we get one of these objects created for each document request that the Web server receives. This object is passed in on the stack, so you can retrieve it using the Perl ``shift&amp;rdquo; statement. This object is also automatically destroyed after the request, so the Request object cannot be used to store data between requests. The idea is that you can store variables that are local to the current request, and shared between all documents on the current Web site; plus, as we&amp;rsquo;ll see later, we can also use it to call object methods. For example, let&amp;rsquo;s say you set up some variables in &lt;em&gt;base.epl&lt;/em&gt;, and then use them in &lt;em&gt;file.html&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;/base.epl&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        &amp;lt;HTML&amp;gt;
        &amp;lt;HEAD&amp;gt;
                &amp;lt;TITLE&amp;gt;Some title&amp;lt;/TITLE&amp;gt;
        &amp;lt;/HEAD&amp;gt;
        [- 
                $req = shift;
                $req-&amp;gt;{webmaster} = &#39;John Smith&#39;
        -]
        &amp;lt;BODY&amp;gt;
        [- Execute (&#39;*&#39;) -]
        &amp;lt;/BODY&amp;gt;
        &amp;lt;/HTML&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;/file.html&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        [- $req = shift -]
        Please send all suggestions to [+ $req-&amp;gt;{webmaster} +].
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see that EmbperlObject is allowing us to set up global variables in one place and share them throughout the Web site. If you place &lt;em&gt;base.epl&lt;/em&gt; in the root document directory, you can have any number of other files in this and subdirectories, and they will all get these variables whenever they are executed. No matter which file is requested, &lt;em&gt;/base.epl&lt;/em&gt; is executed first and then the requested file.&lt;/p&gt;

&lt;p&gt;You don&amp;rsquo;t even need to include the requested &amp;lsquo;*&amp;rsquo; file, but typically you will have to - it would be a bit odd to ignore the requested file!&lt;/p&gt;

&lt;h3 id=&#34;span-id-modular-files-modular-files-span&#34;&gt;&lt;span id=&#34;modular files&#34;&gt;Modular Files&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The previous example is nice; it demonstrates the basic ability to have Web site-wide variables set up in &lt;em&gt;base.epl&lt;/em&gt; and then automatically have them shared by all other files. Leading on from this, we probably want to split up our files, for both maintainability and readability. For example, a non-trivial Web site will probably define some Web site-wide constants, perhaps some global variables, and maybe also have some kind of initialization code that has to be executed for each page (e.g. setting up a database connection). We could put all of this in &lt;em&gt;base.epl&lt;/em&gt;, but this file would quickly begin to look messy. It would be nice to split this stuff out into other files. For example:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;/base.epl&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        &amp;lt;HTML&amp;gt;
        [- Execute (&#39;constants.epl&#39;)-]
        [- Execute (&#39;init.epl&#39;)-]
        &amp;lt;HEAD&amp;gt;
                &amp;lt;TITLE&amp;gt;Some title&amp;lt;/TITLE&amp;gt;
        &amp;lt;/HEAD&amp;gt;
        &amp;lt;BODY&amp;gt;
        [- Execute (&#39;*&#39;) -]
        &amp;lt;/BODY&amp;gt;
        [- Execute (&#39;cleanup.epl&#39;) -]
        &amp;lt;/HTML&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;/constants.epl&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        [-
                $req = shift;
                $req-&amp;gt;{bgcolor} = &amp;quot;white&amp;quot;;
                $req-&amp;gt;{webmaster} = &amp;quot;John Smith&amp;quot;;
                $req-&amp;gt;{website_database} = &amp;quot;mydatabase&amp;quot;;
        -]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;/init.epl&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        [-
                $req = shift;
                # Set up database connection
                use DBI;
                use CGI qw(:standard);
                $dsn = &amp;quot;DBI:mysql:$req-&amp;gt;{website_database}&amp;quot;;
                $req-&amp;gt;{dbh} = DBI-&amp;gt;connect ($dsn);
        -]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;/cleanup.epl&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        [-
                $req = shift;
                # Close down database connection
                $req-&amp;gt;{dbh}-&amp;gt;disconnect();
        -]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see how this would be useful, since each page on your site now has a database connection available in $req-&amp;gt;{dbh}. Also notice that we have a &lt;em&gt;cleanup.epl&lt;/em&gt; file that is always executed at the end - this is useful for cleaning up, shutting down connections and so on.&lt;/p&gt;

&lt;h3 id=&#34;span-id-modular-file-inheritance-modular-file-inheritance-span&#34;&gt;&lt;span id=&#34;modular file inheritance&#34;&gt;Modular File Inheritance&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;To recap, we have seen how we can break our site into modules that are common across multiple files, because they are automatically included by &lt;em&gt;base.epl&lt;/em&gt;. Inheritance is a way in which we can make our Web sites more modular.&lt;/p&gt;

&lt;p&gt;Although the concept of inheritance is one that stems from the object-oriented paradigm, you really don&amp;rsquo;t need to be an OO guru to understand it. We will demonstrate the concept through a simple example.&lt;/p&gt;

&lt;p&gt;Say you wanted different parts of your Web site to have different &amp;lt;TITLE&amp;gt; tags. You could set the title in each page manually, but if you had a number of different pages in each section, then this would quickly get tiresome. We could split off the &amp;lt;HEAD&amp;gt; section into its own file, just like &lt;em&gt;constants.epl&lt;/em&gt; and &lt;em&gt;init.epl&lt;/em&gt;, right? But so far, it looks like we are stuck with a single &lt;em&gt;head.epl&lt;/em&gt; file for the entire Web site, which doesn&amp;rsquo;t really help much.&lt;/p&gt;

&lt;p&gt;The answer lies in subdirectories. This is the key to unlocking inheritance and one of the most powerful features of EmbperlObject. You may use subdirectories currently in your Web site design, maybe for purposes of organization and maintenance. But here, subdirectories actually enable you to override files from upper directories. This is best demonstrated by example (simplified to make this specific point clearer - assume &lt;em&gt;constants.epl&lt;/em&gt;, &lt;em&gt;init.epl&lt;/em&gt; and &lt;em&gt;cleanup.epl&lt;/em&gt; are the same as in the previous example):&lt;/p&gt;

&lt;p&gt;&lt;em&gt;/base.epl&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        &amp;lt;HTML&amp;gt;
        [- Execute (&#39;constants.epl&#39;)-]
        [- Execute (&#39;init.epl&#39;)-]
        &amp;lt;HEAD&amp;gt;
        [- Execute (&#39;head.epl&#39;)-]
        &amp;lt;/HEAD&amp;gt;
        &amp;lt;BODY&amp;gt;
        [- Execute (&#39;*&#39;) -]
        &amp;lt;/BODY&amp;gt;
        [- Execute (&#39;cleanup.epl&#39;) -]
        &amp;lt;/HTML&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;/head.epl&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        &amp;lt;TITLE&amp;gt;Joe&#39;s Website&amp;lt;/TITLE&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;/contact/head.epl&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        &amp;lt;TITLE&amp;gt;Contacting Joe&amp;lt;/TITLE&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Assume that we have an &lt;em&gt;index.html&lt;/em&gt; file in each directory that does something useful. The main thing to focus on is &lt;em&gt;head.epl&lt;/em&gt;. You can see that we have one instance of this file in the root directory, and one in a subdirectory, namely &lt;em&gt;/contact/head.epl&lt;/em&gt;. Here&amp;rsquo;s the neat part: When a page is requested from your Web site, EmbperlObject will search automatically for &lt;em&gt;base.epl&lt;/em&gt; first in the same directory as the requested page. If it doesn&amp;rsquo;t find it there, then it tracks back up the directory tree until it finds the file. But then, when executing &lt;em&gt;base.epl&lt;/em&gt;, any files that are Executed (such as &lt;em&gt;head.epl&lt;/em&gt;) are first looked for in the &lt;strong&gt;original directory&lt;/strong&gt; of the requested file. Again, if the file is not found there, then EmbperlObject tracks back up the directory tree.&lt;/p&gt;

&lt;p&gt;So what does this mean? Well, if we have a subdirectory, then we can see whether we want just the usual &lt;em&gt;index.html&lt;/em&gt; file and nothing else. In that case, all the files included by &lt;em&gt;base.epl&lt;/em&gt; will be found in the root document directory. But if we redefine &lt;em&gt;head.epl&lt;/em&gt;, then EmbperlObject will pick up that version of the file whenever we are in the /contact/ subdirectory.&lt;/p&gt;

&lt;p&gt;That is inheritance in action. In a nutshell, subdirectories inherit files such as &lt;em&gt;head.epl&lt;/em&gt;, &lt;em&gt;constants.epl&lt;/em&gt; and so on from ``parent&amp;rdquo; directories. But if we want, we can redefine any of these files in our subdirectories, thus specializing that functionality for that part of our Web site. If we had 20 .html files in /contact/, then loading any of them would automatically get &lt;em&gt;/contact/head.epl&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This is all very cool, but there is one more wrinkle. Let&amp;rsquo;s say we want to redefine &lt;em&gt;init.epl&lt;/em&gt;, because there is some initialization that is specific to the /contact/ subdirectory. That&amp;rsquo;s fine since we can create &lt;em&gt;/contact/init.epl&lt;/em&gt; and that file would be loaded instead of &lt;em&gt;/init.epl&lt;/em&gt; whenever a file is requested from the /contact/ subdir. But this also means that the initialization code that is in &lt;em&gt;/init.epl&lt;/em&gt; would never get executed, right? That&amp;rsquo;s bad, because the base version of the file does a lot of useful set up. The answer is simple: For cases such as this, we need to make sure to call the parent version of the file at the start. For example:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;/contact/init.epl&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        [- Execute (&#39;../init.epl&#39;) -]

        [-
                # Do some setup specific to this subdirectory
        -]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see that the first thing we do here is Execute the parent version of the file (i.e., the one in the immediate parent directory). Thus we can ensure the integrity of the basic initialization that each page should receive.&lt;/p&gt;

&lt;p&gt;EmbperlObject is smart about this process. For example, we have a situation where we have several levels of subdirectory; then, say we only redefine &lt;em&gt;init.epl&lt;/em&gt; in one of the deeper levels, say &lt;em&gt;/sub/sub/sub/init.epl&lt;/em&gt;. Now, if this file tries to Execute &lt;em&gt;../init.epl&lt;/em&gt;, there may not be any such file in the immediate parent directory - so EmbperlObject automatically tracks back up the directories until it finds the base version, &lt;em&gt;/init.epl&lt;/em&gt;. So, for any subdirectory level in your Web site, you only have to redefine those files that are specific to this particular area. This results in a much cleaner Web site.&lt;/p&gt;

&lt;p&gt;You can break up your files into whatever level of granularity you want, depending on your needs. For instance, instead of just &lt;em&gt;head.epl&lt;/em&gt; you might break it down into &lt;em&gt;title.epl&lt;/em&gt;, &lt;em&gt;metatags.epl&lt;/em&gt; and so on. It&amp;rsquo;s up to you. The more you split it up, the more you can specialize in each of the subdirectories. There is a balance, however, because splitting things up too much results in an overly fragmented site that can be harder to maintain. Moderation is the key - only split out files if they contain a substantial chunk of code, or if you know that you need to redefine them in subdirectories, generally speaking.&lt;/p&gt;

&lt;h3 id=&#34;span-id-subroutines-in-embperlobject-subroutines-in-embperlobject-span&#34;&gt;&lt;span id=&#34;subroutines in embperlobject&#34;&gt;Subroutines in EmbperlObject&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;There are two types of inheritance in EmbperlObject. The first is the one that we described in the previous section, i.e., inheritance of modular files via the directory hierarchy. The other type, which is closely related, is the inheritance of subroutines (both pure Perl and Embperl). In this context, subroutines are really object methods, as we&amp;rsquo;ll see below. As you are probably already aware, there are two types of subroutines in Embperl, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        [!
                sub perl_sub
                {
                        # Some perl code
                }
        !]

        [$ sub embperl_sub $]
                Some HTML
        [$ endsub $]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In EmbperlObject, subroutines become object methods; the difference is that you always call an object method through an object reference. For example, instead of a straight subroutine call like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        foo();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have instead a call through some object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        $obj-&amp;gt;foo();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;EmbperlObject allows you to inherit object methods in much the same way as files. Because of the way that Perl implements objects and methods, there is just a little extra consideration needed. (Note: This is not really a good place to introduce Perl&amp;rsquo;s object functionality. If you&amp;rsquo;re not comfortable with inheritance, @ISA and object methods, then I suggest you take a look at the book ``Programming Perl&amp;rdquo; (O&amp;rsquo;Reilly) or ``Object Oriented Perl&amp;rdquo; by Damien Conway (Manning).)&lt;/p&gt;

&lt;p&gt;A simple use of methods can be demonstrated using the following example:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;/base.epl&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        [! sub title {&#39;Joe&#39;s Website&#39;} !]
        [- $req = shift -]
        &amp;lt;HTML&amp;gt;
        &amp;lt;HEAD&amp;gt;
        &amp;lt;TITLE&amp;gt;[+ $req-&amp;gt;title() +]&amp;lt;/TITLE&amp;gt;
        &amp;lt;/HEAD&amp;gt;
        &amp;lt;/HTML&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;/contact/index.html&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        [! sub title {&#39;Contacting Joe&#39;} !]
        [- $req = shift -]
        &amp;lt;HTML&amp;gt;
                A contact form goes here
        &amp;lt;/HTML&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is an alternative way of implementing the previous ``contact&amp;rdquo; example, which still uses inheritance - but instead of placing the &amp;lt;TITLE&amp;gt; tag in a separate file (&lt;em&gt;head.epl&lt;/em&gt;), we use a method (title()). You can see that we define this method in &lt;em&gt;/base.epl&lt;/em&gt;, so any page that is requested from the root directory will get the title ``Joe&amp;rsquo;s Web Site.&amp;rdquo; This is a good default title. Then, in &lt;em&gt;/foo/index.html&lt;/em&gt; we redefine the &lt;code&gt;title()&lt;/code&gt; method to return ``Contacting Joe.&amp;rdquo; Inheritance ensures that when the call to &lt;code&gt;title()&lt;/code&gt; occurs in &lt;em&gt;/base.epl&lt;/em&gt;, the correct version of the method will be executed. Since &lt;em&gt;/foo/index.html&lt;/em&gt; has its own version of that method, it will automatically be called instead of the base version. This allows each file to potentially redefine methods that were defined in &lt;em&gt;/base.epl&lt;/em&gt;, and it works well. But, as your Web sites get bigger, you will probably want to split off some routines into their own files.&lt;/p&gt;

&lt;p&gt;EmbperlObject also allows us to create special files that contain only inheritable object methods. EmbperlObject can set up @ISA for us, so that the Perl object methods will work as expected. To do this, we need to access our methods through a specially created object rather than directly through the Request object (usually called $r or $req). This is best illustrated by the following example, which demonstrates the code that needs to be added to &lt;em&gt;base.epl&lt;/em&gt; and shows how we implement inheritance via a subdirectory. Once again, assume that missing files such as &lt;em&gt;constants.epl&lt;/em&gt; are the same as the previous example (Note that the &amp;lsquo;object&amp;rsquo; parameter to Execute only works in 1.3.1 and above).&lt;/p&gt;

&lt;p&gt;&lt;em&gt;/base.epl&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        &amp;lt;HTML&amp;gt;
        [- $subs = Execute ({object =&amp;gt; &#39;subs.epl&#39;}); -]
        [- Execute (&#39;constants.epl&#39;) -]
        [- Execute (&#39;init.epl&#39;) -]
        &amp;lt;HEAD&amp;gt;
        [- Execute (&#39;head.epl&#39;) -]
        &amp;lt;/HEAD&amp;gt;
        &amp;lt;BODY&amp;gt;
        [- Execute (&#39;*&#39;, $subs) -]
        &amp;lt;/BODY&amp;gt;
        [- Execute (&#39;cleanup.epl&#39;) -]
        &amp;lt;/HTML&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;/subs.epl&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        [!
                sub hello
                {
                        my ($self, $name) = @_;
                        print OUT &amp;quot;Hello, $name&amp;quot;;
                }
        !]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;/insult/index.html&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        [-
                $subs = $param[0];
                $subs-&amp;gt;hello (&amp;quot;Joe&amp;quot;);
        -]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;/insult/subs.epl&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        [! Execute ({isa =&amp;gt; &#39;../subs.epl&#39;}) !]

        [!
                sub hello
                {
                        my ($self, $name) = @_;
                        $self-&amp;gt;SUPER::hello ($name);
                        print OUT &amp;quot;, you schmuck&amp;quot;;
                }
        !]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we requested the file &lt;em&gt;/insult/index.html&lt;/em&gt;, then we would see something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        Hello, Joe, you schmuck
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So what is happening? First, note that we create a $subs object in &lt;em&gt;base.epl&lt;/em&gt;, using a special call to Execute(). We then pass this object to files that will need it, via an &lt;code&gt;Execute()&lt;/code&gt; parameter. This can be seen with the &amp;lsquo;*&amp;rsquo; file.&lt;/p&gt;

&lt;p&gt;Next, we have two versions of &lt;em&gt;subs.epl&lt;/em&gt;. The first, &lt;em&gt;/subs.epl&lt;/em&gt;, is pretty straightforward. All we need to do is remember that all of these subroutines are now object methods, and so take the extra parameter ($self). The basic &lt;code&gt;hello()&lt;/code&gt; method simply says Hello to the name of the person passed in.&lt;/p&gt;

&lt;p&gt;Then we have a subdirectory, called /insult/. Here we have another instance of &lt;em&gt;subs.epl&lt;/em&gt;, and we redefine hello(). We call the parent version of the function, and then add the insult (``you schmuck&amp;rdquo;). You don&amp;rsquo;t have to call the parent version of methods you define, of course, but it&amp;rsquo;s a useful demonstration of the possibilities.&lt;/p&gt;

&lt;p&gt;The file &lt;em&gt;/insult/subs.epl&lt;/em&gt; has to have a call to &lt;code&gt;Execute()&lt;/code&gt; that sets up @ISA. This is the first line. You might ask why EmbperlObject doesn&amp;rsquo;t do this automatically; it is mainly for reasons of efficiency. Not every file is going to contain methods that need to inherit from the parent file, and so simply requiring this one line seemed to be a good compromise. It also allows for more flexibility, as you can include other arbitrary files into the @ISA tree if you want.&lt;/p&gt;

&lt;h3 id=&#34;span-id-conclusions-conclusions-span&#34;&gt;&lt;span id=&#34;conclusions&#34;&gt;Conclusions&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;So there you have it: an introduction to the use of EmbperlObject for constructing large, modular Web sites. You will probably use it to enable such things as Web site-wide navigation bars, table layouts and whatever else needs to be modularized.&lt;/p&gt;

&lt;p&gt;This document is just an introduction, to give a broad flavor of the tool. You should refer to the actual documentation for details.&lt;/p&gt;

&lt;p&gt;EmbperlObject will inevitably evolve as developers discover what is useful and what isn&amp;rsquo;t. We will try to keep this document up-to-date with these changes, but make sure to check the Embperl Web site regularly for the latest changes.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

