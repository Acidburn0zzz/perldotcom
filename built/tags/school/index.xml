<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>School on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/school/</link>
    <description>Recent content in School on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 19 Jan 2006 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/school/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Analyzing HTML with Perl</title>
      <link>http://localhost:1313/pub/2006/01/19/analyzing_html.html/</link>
      <pubDate>Thu, 19 Jan 2006 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2006/01/19/analyzing_html.html/</guid>
      <description>

&lt;p&gt;Routine work is all around us every day, no matter if you like it or not. For a teacher on computing subjects, grading assignments can be such work. Certain computing assignments aim at practicing operating skills rather than creativity, especially in elementary courses. Grading this kind of assignment is time-consuming and repetitive, if not tedious.&lt;/p&gt;

&lt;p&gt;In a business information system course that I taught, one lesson was about writing web pages. As the course was the first computing subject for the students, we used &lt;a href=&#34;http://www.nvu.com/&#34;&gt;Nvu&lt;/a&gt;, a WYSIWYG web page editor, rather than coding the HTML. One class assignment required writing three or more inter-linked web pages containing a list of HTML elements.&lt;/p&gt;

&lt;p&gt;Write three or more web pages having the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Italicized text (2 points)&lt;/li&gt;
&lt;li&gt;Bolded text (2 points)&lt;/li&gt;
&lt;li&gt;Three different colors of text (5 points)&lt;/li&gt;
&lt;li&gt;Three different sizes of text (5 points)&lt;/li&gt;
&lt;li&gt;Linked graphics with border (5 points)&lt;/li&gt;
&lt;li&gt;Linked graphics without border (5 points)&lt;/li&gt;
&lt;li&gt;Non-linked graphics with border (3 points)&lt;/li&gt;
&lt;li&gt;Non-linked graphics without border (2 points)&lt;/li&gt;
&lt;li&gt;Three external links (5 points)&lt;/li&gt;
&lt;li&gt;One horizontal line&amp;ndash;not full width of page (5 points)&lt;/li&gt;
&lt;li&gt;Three internal links to other pages (10 points)&lt;/li&gt;
&lt;li&gt;Two tables (10 points)&lt;/li&gt;
&lt;li&gt;One bulleted list (5 points)&lt;/li&gt;
&lt;li&gt;One numerical list (5 points)&lt;/li&gt;
&lt;li&gt;Non-default text color (5 points)&lt;/li&gt;
&lt;li&gt;Non-default link color (2 points)&lt;/li&gt;
&lt;li&gt;Non-default active link color (2 points)&lt;/li&gt;
&lt;li&gt;Non-default visited link color (2 points)&lt;/li&gt;
&lt;li&gt;Non-default background color (5 points)&lt;/li&gt;
&lt;li&gt;A background image (5 points)&lt;/li&gt;
&lt;li&gt;Pleasant appearance in the pages (10 points)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Beginning to grade the students&amp;rsquo; work, I found it monotonous and error-prone. Because the HTML elements could be in any of the pages, I had to jump to every page and count the HTML elements in question. I also needed to do it for each element in the requirement. While some occurrences were easy to spot in the rendered pages in a browser, others required close examination of the HTML code. For example, a student wrote a horizontal line (&lt;code&gt;&amp;lt;hr&amp;gt;&lt;/code&gt; element) extending 98 percent of the width of the window, which was difficult to differentiate visually from a full-width horizontal line. Some other students just liked to use black and dark gray as two different colors in different parts of the pages. In addition to locating the elements, awarding and totaling marks were also error-prone.&lt;/p&gt;

&lt;p&gt;I felt a little regret on the flexibility in the requirement. If I had fixed the file names of the pages and assigned the HTML elements to individual pages, grading could have been easier. Rather than continuing the work with regret, I wrote a Perl program to grade the assignments. The program essentially parses the web pages, awards marks according to the requirements, writes basic comments, and calculates the total score.&lt;/p&gt;

&lt;h3 id=&#34;processing-html-with-perl&#34;&gt;Processing HTML with Perl&lt;/h3&gt;

&lt;p&gt;Perl&amp;rsquo;s regular expressions have excellent text processing capability and there are handy modules for parsing web pages. The module &lt;a href=&#34;https://metacpan.org/pod/HTML::TreeBuilder&#34;&gt;&lt;code&gt;HTML::TreeBuilder&lt;/code&gt;&lt;/a&gt; provides a HTML parser that builds a tree structure of the elements in a web page. It is easy to create a tree and build its content from a HTML file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$tree = HTML::TreeBuilder-&amp;gt;new;
$tree-&amp;gt;parse_file($file_name);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nodes in the tree are &lt;a href=&#34;https://metacpan.org/pod/HTML::Element&#34;&gt;&lt;code&gt;HTML::Element&lt;/code&gt;&lt;/a&gt; objects. There are plenty of methods with which to access and manipulate elements in the tree. When you finish using the tree, destroy it and free the memory it occupied:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$tree-&amp;gt;delete;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The module &lt;code&gt;HTML::Element&lt;/code&gt; represents HTML elements in tree structures created by &lt;code&gt;HTML::TreeBuilder&lt;/code&gt;. It has a huge number of methods for accessing and manipulating the element and searching for descendants down the tree or ancestors up the tree. The method &lt;code&gt;find()&lt;/code&gt; retrieves all descending elements with one or more specified tag names. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@elements = $element-&amp;gt;find(&#39;a&#39;, &#39;img&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;stores all &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; elements at or under &lt;code&gt;$element&lt;/code&gt; to the array &lt;code&gt;@elements&lt;/code&gt;. The method &lt;code&gt;look_down()&lt;/code&gt; is a more powerful version of &lt;code&gt;find()&lt;/code&gt;. It selects descending elements by three kinds of criteria: exactly specifying an attribute&amp;rsquo;s value or a tag name, matching an attribute&amp;rsquo;s value or tag name by a regular expression, and applying a subroutine that returns true on examining desired elements. Here are some examples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@anchors = $element-&amp;gt;look_down(&#39;_tag&#39; =&amp;gt; &#39;a&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;retrieves all &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; elements at or under &lt;code&gt;$element&lt;/code&gt; and stores them to the array &lt;code&gt;@anchors&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@colors = $element-&amp;gt;look_down(&#39;style&#39; =&amp;gt; qr/color/);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;selects all elements at or under &lt;code&gt;$element&lt;/code&gt; having a &lt;code&gt;style&lt;/code&gt; attribute value that contains &lt;code&gt;color&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@largeimages = $element-&amp;gt;look_down(
    sub {
         $_[0]-&amp;gt;tag() eq &#39;img&#39;          and
        ($_[0]-&amp;gt;attr(&#39;width&#39;) &amp;gt; 100 or
         $_[0]-&amp;gt;attr(&#39;height&#39;)  &amp;gt; 100)
    }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;locates at or under &lt;code&gt;$element&lt;/code&gt; all images (&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; elements) with widths or heights larger than 100 pixels. Note that this code will produce a warning message on encountering an &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; element that has no &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;height&lt;/code&gt; attribute.&lt;/p&gt;

&lt;p&gt;You can also mix the three kinds of criteria into one invocation of &lt;code&gt;look_down&lt;/code&gt;. The last example could also be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@largeimages = $element-&amp;gt;look_down(
    &#39;_tag&#39;   =&amp;gt; &#39;img&#39;,
    &#39;width&#39;  =&amp;gt; qr//,
    &#39;height&#39; =&amp;gt; qr//,
    sub { $_[0]-&amp;gt;attr(&#39;width&#39;)  &amp;gt; 100 or
          $_[0]-&amp;gt;attr(&#39;height&#39;) &amp;gt; 100 }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code also caters for any missing &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;height&lt;/code&gt; attribute in an &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; element. The parameters &lt;code&gt;&#39;width&#39; =&amp;gt; qr//&lt;/code&gt; and &lt;code&gt;&#39;height&#39; =&amp;gt; qr//&lt;/code&gt; guarantee selection of only those &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; elements that have both &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;height&lt;/code&gt; attributes. The code block checks these for the attribute values, when invoked.&lt;/p&gt;

&lt;p&gt;The method &lt;code&gt;look_up()&lt;/code&gt; looks for ancestors from an element by the same kinds of criteria of &lt;code&gt;look_down()&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;processing-multiple-files&#34;&gt;Processing Multiple Files&lt;/h3&gt;

&lt;p&gt;These methods provide great HTML parsing capability to grade the web page assignments. The grading program first builds the tree structures from the HTML files and stores them in an array &lt;code&gt;@trees&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my @trees;
foreach (@files) {
    print &amp;quot;  building tree for $_ ...\n&amp;quot; if $options{v};
    my $tree = HTML::TreeBuilder-&amp;gt;new;
    $tree-&amp;gt;parse_file($_);
    push( @trees, $tree );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The subroutine &lt;code&gt;doitem()&lt;/code&gt; iterates through the array of trees, applying a pass-in code block to look for particular HTML elements in each tree and accumulating the results of calling the code block. To provide detailed information and facilitate debugging during development, it calls the convenience subroutine &lt;code&gt;printd()&lt;/code&gt; to display the HTML elements found with their corresponding file name when the verbose command line switch (&lt;code&gt;-v&lt;/code&gt;) is set. Essentially, the code invokes this subroutine once for each kind of element in the requirement.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub doitem {
    my $func = shift;
    my $num  = 0;
    foreach my $i ( 0 .. $#files ) {
        my @elements = $func-&amp;gt;( $files[$i], $trees[$i] );
        printd $files[$i], @elements;
        $num += @elements;
    }
    return $num;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code block passed into &lt;code&gt;doitem&lt;/code&gt; is a subroutine that takes two parameters of a file name and its corresponding HTML tree and returns an array of selected elements in the tree. The following code block retrieves all HTML elements in italic, including the &lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt; elements (for example, &lt;code&gt;&amp;lt;i&amp;gt;text&amp;lt;/i&amp;gt;&lt;/code&gt;) and elements with a &lt;code&gt;font-style&lt;/code&gt; of &lt;code&gt;italic&lt;/code&gt; (for example, &lt;code&gt;&amp;lt;span STYLE=&amp;quot;font-style: italic&amp;quot;&amp;gt;text&amp;lt;/span&amp;gt;&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$n = doitem sub {
    my ( $file, $tree ) = @_;
    return ( $tree-&amp;gt;find(&amp;quot;i&amp;quot;),
        $tree-&amp;gt;look_down( &amp;quot;style&amp;quot; =&amp;gt; qr/font-style *: *italic/ ) );
    };

marking &amp;quot;Italicized text (2 points): &amp;quot;
  . ( ( $n &amp;gt; 0 ) ? &amp;quot;good. 2&amp;quot; : &amp;quot;no italic text. 0&amp;quot;
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Two points are available for any italic text in the pages. The &lt;code&gt;marking&lt;/code&gt; subroutine records grading in a string. At the end of the program, examining the string helps to calculate the total points.&lt;/p&gt;

&lt;p&gt;Other requirements are marked in the same manner, though some selection code is more involved. A regular expression helps to select elements with non-default colors.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $pattern = qr/(^|[^-])color *: *rgb\( *[0-9]*, *[0-9]*, *[0-9]*\)/;
return $tree-&amp;gt;look_down(
    &amp;quot;style&amp;quot; =&amp;gt; $pattern,
    sub { $_[0]-&amp;gt;as_trimmed_text ne &amp;quot;&amp;quot; }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nvu applies colors to text by the &lt;code&gt;color&lt;/code&gt; style in the form of &lt;code&gt;rgb(R,G,B)&lt;/code&gt; (for example, &lt;code&gt;&amp;lt;span STYLE=&amp;quot;color: rgb(0, 0, 255);&amp;quot;&amp;gt;text&amp;lt;/span&amp;gt;&lt;/code&gt;). The above code is slightly stricter than the italic code, as it also requires an element to contain some text. The method &lt;code&gt;as_trimmed_text()&lt;/code&gt; of &lt;code&gt;HTML::Element&lt;/code&gt; returns the textual content of an element with any leading and trailing spaces removed.&lt;/p&gt;

&lt;p&gt;Nested invocations of &lt;code&gt;look_down()&lt;/code&gt; locate linked graphics with a border. This selects any link (an &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; element) that encloses an image (an &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; element) that has a border.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return $tree-&amp;gt;look_down(
    &amp;quot;_tag&amp;quot; =&amp;gt; &amp;quot;a&amp;quot;,
    sub {
       $_[0]-&amp;gt;look_down( &amp;quot;_tag&amp;quot; =&amp;gt; &amp;quot;img&amp;quot;, sub { hasBorder( $_[0] ) } );
    }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finding non-linked graphics is more interesting, as it involves both the methods &lt;code&gt;look_down()&lt;/code&gt; and &lt;code&gt;look_up()&lt;/code&gt;. It should only find images (&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; elements) that do not have a parent link (a &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; element) up the tree.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return $tree-&amp;gt;look_down(
    &amp;quot;_tag&amp;quot; =&amp;gt; &amp;quot;img&amp;quot;,
    sub { !$_[0]-&amp;gt;look_up( &amp;quot;_tag&amp;quot; =&amp;gt; &amp;quot;a&amp;quot; ) and hasBorder( $_[0] ); }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Checking valid internal links requires passing &lt;code&gt;look_down()&lt;/code&gt; a code block that excludes common external links by checking the &lt;code&gt;href&lt;/code&gt; value against protocol names, and verifies the existence of the file linked in the web page.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use File::Basename;
$n = doitem sub {
    my ( $file, $tree ) = @_;
    return $tree-&amp;gt;look_down(
        &amp;quot;_tag&amp;quot; =&amp;gt; &amp;quot;a&amp;quot;,
        &amp;quot;href&amp;quot; =&amp;gt; qr//,
        sub {
            !( $_[0]-&amp;gt;attr(&amp;quot;href&amp;quot;) =~ /^ *(http:|https:|ftp:|mailto:)/)
            and -e dirname($file) . &amp;quot;/&amp;quot; . decodeURL( $_[0]-&amp;gt;attr(&amp;quot;href&amp;quot;) );
        }
    );
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nvu changes a page&amp;rsquo;s text color by specifying the color components in the style of the &lt;code&gt;body&lt;/code&gt; tag, like &lt;code&gt;&amp;lt;body style=&amp;quot;color: rgb(0, 0, 255);&amp;quot;&amp;gt;&lt;/code&gt;. A regular expression matches the style pattern and retrieves the three color components. Any non-zero color component denotes a non-default text color in a page.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $pattern = qr/(?:^|[^-])color *: *rgb\(( *[0-9]*),( *[0-9]*),( *[0-9]*)\)/;
return $tree-&amp;gt;look_down(
    &amp;quot;_tag&amp;quot;  =&amp;gt; &amp;quot;body&amp;quot;,
    &amp;quot;style&amp;quot; =&amp;gt; qr//,
    sub {
        $_[0]-&amp;gt;attr(&amp;quot;style&amp;quot;) =~ $pattern and
        ( $1 != 0 or $2 != 0 or $3 != 0 );
    }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With proper use of the methods &lt;code&gt;look_down()&lt;/code&gt;, &lt;code&gt;look_up()&lt;/code&gt;, and &lt;code&gt;as_trimmed_text()&lt;/code&gt;, the code can locate and mark the existence of various required elements and any broken elements (images, internal links, or background images).&lt;/p&gt;

&lt;h3 id=&#34;finishing-up&#34;&gt;Finishing Up&lt;/h3&gt;

&lt;p&gt;The final requirement of the assignment is a pleasant look of the rendered pages. Unfortunately, &lt;code&gt;HTML::TreeBuilder&lt;/code&gt; and its related modules do not analyze and quantify the visual appearance of a web page. Neither does any module that I know. OK, I would award marks for the appearance myself but still want Perl to help in the process&amp;ndash;the program sets the default score and comment, and allows overriding them in flexible way. By using alternative regular expressions, I can accept the default, override the score only, or override both the score and comment.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $input = &amp;quot;&amp;quot;;
do {
    print &amp;quot;$str1 [$str2]: &amp;quot;;
    $input = &amp;lt;STDIN&amp;gt;;
    $input =~ s/(^\s+|\s+$)//g;
} until ( $input =~ /(.*\.\s+\d+$|^\s*$|^\d+$)/ );

$input = $str2 if $input eq &amp;quot;&amp;quot;;
if ( $input =~ /^\d+$/ ) {
    $n = $input;
    if ( $n == 10 ) {
        $input = &amp;quot;good looking, nice content. $n&amp;quot;;
    }
    else {
        ( $input = $str2 ) =~ s/(\.\s*)\d+\s*$/$1$n/;
    }
}
marking &amp;quot;$str1 $input&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, the code examines the marking text string containing comments and scores for each requirement to calculate the total score of the assignment. Each line in that string is in a fixed format (for example, &lt;code&gt;&amp;quot;Italicized text (2 points): good. 0&amp;quot;&lt;/code&gt;). Again, regular expressions retrieve and accumulate the maximum and awarded points.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my ( $total, $score ) = ( 0, 0 );
while ( $marktext =~ /.*?\((\d+)\s+points\).*?\.\s+(\d+)/g )
{
    $total += $1;
    $score += $2;
}
marking &amp;quot;Total ($total points): $score&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Depending on the command-line switches, the program may start a browser to show the first page so that I can look at the pages&amp;rsquo; appearance. It can also optionally write the grading comments and score to a text file which can be feedback for the student.&lt;/p&gt;

&lt;p&gt;I can simply run the program in the directory containing the HTML files, or specify the set of HTML files in the command-line arguments. In the best case, I just let it grade the requirements and press &lt;code&gt;Enter&lt;/code&gt; to accept the default marking for the appearance, and then jot down the total score and email the grading text file to the student.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;I did not evaluate the time saved by the program against its developing effort. Anyway, the program makes the grading process more accurate and less prone to error, and it is more fun to spend time writing a Perl program and getting familiar with useful modules.&lt;/p&gt;

&lt;p&gt;In fact, there are many other modules that could have been used in the program to provide even more automation. Had I read Wasserman&amp;rsquo;s article &amp;ldquo;&lt;a href=&#34;http://localhost:1313/pub/2005/04/21/win32ole.html&#34;&gt;Automating Windows Applications with Win32::OLE&lt;/a&gt;,&amp;rdquo; the program would record the final score to an Excel file automatically. In addition, networking modules such as &lt;a href=&#34;https://metacpan.org/pod/Mail::Internet&#34;&gt;&lt;code&gt;Mail::Internet&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://metacpan.org/pod/Mail::Mailer&#34;&gt;&lt;code&gt;Mail::Mailer&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&#34;https://metacpan.org/pod/Mail::Folder&#34;&gt;&lt;code&gt;Mail::Folder&lt;/code&gt;&lt;/a&gt; could retrieve the assignment files from emails and send the feedback files to the students directly from the program.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Evolution of ePayment Services at UB</title>
      <link>http://localhost:1313/pub/2004/12/09/epayment.html/</link>
      <pubDate>Thu, 09 Dec 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/12/09/epayment.html/</guid>
      <description>

&lt;p&gt;In the summer of 2001, the State University of New York at Buffalo (UB) hired a new Provost. She surveyed various school services and came up with a short list of must-do projects. Given the level of competition in higher education, it&amp;rsquo;s no surprise that she felt that we must be able to accept payments over the internet. In general, we try to make it as easy as possible for students and their parents to manage the business side of their education. Electronic payment is a key, new component of that.&lt;/p&gt;

&lt;h3 id=&#34;how-to-start&#34;&gt;How to Start?&lt;/h3&gt;

&lt;p&gt;Determining how to accept an electronic payment requires skills from a wide variety of groups on campus. So we first put together a committee with representatives from Accounting, Student Accounts, and some offices that wanted to accept electronic payments. My department, Administrative Computing Services, also sat on the committee since we would have to implement the actual technology. Our role was to work with the people who handled the manual payment system and figure out how to automate that system through the web.&lt;/p&gt;

&lt;p&gt;We had no experience taking money over the internet, so we looked at our options:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Purchase a fully outsourced solution.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;We evaluated many all-in-one systems, but most didn&amp;rsquo;t do exactly what we wanted. The biggest problem was integration with our existing system, which had grown over time and had many legacy components. Many vendors had systems that worked only with their complete accounting systems.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;Partially outsourced solution.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;With this approach, we would do some work on our end and offload some to a vendor. This ended up being our initial approach since it allowed us to write the custom parts to interface with our systems, but still outsource the financial parts to reduce our initial risk.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;Mostly custom solution with payment processing outsourced.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;With this configuration, we&amp;rsquo;d host all of the web components in-house. We would use an external vendor for the payment-processing components, including validating credit cards, encumbering the funds from cards, and processing the actual payments through the payment networks and banks.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;Complete in-house system.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Some companies actually act as their own payment processor in addition to running the front-end website components. There is nothing preventing you from processing your own payments, but we found the banking world incredibly complex, especially with regard to credit card transactions. Although we could theoretically save money by doing this work ourselves, we weren&amp;rsquo;t &lt;em&gt;interested&lt;/em&gt; in doing this work. Our Accounting department agreed.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;After evaluating the options, we chose to start with a partially outsourced solution. Over time our needs changed and we became more knowledgeable; we since made the transition to a mostly in-house solution.&lt;/p&gt;

&lt;h3 id=&#34;initial-solution-partial-outsourcing&#34;&gt;Initial Solution: Partial Outsourcing&lt;/h3&gt;

&lt;p&gt;Our initial solution was mostly outsourced, with us building just a few front-end components. This allowed us to get our feet wet with electronic payment without running everything. Even with a vendor doing most of the work, we encountered some challenges.&lt;/p&gt;

&lt;p&gt;To implement this model, we built a website with a few pages that would collect personal data and track some data on the transaction. On the final page of our site, the user clicked a submit button and we shipped them off to the vendor website to enter the credit card information. This way we didn&amp;rsquo;t directly deal with any credit card issues. Each night we would receive a remittance file with the day&amp;rsquo;s transactions and we would reconcile these with our data using a unique identifier.&lt;/p&gt;

&lt;p&gt;The key issues for this first phase were:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Purchase and install a certificate from a widely accepted certificate issuer.&lt;/li&gt;
&lt;li&gt;Make sure all users used SSL. We simply redirected all http requests to the site to https so users couldn&amp;rsquo;t accidentally use unencrypted connections.&lt;/li&gt;
&lt;li&gt;Accurately record a unique identifier to match up transactions when we received the remittance file from the vendor.&lt;/li&gt;
&lt;li&gt;Follow the vendor&amp;rsquo;s protocol to integrate properly with their site.&lt;/li&gt;
&lt;li&gt;Understand the payment-processing system so we could date and post transactions accurately in our batch jobs.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The first two were basically normal tasks for setting up a secure server. The third required a little work, but not much. The challenge was integrating with the vendor. They had limits on the size of a unique identifier that were smaller than we wanted to provide, so we needed to shorten the value we sent. We also had concerns with how we would track down any &amp;ldquo;orphan&amp;rdquo; payments in the payment system that we couldn&amp;rsquo;t track to a particular user. We were lucky that, in practice, this never occurred.&lt;/p&gt;

&lt;p&gt;Number four also presented a challenge. My department is largely a Perl shop and we didn&amp;rsquo;t use Java on our website. During the development process, we discovered that the vendor link required Java to encrypt the data we sent to their system. They used Cryptix PGP with some custom code, available in Java only. That summer at OSCON I learned about the Inline modules and I decided to try one. Since it was only one small Java component, I followed their examples to code the Java encryption subroutine and stuck it at the bottom of the final Perl submission script using &lt;a href=&#34;https://metacpan.org/pod/Inline::Java&#34;&gt;&lt;code&gt;Inline::Java&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We have since moved on to a different system for processing our payments, so this code is a bit dated. However, when we were using it, it looked something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $encrypt = new encrypt();

# We had several calls like this one, one for each parameter we
# needed to encrypt.
# Each call returned a string with the encrypted data.
my $vendor_code = $encrypt-&amp;gt;send_to_vendor($pay_code);

# CGI code to create a form with the encrypted data as hidden fields.
# The form also acted as a confirmation page, so the user saw
# &amp;quot;Please review your information and click to continue&amp;quot;.

# Java code at the bottom of the file.
use Inline ( Java =&amp;gt; &amp;lt;&amp;lt;&#39;END_OF_JAVA_CODE&#39;,
  import xjava.security.Cipher;
  import cryptix.pgp.*;

class encrypt {
  public encrypt(){
  }

  public String send_to_vendor (String value_string){
      PGP pgpObj = new PGP();

      /* Initialize the object with base values. */
     pgpObj.init(&amp;quot;/pgp_dir&amp;quot;, &amp;quot;client name&amp;quot;, &amp;quot;passwd&amp;quot;,&amp;quot;sender_key_name&amp;quot;);

      /* Add the receiver name to the list. */
      pgpObj.addReceiver(&amp;quot;vendor name&amp;quot;);

     /* Create the encoded string. */
     String encvalue = pgpObj.encodeString(value_string);

     return (encvalue);
   }
}
END_OF_JAVA_CODE
SHARED_JVM =&amp;gt; 1,
CLASSPATH =&amp;gt; &#39;paths to cryptix libraries&#39;,
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code itself is very simple. The Java code simply creates a new object, calls a few methods, and returns the encrypted string. The interesting part is how relatively easy it was to embed the Java code in a Perl CGI script and have it work seamlessly. When we initially implemented this in 2001, &lt;code&gt;Inline::Java&lt;/code&gt; was fairly new and there was little documentation on how to do this. Patrick LeBoutillier, the author, was very helpful as I was trying to get it working. Now the &lt;code&gt;Inline::Java&lt;/code&gt; documentation has a section on using &lt;code&gt;Inline::Java&lt;/code&gt; in CGI scripts.&lt;/p&gt;

&lt;p&gt;The last item on the list was far more difficult than we anticipated. For most days, it was a simple formula to tag a record with a date the money would be available. However, weekends had special rules; we saw results that were inconsistent with the documentation we were working from. To nail down the problem, we ended up having to run small test transactions at various times on various days to see when our accountants saw the money actually arrive in the UB account.&lt;/p&gt;

&lt;p&gt;For example, if the documentation said there was a 4 p.m. cut-off time for payments on a given day, we would run a $1.11 transaction at 3:55 p.m., then another $1.12 transaction at 4:05 p.m. Our accounting people would watch the system to see when the payments came through. We needed to increment the amounts because we used the same credit card to process the transactions and there was no other way to keep them straight.&lt;/p&gt;

&lt;p&gt;Following this method, we learned a lot about the backend banking system. Different credit card companies process things on different schedules and handle things differently. The most important thing we found was a bug in the vendor&amp;rsquo;s processing system. After many weeks of running test transactions and comparing the clearing times with the vendor documentation, we finally tracked it back to a problem in the vendor system that they quickly fixed.&lt;/p&gt;

&lt;p&gt;The final product worked well. During the first run of the final confirmation script, &lt;code&gt;Inline::Java&lt;/code&gt; compiles and saves the code to run again, so it was quite fast. The vendor received the encrypted information correctly and could decrypt it successfully; it didn&amp;rsquo;t matter to them that we actually generated the request in Perl. Our remittance files arrived on a regular schedule and we posted the results on a daily cycle.&lt;/p&gt;

&lt;h3 id=&#34;the-world-happens-in-real-time&#34;&gt;The World Happens in Real Time&lt;/h3&gt;

&lt;p&gt;As described above, the vendor did much of the work, but since we passed users off to their system, we were unable to see the results of transactions until the next day. This wasn&amp;rsquo;t a problem for some payments. For example, the graduate school application fee just needs to be received by a particular date. It&amp;rsquo;s not crucial that we know the results of the transaction in real time.&lt;/p&gt;

&lt;p&gt;For tuition payment, however, we needed a real-time solution. At UB and many universities, you can&amp;rsquo;t register for your next semester if you have an outstanding balance from the previous semester. When a student is in this situation, called a checkstop, he needs to be able to pay and have the checkstop lifted immediately. Students often find out about their checkstop while trying to register online, so they need to be able to pay, clear their accounts, and return to the registration system while some courses are still available. What&amp;rsquo;s more, this often happens on a Saturday morning when many services may not be available.&lt;/p&gt;

&lt;h4 id=&#34;real-time-integration-challenges&#34;&gt;Real-Time Integration Challenges&lt;/h4&gt;

&lt;p&gt;The existing accounts system at UB runs on a mainframe, but most new development happens in our distributed Solaris environment. To allow real-time payments, we needed a vendor who could provide an immediate payment response, and we needed to apply that result to the mainframe. We also wanted to design the system to be open for future applications.&lt;/p&gt;

&lt;p&gt;We selected VeriSign as our new vendor and they returned real-time results. To then apply real-time results to our system, we could no longer pass users off to another site; we needed to manage the entire transaction. We redesigned our system to handle this.&lt;/p&gt;

&lt;p&gt;We currently use this redesigned system. The key steps in our current process are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Manage the web transaction using Perl CGI scripts and an Oracle database.&lt;/li&gt;
&lt;li&gt;After the user enters credit card information and clicks Submit, make a SOAP call to our internal payment server. The payment server logs all events.&lt;/li&gt;
&lt;li&gt;Perl scripts on the payment server call our mainframe system to determine if the student&amp;rsquo;s account is eligible to receive a payment.&lt;/li&gt;
&lt;li&gt;If the student has an active account, we call VeriSign using their Perl module.&lt;/li&gt;
&lt;li&gt;Receive and log results from VeriSign.&lt;/li&gt;
&lt;li&gt;If VeriSign approved the payment, call the mainframe again and credit the student&amp;rsquo;s account with the amount of the payment. If student paid in full, remove the checkstop from the account.&lt;/li&gt;
&lt;li&gt;Return the response for the initial SOAP call and present the user with the result of the transaction.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;From a design perspective, most of the steps are necessary given the disparate components we&amp;rsquo;re working with. Despite all of the things we do, the entire process usually takes about 10 seconds.&lt;/p&gt;

&lt;p&gt;We have several systems that access our mainframe in real-time through Perl. The Perl part is a basic socket call to a port on the mainframe. Special software runs on the mainframe as a server that can receive formatted requests and return results after processing against mainframe systems. One major advantage of the mainframe software is that it allows us to use existing mainframe systems through a new internet front-end.&lt;/p&gt;

&lt;p&gt;The interface with VeriSign was likewise fairly easy to integrate. They provide a Perl module to call their system and retrieve results. The majority of the work was in learning all of the non-success response codes and designing the system to handle them appropriately.&lt;/p&gt;

&lt;p&gt;However, you may wonder why we included a SOAP call between internal servers. When we designed the system, we tried to make all of the parts as flexible as possible. For this phase, we built both the front-end (the user websites) and the backend (the payment server). Given a generic enough interface, we speculated that other campus users may want to build their own front-end website and interface directly with the payment server. Constructing a SOAP interface using &lt;a href=&#34;https://metacpan.org/pod/SOAP::Lite&#34;&gt;&lt;code&gt;SOAP::Lite&lt;/code&gt;&lt;/a&gt; allowed us to potentially provide a service in a technology-neutral manner. The system has worked well and performance hasn&amp;rsquo;t been a problem. Thus far, we haven&amp;rsquo;t had an external, campus-entity interface with our system, but we have built other internal systems that use the interface.&lt;/p&gt;

&lt;p&gt;We also have a process in place for payments that don&amp;rsquo;t need immediate application (not real time). For these payments, we follow a similar process but skip the live mainframe connections. At night, we have batch Perl jobs that run and apply the changes to the mainframe.&lt;/p&gt;

&lt;h3 id=&#34;challenges&#34;&gt;Challenges&lt;/h3&gt;

&lt;p&gt;Most of our challenges with the ePayment system are with the user interface, specifically providing enough information. We will frequently receive a result of &amp;ldquo;declined,&amp;rdquo; or &amp;ldquo;declined with possible approval.&amp;rdquo; Some declines are the simple type where the user simply doesn&amp;rsquo;t have enough room on their credit card. However, many credit and debit cards have a maximum charge limit per day that card holders aren&amp;rsquo;t aware of. They tend to hit this limit when using a credit card to make a large charge like a tuition payment. This type of decline is conditional; the card issuer can approve the transaction after a phone call from the card holder.&lt;/p&gt;

&lt;p&gt;The problem is that the return code from VeriSign isn&amp;rsquo;t always clear enough for us to tell users exactly what they need to do. The correct response can also vary from one credit card issuer to another. The challenge is presenting them with messages that give them enough information, but no incorrect information. Even when we can provide them with a clear message such as &amp;ldquo;You need to call your credit card issuer,&amp;rdquo; they often assume it&amp;rsquo;s a problem with our system and contact us anyway.&lt;/p&gt;

&lt;h3 id=&#34;your-euniversity&#34;&gt;Your eUniversity&lt;/h3&gt;

&lt;p&gt;UB&amp;rsquo;s ePayment project has been very successful and our users have received it well. In our last payment cycle, approximately 40% of payments came through the internet, instead of the traditional methods of mailing a check, going to the payment office, or paying over the phone. Even with this level of activity, the level of support required has been very reasonable.&lt;/p&gt;

&lt;p&gt;With so many internet payment systems available &amp;ndash; some specifically designed for education &amp;ndash; some may question custom-building so much of the system. When dealing with legacy components, however, it&amp;rsquo;s often difficult to purchase a solution for just part of the process. Replacing entire systems at a university the size of UB is a much larger project than we usually want to tackle at any one time. In these situations, we&amp;rsquo;ve found Perl to be very flexible, allowing us to patch together disparate systems and external resources to build a cohesive, effective system.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

