<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mp3 on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/mp3/</link>
    <description>Recent content in Mp3 on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 30 Jul 2015 12:49:46 +0000</lastBuildDate>
    <atom:link href="/tags/mp3/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Rip music from anywhere with Audacity</title>
      <link>http://localhost:1313/article/186/2015/7/30/Rip-music-from-anywhere-with-Audacity/</link>
      <pubDate>Thu, 30 Jul 2015 12:49:46 +0000</pubDate>
      
      <guid>http://localhost:1313/article/186/2015/7/30/Rip-music-from-anywhere-with-Audacity/</guid>
      <description>

&lt;p&gt;Sorry Perlers, this post contains no Perl code. Instead I want to show you how to record music with the open source tool &lt;a href=&#34;http://audacityteam.org/&#34;&gt;Audacity&lt;/a&gt;. If you listen to music on YouTube, Soundcloud, Pandora - wherever, you can rip it and save it using Audacity. Say goodbye to the arms race of YouTube downloaders/decoders and HTTP network analysis to find the direct URL for the underlying MP3 (looking at you Bandcamp - still vulnerable at the time of writing). Instead say hello to a solution that will work as long as music plays through your computer (so - forever).&lt;/p&gt;

&lt;h3 id=&#34;setup&#34;&gt;Setup&lt;/h3&gt;

&lt;p&gt;First install Audacity. I&amp;rsquo;m a fedora user so I grabbed it with &lt;code&gt;yum&lt;/code&gt;/&lt;code&gt;dnf&lt;/code&gt;, but users of other systems can use their package manager or get pre-built &lt;a href=&#34;http://www.fosshub.com/Audacity.html/audacity-minsrc-2.1.1.tar.xz&#34;&gt;binary&lt;/a&gt; for Windows or OSX.&lt;/p&gt;

&lt;p&gt;Disable your microphone, you don&amp;rsquo;t want Audacity recording anything except the sound passing out of your speakers. Navigate to the webpage which you want to record from, but don&amp;rsquo;t start the music yet.&lt;/p&gt;

&lt;h3 id=&#34;recording-and-exporting&#34;&gt;Recording and Exporting&lt;/h3&gt;

&lt;p&gt;Start Audacity, click the &amp;ldquo;Transport&amp;rdquo; menu, and select &amp;ldquo;Sound Activated Recording&amp;rdquo;. Now click the record button, and Audacity should pause recording. Switch to the webpage you wan to record from and start the music. You should see Audacity detect the music and begin recording. Once the music has finished, stop Audacity.&lt;/p&gt;

&lt;p&gt;If the music contains more than one track, you&amp;rsquo;ll need to add labels at the start of each track. A fast way to do this is using the silence analyzer. Click the &amp;ldquo;Analyze&amp;rdquo; menu, and &amp;ldquo;Silence Finder&amp;rdquo;. Press &amp;ldquo;OK&amp;rdquo; and Audacity will add a label at each point of silence in the music. Make sure you add a label to the beginning of the music - sound activated recording usually means the first track is not preceded by silence. To manually add labels, just navigate to the section of music where you want to add a label and press &lt;code&gt;Control + B&lt;/code&gt;. You can give each label a title, or add them on export later.&lt;/p&gt;

&lt;p&gt;To maximize the recorded volume, press &lt;code&gt;Control + A&lt;/code&gt; to select all of the recording, select the &amp;ldquo;effect&amp;rdquo; menu, and &amp;ldquo;normalize&amp;rdquo;. The default value of -1.0 decibel is fine. This will ensure the recording doesn&amp;rsquo;t sound &amp;ldquo;quiet&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Finally, select the &amp;ldquo;File&amp;rdquo; menu and &amp;ldquo;Export Audio&amp;rdquo; or &amp;ldquo;Export Multiple&amp;rdquo; if you have more than one track to export. If you&amp;rsquo;re exporting mp3, Audacity will let you add mp3 tags to each track at this point. That&amp;rsquo;s it!&lt;/p&gt;

&lt;h3 id=&#34;automating-the-process&#34;&gt;Automating the process&lt;/h3&gt;

&lt;p&gt;One downside to this method is it is highly manual. One way to automate some of it is by using an Audacity&amp;rsquo;s &lt;a href=&#34;http://manual.audacityteam.org/man/Chains_-_for_batch_processing_and_effects_automation&#34;&gt;chains&lt;/a&gt; feature. To script an audio recording process with Perl, the &lt;a href=&#34;https://metacpan.org/pod/Audio::PortAudio&#34;&gt;Audio::PortAudio&lt;/a&gt; module looks promising, for the capturing and saving of audio data at least.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How Perl Powers the Squeezebox</title>
      <link>http://localhost:1313/pub/2003/12/05/slimp3.html/</link>
      <pubDate>Fri, 05 Dec 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/12/05/slimp3.html/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.slimdevices.com/&#34;&gt;Slim Devices&lt;/a&gt; made their name in 2001 with the SLIMP3, a networked MP3 and Internet radio player. The SLIMP3 won a five-out-of-five mouse rating in &lt;em&gt;Macworld&lt;/em&gt; magazine, and was featured in &lt;em&gt;GQ&lt;/em&gt; magazine and on TechTV&amp;rsquo;s &lt;em&gt;The Screen Savers&lt;/em&gt;. This year, they&amp;rsquo;re trying to repeat the success with Squeezebox, an 802.11-enabled version.&lt;/p&gt;

&lt;p&gt;The interesting thing about the SLIMP3 and the Squeezebox from our point of view, though, is that the server which drives the player is written in Perl, and developers are allowed &amp;ndash; in fact, encouraged &amp;ndash; to hack on it and make the devices do interesting things. A &lt;a href=&#34;http://www.slimdevices.com/dev_overview.html&#34;&gt;developer community&lt;/a&gt; has sprung up around the SLIMP3, and some &lt;a href=&#34;http://www.slimdevices.com/dev_third_party.html&#34;&gt;interesting third-party hacks&lt;/a&gt; have been produced.&lt;/p&gt;

&lt;p&gt;We caught up with Dean Blackketter from Slim Devices, who took some time out from moving Squeezeboxes to answer a few of our questions.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;perl.com: What made you decide, first of all, to write the server code in Perl?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Dean&lt;/strong&gt;: Sean [Adams, Slim Devices founder] wrote the very first version of the software in Perl because he was able to get it up and running quickly. When I first encountered Sean and SLIMP3, I was a little afraid of Perl, having been primarily a C and C++ programmer, mostly because when I tried to read it, I got confused by idiomatic usage.&lt;/p&gt;

&lt;p&gt;I first decided to rewrite the thing in C, but I couldn&amp;rsquo;t really get started until I could read the existing code. So I bought a copy of &lt;em&gt;Learning Perl&lt;/em&gt; and read it in two evenings. Halfway through the first chapter something clicked and I said, &amp;ldquo;That&amp;rsquo;s so cool!&amp;rdquo; Then, about every 10 pages after I&amp;rsquo;d repeat, &amp;ldquo;That&amp;rsquo;s so cool!&amp;rdquo; again, but a little louder. By the end, I was sold. At that point I dug in and started making the software better.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What features of Perl were particularly helpful when you were writing the SlimServer?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The greatest feature of Perl, for us, is that so many people know it. Since our software is open source, we benefit from as many users as possible being able to read and improve our code base. Anybody who&amp;rsquo;s thrown together a little Perl CGI or script is a potential contributor to our software.&lt;/p&gt;

&lt;p&gt;Second, the ability for us to offer our software on a wide array of platforms (Mac OS X, Windows 98/ME/NT/2000/XP, BSD, Linux, Solaris) and also be deployed on server appliances makes it possible for us to get our product running as broadly as possible.&lt;/p&gt;

&lt;p&gt;Third, even though our product&amp;rsquo;s primary feature is playing back audio, the bulk of the software really is processing text. Our built-in HTTP server, command-line interface, device-user interface, and even music meta-information is all text-based, and Perl is nearly the perfect language for this.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What issues did you have to face when considering how to distribute a Perl-based consumer application, and how did you approach them?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Distributing a Perl application on the traditional Unix-like platforms (BSD, Solaris, Linux) is easy. Things got a bit harder on Mac OS X, since command-line solutions aren&amp;rsquo;t acceptable to Mac users. Initially, I wrote a simple graphical application (in AppleScript!) that acted as a launcher for our server software, but this was really not good enough for Mac users. One of our Open Source contributors, Dave Nanian, came to the rescue and built us a System Preferences pane and installer application that work as they should on a Mac.&lt;/p&gt;

&lt;p&gt;Windows is the hardest platform for us to support. Luckily we had another Open Source contributor, Sam Saffron, who decided that building a shell application for the server software would be a great way to learn MFC, and he contributed a nice little app for this. Another contributor, Chris Eastwood, put together an installer for us. But it was the fine folks at &lt;a href=&#34;http://www.activestate.com/&#34;&gt;ActiveState&lt;/a&gt; with their &lt;a href=&#34;http://www.activestate.com/Products/Perl_Dev_Kit/&#34;&gt;Perl Dev Kit&lt;/a&gt; that really made it possible for us to release on Windows with their PerlApp (for making Perl-based .exe files) and PerlSvc (for making Perl-based Windows Services).&lt;/p&gt;

&lt;p&gt;Even with all this help, Perl on Windows is different enough in subtle ways to make it a real pain to maintain. Maybe if we had more hardcore in-house Windows experience things would be easier, but it&amp;rsquo;s a struggle.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;For consumer devices like the SLIMP3, the manufacturer has a choice between open and hackable, and &amp;ldquo;sealed box.&amp;rdquo; You guys went for the hackable approach, GPLing the code and setting up developers&amp;rsquo; forums. What was the rationale behind that?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;When I got into this, the total of my Open Source experience was running a Linux server in my basement. Sean initially released the SLIMP3 software under the GPL, which made it possible for me to help out. I quickly realized that our customers have a lot of talent and energy that they are willing to contribute to make the product better. We&amp;rsquo;re lucky to have a business model where we can make money on the hardware and give the software away. When our customers contribute, they make their own SLIMP3s (and now Squeezeboxes) more valuable to themselves and make the new units we sell to new customers more valuable as well. Everybody wins.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How did you go about building a developer community behind the SlimServer project?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I like to think that the community built itself. We provided a forum (our discussion lists) and Sean and I participate on a daily basis; acting on the requests, suggestions, bug reports, and patches that people post. We&amp;rsquo;re spending more effort lately setting up our own list server and CVS system, as we had problems with our previous forums (Yahoo Groups and SourceForge, respectively), but these will give us a little more control of our virtual spaces.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How do you decide which developer extensions to keep as third-party projects and which to integrate?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If a contribution will make the product better for a substantial portion of our customers and won&amp;rsquo;t make the product worse for any of them, then, generally speaking, it&amp;rsquo;s included. Submitted features that make the software harder or less intuitive to use, require obscure or platform-specific software or hardware to be installed, generally don&amp;rsquo;t make it in. Contributions that are useful to a large fraction of our customers and don&amp;rsquo;t diminish the product&amp;rsquo;s ability to play back music, make it in.&lt;/p&gt;

&lt;p&gt;I act as final arbiter and (hopefully) benevolent dictator, and the community has been really supportive of this.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Finally, we notice that you&amp;rsquo;ve decided to donate 10 percent of your profits to the EFF. What&amp;rsquo;s the motivation behind this?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Digital freedoms are important to the folks at Slim Devices, both personally and at a corporate level. We&amp;rsquo;ve been frustrated by not being able to offer our customers the ability to play the music that they&amp;rsquo;ve bought due to digital rights management systems and onerous licensing fees for various patents. The EFF shares our goal to free our customers&amp;rsquo; music.&lt;/p&gt;

&lt;p&gt;The Squeezebox is available from &lt;a href=&#34;http://www.slimdevices.com/&#34;&gt;Slim Devices&lt;/a&gt; and their resellers, and the server code can be downloaded from their &lt;a href=&#34;http://www.slimdevices.com/su_downloads.html&#34;&gt;downloads site&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Identifying Audio Files with MusicBrainz</title>
      <link>http://localhost:1313/pub/2003/10/03/musicbrainz.html/</link>
      <pubDate>Fri, 03 Oct 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/10/03/musicbrainz.html/</guid>
      <description>

&lt;p&gt;It&amp;rsquo;s quite possible to end up with digital music files that don&amp;rsquo;t have good information about what they are. Files that don&amp;rsquo;t have ID3 information can rely on paths for album information, for example, and that is lost easily. M3U files describing track order can be deleted or ignored by naive archiving.&lt;/p&gt;

&lt;p&gt;Wouldn&amp;rsquo;t it be nice if, once you had a music file, you could use Perl to take what information you did have about a track, send it to the Internet, and get back the data you were missing? Well, you can.&lt;/p&gt;

&lt;h3 id=&#34;span-id-a-step-through-history-a-step-through-history-span&#34;&gt;&lt;span id=&#34;a_step_through_history&#34;&gt;A Step Through History&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In the beginning (well, more or less), music was on CDs. People started listening to CDs on computers shortly after that, and they found that it would be nice to know the track&amp;rsquo;s name, not just the number. Applications were developed that could store the CD metadata locally. Still, it was tedious to type in all those CD lists, so people shared the metadata in a single index file on the Internet.&lt;/p&gt;

&lt;p&gt;As with most other single-file data stores in Internet history, soon it became sensible to turn this into a proper database. And so the CDDB was born. Clients could upload a description of the disc (the Table of Contents, which described how long each track is) and either download the information for that CD, or contribute it if it wasn&amp;rsquo;t in the database.&lt;/p&gt;

&lt;p&gt;During 1999 and 2000, however, the CDDB (after its acquisition by Gracenote) moved from an open position (with GPLed downloads of its data files) to a proprietary one. During this time it stopped access to clients speaking the first version of the CDDB protocol, and instead moved to licensing &amp;ndash; at some cost &amp;ndash; CDDB2 clients, and stopped offering downloads of its data.&lt;/p&gt;

&lt;p&gt;However, a few projects started up, taking advantage of the data that had been freely available until this point. One of these was FreeDB, which quickly established an open replacement for the CDDB. The other is MusicBrainz, which is much more interesting.&lt;/p&gt;

&lt;h3 id=&#34;span-id-freedb-freedb-span&#34;&gt;&lt;span id=&#34;freedb&#34;&gt;FreeDB&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;FreeDB replicates the structure of the old CDDB very faithfully. This means that a number of Perl modules for handling CDDB data are applicable to the FreeDB as well.&lt;/p&gt;

&lt;p&gt;However, despite the large number of FreeDB modules on CPAN, it&amp;rsquo;s not really well suited to the task of finding or correcting digital music file metadata. FreeDB grew out of CDDB, which was designed around the task of identifying entire CDs, not merely single tracks, and that is still reflected in the way most of the modules work; they require you to either have or fake the CD&amp;rsquo;s table of contents to get results.&lt;/p&gt;

&lt;p&gt;FreeDB also has a search form on its web site, and there&amp;rsquo;s a Perl module &amp;ndash; &lt;code&gt;Webservice::FreeDB&lt;/code&gt; &amp;ndash; that you can use to find out information on a per-track basis. However, wherever possible a web service is probably preferable to using a screen scraper, and thankfully such a service is available.&lt;/p&gt;

&lt;h3 id=&#34;span-id-musicbrainz-musicbrainz-span&#34;&gt;&lt;span id=&#34;musicbrainz&#34;&gt;MusicBrainz&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;MusicBrainz has similar origins to FreeDB in the post-Gracenote era. Unlike FreeDB, MB was much more ambitious; as the description says, `&amp;ldquo;MusicBrainz is a community music metadatabase that attempts to create a comprehensive music information site.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;In addition to taking the FreeDB data and making it available (in fact, the FreeDB changes appear to be regularly merged into MusicBrainz), MB takes care to make sure that their data is moderated regularly. FreeDB&amp;rsquo;s discid-based system didn&amp;rsquo;t always make sure that different versions CDs were recognized as duplicates, for example, whereas the MB volunteers attempt to consolidate such data. They also offer fairly powerful searches of the data from a web-based front end.&lt;/p&gt;

&lt;p&gt;More importantly for our purposes, MusicBrainz has a web services API. Rather than using SOAP, it&amp;rsquo;s a REST-based service based on RDF.&lt;/p&gt;

&lt;p&gt;You can see an example of this by downloading the data at a URL like &lt;a href=&#34;http://mm.musicbrainz.org/mm-2.1/album/1073abfc-768e-455b-9937-9b41b923c746/4&#34;&gt;http://mm.musicbrainz.org/mm-2.1/album/1073abfc-768e-455b-9937-9b41b923c746/4&lt;/a&gt;. This returns RDF for the Underworld album &lt;em&gt;Beaucoup Fish&lt;/em&gt;. The long hex string is the album&amp;rsquo;s unique identifier within MusicBrainz, and the number at the end (4) tells MusicBrainz how deeply to go when building the RDF graph. This level of depth means that as well as merely getting a track listing as references to other RDF documents (like &lt;a href=&#34;http://musicbrainz.org/track/55ef9194-bb58-4397-a8a2-e0d41d2e1435&#34;&gt;http://musicbrainz.org/track/55ef9194-bb58-4397-a8a2-e0d41d2e1435&lt;/a&gt;), you get the name of the track inlined in the document.&lt;/p&gt;

&lt;h4 id=&#34;span-id-using-musicbrainz-client-using-musicbrainz-client-span&#34;&gt;&lt;span id=&#34;using_musicbrainz::client&#34;&gt;Using MusicBrainz::Client&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;However, requesting that URL directly requires you know the MusicBrainz ID for that album, track, or artist, and that you can parse RDF. Unsurprisingly, there&amp;rsquo;s code out there that can do both from a given piece of information.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;the MusicBrainz::Client manpage&lt;/code&gt; is a Perl interface to the C client library for MB, and is available as part of the &lt;a href=&#34;http://musicbrainz.org/products/client/download.html&#34;&gt;Client SDK download&lt;/a&gt;, as well as on CPAN.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a small example of using one of the more useful queries provided, the snappily-entitled &lt;code&gt;MBQ_FileInfoLookup&lt;/code&gt;. This takes up to 10 parameters, as documented in the &lt;a href=&#34;http://musicbrainz.org/docs/mb_client/queries_h.html#a84&#34;&gt;Query reference&lt;/a&gt;. However, you can provide as many or as few items as you wish, and in this example, merely two pieces of information are provided: an artist, and a track name.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #!/usr/bin/perl -w
  use strict;

  use MusicBrainz::Client;
  use MusicBrainz::Queries qw(:all);

  my $mb = MusicBrainz::Client-&amp;gt;new();
  my $query = [ &#39;&#39;, &#39;Underworld&#39;, &#39;&#39;, &#39;Air Towel&#39; ];
  my $result;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we&amp;rsquo;ve set up the script, and initialized a client object, let&amp;rsquo;s actually talk to the server.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  if (!$mb-&amp;gt;query_with_args( MBQ_FileInfoLookup, $query )) {
    die &amp;quot;Query failed &amp;quot;.$mb-&amp;gt;get_query_error();
  }

  if (!$mb-&amp;gt;select1(MBS_SelectLookupResult, 1)) {
    die &amp;quot;No lookup result&amp;quot;;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This sends off a query to the MusicBrainz server, and does two checks to see if it&amp;rsquo;s worth continuing. If there&amp;rsquo;s no return value from query_with_args, the script dies with the error returned. If there&amp;rsquo;s not at least one result in the returned data, it also dies.&lt;/p&gt;

&lt;p&gt;The exact arguments that &lt;code&gt;MBQ_FileInfoLookUp&lt;/code&gt; take are documented in the query reference above. Notably, the first argument is the TRM ID. This is a generated, unique identifier for the file, based on a number of weighted checks, including wavelet analysis. Generally I&amp;rsquo;ve found it&amp;rsquo;s still possible to get good results without including it, though.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my $type = $mb-&amp;gt;get_result_data(MBE_LookupGetType);
  my $frag = $mb-&amp;gt;get_fragment_from_url($type);

  if ($frag eq &#39;AlbumTrackResult&#39;) {
    $result = handle_album_track_list($mb);
  }
  else {
    die &amp;quot;Not an AlbumTrackResult; instead of type &#39;$frag&#39;&amp;quot;;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;MBQ_FileInfoLookup&lt;/code&gt; can return different types of result. This code uses two more functions from MusicBrainz to find out the type of the result (the LookupGetType function) and then to parse out from the URL what type of result that is. We&amp;rsquo;re only interested in AlbumTrackResult type, so we die if that&amp;rsquo;s not what&amp;rsquo;s found. If it is of that type, it&amp;rsquo;s handled by a subroutine, which we&amp;rsquo;ll look at now.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  sub handle_album_track_list {
    my $mb = shift;
    my $result;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, we get the MusicBrainz client object and pre-declare our result variable.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for (my $i = 1;; $i++) {
      $mb-&amp;gt;select(MBS_Rewind);

      if (!$mb-&amp;gt;select1(MBS_SelectLookupResult, $i)) {
        last;
      }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MusicBrainz results sets are a lot like database rows. You loop over them, and pull out the data you want.&lt;/p&gt;

&lt;p&gt;However, the interface to the results is somewhat C-like. As you can see, we loop over the results one by one, stopping only when there isn&amp;rsquo;t a result in the set.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      my $relevance = $mb-&amp;gt;get_result_int(MBE_LookupGetRelevance);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, once there is a result, we can pull out information from it, like the relevance of that data.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      # get track info
      $mb-&amp;gt;select(MBS_SelectLookupResultTrack);
      my $track   = $mb-&amp;gt;get_result_data(MBE_TrackGetTrackName);
      my $length  = $mb-&amp;gt;get_result_data(MBE_TrackGetTrackDuration);     
      my $artist  = $mb-&amp;gt;get_result_data(MBE_TrackGetArtistName);
      $mb-&amp;gt;select(MBS_Back);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To get the information about the track, you select the track portion of that result, then issue get_result_data calls for each of the pieces of information you want (such as the artist name, track name and so on).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      # get album info
      $mb-&amp;gt;select(MBS_SelectLookupResultAlbum);
      my $album   = $mb-&amp;gt;get_result_data(MBE_AlbumGetAlbumName);
      my $trackct = $mb-&amp;gt;get_result_int(MBE_AlbumGetNumTracks);
      $mb-&amp;gt;select(MBS_Back);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Similarly, you select the album data, and then select the information about the album you want to return.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      $result-&amp;gt;[$i-1] = { relevance =&amp;gt; $relevance,
                          track     =&amp;gt; $track,
                          album     =&amp;gt; $album,
                          artist    =&amp;gt; $artist,
                          total     =&amp;gt; $trackct,
                          time      =&amp;gt; $length,
                        };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is stored in a hash reference, itself stored in the list of results. (Note we move from MusicBrainz offset of 1 to the Perl offset of 0 here.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    }
    return $result;
  }

  use Data::Dumper;
  print Dumper($result);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally the result is returned and (crudely) inspected. Of course, you could instead take the result with the highest relevance and tag a file here, or offer the choice via some user interface of which result is more likely to be appropriate.&lt;/p&gt;

&lt;h4 id=&#34;span-id-using-audiofile-identify-musicbrainz-using-audiofile-identify-musicbrainz-span&#34;&gt;&lt;span id=&#34;using_audiofile::identify::musicbrainz&#34;&gt;Using AudioFile::Identify::MusicBrainz&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;As you can see, returning the data from MusicBrainz::Client is a fairly verbose procedure. In addition, it&amp;rsquo;s not a pure Perl implementation, so installing the module isn&amp;rsquo;t as easy as it could be, and in some places it&amp;rsquo;s not possible at all.&lt;/p&gt;

&lt;p&gt;Given that the REST interface is open, Tom Insam and I decided to play with getting the RDF results and parsing them, putting together Perl modules along the way to help. The result is &lt;code&gt;the AudioFile::Identify::MusicBrainz manpage&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #!/usr/bin/perl -w
  use strict;

  use AudioFile::Identify::MusicBrainz::Query;
  my $query = { artist =&amp;gt; &#39;Underworld&#39;, 
                track  =&amp;gt; &#39;Air Towel&#39;,
              };
  my $result;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, this is simple setup stuff. You&amp;rsquo;ll note that instead of a list, AIM takes a hash reference with named fields, which is hopefully a little easier to use.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my $aim = AudioFile::Identify::MusicBrainz::Query-&amp;gt;new()
            or die &amp;quot;Can&#39;t make query&amp;quot;;

  $aim-&amp;gt;FileInfoLookup($query);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This block of code instantiates the AIM object and sends off the query.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  for my $record (@{ $aim-&amp;gt;results }) {
    push @{ $result }, {  relevance =&amp;gt; $record-&amp;gt;relevance,
                          track     =&amp;gt; $record-&amp;gt;track-&amp;gt;title,
                          album     =&amp;gt; $record-&amp;gt;album-&amp;gt;title,
                          artist    =&amp;gt; $record-&amp;gt;track-&amp;gt;artist-&amp;gt;title,
                          tracknum  =&amp;gt; $record-&amp;gt;track-&amp;gt;trackNum,
                          total     =&amp;gt; scalar @{$record-&amp;gt;album-&amp;gt;tracks},
                          time      =&amp;gt; $record-&amp;gt;track-&amp;gt;duration,
                       };
  };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This manipulates the results from AIM such that they match the result list that we created from MusicBrainz::Client. Each of them is a method on the returned object. Some, such as the artist name, are objects referenced from other objects.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use Data::Dumper;
  print Dumper($result);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, we crudely inspect the output, which is identical but for the addition of the track number.&lt;/p&gt;

&lt;h3 id=&#34;span-id-inside-audofile-identify-musicbrainz-inside-audofile-identify-musicbrainz-span&#34;&gt;&lt;span id=&#34;inside_audofile::identify::musicbrainz&#34;&gt;Inside AudoFile::Identify::MusicBrainz&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;As you&amp;rsquo;d expect, Perl (and its retinue of modules) made writing this module fairly straightforward. Firstly, LWP makes requesting data from the MusicBrainz server pretty easy. (This code is in &lt;code&gt;the AudioFile::Identify::MusicBrainz::Query manpage, for the curious.)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use LWP;
  use LWP::UserAgent;

  # ...

  my $ua = LWP::UserAgent-&amp;gt;new();

  my $req = HTTP::Request-&amp;gt;new(POST =&amp;gt; $self-&amp;gt;url,);
  $req-&amp;gt;content($rdf);

  my $res = $ua-&amp;gt;request($req);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This sets up an LWP user agent, and sends the RDF query (more on that later) to a URL (returned by another method in the module). That&amp;rsquo;s all you need to get the returned result into the string $res. (The real module has a custom UserAgent string that I&amp;rsquo;ve omitted to save space.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  # Check the outcome of the response
  if ($res-&amp;gt;is_success) {
    $self-&amp;gt;response($res-&amp;gt;content);
    return $self-&amp;gt;parse();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As long as there&amp;rsquo;s a result, it gets stored and then parsed. (Don&amp;rsquo;t worry; the real module also handles errors.) So, what does the parser do?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my $parser = new XML::DOM::Parser;
  my $doc = $parser-&amp;gt;parse($self-&amp;gt;response);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MusicBrainz returns results in RDF, but that RDF is itself encapsulated in XML. Although it&amp;rsquo;s not ideal to use XML tools on RDF, it works well enough in this case.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my $result_nodes = $doc-&amp;gt;getElementsByTagName(&#39;mq:AlbumTrackResult&#39;);

  $n = $result_nodes-&amp;gt;getLength;
  for (my $i = 0; $i &amp;lt; $n; $i++) {
    my $node = $result_nodes-&amp;gt;item($i);
    my $result =
      AudioFile::Identify::MusicBrainz::Result-&amp;gt;new()
                                              -&amp;gt;store($self-&amp;gt;store)
                                              -&amp;gt;type(&#39;Track&#39;)
                                              -&amp;gt;parse($node);
    push @$results, $result;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This block of code is a good example of how the XML is parsed. Firstly, all elements with the name mq:AlbumTrackResult are found. These are progressively looped over, and stored in a new Result object (of type Track), and parsed. So, what happens within the parser?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my $child = $node-&amp;gt;getFirstChild();
  while($child) {
    if ($child-&amp;gt;getNodeType == 1) {
      my $tag = $child-&amp;gt;getTagName;
      $tag =~ s/.*://;
      if ($self-&amp;gt;can($tag)) {
        $self-&amp;gt;$tag($child);
      }
    }
    $child = $child-&amp;gt;getNextSibling();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The node (as passed in above) is examined, and the first child node is examined. While we have a child node to examine, the program checks that it&amp;rsquo;s an element (of node type 1), gets the tag name and removes the namespace, then calls the appropriate get/set method with the appropriate XML node, before moving on to the next child. (This is a somewhat simplified version, with the error checking removed.)&lt;/p&gt;

&lt;p&gt;What happens in an example get/set method? Here&amp;rsquo;s part of the title method from the Track package.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  if (defined($set)) {
    if ($set-&amp;gt;isa(&#39;XML::DOM::Element&#39;) and $set-&amp;gt;getFirstChild) {
      $self-&amp;gt;{title} = $set-&amp;gt;getFirstChild-&amp;gt;toString;
    } else {
      $self-&amp;gt;{title} = $set;
    }
    return $self;
  } else {
    return $self-&amp;gt;{title};
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the method is called with some data, the program makes sure it&amp;rsquo;s an XML::DOM element, then parses it and stores the string within that element, or stores the data that was passed in. Otherwise, it returns the data that was previously stored.&lt;/p&gt;

&lt;p&gt;One point to note is that MusicBrainz doesn&amp;rsquo;t return all the track information you might need in the initial FileInfoLookup query. Therefore the Result package uses another method, called getData in the Track package, to download the RDF for the track from MusicBrainz. This is then parsed and stored in the same way as the RDF above.&lt;/p&gt;

&lt;h3 id=&#34;span-id-conclusion-conclusion-span&#34;&gt;&lt;span id=&#34;conclusion&#34;&gt;Conclusion&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In this article I&amp;rsquo;ve shown you how to connect to MusicBrainz and retrieve information from their web services API with both the MusicBrainz::Client and AudioFile::Identify::MusicBrainz modules, and a little of the internal workings of the latter. This should allow you to find out all those niggling missing pieces of information about the tracks at the bottom of your music collection.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

