<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mock Objects on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/mock-objects/</link>
    <description>Recent content in Mock Objects on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 13 Jul 2006 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/mock-objects/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Still More Perl Lightning Articles</title>
      <link>http://localhost:1313/pub/2006/07/13/lightning-articles.html/</link>
      <pubDate>Thu, 13 Jul 2006 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2006/07/13/lightning-articles.html/</guid>
      <description>

&lt;p&gt;It has been common practice within the Perl community for ages to ship distributions with a &lt;em&gt;Makefile.PL&lt;/em&gt; so that the user will be able to install the packages when he retrieves them, either via the shell which the &lt;code&gt;CPAN/CPANPLUS&lt;/code&gt; modules offer or via manual CPAN download.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;Makefile.PL&lt;/em&gt; consists of meta-information, which in the case of the distribution &lt;a href=&#34;https://metacpan.org/pod/HTML::Tagset&#34;&gt;&lt;code&gt;HTML::Tagset&lt;/code&gt;&lt;/a&gt; is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; # This -*-perl-*- program writes the Makefile for installing this distribution.
 #
 # See &amp;quot;perldoc perlmodinstall&amp;quot; or &amp;quot;perldoc ExtUtils::MakeMaker&amp;quot; for
 # info on how to control how the installation goes.

 require 5.004;
 use strict;
 use ExtUtils::MakeMaker;

 WriteMakefile(
     NAME            =&amp;gt; &#39;HTML::Tagset&#39;,
     AUTHOR          =&amp;gt; &#39;Andy Lester &amp;lt;andy@petdance.com&amp;gt;&#39;,
     VERSION_FROM    =&amp;gt; &#39;Tagset.pm&#39;, # finds $VERSION
     ABSTRACT_FROM   =&amp;gt; &#39;Tagset.pm&#39;, # retrieve abstract from module
     PMLIBDIRS       =&amp;gt; [qw(lib/)],
     dist            =&amp;gt; { COMPRESS =&amp;gt; &#39;gzip -9f&#39;, SUFFIX =&amp;gt; &#39;gz&#39;, },
     clean           =&amp;gt; { FILES =&amp;gt; &#39;HTML-Tagset-*&#39; },
 );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of interest are the arguments to &lt;code&gt;WriteMakefile()&lt;/code&gt;, because they influence the &lt;em&gt;Makefile&lt;/em&gt; written by &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; after the user has invoked the usual build and install procedure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; % perl Makefile.PL
 % make
 % make test
 # make install
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;module-build-successor-of-extutils-makemaker&#34;&gt;&lt;code&gt;Module::Build&lt;/code&gt;, Successor of &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt;?&lt;/h3&gt;

&lt;p&gt;As Ken Williams grew tired of &lt;a href=&#34;https://metacpan.org/pod/ExtUtils::MakeMaker&#34;&gt;&lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt;&lt;/a&gt; and its portability issues, he invented &lt;a href=&#34;https://metacpan.org/pod/Module::Build&#34;&gt;&lt;code&gt;Module::Build&lt;/code&gt;&lt;/a&gt;, a successor of &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt;. One goal of &lt;code&gt;Module::Build&lt;/code&gt; is to run smoothly on most operating systems, because it takes advantage of creating Perl-valid syntax files only and does not rely upon crufty &lt;em&gt;Makefiles&lt;/em&gt;, which are often subject to misinterpretation, because so many incompatible flavors of &lt;code&gt;make&lt;/code&gt; exist in the wild.&lt;/p&gt;

&lt;p&gt;The current maintainer of &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt;, Michael G. Schwern, elaborated about this problem in his talk reachable via &amp;ldquo;&lt;a href=&#34;http://mungus.schwern.org/~schwern/talks/MakeMaker_Is_DOOMED/slides/&#34;&gt;MakeMaker is DOOMED&lt;/a&gt;.&amp;rdquo;&lt;/p&gt;

&lt;h3 id=&#34;module-build-distribution-skeleton&#34;&gt;&lt;code&gt;Module::Build&lt;/code&gt; Distribution &amp;ldquo;Skeleton&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;If you take in consideration the distribution &lt;code&gt;HTML::Tagset&lt;/code&gt; again, the rough skeleton suitable for &lt;code&gt;Module::Build&lt;/code&gt; having converted the &lt;em&gt;Makefile.PL&lt;/em&gt; by &lt;a href=&#34;https://metacpan.org/pod/Module::Build::Convert&#34;&gt;&lt;code&gt;Module::Build::Convert&lt;/code&gt;&lt;/a&gt; into a &lt;em&gt;Build.PL&lt;/em&gt;, the output would be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; # This -*-perl-*- program writes the Makefile for installing this distribution.
 #
 # See &amp;quot;perldoc perlmodinstall&amp;quot; or &amp;quot;perldoc ExtUtils::MakeMaker&amp;quot; for
 # info on how to control how the installation goes.
 # Note: this file has been initially generated by Module::Build::Convert 0.24_01

 require 5.004;
 use strict;
 use warnings;

 use Module::Build;

 my $build = Module::Build-&amp;gt;new
   (
    module_name =&amp;gt; &#39;HTML::Tagset&#39;,
    dist_author =&amp;gt; &#39;Andy Lester &amp;lt;andy@petdance.com&amp;gt;&#39;,
    dist_version_from =&amp;gt; &#39;Tagset.pm&#39;,
    add_to_cleanup =&amp;gt; [
                        &#39;HTML-Tagset-*&#39;
                      ],
    license =&amp;gt; &#39;unknown&#39;,
    create_readme =&amp;gt; 1,
    create_makefile_pl =&amp;gt; &#39;traditional&#39;,
   );

 $build-&amp;gt;create_build_script;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, while &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; prefers uppercased arguments, &lt;code&gt;Module::Build&lt;/code&gt; goes by entirely lowercased arguments, which obey the rule of least surprise by being as intuitive as a description can be.&lt;/p&gt;

&lt;p&gt;The build and installation procedure for a &lt;code&gt;Module::Build&lt;/code&gt; distribution is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; % perl Build.PL
 % perl Build
 % perl Build test
 # perl Build install
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;module-build-convert-s-state-of-operation&#34;&gt;&lt;code&gt;Module::Build::Convert&lt;/code&gt;&amp;rsquo;s State of Operation&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Module::Build::Convert&lt;/code&gt; actually does all of the background work and can be safely considered the back end, whereas &lt;code&gt;make2build&lt;/code&gt; is the practical front-end utility. &lt;code&gt;Module::Build::Convert&lt;/code&gt; currently exposes two kinds of operation: static approach and dynamic execution. The static approach parses the arguments contained within the &lt;em&gt;Makefile.PL&amp;rsquo;s&lt;/em&gt; &lt;code&gt;WriteMakefile()&lt;/code&gt; call, whereas dynamic execution runs the &lt;em&gt;Makefile.PL&lt;/em&gt; and captures the arguments provided to &lt;code&gt;WriteMakefile()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Module::Build::Convert&lt;/code&gt; parses statically by default, because the dynamic execution has the downside that code will be interpreted and the interpreted output will be written to the &lt;em&gt;Build.PL&lt;/em&gt;, so you have to conclude that the user of the distribution will end up with predefined values computed on the author&amp;rsquo;s system. This is something to avoid, whenever possible! If the parsing approach fails, perhaps looping endlessly on input, &lt;code&gt;Module::Build::Convert&lt;/code&gt; will reinitialize to perform dynamic execution of the &lt;em&gt;Makefile.PL&lt;/em&gt; instead.&lt;/p&gt;

&lt;h3 id=&#34;span-id-data-section-data-section-span&#34;&gt;&lt;span id=&#34;data_section&#34;&gt;Data Section&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Module::Build::Convert&lt;/code&gt; comes with a rather huge data section containing the argument conversion table, default arguments, sorting order, and begin and end code. If you wish to change this data, consider making a &lt;em&gt;~/.make2buildrc&lt;/em&gt; file by launching &lt;code&gt;make2build&lt;/code&gt; with the &lt;code&gt;-rc&lt;/code&gt; switch. &lt;em&gt;Do not&lt;/em&gt; edit the &lt;code&gt;Data&lt;/code&gt; section within &lt;code&gt;Module::Build::Convert&lt;/code&gt; directly, unless you are sure you want to submit a patch.&lt;/p&gt;

&lt;h4 id=&#34;argument-conversion&#34;&gt;Argument Conversion&lt;/h4&gt;

&lt;p&gt;On the left-hand side is the &lt;code&gt;MakeMaker&lt;/code&gt;&amp;rsquo;s argument name, and on the right-hand side the &lt;code&gt;Module::Build&lt;/code&gt;&amp;rsquo;s equivalent.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; NAME                  module_name
 DISTNAME              dist_name
 ABSTRACT              dist_abstract
 AUTHOR                dist_author
 VERSION               dist_version
 VERSION_FROM          dist_version_from
 PREREQ_PM             requires
 PL_FILES              PL_files
 PM                    pm_files
 MAN1PODS              pod_files
 XS                    xs_files
 INC                   include_dirs
 INSTALLDIRS           installdirs
 DESTDIR               destdir
 CCFLAGS               extra_compiler_flags
 EXTRA_META            meta_add
 SIGN                  sign
 LICENSE               license
 clean.FILES           @add_to_cleanup
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;default-arguments&#34;&gt;Default Arguments&lt;/h4&gt;

&lt;p&gt;These are default &lt;code&gt;Module::Build&lt;/code&gt; arguments to added. Arguments with a leading &lt;code&gt;#&lt;/code&gt; are ignored.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; #build_requires       HASH
 #recommends           HASH
 #conflicts            HASH
 license               unknown
 create_readme         1
 create_makefile_pl    traditional
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;sorting-order&#34;&gt;Sorting Order&lt;/h4&gt;

&lt;p&gt;This is the sorting order for &lt;code&gt;Module::Build&lt;/code&gt; arguments.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; module_name
 dist_name
 dist_abstract
 dist_author
 dist_version
 dist_version_from
 requires
 build_requires
 recommends
 conflicts
 PL_files
 pm_files
 pod_files
 xs_files
 include_dirs
 installdirs
 destdir
 add_to_cleanup
 extra_compiler_flags
 meta_add
 sign
 license
 create_readme
 create_makefile_pl
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;begin-code&#34;&gt;Begin Code&lt;/h4&gt;

&lt;p&gt;Code that precedes converted &lt;code&gt;Module::Build&lt;/code&gt; arguments. &lt;code&gt;$(UPPERCASE)&lt;/code&gt; are stubs being substituted by &lt;code&gt;Module::Build&lt;/code&gt; code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; use strict;
 use warnings;

 use Module::Build;

 $MAKECODE

 my $b = Module::Build-&amp;gt;new
 $INDENT(
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;end-code&#34;&gt;End Code&lt;/h4&gt;

&lt;p&gt;Code that follows converted &lt;code&gt;Module::Build&lt;/code&gt; arguments. &lt;code&gt;$(UPPERCASE)&lt;/code&gt; are stubs being substituted by &lt;code&gt;Module::Build&lt;/code&gt; code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $INDENT);

 $b-&amp;gt;create_build_script;

 $MAKECODE
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;make2build-basic-usage&#34;&gt;&lt;code&gt;make2build&lt;/code&gt; Basic Usage&lt;/h3&gt;

&lt;p&gt;Using &lt;code&gt;make2build&lt;/code&gt; is as easy as launching it in the directory of the distribution of which &lt;em&gt;Makefile.PL&lt;/em&gt; you wish to convert.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% make2build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may also provide the full path to the distribution, assuming, for example, you didn&amp;rsquo;t &lt;code&gt;cd&lt;/code&gt; directly into the distribution directory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% make2build /path/to/HTML-Tagset*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In both cases, the command will convert any found &lt;em&gt;Makefile.PL&lt;/em&gt; files and will generate no output because &lt;code&gt;make2build&lt;/code&gt; acts quiet by default.&lt;/p&gt;

&lt;h3 id=&#34;make2build-switches&#34;&gt;&lt;code&gt;make2build&lt;/code&gt; Switches&lt;/h3&gt;

&lt;p&gt;As &lt;code&gt;make2build&lt;/code&gt; aims to be a proper script, it of course, provides both the &lt;code&gt;-h&lt;/code&gt; (help screen) and &lt;code&gt;-V&lt;/code&gt; (version) switches.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; % make2build -h
 % make2build -V
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In case you end up with a mangled &lt;em&gt;Build.PL&lt;/em&gt; written, you can examine the parsing process by launching &lt;code&gt;make2build&lt;/code&gt; with the &lt;code&gt;-d&lt;/code&gt; switch, enabling the pseudo-interactive debugging mode.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; % make2build -d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Should you not like the indentation length or judge it to be too small, increase it via the &lt;code&gt;-l&lt;/code&gt; switch followed by an integer.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; % make2build -l length
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you don&amp;rsquo;t agree with the sorting order predefined in &lt;code&gt;Module::Build::Convert&lt;/code&gt;, you may enforce the native sorting order, which strives to arrange standard arguments with those seen available in the &lt;code&gt;Makefile.PL&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; % make2build -n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The argument conversion table, default arguments to add, the sorting order of the arguments, and the begin and end code aren&amp;rsquo;t absolute, either. Change them by invoking &lt;code&gt;make2build&lt;/code&gt; with the &lt;code&gt;-rc&lt;/code&gt; switch to create a resource configuration file in the home directory of the current user; that is likely &lt;em&gt;~/.make2build.rc&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; % make2build -rc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While &lt;code&gt;make2build&lt;/code&gt; is quiet by default, there are two verbosity levels. To enforce verbosity level 1, launch &lt;code&gt;make2build&lt;/code&gt; with &lt;code&gt;-v&lt;/code&gt;. To enforce verbosity level 2, use &lt;code&gt;-vv&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;With &lt;code&gt;-v&lt;/code&gt;, the code will warn about &lt;em&gt;Makefile.PL&lt;/em&gt; options it does not understand or skips. With &lt;code&gt;-vv&lt;/code&gt;, it will accumulate &lt;code&gt;-v&lt;/code&gt; output and the entire generated &lt;em&gt;Build.PL&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; % make2build -v
 % make2build -vv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may execute the &lt;em&gt;Makefile.PL&lt;/em&gt; in first place, but such usage is deprecated because &lt;code&gt;Module::Build::Convert&lt;/code&gt; downgrades automatically when needed.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; % make2build -x (deprecated)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;swinging-with-perl&#34;&gt;Swinging with Perl&lt;/h3&gt;

&lt;p&gt;Phil Crow&lt;/p&gt;

&lt;p&gt;Perl does not have a native graphical user interface (GUI) toolkit. So we use all manner of existing GUI tools in front of our Perl applications. Often we use a web browser. We have long had Perl/Tk and other libraries based on C/C++. Now we can also use Java&amp;rsquo;s Swing toolkit with similar ease.&lt;/p&gt;

&lt;p&gt;In my sample application, when the user presses a button, Perl evaluates an arithmetic expression from the input text box. The result appears in another text box. I&amp;rsquo;ll show the code for this application a piece at a time with a discussion after each piece. To see the whole thing, look in the examples directory of the &lt;a href=&#34;https://metacpan.org/pod/Java::Swing&#34;&gt;&lt;code&gt;Java::Swing&lt;/code&gt;&lt;/a&gt; distribution.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #!/usr/bin/perl
    use strict; use warnings;

    BEGIN {
        $ENV{CLASSPATH} .= &#39;:/path/to/Java/Swing/java&#39;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Java::Swing&lt;/code&gt; needs certain Java classes to be in the class path before it loads, so I&amp;rsquo;ve appended a path to those classes in a &lt;code&gt;BEGIN&lt;/code&gt; block (this block must come before using &lt;code&gt;Java::Swing&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Java::Swing;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This innocuous statement magically sets up namespaces for each Java Swing component, among other things.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $expression  = JTextField-&amp;gt;new();
    my $answer      = JTextField-&amp;gt;new( { columns =&amp;gt; 10 } );
    my $submit      = JButton   -&amp;gt;new(&amp;quot;Evaluate&amp;quot;);
    my $frame       = JFrame    -&amp;gt;new();
    my $root_pane   = $frame-&amp;gt;getContentPane();
    my $south_panel = JPanel-&amp;gt;new();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After using &lt;code&gt;Java::Swing&lt;/code&gt;, you can refer to Swing components as Perl classes. You can even pass named parameters to their constructors, as shown for the second &lt;code&gt;JTextField&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $south_panel-&amp;gt;add(JLabel-&amp;gt;new(&amp;quot;Answer:&amp;quot;), &amp;quot;West&amp;quot;);
    $south_panel-&amp;gt;add($answer,                &amp;quot;Center&amp;quot;);
    $south_panel-&amp;gt;add($submit,                &amp;quot;East&amp;quot;);

    $root_pane-&amp;gt;add($expression,  &amp;quot;North&amp;quot;);
    $root_pane-&amp;gt;add($south_panel, &amp;quot;South&amp;quot;);

    $frame-&amp;gt;setSize(300, 100);
    $frame-&amp;gt;show();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Most work with the components is the same as in any Java program. If you don&amp;rsquo;t understand the above code, consult a good book on Swing (like the one from O&amp;rsquo;Reilly).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $swinger = Java::Swing-&amp;gt;new();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This creates a &lt;code&gt;Java::Swing&lt;/code&gt; instance to connect event listeners and to control the event loop.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $swinger-&amp;gt;connect(
        &amp;quot;ActionListener&amp;quot;, $submit, { actionPerformed =&amp;gt; \&amp;amp;evaluate }
    );

    $swinger-&amp;gt;connect(
        &amp;quot;WindowListener&amp;quot;, $frame, { windowClosing =&amp;gt; \&amp;amp;ending }
    );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Connection is simple. Pass the listener type, the object to listen to, and a hash of code references to call back as events arrive.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $swinger-&amp;gt;start();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Start the event loop. After this, the program passively waits for event callbacks. It stops when one of the callbacks stops the event loop.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub evaluate {
        my $sender_name = shift;
        my $event       = shift;

        $answer-&amp;gt;setText(eval $expression-&amp;gt;getText());
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;My evaluation is simple. I retrieve the text from the expression &lt;code&gt;JTextField&lt;/code&gt;, &lt;code&gt;eval&lt;/code&gt; it, and pass the result to &lt;code&gt;setText&lt;/code&gt; on the answer &lt;code&gt;JTextField&lt;/code&gt;. Using &lt;code&gt;eval&lt;/code&gt; raises possible security concerns, so use it wisely.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub ending {
        $swinger-&amp;gt;stop();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the user closes the window, I stop the event loop by calling &lt;code&gt;stop&lt;/code&gt; on the &lt;code&gt;Java::Swing&lt;/code&gt; instance gained earlier. This kills the program.&lt;/p&gt;

&lt;p&gt;With &lt;code&gt;Java::Swing&lt;/code&gt;, you can build Swing apps in Perl with some important bits of syntactic sugar. First, you don&amp;rsquo;t need to have separate Java files or inline sections. Second, you can pass named arguments to constructors. Finally, you can easily connect event listeners to Perl callback code.&lt;/p&gt;

&lt;h3 id=&#34;scriptify-your-module&#34;&gt;Scriptify Your Module&lt;/h3&gt;

&lt;p&gt;Josh McAdams&lt;/p&gt;

&lt;p&gt;Recently during an MJD talk at Chicago.pm, I saw a little Perl trick that was so amazingly simple and yet so useful that it was hard to believe that more mongers in the crowd hadn&amp;rsquo;t heard of it. The trick involved taking your module and adding a driver routine to it so the module could run as a script.&lt;/p&gt;

&lt;p&gt;To illustrate, start with an example module that contains two utility subroutines that convert weights between pounds and kilograms. The subroutines accept some number and multiplies it by a conversion factor.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  package WeightConverter;

  use strict;
  use warnings;
  use constant LB_PER_KG =&amp;gt; 2.20462262;
  use constant KG_PER_LB =&amp;gt; 1/LB_PER_KG;

  sub kilograms_to_pounds { $_[0] * LB_PER_KG; }

  sub pounds_to_kilograms { $_[0] * KG_PER_LB; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Assuming that the real module has a little error checking and POD, this module would serve you just fine. However, what if you decided that we needed to be able to easily do weight conversions from the command line? One option would be to write a Perl script that used &lt;code&gt;WeightConverter&lt;/code&gt;. If that seems like too much effort, there is a one-liner that would do conversions.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  perl -MWeightConverter -e &#39;print WeightConverter::kilograms_to_pounds(1),&amp;quot;\n&amp;quot;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This would do the trick, but it is a lot to remember and isn&amp;rsquo;t very fun to type. There is a lot of benefit available from saving some form of script, and believe it or not, the module can hold that script. All that you have to do is write some driver subroutine and then call that subroutine if the module is not being used by another script. Here is an example driver for &lt;code&gt;WeightConverter&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This example driver script just loops through the command-line arguments and tries to find instances where the argument contains either a &lt;code&gt;k&lt;/code&gt; or &lt;code&gt;p&lt;/code&gt; equal to some value. Based on whether or not you are starting with pounds or kilograms, it calls the appropriate subroutine and prints the results.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  sub run {
    for (@ARGV) {
      if(/^[-]{0,2}(k|p)\w*=(.+)$/) {
        $1 eq &#39;k&#39; ?
          print &amp;quot;$2 kilograms is &amp;quot;, kilograms_to_pounds($2), &amp;quot; pounds\n&amp;quot; :
          print &amp;quot;$2 pounds is &amp;quot;, pounds_to_kilograms($2), &amp;quot; kilograms\n&amp;quot; ;
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now all that is left is to tell the module to run the &lt;code&gt;run&lt;/code&gt; subroutine if someone has run the module on its own. This is as easy as adding one line somewhere in the main body of the module.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  run unless caller;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All this statement does is execute the &lt;code&gt;run&lt;/code&gt; subroutine unless the &lt;code&gt;caller&lt;/code&gt; function returns a value. &lt;code&gt;caller&lt;/code&gt; will only return true if &lt;code&gt;WeightConverter&lt;/code&gt; is being used in another script. Now, this module is usable in other scripts as well as on the command line.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $&amp;gt; perl WeightConverter.pm -kilos=2 -pounds=145 -k=.345
  2 kilograms is 4.40924524 pounds
  145 pounds is 65.7708937051548 kilograms
  .345 kilograms is 0.7605948039 pounds
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mocks-in-your-test-fixtures&#34;&gt;Mocks in Your Test Fixtures&lt;/h3&gt;

&lt;p&gt;by chromatic&lt;/p&gt;

&lt;p&gt;Since writing &lt;code&gt;Test::MockObject&lt;/code&gt;, I&amp;rsquo;ve used it in nearly every complex test file I&amp;rsquo;ve written. It makes my life much easier to be able to control only what I need for the current group of tests.&lt;/p&gt;

&lt;p&gt;I wish I&amp;rsquo;d written &lt;code&gt;Test::MockObject::Extends&lt;/code&gt; earlier than I did; that module allows you to decorate an existing object with a mockable wrapper. It works just as the wrapped object does, but if you add any mocked methods, it will work like a regular mock object.&lt;/p&gt;

&lt;p&gt;This is very useful when you don&amp;rsquo;t want to go through all of the overhead of setting up your own mock object but do want to override one or two methods. (It&amp;rsquo;s almost always the right thing to do instead of using &lt;code&gt;Test::MockObject.&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;Another very useful test module is &lt;code&gt;Test::Class&lt;/code&gt;. It takes more work to understand and to use than &lt;code&gt;Test::More&lt;/code&gt;, but it pays back that investment by allowing you to group, reuse, and organize tests in the same way you would group, reuse, and organize objects in your code. Instead of writing your tests procedurally, from the start to the end of a test file, you organize them into classes.&lt;/p&gt;

&lt;p&gt;This is most useful when you&amp;rsquo;ve organized your code along similar lines. If you have a base class with a lot of behavior and a handful of subclasses that add and override a little bit of behavior, write a &lt;code&gt;Test::Class&lt;/code&gt;-based test for the base class and smaller tests that inherit from the base test for the subclasses.&lt;/p&gt;

&lt;p&gt;Goodbye, duplicate code.&lt;/p&gt;

&lt;h4 id=&#34;fixtures&#34;&gt;Fixtures&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Test::Class&lt;/code&gt; encourages you to group related tests into test methods. This allows you to override and extend those groups of tests in test subclasses. (Good OO design principles apply here; tests are still just code, after all.) One of the benefits of grouping tests in this way is that you can use test fixtures.&lt;/p&gt;

&lt;p&gt;A test fixture is another method that runs before every test method. You can use them to set up the test environment&amp;ndash;creating a new object to test, resetting test data, and generally making sure that tests don&amp;rsquo;t interfere with each other.&lt;/p&gt;

&lt;p&gt;A standard test fixture might resemble:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  sub make_fixture :Test( setup )
  {
      my $self        = shift;
      $self-&amp;gt;{object} = $self-&amp;gt;test_class()-&amp;gt;new();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Assuming that there&amp;rsquo;s a &lt;code&gt;test_class()&lt;/code&gt; method that returns the name of the class being tested, this fixture creates a new instance before every test method and stores it as the &lt;code&gt;object&lt;/code&gt; attribute. The test methods can then fetch this as normal.&lt;/p&gt;

&lt;h4 id=&#34;putting-them-together&#34;&gt;Putting Them Together&lt;/h4&gt;

&lt;p&gt;I recently built some tests for a large system using &lt;code&gt;Test::Class&lt;/code&gt;. Some of the tests had mockable features&amp;ndash;they dealt with file or database errors, for example. I found myself creating a lot of little &lt;code&gt;Test::MockObject::Extends&lt;/code&gt; instances within most of the tests.&lt;/p&gt;

&lt;p&gt;Then inspiration struck. Duplication is bad. Repetition is bad. Factor it out into one place.&lt;/p&gt;

&lt;p&gt;The insight was quick and sudden. If &lt;code&gt;Test::MockObject::Extends&lt;/code&gt; is transparent (and if it isn&amp;rsquo;t, please file a bug&amp;ndash;I&amp;rsquo;ll fix it), I can use it in the test fixture all the time and then be able to mock whenever I want without doing any setup. I changed my fixture to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  sub make_fixture :Test( setup )
  {
      my $self        = shift;
          my $object      = $self-&amp;gt;test_class()-&amp;gt;new();
      $self-&amp;gt;{object} = Test::MockObject::Extends-&amp;gt;new( $object );
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The rest of my code remained unchanged, except that now I could delete several identical lines from several test methods.&lt;/p&gt;

&lt;p&gt;Do note that, for this to work, you must adhere to good OO design principles in the code being tested. Don&amp;rsquo;t assume that &lt;code&gt;ref&lt;/code&gt; is always what you think it should be (and use the &lt;code&gt;isa()&lt;/code&gt; method instead).&lt;/p&gt;

&lt;p&gt;Sure, this is a one-line trick, but it removed a lot of busy work from my life and it illustrates two interesting techniques for managing tests. If you need simpler, more precise mocks, use &lt;code&gt;Test::MockObject::Extends&lt;/code&gt;. If you need better organization and less duplication in your test files, use &lt;code&gt;Test::Class&lt;/code&gt;. Like all good test modules, they work together almost flawlessly.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>An Introduction to Test::MockDBI</title>
      <link>http://localhost:1313/pub/2005/07/21/test_mockdbi.html/</link>
      <pubDate>Thu, 21 Jul 2005 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2005/07/21/test_mockdbi.html/</guid>
      <description>

&lt;h3 id=&#34;prelude&#34;&gt;Prelude&lt;/h3&gt;

&lt;p&gt;How do you test DBI programs:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Without having to modify your current program code or environment settings?&lt;/li&gt;
&lt;li&gt;Without having to set up multiple test databases?&lt;/li&gt;
&lt;li&gt;Without separating your test data from your test code?&lt;/li&gt;
&lt;li&gt;With tests for every bizarre value your program will ever have to face?&lt;/li&gt;
&lt;li&gt;With complete control over all database return values, along with all DBI method return values?&lt;/li&gt;
&lt;li&gt;With an easy, regex-based rules interface?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You test with &lt;a href=&#34;https://metacpan.org/pod/Test::MockDBI&#34;&gt;Test::MockDBI&lt;/a&gt;, that&amp;rsquo;s how. Test::MockDBI provides all of this by using Test::MockObject::Extends to mock up the entire DBI API. Without a solution like Test::MockDBI&amp;ndash;a solution that enables direct manipulation of the DBI&amp;ndash;you&amp;rsquo;ll have to trace DBI methods through a series of test databases.&lt;/p&gt;

&lt;p&gt;You can make test databases work, but:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;You&amp;rsquo;ll need multiple (perhaps many) databases when you need multiple sets of mutually inconsistent values for complete test coverage.&lt;/li&gt;
&lt;li&gt;Some DBI failure modes are impossible to generate through any test database.&lt;/li&gt;
&lt;li&gt;Depending on the database toolset available, it may be difficult to insert all necessary test values&amp;ndash;for example, Unicode values in ASCII applications, or bizarre file types in a document-manager application.&lt;/li&gt;
&lt;li&gt;Test databases, by definition, are separate from their corresponding test code. This increases the chance that the test code and the test data will fall out of sync with each other.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Using Test::MockDBI avoids these problems. Read on to learn how Test::MockDBI eases the job of testing DBI applications.&lt;/p&gt;

&lt;h3 id=&#34;a-mock-up-of-the-entire-dbi&#34;&gt;A Mock Up of the Entire DBI&lt;/h3&gt;

&lt;p&gt;Test::MockDBI mocks up the entire DBI API by using &lt;a href=&#34;https://metacpan.org/pod/Test::MockObject::Extends&#34;&gt;Test::MockObject::Extends&lt;/a&gt; to substitute a Test::MockObject::Extends object in place of the &lt;a href=&#34;https://metacpan.org/pod/DBI&#34;&gt;DBI&lt;/a&gt;. A feature of this approach is that if the DBI API changes (and you use that change), you will notice during testing if you haven&amp;rsquo;t upgraded Test::MockDBI, as your program will complain about missing DBI API method(s).&lt;/p&gt;

&lt;p&gt;Mocking up the entire DBI means that you can add the DBI testing code into an existing application without changing the initial application code&amp;ndash;using Test::MockDBI is entirely transparent to the rest of your application, as it neither knows nor cares that it&amp;rsquo;s using Test::MockDBI in place of the DBI. This property of transparency is what drove me to develop Test::MockDBI, as it meant I could add the Test::MockDBI DBI testing code to existing client applications without modifying the existing code (handy, for us consultants).&lt;/p&gt;

&lt;p&gt;Further enhancing Test::MockDBI&amp;rsquo;s transparency is the &lt;code&gt;DBI testing type&lt;/code&gt; class value. Testing is only enabled when the DBI testing type is non-zero, so you can just leave the DBI testing code additions in your production code&amp;ndash;users will not even know about your DBI testing code unless you tell them.&lt;/p&gt;

&lt;p&gt;Mocking up the entire DBI also means that you have complete control of the DBI&amp;rsquo;s behavior during testing. Often, you can simulate a &lt;code&gt;SELECT&lt;/code&gt; DBI transaction with a simple state machine that returns just a few rows from the (mocked up) database. Test::MockDBI lets you use a &lt;code&gt;CODEREF&lt;/code&gt; to supply database return values, so you can easily put a simple state machine into the &lt;code&gt;CODEREF&lt;/code&gt; to supply the necessary database values for testing. You could even put a delay loop into the &lt;code&gt;CODEREF&lt;/code&gt; when you need to perform speed tests on your code.&lt;/p&gt;

&lt;h3 id=&#34;rules-based-dbi-testing&#34;&gt;Rules-Based DBI Testing&lt;/h3&gt;

&lt;p&gt;You control the mocked-up DBI of Test::MockDBI with one or more rules that you insert as Test::MockDBI method calls into your program. The default DBI method values provided by Test::MockDBI make the database appear to have a hole in the bottom of it&amp;ndash;all method calls return OK, but you can&amp;rsquo;t get any data out of the database. Rules for DBI methods that return database values (the &lt;code&gt;fetch*()&lt;/code&gt; and &lt;code&gt;select*()&lt;/code&gt; methods) can use either a value that they return directly for matching method calls, or a &lt;code&gt;CODEREF&lt;/code&gt; called to provide a value each time that rule fires. A rule matches when its DBI testing type is the current testing type and the current SQL matches the rule&amp;rsquo;s regular expression. Rules fire in the order in which you declare them, so usually you want to order your rules from most-specific to least-specific.&lt;/p&gt;

&lt;p&gt;The DBI testing type is an unsigned integer matching &lt;code&gt;/^d+$/&lt;/code&gt;. When the DBI testing type is zero, there will be no DBI testing (or at least, no mocked-up DBI testing) performed, and the program will use the DBI normally. A zero DBI testing type value in a rule means the rule could fire for any non-zero DBI testing type value&amp;ndash;that is, zero is the wildcard DBI testing type value for rules. Set the DBI testing type either by a first command-line argument of the form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--dbitest[=DTT]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where the optional &lt;code&gt;DTT&lt;/code&gt; is the DBI testing type (defaulting to one), or through Test::MockDBI&amp;rsquo;s &lt;code&gt;set_dbi_test_type()&lt;/code&gt; method. Setting the DBI testing type through a first command-line argument has the advantage of requiring no modifications to the code under test, as this command-line processing is done so early (during &lt;code&gt;BEGIN&lt;/code&gt; time for Test::MockDBI) that the code under test should be ignorant of whether this processing ever happened.&lt;/p&gt;

&lt;h3 id=&#34;dbi-return-values&#34;&gt;DBI Return Values&lt;/h3&gt;

&lt;p&gt;Test::MockDBI defaults to returning a success (true) value for all DBI method calls. This fits well with the usual techniques of DBI programming, where the first DBI error causes the program to stop what it is doing. Test::MockDBI&amp;rsquo;s &lt;code&gt;bad_method()&lt;/code&gt; method creates a rule that forces a failure return value on the specified DBI method when the current DBI testing type and SQL match those of the rule. Arbitrary DBI method return value failures like these are difficult (at best) to generate with a test database.&lt;/p&gt;

&lt;p&gt;Test::MockDBI&amp;rsquo;s &lt;code&gt;set_retval_scalar()&lt;/code&gt; and &lt;code&gt;set_retval_array()&lt;/code&gt; methods create rules for what database values to return. Set rules for scalar return values (&lt;code&gt;arrayrefs&lt;/code&gt; and &lt;code&gt;hashrefs&lt;/code&gt;) with &lt;code&gt;set_retval_scalar()&lt;/code&gt; and for array return value rules with &lt;code&gt;set_retval_array()&lt;/code&gt;. You can supply a value to be returned every time the rule matches, which is good when extracting single rows out of the database, such as configuration parameters. Alternatively, pass a &lt;code&gt;CODEREF&lt;/code&gt; that will be called each time the rule fires to return a new value. Commonly, with &lt;code&gt;SELECT&lt;/code&gt; statements, the DBI returns one or more rows, then returns an empty row to signify the end of the data. A &lt;code&gt;CODEREF&lt;/code&gt; can incorporate a state machine that implements this &amp;ldquo;return 1+ rows, then a terminator&amp;rdquo; behavior quite easily. Having individual state machines for each rule is much easier to develop with than having one master state machine embedded into Test::MockDBI&amp;rsquo;s core. (An early alpha of Test::MockDBI used the master state machine approach, so I have empirical evidence of this result&amp;ndash;I am not emptily theorizing here.)&lt;/p&gt;

&lt;p&gt;Depending on what tools you have for creating your test databases, it may be difficult to populate the test database with all of the values you need to test against. Although it is probably not so much the case today, only a few years ago populating a database with Unicode was difficult, given the national-charset-based tools of the day. Even today, a document management system might be difficult to populate with weird file types. Test::MockDBI makes these kinds of tests much easier to carry out, as you directly specify the data for the mock database to return rather than using a separate test database.&lt;/p&gt;

&lt;p&gt;This ease of database value testing also applies when you need to test against combinations of database values that are unlikely to occur in practice (the old &amp;ldquo;comparing apples to battleships&amp;rdquo; problem). If you need to handle database value corruption&amp;ndash;as in network problems causing the return of partial values from a Chinese database when the program is in the U.S.&amp;ndash;this ability to completely specify the database return values could be invaluable in testing. Test::MockDBI lets you take complete control of your database return values without separating test code and test data.&lt;/p&gt;

&lt;h3 id=&#34;simplicity-test-mockdbi-s-standard-output-based-interface&#34;&gt;Simplicity: Test::MockDBI&amp;rsquo;s Standard-Output-Based Interface&lt;/h3&gt;

&lt;p&gt;This modern incarnation of the age-old stubbed-functions technique also uses the old technique of &amp;ldquo;&lt;code&gt;printf()&lt;/code&gt; and scratch head&amp;rdquo; as its output interface. This being Perl we are working with, and not FORTRAN IV (thank goodness), we have multiple options beyond the use of unvarnished standard output.&lt;/p&gt;

&lt;p&gt;One option that I think integrates well with DBI-using module testing is to redirect standard output into a string using &lt;a href=&#34;https://metacpan.org/pod/IO::String&#34;&gt;IO::String&lt;/a&gt;. You can then match the string against the regex you are looking for. As you have already guessed, use of pure standard output integrates well with command-line program testing.&lt;/p&gt;

&lt;p&gt;What you will look for, irrespective of where your code actually looks, is the output of each DBI method as it executes&amp;ndash;the method name and arguments&amp;ndash;along with anything else your code writes to standard output.&lt;/p&gt;

&lt;h3 id=&#34;bind-test-data-to-test-code&#34;&gt;Bind Test Data to Test Code&lt;/h3&gt;

&lt;p&gt;Because DBI and database return values are bound to your test programs when using Test::MockDBI, there is less risk of test data getting out of sync with the test code. A separate test database introduces another point of failure in your testing process. Multiple test databases add yet another point of failure for each database. Whatever you use to generate the test databases also introduces another point of failure for each database. I can imagine cases where special-purpose programs for generating test databases might create multiple points of failure, especially if the programs have to integrate data from multiple sources to generate the test data (such as a VMS Bill of Materials database and a Solaris PCB CAD file for a test database generation program running on Linux).&lt;/p&gt;

&lt;p&gt;One of the major advances in software engineering is the increasing ability to gather and control related information together&amp;ndash;the 1990s advance of object-oriented programming in common languages is a testimony to this, from which we Perl programmers reap the benefits in our use of CPAN. For many testing purposes, there is no need for separate test databases. Without that need for a separate test database, separating test data from test code only complicates the testing process. Test::MockDBI lets you bind together your test code and test data into one nice, neat package. Binding is even closer than code and comments, as comments can get out of sync with their code, while the test code and test data for Test::MockDBI cannot get out of sync too far without causing their tests to fail unexpectedly.&lt;/p&gt;

&lt;h3 id=&#34;when-to-use-test-mockdbi&#34;&gt;When to Use Test::MockDBI&lt;/h3&gt;

&lt;p&gt;DBI&amp;rsquo;s &lt;code&gt;trace()&lt;/code&gt;, &lt;a href=&#34;https://metacpan.org/pod/DBD::Mock&#34;&gt;DBD::Mock&lt;/a&gt;, and Test::MockDBI are complementary solutions to the problem of testing DBI software. DBI&amp;rsquo;s &lt;code&gt;trace()&lt;/code&gt; is a pure tracing mechanism, as it does not change the data returned from the database or the DBI method return values. DBD::Mock works at level of a database driver, so you have to look at your DBI testing from the driver&amp;rsquo;s point of view, rather than the DBI caller&amp;rsquo;s point of view. DBD::Mock also requires that your code supports configurable DBI DSNs, which may not be the case in all circumstances, especially when you must maintain or enhance legacy DBI software.&lt;/p&gt;

&lt;p&gt;Test::MockDBI works at the DBI caller&amp;rsquo;s level, which is (IMHO) more natural for testing DBI-using software (possibly a matter of taste: TMTOWTDI). Test::MockDBI&amp;rsquo;s interface with your DBI software is a set of easy-to-program, regex-based rules, which incorporate a lot of power into one or a few lines of code, thereby using Perl&amp;rsquo;s built-in regex support to best advantage. This binds test data and test code tightly together, reducing the chance of synchronization problems between the test data and the test code. Using Test::MockDBI does not require modifying the current code of the DBI software being tested, as you only need additional code to enable Test::MockDBI-driven DBI testing.&lt;/p&gt;

&lt;p&gt;Test::MockDBI takes additional coding effort when you need to test DBI program performance. It may be that for performance testing, you want to use test databases rather than Test::MockDBI. If you were in any danger of your copy of &lt;em&gt;DBI.pm&lt;/em&gt; becoming corrupted, I don&amp;rsquo;t know whether you could adequately test that condition with Test::MockDBI, depending on the corruption. You would probably have to create a special mock DBI to test corrupted DBI code handling, though you could start building the special mock DBI by inheriting from Test::MockDBI without any problems from Test::MockDBI&amp;rsquo;s design, as it should be inheritance-friendly.&lt;/p&gt;

&lt;h3 id=&#34;some-examples&#34;&gt;Some Examples&lt;/h3&gt;

&lt;p&gt;To make:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$dbh = DBI-&amp;gt;connect(&amp;quot;dbi:AZ:universe&amp;quot;, &amp;quot;mortal&amp;quot;, &amp;quot;(none)&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;fail, add the rule:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$tmd-&amp;gt;bad_method(&amp;quot;connect&amp;quot;, 1,
    &amp;quot;CONNECT TO dbi:AZ:universe AS mortal WITH \\(none\\)&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(where &lt;code&gt;$tmd&lt;/code&gt; is the only Test::MockDBI object, which you obtain through Test::MockDBI&amp;rsquo;s &lt;code&gt;get_instance()&lt;/code&gt; method).&lt;/p&gt;

&lt;p&gt;To make a SQL &lt;code&gt;SELECT&lt;/code&gt; failure when using &lt;code&gt;DBI::execute()&lt;/code&gt;, use the rule:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$tmd-&amp;gt;bad_method(&amp;quot;execute&amp;quot;, 1,
    &amp;quot;SELECT zip_plus_4 from zipcodes where state=&#39;IN&#39;&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This rule implies that:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;DBI::connect()&lt;/code&gt; &lt;code&gt;succeeded()&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;DBI::prepare()&lt;/code&gt; &lt;code&gt;succeeded()&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;But the &lt;code&gt;DBI::execute()&lt;/code&gt; failed as it should.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A common use of direct scalar return values is returning configuration data, such as a U.S. zip code for an address:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$tmd-&amp;gt;set_retval_scalar(1,
 &amp;quot;zip5.*&#39;IN&#39;.*&#39;NOBLESVILLE&#39;.*&#39;170 WESTFIELD RD&#39;&amp;quot;,
 [ 46062 ]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This demonstrates using a regular expression, as matching SQL could then look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT
  zip5
FROM
  zipcodes
WHERE
  state=&#39;IN&#39; AND
  city=&#39;NOBLESVILLE&#39; AND
  street_address=&#39;170 WESTFIELD RD&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the rule would match.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SELECT&lt;/code&gt;s that return one or more rows from the database are the common case:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $counter = 0;                    # name counter
sub possibly_evil_names {
    $counter++;
    if ($counter == 1) {
        return (&#39;Adolf&#39;, &#39;Germany&#39;);
    } elsif ($counter == 2) {
        return (&#39;Josef&#39;, &#39;U.S.S.R.&#39;);
    } else {
        return ();
    }
}
$tmd-&amp;gt;set_retval_array(1,
   &amp;quot;SELECT\\s+name,\\s+country.*possibly_evil_names&amp;quot;,
   \&amp;amp;possibly_evil_names);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using a &lt;code&gt;CODEREF&lt;/code&gt; (&lt;code&gt;\&amp;amp;possibly_evil_names&lt;/code&gt;) lets you easily add the state machine for implementing a return of two names followed by an empty array (because the code uses &lt;code&gt;fetchrow_array()&lt;/code&gt; to retrieve each row). SQL for this query could look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT
  name,
  country
FROM
  possibly_evil_names
WHERE
  year &amp;lt; 2000
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;summary&#34;&gt;Summary&lt;/h3&gt;

&lt;p&gt;Albert Einstein once said, &amp;ldquo;Everything should be made as simple as possible, but no simpler.&amp;rdquo; This is what I have striven for while developing Test::MockDBI&amp;ndash;the simplest possible useful module for testing DBI programs by mocking up the entire DBI.&lt;/p&gt;

&lt;p&gt;Test::MockDBI gives you:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Complete control of DBI return values and database-returned data.&lt;/li&gt;
&lt;li&gt;Returned database values from either direct value specifications or &lt;code&gt;CODEREF&lt;/code&gt;-generated values.&lt;/li&gt;
&lt;li&gt;Easy, regex-based rules that govern the DBI&amp;rsquo;s behavior, along with intelligent defaults for the common cases.&lt;/li&gt;
&lt;li&gt;Complete transparency to other code, so the code under test neither knows nor cares that you are testing it with Test::MockDBI.&lt;/li&gt;
&lt;li&gt;Test data tightly bound to test code, which promotes cohesiveness in your testing environment, thereby reducing the chance that your tests might silently fail due to loss of synchronization between your test data and your test code.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Test::MockDBI is a valuable addition to the arsenal of DBI testing techniques.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Perl Code Kata: Mocking Objects</title>
      <link>http://localhost:1313/pub/2005/04/07/mockobject_kata.html/</link>
      <pubDate>Thu, 07 Apr 2005 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2005/04/07/mockobject_kata.html/</guid>
      <description>

&lt;p&gt;The last Perl Code Kata was on &lt;a href=&#34;https://metacpan.org/pod/DBD::Mock&#34;&gt;DBD::Mock&lt;/a&gt;, a mock DBI driver which is useful for &lt;a href=&#34;http://localhost:1313/pub/2005/02/10/database_kata.html&#34;&gt;testing Perl DBI applications&lt;/a&gt;. This Kata delves once again into the world of mock objects, this time using the more general &lt;a href=&#34;https://metacpan.org/pod/Test::MockObject&#34;&gt;Test::MockObject&lt;/a&gt; module.&lt;/p&gt;

&lt;h3 id=&#34;what-are-mock-objects&#34;&gt;What are Mock Objects?&lt;/h3&gt;

&lt;p&gt;Mock objects are exactly what they sound like: &amp;ldquo;mocked&amp;rdquo; or &amp;ldquo;fake&amp;rdquo; objects. Through the power of polymorphism, it&amp;rsquo;s easy to swap one object for another object which implements the same interface. Mock objects take advantage of this fact, allowing you to substitute the &lt;em&gt;most minimally mocked implementation of an object possible&lt;/em&gt; for the real one during testing. This allows a greater degree of isolation within your tests, which is just an all around good thing.&lt;/p&gt;

&lt;h3 id=&#34;what-are-mock-objects-good-for&#34;&gt;What are Mock Objects Good For?&lt;/h3&gt;

&lt;p&gt;Mock objects are primarily useful when writing unit tests. They share a certain similarity with the Null Object pattern in that they are purposefully &lt;em&gt;not&lt;/em&gt; meant to work. Mock objects take things one step further and allow you to mock certain actions or reactions that your mock object should have, so they are especially useful in scenarios usually considered &lt;em&gt;hard to test&lt;/em&gt;. Here is a short list of some scenarios in which mock objects make hard things easy.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Tests which depend on outside resources such as networks, databases, etc.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;If your code properly encapsulates any outside resources, then it should be possible to substitute a mocked object in its place during testing. This is especially useful when you have little control over the execution environment of your module. The previous Test Code Kata illustrated this by mocking the database itself. You need not stop with databases; you can mock any sufficiently encapsulated resource such as network connections, files, or miscellaneous external devices.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;Tests for which dependencies require a lot of setup.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Sometimes your object will have a dependency which requires a large amount of set-up code. The more non-test code in your tests, the higher the possibility that it will contain a bug which can then corrupt your test results. Many times your code uses only a small portion of this hard-to-setup dependency as well. Mock objects can help simplify things by allowing you to create the most minimally mocked implementation of an object and its dependencies possible, thus removing the burden of the set-up code and reducing the possibility of bugs in your non-test code.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;Tests for failures; in particular, failure edge cases.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Testing for failures can sometimes be very difficult to do, especially when the failure is not immediate, but triggered by a more subtle set of interactions. Using mock objects, it is possible to achieve exacting control over when, where, and why your object will fail. Mock objects often make this kind of testing trivial.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;Tests with optional dependencies.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Good code should be flexible code. Many times this means that your code needs to adapt to many different situations and many different environments based on the resources available at runtime. Requiring the presence of these situations and/or environments in order to test your code can be very difficult to set up or to tear down. Just as with testing failures, it is possible to use mock objects to achieve a high degree of control over your environment and mock the situations you need to test.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;the-problem&#34;&gt;The Problem&lt;/h3&gt;

&lt;p&gt;The example code for this kata illustrates as many points as possible about which mock objects are good at testing. Here is the code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package Site::Member;

use strict;
our $VERSION = &#39;0.01&#39;;

sub new { bless { ip_address =&amp;gt; &#39;&#39; }, shift }

sub ip_address { 
    my ($self, $ip_address) = @_;
    $self-&amp;gt;{ip_address} = $ip_address if $ip_address;
    return $self-&amp;gt;{ip_address};
}

# ...

sub city {
    my ($self) = @_;
    eval &amp;quot;use Geo::IP&amp;quot;;
    if ($@) {
        warn &amp;quot;You must have Geo::IP installed for this feature&amp;quot;;
        return;
    }
    my $geo = Geo::IP-&amp;gt;open(
                &amp;quot;/usr/local/share/GeoIP/GeoIPCity.dat&amp;quot;, 
                Geo::IP-&amp;gt;GEOIP_STANDARD
            ) || die &amp;quot;Could not create a Geo::IP object with City data&amp;quot;;
    my $record = $geo-&amp;gt;record_by_addr($self-&amp;gt;ip_address());
    return $record-&amp;gt;city();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example code comes from a fictional online community software package. Many such sites offer user homepages which can display all sorts of user information. As an optional feature, the software can use the member&amp;rsquo;s IP address along with the &lt;a href=&#34;https://metacpan.org/pod/Geo::IP&#34;&gt;Geo::IP&lt;/a&gt; module to determine the user&amp;rsquo;s city. The reason this feature is optional is that while &lt;code&gt;Geo::IP&lt;/code&gt; and the C library it uses are both free, the city data is not.&lt;/p&gt;

&lt;p&gt;The use cases suggest testing for the following scenarios:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;User does not have &lt;code&gt;Geo::IP&lt;/code&gt; installed.&lt;/li&gt;
&lt;li&gt;User has &lt;code&gt;Geo::IP&lt;/code&gt; installed but does not have the city data.&lt;/li&gt;
&lt;li&gt;User has &lt;code&gt;Geo::IP&lt;/code&gt; and city data installed correctly.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Using &lt;code&gt;Test::MockObject&lt;/code&gt;, take thirty to forty minutes and see if you can write tests which cover all these use cases.&lt;/p&gt;

&lt;h3 id=&#34;tips-tricks-and-suggestions&#34;&gt;Tips, Tricks, and Suggestions&lt;/h3&gt;

&lt;p&gt;Some of the real strengths of &lt;code&gt;Test::MockObject&lt;/code&gt; lie in its adaptability and how simply it adapts. All &lt;code&gt;Test::MockObject&lt;/code&gt; sessions begin with creating an instance.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $mock = Test::MockObject-&amp;gt;new();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Even just this much can be useful because a &lt;code&gt;Test::MockObject&lt;/code&gt; instance warns about all un-mocked methods called on it. I have used this &amp;ldquo;feature&amp;rdquo; to help trace calls while writing complex tests.&lt;/p&gt;

&lt;p&gt;The next step is to mock some methods. The simplest approach is to use the &lt;code&gt;mock&lt;/code&gt; method. It takes a method name and a subroutine reference. Every time something calls that method on the object, your &lt;code&gt;$mock&lt;/code&gt; instance will run that sub.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$mock-&amp;gt;mock(&#39;greetings&#39; =&amp;gt; sub {
    my ($mock, $name) = @_;
    return &amp;quot;Hello $name&amp;quot;;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How much simpler could it be?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Test::MockObject&lt;/code&gt; also offers several pre-built mock method builders, such as &lt;code&gt;set_true&lt;/code&gt;, &lt;code&gt;set_false&lt;/code&gt;, and &lt;code&gt;set_always&lt;/code&gt;. These methods pretty much DWIM.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$mock-&amp;gt;set_true(&#39;foo&#39;); # the foo() method will return true
$mock-&amp;gt;set_false(&#39;bar&#39;); # the bar() method will return false
$mock-&amp;gt;set_always(&#39;baz&#39; =&amp;gt; 100); # the bar() method will always return 100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s even possible for the object to mock not only the methods, but its class as well. The simplest approach is to use the &lt;code&gt;set_isa&lt;/code&gt; method to tell the &lt;code&gt;$mock&lt;/code&gt; object to pretend that it belongs to another class.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$mock-&amp;gt;set_isa(&#39;Foo::Bar&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, any code that calls this mock object&amp;rsquo;s &lt;code&gt;isa()&lt;/code&gt; method will believe that the &lt;code&gt;$mock&lt;/code&gt; is a &lt;code&gt;Foo::Bar&lt;/code&gt; object.&lt;/p&gt;

&lt;p&gt;In many cases, it is enough to substitute a &lt;code&gt;$mock&lt;/code&gt; instance for a real one and let polymorphism do the rest. Other times it is necessary to inject control into the code much earlier than this. This is where the &lt;code&gt;fake_module&lt;/code&gt; method comes in.&lt;/p&gt;

&lt;p&gt;With the &lt;code&gt;fake_module&lt;/code&gt; method, &lt;code&gt;Test::MockObject&lt;/code&gt; can subvert control of an entire package such that it will intercept any calls to that package. The following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $mock = Test::MockObject-&amp;gt;new();
$mock-&amp;gt;fake_module(&#39;Foo::Bar&#39; =&amp;gt; (
    &#39;import&#39; =&amp;gt; sub { die &amp;quot;Foo::Bar could not be loaded&amp;quot; }
));
use_ok(&#39;Foo::Bar&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;actually gives the illusion that the &lt;code&gt;Foo::Bar&lt;/code&gt; module failed to load regardless of whether the user has it installed. These kinds of edge cases can be very difficult to test, but &lt;code&gt;Test::MockObject&lt;/code&gt; simplifies them greatly.&lt;/p&gt;

&lt;p&gt;But wait, that&amp;rsquo;s not all.&lt;/p&gt;

&lt;p&gt;After your tests have run using your mock objects, it is possible to inspect the methods called on them and query the order of their calls. You can even inspect the arguments passed into these methods. There several methods for this, so I refer you to the POD documentation of &lt;code&gt;Test::MockObject&lt;/code&gt; for details.&lt;/p&gt;

&lt;h3 id=&#34;the-solution&#34;&gt;The Solution&lt;/h3&gt;

&lt;p&gt;I designed each use case to illustrate a different capability of &lt;code&gt;Test::MockObject&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;User does not have Geo::IP installed.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Test::More tests =&amp;gt; 4;
use Test::MockObject;

my $mock = Test::MockObject-&amp;gt;new();
$mock-&amp;gt;fake_module(&#39;Geo::IP&#39; =&amp;gt; (
    &#39;import&#39; =&amp;gt; sub { die &amp;quot;Could not load Geo::IP&amp;quot; },
));

use_ok(&#39;Site::Member&#39;);

my $u = Site::Member-&amp;gt;new();
isa_ok($u, &#39;Site::Member&#39;);

my $warning;
local $SIG{__WARN__} = sub { $warning = shift };

ok(!defined($u-&amp;gt;city()), &#39;... this should return undef&#39;);
like($warning, 
        qr/^You must have Geo\:\:IP installed for this feature/, 
        &#39;... and we should have our warning&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This use case illustrates the use of &lt;code&gt;Test::MockObject&lt;/code&gt; to mock the failure of the loading of an optional resource, which in this case is the &lt;code&gt;Geo::IP&lt;/code&gt; module.&lt;/p&gt;

&lt;p&gt;The sample code attempts to load &lt;code&gt;Geo::IP&lt;/code&gt; by calling &lt;code&gt;eval &amp;quot;use Geo::IP&amp;quot;&lt;/code&gt;. Because &lt;code&gt;use&lt;/code&gt; always calls a module&amp;rsquo;s &lt;code&gt;import&lt;/code&gt; method, it is possible to exploit this and mock a &lt;code&gt;Geo::IP&lt;/code&gt; load failure. This is easy to accomplish by using the &lt;code&gt;fake_module&lt;/code&gt; method and making the &lt;code&gt;import&lt;/code&gt; method die. This then triggers the warning code in the &lt;code&gt;city&lt;/code&gt; method, which the &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; handler captures into &lt;code&gt;$warning&lt;/code&gt; for a later test.&lt;/p&gt;

&lt;p&gt;This is an example of a failure edge case which would be difficult to test without &lt;code&gt;Test::MockObject&lt;/code&gt; because it requires control of the Perl libraries installed. Testing this without &lt;code&gt;Test::MockObject&lt;/code&gt; would require altering the &lt;code&gt;@INC&lt;/code&gt; in subtle ways or mocking a &lt;code&gt;Geo::IP&lt;/code&gt; package of your own. &lt;code&gt;Test::MockObject&lt;/code&gt; does that for you, so why bother to re-invent a wheel if you don&amp;rsquo;t need to?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;User has &lt;code&gt;Geo::IP&lt;/code&gt; installed but does not have the city data.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Test::More tests =&amp;gt; 3;
use Test::Exception;
use Test::MockObject;

my $mock = Test::MockObject-&amp;gt;new();
$mock-&amp;gt;fake_module(&#39;Geo::IP&#39; =&amp;gt; (
    &#39;open&#39;           =&amp;gt; sub { undef },
    &#39;GEOIP_STANDARD&#39; =&amp;gt; sub { 0 }
));

use_ok(&#39;Site::Member&#39;);

my $u = Site::Member-&amp;gt;new();
isa_ok($u, &#39;Site::Member&#39;);

$u-&amp;gt;ip_address(&#39;64.40.146.219&#39;);

throws_ok {
    $u-&amp;gt;city()
} qr/Could not create a Geo\:\:IP object/, &#39;... got the error we expected&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This next use case illustrates the use of &lt;code&gt;Test::MockObject&lt;/code&gt; to mock a dependency relationship, in particular the failure case where &lt;code&gt;Geo::IP&lt;/code&gt; cannot find the specified database file.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Geo::IP&lt;/code&gt; follows the common Perl idiom of returning &lt;code&gt;undef&lt;/code&gt; if the object constructor fails. The example code tests for this case and throws an exception if it comes up. Testing for this failure uses the &lt;code&gt;fake_module&lt;/code&gt; method again to hijack &lt;code&gt;Geo::IP&lt;/code&gt; and install a mocked version of its &lt;code&gt;open&lt;/code&gt; method (the code also fakes the &lt;code&gt;GEOIP_STANDARD&lt;/code&gt; constant here). The mocked &lt;code&gt;open&lt;/code&gt; simply returns &lt;code&gt;undef&lt;/code&gt; which will create the proper conditions to trigger the exception in the example code. The exception is then caught using the &lt;code&gt;throws_ok&lt;/code&gt; method of the &lt;a href=&#34;https://metacpan.org/pod/Test::Exception&#34;&gt;Test::Exception&lt;/a&gt; module.&lt;/p&gt;

&lt;p&gt;This example illustrates that it is still possible to mock objects even if your code is not in the position to pass in a mocked instance itself. Again, to test this without using &lt;code&gt;Test::MockObject&lt;/code&gt; would require control of the outside environment (the &lt;code&gt;Geo::IP database&lt;/code&gt; file), or in some way having control over where &lt;code&gt;Geo::IP&lt;/code&gt; looks for the database file. While well-written and well-architected code would probably allow you to alter the database file path and therefore test this without using mock objects, the mock object version makes no such assumptions and therefore works the same in either case.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;User has &lt;code&gt;Geo::IP&lt;/code&gt; and the Geo-IP city data installed correctly.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Test::More tests =&amp;gt; 7;
use Test::MockObject;

my $mock = Test::MockObject-&amp;gt;new();
$mock-&amp;gt;fake_module(&#39;Geo::IP&#39; =&amp;gt; (
    &#39;open&#39;           =&amp;gt; sub { $mock },
    &#39;GEOIP_STANDARD&#39; =&amp;gt; sub { 0 }
));

my $mock_record = Test::MockObject-&amp;gt;new();
$mock_record-&amp;gt;set_always(&#39;city&#39;, &#39;New York City&#39;);

$mock-&amp;gt;set_always(&#39;record_by_addr&#39;, $mock_record);

use_ok(&#39;Site::Member&#39;);

my $u = Site::Member-&amp;gt;new();
isa_ok($u, &#39;Site::Member&#39;);

$u-&amp;gt;ip_address(&#39;64.40.146.219&#39;);

is($u-&amp;gt;city(), &#39;New York City&#39;, &#39;... got the right city&#39;);

cmp_ok($mock-&amp;gt;call_pos(&#39;record_by_addr&#39;), &#39;==&#39;, 0,
        &#39;... our mock object was called&#39;);
is_deeply(
        [ $mock-&amp;gt;call_args(0) ],
        [ $mock, &#39;64.40.146.219&#39; ],
        &#39;... our mock was called with the right args&#39;);

cmp_ok($mock_record-&amp;gt;call_pos(&#39;city&#39;), &#39;==&#39;, 0,
        &#39;... our mock record object was called&#39;);
is_deeply(
        [ $mock_record-&amp;gt;call_args(0) ],
        [ $mock_record ],
        &#39;... our mock record was called with the right args&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This next case illustrates a success case, where &lt;code&gt;Geo::IP&lt;/code&gt; finds the database file it wants and returns the expected results.&lt;/p&gt;

&lt;p&gt;Once again, the &lt;code&gt;fake_module&lt;/code&gt; method of &lt;code&gt;Test::MockObject&lt;/code&gt; mocks &lt;code&gt;Geo::IP&lt;/code&gt;&amp;rsquo;s &lt;code&gt;open&lt;/code&gt; method, this time returning the &lt;code&gt;$mock&lt;/code&gt; instance itself. The code creates another mock object, this time for the &lt;code&gt;Geo::IP::Record&lt;/code&gt; instance which &lt;code&gt;Geo::IP&lt;/code&gt;&amp;rsquo;s &lt;code&gt;record_by_addr&lt;/code&gt; returns. &lt;code&gt;Test::MockObject&lt;/code&gt;&amp;rsquo;s &lt;code&gt;set_always&lt;/code&gt; method mocks the &lt;code&gt;city&lt;/code&gt; method for the &lt;code&gt;$mock_record&lt;/code&gt; instance. After this, &lt;code&gt;Geo::IP&lt;/code&gt;&amp;rsquo;s &lt;code&gt;record_by_addr&lt;/code&gt; is mocked to return the &lt;code&gt;$mock_record&lt;/code&gt; instance. With all of these mocks in place, the tests then run. After that, inspecting the mock objects ensures that the code called the correct methods on the mocked objects in the correct order and with the correct arguments.&lt;/p&gt;

&lt;p&gt;This example illustrates testing success without needing to worry about the existence of an outside dependency. &lt;code&gt;Test::MockObject&lt;/code&gt; supports taking this test one step further and providing methods for inspecting the details of the interaction between the example code and that of the mocked &lt;code&gt;Geo::IP&lt;/code&gt; module. Accomplishing this test without &lt;code&gt;Test::MockObject&lt;/code&gt; would be almost impossible given the lack of control over the &lt;code&gt;Geo::IP&lt;/code&gt; module and its internals.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Mock objects can seem complex and overly abstract at first, but once grasped they can be a simple, clean way to make hard things easy. I hope to have shown how creating simple and minimal mock object with &lt;code&gt;Test::MockObject&lt;/code&gt; can help in testing cases which might be difficult using more traditional means.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

