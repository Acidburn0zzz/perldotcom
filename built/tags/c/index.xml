<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/c/</link>
    <description>Recent content in C on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 27 Oct 2019 12:07:00 +0000</lastBuildDate>
    <atom:link href="/tags/c/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>My Perl Wishlist: Invariant Sigils (Part 1)</title>
      <link>http://localhost:1313/article/my-perl-wishlist-invariant-sigils-part-1/</link>
      <pubDate>Sun, 27 Oct 2019 12:07:00 +0000</pubDate>
      
      <guid>http://localhost:1313/article/my-perl-wishlist-invariant-sigils-part-1/</guid>
      <description>

&lt;p&gt;Pop quiz!  Q: What was my mistake in this line?&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;is %HASH{answer}, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;forty-two&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;%HASH properly filled&amp;#39;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A: I had the answer right, but I messed up the sigil on &lt;code&gt;HASH&lt;/code&gt;.  It
should be:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;is $HASH{answer}, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;forty-two&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;%HASH properly filled&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;#  ^ $, not %&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Unfortunately, on Perl v5.20+, both statements work the same way!  I
didn&amp;rsquo;t catch the problem until I shipped this code and
&lt;a href=&#34;http://matrix.cpantesters.org/?dist=vars-i+1.08-TRIAL&#34;&gt;cpantesters&lt;/a&gt;
showed me my mistake.  It was an easy fix, but it reminded me that Perl&amp;rsquo;s
&lt;a href=&#34;http://modernperlbooks.com/books/modern_perl/chapter_03.html#variablenamesandsigils&#34;&gt;variant sigils&lt;/a&gt;
can trip up programmers at any level.  If I could change one thing about
Perl 5, I would change to invariant sigils.&lt;/p&gt;

&lt;h2 id=&#34;the-current-situation&#34;&gt;The current situation&lt;/h2&gt;

&lt;p&gt;In Perl, the sigil tells you
&lt;a href=&#34;https://perldoc.perl.org/perlintro.html#Perl-variable-types&#34;&gt;how many things to expect&lt;/a&gt;.
Scalars such as &lt;code&gt;$foo&lt;/code&gt; are single values.  Any single value in an array
&lt;code&gt;@foo&lt;/code&gt; or hash &lt;code&gt;%foo&lt;/code&gt;, since it is only one thing,
&lt;a href=&#34;https://perldoc.perl.org/perldata.html#Variable-names&#34;&gt;also uses &lt;code&gt;$&lt;/code&gt;&lt;/a&gt;,
so &lt;code&gt;$foo&lt;/code&gt;, &lt;code&gt;@foo&lt;/code&gt;, and &lt;code&gt;%foo&lt;/code&gt; could all refer to different pieces of the
same variable &amp;mdash; or to different variables.
This technique of &amp;ldquo;variant sigils&amp;rdquo; works, but confuses
new Perl users and tripped up yours truly.  To know what you
are accessing in an array or hash, you have to look at both the sigil
and the brackets.  As a reminder:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Sigil&lt;/th&gt;
&lt;th&gt;No brackets&lt;/th&gt;
&lt;th&gt;&lt;code&gt;[ ]&lt;/code&gt; (array access)&lt;/th&gt;
&lt;th&gt;&lt;code&gt;{ }&lt;/code&gt; (hash access)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;$z&lt;/code&gt;: a scalar, i.e., a single value&lt;/td&gt;
&lt;td&gt;&lt;code&gt;$z[0]&lt;/code&gt;: the first element of array &lt;code&gt;@z&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;$z{0}&lt;/code&gt;: the value in hash &lt;code&gt;%z&lt;/code&gt; at key &lt;code&gt;&amp;quot;0&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@z&lt;/code&gt;: An array, i.e., a list of value(s)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@z[0, 1]&lt;/code&gt;: the list &lt;code&gt;($z[0], $z[1])&lt;/code&gt; of two elements from &lt;code&gt;@z&lt;/code&gt; (an &amp;ldquo;array slice&amp;rdquo;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@z{0, &amp;quot;foo&amp;quot;}&lt;/code&gt;: the list &lt;code&gt;($z{0}, $z{foo})&lt;/code&gt; of two elements from hash &lt;code&gt;%z&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%z&lt;/code&gt;: A hash, i.e., a list of key/value pair(s)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%z[0, 1]&lt;/code&gt;: the list &lt;code&gt;(0, $z[0], 1, $z[1])&lt;/code&gt; of keys and two values from array &lt;code&gt;@z&lt;/code&gt; (a &amp;ldquo;hash slice&amp;rdquo;)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%z{0, &amp;quot;foo&amp;quot;}&lt;/code&gt;: the list &lt;code&gt;(&amp;quot;0&amp;quot;, $z{0}, &amp;quot;foo&amp;quot;, $z{foo})&lt;/code&gt; of keys and values from hash &lt;code&gt;%z&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;make-the-sigils-part-of-the-name&#34;&gt;Make the sigils part of the name&lt;/h2&gt;

&lt;p&gt;To save myself from repeating my errors, I&amp;rsquo;d like the sigil to be part of a
variable&amp;rsquo;s name.  This is not a new idea; scalars work this way in Perl, bash,
and &lt;a href=&#34;https://docs.perl6.org/language/101-basics#sigil_and_identifier&#34;&gt;Raku&lt;/a&gt;
(&lt;a href=&#34;https://github.com/perl6/problem-solving/blob/master/solutions/language/Path-to-Raku.md&#34;&gt;formerly Perl 6&lt;/a&gt;).
That would make the above table look like:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Sigil&lt;/th&gt;
&lt;th&gt;No brackets&lt;/th&gt;
&lt;th&gt;&lt;code&gt;[ ]&lt;/code&gt; (array access)&lt;/th&gt;
&lt;th&gt;&lt;code&gt;{ }&lt;/code&gt; (hash access)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;$z&lt;/code&gt;: a scalar, i.e., a single value&lt;/td&gt;
&lt;td&gt;&lt;code&gt;$z[0]&lt;/code&gt;: N/A&lt;/td&gt;
&lt;td&gt;&lt;code&gt;$z{0}&lt;/code&gt;: N/A&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@z&lt;/code&gt;: An array, i.e., a list of value(s)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@z[0]&lt;/code&gt;: the first element of &lt;code&gt;@z&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@z{0}&lt;/code&gt;: N/A&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%z&lt;/code&gt;: A hash, i.e., a list of key/value pair(s)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%z[0]&lt;/code&gt;: N/A&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%z{0}&lt;/code&gt;: the value in hash &lt;code&gt;%z&lt;/code&gt; at key &lt;code&gt;0&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Simpler!  Any reference to &lt;code&gt;@z&lt;/code&gt; would always be doing &lt;em&gt;something&lt;/em&gt; with
the array named &lt;code&gt;@z&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;but-what-about-slices&#34;&gt;But what about slices?&lt;/h2&gt;

&lt;p&gt;Slices such as &lt;code&gt;@z[0,1]&lt;/code&gt; and &lt;code&gt;%z{qw(hello there)}&lt;/code&gt; return multiple
values from an array or hash.  If sigils &lt;code&gt;@&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt; are no longer
available for slicing, we need an alternative.
The Perl family currently provides two models: postfix dereferencing
(&amp;ldquo;postderef&amp;rdquo;) syntax and postfix adverbs.&lt;/p&gt;

&lt;p&gt;Perl v5.20+ support
&lt;a href=&#34;https://www.effectiveperlprogramming.com/2014/09/use-postfix-dereferencing/&#34;&gt;postderef&lt;/a&gt;,
which gives us one option.  Postderef separates the name from the slice:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Valid Perl v5.20+&lt;/span&gt;
$hashref&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{a};      &lt;span style=&#34;color:#75715e&#34;&gt;# Scalar, element at index &amp;#34;a&amp;#34; of the hash pointed to by $hashref&lt;/span&gt;
$hashref&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;@{a};     &lt;span style=&#34;color:#75715e&#34;&gt;# List including the &amp;#34;a&amp;#34; element of the hash pointed to by $hashref&lt;/span&gt;
$hashref&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;%{a};     &lt;span style=&#34;color:#75715e&#34;&gt;# List including the key &amp;#34;a&amp;#34; and the &amp;#34;a&amp;#34; element of the hash pointed to by $hashref&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The type of slice comes after the reference, instead of as a sigil
before the reference.  With non-references, that idea would give us slice
syntax such as &lt;code&gt;@array@[1,2,3]&lt;/code&gt; or &lt;code&gt;%hash%{a}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Raku gives us another option: &amp;ldquo;adverbs&amp;rdquo; such as
&lt;a href=&#34;https://docs.perl6.org/language/subscripts#:kv&#34;&gt;&lt;code&gt;:kv&lt;/code&gt;&lt;/a&gt;.  For example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl6&#34; data-lang=&#34;perl6&#34;&gt;# Valid Raku
%hash{&amp;#34;a&amp;#34;}          # Single value, element at index &amp;#34;a&amp;#34; of %hash
%hash{&amp;#34;a&amp;#34;}:v;       # The same --- just the value
%hash{&amp;#34;a&amp;#34;}:kv;      # The list including key &amp;#34;a&amp;#34; and the value of the &amp;#34;a&amp;#34; element of %hash&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The adverb (e.g., &lt;code&gt;:kv&lt;/code&gt;) goes in postfix position, immediately
after the brackets or braces.  Following this model,
slices would look like &lt;code&gt;@array[1,2,3]:l&lt;/code&gt; or &lt;code&gt;%hash{a}:kv&lt;/code&gt;.  (For clarity,
I propose &lt;code&gt;:l&lt;/code&gt;, as in &lt;strong&gt;l&lt;/strong&gt;ist, instead of Raku&amp;rsquo;s &lt;code&gt;:v&lt;/code&gt;.  Raku&amp;rsquo;s &lt;code&gt;:v&lt;/code&gt; can return
a scalar or a list.)&lt;/p&gt;

&lt;p&gt;So, the choices I see are (postderef-inspired / Raku-inspired):&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;What you want&lt;/th&gt;
&lt;th&gt;No subscript&lt;/th&gt;
&lt;th&gt;&lt;code&gt;[ ]&lt;/code&gt; access&lt;/th&gt;
&lt;th&gt;&lt;code&gt;{ }&lt;/code&gt; access&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Scalar&lt;/td&gt;
&lt;td&gt;&lt;code&gt;$z&lt;/code&gt;: a scalar, i.e., a single value&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@z[0]&lt;/code&gt;: a single value from an array&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%z{0}&lt;/code&gt;: the value in hash &lt;code&gt;%z&lt;/code&gt; at key &lt;code&gt;&amp;quot;0&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;List of values&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@z&lt;/code&gt;: an array, i.e., a list of value(s)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@z@[0, 1]&lt;/code&gt; / &lt;code&gt;@z[0, 1]:l&lt;/code&gt;: the list currently written &lt;code&gt;($z[0], $z[1])&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%z@{0, &amp;quot;foo&amp;quot;}&lt;/code&gt; / &lt;code&gt;%z{0, &amp;quot;foo&amp;quot;}:l&lt;/code&gt;: the list currently written &lt;code&gt;($z{0}, $z{foo})&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;List of key/value pairs&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%z&lt;/code&gt;: a hash, i.e., a list of key/value pair(s)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@z%[0, 1]&lt;/code&gt; / &lt;code&gt;@z[0, 1]:kv&lt;/code&gt;: the list currently written &lt;code&gt;(0, $z[0], 1, $z[1])&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;%z%{0, &amp;quot;foo&amp;quot;}&lt;/code&gt; / &lt;code&gt;%z{0, &amp;quot;foo&amp;quot;}:kv&lt;/code&gt;: the list currently written &lt;code&gt;(&amp;quot;0&amp;quot;, $z{0}, &amp;quot;foo&amp;quot;, $z{foo})&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;you-can-t-always-get-what-you-want&#34;&gt;You can&amp;rsquo;t always get what you want&lt;/h2&gt;

&lt;p&gt;I prefer the adverb syntax.  It is easy to read, and it draws on
all the expertise that has gone into the design of Raku.
However, my preference has to be implementable.
I&amp;rsquo;m not convinced that it is without major surgery.&lt;/p&gt;

&lt;p&gt;The Perl parser decides how to interpret what is inside the brackets
depending on the context provided by the slice.
The parser interprets the &lt;code&gt;...&lt;/code&gt; in &lt;code&gt;@foo[...]&lt;/code&gt; as
a list (&lt;a href=&#34;https://github.com/Perl/perl5/blob/c58ad1f93e9ad7834d3735683462c07119aa87f5/perly.y#L1143-L1148&#34;&gt;ref&lt;/a&gt;).
In &lt;code&gt;$foo[...]&lt;/code&gt;, the parser sees the &lt;code&gt;...&lt;/code&gt; as a scalar expression
(&lt;a href=&#34;https://github.com/Perl/perl5/blob/c58ad1f93e9ad7834d3735683462c07119aa87f5/perly.y#L958-L960&#34;&gt;ref&lt;/a&gt;).
For any slice syntax, the Perl parser needs to know the desired
type of result while parsing the subscript expression.  The adverb form,
unfortunately, leaves the parser guessing until after the subscript
is parsed.&lt;/p&gt;

&lt;p&gt;You can, in fact, hack the Perl parser to save the subscript
until it sees a postfix adverb.  The parser can then apply the correct
context.  I wrote a
&lt;a href=&#34;https://github.com/Perl/perl5/compare/9786385e68f7f14df6f4dd0f04d2c72c0d9a2511...cxw42:3cd904788536b445c9c3abe9b469e1b569942051&#34;&gt;proof-of-concept&lt;/a&gt;
for &lt;code&gt;@arr[expr]:v&lt;/code&gt;.  It doesn&amp;rsquo;t execute any code, but it does parse
a postfix-adverb slice without crashing!  However, while writing that code,
I ran across a surprise: new syntax isn&amp;rsquo;t tied to a &lt;code&gt;use v5.xx&lt;/code&gt;
directive.&lt;/p&gt;

&lt;p&gt;It turns out the Perl parser lets code written against any Perl version
use the latest syntax.  Both of the following command lines work on Perl v5.30:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ perl -Mstrict -Mwarnings -E &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;my $z; $z-&amp;gt;@* = 10..20&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#                           ^ -E: use all the latest features
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;$ perl -Mstrict -Mwarnings -e &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;my $z; $z-&amp;gt;@* = 10..20&amp;#39;&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;# (!!!)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;#                           ^ -e: not the latest features&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The second command line does not &lt;code&gt;use v5.30&lt;/code&gt;, so you can&amp;rsquo;t use &lt;code&gt;say&lt;/code&gt;
(introduced in v5.10).  However, you can use postderef (from v5.20)!&lt;/p&gt;

&lt;p&gt;Because the parser lets old programs use new syntax, any proposed addition
to Perl&amp;rsquo;s syntax has to be meaningless in all previous Perl versions.
A postfix adverb fails this test.  For example, the following is a valid
Perl program:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;kv&lt;/span&gt; { &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;kv&amp;#34;&lt;/span&gt; }
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @arr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; ? @arr[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]:kv;
        &lt;span style=&#34;color:#75715e&#34;&gt;# ^^^^^^^^^^^^ valid Perl 5 syntax, but not a slice :(&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\n&amp;#34;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;My preferred slice syntax could change the meaning of existing programs,
so it looks like I can&amp;rsquo;t get my first choice.&lt;/p&gt;

&lt;h2 id=&#34;next-steps&#34;&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;This is not the end of the story!  In Part 2, I will dig deeper into
Perl&amp;rsquo;s parser and tokenizer.  I will share some surprises I discovered
while investigating postderef.  I will then describe a possible path
to invariant sigils and the simplicity they can provide.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The road to a 55x speedup with XS</title>
      <link>http://localhost:1313/article/the-road-to-a-55x-speedup-with-xs/</link>
      <pubDate>Tue, 14 Jun 2016 20:54:51 +0000</pubDate>
      
      <guid>http://localhost:1313/article/the-road-to-a-55x-speedup-with-xs/</guid>
      <description>

&lt;p&gt;Lately my client has been concerned with improving their application speed, so naturally I started to think about XS, Perl&amp;rsquo;s C macro language. With XS you can write C code and call it from Perl.&lt;/p&gt;

&lt;p&gt;To test the waters I wrote a simple URI encoder/decoder in C and with some trial-and-error managed to make &lt;a href=&#34;https://metacpan.org/pod/URI::Encode::XS&#34;&gt;URI::Encode::XS&lt;/a&gt;, a module that used it. &amp;ldquo;This is easy!&amp;rdquo; I thought and excitedly typed out a benchmarking &lt;a href=&#34;https://github.com/dnmfarrell/URI-Encode-XS/blob/master/bench&#34;&gt;script&lt;/a&gt;. I benchmarked my module against &lt;a href=&#34;https://metacpan.org/pod/URI::Escape&#34;&gt;URI::Escape&lt;/a&gt; a venerable but rather slow &lt;em&gt;pure-Perl&lt;/em&gt; URI encoder/decoder. You can imagine how crestfallen I was when I read the benchmark results to find that all of my effort only netted a 20% speedup. I wondered if Perl&amp;rsquo;s string routines are so fast they&amp;rsquo;re hard to improve upon.&lt;/p&gt;

&lt;h3 id=&#34;renewed-hope&#34;&gt;Renewed hope&lt;/h3&gt;

&lt;p&gt;Enter &lt;a href=&#34;https://metacpan.org&#34;&gt;URI::XSEscape&lt;/a&gt;, a &amp;ldquo;quick and dirty&amp;rdquo; (the authors&amp;rsquo; words) XS implementation of URI::Escape. It was uploaded to CPAN last month. You can see the authors&amp;rsquo; &lt;a href=&#34;https://metacpan.org/pod/URI::XSEscape#BENCHMARKS&#34;&gt;benchmarks&lt;/a&gt; for yourself, but in my testing it appeared to be about 18.5 times faster than URI::Escape. That&amp;rsquo;s not a misprint - on my laptop it encoded 2.75m strings per second, compared to 138k for URI::Escape. So how did they do it?&lt;/p&gt;

&lt;p&gt;First let&amp;rsquo;s look at my naive C encode implementation:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;void &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;uri_encode (char &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;uri, const char &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;special_chars, char &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;buffer)
{
  int i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
  &lt;span style=&#34;color:#e6db74&#34;&gt;/* \0 is null, end of the string */&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (uri[i] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;)
  {
    int encode_char &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    int j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (special_chars[j] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;)
    {
      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (uri[i] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; special_chars[j])
      {
        &lt;span style=&#34;color:#e6db74&#34;&gt;/* do not encode char as it is in the special_chars set */&lt;/span&gt;
        encode_char &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        break;
      }
      j&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (encode_char &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
    {
      char code[&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;];
      sprintf(code, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%%%02X&amp;#34;&lt;/span&gt;, uri[i]);
      strcat(buffer, code);
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
    {
      char code[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;];
      code[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; uri[i];
      code[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;;
      strcat(buffer, code);
    }
    i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically what this does is loop through the &lt;code&gt;uri&lt;/code&gt; string, looking characters that are in the &lt;code&gt;special_chars&lt;/code&gt; string, and if it finds a match, it percent encodes the character with &lt;code&gt;sprintf&lt;/code&gt; and appends the result to &lt;code&gt;buffer&lt;/code&gt; which is the encoded string. Compare this with the encode function from &lt;code&gt;URI::XSEscape&lt;/code&gt; (I&amp;rsquo;ve simplified it slightly):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;Buffer&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; uri_encode(Buffer&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; src, int length,
                   Buffer&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; tgt)
{
    int s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; src&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;pos;
    int t &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; tgt&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;pos;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (s &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; (src&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;pos &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; length)) {
        unsigned char u &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (unsigned char) src&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;data[s];
        char&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; v &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; uri_encode_tbl[(int)u];

        &lt;span style=&#34;color:#f92672&#34;&gt;/*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; current source character doesn&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;t need to be encoded,
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;           just copy it to target*/
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        if (!v) {
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;            tgt-&amp;gt;data[t++] = src-&amp;gt;data[s++];
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;            continue;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        }
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        /* copy encoded character from our table */
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        tgt-&amp;gt;data[t+0] = &amp;#39;&lt;/span&gt;%&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;#39;;&lt;/span&gt;
        tgt&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;data[t&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; v[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;];
        tgt&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;data[t&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; v[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];

        &lt;span style=&#34;color:#f92672&#34;&gt;/*&lt;/span&gt; we used up &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; characters (%XY) in target
         &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; character from source &lt;span style=&#34;color:#f92672&#34;&gt;*/&lt;/span&gt;
        t &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;;
        &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;s;
    }
    &lt;span style=&#34;color:#e6db74&#34;&gt;/* null-terminate target and return src as was left */&lt;/span&gt;
    src&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;pos &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s;
    tgt&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;pos &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; t;
    buffer_terminate(tgt);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; src;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This code loops through the input string but instead of comparing the current character to another string of special characters, it does a table lookup. This is much faster than looping through another string. Note how it doesn&amp;rsquo;t use &lt;code&gt;sprintf&lt;/code&gt; either - all the hex codes are pre-computed in &lt;code&gt;uri_encode_tbl&lt;/code&gt;. Finally, instead of creating a new string and concatenating it to the output string, this code simply copies the output directly to the output string&amp;rsquo;s memory location.&lt;/p&gt;

&lt;p&gt;This code also avoid a subtle bug with my implementation: Perl strings can contain null characters, but in C null is used to terminate strings. Because URI::XSEscape&amp;rsquo;s encode function accepts a length argument, it can encode strings will nulls and my version can&amp;rsquo;t.&lt;/p&gt;

&lt;h3 id=&#34;going-faster&#34;&gt;Going faster&lt;/h3&gt;

&lt;p&gt;At this point I updated the encode/decode functions in URI::Encode::XS to be table based like URI::XSEscape and saw huge gains in performance, making URI::Encode::XS about 25 times faster than URI::Escape (URI::Encode::XS doesn&amp;rsquo;t support user-defined escape values, so it&amp;rsquo;s simpler than URI::XSEscape). I thought a 25x improvement was as good as it got, and was about done with the module, when I was contacted by &lt;a href=&#34;https://metacpan.org/author/CHANSEN&#34;&gt;Christian Hansen&lt;/a&gt; (author of &lt;a href=&#34;https://metacpan.org/release/Time-Moment&#34;&gt;Time::Moment&lt;/a&gt;). Christian overhauled my simple XS code to make it safer and faster. This is what became of the &lt;code&gt;uri_encode&lt;/code&gt; C function:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;size_t uri_encode (const char &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;src, const size_t len, char &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;dst)
{
  size_t i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len
  {
    const char &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; code &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; uri_encode_tbl[ (unsigned char)src[i] ];
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (code)
    {
      memcpy(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;dst[j], code, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;);
      j &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
    {
      dst[j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; src[i];
      j&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
    }
    i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
  }
  dst[j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; j;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This version looks up the character value in a pre-computed table and then uses &lt;code&gt;memcpy&lt;/code&gt; to append it to the output string (avoiding 3 separate assignments). It also returns the length of encoded string, which is useful. After Christian&amp;rsquo;s optimizations, my benchmarking &lt;a href=&#34;https://github.com/dnmfarrell/URI-Encode-XS/blob/master/bench&#34;&gt;script&lt;/a&gt; showed URI::Encode::XS&amp;rsquo;s encoding function to be 55 times faster than URI::Escape (about 8m encoded strings per second). Much of the gains came from optimizing the &lt;a href=&#34;https://github.com/dnmfarrell/URI-Encode-XS/blob/df8009e9d7af4cf243fa29ca8aaa23982feeba58/XS.xs#L143&#34;&gt;xsub&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;the-power-of-c-the-pleasure-of-perl&#34;&gt;The power of C, the pleasure of Perl&lt;/h3&gt;

&lt;p&gt;To me the most magical thing about XS code is you call it from Perl:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; URI::Encode::XS &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;uri_encode&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $encoding &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; uri_encode($some_string); &lt;span style=&#34;color:#75715e&#34;&gt;# super fast&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So the user has the convenience of writing Perl code, but the benefit of the faster implementation. Perl is already pretty fast, but there are certain operations that are expensive. If you work on a Perl application, how much faster would it be if you could make all of the bottlenecks 55 times faster?&lt;/p&gt;

&lt;h3 id=&#34;learning-xs&#34;&gt;Learning XS&lt;/h3&gt;

&lt;p&gt;If you&amp;rsquo;d like to learn more about XS, I&amp;rsquo;d strongly recommend this &lt;a href=&#34;http://world.std.com/~swmcd/steven/perl/pm/xs/intro/index.html&#34;&gt;series&lt;/a&gt; by Steven W McDougall. It&amp;rsquo;s the best introduction I know of.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/xsawyerx/xs-fun&#34;&gt;XS is Fun&lt;/a&gt; is a more modern introduction to XS programming that takes you through the steps of writing an XS module and importing a C library.&lt;/p&gt;

&lt;p&gt;Chapter 18 &amp;ldquo;Extending Perl: A First Course&amp;rdquo; in &lt;a href=&#34;http://shop.oreilly.com/product/9781565922204.do&#34;&gt;Advanced Perl Programming&lt;/a&gt; first edition has a good introduction to XS. It covers the most common macros for scalars, arrays and hashes which is useful (the second edition doesn&amp;rsquo;t cover XS). &lt;a href=&#34;https://www.manning.com/books/extending-and-embedding-perl&#34;&gt;Extending and Embedding Perl&lt;/a&gt; goes further, with several tutorials on the different ways to call and receive data from XS. Both books are a bit dated but I found them valuable and an easier read than the official docs.&lt;/p&gt;

&lt;p&gt;The official Perl documentation has useful reference sources: &lt;a href=&#34;https://perldoc.perl.org/perlxs.html&#34;&gt;perlxs&lt;/a&gt;, &lt;a href=&#34;https://perldoc.perl.org/perlapi.html&#34;&gt;perlapi&lt;/a&gt; and &lt;a href=&#34;https://perldoc.perl.org/perlxs.html&#34;&gt;perlguts&lt;/a&gt;. There is also &lt;a href=&#34;https://perldoc.perl.org/perlxs.html&#34;&gt;perlxstut&lt;/a&gt; but I would skip that in favor of the above resources.&lt;/p&gt;

&lt;p&gt;Several times I&amp;rsquo;ve found XS macros used in Perl code that are not explained in any documentation (e.g. &lt;code&gt;dXSTARG&lt;/code&gt;). In those cases it pays to have a copy of the Perl &lt;a href=&#34;https://www.perl.org/get.html&#34;&gt;source code&lt;/a&gt; - just grep the source and you&amp;rsquo;ll find its definition with a comment (typically in &lt;code&gt;pp.h&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&#34;a-note-on-the-benchmarks&#34;&gt;A note on the benchmarks&lt;/h3&gt;

&lt;p&gt;The benchmarks in this article were all run on my laptop, a Dell XPS 13 with 8GB RAM running Fedora 23. Different hardware will yield different results (Christian&amp;rsquo;s benchmark showed URI::Encode::XS to be 90x (!) faster than URI::Escape).&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/dnmfarrell/URI-Encode-XS/blob/master/bench&#34;&gt;script&lt;/a&gt; counts how many times each module can encode a string per second. But a string of a different length, or with a different number of reserved characters will yield a different benchmark. For example benchmarking an empty string shows URI::Encode::XS to be just 9x times faster on my laptop.&lt;/p&gt;

&lt;p&gt;The module versions were URI::Encode::XS v0.08 and URI::Escape v3.31. The Perl version was 5.22.&lt;/p&gt;

&lt;h3 id=&#34;thanks&#34;&gt;Thanks&lt;/h3&gt;

&lt;p&gt;A big thank you to Christian Hansen and Jesse DuMond for your help with URI::Encode::XS. The module would not be half of what it is without your contributions.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Why Not Translate Perl to C?</title>
      <link>http://localhost:1313/pub/2001/06/27/ctoperl.html/</link>
      <pubDate>Wed, 27 Jun 2001 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2001/06/27/ctoperl.html/</guid>
      <description>

&lt;p&gt;People often have the idea that automatically translating Perl to C and then compiling the C will make their Perl programs run faster, because &amp;ldquo;C is much faster than Perl.&amp;rdquo; This article explains why this strategy is unlikely to work.&lt;/p&gt;

&lt;h3 id=&#34;short-summary&#34;&gt;Short Summary&lt;/h3&gt;

&lt;p&gt;Your Perl program is being run by the Perl interpreter. You want a C program that does the same thing that your Perl program does. A C program to do what your Perl program does would have to do most of the same things that the Perl interpreter does when it runs your Perl program. There is no reason to think that the C program could do those things faster than the Perl interpreter does them, because the Perl interpreter itself is written in very fast C.&lt;/p&gt;

&lt;p&gt;Some detailed case studies follow.&lt;/p&gt;

&lt;h3 id=&#34;built-in-functions&#34;&gt;Built-In Functions&lt;/h3&gt;

&lt;p&gt;Suppose your program needs to split a line into fields, and uses the Perl &lt;code&gt;split&lt;/code&gt; function to do so. You want to compile this to C so it will be faster.&lt;/p&gt;

&lt;p&gt;This is obviously not going to work, because the &lt;code&gt;split&lt;/code&gt; function is already implemented in C. If you have the Perl source code, you can see the implementation of &lt;code&gt;split&lt;/code&gt; in the file &lt;code&gt;pp.c&lt;/code&gt;; it is in the function named &lt;code&gt;pp_split&lt;/code&gt;. When your Perl program uses &lt;code&gt;split&lt;/code&gt;, Perl calls this &lt;code&gt;pp_split&lt;/code&gt; function to do the splitting. &lt;code&gt;pp_split&lt;/code&gt; is written in C, and it has already been compiled to native machine code.&lt;/p&gt;

&lt;p&gt;Now, suppose you want to translate your Perl program to C. How will you translate your &lt;code&gt;split&lt;/code&gt; call? The only thing you can do is translate it to a call to the C &lt;code&gt;pp_split&lt;/code&gt; function, or some other equivalent function that splits. There is no reason to believe that any C implementation of &lt;code&gt;split&lt;/code&gt; will be faster than the &lt;code&gt;pp_split&lt;/code&gt; that Perl already has. Years of work have gone into making &lt;code&gt;pp_split&lt;/code&gt; as fast as possible.&lt;/p&gt;

&lt;p&gt;You can make the same argument for all of Perl&amp;rsquo;s other built-in functions, such as &lt;code&gt;join&lt;/code&gt;, &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;rand&lt;/code&gt; and &lt;code&gt;readdir&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So much for built-in functions.&lt;/p&gt;

&lt;h3 id=&#34;data-structures&#34;&gt;Data Structures&lt;/h3&gt;

&lt;p&gt;Why is Perl slow to begin with? One major reason is that its data structures are extremely flexible, and this flexibility imposes a speed penalty.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look in detail at an important example: strings. Consider this Perl code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        $x = &#39;foo&#39;;     
        $y = &#39;bar&#39;;
        $x .= $y;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is, we want to append &lt;code&gt;$y&lt;/code&gt; to the end of &lt;code&gt;$x&lt;/code&gt;. In C, this is extremely tricky. In C, you would start by doing something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        char *x = &amp;quot;foo&amp;quot;;
        char *y = &amp;quot;bar&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you have a problem. You would like to insert &lt;code&gt;bar&lt;/code&gt; at the end of the buffer pointed to by &lt;code&gt;x&lt;/code&gt;. But you can&amp;rsquo;t, because there is not enough room; &lt;code&gt;x&lt;/code&gt; only points to enough space for four characters, and you need space for seven. (C strings always have an extra &lt;code&gt;nul&lt;/code&gt; character on the end.) To append &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;, you must allocate a new buffer, and then arrange for &lt;code&gt;x&lt;/code&gt; to point to the new buffer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        char *tmp = malloc(strlen(x) + strlen(y) + 1);
        strcpy(tmp, x);
        strcat(tmp, y);
        x = tmp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works fine if &lt;code&gt;x&lt;/code&gt; is the only pointer to that particular buffer. But if some other part of the program also had a pointer to the buffer, this code does not work. Why not? Here&amp;rsquo;s the picture of what we did:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BEFORE:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2001_06_27_ctoperl/cbef.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Here &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt; are two variables that both contain pointers to the same buffer. We want to append &lt;code&gt;bar&lt;/code&gt; to the end of the string. But the C code we used above doesn&amp;rsquo;t quite work, because we allocated a new region of memory to hold the result, and then pointed &lt;code&gt;x&lt;/code&gt; to it:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AFTER &lt;code&gt;x = tmp&lt;/code&gt;:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2001_06_27_ctoperl/caft.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s tempting to think that we should just point &lt;code&gt;z&lt;/code&gt; to the new buffer also, but in practice this is impossible. The function that is doing the appending cannot know whether there is such a &lt;code&gt;z&lt;/code&gt;, or where it may be. There might be 100 variables like &lt;code&gt;z&lt;/code&gt; all pointing to the old buffer, and there is no good way to keep track of them so that they can all be changed when the array moves.&lt;/p&gt;

&lt;p&gt;Perl does support a transparent string append operation. Let&amp;rsquo;s see how this works. In Perl, a variable like &lt;code&gt;$x&lt;/code&gt; does not point directly at the buffer. Instead, it points at a structure called an SV. (&amp;lsquo;Scalar Value&amp;rsquo;) The SV has the pointer to the buffer, and also some other things that I do not show:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BEFORE &lt;code&gt;$x .= $y&lt;/code&gt;&lt;/strong&gt;
&lt;img src=&#34;http://localhost:1313/images/_pub_2001_06_27_ctoperl/pbef.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;When you ask Perl to append &lt;code&gt;bar&lt;/code&gt; to &lt;code&gt;$x&lt;/code&gt;, it follows the pointers and finds that there is not enough space in the buffer. So, just as in C, it allocates a new buffer and stores the result in the new buffer. Then it fixes the pointer in the SV to point to the new buffer, and it throws away the old buffer:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2001_06_27_ctoperl/paft.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$z&lt;/code&gt; have both changed. If there were any other variables sharing the SV, their values would have changed also. This technique is called &amp;ldquo;double indirection,&amp;lsquo;&amp;rdquo; and it is how Perl can support operations like &lt;code&gt;.=&lt;/code&gt;. A similar principle applies for arrays; this is how Perl can support the &lt;code&gt;push&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;The flexibility comes at a price: Whenever you want to use the value of &lt;code&gt;$x&lt;/code&gt;, Perl must follow two pointers to get the value: The first to find the SV structure, and the second to get to the buffer with the character data. This means that using a string in Perl takes at least twice as long as in C. In C, you follow just one pointer.&lt;/p&gt;

&lt;p&gt;If you want to compile Perl to C, you have a big problem. You would like to support operations like &lt;code&gt;.=&lt;/code&gt; and &lt;code&gt;push&lt;/code&gt;, but C does not support these very well. There are only three solutions:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Don&amp;rsquo;t support &lt;code&gt;.=&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This is a bad solution, because after you disallow all the Perl operations like &lt;code&gt;.=&lt;/code&gt; and &lt;code&gt;push&lt;/code&gt; what you have left is not very much like Perl; it is much more like C, and then you might as well just write the program in C in the first place.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Do something extremely clever&lt;/p&gt;

&lt;p&gt;Cleverness is in short supply this month. &lt;code&gt;:)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use a double-indirection technique in the compiled C code&lt;/p&gt;

&lt;p&gt;This works, but the resulting C code will be slow, because you will have to traverse twice as many pointers each time you want to look up the value of a variable. But that is why Perl is slow! Perl is already doing the double-indirection lookup in C, and the code to do this has already been compiled to native machine code.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So again, it&amp;rsquo;s not clear that you are going to get any benefit from translating Perl to C. The slowness of Perl comes from the flexibility of the data structures. The code to manipulate these structures is already written in C. If you translate a Perl program to C, you have the choice of throwing away the flexibility of the data structure, in which case you are now writing C programs with C structures, or keeping the flexibility with the same speed penalty. You probably cannot speed up the data structures, because if anyone knew how to make the structures faster and still keep them flexible, they would already have made those changes in the C code for Perl itself.&lt;/p&gt;

&lt;h3 id=&#34;possible-future-work&#34;&gt;Possible Future Work&lt;/h3&gt;

&lt;p&gt;It should now be clear that although it might not be hard to translate Perl to C, programs probably will not be faster as a result.&lt;/p&gt;

&lt;p&gt;However, it&amp;rsquo;s possible that a sufficiently clever person could make a Perl-to-C translator that produced faster C code. The programmer would need to give hints to the translator to say how the variables were being used. For example, suppose you have an array &lt;code&gt;@a&lt;/code&gt;. With such an array, Perl is ready for anything. You might do &lt;code&gt;$a[1000000] = &#39;hello&#39;;&lt;/code&gt; or &lt;code&gt;$a[500] .= &#39;foo&#39;;&lt;/code&gt; or &lt;code&gt;$a[500] /= 17;&lt;/code&gt;. This flexibility is expensive. But suppose you know that this array will only hold integers and there will never be more than 1,000 integers. You might tell the translator that, and then instead of producing C code to manage a slow Perl array, the translator can produce&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;int a[&lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;];&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and use a fast C array of machine integers.&lt;/p&gt;

&lt;p&gt;To do this, you have to be very clever and you have to think of a way of explaining to the translator that &lt;code&gt;@a&lt;/code&gt; will never be bigger than 1,000 elements and will only contain integers, or a way for the translator to guess that just from looking at the Perl program.&lt;/p&gt;

&lt;p&gt;People are planning these features for Perl 6 right now. For example, Larry Wall, the author of Perl, plans that you will be able to declare a Perl array as&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; int @a is dim(&lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then a Perl-to-C translator (or Perl itself) might be able to use a fast C array of machine integers rather than a slow Perl array of SVs. If you are interested, you may want to join the perl6-internals mailing list.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pathologically Polluting Perl</title>
      <link>http://localhost:1313/pub/2001/02/inline.html/</link>
      <pubDate>Tue, 06 Feb 2001 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2001/02/inline.html/</guid>
      <description>

&lt;h3 id=&#34;pathologically-polluting-perl&#34;&gt;Pathologically Polluting Perl&lt;/h3&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Table of Contents&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;•&lt;a href=&#34;#inline%20in%20action%20%20simple%20examples%20in%20c&#34;&gt;Inline in Action - Simple examples in C&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#hello,%20world&#34;&gt;Hello, world&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#just%20another%20____%20hacker&#34;&gt;Just Another ____ Hacker&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#what%20about%20xs%20and%20swig&#34;&gt;What about XS and SWIG?&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#oneliners&#34;&gt;One-Liners&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#supported%20platforms%20for%20c&#34;&gt;Supported Platforms for C&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#the%20inline%20syntax&#34;&gt;The Inline Syntax&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#fine%20dining%20%20a%20glimpse%20at%20the%20c%20cookbook&#34;&gt;Fine Dining - A Glimpse at the C Cookbook&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#external%20libraries&#34;&gt;External Libraries&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#it%20takes%20all%20types&#34;&gt;It Takes All Types&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#some%20ware%20beyond%20the%20c&#34;&gt;Some Ware Beyond the C&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#see%20perl%20run.%20run%20perl,%20run!&#34;&gt;See Perl Run. Run, Perl, Run!&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#the%20future%20of%20inline&#34;&gt;The Future of Inline&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;br /&gt;
&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;No programming language is Perfect. Perl comes very close. &lt;strong&gt;P&lt;/strong&gt;! &lt;strong&gt;e&lt;/strong&gt;! &lt;strong&gt;r&lt;/strong&gt;! &lt;em&gt;l&lt;/em&gt;? :-( Not quite ``Perfect&amp;rdquo;. Sometimes it just makes sense to use another language for part of your work. You might have a stable, pre-existing code base to take advantage of. Perhaps maximum performance is the issue. Maybe you just ``know how to do it&amp;rdquo; that way. Or very likely, it&amp;rsquo;s a project requirement forced upon you by management. Whatever the reason, wouldn&amp;rsquo;t it be great to use Perl most of the time, but be able to invoke something else when you had to?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Inline.pm&lt;/code&gt; is a new module that glues other programming languages to Perl. It allows you to write C, C++, and Python code directly inside your Perl scripts and modules. This is conceptually similar to the way you can write inline assembly language in C programs. Thus the name: &lt;code&gt;Inline.pm&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The basic philosophy behind Inline is this: ``make it as easy as possible to use Perl with other programming languages, while ensuring that the user&amp;rsquo;s experience retains the DWIMity of Perl&amp;rdquo;. To accomplish this, Inline must do away with nuisances such as interface definition languages, makefiles, build directories and compiling. You simply write your code and run it. Just like Perl.&lt;/p&gt;

&lt;p&gt;Inline will silently take care of all the messy implementation details and ``do the right thing&amp;rdquo;. It analyzes your code, compiles it if necessary, creates the correct Perl bindings, loads everything up, and runs the whole schmear. The net effect of this is you can now write functions, subroutines, classes, and methods in another language and call them as if they were Perl.&lt;/p&gt;

&lt;h3 id=&#34;span-id-inline-in-action-simple-examples-in-c-inline-in-action-simple-examples-in-c-span&#34;&gt;&lt;span id=&#34;inline in action  simple examples in c&#34;&gt;Inline in Action - Simple examples in C&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Inline addresses an old problem in a completely revolutionary way. Just describing Inline doesn&amp;rsquo;t really do it justice. It should be &lt;em&gt;seen&lt;/em&gt; to be fully appreciated. Here are a couple examples to give you a feel for the module.&lt;/p&gt;

&lt;h3 id=&#34;span-id-hello-world-hello-world-span&#34;&gt;&lt;span id=&#34;hello, world&#34;&gt;Hello, world&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;It seems that the first thing any programmer wants to do when he learns a new programming technique is to use it to greet the Earth. In keeping with that tradition, here is the ``Hello, world&amp;rdquo; program using Inline.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Inline C =&amp;gt; &amp;lt;&amp;lt;&#39;END_C&#39;;
    void greet() {
        printf(&amp;quot;Hello, world\n&amp;quot;);
    }
    END_C

    greet;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Simply run this script from the command line and it will print (you guessed it):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Hello, world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example, &lt;code&gt;Inline.pm&lt;/code&gt; is instantiated with the name of a programming language, ``C&amp;rdquo;, and a string containing a piece of that language&amp;rsquo;s source code. This C code defines a function called &lt;code&gt;greet()&lt;/code&gt; which gets bound to the Perl subroutine &lt;code&gt;&amp;amp;main::greet&lt;/code&gt;. Therefore, when we call the &lt;code&gt;greet()&lt;/code&gt; subroutine, the program prints our message on the screen.&lt;/p&gt;

&lt;p&gt;You may be wondering why there are no &lt;code&gt;#include&lt;/code&gt; statements for things like &lt;code&gt;stdio.h&lt;/code&gt;? That&amp;rsquo;s because Inline::C automatically prepends the following lines to the top of your code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #include &amp;quot;EXTERN.h&amp;quot;
    #include &amp;quot;perl.h&amp;quot;
    #include &amp;quot;XSUB.h&amp;quot;
    #include &amp;quot;INLINE.h&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These header files include all of the standard system header files, so you almost never need to use &lt;code&gt;#include&lt;/code&gt; unless you are dealing with a non-standard library. This is in keeping with Inline&amp;rsquo;s philosophy of making easy things easy. (Where have I heard that before?)&lt;/p&gt;

&lt;h3 id=&#34;span-id-just-another-hacker-just-another-hacker-span&#34;&gt;&lt;span id=&#34;just another ____ hacker&#34;&gt;Just Another ____ Hacker&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The next logical question is, ``How do I pass data back and forth between Perl and C?&amp;rdquo; In this example we&amp;rsquo;ll pass a string to a C function and have it pass back a brand new Perl scalar.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Inline C;
    print JAxH(&#39;Perl&#39;);


    __END__
    __C__
    SV* JAxH(char* x) {
        return newSVpvf(&amp;quot;Just Another %s Hacker\n&amp;quot;, x);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you run this program, it prints:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Just Another Perl Hacker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;ve probably noticed that this example is coded differently then the last one. The &lt;code&gt;use Inline&lt;/code&gt; statement specifies the language being used, but not the source code. This is an indicator for Inline to look for the source at the end of the program, after the special marker &amp;lsquo;&lt;code&gt;__C__&lt;/code&gt;&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;The concept being demonstrated is that we can pass Perl data in and out of a C function. Using the default Perl type conversions, Inline can easily convert all of the basic Perl data types to C and vice-versa.&lt;/p&gt;

&lt;p&gt;This example uses a couple of the more advanced concepts of Inlining. Its return value is of the type &lt;code&gt;SV*&lt;/code&gt; (or Scalar Value). The Scalar Value is the most common Perl internal type. Also, the Perl internal function &lt;code&gt;newSVpfv()&lt;/code&gt; is called to create a new Scalar Value from a string, using the familiar &lt;code&gt;sprintf()&lt;/code&gt; syntax. You can learn more about simple Perl internals by reading the &lt;code&gt;perlguts&lt;/code&gt; and &lt;code&gt;perlapi&lt;/code&gt; documentation distributed with Perl.&lt;/p&gt;

&lt;h3 id=&#34;span-id-what-about-xs-and-swig-what-about-xs-and-swig-span&#34;&gt;&lt;span id=&#34;what about xs and swig&#34;&gt;What about XS and SWIG?&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s detour momentarily to ponder ``Why Inline?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;There are already two major facilities for extending Perl with C. They are XS and SWIG. Both are similar in their capabilities, at least as far as Perl is concerned. And both of them are quite difficult to learn compared to Inline. Since SWIG isn&amp;rsquo;t used in practice to nearly the degree that XS is, I&amp;rsquo;ll only address XS.&lt;/p&gt;

&lt;p&gt;There is a big fat learning curve involved with setting up and using the XS environment. You need to get quite intimate with the following docs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; * perlxs
 * perlxstut
 * perlapi
 * perlguts
 * perlcall
 * perlmod
 * h2xs
 * xsubpp
 * ExtUtils::MakeMaker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With Inline you can be up and running in minutes. There is a C Cookbook with lots of short but complete programs that you can extend to your real-life problems. No need to learn about the complicated build process going on in the background. You don&amp;rsquo;t even need to compile the code yourself. Perl programmers cannot be bothered with silly things like compiling. ``Tweak, Run, Tweak, Run&amp;rdquo; is our way of life. Inline takes care of every last detail except writing the C code.&lt;/p&gt;

&lt;p&gt;Another advantage of Inline is that you can use it directly in a script. As we&amp;rsquo;ll soon see, you can even use it in a Perl one-liner. With XS and SWIG, you always set up an entirely separate module, even if you only have one or two functions. Inline makes easy things easy, and hard things possible. Just like Perl.&lt;/p&gt;

&lt;p&gt;Finally, Inline supports several programming languages (not just C and C++). As of this writing, Inline has support for C, C++, Python, and CPR. There are plans to add many more.&lt;/p&gt;

&lt;h3 id=&#34;span-id-oneliners-one-liners-span&#34;&gt;&lt;span id=&#34;oneliners&#34;&gt;One-Liners&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Perl is famous for its one-liners. A Perl one-liner is short piece of Perl code that can accomplish a task that would take much longer in another language. It is one of the popular techniques that Perl hackers use to flex their programming muscles.&lt;/p&gt;

&lt;p&gt;So you may wonder: ``Is Inline powerful enough to produce a one-liner that is also bonifide C extension?&amp;rdquo; Of course it is! Here you go:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    perl -e &#39;use Inline C=&amp;gt;
    q{void J(){printf(&amp;quot;Just Another Perl Hacker\n&amp;quot;);}};J&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Try doing that with XS! We can even write the more complex Inline &lt;code&gt;JAxH()&lt;/code&gt; discussed earlier as a one-liner:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    perl -le &#39;use Inline C=&amp;gt;
    q{SV*JAxH(char*x){return newSVpvf(&amp;quot;Just Another %s Hacker&amp;quot;,x);}};print JAxH+Perl&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I have been using this one-liner as my email signature for the past couple months. I thought it was pretty cool until Bernhard Muenzer posted this gem to &lt;code&gt;comp.lang.perl.modules&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #!/usr/bin/perl -- -* Nie wieder Nachtschicht! *- -- lrep\nib\rsu\!#
    use Inline C=&amp;gt;&#39;void C(){int m,u,e=0;float l,_,I;for(;1840-e;putchar((++e&amp;gt;907
     &amp;amp;&amp;amp;942&amp;gt;e?61-m:u)[&amp;quot;\n)moc.isc@rezneumb(rezneuM drahnreB&amp;quot;]))for(u=_=l=0;79-(m
      =e%80)&amp;amp;&amp;amp;I*l+_*_&amp;lt;6&amp;amp;&amp;amp;26-++u;_=2*l*_+e/80*.09-1,l=I)I=l*l-_*_-2+m/27.;}&#39;;&amp;amp;C
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-supported-platforms-for-c-supported-platforms-for-c-span&#34;&gt;&lt;span id=&#34;supported platforms for c&#34;&gt;Supported Platforms for C&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Inline C works on all of the Perl platforms that I have tested it with so far. This includes all common Unixes and recent versions of Microsoft Windows. The only catch is that you must have the same compiler and &lt;code&gt;make&lt;/code&gt; utility that was used to build your &lt;code&gt;perl&lt;/code&gt; binary.&lt;/p&gt;

&lt;p&gt;Inline has been successfully used on Linux, Solaris, AIX, HPUX, and all the recent BSD&amp;rsquo;s.&lt;/p&gt;

&lt;p&gt;There are two common ways to use Inline on MS Windows. The first one is with ActiveState&amp;rsquo;s ActivePerl for MSWin32. In order to use Inline in that environment, you&amp;rsquo;ll need a copy of MS Visual C++ 6.0. This comes with the &lt;code&gt;cl.exe&lt;/code&gt; compiler and the &lt;code&gt;nmake&lt;/code&gt; make utility. Actually these are the only parts you need. The visual components aren&amp;rsquo;t necessary for Inline.&lt;/p&gt;

&lt;p&gt;The other alternative is to use the Cygwin utilities. This is an actual Unix porting layer for Windows. It includes all of the most common Unix utilities, such as &lt;code&gt;bash&lt;/code&gt;, &lt;code&gt;less&lt;/code&gt;, &lt;code&gt;make&lt;/code&gt;, &lt;code&gt;gcc&lt;/code&gt; and of course &lt;code&gt;perl&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-inline-syntax-the-inline-syntax-span&#34;&gt;&lt;span id=&#34;the inline syntax&#34;&gt;The Inline Syntax&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Inline is a little bit different than most of the Perl modules that you are used to. It doesn&amp;rsquo;t import any functions into your namespace and it doesn&amp;rsquo;t have any object oriented methods. Its entire interface is specified through &lt;code&gt;&#39;use Inline ...&#39;&lt;/code&gt; commands. The general Inline usage is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Inline C =&amp;gt; source-code,
               config_option =&amp;gt; value,
               config_option =&amp;gt; value;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where &lt;code&gt;C&lt;/code&gt; is the programming language, and &lt;code&gt;source-code&lt;/code&gt; is a string, filename, or the keyword &amp;lsquo;&lt;code&gt;DATA&lt;/code&gt;&amp;rsquo;. You can follow that with any number of optional &amp;lsquo;&lt;code&gt;keyword =&amp;gt; value&lt;/code&gt;&amp;rsquo; configuration pairs. If you are using the &amp;lsquo;DATA&amp;rsquo; option, with no configuration parameters, you can just say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Inline C;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-fine-dining-a-glimpse-at-the-c-cookbook-fine-dining-a-glimpse-at-the-c-cookbook-span&#34;&gt;&lt;span id=&#34;fine dining  a glimpse at the c cookbook&#34;&gt;Fine Dining - A Glimpse at the C Cookbook&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In the spirit of the O&amp;rsquo;Reilly book ``Perl Cookbook&amp;rdquo;, Inline provides a manpage called C-Cookbook. In it you will find the recipes you need to help satisfy your Inline cravings. Here are a couple of tasty morsels that you can whip up in no time. Bon Appetit!&lt;/p&gt;

&lt;h3 id=&#34;span-id-external-libraries-external-libraries-span&#34;&gt;&lt;span id=&#34;external libraries&#34;&gt;External Libraries&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The most common real world need for Inline is probably using it to access existing compiled C code from Perl. This is easy to do. The secret is to write a wrapper function for each function you want to expose in Perl space. The wrapper calls the real function. It also handles how the arguments get passed in and out. Here is a short Windows example that displays a text box with a message, a caption and an ``OK&amp;rdquo; button:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Inline C =&amp;gt; DATA =&amp;gt;
               LIBS =&amp;gt; &#39;-luser32&#39;,
               PREFIX =&amp;gt; &#39;my_&#39;;

    MessageBoxA(&#39;Inline Message Box&#39;, &#39;Just Another Perl Hacker&#39;);


    __END__
    __C__
    #include &amp;lt;windows.h&amp;gt;
    int my_MessageBoxA(char* Caption, char* Text) {
      return MessageBoxA(0, Text, Caption, 0);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This program calls a function from the MSWin32 &lt;code&gt;user32.dll&lt;/code&gt; library. The wrapper determines the type and order of arguments to be passed from Perl. Even though the real &lt;code&gt;MessageBoxA()&lt;/code&gt; needs four arguments, we can expose it to Perl with only two, and we can change the order. In order to avoid namespace conflicts in C, the wrapper must have a different name. But by using the &lt;code&gt;PREFIX&lt;/code&gt; option (same as the XS &lt;code&gt;PREFIX&lt;/code&gt; option) we can bind it to the original name in Perl.&lt;/p&gt;

&lt;h3 id=&#34;span-id-it-takes-all-types-it-takes-all-types-span&#34;&gt;&lt;span id=&#34;it takes all types&#34;&gt;It Takes All Types&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Older versions of Inline only supported five C data types. These were: &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;char*&lt;/code&gt; and &lt;code&gt;SV*&lt;/code&gt;. This was all you needed. All the basic Perl scalar types are represented by these. Fancier things like references could be handled by using the generic &lt;code&gt;SV*&lt;/code&gt; (scalar value) type, and then doing the mapping code yourself, inside the C function.&lt;/p&gt;

&lt;p&gt;The process of converting between Perl&amp;rsquo;s &lt;code&gt;SV*&lt;/code&gt; and C types is called &lt;strong&gt;typemapping&lt;/strong&gt;. In XS, you normally do this by using &lt;code&gt;typemap&lt;/code&gt; files. A default &lt;code&gt;typemap&lt;/code&gt; file exists in every Perl installation in a file called &lt;code&gt;/usr/lib/perl5/5.6.0/ExtUtils/typemap&lt;/code&gt; or something similar. This file contains conversion code for over 20 different C types, including all of the Inline defaults.&lt;/p&gt;

&lt;p&gt;As of version 0.30, Inline no longer has &lt;em&gt;any&lt;/em&gt; built in types. It gets all of its types exclusively from &lt;code&gt;typemap&lt;/code&gt; files. Since it uses Perl&amp;rsquo;s default &lt;code&gt;typemap&lt;/code&gt; file for its own defaults, it actually has many more types available automatically.&lt;/p&gt;

&lt;p&gt;This setup provides a lot of flexibility. You can specify your own &lt;code&gt;typemap&lt;/code&gt; files through the use of the &lt;code&gt;TYPEMAPS&lt;/code&gt; configuration option. This not only allows you to override the defaults with your own conversion code, but it also means that you can add new types to Inline as well. The major advantage to extending the Inline syntax this way is that there are already many typemaps available for various APIs. And if you&amp;rsquo;ve done your own XS coding in the past, you can use your existing &lt;code&gt;typemap&lt;/code&gt; files as is. No changes are required.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at a small example of writing your own typemaps. For some reason, the C type &lt;code&gt;float&lt;/code&gt; is not represented in the default Perl &lt;code&gt;typemap&lt;/code&gt; file. I suppose it&amp;rsquo;s because Perl&amp;rsquo;s floating point numbers are always stored as type &lt;code&gt;double&lt;/code&gt;, which is higher precision than &lt;code&gt;float&lt;/code&gt;. But if we wanted it anyway, writing a &lt;code&gt;typemap&lt;/code&gt; file to support &lt;code&gt;float&lt;/code&gt; is trivial.&lt;/p&gt;

&lt;p&gt;Here is what the file would look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    float                   T_FLOAT


    INPUT
    T_FLOAT
            $var = (float)SvNV($arg)


    OUTPUT
    T_FLOAT
            sv_setnv($arg, (double)$var);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Without going into details, this file provides two snippets of code. One for converting a &lt;code&gt;SV*&lt;/code&gt; to a float, and one for the opposite. Now we can write the following script:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Inline C =&amp;gt; DATA =&amp;gt;
               TYPEMAPS =&amp;gt; &#39;./typemap&#39;;


    print &#39;1.2 + 3.4 = &#39;, fadd(1.2, 3.4), &amp;quot;\n&amp;quot;;


    __END__
    __C__
    float fadd(float x, float y) {
        return x + y;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-some-ware-beyond-the-c-some-ware-beyond-the-c-span&#34;&gt;&lt;span id=&#34;some ware beyond the c&#34;&gt;Some Ware Beyond the C&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The primary goal of Inline is to make it easy to use other programming languages with Perl. This is not limited to C. The initial implementations of Inline only supported C, and the language support was built directly into &lt;code&gt;Inline.pm&lt;/code&gt;. Since then things have changed considerably. Inline now supports multiple languages of both compiled and interpreted nature. And it keeps the implementations in an object oriented type structure, whereby each language has its own separate module, but they can inherit behavior from the base Inline module.&lt;/p&gt;

&lt;p&gt;On my second day working at ActiveState, a young man approached me. ``Hi, my name is Neil Watkiss. I just hacked your Inline module to work with C++.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Neil, I soon found out, was a computer science student at a local university. He was working part-time for ActiveState then, and had somehow stumbled across Inline. I was thrilled! I had wanted to pursue new languages, but didn&amp;rsquo;t know how I&amp;rsquo;d find the time. Now I was sitting 15 feet away from my answer!&lt;/p&gt;

&lt;p&gt;Over the next couple months, Neil and I spent our spare time turning Inline into a generic environment for gluing new languages to Perl. I ripped all the C specific code out of Inline and put it into Inline::C. Neil started putting together Inline::CPP and Inline::Python. Together we came up with a new syntax that allowed multiple languages and easier configuration.&lt;/p&gt;

&lt;p&gt;Here is a sample program that makes uses of Inline Python:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Inline Python;
    my $language = shift;
    print $language, 
          (match($language, &#39;Perl&#39;) ? &#39; rules&#39; : &#39; sucks&#39;),
          &amp;quot;!\n&amp;quot;;
    __END__
    __Python__
    import sys
    import re
    def match(str, regex):
        f = re.compile(regex);
        if f.match(str): return 1
        return 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This program uses a Python regex to show that ``Perl rules!&amp;ldquo;.&lt;/p&gt;

&lt;p&gt;Since Python supports its own versions of Perl scalars, arrays, and hashes, Inline::Python can flip-flop between them easily and logically. If you pass a hash reference to python, it will turn it into a dictionary, and vice-versa. Neil even has mechanisms for calling back to Perl from Python code. See the Inline::Python docs for more info.&lt;/p&gt;

&lt;h3 id=&#34;span-id-see-perl-run-run-perl-run-see-perl-run-run-perl-run-span&#34;&gt;&lt;span id=&#34;see perl run. run perl, run!&#34;&gt;See Perl Run. Run Perl, Run!&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Inline is a great way to write C extensions for Perl. But is there an equally simple way to embed a Perl interpreter in a C program? I pondered this question myself one day. Writing Inline functionality for C would not be my cup of tea.&lt;/p&gt;

&lt;p&gt;The normal way to embed Perl into C involves jumping through a lot of hoops to bootstrap a perl interpreter. Too messy for one-liners. And you need to compile the C. Not very Inlinish. But what if you could pass your C program to a perl program that could pass it to Inline? Then you could write this program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #!/usr/bin/cpr
    int main(void) {
        printf(&amp;quot;Hello, world\n&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and just run it from the command line. Interpreted C!&lt;/p&gt;

&lt;p&gt;And thus, a new programming language was born. &lt;strong&gt;CPR&lt;/strong&gt;. ``C Perl Run&amp;rdquo;. The Perl module that gives it life is called &lt;code&gt;Inline::CPR&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Of course, CPR is not really its own language, in the strict sense. But you can think of it that way. CPR is just like C except that you can call out to the Perl5 API at any time, without any extra code. In fact, CPR redefines this API with its own CPR wrapper API.&lt;/p&gt;

&lt;p&gt;There are several ways to think of CPR: ``a new language&amp;rdquo;, ``an easy way to embed Perl in C&amp;rdquo;, or just ``a cute hack&amp;rdquo;. I lean towards the latter. CPR is probably a far stretch from meeting most peoples embedding needs. But at the same time its a very easy way to play around with, and perhaps redefine, the Perl5 internal API. The best compliment I&amp;rsquo;ve gotten for CPR is when my ActiveState coworker Adam Turoff said, ``I feel like my head has just been wrapped around a brick&amp;rdquo;. I hope this next example makes you feel that way too:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #!/usr/bin/cpr
    int main(void) {
        CPR_eval(&amp;quot;use Inline (C =&amp;gt; q{
            char* greet() {
                return \&amp;quot;Hello world\&amp;quot;;
            }
        })&amp;quot;);

        printf(&amp;quot;%s, I&#39;m running under Perl version %s\n&amp;quot;,
               CPR_eval(&amp;quot;&amp;amp;greet&amp;quot;),
               CPR_eval(&amp;quot;use Config; $Config{version}&amp;quot;));
        return 0;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running this program prints:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Hello world, I&#39;m running under Perl version 5.6.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using the &lt;code&gt;eval()&lt;/code&gt; call this CPR program calls Perl and tells it to use Inline C to add a new function, which the CPR program subsequently calls. I think I have a headache myself.&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-future-of-inline-the-future-of-inline-span&#34;&gt;&lt;span id=&#34;the future of inline&#34;&gt;The Future of Inline&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Inline version 0.30 was written specifically so that it would be easy for other people in the Perl community to contribute new language bindings for Perl. On the day of that release, I announced the birth of the Inline mailing list, &lt;a href=&#34;mailto:inline@perl.org.&#34;&gt;inline@perl.org.&lt;/a&gt; This is intended to be the primary forum for discussion on all Inline issues, including the proposal of new features, and the authoring of new ILSMs.&lt;/p&gt;

&lt;p&gt;In the year 2001, I would like to see bindings for Java, Ruby, Fortran and Bash. I don&amp;rsquo;t plan on authoring all of these myself. But I may kickstart some of them, and see if anyone&amp;rsquo;s interested in taking over. If &lt;em&gt;you&lt;/em&gt; have a desire to get involved with Inline development, please join the mailing list (&lt;a href=&#34;mailto:inline-subscribe@perl.org&#34;&gt;inline-subscribe@perl.org&lt;/a&gt;) and speak up.&lt;/p&gt;

&lt;p&gt;My primary focus at the present time, is to make the base Inline module as simple, flexible, and stable as possible. Also I want to see Inline::C become an acceptable replacement for XS; at least for most situations.&lt;/p&gt;

&lt;h3 id=&#34;span-id-conclusion-conclusion-span&#34;&gt;&lt;span id=&#34;conclusion&#34;&gt;Conclusion&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Using XS is just too hard. At least when you compare it to the rest of the Perl we know and love. Inline takes advantage of the existing frameworks for combining Perl and C, and packages it all up into one easy to swallow pill. As an added bonus, it provides a great framework for binding other programming languages to Perl. You might say, ``It&amp;rsquo;s a &amp;lsquo;Perl-fect&amp;rsquo; solution!&amp;rdquo;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Topaz: Perl for the 22nd Century</title>
      <link>http://localhost:1313/pub/1999/09/topaz.html/</link>
      <pubDate>Tue, 28 Sep 1999 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/1999/09/topaz.html/</guid>
      <description>

&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;One of the more interesting talks at the O&amp;rsquo;Reilly 1999 Open Source Convention was by Chip Salzenberg, one of the core developers of Perl. He described his work on Topaz, a new effort to completely re-write the internals of Perl in C++. The following article is an abridged version of the transcript of this talk that provide the basic context for Topaz and the objectives for this new project. You can also listen to the complete 85-minute talk using the RealPlayer.&lt;/em&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Listen to Chip Salzenburg&amp;rsquo;s Topaz talk! Choose either &lt;a href=&#34;http://g2.songline.com:8080/ramgen/perl.com/realaudio/Topaz1.rm&#34;&gt;Real Audio&lt;/a&gt; or you can &lt;a href=&#34;http://localhost:1313/media/_pub_1999_09_topaz/Topaz1.mp3&#34;&gt;download the MP3&lt;/a&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Topaz is a project to re-implement all of Perl in C++. If it comes to fruition, if it actually works, it&amp;rsquo;s going to be Perl 6. There is, of course, the possibility that for various reasons, things may change and it may not really work out, so that&amp;rsquo;s why I&amp;rsquo;m not really calling it Perl 6 at this point. Occasionally I have been known to say, &amp;ldquo;It will be fixed in Perl 6,&amp;rdquo; but I&amp;rsquo;m just speaking through my hat when I say that.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Who&amp;rsquo;s doing it?&lt;/strong&gt; Well, it&amp;rsquo;s me mostly for now because when you&amp;rsquo;re starting on something like this, there&amp;rsquo;s really not a lot of room to fit more than one or two people. The core design decisions can&amp;rsquo;t be done in a bazaar fashion (with an &amp;ldquo;a&amp;rdquo;), although obviously they can be bizarre (with an &amp;ldquo;i&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;When?&lt;/strong&gt; The official start was last year&amp;rsquo;s Perl conference. I expected to have something, more or less equivalent to Perl 4 by, well, now. That was a little optimistic.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;So how will it be done?&lt;/strong&gt; Well, it&amp;rsquo;s being done in C++, and there are some reasons for that, one of which is, of course, I happen to like C++. Actually the very first discussion/argument on the Perl 6 porter&amp;rsquo;s mailing list was what language to use. We had some runners-up that actually were under serious consideration.&lt;/p&gt;

&lt;h3 id=&#34;choosing-a-systems-programming-language&#34;&gt;Choosing A Systems Programming Language&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Objective C&lt;/strong&gt; has some nice characteristics. It&amp;rsquo;s simple and, with a GNU implementation, it is pretty much available everywhere. The downside is that Objective C has no equivalent of inline functions, so you&amp;rsquo;d have to resort to heavy use of macros again, which is something I&amp;rsquo;d like to get away from. Also, it doesn&amp;rsquo;t have any support for namespaces, which means that the entire mess we currently have would have to be carried forward: maintaining a separate list of external functions that need to be renamed by the preprocessor during compilation so that you don&amp;rsquo;t conflict with somebody else when you embed it in another program. I really hate that part. Even though it&amp;rsquo;s well done, it&amp;rsquo;s just one of those things you wish you didn&amp;rsquo;t have to do.&lt;/p&gt;

&lt;p&gt;In C++ you solve that problem by saying &amp;ldquo;namespace Perl open curly brace,&amp;rdquo; and the rest is automatic. So that is the reason why Objective C fell out of the running.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eiffel&lt;/strong&gt; actually was a serious contender for a long time. That is, until I realized that to get decent performance, Eiffel compilers—or I should say the free Eiffel compiler, because there are multiple implementations—needed to do analysis at link-time as to all the classes that were actually in the program. Eiffel has no equivalent of declaring member functions—I&amp;rsquo;m using the C++ terminology—declaring them to be virtual or nonvirtual. It intuits this by figuring out the equivalent of the Java characteristic final, i.e., I have no derived classes, at link-time. And so it says, well, if there are no derived classes, then therefore I can just inline this function call. Which is clever and all, but the problem is that Topaz must be able to load classes dynamically at run time and incorporate them into the class structure, and so obviously anything that depends on link-time analysis is right out. So that was the end of Eiffel.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ada&lt;/strong&gt;, actually as a language, has much to recommend it. Conciseness is not one of them, but it does have some good characteristics. I do secretly tend toward the bondage and discipline style of programming, i.e., the more you tell the compiler, the more it can help you to enforce the things you told it. However, the only free implementation of Ada, at least the only one I&amp;rsquo;m aware of, GNAT, is written in Ada. This is an interesting design decision and it obviously helped them. They obviously like Ada so they use it, right? The problem is that if Perl 6 were written in Ada—it would require people to bootstrap GNAT before they could even get to Perl. That&amp;rsquo;s too much of a burden to put on anybody.&lt;/p&gt;

&lt;p&gt;So, we&amp;rsquo;re left with C++. It&amp;rsquo;s rather like the comment that I believe Winston Churchill is reported to have said about democracy: It&amp;rsquo;s absolutely the worst system except for all the others. So, C++ is the worst language we could have chosen, except for all the others.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;So, where will it run?&lt;/strong&gt; The plan is for it to run anywhere that there&amp;rsquo;s an ANSI-C++ compiler. Those of you who have seen the movie the mini-series Shogun might remember when the pilot is suppose to learn Japanese, and if he doesn&amp;rsquo;t learn it the entire village will be killed. He can&amp;rsquo;t stand the possibility of all these deaths being on his head so he&amp;rsquo;s about to commit suicide and finally the shogun says, &amp;ldquo;Well, whatever you learn, it will be considered enough,&amp;rdquo; and so then he&amp;rsquo;s okay with it. Well, that&amp;rsquo;s kind of how I feel about Visual C++. Whatever Visual C++ implements, we shall call that &amp;ldquo;enough,&amp;rdquo; because I really don&amp;rsquo;t think that we can ignore Windows as a target market. If nothing else, we need the checklist item—works on Windows. Otherwise the people who don&amp;rsquo;t understand what&amp;rsquo;s going on will refuse to Perl in situations where they really need to.&lt;/p&gt;

&lt;p&gt;So, you know, unless there&amp;rsquo;s an overriding reason why it&amp;rsquo;s absolutely impossible, although we will use ANSI features as much as possible because ANSI C++ really is a well-done description and a well-done specification for C++ with a few minor things I don&amp;rsquo;t like. Visual C++ is so common we really just can&amp;rsquo;t afford to ignore it.&lt;/p&gt;

&lt;p&gt;As for non-Windows platforms, and even for Windows platforms for some people, EGCS (which actually has now been renamed to GCC 2.95) is a really amazingly good implementation of the C++ language. The kind of bugs, the kind of features that they&amp;rsquo;re working on the mailing list, are so esoteric that actually it takes me two or three times to read through just the description of the bug before I understand it. The basic stuff is no problem at all.&lt;/p&gt;

&lt;p&gt;The ANSI C++ library for EGCS/GCC is really not all that good at this point, but work is under way on that. I expected them to be more or less done by now, but obviously they&amp;rsquo;re not. I still expect them to be done by the next conference. It&amp;rsquo;s just that the next conference is now the conference 4.0. By then I hope that we&amp;rsquo;ll be able to use that library in the Topaz implementation.&lt;/p&gt;

&lt;p&gt;Now, the big question:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Why in the world would I do such a thing?&lt;/strong&gt; Or rather start the ball rolling? Well the primary reason was difficulty in maintenance. Perl&amp;rsquo;s guts are, well, complicated. Nat Torkington described them well. I believe he said that they are &amp;ldquo;an interconnected mass of livers and pancreas and lungs and little sharp pointy things and the occasional exploding kidney.&amp;rdquo; It really is hard to maintain Perl 5. Considering how many people have had their hands in it; it&amp;rsquo;s not surprising that this is the situation. And you really need indoctrination in all the mysteries and magic structures and so on—before you can really hope to make significant changes to the Perl core without breaking more things than you&amp;rsquo;re adding.&lt;/p&gt;

&lt;p&gt;Some design decisions have made certain bugs really hard to get rid of. For example, the fact that things on the stack do not have the reference counts incremented has made it necessary to fake the reference counting in some circumstances, � la the mortality concept, for those of you who have been in there.&lt;/p&gt;

&lt;p&gt;Really, when you think about it, the number of people who can do that sort of deep work because they&amp;rsquo;re willing to or have been forced to put enough time into understanding it, is very limited, and that&amp;rsquo;s bad for Perl, I think. It would be better if the barrier to entry to working on the core were lower. Right now the only thing that&amp;rsquo;s really accessible to everyone is the surface language, so anytime anybody has the feeling that they want to contribute to Perl, the only thing they know how to do is suggest a new feature. I hope in the future they&amp;rsquo;ll be able to do things like suggest an improvement in the efficiency layer or something like that.&lt;/p&gt;

&lt;p&gt;The secondary reason actually is new features. There are some features there where people say, &amp;ldquo;Yeah, I want that just cuz it&amp;rsquo;s cool.&amp;rdquo; First of all, dynamic loading of basic types—and I&amp;rsquo;ll give an example of that later—the basic concept is if you want to invent a new thing like a B-tree hash, you shouldn&amp;rsquo;t have to modify the Perl core for that. You should just be able to create an add-on that&amp;rsquo;s dynamically loaded and inserts itself and then you&amp;rsquo;d be able to use it.&lt;/p&gt;

&lt;p&gt;Robust byte-code compilation is another such feature. Now, in complete honesty, I don&amp;rsquo;t know. I haven&amp;rsquo;t looked at the existing byte-code compilation output, but I do know from examining how the internals work that retrofitting something like that is quite difficult. If you incorporate it into the structure of the OP-tree (for those of you who know what that is, the basic operations), there&amp;rsquo;s the concept of a separation between designing the semantic tree (as in &amp;ldquo;this is what I want&amp;rdquo;) versus designing the runtime representation for efficient execution. Once you&amp;rsquo;ve made that separation, now you can also have a separate implementation of the semantic tree, which is, say, just a list of byte codes that would be easy to write to a file and then read back later. So, separation of representing the OP-tree statically versus what you use dynamically is an important part of that part the internals.&lt;/p&gt;

&lt;p&gt;Also, something that could be done currently but nobody&amp;rsquo;s gotten around to it—Micro Perl. Now if you built Perl, you&amp;rsquo;ve noticed that there&amp;rsquo;s a main Perl, and then there&amp;rsquo;s Mini Perl, which you always to expect to have a little price tag hanging off of, and then there&amp;rsquo;s the concept of Micro Perl, which is even smaller than Mini Perl. The idea here is: What parts of Perl can you build without any knowledge that Configure would give you. Or perhaps, only very, very, very little configure tests. For example, we could assume ANSI or we could assume pseudo-POSIX. In any case, even if you limit yourself to ANSI, you&amp;rsquo;ve got quite a bit of stuff. You, of course, have all the basic internal data structures in the language. You can make a call to system, to spawn children, and a few other things, and that basically gives you Perl as your scripting language. Then you can write the configure in Micro Perl. I don&amp;rsquo;t know about you, but I&amp;rsquo;d much rather use Micro Perl as a language for configuration than sh, because who knows what particular weird variant of sh you&amp;rsquo;re going to have, and really isn&amp;rsquo;t it kind of a pain to have to spawn an external text program just to see if two strings are equal? Come on. Okay, so that&amp;rsquo;s also part of the plan. We could do this with Perl 5, who knows maybe now that I&amp;rsquo;ve mentioned it somebody will, but that&amp;rsquo;s also something I have in mind.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Why not use C?&lt;/strong&gt; Certainly C does have a lot to recommend it. The necessity of using all those weird macros for namespace manipulation, which I&amp;rsquo;d rather just use the namespace operator for, and the proliferation of macros are all disadvantages. Stroustrup makes the persuasive argument that every time you can eliminate a macro and replace it with an inline function or a const declaration or something or that sort, you are benefiting yourself because the preprocessor is so uncontrolled and all of the information from it is lost when you get to the debugger. So I&amp;rsquo;d prefer to use C++ for that reason.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Would it be plausible to use Perl, presumably Perl 5 to automatically generate parts of Perl 6?&lt;/strong&gt; And the answer is yes, that absolutely will be done. The equivalent of what is now opcode.pl will still exist, and it will be generating a whole bunch of C++ classes to implement the various types of OPs.&lt;/p&gt;

&lt;p&gt;A perfect Perl doesn&amp;rsquo;t have systems programming as part of its target problem domain. That&amp;rsquo;s what C++ and C and those other languages are for. Those are systems programming languages. Perl is an application language, and in fact one of the things that I really felt uncomfortable about Eiffel was that it also is really an applications programming language. The whole concept of pointers and pointer arithmetic and memory management—if you read Meyer&amp;rsquo;s new book, the chapter on memory management begins with &amp;ldquo;Ideally, we would like to completely forget about memory management.&amp;rdquo; And I thought to myself, well that&amp;rsquo;s great if you&amp;rsquo;re doing applications, but for systems programming, that&amp;rsquo;s nuts. It&amp;rsquo;s an example of what the language is for. When I was trying to figure out how to be persuasive on this subject, I finally realized that Perl may be competing with Java in the problem space, but when you&amp;rsquo;re writing Perl, implementing the Perl runtime, really what you&amp;rsquo;re doing is something equivalent to writing a JVM. You&amp;rsquo;re writing the equivalent of a Java Virtual Machine. Now, would you write a JVM in Eiffel? I don&amp;rsquo;t think so. No, so neither would you write the Perl runtime in Java or in Eiffel.&lt;/p&gt;

&lt;h3 id=&#34;how-or-why-perl-changes&#34;&gt;How or Why Perl Changes&lt;/h3&gt;

&lt;p&gt;The language changes only when Larry says so. What he has said on this subject is that anything that is officially deprecated is fair game for removal. Beyond that I really need to leave things as is. He&amp;rsquo;s the language designer. I&amp;rsquo;m the language implementer, at least for this particular project. It seems like a good separation of responsibilities. You know, I&amp;rsquo;ve got enough on my plate without trying to redesign the language.&lt;/p&gt;

&lt;p&gt;Larry is open to suggestions, and in fact that was an interesting discussion we had recently on the Perl 5 Porters mailing list. Was the syntax appropriate for declaring variables to give appropriate hints to a hypothetical compiler? That is to say MY INT $X or MY STR $Y &amp;ndash; and I thought that the INT and the STR and the NUM should be suffixes, something like MY $X:NUM—and, in fact, that suffix syntax is something that Larry officially has blessed, but just not for this purpose. That&amp;rsquo;s the instinct of the language designer coming to the fore saying that something that is a string or a number should not be so hard to type. It should read better.&lt;/p&gt;

&lt;p&gt;Meanwhile, if you want to declare something as being a reference to a class - MY DOG SPOT—that&amp;rsquo;s going to work. You can say that $SPOT when it has a defined value will be a reference to an object of type DOG or at least of a type that is compatible with DOG, and the syntax is already permitted in the Perl parser; it doesn&amp;rsquo;t do very much yet but that will be more fully implemented in the future as well. Many of the detailed aspects of this came about not just springing fully formed from Larry&amp;rsquo;s forehead but as a result of discussion. So yes, he absolutely is taking suggestions.&lt;/p&gt;

&lt;h3 id=&#34;getting-into-the-internals&#34;&gt;Getting into the Internals&lt;/h3&gt;

&lt;p&gt;Now I&amp;rsquo;d like to ask how many of you do not know anything about C++? Okay, a fair number, so I&amp;rsquo;m going to have to explain—everyone else is lying. Two kinds of people: people who say that they know C++ and the truthful. Okay. C++ is complicated, definitely. Actually that reminds me, I&amp;rsquo;m doing this in C++ and I use EMACS. Tom Christiansen asked me, &amp;ldquo;Chip, is there anything that you like that isn&amp;rsquo;t big and complicated?&amp;rdquo; C++, EMACS, Perl, Unix, English—no, I guess not.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;At this point, Chip begins to dive rather deep into a discussion of the internals. You can &lt;a href=&#34;http://g2.songline.com:8080/ramgen/perl.com/realaudio/OSSC99-Topaz.rm&#34;&gt;listen&lt;/a&gt; to the rest of his talk if you are interested in these details.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

