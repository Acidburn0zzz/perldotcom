<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Net Clr C on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/net-clr-c/</link>
    <description>Recent content in Net Clr C on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 19 Mar 2002 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/net-clr-c/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>A Perl Hacker&#39;s Foray into .NET</title>
      <link>http://localhost:1313/pub/2002/03/19/dotnet.html/</link>
      <pubDate>Tue, 19 Mar 2002 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2002/03/19/dotnet.html/</guid>
      <description>

&lt;p&gt;No, I haven&amp;rsquo;t sold out; I haven&amp;rsquo;t gone over to the dark side; I haven&amp;rsquo;t been bought. I&amp;rsquo;m one of the last people to be using closed-source software by choice. But one of the traits of any self-respecting hacker is curiosity, and so when he hears about some cool new technology, he&amp;rsquo;s almost obliged to check it out and see whether there&amp;rsquo;s anything he can learn from it. So this particular Perl hacker took a look at Microsoft&amp;rsquo;s .NET Framework, and, well, Mikey, I think he likes it.&lt;/p&gt;

&lt;h3 id=&#34;what-is-net&#34;&gt;What Is .NET?&lt;/h3&gt;

&lt;p&gt;When something&amp;rsquo;s as incredibly hyped as Microsoft&amp;rsquo;s .NET project, it&amp;rsquo;s hard to convince people that there&amp;rsquo;s a real working technology underneath it. Unfortunately, Microsoft doesn&amp;rsquo;t do itself any favors by slapping the .NET moniker on anything they can. So let&amp;rsquo;s clarify what we&amp;rsquo;re talking about.&lt;/p&gt;

&lt;p&gt;.NET is applied to anything with the broad notion of &amp;ldquo;Web services&amp;rdquo; &amp;ndash; from the Passport and Hailstorm automated privacy-deprivation services and the Web-service-enabled versions of operating systems and application products to the C# language and the Common Language Runtime. But there is an underlying theme and it goes like this: The .NET &lt;strong&gt;Framework&lt;/strong&gt; is an environment based on the Common Language Runtime and (to some extent) the C# language, for creating portable Web services.&lt;/p&gt;

&lt;p&gt;So for our exploration, the components of the .NET Framework that we care about are the Common Language Runtime and the C# language. And to nail it down beyond any doubt, these are things that you can download and use today. They&amp;rsquo;re real, they exist and they work.&lt;/p&gt;

&lt;h3 id=&#34;the-net-clr&#34;&gt;The .NET CLR&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s begin with the CLR. The CLR is, in essence, a virtual machine for C# much like the Java VM, but which is specifically designed to allow a wide variety of languages other than C# to run on it. Does this ring any bells with Perl programmers? Yes, it&amp;rsquo;s not entirely dissimilar to the idea of the Parrot VM, the host VM for Perl 6 but designed to run other languages as well.&lt;/p&gt;

&lt;p&gt;But that&amp;rsquo;s more or less where the similarity ends. For starters, while Parrot is chiefly intended to be ran as an interpreted VM but has a &amp;ldquo;bolted-on&amp;rdquo; JIT, CLR is expected to be JITted from the get-go. Microsoft seems to want to avoid the accusations of slowness leveled at Java by effectively requiring JIT compilation.&lt;/p&gt;

&lt;p&gt;Another &amp;ldquo;surface&amp;rdquo; distinction between Parrot and CLR is that the languages supported by the CLR are primarily statically typed languages such as C#, J#, (a variant of Java) and Visual Basic .NET. The languages Parrot aims to support are primarily dynamically typed, allowing run-time compilation, symbolic variable access, (try doing &lt;code&gt;${&amp;quot;Package::$var&amp;quot;}&lt;/code&gt; in C#&amp;hellip;) closures, and other relatively wacky operations.&lt;/p&gt;

&lt;p&gt;To address these sorts of features, the &lt;a href=&#34;http://research.microsoft.com/project7.net/project_7.htm&#34;&gt;Project 7&lt;/a&gt; research project was set up to provide .NET ports for a variety of &amp;ldquo;academic&amp;rdquo; languages. Unfortunately, it transpires that this has highlighted some limitations of the CLR, and so almost all of the implementations have had to modify their target languages slightly or drop difficult features. For instance, the work on &lt;a href=&#34;http://www.cs.mu.oz.au/research/mercury/&#34;&gt;Mercury&lt;/a&gt; turned up some deficiencies in CLR&amp;rsquo;s Common Type System that would also affect a Perl implementation. We&amp;rsquo;ll discuss these deficiencies later when we examine how Perl and the .NET Framework can interact.&lt;/p&gt;

&lt;p&gt;But on the other hand, let&amp;rsquo;s not let this detract from what the CLR is good at - it can run a variety of different languages relatively efficiently, and it can share data between languages. Let&amp;rsquo;s now take a look at C#, the native language of the CLR, and then see how we can run .NET executables on our favourite free operating systems.&lt;/p&gt;

&lt;h3 id=&#34;c&#34;&gt;C#&lt;/h3&gt;

&lt;p&gt;C# is Microsoft&amp;rsquo;s new language for the .NET Framework. It shares some features with Java, and in fact looks extremely like Java at first glance. Here&amp;rsquo;s a piece of C# code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System;

class App {
   public static void Main(string[] args) {
      Console.WriteLine(&amp;quot;Hello World&amp;quot;);
      foreach (String s in args) {
         Console.WriteLine(&amp;quot;Command-line argument: &amp;quot; + s);
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Naturally, the Java-like features are quite obvious to anyone who&amp;rsquo;s seen much Java - everything&amp;rsquo;s in a class, and there&amp;rsquo;s an explicitly defined &lt;code&gt;Main&lt;/code&gt; function. But what&amp;rsquo;s this - a Perl-like &lt;code&gt;foreach&lt;/code&gt; loop. And that &lt;code&gt;using&lt;/code&gt; declaration seems strangely familiar.&lt;/p&gt;

&lt;p&gt;Now, don&amp;rsquo;t get me wrong. I&amp;rsquo;m not trying to claim that C# is some bastard offspring of Perl and Java, or even that C# really has that much in common with Perl; it doesn&amp;rsquo;t. But it is a well-designed language that does have a bunch of &amp;ldquo;programmer-friendly&amp;rdquo; language features that traditionally made &amp;ldquo;scripting&amp;rdquo; languages like Perl or Python faster for rapid code prototyping.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s some more code, which forms part of a game-of-life benchmarking tool we used to benchmark the CLR against Parrot.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    static String generate(String input) {
        int cell, neighbours;
        int len = input.Length;
        String output = &amp;quot;&amp;quot;;
        cell = 0; 
        do {
            neighbours = 0;
            foreach (int offset in new Int32[] {-16, -15, -14, -1, 1, 14, 15, 16}) {
                int pos = (offset + len + cell) % len;
                if (input.Substring(pos, 1) == &amp;quot;*&amp;quot;)
                    neighbours++; 
            }
            if (input.Substring(cell, 1) == &amp;quot;*&amp;quot;) {
                output += (neighbours &amp;lt; 2 || neighbours &amp;gt; 3) ? &amp;quot; &amp;quot; : &amp;quot;*&amp;quot;;
            } else {
                output += (neighbours == 3) ? &amp;quot;*&amp;quot; : &amp;quot; &amp;quot;;
            } 
        } while (++cell &amp;lt; len); 
        return output;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This runs one generation of the &lt;a href=&#34;http://www.math.com/students/wonders/life/life.html&#34;&gt;game of life&lt;/a&gt;, taking an input playing field and building an output string. What&amp;rsquo;s remarkable about this is that I wrote it after a day of looking at C# code, with no prior exposure to Java. C# is certainly easy to pick up.&lt;/p&gt;

&lt;p&gt;What can Perl learn from C#? That&amp;rsquo;s an interesting question, especially as the Perl 6 design project is ongoing. Let&amp;rsquo;s have a a quick look at some of the innovations in C# and how we might apply them to Perl.&lt;/p&gt;

&lt;h4 id=&#34;strong-names&#34;&gt;Strong Names&lt;/h4&gt;

&lt;p&gt;We&amp;rsquo;ll start with an easy one, since Larry has already said that something like this will already be in Perl 6: To avoid versioning clashes and interface incompatibilities, .NET has the concept of &amp;ldquo;strong names.&amp;rdquo; Assemblies &amp;ndash; the C# equivalent of Java&amp;rsquo;s &lt;code&gt;jar&lt;/code&gt; files &amp;ndash; have metadata containing their name, version number, md5sum and cryptographic signature, meaning you can be sure you&amp;rsquo;re always going to get the definitions and behavior you&amp;rsquo;d expect from any third-party code you run. More generally, assemblies support arbitrary metadata that you can use to annotate their contents.&lt;/p&gt;

&lt;p&gt;This approach to versioning and metadata in Perl 6 was highlighted in Larry&amp;rsquo;s &lt;a href=&#34;http://localhost:1313/pub/2001/07/25/onion.html&#34;&gt;State of the Onion&lt;/a&gt; talk this year, and is also the solution used by JavaScript 2.0, as described by Waldemar Horwat at his &lt;a href=&#34;http://localhost:1313/pub/2001/11/21/lightweight.html&#34;&gt;LL1 presentation&lt;/a&gt;, so it seems to be the way the language world is going.&lt;/p&gt;

&lt;h4 id=&#34;properties&#34;&gt;Properties&lt;/h4&gt;

&lt;p&gt;C# supports properties, which are class fields with explicit get/set methods. This is slightly akin to Perl&amp;rsquo;s tying, but much, much slicker. Here&amp;rsquo;s an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    private int MyInt;
    public int SomeInt {
        get {
            Console.WriteLine(&amp;quot;I was got.\n&amp;quot;);
            return MyInt;
        }
        set {
            Console.WriteLine(&amp;quot;I was set.\n&amp;quot;);
            MyInt = value;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whenever we access &lt;code&gt;SomeInt&lt;/code&gt;, the &lt;code&gt;get&lt;/code&gt; accessor is executed, and returns the value of the underlying &lt;code&gt;MyInt&lt;/code&gt; variable; when we write to it, the corresponding &lt;code&gt;set&lt;/code&gt; accessor is called. Here&amp;rsquo;s one suggested way we could do something similar in Perl 6:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      my $myint;
      our $SomeInt :get(sub{ print &amp;quot;I was got!\n&amp;quot;; $myint })
                   :set(sub{ print &amp;quot;I was set!\n&amp;quot;; $myint = $^a });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C# actually takes this idea slightly further, providing &amp;ldquo;indexers&amp;rdquo;, which are essentially tied arrays:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    private String realString;
    public String substrString[int idx] {
        get {
            return realString.Substring(idx, 1);
        }
        set {
            realString = realString(0, idx) + value + realString(idx+1);
        }
    }

    substrString[12] = &amp;quot;*&amp;quot;; // substr($string, 12, 1) = &amp;quot;*&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;object-value-duality&#34;&gt;Object-Value Duality&lt;/h4&gt;

&lt;p&gt;Within the CLR type system, (CTS) there are two distinct types (as it were) of types: reference types and value types. Value types are the simple, honest-to-God values: integers, floating point numbers, strings, and so on. Reference types, on the other hand, are objects, references, pointers and the like.&lt;/p&gt;

&lt;p&gt;Now for the twist: Each value type has an associated reference type, and you can convert values between them. So, if you&amp;rsquo;ve got an &lt;code&gt;int counter;&lt;/code&gt;, then you can &amp;ldquo;box&amp;rdquo; it as an object like so: &lt;code&gt;Object CounterObj = counter&lt;/code&gt;. More specifically, &lt;code&gt;int&lt;/code&gt; corresponds to &lt;code&gt;Int32&lt;/code&gt;. This gives us the flexibility of objects when we need to, for instance, call methods on them, but the speed of fixed values when we&amp;rsquo;re doing tight loops on the stack.&lt;/p&gt;

&lt;p&gt;While Perl is and needs to remain an essentially untyped language, optional explicit typing definitions combined with object-value duality could massively up Perl&amp;rsquo;s flexibility as well as bringing some potential optimizations.&lt;/p&gt;

&lt;h4 id=&#34;chaining-delegates&#34;&gt;Chaining Delegates&lt;/h4&gt;

&lt;p&gt;Here&amp;rsquo;s an extremely rare thing - a non-obvious use of operator overloading that actually makes some sense. In event-driven programming, you&amp;rsquo;ll often want to assign callbacks to happen on a given event. Here&amp;rsquo;s how C# does it: (The following code adapted from &lt;a href=&#34;http://www.csharphelp.com/archives/archive253.html&#34;&gt;Events in C#&lt;/a&gt; by Sanju)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;delegate void ButtonEventHandler(object source, int clickCount);

class Button {
    public event ButtonEventHandler ButtonClick;

    public void clicked(int count) { // Fire the handler
        if (ButtonClick != null) ButtonClick (this,count);
    }
}

public class Dialog {
    public Dialog() {
        Button b = new Button();

        b.ButtonClick += new ButtonEventHandler(onButtonAction);
        b.clicked(1);
    }
}

public void onButtonAction(object source,int clickCount) {
    //Define the actions to be performed on button-click here.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Can you see what&amp;rsquo;s going on? The &amp;ldquo;delegate&amp;rdquo; type &lt;code&gt;ButtonEventHandler&lt;/code&gt; is a function signature that we can use to handle button click events. Our &lt;code&gt;Button&lt;/code&gt; class has one of these handlers, &lt;code&gt;ButtonClick&lt;/code&gt;, which is defined as an &lt;code&gt;event&lt;/code&gt;. In the &lt;code&gt;Dialog&lt;/code&gt; class, we instatiate a new delegate, using the &lt;code&gt;onButtonAction&lt;/code&gt; function to fulfill the role of a &lt;code&gt;ButtonEventHandler&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But notice how we assign it to the &lt;code&gt;Button&lt;/code&gt;&amp;rsquo;s &lt;code&gt;ButtonClick&lt;/code&gt; field - we use addition. We can add more handlers in the same way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    b.ButtonClick += new ButtonEventHandler(myButtonHandler);
    b.ButtonClick += new ButtonEventHandler(otherButtonHandler);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now when the button&amp;rsquo;s &lt;code&gt;clicked&lt;/code&gt; method fires off the delegates, all three of these functions will be called in turn. We might decide that we need to get rid of one of them:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    b.ButtonClick -= new ButtonEventHandler(myButtonHandler);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After that, only the two functions &lt;code&gt;onButtonAction&lt;/code&gt; and &lt;code&gt;otherButtonHandler&lt;/code&gt; are active. Chaining delegates like this is something I haven&amp;rsquo;t seen in any other language, and makes sense for event-based programming; it&amp;rsquo;s something it might be good for Perl 6 to support.&lt;/p&gt;

&lt;h3 id=&#34;mono-and-rotor-running-net&#34;&gt;Mono and Rotor - Running .NET&lt;/h3&gt;

&lt;p&gt;OK, enough talk about C#. Let&amp;rsquo;s go run some.&lt;/p&gt;

&lt;p&gt;Of course, the easiest way to do this at present is to do your development on a Windows box. Just grab a copy of the &lt;a href=&#34;http://msdn.microsoft.com/downloads/default.asp?url=/downloads/sample.asp?url=/msdn-files/027/000/976/msdncompositedoc.xml&#34;&gt;.NET Framework SDK&lt;/a&gt;, (only 137M!) install it, and you have a C# compiler at your disposal which can produce .NET executables running on the Microsoft CLR. This is how I do my C# experimentation - I have a copy of Windows running on a virtual machine, sharing a filesystem with my OS X laptop. I do my editing in my favourite Unix editor, then pop over to the Windows session to run the &lt;code&gt;CSC&lt;/code&gt; compiler.&lt;/p&gt;

&lt;p&gt;I know that for some of us, however, that&amp;rsquo;s not a great solution. Thankfully, the creative monkeys at &lt;a href=&#34;http://www.ximian.com&#34;&gt;Ximian&lt;/a&gt; have been feverishly working on bringing us an open-sourced .NET Framework implementation. The &lt;a href=&#34;http://www.go-mono.com&#34;&gt;Mono&lt;/a&gt; project comprises of an implementation of the Common Language Runtime plus a C# compiler and other goodies; a very easy way to get started with .NET is to pick up a release of Mono, and compile and install it.&lt;/p&gt;

&lt;p&gt;After the usual &lt;code&gt;./configure;make;make install&lt;/code&gt;, you have three new commands at your disposal: &lt;code&gt;mcs&lt;/code&gt; is the Mono C# compiler; &lt;code&gt;mint&lt;/code&gt; is the CLR Interpreter; and &lt;code&gt;mono&lt;/code&gt; is its JITted cousin.&lt;/p&gt;

&lt;p&gt;And yes, Veronica, you can run .NET &lt;code&gt;EXE&lt;/code&gt; files on Linux. Let&amp;rsquo;s take the first C# example from the top of this article, and run it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; % mcs -o hello.exe hello.cs
 % mono hello.exe A Test Program
Hello World
Command-line argument: A
Command-line argument: Test
Command-line argument: Program
RESULT: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And just to show you we&amp;rsquo;re not messing you around:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; % file hello.exe
hello.exe: MS Windows PE 32-bit Intel 80386 console executable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mono isn&amp;rsquo;t a particularly quick runtime, nor is it particularly complete, but it has a large number of hackers improving its base classes every day. It runs a large percentage of the .NET executables I throw at it, and the &lt;code&gt;mcs&lt;/code&gt; compiler can now compile itself, so you can do all your development using open source tools.&lt;/p&gt;

&lt;p&gt;Another option, once it appears, is Microsoft&amp;rsquo;s &lt;a href=&#34;http://www.oreillynet.com/pub/dotnet/2002/03/04/rotor.html&#34;&gt;Rotor&lt;/a&gt; project, a shared source CLR and compiler suite. Rotor aims to be the ECMA standard implementation of the .NET Framework; Microsoft has submitted the Framework for standardization, but in typical style, its own implementations add extra functionality not part of the standard. Oh, and in case the words &amp;ldquo;shared source&amp;rdquo; haven&amp;rsquo;t jumped out at you yet, do not even &lt;em&gt;consider&lt;/em&gt; looking at Rotor if you may work on Mono at some point. However, for the casual user, its comprehensive implementation means it will be a better short-term choice for .NET experimentation - again, once it&amp;rsquo;s released.&lt;/p&gt;

&lt;h3 id=&#34;clr-architecture&#34;&gt;CLR Architecture&lt;/h3&gt;

&lt;p&gt;Before we finish considering how Perl and the .NET Framework relate to each other, let&amp;rsquo;s take a more in-depth look at the internals of the Common Language Runtime compared to our own Parrot.&lt;/p&gt;

&lt;p&gt;First, the CLR is a stack-based virtual machine, as opposed to Parrot&amp;rsquo;s register approach. I don&amp;rsquo;t know why this approach was taken, other than, I imagine, &amp;ldquo;because everyone else does it.&amp;rdquo; CLR runs a bytecode language, which Microsoft calls MS-IL when it is talking about their implementation of CLR, and what it calls CIL (Common Intermediate Language) to ECMA. It&amp;rsquo;s object-oriented assembler, a true horror to behold, but it works. Here&amp;rsquo;s a fragment of the IL for our Hello example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    .method public static 
           default void Main(string[] args)  cil managed 
    {
        // Method begins at RVA 0x2090
        .entrypoint
        // Code size 78 (0x4e)
        .maxstack 9
        .locals (
                string  V_0,
                string[]        V_1,
                int32   V_2)
        IL_0000: ldstr &amp;quot;Hello World&amp;quot;
        IL_0005: call void System.Console::WriteLine(string)
        IL_000a: ldarg.s 0
     ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to optimize CLR for JITting, it imposes a number of restrictions on the IL. For instance, the stack may only be used to store parameters and return values from operations and calls; you can&amp;rsquo;t access arbitrary points in the stack; more significantly, the types of values on the stack have to be statically determinable and invariant. That&amp;rsquo;s to say, at a given call in the code, you know for sure what types of things are on the stack at the time.&lt;/p&gt;

&lt;p&gt;The types themselves are part of the Common Type System, something every language compiling to .NET has to conform to. As we have mentioned, CTS types are either value types or reference types. There&amp;rsquo;s a smaller subset of CTS called the Common Language Specification, CLS. Languages &lt;strong&gt;must&lt;/strong&gt; implement CLS types, and may implement their own types as part of the CTS. The CLS ought to be used in all &amp;ldquo;outward-facing&amp;rdquo; APIs where two different languages might meet; the idea being the data passed between two languages is guaranteed to have a known meaning and semantics. However, this API restriction is not enforced by the VM.&lt;/p&gt;

&lt;p&gt;Types which can appear on the stack are restricted again; you&amp;rsquo;re allowed int32, int64, int, float, a reference, a &amp;ldquo;managed&amp;rdquo; pointer or an unmanaged pointer. &amp;ldquo;Management&amp;rdquo; is determined by where the pointer comes from (trusted code is managed) and influences what it&amp;rsquo;s allowed to see and how it gets GCed. Local arguments may live somewhere other than on the main stack - this is implementation-defined - in which case they have access to a richer set of types; but since you have a reference to an object, you should be OK.&lt;/p&gt;

&lt;p&gt;Other value types include structures and enumerations. Since value types are passed around on the stack, you can&amp;rsquo;t really have big structures, since you&amp;rsquo;d be passing loads of data. There&amp;rsquo;s also the typed reference, which is a reference plus something storing what sort of reference it is. Reference types are kept in the heap, managed by garbage collection, and are referenced on the stack. This is not unlike what Parrot does with PMC and non-PMC registers.&lt;/p&gt;

&lt;p&gt;Like Java, the CLR has a reasonably small number of operations. You can load/store constants, local variables, arguments, fields and array elements; you can create and dereference pointers; you can do arithmetic; you can do conversion, casting and truncating; there are branch ops (including a built-in lookup-table switch op) and method call ops; there&amp;rsquo;s a special tail-recursion method-call op; you can throw and handle exceptions; you can box and unbox, converting value types to reference types and vice verca; you can create an array and find its length; you can handle typed references. And that&amp;rsquo;s essentially it. Anything else is outside the realm of the CLR, and has to be implemented with external methods.&lt;/p&gt;

&lt;p&gt;An excellent paper comparing the CLR and the JVM has been produced by the team working on Component Pascal; they&amp;rsquo;ve ported CP to both virtual machines, and so are very well-placed to run a comparison. See the &lt;a href=&#34;http://www2.fit.qut.edu.au/CompSci/PLAS//ComponentPascal/&#34;&gt;GPCP project page&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;perl-and-net&#34;&gt;Perl and .NET&lt;/h3&gt;

&lt;p&gt;How can we connect Perl and .NET? Well, let&amp;rsquo;s look at the pieces of work that have already been done in this area. ActiveState have been leading research, with their experimental &lt;a href=&#34;http://www.activestate.com/Initiatives/NET/Research.html&#34;&gt;Perl for .NET Research&lt;/a&gt; and &lt;a href=&#34;http://www.activestate.com/PerlNET/&#34;&gt;PerlNET&lt;/a&gt; projects.&lt;/p&gt;

&lt;p&gt;Perl for .NET Research was a brave idea; Jan Dubois essentially wrote a Perl interpreter in C#, and used the standard Perl compilation technique of combining an embedded interpreter with a serialized representation of the Perl program. The resulting compiler is a C# analog of the &lt;code&gt;B::CC&lt;/code&gt; module, and then runs the &lt;code&gt;CSC&lt;/code&gt; compiler to compile the C# representation of the Perl program, linking in the Perl interpreter, into an executable. To be honest, I couldn&amp;rsquo;t get Perl for .NET Research to produce executables, but I could study it enough to see what it was doing.&lt;/p&gt;

&lt;p&gt;PerlNET, now included with AS&amp;rsquo;s Perl Dev Kit, takes a rather different approach. This time the Perl interpreter sits &amp;ldquo;outside&amp;rdquo; the .NET Framework, communicating with it through DLLs. This allows for .NET Framework code to call into Perl, and also for Perl to make calls into the .NET Framework library. For instance, one may write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use namespace &amp;quot;System&amp;quot;;
    Console-&amp;gt;WriteLine(&amp;quot;Hello World!&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to call the &lt;code&gt;System.Console.WriteLine&lt;/code&gt; method in the .NET Framework runtime library.&lt;/p&gt;

&lt;p&gt;However, neither of these initiatives compile Perl to MS-IL in the usual sense of the word. This is surprising, since it would be an interesting test of the flexibility of the Common Type System.&lt;/p&gt;

&lt;p&gt;This is one of the possible avenues I&amp;rsquo;d like to see explored in terms of bringing .NET and Perl closer together. Other possibilities include crossover between CLR and Parrot - I&amp;rsquo;d love to see .NET executables run on top of Parrot and Parrot bytecode files convertable to .NET; I&amp;rsquo;d like to see a Perl 6 interpreter emit MS-IL; I&amp;rsquo;d like to see Perl programs sharing data and objects with other languages on top of some virtual machine.&lt;/p&gt;

&lt;p&gt;Like it or not, there&amp;rsquo;s a good chance that the .NET Framework is going to be a big part of the technological scene in the future. I hope after this brief introduction, you&amp;rsquo;re a little more prepared for it when it happens, and we have some direction as to how Perl fits into it.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;For more on .NET, check O&amp;rsquo;Reilly Network&amp;rsquo;s &lt;a href=&#34;http://oreillynet.com/dotnet&#34;&gt;.NET DevCenter&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

