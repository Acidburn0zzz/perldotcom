<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tie File on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/tie-file/</link>
    <description>Recent content in Tie File on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 16 Sep 2004 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/tie-file/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Embedded Databases</title>
      <link>http://localhost:1313/pub/2004/09/12/embedded.html/</link>
      <pubDate>Thu, 16 Sep 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/09/12/embedded.html/</guid>
      <description>

&lt;p&gt;The expression &amp;ldquo;Embedded Database&amp;rdquo; requires an explanation. A &amp;ldquo;database&amp;rdquo; is an application that allows the targeted retrieval of stored data &amp;ndash; a log-file is not a database. By &amp;ldquo;embedded&amp;rdquo; I mean a database that does not run in a separate process, but instead is directly linked (&amp;ldquo;embedded&amp;rdquo;) into the application requiring access to the stored data. This is in contrast to more conventional database management systems (such as Postgres or Oracle), which run as a separate process, and to which the application connects using some form of Inter Process Communication (such as TCP/IP sockets, for instance).&lt;/p&gt;

&lt;p&gt;The prime advantage of embedded database systems lies in their availability and ease of administration. Since the data is kept in ordinary files in the user&amp;rsquo;s space, there is no need to obtain special permissions to connect to the database process or to obtain a database account. Furthermore, since embedded databases require nothing more than a normal library, they can be useful in constrained environments (think shared web hosting), where no &amp;ldquo;proper&amp;rdquo; database is available. They can even be linked to an application and shipped with it.&lt;/p&gt;

&lt;h3 id=&#34;sequential-access-tie-file&#34;&gt;Sequential Access: &lt;code&gt;Tie::File&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;The simplest database is still a flat file of records, separated by a record separator. If the separator is chosen to be the new line character &lt;code&gt;&amp;quot;\n&amp;quot;&lt;/code&gt;, as it usually is, then a record corresponds to a line.&lt;/p&gt;

&lt;p&gt;Flat files allow only sequential access. This can be both a blessing and a curse: if the application primarily requires the lookup of individual records in arbitrary order, then flat files become impractical once the number of records becomes too large. On the other hand, if the typical access pattern is sequential for at least a substantial subset of records, then a flat file can be very practical.&lt;/p&gt;

&lt;p&gt;Here is a typical (if a little construed) example: Assume that we have several thousand very long strings (say, each string having more than one million characters) and we want to determine whether any two strings are equal. To do so, we have to compare each string to all remaining ones, using two nested loops. However, the total amount of data is too large to be all kept in memory. On the other hand, we access &lt;em&gt;all&lt;/em&gt; the records in a predictable, sequential order.&lt;/p&gt;

&lt;p&gt;The Perl module &lt;code&gt;Tie::File&lt;/code&gt; allows us to do so in a particularly convenient fashion: it &lt;code&gt;tie&lt;/code&gt;s a Perl array to the file in such a way that each record corresponds to an element of the array.&lt;/p&gt;

&lt;p&gt;Here then is a code snippet that demonstrates the use of &lt;code&gt;Tie::File&lt;/code&gt; to our string comparison problem introduced above:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Tie::File;

tie @array, &#39;Tie::File&#39;, &#39;data.txt&#39; or die &amp;quot;Could not tie to file: $!&amp;quot;;

$len = scalar( @array );

for( $i=0; $i&amp;lt;$len; $i++ ) {
  $string1 = $array[$i];

  for( $j=$i; $j&amp;lt;$len; $j++ ) {
    $string2 = $array[$j];

    compare_strings( $string1, $string2 );
  }
}

untie @array;

sub compare_strings {
  my ( $s1, $s2 ) = @_;

  # do something smart...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is no question that this program requires heavy disk access, and if we had additional information about the data in question, we should try hard to use it and avoid the brute force approach of comparing &amp;ldquo;everything to everything&amp;rdquo;. However, if we have no choice, then &lt;code&gt;Tie::File&lt;/code&gt; makes code like the above as efficient as can be: It does not attempt to load the entire file into memory, so that arbitrarily large files can be processed. The first time we iterate over the file, &lt;code&gt;Tie::File&lt;/code&gt; builds up an index containing the offset of each record from the beginning of the file, so that subsequent accesses can go directly to the proper position in the file using &lt;code&gt;seek()&lt;/code&gt;. Finally, accessed records are cached in memory and the cache size can be adjusted passing the &lt;code&gt;memory&lt;/code&gt; option to the &lt;code&gt;tie&lt;/code&gt; command.&lt;/p&gt;

&lt;p&gt;However, any changes to the array (and its underlying file), in particular insertions and deletions in the middle, will always be slow, since all the subsequent records will have to be moved. If your application requires such capabilities, don&amp;rsquo;t use &lt;code&gt;Tie::File&lt;/code&gt;, use a Berkeley DB!&lt;/p&gt;

&lt;h3 id=&#34;fast-lookup-berkeley-db&#34;&gt;Fast Lookup: Berkeley DB&lt;/h3&gt;

&lt;p&gt;A Berkeley DB is almost the exact opposite of a flat file in regards to the access patterns it supports. Scanning through a large number of successive records is difficult if not entirely impossible, but reading, inserting, updating, and deleting random records is very, very fast!&lt;/p&gt;

&lt;p&gt;Conceptually, a Berkeley DB is a hash, saved to a file. Each record is found by its key, and the value of the record is treated as a string. It is up to the application to interpret this string - for instance, to break it up into parts, representing different fields.&lt;/p&gt;

&lt;p&gt;The following code opens a Berkeley DB (creating a new file, if necessary) and writes a single record, containing information suitable for the &lt;code&gt;/etc/passwd&lt;/code&gt; file. We then look up the same record, using the login name as key, and &lt;code&gt;split&lt;/code&gt; the data into its constituent fields.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use BerkeleyDB;

$login = &#39;root&#39;;
@info  = ( 0, 0, &#39;SuperUser&#39;, &#39;/root&#39;, &#39;/bin/tcsh&#39; );

$db = new BerkeleyDB::Hash( -Filename =&amp;gt; &#39;data.dbm&#39;,
                -Flags =&amp;gt; DB_CREATE ) or die &amp;quot;Cannot open file: $!&amp;quot;;

$db-&amp;gt;db_put( $login, join(&#39;:&#39;, @info) );

$db-&amp;gt;db_get( $login, $val );

( $uid, $gid, $name, $home, $shell ) = split &#39;:&#39;, $val;

print &amp;quot;$login:\t$uid|$gid $name \t$home\t$shell\n&amp;quot;;

$db-&amp;gt;db_close();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above uses the Perl interface to the Berkeley DB modelled after its C API. The &lt;code&gt;BerkeleyDB&lt;/code&gt; module also supports a &lt;code&gt;tie&lt;/code&gt; interface, tying the database file to a Perl hash, making code like the following possible: &lt;code&gt;$hash{ $login } = join( &#39;:&#39;, @info );&lt;/code&gt;. The API-style interface, on the other hand, follows the native interface of the Berkeley DB quite closely, which means that most of the (quite extensive) original C API documentation also applies when programming Perl - which is good, since the perldoc for &lt;code&gt;BerkeleyDB&lt;/code&gt; is a bit sketchy in places. Try &lt;code&gt;man db_intro&lt;/code&gt; to get started on the native Berkeley DB interface, or visit the Berkeley DB&amp;rsquo;s homepage.&lt;/p&gt;

&lt;p&gt;Complex data structures can be stored in a Berkeley DB provided they have been serialized properly. If a simple solution using &lt;code&gt;join&lt;/code&gt; and &lt;code&gt;split&lt;/code&gt; as demonstrated above is not sufficient, we can use modules such as &lt;code&gt;Data::Dumper&lt;/code&gt; or (better) &lt;code&gt;Storable&lt;/code&gt; to obtain a flat string representation suitable for storage in the Berkeley DB. There is also the &lt;code&gt;MLDBM&lt;/code&gt; (&amp;ldquo;Mulit-Level DBM&amp;rdquo;) module, which provides a convenient wrapper interface, bundling serialization and storage.&lt;/p&gt;

&lt;p&gt;For suitable problems, solutions based on Berkeley DBs can work very well. However, there are a couple of problems. One is that the Berkeley DB must be available - it has to be installed separately (usually as &lt;code&gt;/usr/lib/libdb.so&lt;/code&gt;). The bigger limitation is that although there are quite a few problems out there for which a single-key lookup is sufficient, for many applications such a simple access pattern will not work. This is when we require a relational database &amp;ndash; such as SQLite.&lt;/p&gt;

&lt;h3 id=&#34;complex-queries-sqlite&#34;&gt;Complex Queries: SQLite&lt;/h3&gt;

&lt;p&gt;There are situations when neither of the aforementioned straightforward access patterns applies. Berkeley DBs are great if we know the key for the record - but what happens if we only know part of the key, or we are interested in a set of records, all matching some pattern or logical expression? Alas, the Berkeley DB does not allow wildcard searches. Another frequently arising problem occurs when each record has several fields or attributes and we want to be able to look up records by either one of them (such as being able to search a list of books by author as well as title). This can be achieved in a Berkeley DB using multiple lookups, but one can&amp;rsquo;t help thinking that there &lt;em&gt;got&lt;/em&gt; to be a better way! Finally, the simple key/value mapping of the Berkeley DB occasionally forces duplication of data, since all the relevant information has to be present in each record - this both wastes storage space and creates maintenance problems.&lt;/p&gt;

&lt;p&gt;Relational databases address all these points. They permit wildcard and logical expression searches, multiple searchable columns, and joins to represent relationships. Unfortunately, search capabilities such as these used to be restricted to big, standalone relational database engines (such as Postgres or Oracle), often making them unavailable for the quick-and-dirty Perl project.&lt;/p&gt;

&lt;p&gt;This is where the SQLite project comes in: Founded in 2000, SQLite tries to combine the convenience of the Berkeley DB architecture with the power of a relational (SQL) database. Its latest release is version 2.8.14, with the next major revision, version 3.0, currently in beta. SQLite implements most of standard SQL (with some exceptions, such as correlated subqueries).&lt;/p&gt;

&lt;p&gt;However, with added power comes additional complexity: a relational database no longer &lt;code&gt;tie&lt;/code&gt;s neatly to one of Perl&amp;rsquo;s built-in data structures. Instead, one has to use the &lt;code&gt;DBI&lt;/code&gt; (DataBaseInterface) module and code the queries in SQL. Furthermore, since the structure of the data is no longer predetermined, the programmer has to define and construct the required tables explicitly.&lt;/p&gt;

&lt;p&gt;This is not the place for a full discussion of the Perl-DBI, but the example below is enough to get started. First, SQLite has to be installed on the system. Conveniently, the DBI-driver for SQLite, &lt;code&gt;DBD::SQLite&lt;/code&gt;, already contains the database engine itself as part of the module - so installing this module is all that is required to be able to use SQLite from Perl.&lt;/p&gt;

&lt;p&gt;We begin by &lt;code&gt;connecting&lt;/code&gt; to the SQLite database contained in the file &amp;ldquo;&lt;code&gt;data.dbl&lt;/code&gt;&amp;rdquo;. Note that the &lt;code&gt;connect&lt;/code&gt; method loads the appropriate database driver - all we need to do is specify &lt;code&gt;use DBI;&lt;/code&gt;. We create and populate two tables, and then run a query joining the two tables and using an SQL wildcard. The results are returned as a reference to an array. Each array element is an array itself, containing the column values in its elements.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use DBI;

$dbh = DBI-&amp;gt;connect( &amp;quot;dbi:SQLite:data.dbl&amp;quot; ) || die &amp;quot;Cannot connect: $DBI::errstr&amp;quot;;


$dbh-&amp;gt;do( &amp;quot;CREATE TABLE authors ( lastname, firstname )&amp;quot; );
$dbh-&amp;gt;do( &amp;quot;INSERT INTO authors VALUES ( &#39;Conway&#39;, &#39;Damian&#39; ) &amp;quot; );
$dbh-&amp;gt;do( &amp;quot;INSERT INTO authors VALUES ( &#39;Booch&#39;, &#39;Grady&#39; ) &amp;quot; );

$dbh-&amp;gt;do( &amp;quot;CREATE TABLE books ( title, author )&amp;quot; );
$dbh-&amp;gt;do( &amp;quot;INSERT INTO books VALUES ( &#39;Object Oriented Perl&#39;,
                                          &#39;Conway&#39; ) &amp;quot; );
$dbh-&amp;gt;do( &amp;quot;INSERT INTO books VALUES ( &#39;Object-Oriented Analysis and Design&#39;,
                                          &#39;Booch&#39; ) &amp;quot;);
$dbh-&amp;gt;do( &amp;quot;INSERT INTO books VALUES ( &#39;Object Solutions&#39;, &#39;Booch&#39; ) &amp;quot; );


$res = $dbh-&amp;gt;selectall_arrayref( q( SELECT a.lastname, a.firstname, b.title
                    FROM books b, authors a
                    WHERE b.title like &#39;%Orient%&#39;
                    AND a.lastname = b.author ) );

foreach( @$res ) {
  print &amp;quot;$_-&amp;gt;[0], $_-&amp;gt;[1]:\t$_-&amp;gt;[2]\n&amp;quot;;
}

$dbh-&amp;gt;disconnect;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;books&lt;/code&gt; table references the &lt;code&gt;authors&lt;/code&gt; table via a foreign key. This is a one-to-many relationship: each book has only a single author, but an author can have written multiple books. What would we have done if books could have been co-authored by multiple writers? We would have used a cross-reference table to represent the resulting many-to-many relationship. Try &lt;em&gt;that&lt;/em&gt; with Berkeley DBs!&lt;/p&gt;

&lt;p&gt;SQLite shares with the Berkeley DB the approach of being mostly typeless and treating data as simple strings. In our table definitions above, we did not specify the data types of any of the columns, as would be required by Oracle or Postgres. SQLite provides a bit more structure, in that it provides separate columns, so that distinct values do not have to be glued together to form a string, as was required when using a Berkeley DB. Furthermore, SQLite will try to convert strings to floating point numbers if numerical comparisons or operations (such as &lt;code&gt;SUM&lt;/code&gt; or &lt;code&gt;AVG&lt;/code&gt;) are performed on them.&lt;/p&gt;

&lt;p&gt;Since SQLite is a relational database, the data architecture (the &amp;ldquo;schema&amp;rdquo;) can be arbitrarily complex, with data distributed across multiple tables and with foreign keys to represent relationships. This is a big topic &amp;ndash; any book on the relational model will provide plenty of information, including issues such as database normalization and tools such as Entity/Relationship-Models.&lt;/p&gt;

&lt;h3 id=&#34;summary&#34;&gt;Summary&lt;/h3&gt;

&lt;p&gt;In this paper, we considered three ways to add database capabilities to a Perl program, without requiring major external database installations or administrative support. Depending on the typical access patterns, flat files or Berkeley DBs may be suitable choices. For more complex queries, the SQLite project provides all the power of relational database architecture in a single Perl DBD module.&lt;/p&gt;

&lt;h3 id=&#34;resources&#34;&gt;Resources&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://perl.plover.com/TieFile&#34;&gt;&lt;code&gt;Tie::File&lt;/code&gt; Home Page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.sleepycat.com/&#34;&gt;Berkeley DB Home Page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.sqlite.org/&#34;&gt;SQLite Home Page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/DBD::SQLite&#34;&gt;Perl DBI Driver for SQLite on CPAN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www-106.ibm.com/developerworks/web/library/wa-dbdsgn2.html&#34;&gt;Practical Database Design&lt;/a&gt; A brief introduction to the representation of relationships in relational DBs and to DB Normalization.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>

