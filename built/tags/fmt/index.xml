<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Fmt on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/fmt/</link>
    <description>Recent content in Fmt on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 07 Feb 2017 08:26:00 +0000</lastBuildDate>
    <atom:link href="/tags/fmt/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Six more things I like about 6</title>
      <link>http://localhost:1313/article/6-more-things-about-6/</link>
      <pubDate>Tue, 07 Feb 2017 08:26:00 +0000</pubDate>
      
      <guid>http://localhost:1313/article/6-more-things-about-6/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://www.theperlshop.com&#34;&gt;The Perl Shop&lt;/a&gt; recently sponsored me to speak about Perl 6 at a meeting of the &lt;a href=&#34;http://boston.pm.org&#34;&gt;Boston Perl mongers&lt;/a&gt;. They had backed the Kickstarter project for &lt;a href=&#34;https://www.learningperl6.com&#34;&gt;Learning Perl 6&lt;/a&gt;. As part of that, I&amp;rsquo;m giving talks to Perl mongers groups about what I like about the language. These aren&amp;rsquo;t necessarily the most exciting or advanced features or the newest computer science features. They are merely things that I like.&lt;/p&gt;

&lt;p&gt;Many of these features are scattered across the languages landscape, and I&amp;rsquo;ve long said that I&amp;rsquo;d gladly abandon Perl when I found a language I liked better. Now I&amp;rsquo;m getting some of the features I may have coveted in languages that are missing some of the stuff I still enjoy about Perl.&lt;/p&gt;

&lt;h3 id=&#34;rats&#34;&gt;Rats&lt;/h3&gt;

&lt;p&gt;Perl 6 can maintain precision as long as possible by keeping rational numbers as ratios instead of making them native floating points (although you can still do that too). This means that we don&amp;rsquo;t have to deal with the variety of problems that come with relying on the underlying storage.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl5 -le &#39;print 0.3 - 0.2 - 0.1&#39;
-2.77555756156289e-17
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s a little off, but we&amp;rsquo;ve come to accept that (for example, multiplying all money amounts so you only deal in integers). Perl 6 however, stores them exactly as long as it can:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl6
To exit type &#39;exit&#39; or &#39;^D&#39;
&amp;gt; my $rat = 0.3
0.3
&amp;gt; $rat.numerator
3
&amp;gt; $rat.denominator
10
&amp;gt; 0.3 - 0.2 - 0.1
0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A repeating decimal is still a rational number, although Perl 6 doesn&amp;rsquo;t yet have a feature to put the overbar on the repeating part:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; &amp;lt;1/3&amp;gt;
0.333333
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;soft-failures&#34;&gt;Soft Failures&lt;/h3&gt;

&lt;p&gt;Perl 6 has &lt;a href=&#34;https://docs.perl6.org/type/Failure&#34;&gt;Failure&lt;/a&gt; objects, which wrap an exception. Many things may return such an object when something goes wrong. A &lt;a href=&#34;https://docs.perl6.org/type/Failure&#34;&gt;Failure&lt;/a&gt; is always &lt;code&gt;False&lt;/code&gt; in Boolean context, but Perl 6 also marks it as handled when it&amp;rsquo;s checked like that. Otherwise, if I try to use that object as if everything succeeded, it immediately throws its exception:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $file &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;not-there&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;unless&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $fh &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; open $file {
	put &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;In unless: exception is {$fh.exception.^name}&amp;#34;&lt;/span&gt;
	}

CATCH {
	put &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Caught {.^name}: {.message}&amp;#34;&lt;/span&gt;;
	}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The output shows that I handled the problem in the &lt;code&gt;unless&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;In unless: exception is X::AdHoc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compare this with code that doesn&amp;rsquo;t check the result of the &lt;code&gt;open&lt;/code&gt; and keep going as if the filehandle is good:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $file &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;not-there&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $fh &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; open $file;

$fh&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;lines;

CATCH {
	put &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Caught {.^name}: {.message}&amp;#34;&lt;/span&gt;;
	}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now the exception takes over and the &lt;code&gt;CATCH&lt;/code&gt; block handles it. There&amp;rsquo;s a strack trace that comes with that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Caught X::AdHoc: Failed to open file not-there: no such file or directory
Failed to open file not-there: no such file or directory
  in any  at ... CORE.setting.moarvm line 1
  in block &amp;lt;unit&amp;gt; at ...

Actually thrown at:
  in block &amp;lt;unit&amp;gt; at ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I love that this lets me decide how to check the error. I&amp;rsquo;ve always thought that the various syntaxes for &lt;code&gt;try&lt;/code&gt; (in any language) bullied their ways into the language and took over the source code.&lt;/p&gt;

&lt;p&gt;And, I&amp;rsquo;m sufficiently besotted with this idea of object-oriented programming that I have a Perl 5 module that does a similar thing: &lt;a href=&#34;https://metacpan.org/pod/ReturnValue&#34;&gt;ReturnValue&lt;/a&gt;. I use that to return values where the caller can determine what happened by calling methods on the result.&lt;/p&gt;

&lt;h3 id=&#34;resumable-exceptions&#34;&gt;Resumable Exceptions&lt;/h3&gt;

&lt;p&gt;So let&amp;rsquo;s talk about exceptions. I haven&amp;rsquo;t liked the fake ones people tried to push on me in Perl 5. If I can&amp;rsquo;t actually handle it and continue the program, I don&amp;rsquo;t think it&amp;rsquo;s a proper exception. It&amp;rsquo;s just a different way to return a value.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;CATCH {
	default {
		put &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Problem with file: {.^name} --&amp;gt; {.message}&amp;#34;&lt;/span&gt;;
		&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;resume
		}
	}

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $line &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; read&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;a&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;line( &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;not-there&amp;#39;&lt;/span&gt; );

&lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;read&lt;/span&gt;-a-line ( $file ) {
	X::AdHoc&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;( :payload&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Oh &lt;span style=&#34;color:#66d9ef&#34;&gt;no&lt;/span&gt; Mr Bill&lt;span style=&#34;color:#f92672&#34;&gt;!&amp;gt;&lt;/span&gt; )&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;throw;
	say &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hey, I can keep going!&amp;#34;&lt;/span&gt;
	}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I see that &lt;code&gt;CATCH&lt;/code&gt; handled the exception, but then let the code in the subroutine continue:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Problem with file: X::AdHoc --&amp;gt; Oh no Mr Bill!
Hey, I can keep going!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not every exception can resume, but I see a lot of promise in this ability.&lt;/p&gt;

&lt;h3 id=&#34;easier-interpolation&#34;&gt;Easier Interpolation&lt;/h3&gt;

&lt;p&gt;My estimation of a language is mostly based on how easy I can create new strings. Perl 5 was pretty good about that, but Perl 6 is even better.&lt;/p&gt;

&lt;p&gt;Scalars, arrays, and hashes (yes, hashes!) can interpolate directly, although you need to add the subscript characters for the latter two:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;say &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;This one has a $scalar&amp;#34;&lt;/span&gt;;
say &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;The array needs braces: @array[]&amp;#34;&lt;/span&gt;;
say &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;The hash needs curlies: %hash{}&amp;#34;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Better than that, though, is that I can interpolate anything by enclosing it in braces within the string. Perl 6 evaluates the code in the braces and replaces the block with the last evaluated expression:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;say &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;There are { $scalar.elems } elements&amp;#34;&lt;/span&gt;;
say &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;The object&amp;#39;s name is { $object.^name }&amp;#34;&lt;/span&gt;;
say &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;The sum is { 2 + 2 }&amp;#34;&lt;/span&gt;;
say &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;The lowest is { @array.sort.[1] }&amp;#34;&lt;/span&gt;;
say &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;The lowest is { @array.min }&amp;#34;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I could do this with &lt;code&gt;sprintf&lt;/code&gt;, and sometimes I think that&amp;rsquo;s more appropriate. But I&amp;rsquo;ve often played reference-dereference games in strings to do what I can now do by design. I really like this (and so will Ruby programmers, I think).&lt;/p&gt;

&lt;h3 id=&#34;fmt&#34;&gt;fmt&lt;/h3&gt;

&lt;p&gt;Have something in a scalar that you want to format in a different way? There&amp;rsquo;s a method for that. This isn&amp;rsquo;t one of the exciting new features because &lt;code&gt;printf&lt;/code&gt; has been around forever. Similar to the interpolation, this might seem like a small thing, put in the times I&amp;rsquo;ve used it I&amp;rsquo;ve been quite pleased despite the voice at the back of my head that says &amp;ldquo;It&amp;rsquo;s just &lt;code&gt;sprintf&lt;/code&gt; you idiot!&amp;rdquo;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @buffer &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Buf&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;( &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt; );
@buffer&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;map( { &lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;fmt: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%02x&amp;#34;&lt;/span&gt; } )&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;join( &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt; )&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;put;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I forego the parens there and give the arguments to &lt;code&gt;.fmt&lt;/code&gt; by putting a colon after the method name. Since I didn&amp;rsquo;t specify an object this uses the topic (what you call &lt;code&gt;$_&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;For some reason I really like this more than what everyone reading this article is thinking:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$buffer&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;map( { sprintf &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%02x&amp;#34;&lt;/span&gt;, $_ } )&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;join( &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt; )&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;lists-of-lists&#34;&gt;Lists of lists&lt;/h3&gt;

&lt;p&gt;Perl 6 has lists of lists (ever since the &lt;a href=&#34;https://perl6advent.wordpress.com/2015/12/14/day-15-2015-the-year-of-the-great-list-refactor/&#34;&gt;Great List Refactor&lt;/a&gt;). This will be a bit disconcerting to those use to the &amp;ldquo;always flat&amp;rdquo; lists of Perl 5, but I think you&amp;rsquo;ll get used to them. This is quite handy for keeping related values together.&lt;/p&gt;

&lt;p&gt;And, a list is an object, and as a single thingy you can store it in a scalar variable. It knows that it is a list:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $scalar &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ( &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; );
&lt;span style=&#34;color:#75715e&#34;&gt;# my $scalar = 1, 2, 3;  # Nope!&lt;/span&gt;

put &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;scalar: $scalar&amp;#34;&lt;/span&gt;;
put &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;scalar: { $scalar.^name }&amp;#34;&lt;/span&gt;;

scalar: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;
scalar: List&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can have literal lists of lists:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @array &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ( ( &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; ), &lt;span style=&#34;color:#e6db74&#34;&gt;qw/a b/&lt;/span&gt; );

put &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;elems: { @array.elems }&amp;#34;&lt;/span&gt;;
put &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;@array[]&amp;#34;&lt;/span&gt;;  &lt;span style=&#34;color:#75715e&#34;&gt;# the whole thing&lt;/span&gt;
put &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;@array[0]&amp;#34;&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;# the first thing&lt;/span&gt;
put &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;{ @array[0].^name }&amp;#34;&lt;/span&gt;;

&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; a b
&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
List&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But here&amp;rsquo;s something even better. You can go the other way. I go from the flat list of this buffer (list of numbers representing octets in this case) to two-element lists that I can iterate over. This is quite handy for dealing with binary formats:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; Buf $buf &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;
	Buf&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;( &lt;span style=&#34;color:#ae81ff&#34;&gt;0xDE&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0xAD&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0xBE&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0xEF&lt;/span&gt; );

&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; $buf&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;rotor(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; $c {
	put &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;c is $c&amp;#34;&lt;/span&gt;;
	put &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;word is &amp;#34;&lt;/span&gt;,
	( $c[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;+&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; $c[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] )
		&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;fmt( &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;%02X&amp;#39;&lt;/span&gt; );
	}

c is &lt;span style=&#34;color:#ae81ff&#34;&gt;222&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;173&lt;/span&gt;
word is DEAD
c is &lt;span style=&#34;color:#ae81ff&#34;&gt;190&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;239&lt;/span&gt;
word is BEEF&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There&amp;rsquo;s much more that I can write about lists of lists, but this article is long enough already. I&amp;rsquo;ll save some of that for later articles. You can see more of my Perl 6 stuff at &lt;a href=&#34;https://www.learningperl6.com/&#34;&gt;https://www.learningperl6.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

