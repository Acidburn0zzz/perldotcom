<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Spam Vipul S Spamassassin on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/spam-vipul-s-spamassassin/</link>
    <description>Recent content in Spam Vipul S Spamassassin on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 06 Mar 2002 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/spam-vipul-s-spamassassin/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Stopping Spam with SpamAssassin</title>
      <link>http://localhost:1313/pub/2002/03/06/spam.html/</link>
      <pubDate>Wed, 06 Mar 2002 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2002/03/06/spam.html/</guid>
      <description>

&lt;p&gt;I receive a lot of spam; an absolute massive bucket load of spam. I received more than 100 pieces of spam in the first three days of this month. I receive so much spam that &lt;a href=&#34;http://www.spam.com/&#34;&gt;Hormel Foods&lt;/a&gt; sends trucks to take it away. And I&amp;rsquo;m convinced that things are getting worse. We&amp;rsquo;re all being bombarded with junk mail more than ever these days.&lt;/p&gt;

&lt;p&gt;Well, a couple of days ago, I reached my breaking point, and decided that the &lt;a href=&#34;http://localhost:1313/pub/2001/07/17/mailfiltering.html&#34;&gt;simple mail filtering&lt;/a&gt; I had in place up until now just wasn&amp;rsquo;t up to the job. It was time to call in an assassin.&lt;/p&gt;

&lt;h3 id=&#34;spamassassin&#34;&gt;SpamAssassin&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://www.spamassassin.org&#34;&gt;SpamAssassin&lt;/a&gt; is a rule-based spam identification tool. It&amp;rsquo;s written in Perl, and there are several ways of using it: You can call a client program, &lt;code&gt;spamassassin&lt;/code&gt;, and have it determine whether a given message is likely to be spam; you can do essentially the same thing but use a client/server approach so that your client isn&amp;rsquo;t always loading and parsing the rules each time mail comes; or, finally, you can use a Perl module interface to filter spam from a Perl program.&lt;/p&gt;

&lt;p&gt;SpamAssassin is extremely configurable; you can select which rules you want to use, change the way the rules contribute to a piece of mail&amp;rsquo;s &amp;ldquo;spam score,&amp;rdquo; and add your own rules. We&amp;rsquo;ll look at some of these features later in the article. First, how do we get SpamAssassin installed and start using it?&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re using Debian Linux or one of the BSDs, then this couldn&amp;rsquo;t be easier: just install the appropriate package using &lt;code&gt;apt&lt;/code&gt; or the ports tree respectively. (The BSD port is called &lt;code&gt;p5-Mail-SpamAssassin&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;Those less fortunate will have to &lt;a href=&#34;http://www.spamassassin.org/released/Mail-SpamAssassin-2.11.tar.gz&#34;&gt;download&lt;/a&gt; the latest version of SpamAssassin, and install it themselves.&lt;/p&gt;

&lt;h3 id=&#34;vipul-s-razor&#34;&gt;Vipul&amp;rsquo;s Razor&lt;/h3&gt;

&lt;p&gt;SpamAssassin uses a variety of ways for testing whether an e-mail is spam, ranging from simple textual checks on the headers or body and detecting missing or misleading headers to network-based checks such as &lt;a href=&#34;http://www.orbz.org&#34;&gt;relay blackhole lists&lt;/a&gt; and an interesting distributed system called &lt;a href=&#34;http://razor.sourceforge.net/&#34;&gt;Vipul&amp;rsquo;s Razor&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Vipul&amp;rsquo;s Razor takes advantage of the fact that spam is, by its nature, distributed in bulk. Hence, a lot of the spam that you see, I&amp;rsquo;m also going to see at some point. If there were a big clearing-house where you could report spam and I could see if my incoming mail matches what you&amp;rsquo;ve already reported, then I could have a guaranteed way of determining whether a given mail is spam. Vipul&amp;rsquo;s Razor is that clearing-house.&lt;/p&gt;

&lt;p&gt;Why is it a Razor? Because it&amp;rsquo;s a collaborative system, its strength is directly derived from the quality of its database, which comes back to the way it&amp;rsquo;s used by the likes of you and me. If end-users report lots of real spam, the Razor gets better; if the database gets &amp;ldquo;poisoned&amp;rdquo; by lots of false or misleading reports, then the efficiency of the whole system drops.&lt;/p&gt;

&lt;p&gt;Just like any other spam detection mechanism, Razor isn&amp;rsquo;t perfect. There are two points particularly worth noting. First, while it tries to completely avoid false positives (saying something&amp;rsquo;s spam when it isn&amp;rsquo;t) by requiring that spam be reported, it doesn&amp;rsquo;t do anything about false negatives (saying something&amp;rsquo;s not spam when it is) because it only knows about the mail in its database.&lt;/p&gt;

&lt;p&gt;Second, spammers, like all other primitive organisms, are constantly evolving. Vipul&amp;rsquo;s Razor only works for spam that is delivered in bulk without modification. Spam that is &amp;ldquo;personalized&amp;rdquo; by the addition of random spaces, letters or the name of the recipient, will produce a different signature that won&amp;rsquo;t match similar spam messages in the Razor database.&lt;/p&gt;

&lt;p&gt;Nevertheless, the Razor is an excellent addition to the spam fighter&amp;rsquo;s arsenal, since when it marks something as spam, you can be almost positive it&amp;rsquo;s correct. And just like SpamAssassin, it&amp;rsquo;s all pure Perl. &lt;code&gt;Mail::Audit&lt;/code&gt; has long supported a Razor plugin, but now we can move to calling Razor as part of a more comprehensive mail filtering system based on SpamAssasin and &lt;code&gt;Mail::Audit&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Installing Vipul&amp;rsquo;s Razor is similar to installing SpamAssassin. Debian and BSD users have packages called &amp;ldquo;razor&amp;rdquo; and &amp;ldquo;razor-clients,&amp;rdquo; respectively; and the rest of the world can download and install from the &lt;a href=&#34;http://razor.sourceforge.net&#34;&gt;home page&lt;/a&gt;. SpamAssassin will detect whether Razor is available and, by default, use it if so.&lt;/p&gt;

&lt;h3 id=&#34;assassinating-spam-with-mail-audit-the-easy-way&#34;&gt;Assassinating Spam With Mail::Audit : The Easy Way&lt;/h3&gt;

&lt;p&gt;So this is the part you&amp;rsquo;ve all been waiting for. How do we use these things to trap spam? For those of you who aren&amp;rsquo;t familiar with &lt;code&gt;Mail::Audit&lt;/code&gt;, the idea is simple: just like with &lt;code&gt;procmail&lt;/code&gt;, you write recipes that determine what happens to your mail. However, in the case of &lt;code&gt;Mail::Audit&lt;/code&gt;, you specify the recipe in Perl. For instance, here&amp;rsquo;s a recipe to move all mail sent to &lt;code&gt;perl5-porters@perl.org&lt;/code&gt; to another folder:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Mail::Audit;
    my $mail = Mail::Audit-&amp;gt;new();
    if ($mail-&amp;gt;from =~ /perl5-porters\@perl.org/) {
        $mail-&amp;gt;accept(&amp;quot;p5p&amp;quot;);
    }
    $mail-&amp;gt;accept();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For more details on how to construct mail filters with &lt;code&gt;Mail::Audit&lt;/code&gt;, see my &lt;a href=&#34;http://localhost:1313/pub/2001/07/17/mailfiltering.html&#34;&gt;previous article&lt;/a&gt;.
Plugging SpamAssassin into your filters couldn&amp;rsquo;t be simpler. First of all, you absolutely need the latest version of &lt;a href=&#34;https://metacpan.org/pod/Mail::Audit&#34;&gt;Mail::Audit&lt;/a&gt;. Nothing earlier than 2.1 will do! Now write a filter like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Mail::Audit;
    use Mail::SpamAssassin;
    my $mail = Mail::Audit-&amp;gt;new();

    ... the rest of your rules here ...

    my $spamtest = Mail::SpamAssassin-&amp;gt;new();
    my $status = $spamtest-&amp;gt;check($mail);

    if ($status-&amp;gt;is_spam ()) {
        $status-&amp;gt;rewrite_mail() };
        $mail-&amp;gt;accept(&amp;quot;spam&amp;quot;);
    }
    $mail-&amp;gt;accept();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you might be able to guess, the important thing here is the calls to &lt;code&gt;check&lt;/code&gt; and &lt;code&gt;is_spam&lt;/code&gt;. &lt;code&gt;check&lt;/code&gt; produces a &amp;ldquo;status object&amp;rdquo; that we can query and use to manipulate the e-mail. &lt;code&gt;is_spam&lt;/code&gt; tells us whether the mail has exceeded the number of &amp;ldquo;spam points&amp;rdquo; required to flag an e-mail as spam.
The &lt;code&gt;rewrite_mail&lt;/code&gt; method adds some headers and rewrites the subject line to include the distinctive string &amp;ldquo;*****SPAM******&amp;rdquo;. The additional headers explain why the e-mail was flagged as spam. For instance:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;X-Spam-Status: Yes, hits=6.1 required=5.0
tests=SUBJ_HAS_Q_MARK,REPLY_TO_EMPTY,SUBJ_ENDS_IN_Q_MARK version=2.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This message had a question mark in the subject, an empty reply-to, and the subject ended in a question mark. The mail wasn&amp;rsquo;t actually spam, but this goes to prove that the technique isn&amp;rsquo;t perfect. Nevertheless, since installing the spam filter, I&amp;rsquo;ve only seen about 10 false positives, and zero false negatives. I&amp;rsquo;m happy enough with this solution.
One important point to remember, however, is where in the course of your filtering you should call SpamAssassin&amp;rsquo;s checks. For instance, you want to do so after your mailing list filtering, because mail sent to mailing lists may have munged headers that might confuse SpamAssassin. However, this means that spam sent to mailing lists might slip through the net. Experiment, and find the best solution for your own e-mail patterns.&lt;/p&gt;

&lt;h3 id=&#34;assassinating-spam-without-mail-audit&#34;&gt;Assassinating Spam Without Mail::Audit&lt;/h3&gt;

&lt;p&gt;Of course, there are times when it might not be suitable to use &lt;code&gt;Mail::Audit&lt;/code&gt; or you may not want to. Since SpamAssassin is provided as a command line tool as well as a set of Perl modules, it&amp;rsquo;s easy enough to integrate it in whatever mail filtering solution you use.&lt;/p&gt;

&lt;p&gt;For instance, here&amp;rsquo;s a procmail recipe that calls out to &lt;code&gt;spamassassin&lt;/code&gt; to filter out spam:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:0fw
| spamassassin -P

:0:
* ^X-Spam-Status: Yes
spambox
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the speed-conscious, you can run the &lt;code&gt;spamd&lt;/code&gt; daemon and replace calls to &lt;code&gt;spamassassin&lt;/code&gt; with &lt;code&gt;spamc&lt;/code&gt;; be aware that this is a TCP/IP daemon that you may want to firewall from the rest of the world.
Another approach is to call &lt;code&gt;spamassassin&lt;/code&gt; in your mail transport agent, meaning that spam is filtered out before it even attempts to be delivered to you. There&amp;rsquo;s a Sendmail &lt;a href=&#34;http://savannah.gnu.org/projects/spamass-milt/&#34;&gt;milter&lt;/a&gt; library available that allows you to use SpamAssassin, and similar tricks for Exim and other MTAs are available.&lt;/p&gt;

&lt;h3 id=&#34;assassinating-spam-with-mail-audit-more-complex-operations&#34;&gt;Assassinating Spam With Mail::Audit : More Complex Operations&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;Mail::SpamAssassin&lt;/code&gt; module has many other methods you can use to manipulate e-mail. For instance, if you&amp;rsquo;ve identified something as definitely being spam, then you can use&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $spamtest-&amp;gt;report_as_spam($mail);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to report it to Vipul&amp;rsquo;s Razor. (Take note of this: As we&amp;rsquo;ve mentioned above, the efficiency of the Razor database comes from the fact that e-mails in it are confirmed as spam by a human. Adding false positives to the database would degrade its usefulness for everyone. Only submit mail that you&amp;rsquo;ve confirmed personally.)
If you&amp;rsquo;re finding that mail checking is taking too long because SpamAssassin is having to contact the various network-based blacklists and databases, then you can instruct it to only perform &amp;ldquo;local&amp;rdquo; checking:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $spamtest = Mail::SpamAssassin-&amp;gt;new({local_tests_only =&amp;gt; 1});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is a wealth of other options available. See the &lt;code&gt;Mail::SpamAssassin&lt;/code&gt; documentation for more details, and happy assassinating!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

