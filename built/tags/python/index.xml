<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/python/</link>
    <description>Recent content in Python on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 06 Feb 2001 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/python/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Pathologically Polluting Perl</title>
      <link>http://localhost:1313/pub/2001/02/inline.html/</link>
      <pubDate>Tue, 06 Feb 2001 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2001/02/inline.html/</guid>
      <description>

&lt;h3 id=&#34;pathologically-polluting-perl&#34;&gt;Pathologically Polluting Perl&lt;/h3&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Table of Contents&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;•&lt;a href=&#34;#inline%20in%20action%20%20simple%20examples%20in%20c&#34;&gt;Inline in Action - Simple examples in C&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#hello,%20world&#34;&gt;Hello, world&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#just%20another%20____%20hacker&#34;&gt;Just Another ____ Hacker&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#what%20about%20xs%20and%20swig&#34;&gt;What about XS and SWIG?&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#oneliners&#34;&gt;One-Liners&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#supported%20platforms%20for%20c&#34;&gt;Supported Platforms for C&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#the%20inline%20syntax&#34;&gt;The Inline Syntax&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#fine%20dining%20%20a%20glimpse%20at%20the%20c%20cookbook&#34;&gt;Fine Dining - A Glimpse at the C Cookbook&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#external%20libraries&#34;&gt;External Libraries&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#it%20takes%20all%20types&#34;&gt;It Takes All Types&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#some%20ware%20beyond%20the%20c&#34;&gt;Some Ware Beyond the C&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#see%20perl%20run.%20run%20perl,%20run!&#34;&gt;See Perl Run. Run, Perl, Run!&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#the%20future%20of%20inline&#34;&gt;The Future of Inline&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;br /&gt;
&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;No programming language is Perfect. Perl comes very close. &lt;strong&gt;P&lt;/strong&gt;! &lt;strong&gt;e&lt;/strong&gt;! &lt;strong&gt;r&lt;/strong&gt;! &lt;em&gt;l&lt;/em&gt;? :-( Not quite ``Perfect&amp;rdquo;. Sometimes it just makes sense to use another language for part of your work. You might have a stable, pre-existing code base to take advantage of. Perhaps maximum performance is the issue. Maybe you just ``know how to do it&amp;rdquo; that way. Or very likely, it&amp;rsquo;s a project requirement forced upon you by management. Whatever the reason, wouldn&amp;rsquo;t it be great to use Perl most of the time, but be able to invoke something else when you had to?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Inline.pm&lt;/code&gt; is a new module that glues other programming languages to Perl. It allows you to write C, C++, and Python code directly inside your Perl scripts and modules. This is conceptually similar to the way you can write inline assembly language in C programs. Thus the name: &lt;code&gt;Inline.pm&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The basic philosophy behind Inline is this: ``make it as easy as possible to use Perl with other programming languages, while ensuring that the user&amp;rsquo;s experience retains the DWIMity of Perl&amp;rdquo;. To accomplish this, Inline must do away with nuisances such as interface definition languages, makefiles, build directories and compiling. You simply write your code and run it. Just like Perl.&lt;/p&gt;

&lt;p&gt;Inline will silently take care of all the messy implementation details and ``do the right thing&amp;rdquo;. It analyzes your code, compiles it if necessary, creates the correct Perl bindings, loads everything up, and runs the whole schmear. The net effect of this is you can now write functions, subroutines, classes, and methods in another language and call them as if they were Perl.&lt;/p&gt;

&lt;h3 id=&#34;span-id-inline-in-action-simple-examples-in-c-inline-in-action-simple-examples-in-c-span&#34;&gt;&lt;span id=&#34;inline in action  simple examples in c&#34;&gt;Inline in Action - Simple examples in C&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Inline addresses an old problem in a completely revolutionary way. Just describing Inline doesn&amp;rsquo;t really do it justice. It should be &lt;em&gt;seen&lt;/em&gt; to be fully appreciated. Here are a couple examples to give you a feel for the module.&lt;/p&gt;

&lt;h3 id=&#34;span-id-hello-world-hello-world-span&#34;&gt;&lt;span id=&#34;hello, world&#34;&gt;Hello, world&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;It seems that the first thing any programmer wants to do when he learns a new programming technique is to use it to greet the Earth. In keeping with that tradition, here is the ``Hello, world&amp;rdquo; program using Inline.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Inline C =&amp;gt; &amp;lt;&amp;lt;&#39;END_C&#39;;
    void greet() {
        printf(&amp;quot;Hello, world\n&amp;quot;);
    }
    END_C

    greet;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Simply run this script from the command line and it will print (you guessed it):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Hello, world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example, &lt;code&gt;Inline.pm&lt;/code&gt; is instantiated with the name of a programming language, ``C&amp;rdquo;, and a string containing a piece of that language&amp;rsquo;s source code. This C code defines a function called &lt;code&gt;greet()&lt;/code&gt; which gets bound to the Perl subroutine &lt;code&gt;&amp;amp;main::greet&lt;/code&gt;. Therefore, when we call the &lt;code&gt;greet()&lt;/code&gt; subroutine, the program prints our message on the screen.&lt;/p&gt;

&lt;p&gt;You may be wondering why there are no &lt;code&gt;#include&lt;/code&gt; statements for things like &lt;code&gt;stdio.h&lt;/code&gt;? That&amp;rsquo;s because Inline::C automatically prepends the following lines to the top of your code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #include &amp;quot;EXTERN.h&amp;quot;
    #include &amp;quot;perl.h&amp;quot;
    #include &amp;quot;XSUB.h&amp;quot;
    #include &amp;quot;INLINE.h&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These header files include all of the standard system header files, so you almost never need to use &lt;code&gt;#include&lt;/code&gt; unless you are dealing with a non-standard library. This is in keeping with Inline&amp;rsquo;s philosophy of making easy things easy. (Where have I heard that before?)&lt;/p&gt;

&lt;h3 id=&#34;span-id-just-another-hacker-just-another-hacker-span&#34;&gt;&lt;span id=&#34;just another ____ hacker&#34;&gt;Just Another ____ Hacker&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The next logical question is, ``How do I pass data back and forth between Perl and C?&amp;rdquo; In this example we&amp;rsquo;ll pass a string to a C function and have it pass back a brand new Perl scalar.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Inline C;
    print JAxH(&#39;Perl&#39;);


    __END__
    __C__
    SV* JAxH(char* x) {
        return newSVpvf(&amp;quot;Just Another %s Hacker\n&amp;quot;, x);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you run this program, it prints:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Just Another Perl Hacker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;ve probably noticed that this example is coded differently then the last one. The &lt;code&gt;use Inline&lt;/code&gt; statement specifies the language being used, but not the source code. This is an indicator for Inline to look for the source at the end of the program, after the special marker &amp;lsquo;&lt;code&gt;__C__&lt;/code&gt;&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;The concept being demonstrated is that we can pass Perl data in and out of a C function. Using the default Perl type conversions, Inline can easily convert all of the basic Perl data types to C and vice-versa.&lt;/p&gt;

&lt;p&gt;This example uses a couple of the more advanced concepts of Inlining. Its return value is of the type &lt;code&gt;SV*&lt;/code&gt; (or Scalar Value). The Scalar Value is the most common Perl internal type. Also, the Perl internal function &lt;code&gt;newSVpfv()&lt;/code&gt; is called to create a new Scalar Value from a string, using the familiar &lt;code&gt;sprintf()&lt;/code&gt; syntax. You can learn more about simple Perl internals by reading the &lt;code&gt;perlguts&lt;/code&gt; and &lt;code&gt;perlapi&lt;/code&gt; documentation distributed with Perl.&lt;/p&gt;

&lt;h3 id=&#34;span-id-what-about-xs-and-swig-what-about-xs-and-swig-span&#34;&gt;&lt;span id=&#34;what about xs and swig&#34;&gt;What about XS and SWIG?&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s detour momentarily to ponder ``Why Inline?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;There are already two major facilities for extending Perl with C. They are XS and SWIG. Both are similar in their capabilities, at least as far as Perl is concerned. And both of them are quite difficult to learn compared to Inline. Since SWIG isn&amp;rsquo;t used in practice to nearly the degree that XS is, I&amp;rsquo;ll only address XS.&lt;/p&gt;

&lt;p&gt;There is a big fat learning curve involved with setting up and using the XS environment. You need to get quite intimate with the following docs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; * perlxs
 * perlxstut
 * perlapi
 * perlguts
 * perlcall
 * perlmod
 * h2xs
 * xsubpp
 * ExtUtils::MakeMaker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With Inline you can be up and running in minutes. There is a C Cookbook with lots of short but complete programs that you can extend to your real-life problems. No need to learn about the complicated build process going on in the background. You don&amp;rsquo;t even need to compile the code yourself. Perl programmers cannot be bothered with silly things like compiling. ``Tweak, Run, Tweak, Run&amp;rdquo; is our way of life. Inline takes care of every last detail except writing the C code.&lt;/p&gt;

&lt;p&gt;Another advantage of Inline is that you can use it directly in a script. As we&amp;rsquo;ll soon see, you can even use it in a Perl one-liner. With XS and SWIG, you always set up an entirely separate module, even if you only have one or two functions. Inline makes easy things easy, and hard things possible. Just like Perl.&lt;/p&gt;

&lt;p&gt;Finally, Inline supports several programming languages (not just C and C++). As of this writing, Inline has support for C, C++, Python, and CPR. There are plans to add many more.&lt;/p&gt;

&lt;h3 id=&#34;span-id-oneliners-one-liners-span&#34;&gt;&lt;span id=&#34;oneliners&#34;&gt;One-Liners&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Perl is famous for its one-liners. A Perl one-liner is short piece of Perl code that can accomplish a task that would take much longer in another language. It is one of the popular techniques that Perl hackers use to flex their programming muscles.&lt;/p&gt;

&lt;p&gt;So you may wonder: ``Is Inline powerful enough to produce a one-liner that is also bonifide C extension?&amp;rdquo; Of course it is! Here you go:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    perl -e &#39;use Inline C=&amp;gt;
    q{void J(){printf(&amp;quot;Just Another Perl Hacker\n&amp;quot;);}};J&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Try doing that with XS! We can even write the more complex Inline &lt;code&gt;JAxH()&lt;/code&gt; discussed earlier as a one-liner:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    perl -le &#39;use Inline C=&amp;gt;
    q{SV*JAxH(char*x){return newSVpvf(&amp;quot;Just Another %s Hacker&amp;quot;,x);}};print JAxH+Perl&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I have been using this one-liner as my email signature for the past couple months. I thought it was pretty cool until Bernhard Muenzer posted this gem to &lt;code&gt;comp.lang.perl.modules&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #!/usr/bin/perl -- -* Nie wieder Nachtschicht! *- -- lrep\nib\rsu\!#
    use Inline C=&amp;gt;&#39;void C(){int m,u,e=0;float l,_,I;for(;1840-e;putchar((++e&amp;gt;907
     &amp;amp;&amp;amp;942&amp;gt;e?61-m:u)[&amp;quot;\n)moc.isc@rezneumb(rezneuM drahnreB&amp;quot;]))for(u=_=l=0;79-(m
      =e%80)&amp;amp;&amp;amp;I*l+_*_&amp;lt;6&amp;amp;&amp;amp;26-++u;_=2*l*_+e/80*.09-1,l=I)I=l*l-_*_-2+m/27.;}&#39;;&amp;amp;C
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-supported-platforms-for-c-supported-platforms-for-c-span&#34;&gt;&lt;span id=&#34;supported platforms for c&#34;&gt;Supported Platforms for C&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Inline C works on all of the Perl platforms that I have tested it with so far. This includes all common Unixes and recent versions of Microsoft Windows. The only catch is that you must have the same compiler and &lt;code&gt;make&lt;/code&gt; utility that was used to build your &lt;code&gt;perl&lt;/code&gt; binary.&lt;/p&gt;

&lt;p&gt;Inline has been successfully used on Linux, Solaris, AIX, HPUX, and all the recent BSD&amp;rsquo;s.&lt;/p&gt;

&lt;p&gt;There are two common ways to use Inline on MS Windows. The first one is with ActiveState&amp;rsquo;s ActivePerl for MSWin32. In order to use Inline in that environment, you&amp;rsquo;ll need a copy of MS Visual C++ 6.0. This comes with the &lt;code&gt;cl.exe&lt;/code&gt; compiler and the &lt;code&gt;nmake&lt;/code&gt; make utility. Actually these are the only parts you need. The visual components aren&amp;rsquo;t necessary for Inline.&lt;/p&gt;

&lt;p&gt;The other alternative is to use the Cygwin utilities. This is an actual Unix porting layer for Windows. It includes all of the most common Unix utilities, such as &lt;code&gt;bash&lt;/code&gt;, &lt;code&gt;less&lt;/code&gt;, &lt;code&gt;make&lt;/code&gt;, &lt;code&gt;gcc&lt;/code&gt; and of course &lt;code&gt;perl&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-inline-syntax-the-inline-syntax-span&#34;&gt;&lt;span id=&#34;the inline syntax&#34;&gt;The Inline Syntax&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Inline is a little bit different than most of the Perl modules that you are used to. It doesn&amp;rsquo;t import any functions into your namespace and it doesn&amp;rsquo;t have any object oriented methods. Its entire interface is specified through &lt;code&gt;&#39;use Inline ...&#39;&lt;/code&gt; commands. The general Inline usage is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Inline C =&amp;gt; source-code,
               config_option =&amp;gt; value,
               config_option =&amp;gt; value;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where &lt;code&gt;C&lt;/code&gt; is the programming language, and &lt;code&gt;source-code&lt;/code&gt; is a string, filename, or the keyword &amp;lsquo;&lt;code&gt;DATA&lt;/code&gt;&amp;rsquo;. You can follow that with any number of optional &amp;lsquo;&lt;code&gt;keyword =&amp;gt; value&lt;/code&gt;&amp;rsquo; configuration pairs. If you are using the &amp;lsquo;DATA&amp;rsquo; option, with no configuration parameters, you can just say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Inline C;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-fine-dining-a-glimpse-at-the-c-cookbook-fine-dining-a-glimpse-at-the-c-cookbook-span&#34;&gt;&lt;span id=&#34;fine dining  a glimpse at the c cookbook&#34;&gt;Fine Dining - A Glimpse at the C Cookbook&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In the spirit of the O&amp;rsquo;Reilly book ``Perl Cookbook&amp;rdquo;, Inline provides a manpage called C-Cookbook. In it you will find the recipes you need to help satisfy your Inline cravings. Here are a couple of tasty morsels that you can whip up in no time. Bon Appetit!&lt;/p&gt;

&lt;h3 id=&#34;span-id-external-libraries-external-libraries-span&#34;&gt;&lt;span id=&#34;external libraries&#34;&gt;External Libraries&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The most common real world need for Inline is probably using it to access existing compiled C code from Perl. This is easy to do. The secret is to write a wrapper function for each function you want to expose in Perl space. The wrapper calls the real function. It also handles how the arguments get passed in and out. Here is a short Windows example that displays a text box with a message, a caption and an ``OK&amp;rdquo; button:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Inline C =&amp;gt; DATA =&amp;gt;
               LIBS =&amp;gt; &#39;-luser32&#39;,
               PREFIX =&amp;gt; &#39;my_&#39;;

    MessageBoxA(&#39;Inline Message Box&#39;, &#39;Just Another Perl Hacker&#39;);


    __END__
    __C__
    #include &amp;lt;windows.h&amp;gt;
    int my_MessageBoxA(char* Caption, char* Text) {
      return MessageBoxA(0, Text, Caption, 0);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This program calls a function from the MSWin32 &lt;code&gt;user32.dll&lt;/code&gt; library. The wrapper determines the type and order of arguments to be passed from Perl. Even though the real &lt;code&gt;MessageBoxA()&lt;/code&gt; needs four arguments, we can expose it to Perl with only two, and we can change the order. In order to avoid namespace conflicts in C, the wrapper must have a different name. But by using the &lt;code&gt;PREFIX&lt;/code&gt; option (same as the XS &lt;code&gt;PREFIX&lt;/code&gt; option) we can bind it to the original name in Perl.&lt;/p&gt;

&lt;h3 id=&#34;span-id-it-takes-all-types-it-takes-all-types-span&#34;&gt;&lt;span id=&#34;it takes all types&#34;&gt;It Takes All Types&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Older versions of Inline only supported five C data types. These were: &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;char*&lt;/code&gt; and &lt;code&gt;SV*&lt;/code&gt;. This was all you needed. All the basic Perl scalar types are represented by these. Fancier things like references could be handled by using the generic &lt;code&gt;SV*&lt;/code&gt; (scalar value) type, and then doing the mapping code yourself, inside the C function.&lt;/p&gt;

&lt;p&gt;The process of converting between Perl&amp;rsquo;s &lt;code&gt;SV*&lt;/code&gt; and C types is called &lt;strong&gt;typemapping&lt;/strong&gt;. In XS, you normally do this by using &lt;code&gt;typemap&lt;/code&gt; files. A default &lt;code&gt;typemap&lt;/code&gt; file exists in every Perl installation in a file called &lt;code&gt;/usr/lib/perl5/5.6.0/ExtUtils/typemap&lt;/code&gt; or something similar. This file contains conversion code for over 20 different C types, including all of the Inline defaults.&lt;/p&gt;

&lt;p&gt;As of version 0.30, Inline no longer has &lt;em&gt;any&lt;/em&gt; built in types. It gets all of its types exclusively from &lt;code&gt;typemap&lt;/code&gt; files. Since it uses Perl&amp;rsquo;s default &lt;code&gt;typemap&lt;/code&gt; file for its own defaults, it actually has many more types available automatically.&lt;/p&gt;

&lt;p&gt;This setup provides a lot of flexibility. You can specify your own &lt;code&gt;typemap&lt;/code&gt; files through the use of the &lt;code&gt;TYPEMAPS&lt;/code&gt; configuration option. This not only allows you to override the defaults with your own conversion code, but it also means that you can add new types to Inline as well. The major advantage to extending the Inline syntax this way is that there are already many typemaps available for various APIs. And if you&amp;rsquo;ve done your own XS coding in the past, you can use your existing &lt;code&gt;typemap&lt;/code&gt; files as is. No changes are required.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at a small example of writing your own typemaps. For some reason, the C type &lt;code&gt;float&lt;/code&gt; is not represented in the default Perl &lt;code&gt;typemap&lt;/code&gt; file. I suppose it&amp;rsquo;s because Perl&amp;rsquo;s floating point numbers are always stored as type &lt;code&gt;double&lt;/code&gt;, which is higher precision than &lt;code&gt;float&lt;/code&gt;. But if we wanted it anyway, writing a &lt;code&gt;typemap&lt;/code&gt; file to support &lt;code&gt;float&lt;/code&gt; is trivial.&lt;/p&gt;

&lt;p&gt;Here is what the file would look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    float                   T_FLOAT


    INPUT
    T_FLOAT
            $var = (float)SvNV($arg)


    OUTPUT
    T_FLOAT
            sv_setnv($arg, (double)$var);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Without going into details, this file provides two snippets of code. One for converting a &lt;code&gt;SV*&lt;/code&gt; to a float, and one for the opposite. Now we can write the following script:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Inline C =&amp;gt; DATA =&amp;gt;
               TYPEMAPS =&amp;gt; &#39;./typemap&#39;;


    print &#39;1.2 + 3.4 = &#39;, fadd(1.2, 3.4), &amp;quot;\n&amp;quot;;


    __END__
    __C__
    float fadd(float x, float y) {
        return x + y;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-some-ware-beyond-the-c-some-ware-beyond-the-c-span&#34;&gt;&lt;span id=&#34;some ware beyond the c&#34;&gt;Some Ware Beyond the C&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The primary goal of Inline is to make it easy to use other programming languages with Perl. This is not limited to C. The initial implementations of Inline only supported C, and the language support was built directly into &lt;code&gt;Inline.pm&lt;/code&gt;. Since then things have changed considerably. Inline now supports multiple languages of both compiled and interpreted nature. And it keeps the implementations in an object oriented type structure, whereby each language has its own separate module, but they can inherit behavior from the base Inline module.&lt;/p&gt;

&lt;p&gt;On my second day working at ActiveState, a young man approached me. ``Hi, my name is Neil Watkiss. I just hacked your Inline module to work with C++.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Neil, I soon found out, was a computer science student at a local university. He was working part-time for ActiveState then, and had somehow stumbled across Inline. I was thrilled! I had wanted to pursue new languages, but didn&amp;rsquo;t know how I&amp;rsquo;d find the time. Now I was sitting 15 feet away from my answer!&lt;/p&gt;

&lt;p&gt;Over the next couple months, Neil and I spent our spare time turning Inline into a generic environment for gluing new languages to Perl. I ripped all the C specific code out of Inline and put it into Inline::C. Neil started putting together Inline::CPP and Inline::Python. Together we came up with a new syntax that allowed multiple languages and easier configuration.&lt;/p&gt;

&lt;p&gt;Here is a sample program that makes uses of Inline Python:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Inline Python;
    my $language = shift;
    print $language, 
          (match($language, &#39;Perl&#39;) ? &#39; rules&#39; : &#39; sucks&#39;),
          &amp;quot;!\n&amp;quot;;
    __END__
    __Python__
    import sys
    import re
    def match(str, regex):
        f = re.compile(regex);
        if f.match(str): return 1
        return 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This program uses a Python regex to show that ``Perl rules!&amp;ldquo;.&lt;/p&gt;

&lt;p&gt;Since Python supports its own versions of Perl scalars, arrays, and hashes, Inline::Python can flip-flop between them easily and logically. If you pass a hash reference to python, it will turn it into a dictionary, and vice-versa. Neil even has mechanisms for calling back to Perl from Python code. See the Inline::Python docs for more info.&lt;/p&gt;

&lt;h3 id=&#34;span-id-see-perl-run-run-perl-run-see-perl-run-run-perl-run-span&#34;&gt;&lt;span id=&#34;see perl run. run perl, run!&#34;&gt;See Perl Run. Run Perl, Run!&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Inline is a great way to write C extensions for Perl. But is there an equally simple way to embed a Perl interpreter in a C program? I pondered this question myself one day. Writing Inline functionality for C would not be my cup of tea.&lt;/p&gt;

&lt;p&gt;The normal way to embed Perl into C involves jumping through a lot of hoops to bootstrap a perl interpreter. Too messy for one-liners. And you need to compile the C. Not very Inlinish. But what if you could pass your C program to a perl program that could pass it to Inline? Then you could write this program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #!/usr/bin/cpr
    int main(void) {
        printf(&amp;quot;Hello, world\n&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and just run it from the command line. Interpreted C!&lt;/p&gt;

&lt;p&gt;And thus, a new programming language was born. &lt;strong&gt;CPR&lt;/strong&gt;. ``C Perl Run&amp;rdquo;. The Perl module that gives it life is called &lt;code&gt;Inline::CPR&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Of course, CPR is not really its own language, in the strict sense. But you can think of it that way. CPR is just like C except that you can call out to the Perl5 API at any time, without any extra code. In fact, CPR redefines this API with its own CPR wrapper API.&lt;/p&gt;

&lt;p&gt;There are several ways to think of CPR: ``a new language&amp;rdquo;, ``an easy way to embed Perl in C&amp;rdquo;, or just ``a cute hack&amp;rdquo;. I lean towards the latter. CPR is probably a far stretch from meeting most peoples embedding needs. But at the same time its a very easy way to play around with, and perhaps redefine, the Perl5 internal API. The best compliment I&amp;rsquo;ve gotten for CPR is when my ActiveState coworker Adam Turoff said, ``I feel like my head has just been wrapped around a brick&amp;rdquo;. I hope this next example makes you feel that way too:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #!/usr/bin/cpr
    int main(void) {
        CPR_eval(&amp;quot;use Inline (C =&amp;gt; q{
            char* greet() {
                return \&amp;quot;Hello world\&amp;quot;;
            }
        })&amp;quot;);

        printf(&amp;quot;%s, I&#39;m running under Perl version %s\n&amp;quot;,
               CPR_eval(&amp;quot;&amp;amp;greet&amp;quot;),
               CPR_eval(&amp;quot;use Config; $Config{version}&amp;quot;));
        return 0;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running this program prints:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Hello world, I&#39;m running under Perl version 5.6.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using the &lt;code&gt;eval()&lt;/code&gt; call this CPR program calls Perl and tells it to use Inline C to add a new function, which the CPR program subsequently calls. I think I have a headache myself.&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-future-of-inline-the-future-of-inline-span&#34;&gt;&lt;span id=&#34;the future of inline&#34;&gt;The Future of Inline&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Inline version 0.30 was written specifically so that it would be easy for other people in the Perl community to contribute new language bindings for Perl. On the day of that release, I announced the birth of the Inline mailing list, &lt;a href=&#34;mailto:inline@perl.org.&#34;&gt;inline@perl.org.&lt;/a&gt; This is intended to be the primary forum for discussion on all Inline issues, including the proposal of new features, and the authoring of new ILSMs.&lt;/p&gt;

&lt;p&gt;In the year 2001, I would like to see bindings for Java, Ruby, Fortran and Bash. I don&amp;rsquo;t plan on authoring all of these myself. But I may kickstart some of them, and see if anyone&amp;rsquo;s interested in taking over. If &lt;em&gt;you&lt;/em&gt; have a desire to get involved with Inline development, please join the mailing list (&lt;a href=&#34;mailto:inline-subscribe@perl.org&#34;&gt;inline-subscribe@perl.org&lt;/a&gt;) and speak up.&lt;/p&gt;

&lt;p&gt;My primary focus at the present time, is to make the base Inline module as simple, flexible, and stable as possible. Also I want to see Inline::C become an acceptable replacement for XS; at least for most situations.&lt;/p&gt;

&lt;h3 id=&#34;span-id-conclusion-conclusion-span&#34;&gt;&lt;span id=&#34;conclusion&#34;&gt;Conclusion&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Using XS is just too hard. At least when you compare it to the rest of the Perl we know and love. Inline takes advantage of the existing frameworks for combining Perl and C, and packages it all up into one easy to swallow pill. As an added bonus, it provides a great framework for binding other programming languages to Perl. You might say, ``It&amp;rsquo;s a &amp;lsquo;Perl-fect&amp;rsquo; solution!&amp;rdquo;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Open Source Highlights</title>
      <link>http://localhost:1313/pub/1999/09/trips/tripreport.html/</link>
      <pubDate>Tue, 28 Sep 1999 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/1999/09/trips/tripreport.html/</guid>
      <description>

&lt;h3 id=&#34;overview&#34;&gt;Overview&lt;/h3&gt;

&lt;p&gt;August 21 - 24, 1999&lt;/p&gt;

&lt;p&gt;My main reason for attending the Open Source Conference is to observe Open Source developments and to gather business intelligence for Chevron. I learned Python. I also concentrated on understanding the business case for Open Source and understanding and interpreting correctly events in the industry.&lt;/p&gt;

&lt;h3 id=&#34;learning-python-and-python-for-windows&#34;&gt;Learning Python and Python for Windows.&lt;/h3&gt;

&lt;p&gt;Armed with my recent experience of ploughing through the most obfuscated Perl code, I chose to learn Python, a well-constructed, object-oriented language. Python was created by Guido von Rossum who named it after his favorite TV show, Monty Python&amp;rsquo;s Flying Circus. Python is easy to read and handles Object Oriented Programming in a natural and easy to learn way. The development time of any project in Python is fast. It also tends to encourage clarity in human communication as its very execution depends on use of white space and indentation. The Python Development Environment (IDLE) also, rather neatly, enables &amp;ldquo;grep&amp;rdquo; searches for strings in any Unix or NT files I attended an excellent Windows Python tutorial which emphasized using Python with the array of Windows functions from COM, the register, as a macro language and as a test-harness for other systems&amp;hellip;in addition to its &amp;ldquo;normal&amp;rdquo; function of data processing and as systems &amp;ldquo;glue&amp;rdquo;. Much of the tutorial attended to COM processing with Excel and Word examples, databases, systems administration, C++ and DLLs. Python Programming on Win32 will be published in November 1999 - see &lt;a href=&#34;http://www.oreilly.com/catalog/pythonwin32/noframes.html&#34;&gt;here.&lt;/a&gt; I also asked about Python and LDAP and was able to locate sites at: &lt;a href=&#34;http://www.it.uq.edu.au/~leonard/dc-prj/ldapmodule/&#34;&gt;www.it.uq.edu.au/~leonard/dc-prj/ldapmodule&lt;/a&gt; and &lt;a href=&#34;http://sites.inka.de/ms/python/ldap-client.cgi&#34;&gt;http://sites.inka.de/ms/python/ldap-client.cgi&lt;/a&gt; Python LDAP calls are well constructed and clearer to read than Perl. &amp;hellip;but more research is needed here.&lt;/p&gt;

&lt;h3 id=&#34;keynote-speech-151-rules-for-revolutionaries&#34;&gt;Keynote Speech&amp;amp;#151&amp;rdquo;Rules for Revolutionaries&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;Guy Kawasaki, a venture capitalist and previously an evangelist for Apple, gave the keynote &amp;ldquo;Rules for Revolutionaries&amp;rdquo;. His speech was both funny and inspirational. He suggested ten things to do to succeed, starting with examples of change in food preservation and regaled us with stories drawn from personal experience and the computer industry. Guy gave good advice for anyone attempting change. I have a video copy of this speech should anyone like to see it. See also book references, &lt;a href=&#34;http://www.amazon.com/exec/obidos/ASIN/0066620023/o/qid=935617403/sr=8-1/002%0A-7248840-3554434&#34;&gt;&amp;ldquo;Crossing the Chasm&amp;rdquo;&lt;/a&gt;by Geoffrey Moore and &lt;a href=&#34;http://www.amazon.com/exec/obidos/ASIN/0887309968/o/qid=935617533/sr=8-1/002%0A-7248840-3554434&#34;&gt;&amp;ldquo;Rules for Revolutionaries&amp;rdquo;&lt;/a&gt; by Guy Kawasaki. The mechanism in a revolution, he reminded us, was not &amp;ldquo;a rising tide floats all boats&amp;rdquo;&amp;hellip;but&amp;hellip;&amp;ldquo;in a tornado even turkeys can fly&amp;rdquo;. He emphasized, it is our objective as revolutionaries to create the tornado.&lt;/p&gt;

&lt;h3 id=&#34;people-and-information&#34;&gt;People and Information.&lt;/h3&gt;

&lt;p&gt;I spoke with VA/Linux to clarify their confidence in the small-margin market of selling hardware with pre-loaded Linux. They had been in operation since 1993 and had a lot of Linux turnkey experience particularly service and support. Among their talents is Beowulf installation - I thought they might be of interest to our high-end computing people. Certainly their $899 personal computers are blindingly fast and I consider they have good prospects when they go public. According to John Vrolyk of SGI (Silicon Graphics), VA/Linux has a strong business model. SGI has invested a large amount and is co-developing software. Armed with knowledge of Unilever&amp;rsquo;s success in managing a Sendmail backbone and IMAP connectivity with Outlook desktops, I considered it worth asking about the economics and possibility of running a similar system at Chevron. The Sendmail people were not able to present any base figures and told me their Director of Corporate Accounts would contact me. I said there was only a point in doing that if we could work up some comparative figures with which to work. Point pending. I spoke with Derrick Story of O&amp;rsquo;Reilly and Bob McMillan of Linux Magazine, both of whom were encouraging in wanting to keep in contact and to consider any articles I might care to write. I have been published before so it&amp;rsquo;s a reasonable stretch. I also met with Andrew Leonard of Salon who wants to include the story of Open Source at Chevron in a new book he&amp;rsquo;s writing on the movement.&lt;/p&gt;

&lt;h3 id=&#34;the-state-of-python-address&#34;&gt;&amp;ldquo;The State of Python&amp;rdquo; Address&lt;/h3&gt;

&lt;p&gt;Guido von Rossum gave the keynote address indicating increased interest in Python. During August alone over 8,000 Windows versions have been downloaded and the Python website has had over 63,000 hits. Guido reviewed the recent successes of Python in Web Development Packages (ZOPE), Mailman, JPYTHON, Windows (COM and ASP), XML, Open Classroom, Industrial Light and Magic (Star Wars), Yahoo and Lawrence Livermore Labs. He then referred to CP4E (Computer Programming for Everyone) and outlined why he expected Python will take over from Pascal in education. The next release of Python will be issued in 2000 and Python 2.0 in 2001. DARPA is supporting further development of the IDLE developer environment.&lt;/p&gt;

&lt;h3 id=&#34;linux-in-wearable-computer-research&#34;&gt;Linux in Wearable Computer Research&lt;/h3&gt;

&lt;p&gt;Thad Starner from Georgia Tech is a most friendly, intelligent and innovative man. He described the status of wearable research and how he personally uses a wearable for all his computing needs. He described why Linux is an ideal choice for research and alluded to the advantages of Linux:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Research needs several tries to do anything good&amp;hellip;and since, at the start you don&amp;rsquo;t know what you are doing (that&amp;rsquo;s research), you need to be able to make changes quickly.&lt;/li&gt;
&lt;li&gt;Market-driven research is a fallacy. Consumers don&amp;rsquo;t know what they want and even though they may express interest, don&amp;rsquo;t know enough to express what is reasonable.&lt;/li&gt;
&lt;li&gt;It&amp;rsquo;s a real problem when research degenerates into struggling with the interface problem of a proprietary system.&lt;/li&gt;
&lt;li&gt;Commercial packages create balkanization of projects where one groups find it difficult to talk to one another. Code is &amp;ldquo;idea&amp;rdquo; exchange.&lt;/li&gt;
&lt;li&gt;No black walls round bits of code makes training easier.&lt;/li&gt;
&lt;li&gt;Complicated machines are possible within small budgets.&lt;/li&gt;
&lt;li&gt;The usual arguments of Linux giving flexibility, stability, scalability, obsolescence protection, real time, drivers, raid prototyping, remote access and networking at low cost.&lt;/li&gt;
&lt;li&gt;Need for greater than 640 x 480 displays&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Other factors he mentioned were low fixed cost base for embedded devices, great community, easy porting to other platforms. Dr Starner then spoke of how he runs his research administration and announced the Wearable Computer Conference (ISWC) to be held in Oct 18 - 19, 1999 at the Cathedral Hill Hotel in San Francisco. The web site is &lt;a href=&#34;http://iswc.gatech.com&#34;&gt;http://iswc.gatech.com.&lt;/a&gt; Other subjects he covered were wearable research to support the deaf or blind&amp;hellip;and gambling, particularly the work of Shannon and Thorp who did research with shoe-based computers in Las Vegas running simulations timing ball, rotation of wheel etc., giving them a 44% advantage over the house. Dr Starner gave me names for &amp;ldquo;blind&amp;rdquo; research. Collins, who created a camera/tactile blind navigation system, John Goldwaite from Georgia Tech and David Ascher, who taught me Python, at a San Francisco sight research organization - address &amp;lt;mailto:&amp;ldquo;da@python.net&amp;rdquo;&amp;gt;da@python.net. Getting back to wearables, Thad described the keyboard, twiddler (a combination keyboard and mouse enabling sixty wpm input), the retinal projection system and the now credit card sized processor. Very short-range wireless and IR communication are used for communication. He described the non-intrusive collaboration that is enabled and a nice remembrance agent that works under EMACS&amp;hellip;also how he used this to sit for his Ph.D. This technology has much significance for Chevron in supporting the disabled in computing and, more mainstream, in refinery and pipeline &amp;ldquo;hands-off&amp;rdquo; computer work. Current research is tracking fingertips, glasses that attach links to physical reality, messaging and a form of active badges, baseball cap mounted sign-language to English translator, circuits sewn in clothing. The future will include wearables. There are 8 billion computers on the planet, two percent only of which are desktops. Cray-like power can be carried and very short-range wireless communications used. Cell phones will run an OS&amp;hellip;lots of other stuff&amp;hellip;smart dust, etc. References:&lt;a href=&#34;http://www.gvu.gatech.edu/ccg&#34;&gt;http://www.gvu.gatech.edu/ccg&lt;/a&gt; and &lt;a href=&#34;http://www.media.mit.edu/wearables&#34;&gt;http://www.media.mit.edu/wearables.&lt;/a&gt; Andy Barrow has a tape recording of this talk should you wish to hear it.&lt;/p&gt;

&lt;h3 id=&#34;making-the-business-case-to-management-for-open-source&#34;&gt;Making the Business Case to Management for Open Source&lt;/h3&gt;

&lt;p&gt;Barry Caplin, a manager of USWest, gave a presentation on how to make the case for open source to management. The detail slides are at &lt;span&gt;www.users.uswest.net/~bcaplin/talks&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Barry spoke of management fears about Open Source, the problems with proprietary systems, and how to make the case. In particular, that deserves a summary here. Making the case consists of:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Gather the information&lt;/li&gt;
&lt;li&gt;Journal the current situation&lt;/li&gt;
&lt;li&gt;Journal the company&amp;rsquo;s current capabilities and skills&lt;/li&gt;
&lt;li&gt;Determine company&amp;rsquo;s needs and goals&lt;/li&gt;
&lt;li&gt;Identify players and allies&lt;/li&gt;
&lt;li&gt;Identify top-tech minds&lt;/li&gt;
&lt;li&gt;Get feedback from a sympathetic manager&lt;/li&gt;
&lt;li&gt;Identify people you have to convince and target the presentation accordingly&lt;/li&gt;
&lt;li&gt;Publish a White Paper&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There was considerable debate during question time about the economic viability of Open Source. Issues were discussed but hardly resolved (see Keynote&amp;amp;#151&amp;rdquo;Extreme Business&amp;rdquo; by John Vrolyk of SGI for a more definitive process).&lt;/p&gt;

&lt;p&gt;The White Paper should be a &amp;ldquo;living document&amp;rdquo;, address itself to the core purpose, vision and corporate culture, should contain some degree of &amp;ldquo;comfort factor&amp;rdquo; and must contain:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;An Executive Summary.&lt;/li&gt;
&lt;li&gt;Relevant Company History.&lt;/li&gt;
&lt;li&gt;A Summary Expertise Matrix of People Skills&lt;/li&gt;
&lt;li&gt;The Criteria for Choice including scalability, security, robustness, risk, cost of conversion, lowered operational cost, stability, training and standardization, advantages of shared code and shared people.&lt;/li&gt;
&lt;li&gt;A Plan to Integrate other proprietary and commercial products.&lt;/li&gt;
&lt;li&gt;Summary and Conclusions.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The White Paper must not contain too much opinion or technical depth - details can be discussed later.&lt;/p&gt;

&lt;h3 id=&#34;keynote-speech-sun-and-open-source&#34;&gt;Keynote Speech - &amp;ldquo;Sun and Open Source&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;Bill Joy of Sun described the BSD Unix and vi editor developments and the difficulties and successes he had experienced before he joined Sun. He emphasized the strength of copyright in enforcing &amp;ldquo;good behavior&amp;rdquo; rather than contract law implying that the GNU Public License created by Richard Stallman in 1981 was a particularly good method of ensuring that Open Source would not fragment.&lt;/p&gt;

&lt;h3 id=&#34;extreme-business-is-linux-economically-viable&#34;&gt;&amp;ldquo;Extreme Business&amp;rdquo; - Is Linux Economically Viable?&lt;/h3&gt;

&lt;p&gt;This address, given by John Vrolyk, a senior VP of Silicon Graphics, was very impressive. I have an audio tape should anyone wish to listen to it. Mr Vrolyk considered the next phase of Linux development would be the alignment around brands. He had some interesting things to say:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The OS is a commodity, no end-user really cares what it is.&lt;/li&gt;
&lt;li&gt;Microsoft should concentrate on desktop applications.&lt;/li&gt;
&lt;li&gt;SGI had released their IRIX file journalling system to Open Source.&lt;/li&gt;
&lt;li&gt;SGI, HP and Intel are guaranteeing smooth transfer of Linux to 64bit chips.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Vrolyk made the example of economic sustainability by using water as an example. Water is free. But Perrier and Pellegrino seem to do very well. Case closed.&lt;/p&gt;

&lt;p&gt;Regarding business models, he alluded to those of the VA/Linux (turnkey), Sun (envelop), IBM (just throw money), SGI (hardware and service), O&amp;rsquo;Reilly (publishing), Stonehenge (training) or Red Hat (GIL-like distribution and service) type and said it was unclear which would succeed well, but SGI were investing in VA/Linux as one with good potential. He also added that the industry in general is turning from having to go cap-in-hand for compliance testing for Redmond&amp;rsquo;s proprietary and often secret standards. This is a revolution. &amp;ldquo;Stupid ideas&amp;rdquo; he said &amp;ldquo;only last for any time in large corporations&amp;rdquo;. I reflected on recent events in Chevron. We have positioned ourselves reasonably well for the Tsunami about to hit.&lt;/p&gt;

&lt;p&gt;&amp;amp;#169Chevron Corporation.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

