<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Xs on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/xs/</link>
    <description>Recent content in Xs on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 30 Apr 2018 20:34:45 +0000</lastBuildDate>
    <atom:link href="/tags/xs/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>XS utility routines that are good to know</title>
      <link>http://localhost:1313/article/xs-utility-routines-that-are-good-to-know/</link>
      <pubDate>Mon, 30 Apr 2018 20:34:45 +0000</pubDate>
      
      <guid>http://localhost:1313/article/xs-utility-routines-that-are-good-to-know/</guid>
      <description>

&lt;p&gt;In the previous &lt;a href=&#34;http://localhost:1313/article/writing-your-own-xs-functions/&#34;&gt;tutorial&lt;/a&gt;, we learned how to write our own functions in XS, how to process multiple arguments, and return different values, including &lt;code&gt;undef&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In this tutorial I&amp;rsquo;m going to cover some useful routines for common cases you&amp;rsquo;ll encounter when programming in XS. One that you&amp;rsquo;ve already seen is &lt;code&gt;SvOK&lt;/code&gt; which can tell you if a scalar is defined or not. Here are the new areas I&amp;rsquo;ll discuss:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Scheduling XS code to run at startup&lt;/li&gt;
&lt;li&gt;Handling tied variables&lt;/li&gt;
&lt;li&gt;Unicode tools&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When writing XS code, these are things you&amp;rsquo;ll often want to be aware of, and know how to handle.&lt;/p&gt;

&lt;h3 id=&#34;module-code&#34;&gt;Module Code&lt;/h3&gt;

&lt;p&gt;As before, we&amp;rsquo;ll define the module code to load our XS. This is all that&amp;rsquo;s required:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package XS::Tutorial::Three;
require XSLoader;

XSLoader::load();
1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That should be saved as &lt;code&gt;lib/XS/Tutorial/Three.pm&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;xs-code&#34;&gt;XS Code&lt;/h3&gt;

&lt;p&gt;The top of the XS file will look similar to the previous chapter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define PERL_NO_GET_CONTEXT // we&#39;ll define thread context if necessary (faster)
#include &amp;quot;EXTERN.h&amp;quot;         // globals/constant import locations
#include &amp;quot;perl.h&amp;quot;           // Perl symbols, structures and constants definition
#include &amp;quot;XSUB.h&amp;quot;           // xsubpp functions and macros

MODULE = XS::Tutorial::Three  PACKAGE = XS::Tutorial::Three
PROTOTYPES: ENABLE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remember to append any XS code after the &lt;code&gt;PROTOTYPES&lt;/code&gt; line. This should be saved as &lt;code&gt;lib/XS/Tutorial/Three.xs&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;scheduling-xs-code-to-run-at-startup&#34;&gt;Scheduling XS code to run at startup&lt;/h3&gt;

&lt;p&gt;Sometimes you&amp;rsquo;ll need to run some code before your XS functions can work. For example, &lt;a href=&#34;https://github.com/openvenues/libpostal&#34;&gt;libpostal&lt;/a&gt; has startup routines which populate data structures that must be called before the library can be used.&lt;/p&gt;

&lt;p&gt;You could code this in a &amp;ldquo;lazy&amp;rdquo; way, that is, inside the XS function, check to see if the init code has been run, and if not, run it before executing the rest of the function code.&lt;/p&gt;

&lt;p&gt;However XS offers another way to do it by using the &lt;code&gt;BOOT&lt;/code&gt; keyword. Any C code included below the keyword, will be executed during the startup process:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BOOT:
printf(&amp;quot;We&#39;re starting up!\n&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The boot section is terminated by the first empty line after the keyword.&lt;/p&gt;

&lt;h3 id=&#34;handling-tied-variables&#34;&gt;Handling tied variables&lt;/h3&gt;

&lt;p&gt;Tied variables are special variables that execute custom code when they are interacted with. But you never use them, so why worry about them? The
thing is if you&amp;rsquo;re writing code to be used by others, you can&amp;rsquo;t be sure that a caller won&amp;rsquo;t pass a tied variable to one of your XS functions. And unlike
regular Perl, XS does &lt;strong&gt;not&lt;/strong&gt; execute tied code automatically.&lt;/p&gt;

&lt;p&gt;XS does provide &lt;a href=&#34;https://perldoc.perl.org/perlapi.html#Magical-Functions&#34;&gt;functions&lt;/a&gt; for working with tied variables though. One you&amp;rsquo;ll see in a lot of XS code is &lt;code&gt;SvGETMAGIC&lt;/code&gt;. Imagine your function is passed a tied variable; it&amp;rsquo;s value will be undefined in XS, until you call &lt;code&gt;mg_get&lt;/code&gt; (&amp;ldquo;magic get&amp;rdquo;) on it, which calls &lt;code&gt;FETCH&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Unfortunately, &lt;code&gt;mg_get&lt;/code&gt; can only be called on tied scalars so you don&amp;rsquo;t want to call it on a regular scalar. That&amp;rsquo;s where &lt;code&gt;SvGETMAGIC&lt;/code&gt; comes in: if the scalar is
tied, it will call &lt;code&gt;mg_get&lt;/code&gt;, if not, nothing will happen.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s how you might use it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SV*
get_tied_value(SV *foo)

PPCODE:
  /* call FETCH() if it&#39;s a tied variable to populate the sv */
  SvGETMAGIC(foo);
  PUSHs(sv_2mortal(foo));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code declares an XS function called &lt;code&gt;get_tied_value&lt;/code&gt;, which accepts a scalar variable, and calls &lt;code&gt;SvGETMAGIC&lt;/code&gt; on it, returning the value, by pushing it onto the stack.&lt;/p&gt;

&lt;h4 id=&#34;magic&#34;&gt;Magic?&lt;/h4&gt;

&lt;p&gt;You might be wondering why functions dealing with tied variables are named &amp;ldquo;magic&amp;rdquo; or &amp;ldquo;mg&amp;rdquo;. The reason is that tied behavior for each variable is implemented via a pointer to a &lt;a href=&#34;https://perldoc.perl.org/perlguts.html#Magic-Virtual-Tables&#34;&gt;magic virtual table&lt;/a&gt; which is a structure containing function pointers to the tied behavior.&lt;/p&gt;

&lt;p&gt;Often the Perl C API will provide &lt;code&gt;mg&lt;/code&gt; (&amp;ldquo;magic&amp;rdquo;) and &lt;code&gt;nomg&lt;/code&gt; (&amp;ldquo;non magic&amp;rdquo;) variants of functions, so you can decide if you want to trigger the tied behavior.&lt;/p&gt;

&lt;h3 id=&#34;utf-8-tools&#34;&gt;UTF-8 tools&lt;/h3&gt;

&lt;p&gt;Perl has loads of tools for managing UTF-8 encoded text, but with XS you&amp;rsquo;re working in C, which does not. Start thinking about basic types like &lt;code&gt;char&lt;/code&gt;
and common assumptions in C code, and you&amp;rsquo;ll realize that multibyte characters can wreak havoc unless you handle them correctly.&lt;/p&gt;

&lt;p&gt;Fortunately, the Perl C API does provide &lt;a href=&#34;https://perldoc.perl.org/perlapi.html#Unicode-Support&#34;&gt;functions&lt;/a&gt; for managing UTF-8 data that
can help. Here are a couple of examples.&lt;/p&gt;

&lt;p&gt;Perl scalars have a UTF-8 flag, which is turned on when the scalar contains decoded UTF-8 data. We can detect it with &lt;code&gt;SvUTF8&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SV*
is_utf8(SV *foo)
PPCODE:
  /* if the UTF-8 flag is set return 1 &amp;quot;true&amp;quot; */
  if (SvUTF8(foo)) {
    PUSHs(sv_2mortal(newSViv(1)));
  }
  /* else return undef &amp;quot;false&amp;quot; */
  else {
    PUSHs(sv_newmortal());
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This declares an XS function called &lt;code&gt;is_utf8&lt;/code&gt; which accepts a scalar and returns true if the UTF-8 flag is set, or false if it isn&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;Imagine you have some C code that only works with ASCII text, that is, single byte characters. You can detect incoming scalars that have the UTF-8 flag turned on
with &lt;code&gt;SvUTF8&lt;/code&gt;, but what do you do about ones that have the flag?&lt;/p&gt;

&lt;p&gt;You could &lt;code&gt;croak&lt;/code&gt; immediately, throwing an exception. Or you could try to &lt;em&gt;downgrade&lt;/em&gt; the scalar to be non UTF-8 as the string may be marked as UTF-8 but only contain ASCII compatible characters (decimal values 0-127).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SV*
is_downgradeable(SV *foo)
PPCODE:
  /* if the UTF-8 flag is set and the scalar is not downgrade-able return
     undef */
  if (SvUTF8(foo) &amp;amp;&amp;amp; !sv_utf8_downgrade(foo, TRUE)) {
    PUSHs(sv_newmortal());
  }
  /* else return 1 */
  else {
    PUSHs(sv_2mortal(newSViv(1)));
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function returns false if the scalar contains data that is not downgrade-able to ASCII, otherwise it returns true. It does that by using the &lt;code&gt;sv_utf8_downgrade&lt;/code&gt; function, which accepts the scalar and a boolean value indicating if it&amp;rsquo;s ok to fail. As the second argument is &lt;code&gt;TRUE&lt;/code&gt;, the function simply returns false if the scalar is not downgrade-able (otherwise it would &lt;code&gt;croak&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Parts &lt;a href=&#34;http://localhost:1313/article/getting-started-with-xs/&#34;&gt;one&lt;/a&gt; and &lt;a href=&#34;http://localhost:1313/article/writing-your-own-xs-functions/&#34;&gt;two&lt;/a&gt; in this series contain the background information necessary to understand this one&lt;/li&gt;
&lt;li&gt;This series is also on CPAN (&lt;a href=&#34;https://metacpan.org/pod/XS::Tutorial&#34;&gt;XS::Tutorial&lt;/a&gt;) complete with all the code&lt;/li&gt;
&lt;li&gt;The &lt;a href=&#34;https://perldoc.perl.org/perlxs.html#The-BOOT%3a-Keyword&#34;&gt;BOOT&lt;/a&gt; keyword&lt;/li&gt;
&lt;li&gt;Tied variable &lt;a href=&#34;https://perldoc.perl.org/perlapi.html#Magical-Functions&#34;&gt;functions&lt;/a&gt; and the &lt;a href=&#34;https://perldoc.perl.org/perlguts.html#Magic-Virtual-Tables&#34;&gt;magic virtual table&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://perldoc.perl.org/perlapi.html#Unicode-Support&#34;&gt;Perl UTF-8 functions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
Cover image &amp;copy; &lt;a href=&#34;https://pixabay.com/en/plumbing-pipe-wrench-plumber-840835/&#34;&gt;Steve Buissinne&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Writing your own XS functions</title>
      <link>http://localhost:1313/article/writing-your-own-xs-functions/</link>
      <pubDate>Fri, 12 Jan 2018 08:28:40 +0000</pubDate>
      
      <guid>http://localhost:1313/article/writing-your-own-xs-functions/</guid>
      <description>

&lt;p&gt;In &lt;a href=&#34;http://localhost:1313/article/getting-started-with-xs/&#34;&gt;part one&lt;/a&gt;, we learned the basic components of XS, and integrated
two C functions into Perl. This chapter is going to show you how to define xsubs
that accept multiple parameters, and define your own logic, instead of using XS
as a Foreign Function Interface to a C library.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll need the files from &lt;a href=&#34;http://localhost:1313/article/getting-started-with-xs/&#34;&gt;part one&lt;/a&gt; to execute the code in this article.&lt;/p&gt;

&lt;h3 id=&#34;module-code&#34;&gt;Module Code&lt;/h3&gt;

&lt;p&gt;As before, we&amp;rsquo;ll define the module code to load our XS. This is all that&amp;rsquo;s
required:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;package&lt;/span&gt; XS::Tutorial::Two;
&lt;span style=&#34;color:#66d9ef&#34;&gt;require&lt;/span&gt; XSLoader;

XSLoader::load();
&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That should be saved as &lt;code&gt;lib/XS/Tutorial/Two.pm&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;xs-code&#34;&gt;XS Code&lt;/h3&gt;

&lt;p&gt;The top of the XS file will look similar to the previous chapter:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define PERL_NO_GET_CONTEXT &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// we&amp;#39;ll define thread context if necessary (faster)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;EXTERN.h&amp;#34;         // globals/constant import locations&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;perl.h&amp;#34;           // Perl symbols, structures and constants definition&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;XSUB.h&amp;#34;           // xsubpp functions and macros&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;stdint.h&amp;#34;         // portable integer types&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
MODULE &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; XS&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Tutorial&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Two  PACKAGE &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; XS&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Tutorial&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Two
PROTOTYPES: ENABLE&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Remember to append any XS code after the &lt;code&gt;PROTOTYPES&lt;/code&gt; line. This should be saved
as &lt;code&gt;lib/XS/Tutorial/Two.xs&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;adding-numbers&#34;&gt;Adding numbers&lt;/h3&gt;

&lt;p&gt;Here&amp;rsquo;s a simple declaration of an xsub that adds two integers:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;add_ints&lt;/span&gt; (addend1, addend2)
  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; addend1
  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; addend2
  CODE:
    RETVAL &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; addend1 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; addend2;
  OUTPUT:
    RETVAL&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This declares an xsub called &lt;code&gt;add_ints&lt;/code&gt; which accepts two integers and whose
return type is &lt;code&gt;int&lt;/code&gt;. Note the &lt;a href=&#34;https://stackoverflow.com/questions/1630631/alternative-kr-c-syntax-for-function-declaration-versus-prototypes&#34;&gt;K&amp;amp;R&lt;/a&gt; style of the function definition. This can also be written as:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;add_ints (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; addend1, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; addend2)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But you rarely see it done that way in the wild. I don&amp;rsquo;t know if that&amp;rsquo;s a cargo
cult thing or there are edge cases to the xsub compiler that I&amp;rsquo;m not aware of.
Just to be safe, I&amp;rsquo;ll keep doing it the way everyone else does (the cult
persists!).&lt;/p&gt;

&lt;p&gt;Whereas &lt;a href=&#34;http://localhost:1313/article/getting-started-with-xs/&#34;&gt;before&lt;/a&gt; we were essentially mapping C functions like &lt;code&gt;srand&lt;/code&gt; to Perl,
here we&amp;rsquo;re declaring our own logic: &lt;code&gt;add_ints&lt;/code&gt; isn&amp;rsquo;t imported from anywhere,
we&amp;rsquo;re declaring it as a new function.&lt;/p&gt;

&lt;p&gt;Since &lt;code&gt;add_ints&lt;/code&gt; is a new function, we need to define the logic of it, and
that&amp;rsquo;s where the &lt;code&gt;CODE&lt;/code&gt; section comes in. Here we can write C code which
forms the body of the function. In this example, I add the two subroutine
parameters together and assign the result to &lt;code&gt;RETVAL&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://perldoc.perl.org/perlxs.html#The-RETVAL-Variable&#34;&gt;RETVAL&lt;/a&gt; (&amp;ldquo;RETurn VALue&amp;rdquo;) is a special variable that is declared by the xsub processor
(xsubpp). The &lt;code&gt;OUTPUT&lt;/code&gt; section accepts the return variable for the xsub, placing
it on the stack, so that calling code will receive it.&lt;/p&gt;

&lt;h3 id=&#34;adding-more-than-two-numbers&#34;&gt;Adding more than two numbers&lt;/h3&gt;

&lt;p&gt;Adding two numbers is all well and good, but lists are the lingua franca of
Perl. Let&amp;rsquo;s update the &lt;code&gt;add_ints&lt;/code&gt; xsub to accept n values:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;int32_t
&lt;span style=&#34;color:#a6e22e&#34;&gt;add_ints&lt;/span&gt; (...)
  CODE:
    uint32_t i;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; items; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;SvOK(ST(i)) &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;SvIOK(ST(i)))
        croak(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;requires a list of integers&amp;#34;&lt;/span&gt;);

      RETVAL &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; SvIVX(ST(i));
    }
  OUTPUT:
    RETVAL&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;First off, notice I&amp;rsquo;ve updated the return value. One issue with using &lt;code&gt;int&lt;/code&gt; in
C is it may be a different size on different machine architectures. &lt;code&gt;int32_t&lt;/code&gt;
is from the &lt;code&gt;stdint.h&lt;/code&gt; library, and guaranteed to be a 32 bit signed integer.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve replaced the function parameters with &lt;code&gt;...&lt;/code&gt; which indicates the function
accepts a variable number of arguments, just like in C. In the &lt;code&gt;CODE&lt;/code&gt; section,
I declare a &lt;code&gt;uint32_t&lt;/code&gt; integer called &lt;code&gt;i&lt;/code&gt; (&lt;code&gt;uint32_t&lt;/code&gt; is a 32 bit unsigned
integer).&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;for&lt;/code&gt; loop uses the special variable &lt;code&gt;items&lt;/code&gt; (the number of arguments passed
to the function) to iterate over the arguments. The &lt;code&gt;if&lt;/code&gt; statement calls
the macro &lt;code&gt;ST&lt;/code&gt; to access the stack variable at position &lt;code&gt;i&lt;/code&gt;. This is used to
check that the scalar is defined (&lt;code&gt;SvOK&lt;/code&gt;) and that it is an integer (&lt;code&gt;SvIOK&lt;/code&gt;).
If either test fails, the code calls &lt;code&gt;croak&lt;/code&gt; to throw a fatal exception.&lt;/p&gt;

&lt;p&gt;Otherwise the integer value is extracted from the scalar (&lt;code&gt;SvIVX&lt;/code&gt;) and added
to &lt;code&gt;RETVAL&lt;/code&gt;. If all of these C macros look strange to you, don&amp;rsquo;t worry, they are
weird! They are part of the Perl C API, and they&amp;rsquo;re documented in &lt;a href=&#34;https://perldoc.perl.org/perlapi.html&#34;&gt;perlapi&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;edge-cases&#34;&gt;Edge cases&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s probably a good time to write some tests for this function, here&amp;rsquo;s a
start:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Test::More;

&lt;span style=&#34;color:#66d9ef&#34;&gt;BEGIN&lt;/span&gt; { use_ok &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;XS::Tutorial::Two&amp;#39;&lt;/span&gt; }

cmp_ok XS::Tutorial::Two::add_ints(&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;), &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;==&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
cmp_ok XS::Tutorial::Two::add_ints(&lt;span style=&#34;color:#ae81ff&#34;&gt;1500&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;21000&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;), &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;==&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;21500&lt;/span&gt;;

done_testing;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I saved that file as &lt;code&gt;t/two.t&lt;/code&gt;, and run it by building the distribution with
&lt;code&gt;make&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;perl Makefile.PL &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Do you know what the return value would be if &lt;code&gt;add_ints&lt;/code&gt; was called with no
arguments? Maybe &lt;code&gt;undef&lt;/code&gt;, since if there are no arguments, the for loop will
not have any iterations. Here&amp;rsquo;s a test for that condition:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;ok &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;defined XS::Tutorial::Two::add_ints(), &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;empty list returns undef&amp;#39;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Re-building and running the tests with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make clean &amp;amp;&amp;amp; perl Makefile.PL &amp;amp;&amp;amp;  make &amp;amp;&amp;amp; make test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That test fails, because the return value is zero! This is a quirk of C:
uninitialized integers can be zero. Let&amp;rsquo;s fix the xsub to return &lt;code&gt;undef&lt;/code&gt; when
it doesn&amp;rsquo;t receive any arguments:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;SV &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;add_ints&lt;/span&gt; (...)
  PPCODE:
    uint32_t i;
    int32_t total &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (items &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
      &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; items; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;SvOK(ST(i)) &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;SvIOK(ST(i)))
          croak(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;requires a list of integers&amp;#34;&lt;/span&gt;);

        total &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; SvIVX(ST(i));
      }
      PUSHs(sv_2mortal(newSViv(total)));
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
      PUSHs(sv_newmortal());
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Woah, quite a few changes! First I&amp;rsquo;ve changed the return type to &lt;code&gt;SV *&lt;/code&gt;, from
&lt;code&gt;int32_t&lt;/code&gt;. The reason for this will become clear in a moment.  The &lt;code&gt;CODE&lt;/code&gt; section
is now called &lt;code&gt;PPCODE&lt;/code&gt;, which tells xsubpp that we will be managing the return
value of xsub ourselves, hence the &lt;code&gt;OUTPUT&lt;/code&gt; section is gone.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve declared a new variable called &lt;code&gt;total&lt;/code&gt; to capture the running total of the
arguments as they&amp;rsquo;re added. If we received at least one argument, total is copied
into a new scalar integer value (&lt;code&gt;newSViv&lt;/code&gt;), its reference count is corrected
(&lt;code&gt;sv_2mortal&lt;/code&gt;) and it is pushed onto the stack pointer (&lt;code&gt;PUSHs&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Otherwise a new &lt;code&gt;undef&lt;/code&gt; scalar is declared with &lt;code&gt;sv_newmortal&lt;/code&gt; and that is pushed
onto the stack pointer instead. So in both cases we&amp;rsquo;re returning an &lt;code&gt;SV&lt;/code&gt;. And as
we&amp;rsquo;re returning a Perl type instead of a C type (&lt;code&gt;int32_t&lt;/code&gt;) there is no need for
xsubpp to cast our return value into a Perl scalar, we&amp;rsquo;re already doing it.&lt;/p&gt;

&lt;h3 id=&#34;wrap-up&#34;&gt;Wrap up&lt;/h3&gt;

&lt;p&gt;This tutorial has covered some critical skills for writing xsubs: how to accept
multiple parameters, how to write your own logic, and how to manage the stack
pointer. If you grok all of these, and the content of &lt;a href=&#34;http://localhost:1313/article/getting-started-with-xs/&#34;&gt;part one&lt;/a&gt;
you have enough to get started writing your own XS code.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;This documentation and code is on CPAN (&lt;a href=&#34;https://metacpan.org/pod/XS::Tutorial&#34;&gt;XS::Tutorial&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://perldoc.perl.org/perlxs.html&#34;&gt;perlxs&lt;/a&gt; defines the keywords recognized by &lt;a href=&#34;https://perldoc.perl.org/xsubpp.html&#34;&gt;xsubpp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://perldoc.perl.org/perlapi.html&#34;&gt;perlapi&lt;/a&gt; lists the C macros used to interact with Perl data structures (and the interpreter)&lt;/li&gt;
&lt;li&gt;The &lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdint.h.html&#34;&gt;stdint.h&lt;/a&gt; C library provides sets of portable integer types&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Getting started with XS</title>
      <link>http://localhost:1313/article/getting-started-with-xs/</link>
      <pubDate>Wed, 03 May 2017 20:47:51 +0000</pubDate>
      
      <guid>http://localhost:1313/article/getting-started-with-xs/</guid>
      <description>

&lt;p&gt;eXtendable Subroutines (XS) are subroutines written in C that are callable from
Perl code. There are two common reasons you&amp;rsquo;d want to use XS: there is a C
library you&amp;rsquo;d like to use with Perl, or you want to make a subroutine faster
by processing it in C instead of Perl.&lt;/p&gt;

&lt;p&gt;This tutorial will walk you through all the components needed to get up and
running with a basic XS example. There will be a lot of new terms and concepts:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you want to write XS, you have to learn it. Learning XS is very difficult&lt;/p&gt;

&lt;p&gt;Steven W. McDougall&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Try not to get discouraged if things don&amp;rsquo;t click right away: I promise you that
learning XS can be hugely rewarding: you&amp;rsquo;ll develop the power to write lightning
fast code; get a better understanding of how Perl internals work, and be able to
integrate any C library you choose and use it from Perl.&lt;/p&gt;

&lt;h3 id=&#34;components&#34;&gt;Components&lt;/h3&gt;

&lt;p&gt;There are a few basic components needed to write an xsub. The first is a Perl
module that will provide the namespace for any XS functions. This is all that&amp;rsquo;s
needed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package XS::Tutorial::One;
require XSLoader;

XSLoader::load();
1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This file should be saved as &lt;code&gt;lib/XS/Tutorial/One.pm&lt;/code&gt;. &lt;code&gt;XSLoader::load&lt;/code&gt; by
default searches for XS code that matches the package name it is called from*.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s create a main distribution module too:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package XS::Tutorial;
BEGIN { our $VERSION = 0.01 }
1;

=encoding utf8

=head1 NAME

XS::Tutorial - documentation with examples for learning Perl XS

=cut
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That file should be saved as &lt;code&gt;lib/XS/Tutorial.pm&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The next thing we need is a .xs file which defines the xsubs to be loaded by
&lt;code&gt;XS::Tutorial::One&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define PERL_NO_GET_CONTEXT // we&#39;ll define thread context if necessary (faster)
#include &amp;quot;EXTERN.h&amp;quot;         // globals/constant import locations
#include &amp;quot;perl.h&amp;quot;           // Perl symbols, structures and constants definition
#include &amp;quot;XSUB.h&amp;quot;           // xsubpp functions and macros
#include &amp;lt;stdlib.h&amp;gt;         // rand()

// additional c code goes here

MODULE = XS::Tutorial::One  PACKAGE = XS::Tutorial::One
PROTOTYPES: ENABLE

 # XS code goes here

 # XS comments begin with &amp;quot; #&amp;quot; to avoid them being interpreted as pre-processor
 # directives

unsigned int
rand()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This file should be saved as &lt;code&gt;lib/XS/Tutorial/One.xs&lt;/code&gt;. The top half of the file
is pure C code. The line beginning &lt;code&gt;MODULE = XS::Tutorial::One&lt;/code&gt; indicates the
start of the XS code. This section will be parsed and compiled into C code by
&lt;code&gt;xsubpp&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;MODULE&lt;/code&gt; and &lt;code&gt;PACKAGE&lt;/code&gt; directives define the Perl module and package which
will load any xsubs we define. The line &lt;code&gt;PROTOTYPES: ENABLE&lt;/code&gt; tells &lt;code&gt;xsubpp&lt;/code&gt;
to define subroutine prototypes for any xsubs we create. This is usually what
you want: prototypes can help Perl catch compile time errors.&lt;/p&gt;

&lt;p&gt;The last two lines of the file are an xsub:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unsigned int
rand()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first line defines the return type. The second line does two things: it
indicates the name of the C function to be called &lt;em&gt;and&lt;/em&gt; it defines the
signature of the xsub.&lt;/p&gt;

&lt;p&gt;In this case we&amp;rsquo;re calling &lt;code&gt;rand&lt;/code&gt; and accepting no parameters. This isn&amp;rsquo;t
Perl&amp;rsquo;s built-in rand function, &lt;em&gt;this&lt;/em&gt; rand comes from stdlib.h.&lt;/p&gt;

&lt;p&gt;The final thing we need is a &lt;code&gt;Makefile.PL&lt;/code&gt; script - as XS code is compiled, we
need a tool to build it before we can use it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use 5.008005;
use ExtUtils::MakeMaker 7.12; # for XSMULTI option

WriteMakefile(
  NAME           =&amp;gt; &#39;XS::Tutorial&#39;,
  VERSION_FROM   =&amp;gt; &#39;lib/XS/Tutorial.pm&#39;,
  PREREQ_PM      =&amp;gt; { &#39;ExtUtils::MakeMaker&#39; =&amp;gt; &#39;7.12&#39; },
  ABSTRACT_FROM  =&amp;gt; &#39;lib/XS/Tutorial.pm&#39;,
  AUTHOR         =&amp;gt; &#39;David Farrell&#39;,
  CCFLAGS        =&amp;gt; &#39;-Wall -std=c99&#39;,
  OPTIMIZE       =&amp;gt; &#39;-O3&#39;,
  LICENSE        =&amp;gt; &#39;freebsd&#39;,
  XSMULTI        =&amp;gt; 1,
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The ExtUtils::MakeMaker &lt;a href=&#34;https://metacpan.org/pod/ExtUtils::MakeMaker&#34;&gt;docs&lt;/a&gt; explain these options.&lt;/p&gt;

&lt;p&gt;But let&amp;rsquo;s talk about &lt;code&gt;XSMULTI&lt;/code&gt;. This is a relatively new feature which allows
you to have separate .xs files for modules. By default EUMM assumes the xs
file matches the distribution name. In this case that would mean having a single
Tutorial.xs file, with multiple xs &lt;code&gt;MODULE&lt;/code&gt; and &lt;code&gt;PACKAGE&lt;/code&gt; declarations in it.
By using &lt;code&gt;XSMULTI&lt;/code&gt;, we can have multiple XS files, one for each module in the
distribution instead.&lt;/p&gt;

&lt;p&gt;*Actually it searches for compiled C code but the effect is the same.&lt;/p&gt;

&lt;h3 id=&#34;building&#34;&gt;Building&lt;/h3&gt;

&lt;p&gt;Now we should have four files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lib/XS/Tutorial.pm
lib/XS/Tutorial/One.pm
lib/XS/Tutorial/One.xs
Makefile.PL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following commands will build the distribution:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl Makefile.PL
$ make
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-minor-essay-to-understand-xsubpp-generated-c&#34;&gt;A minor essay to understand xsubpp generated C&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;make&lt;/code&gt; creates a bunch of files, but take a look at &lt;code&gt;lib/XS/Tutorial/One.c&lt;/code&gt;.
This is the output of &lt;code&gt;xsubpp&lt;/code&gt;. If you look closely enough, you can find the
lines of C code from &lt;code&gt;lib/XS/Tutorial/One.xs&lt;/code&gt; in there. But checkout what
happened to our &lt;code&gt;rand&lt;/code&gt; xsub:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;XS_EUPXS(XS_XS__Tutorial__One_rand); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_XS__Tutorial__One_rand)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  &amp;quot;&amp;quot;);
    {
  unsigned int        RETVAL;
  dXSTARG;

  RETVAL = rand();
  XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;xsubpp&lt;/code&gt; has replaced our XS code with some rather ugly C macros! These macros
are part of the Perl interpreter&amp;rsquo;s C API. Many are documented in &lt;a href=&#34;https://perldoc.perl.org/perlapi.html&#34;&gt;perlapi&lt;/a&gt;
and they are usually defined in &lt;code&gt;XSUB.h&lt;/code&gt; or &lt;code&gt;perl.h&lt;/code&gt; in the Perl source code.&lt;/p&gt;

&lt;p&gt;So what are these macros doing? At a high level, &lt;code&gt;dVAR&lt;/code&gt; and &lt;code&gt;dXSARGS&lt;/code&gt; setup
the global pointer stack and some local variables. &lt;code&gt;items&lt;/code&gt; is a count of the
arguments supplied to the xsub. As &lt;code&gt;rand&lt;/code&gt; is a void function, if this isn&amp;rsquo;t
zero, it croaks. &lt;code&gt;croak_xs_usage&lt;/code&gt; takes a coderef and an args string. In this
context &lt;code&gt;cv&lt;/code&gt; is the xsub, and there are no args so the string is empty.&lt;/p&gt;

&lt;p&gt;Next the code declares &lt;code&gt;RETVAL&lt;/code&gt;, the return value of the xsub. &lt;code&gt;dXTARG&lt;/code&gt;
initializes the &lt;code&gt;TARG&lt;/code&gt; pointer. Next &lt;code&gt;rand()&lt;/code&gt; is called its return value
assigned to &lt;code&gt;RETVAL&lt;/code&gt;. &lt;code&gt;XSprePUSH&lt;/code&gt; moves the stack pointer back one,
and &lt;code&gt;PUSHu&lt;/code&gt; copies &lt;code&gt;RETVAL&lt;/code&gt; into &lt;code&gt;TARG&lt;/code&gt; and pushes it onto the global stack
pointer. &lt;code&gt;XSRETURN&lt;/code&gt; returns from the xsub, indicating how many arguments it
added to the stack, which in this case, is one.&lt;/p&gt;

&lt;p&gt;Writing XS, you usually don&amp;rsquo;t need to study the generated C code, but it&amp;rsquo;s
helpful to have an awareness of the process.&lt;/p&gt;

&lt;h3 id=&#34;installing&#34;&gt;Installing&lt;/h3&gt;

&lt;p&gt;Now the code is compiled, install it with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you&amp;rsquo;re using system Perl, you may need to use &lt;code&gt;sudo&lt;/code&gt; to install. Now we can
test the module using a one liner:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl -MXS::Tutorial::One -E &#39;say XS::Tutorial::One::rand()&#39;
1804289383
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It works! Did you try running it twice though?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl -MXS::Tutorial::One -E &#39;say XS::Tutorial::One::rand()&#39;
1804289383
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We get the same pseudorandom sequence each time&amp;hellip; We need to call &lt;code&gt;srand&lt;/code&gt; to
seed the sequence. That function is already provided by &lt;code&gt;stdlib.h&lt;/code&gt;, so all we
need to do is append the following text to &lt;code&gt;lib/XS/Tutorial/One.xs&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void
srand(seed)
  unsigned int seed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This xsub is different to the first one: its return type is &lt;code&gt;void&lt;/code&gt; which
means it returns nothing. It also includes a parameter called &lt;code&gt;seed&lt;/code&gt; in its
signature, and the last line defines it as an unsigned int.&lt;/p&gt;

&lt;p&gt;Rebuild and install the distribution:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can seed the pseudorandom sequence by calling &lt;code&gt;srand&lt;/code&gt; before &lt;code&gt;rand&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl -MXS::Tutorial::One -E &#39;XS::Tutorial::One::srand(777);\
say XS::Tutorial::One::rand()&#39;
947371799
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We used a lucky (777) seed number, and &lt;code&gt;rand&lt;/code&gt; emitted a different number, yay!&lt;/p&gt;

&lt;h3 id=&#34;did-we-beat-perl&#34;&gt;Did we beat Perl?&lt;/h3&gt;

&lt;p&gt;As you know by now, xsubs are often faster than pure Perl code. We&amp;rsquo;ve built two
xsubs for &lt;code&gt;rand&lt;/code&gt; and &lt;code&gt;srand&lt;/code&gt;, which are also available as built-in functions
in Perl. Do you think the xsubs are faster? Here&amp;rsquo;s a benchmark from my machine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;              Rate xs_rand bi_rand
xs_rand 15691577/s      --    -64%
bi_rand 43095739/s    175%      --
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oh no! Despite our &lt;code&gt;rand&lt;/code&gt; xsub directly calling the C &lt;code&gt;stdlib&lt;/code&gt; function, it&amp;rsquo;s
miles slower than Perl&amp;rsquo;s built-in &lt;code&gt;rand&lt;/code&gt;. This isn&amp;rsquo;t because xsubs are slow,
rather that Perl&amp;rsquo;s built-in functions are really fast. There is an overhead
associated with calling xsubs which built-in functions do not pay.&lt;/p&gt;

&lt;h3 id=&#34;tests&#34;&gt;Tests&lt;/h3&gt;

&lt;p&gt;Instead of running one liners to check our code works, we can write unit tests.
Here&amp;rsquo;s a basic script:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/perl
use Test::More;

BEGIN { use_ok &#39;XS::Tutorial::One&#39; }

ok my $rand = XS::Tutorial::One::rand(), &#39;rand()&#39;;
like $rand, qr/^\d+$/, &#39;rand() returns a number&#39;;

ok !defined XS::Tutorial::One::srand(5), &#39;srand()&#39;;
ok $rand ne XS::Tutorial::One::rand(), &#39;after srand, rand returns different number&#39;;
done_testing;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Save this file as &lt;code&gt;t/one.t&lt;/code&gt;. Assuming you built and installed the distribution
already, you can just do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl t/one.t
ok 1 - use XS::Tutorial::One;
ok 2 - rand()
ok 3 - rand() returns a number
ok 4 - srand()
ok 5 - after srand, rand returns different number
1..5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now when building the distribution in the future, you should do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl Makefile.PL &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will rebuild and test the distribution. Because XS code is compiled,
writing tests and using that one liner, you can quickly cycle through coding
and testing.&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t forget to add Test::More to the &lt;code&gt;PREREQ_PM&lt;/code&gt; entry in &lt;code&gt;Makefile.PL&lt;/code&gt;. When
you don&amp;rsquo;t have a specific minimum version, you can just use 0:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PREREQ_PM =&amp;gt; { &#39;Test::More&#39; =&amp;gt; 0, &#39;ExtUtils::MakeMaker&#39; =&amp;gt; &#39;7.12&#39; },
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;cleanup&#34;&gt;Cleanup&lt;/h3&gt;

&lt;p&gt;Building distributions generates a lot of temporary files. ExtUtils::MakeMaker
provides a realclean routine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ make realclean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will delete all the build files and reset the working directory to normal.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;This article and code are on CPAN as &lt;a href=&#34;https://metacpan.org/pod/XS::Tutorial::One&#34;&gt;XS::Tutorial::One&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;XS Mechanics by Steven W. McDougall is my second favorite :) XS &lt;a href=&#34;http://world.std.com/~swmcd/steven/perl/pm/xs/intro/&#34;&gt;tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://perldoc.perl.org/perlxs.html&#34;&gt;perlxs&lt;/a&gt; defines the keywords recognized by &lt;a href=&#34;https://perldoc.perl.org/xsubpp.html&#34;&gt;xsubpp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://perldoc.perl.org/perlapi.html&#34;&gt;perlapi&lt;/a&gt; : C macros used to interact with Perl data structures (and the interpreter)&lt;/li&gt;
&lt;li&gt;The &lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/9699919799/&#34;&gt;stdlib.h&lt;/a&gt; man page defines the C standard library functions and types&lt;/li&gt;
&lt;li&gt;For writing Makefile.PL files: ExtUtils::MakeMaker &lt;a href=&#34;https://metacpan.org/pod/ExtUtils::MakeMaker&#34;&gt;docs&lt;/a&gt; are invaluable&lt;/li&gt;
&lt;li&gt;Perl&amp;rsquo;s built-in &lt;a href=&#34;https://perldoc.perl.org/functions/rand.html&#34;&gt;rand&lt;/a&gt; and &lt;a href=&#34;https://perldoc.perl.org/functions/srand.html&#34;&gt;srand&lt;/a&gt; functions&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The road to a 55x speedup with XS</title>
      <link>http://localhost:1313/article/the-road-to-a-55x-speedup-with-xs/</link>
      <pubDate>Tue, 14 Jun 2016 20:54:51 +0000</pubDate>
      
      <guid>http://localhost:1313/article/the-road-to-a-55x-speedup-with-xs/</guid>
      <description>

&lt;p&gt;Lately my client has been concerned with improving their application speed, so naturally I started to think about XS, Perl&amp;rsquo;s C macro language. With XS you can write C code and call it from Perl.&lt;/p&gt;

&lt;p&gt;To test the waters I wrote a simple URI encoder/decoder in C and with some trial-and-error managed to make &lt;a href=&#34;https://metacpan.org/pod/URI::Encode::XS&#34;&gt;URI::Encode::XS&lt;/a&gt;, a module that used it. &amp;ldquo;This is easy!&amp;rdquo; I thought and excitedly typed out a benchmarking &lt;a href=&#34;https://github.com/dnmfarrell/URI-Encode-XS/blob/master/bench&#34;&gt;script&lt;/a&gt;. I benchmarked my module against &lt;a href=&#34;https://metacpan.org/pod/URI::Escape&#34;&gt;URI::Escape&lt;/a&gt; a venerable but rather slow &lt;em&gt;pure-Perl&lt;/em&gt; URI encoder/decoder. You can imagine how crestfallen I was when I read the benchmark results to find that all of my effort only netted a 20% speedup. I wondered if Perl&amp;rsquo;s string routines are so fast they&amp;rsquo;re hard to improve upon.&lt;/p&gt;

&lt;h3 id=&#34;renewed-hope&#34;&gt;Renewed hope&lt;/h3&gt;

&lt;p&gt;Enter &lt;a href=&#34;https://metacpan.org&#34;&gt;URI::XSEscape&lt;/a&gt;, a &amp;ldquo;quick and dirty&amp;rdquo; (the authors&amp;rsquo; words) XS implementation of URI::Escape. It was uploaded to CPAN last month. You can see the authors&amp;rsquo; &lt;a href=&#34;https://metacpan.org/pod/URI::XSEscape#BENCHMARKS&#34;&gt;benchmarks&lt;/a&gt; for yourself, but in my testing it appeared to be about 18.5 times faster than URI::Escape. That&amp;rsquo;s not a misprint - on my laptop it encoded 2.75m strings per second, compared to 138k for URI::Escape. So how did they do it?&lt;/p&gt;

&lt;p&gt;First let&amp;rsquo;s look at my naive C encode implementation:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;void &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;uri_encode (char &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;uri, const char &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;special_chars, char &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;buffer)
{
  int i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
  &lt;span style=&#34;color:#e6db74&#34;&gt;/* \0 is null, end of the string */&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (uri[i] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;)
  {
    int encode_char &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    int j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (special_chars[j] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;)
    {
      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (uri[i] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; special_chars[j])
      {
        &lt;span style=&#34;color:#e6db74&#34;&gt;/* do not encode char as it is in the special_chars set */&lt;/span&gt;
        encode_char &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        break;
      }
      j&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (encode_char &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
    {
      char code[&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;];
      sprintf(code, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%%%02X&amp;#34;&lt;/span&gt;, uri[i]);
      strcat(buffer, code);
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
    {
      char code[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;];
      code[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; uri[i];
      code[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;;
      strcat(buffer, code);
    }
    i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically what this does is loop through the &lt;code&gt;uri&lt;/code&gt; string, looking characters that are in the &lt;code&gt;special_chars&lt;/code&gt; string, and if it finds a match, it percent encodes the character with &lt;code&gt;sprintf&lt;/code&gt; and appends the result to &lt;code&gt;buffer&lt;/code&gt; which is the encoded string. Compare this with the encode function from &lt;code&gt;URI::XSEscape&lt;/code&gt; (I&amp;rsquo;ve simplified it slightly):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;Buffer&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; uri_encode(Buffer&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; src, int length,
                   Buffer&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; tgt)
{
    int s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; src&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;pos;
    int t &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; tgt&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;pos;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (s &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; (src&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;pos &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; length)) {
        unsigned char u &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (unsigned char) src&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;data[s];
        char&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; v &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; uri_encode_tbl[(int)u];

        &lt;span style=&#34;color:#f92672&#34;&gt;/*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; current source character doesn&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;t need to be encoded,
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;           just copy it to target*/
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        if (!v) {
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;            tgt-&amp;gt;data[t++] = src-&amp;gt;data[s++];
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;            continue;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        }
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        /* copy encoded character from our table */
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        tgt-&amp;gt;data[t+0] = &amp;#39;&lt;/span&gt;%&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;#39;;&lt;/span&gt;
        tgt&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;data[t&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; v[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;];
        tgt&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;data[t&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; v[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];

        &lt;span style=&#34;color:#f92672&#34;&gt;/*&lt;/span&gt; we used up &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; characters (%XY) in target
         &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; character from source &lt;span style=&#34;color:#f92672&#34;&gt;*/&lt;/span&gt;
        t &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;;
        &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;s;
    }
    &lt;span style=&#34;color:#e6db74&#34;&gt;/* null-terminate target and return src as was left */&lt;/span&gt;
    src&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;pos &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s;
    tgt&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;pos &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; t;
    buffer_terminate(tgt);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; src;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This code loops through the input string but instead of comparing the current character to another string of special characters, it does a table lookup. This is much faster than looping through another string. Note how it doesn&amp;rsquo;t use &lt;code&gt;sprintf&lt;/code&gt; either - all the hex codes are pre-computed in &lt;code&gt;uri_encode_tbl&lt;/code&gt;. Finally, instead of creating a new string and concatenating it to the output string, this code simply copies the output directly to the output string&amp;rsquo;s memory location.&lt;/p&gt;

&lt;p&gt;This code also avoid a subtle bug with my implementation: Perl strings can contain null characters, but in C null is used to terminate strings. Because URI::XSEscape&amp;rsquo;s encode function accepts a length argument, it can encode strings will nulls and my version can&amp;rsquo;t.&lt;/p&gt;

&lt;h3 id=&#34;going-faster&#34;&gt;Going faster&lt;/h3&gt;

&lt;p&gt;At this point I updated the encode/decode functions in URI::Encode::XS to be table based like URI::XSEscape and saw huge gains in performance, making URI::Encode::XS about 25 times faster than URI::Escape (URI::Encode::XS doesn&amp;rsquo;t support user-defined escape values, so it&amp;rsquo;s simpler than URI::XSEscape). I thought a 25x improvement was as good as it got, and was about done with the module, when I was contacted by &lt;a href=&#34;https://metacpan.org/author/CHANSEN&#34;&gt;Christian Hansen&lt;/a&gt; (author of &lt;a href=&#34;https://metacpan.org/release/Time-Moment&#34;&gt;Time::Moment&lt;/a&gt;). Christian overhauled my simple XS code to make it safer and faster. This is what became of the &lt;code&gt;uri_encode&lt;/code&gt; C function:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;size_t uri_encode (const char &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;src, const size_t len, char &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;dst)
{
  size_t i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len
  {
    const char &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; code &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; uri_encode_tbl[ (unsigned char)src[i] ];
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (code)
    {
      memcpy(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;dst[j], code, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;);
      j &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
    {
      dst[j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; src[i];
      j&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
    }
    i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
  }
  dst[j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; j;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This version looks up the character value in a pre-computed table and then uses &lt;code&gt;memcpy&lt;/code&gt; to append it to the output string (avoiding 3 separate assignments). It also returns the length of encoded string, which is useful. After Christian&amp;rsquo;s optimizations, my benchmarking &lt;a href=&#34;https://github.com/dnmfarrell/URI-Encode-XS/blob/master/bench&#34;&gt;script&lt;/a&gt; showed URI::Encode::XS&amp;rsquo;s encoding function to be 55 times faster than URI::Escape (about 8m encoded strings per second). Much of the gains came from optimizing the &lt;a href=&#34;https://github.com/dnmfarrell/URI-Encode-XS/blob/df8009e9d7af4cf243fa29ca8aaa23982feeba58/XS.xs#L143&#34;&gt;xsub&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;the-power-of-c-the-pleasure-of-perl&#34;&gt;The power of C, the pleasure of Perl&lt;/h3&gt;

&lt;p&gt;To me the most magical thing about XS code is you call it from Perl:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; URI::Encode::XS &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;uri_encode&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $encoding &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; uri_encode($some_string); &lt;span style=&#34;color:#75715e&#34;&gt;# super fast&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So the user has the convenience of writing Perl code, but the benefit of the faster implementation. Perl is already pretty fast, but there are certain operations that are expensive. If you work on a Perl application, how much faster would it be if you could make all of the bottlenecks 55 times faster?&lt;/p&gt;

&lt;h3 id=&#34;learning-xs&#34;&gt;Learning XS&lt;/h3&gt;

&lt;p&gt;If you&amp;rsquo;d like to learn more about XS, I&amp;rsquo;d strongly recommend this &lt;a href=&#34;http://world.std.com/~swmcd/steven/perl/pm/xs/intro/index.html&#34;&gt;series&lt;/a&gt; by Steven W McDougall. It&amp;rsquo;s the best introduction I know of.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/xsawyerx/xs-fun&#34;&gt;XS is Fun&lt;/a&gt; is a more modern introduction to XS programming that takes you through the steps of writing an XS module and importing a C library.&lt;/p&gt;

&lt;p&gt;Chapter 18 &amp;ldquo;Extending Perl: A First Course&amp;rdquo; in &lt;a href=&#34;http://shop.oreilly.com/product/9781565922204.do&#34;&gt;Advanced Perl Programming&lt;/a&gt; first edition has a good introduction to XS. It covers the most common macros for scalars, arrays and hashes which is useful (the second edition doesn&amp;rsquo;t cover XS). &lt;a href=&#34;https://www.manning.com/books/extending-and-embedding-perl&#34;&gt;Extending and Embedding Perl&lt;/a&gt; goes further, with several tutorials on the different ways to call and receive data from XS. Both books are a bit dated but I found them valuable and an easier read than the official docs.&lt;/p&gt;

&lt;p&gt;The official Perl documentation has useful reference sources: &lt;a href=&#34;https://perldoc.perl.org/perlxs.html&#34;&gt;perlxs&lt;/a&gt;, &lt;a href=&#34;https://perldoc.perl.org/perlapi.html&#34;&gt;perlapi&lt;/a&gt; and &lt;a href=&#34;https://perldoc.perl.org/perlxs.html&#34;&gt;perlguts&lt;/a&gt;. There is also &lt;a href=&#34;https://perldoc.perl.org/perlxs.html&#34;&gt;perlxstut&lt;/a&gt; but I would skip that in favor of the above resources.&lt;/p&gt;

&lt;p&gt;Several times I&amp;rsquo;ve found XS macros used in Perl code that are not explained in any documentation (e.g. &lt;code&gt;dXSTARG&lt;/code&gt;). In those cases it pays to have a copy of the Perl &lt;a href=&#34;https://www.perl.org/get.html&#34;&gt;source code&lt;/a&gt; - just grep the source and you&amp;rsquo;ll find its definition with a comment (typically in &lt;code&gt;pp.h&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&#34;a-note-on-the-benchmarks&#34;&gt;A note on the benchmarks&lt;/h3&gt;

&lt;p&gt;The benchmarks in this article were all run on my laptop, a Dell XPS 13 with 8GB RAM running Fedora 23. Different hardware will yield different results (Christian&amp;rsquo;s benchmark showed URI::Encode::XS to be 90x (!) faster than URI::Escape).&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/dnmfarrell/URI-Encode-XS/blob/master/bench&#34;&gt;script&lt;/a&gt; counts how many times each module can encode a string per second. But a string of a different length, or with a different number of reserved characters will yield a different benchmark. For example benchmarking an empty string shows URI::Encode::XS to be just 9x times faster on my laptop.&lt;/p&gt;

&lt;p&gt;The module versions were URI::Encode::XS v0.08 and URI::Escape v3.31. The Perl version was 5.22.&lt;/p&gt;

&lt;h3 id=&#34;thanks&#34;&gt;Thanks&lt;/h3&gt;

&lt;p&gt;A big thank you to Christian Hansen and Jesse DuMond for your help with URI::Encode::XS. The module would not be half of what it is without your contributions.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pathologically Polluting Perl</title>
      <link>http://localhost:1313/pub/2001/02/inline.html/</link>
      <pubDate>Tue, 06 Feb 2001 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2001/02/inline.html/</guid>
      <description>

&lt;h3 id=&#34;pathologically-polluting-perl&#34;&gt;Pathologically Polluting Perl&lt;/h3&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Table of Contents&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;•&lt;a href=&#34;#inline%20in%20action%20%20simple%20examples%20in%20c&#34;&gt;Inline in Action - Simple examples in C&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#hello,%20world&#34;&gt;Hello, world&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#just%20another%20____%20hacker&#34;&gt;Just Another ____ Hacker&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#what%20about%20xs%20and%20swig&#34;&gt;What about XS and SWIG?&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#oneliners&#34;&gt;One-Liners&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#supported%20platforms%20for%20c&#34;&gt;Supported Platforms for C&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#the%20inline%20syntax&#34;&gt;The Inline Syntax&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#fine%20dining%20%20a%20glimpse%20at%20the%20c%20cookbook&#34;&gt;Fine Dining - A Glimpse at the C Cookbook&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#external%20libraries&#34;&gt;External Libraries&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#it%20takes%20all%20types&#34;&gt;It Takes All Types&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#some%20ware%20beyond%20the%20c&#34;&gt;Some Ware Beyond the C&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#see%20perl%20run.%20run%20perl,%20run!&#34;&gt;See Perl Run. Run, Perl, Run!&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#the%20future%20of%20inline&#34;&gt;The Future of Inline&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;br /&gt;
&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;No programming language is Perfect. Perl comes very close. &lt;strong&gt;P&lt;/strong&gt;! &lt;strong&gt;e&lt;/strong&gt;! &lt;strong&gt;r&lt;/strong&gt;! &lt;em&gt;l&lt;/em&gt;? :-( Not quite ``Perfect&amp;rdquo;. Sometimes it just makes sense to use another language for part of your work. You might have a stable, pre-existing code base to take advantage of. Perhaps maximum performance is the issue. Maybe you just ``know how to do it&amp;rdquo; that way. Or very likely, it&amp;rsquo;s a project requirement forced upon you by management. Whatever the reason, wouldn&amp;rsquo;t it be great to use Perl most of the time, but be able to invoke something else when you had to?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Inline.pm&lt;/code&gt; is a new module that glues other programming languages to Perl. It allows you to write C, C++, and Python code directly inside your Perl scripts and modules. This is conceptually similar to the way you can write inline assembly language in C programs. Thus the name: &lt;code&gt;Inline.pm&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The basic philosophy behind Inline is this: ``make it as easy as possible to use Perl with other programming languages, while ensuring that the user&amp;rsquo;s experience retains the DWIMity of Perl&amp;rdquo;. To accomplish this, Inline must do away with nuisances such as interface definition languages, makefiles, build directories and compiling. You simply write your code and run it. Just like Perl.&lt;/p&gt;

&lt;p&gt;Inline will silently take care of all the messy implementation details and ``do the right thing&amp;rdquo;. It analyzes your code, compiles it if necessary, creates the correct Perl bindings, loads everything up, and runs the whole schmear. The net effect of this is you can now write functions, subroutines, classes, and methods in another language and call them as if they were Perl.&lt;/p&gt;

&lt;h3 id=&#34;span-id-inline-in-action-simple-examples-in-c-inline-in-action-simple-examples-in-c-span&#34;&gt;&lt;span id=&#34;inline in action  simple examples in c&#34;&gt;Inline in Action - Simple examples in C&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Inline addresses an old problem in a completely revolutionary way. Just describing Inline doesn&amp;rsquo;t really do it justice. It should be &lt;em&gt;seen&lt;/em&gt; to be fully appreciated. Here are a couple examples to give you a feel for the module.&lt;/p&gt;

&lt;h3 id=&#34;span-id-hello-world-hello-world-span&#34;&gt;&lt;span id=&#34;hello, world&#34;&gt;Hello, world&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;It seems that the first thing any programmer wants to do when he learns a new programming technique is to use it to greet the Earth. In keeping with that tradition, here is the ``Hello, world&amp;rdquo; program using Inline.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Inline C =&amp;gt; &amp;lt;&amp;lt;&#39;END_C&#39;;
    void greet() {
        printf(&amp;quot;Hello, world\n&amp;quot;);
    }
    END_C

    greet;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Simply run this script from the command line and it will print (you guessed it):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Hello, world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example, &lt;code&gt;Inline.pm&lt;/code&gt; is instantiated with the name of a programming language, ``C&amp;rdquo;, and a string containing a piece of that language&amp;rsquo;s source code. This C code defines a function called &lt;code&gt;greet()&lt;/code&gt; which gets bound to the Perl subroutine &lt;code&gt;&amp;amp;main::greet&lt;/code&gt;. Therefore, when we call the &lt;code&gt;greet()&lt;/code&gt; subroutine, the program prints our message on the screen.&lt;/p&gt;

&lt;p&gt;You may be wondering why there are no &lt;code&gt;#include&lt;/code&gt; statements for things like &lt;code&gt;stdio.h&lt;/code&gt;? That&amp;rsquo;s because Inline::C automatically prepends the following lines to the top of your code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #include &amp;quot;EXTERN.h&amp;quot;
    #include &amp;quot;perl.h&amp;quot;
    #include &amp;quot;XSUB.h&amp;quot;
    #include &amp;quot;INLINE.h&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These header files include all of the standard system header files, so you almost never need to use &lt;code&gt;#include&lt;/code&gt; unless you are dealing with a non-standard library. This is in keeping with Inline&amp;rsquo;s philosophy of making easy things easy. (Where have I heard that before?)&lt;/p&gt;

&lt;h3 id=&#34;span-id-just-another-hacker-just-another-hacker-span&#34;&gt;&lt;span id=&#34;just another ____ hacker&#34;&gt;Just Another ____ Hacker&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The next logical question is, ``How do I pass data back and forth between Perl and C?&amp;rdquo; In this example we&amp;rsquo;ll pass a string to a C function and have it pass back a brand new Perl scalar.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Inline C;
    print JAxH(&#39;Perl&#39;);


    __END__
    __C__
    SV* JAxH(char* x) {
        return newSVpvf(&amp;quot;Just Another %s Hacker\n&amp;quot;, x);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you run this program, it prints:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Just Another Perl Hacker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;ve probably noticed that this example is coded differently then the last one. The &lt;code&gt;use Inline&lt;/code&gt; statement specifies the language being used, but not the source code. This is an indicator for Inline to look for the source at the end of the program, after the special marker &amp;lsquo;&lt;code&gt;__C__&lt;/code&gt;&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;The concept being demonstrated is that we can pass Perl data in and out of a C function. Using the default Perl type conversions, Inline can easily convert all of the basic Perl data types to C and vice-versa.&lt;/p&gt;

&lt;p&gt;This example uses a couple of the more advanced concepts of Inlining. Its return value is of the type &lt;code&gt;SV*&lt;/code&gt; (or Scalar Value). The Scalar Value is the most common Perl internal type. Also, the Perl internal function &lt;code&gt;newSVpfv()&lt;/code&gt; is called to create a new Scalar Value from a string, using the familiar &lt;code&gt;sprintf()&lt;/code&gt; syntax. You can learn more about simple Perl internals by reading the &lt;code&gt;perlguts&lt;/code&gt; and &lt;code&gt;perlapi&lt;/code&gt; documentation distributed with Perl.&lt;/p&gt;

&lt;h3 id=&#34;span-id-what-about-xs-and-swig-what-about-xs-and-swig-span&#34;&gt;&lt;span id=&#34;what about xs and swig&#34;&gt;What about XS and SWIG?&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s detour momentarily to ponder ``Why Inline?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;There are already two major facilities for extending Perl with C. They are XS and SWIG. Both are similar in their capabilities, at least as far as Perl is concerned. And both of them are quite difficult to learn compared to Inline. Since SWIG isn&amp;rsquo;t used in practice to nearly the degree that XS is, I&amp;rsquo;ll only address XS.&lt;/p&gt;

&lt;p&gt;There is a big fat learning curve involved with setting up and using the XS environment. You need to get quite intimate with the following docs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; * perlxs
 * perlxstut
 * perlapi
 * perlguts
 * perlcall
 * perlmod
 * h2xs
 * xsubpp
 * ExtUtils::MakeMaker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With Inline you can be up and running in minutes. There is a C Cookbook with lots of short but complete programs that you can extend to your real-life problems. No need to learn about the complicated build process going on in the background. You don&amp;rsquo;t even need to compile the code yourself. Perl programmers cannot be bothered with silly things like compiling. ``Tweak, Run, Tweak, Run&amp;rdquo; is our way of life. Inline takes care of every last detail except writing the C code.&lt;/p&gt;

&lt;p&gt;Another advantage of Inline is that you can use it directly in a script. As we&amp;rsquo;ll soon see, you can even use it in a Perl one-liner. With XS and SWIG, you always set up an entirely separate module, even if you only have one or two functions. Inline makes easy things easy, and hard things possible. Just like Perl.&lt;/p&gt;

&lt;p&gt;Finally, Inline supports several programming languages (not just C and C++). As of this writing, Inline has support for C, C++, Python, and CPR. There are plans to add many more.&lt;/p&gt;

&lt;h3 id=&#34;span-id-oneliners-one-liners-span&#34;&gt;&lt;span id=&#34;oneliners&#34;&gt;One-Liners&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Perl is famous for its one-liners. A Perl one-liner is short piece of Perl code that can accomplish a task that would take much longer in another language. It is one of the popular techniques that Perl hackers use to flex their programming muscles.&lt;/p&gt;

&lt;p&gt;So you may wonder: ``Is Inline powerful enough to produce a one-liner that is also bonifide C extension?&amp;rdquo; Of course it is! Here you go:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    perl -e &#39;use Inline C=&amp;gt;
    q{void J(){printf(&amp;quot;Just Another Perl Hacker\n&amp;quot;);}};J&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Try doing that with XS! We can even write the more complex Inline &lt;code&gt;JAxH()&lt;/code&gt; discussed earlier as a one-liner:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    perl -le &#39;use Inline C=&amp;gt;
    q{SV*JAxH(char*x){return newSVpvf(&amp;quot;Just Another %s Hacker&amp;quot;,x);}};print JAxH+Perl&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I have been using this one-liner as my email signature for the past couple months. I thought it was pretty cool until Bernhard Muenzer posted this gem to &lt;code&gt;comp.lang.perl.modules&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #!/usr/bin/perl -- -* Nie wieder Nachtschicht! *- -- lrep\nib\rsu\!#
    use Inline C=&amp;gt;&#39;void C(){int m,u,e=0;float l,_,I;for(;1840-e;putchar((++e&amp;gt;907
     &amp;amp;&amp;amp;942&amp;gt;e?61-m:u)[&amp;quot;\n)moc.isc@rezneumb(rezneuM drahnreB&amp;quot;]))for(u=_=l=0;79-(m
      =e%80)&amp;amp;&amp;amp;I*l+_*_&amp;lt;6&amp;amp;&amp;amp;26-++u;_=2*l*_+e/80*.09-1,l=I)I=l*l-_*_-2+m/27.;}&#39;;&amp;amp;C
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-supported-platforms-for-c-supported-platforms-for-c-span&#34;&gt;&lt;span id=&#34;supported platforms for c&#34;&gt;Supported Platforms for C&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Inline C works on all of the Perl platforms that I have tested it with so far. This includes all common Unixes and recent versions of Microsoft Windows. The only catch is that you must have the same compiler and &lt;code&gt;make&lt;/code&gt; utility that was used to build your &lt;code&gt;perl&lt;/code&gt; binary.&lt;/p&gt;

&lt;p&gt;Inline has been successfully used on Linux, Solaris, AIX, HPUX, and all the recent BSD&amp;rsquo;s.&lt;/p&gt;

&lt;p&gt;There are two common ways to use Inline on MS Windows. The first one is with ActiveState&amp;rsquo;s ActivePerl for MSWin32. In order to use Inline in that environment, you&amp;rsquo;ll need a copy of MS Visual C++ 6.0. This comes with the &lt;code&gt;cl.exe&lt;/code&gt; compiler and the &lt;code&gt;nmake&lt;/code&gt; make utility. Actually these are the only parts you need. The visual components aren&amp;rsquo;t necessary for Inline.&lt;/p&gt;

&lt;p&gt;The other alternative is to use the Cygwin utilities. This is an actual Unix porting layer for Windows. It includes all of the most common Unix utilities, such as &lt;code&gt;bash&lt;/code&gt;, &lt;code&gt;less&lt;/code&gt;, &lt;code&gt;make&lt;/code&gt;, &lt;code&gt;gcc&lt;/code&gt; and of course &lt;code&gt;perl&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-inline-syntax-the-inline-syntax-span&#34;&gt;&lt;span id=&#34;the inline syntax&#34;&gt;The Inline Syntax&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Inline is a little bit different than most of the Perl modules that you are used to. It doesn&amp;rsquo;t import any functions into your namespace and it doesn&amp;rsquo;t have any object oriented methods. Its entire interface is specified through &lt;code&gt;&#39;use Inline ...&#39;&lt;/code&gt; commands. The general Inline usage is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Inline C =&amp;gt; source-code,
               config_option =&amp;gt; value,
               config_option =&amp;gt; value;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where &lt;code&gt;C&lt;/code&gt; is the programming language, and &lt;code&gt;source-code&lt;/code&gt; is a string, filename, or the keyword &amp;lsquo;&lt;code&gt;DATA&lt;/code&gt;&amp;rsquo;. You can follow that with any number of optional &amp;lsquo;&lt;code&gt;keyword =&amp;gt; value&lt;/code&gt;&amp;rsquo; configuration pairs. If you are using the &amp;lsquo;DATA&amp;rsquo; option, with no configuration parameters, you can just say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Inline C;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-fine-dining-a-glimpse-at-the-c-cookbook-fine-dining-a-glimpse-at-the-c-cookbook-span&#34;&gt;&lt;span id=&#34;fine dining  a glimpse at the c cookbook&#34;&gt;Fine Dining - A Glimpse at the C Cookbook&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In the spirit of the O&amp;rsquo;Reilly book ``Perl Cookbook&amp;rdquo;, Inline provides a manpage called C-Cookbook. In it you will find the recipes you need to help satisfy your Inline cravings. Here are a couple of tasty morsels that you can whip up in no time. Bon Appetit!&lt;/p&gt;

&lt;h3 id=&#34;span-id-external-libraries-external-libraries-span&#34;&gt;&lt;span id=&#34;external libraries&#34;&gt;External Libraries&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The most common real world need for Inline is probably using it to access existing compiled C code from Perl. This is easy to do. The secret is to write a wrapper function for each function you want to expose in Perl space. The wrapper calls the real function. It also handles how the arguments get passed in and out. Here is a short Windows example that displays a text box with a message, a caption and an ``OK&amp;rdquo; button:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Inline C =&amp;gt; DATA =&amp;gt;
               LIBS =&amp;gt; &#39;-luser32&#39;,
               PREFIX =&amp;gt; &#39;my_&#39;;

    MessageBoxA(&#39;Inline Message Box&#39;, &#39;Just Another Perl Hacker&#39;);


    __END__
    __C__
    #include &amp;lt;windows.h&amp;gt;
    int my_MessageBoxA(char* Caption, char* Text) {
      return MessageBoxA(0, Text, Caption, 0);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This program calls a function from the MSWin32 &lt;code&gt;user32.dll&lt;/code&gt; library. The wrapper determines the type and order of arguments to be passed from Perl. Even though the real &lt;code&gt;MessageBoxA()&lt;/code&gt; needs four arguments, we can expose it to Perl with only two, and we can change the order. In order to avoid namespace conflicts in C, the wrapper must have a different name. But by using the &lt;code&gt;PREFIX&lt;/code&gt; option (same as the XS &lt;code&gt;PREFIX&lt;/code&gt; option) we can bind it to the original name in Perl.&lt;/p&gt;

&lt;h3 id=&#34;span-id-it-takes-all-types-it-takes-all-types-span&#34;&gt;&lt;span id=&#34;it takes all types&#34;&gt;It Takes All Types&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Older versions of Inline only supported five C data types. These were: &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;char*&lt;/code&gt; and &lt;code&gt;SV*&lt;/code&gt;. This was all you needed. All the basic Perl scalar types are represented by these. Fancier things like references could be handled by using the generic &lt;code&gt;SV*&lt;/code&gt; (scalar value) type, and then doing the mapping code yourself, inside the C function.&lt;/p&gt;

&lt;p&gt;The process of converting between Perl&amp;rsquo;s &lt;code&gt;SV*&lt;/code&gt; and C types is called &lt;strong&gt;typemapping&lt;/strong&gt;. In XS, you normally do this by using &lt;code&gt;typemap&lt;/code&gt; files. A default &lt;code&gt;typemap&lt;/code&gt; file exists in every Perl installation in a file called &lt;code&gt;/usr/lib/perl5/5.6.0/ExtUtils/typemap&lt;/code&gt; or something similar. This file contains conversion code for over 20 different C types, including all of the Inline defaults.&lt;/p&gt;

&lt;p&gt;As of version 0.30, Inline no longer has &lt;em&gt;any&lt;/em&gt; built in types. It gets all of its types exclusively from &lt;code&gt;typemap&lt;/code&gt; files. Since it uses Perl&amp;rsquo;s default &lt;code&gt;typemap&lt;/code&gt; file for its own defaults, it actually has many more types available automatically.&lt;/p&gt;

&lt;p&gt;This setup provides a lot of flexibility. You can specify your own &lt;code&gt;typemap&lt;/code&gt; files through the use of the &lt;code&gt;TYPEMAPS&lt;/code&gt; configuration option. This not only allows you to override the defaults with your own conversion code, but it also means that you can add new types to Inline as well. The major advantage to extending the Inline syntax this way is that there are already many typemaps available for various APIs. And if you&amp;rsquo;ve done your own XS coding in the past, you can use your existing &lt;code&gt;typemap&lt;/code&gt; files as is. No changes are required.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at a small example of writing your own typemaps. For some reason, the C type &lt;code&gt;float&lt;/code&gt; is not represented in the default Perl &lt;code&gt;typemap&lt;/code&gt; file. I suppose it&amp;rsquo;s because Perl&amp;rsquo;s floating point numbers are always stored as type &lt;code&gt;double&lt;/code&gt;, which is higher precision than &lt;code&gt;float&lt;/code&gt;. But if we wanted it anyway, writing a &lt;code&gt;typemap&lt;/code&gt; file to support &lt;code&gt;float&lt;/code&gt; is trivial.&lt;/p&gt;

&lt;p&gt;Here is what the file would look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    float                   T_FLOAT


    INPUT
    T_FLOAT
            $var = (float)SvNV($arg)


    OUTPUT
    T_FLOAT
            sv_setnv($arg, (double)$var);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Without going into details, this file provides two snippets of code. One for converting a &lt;code&gt;SV*&lt;/code&gt; to a float, and one for the opposite. Now we can write the following script:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Inline C =&amp;gt; DATA =&amp;gt;
               TYPEMAPS =&amp;gt; &#39;./typemap&#39;;


    print &#39;1.2 + 3.4 = &#39;, fadd(1.2, 3.4), &amp;quot;\n&amp;quot;;


    __END__
    __C__
    float fadd(float x, float y) {
        return x + y;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-some-ware-beyond-the-c-some-ware-beyond-the-c-span&#34;&gt;&lt;span id=&#34;some ware beyond the c&#34;&gt;Some Ware Beyond the C&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The primary goal of Inline is to make it easy to use other programming languages with Perl. This is not limited to C. The initial implementations of Inline only supported C, and the language support was built directly into &lt;code&gt;Inline.pm&lt;/code&gt;. Since then things have changed considerably. Inline now supports multiple languages of both compiled and interpreted nature. And it keeps the implementations in an object oriented type structure, whereby each language has its own separate module, but they can inherit behavior from the base Inline module.&lt;/p&gt;

&lt;p&gt;On my second day working at ActiveState, a young man approached me. ``Hi, my name is Neil Watkiss. I just hacked your Inline module to work with C++.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Neil, I soon found out, was a computer science student at a local university. He was working part-time for ActiveState then, and had somehow stumbled across Inline. I was thrilled! I had wanted to pursue new languages, but didn&amp;rsquo;t know how I&amp;rsquo;d find the time. Now I was sitting 15 feet away from my answer!&lt;/p&gt;

&lt;p&gt;Over the next couple months, Neil and I spent our spare time turning Inline into a generic environment for gluing new languages to Perl. I ripped all the C specific code out of Inline and put it into Inline::C. Neil started putting together Inline::CPP and Inline::Python. Together we came up with a new syntax that allowed multiple languages and easier configuration.&lt;/p&gt;

&lt;p&gt;Here is a sample program that makes uses of Inline Python:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Inline Python;
    my $language = shift;
    print $language, 
          (match($language, &#39;Perl&#39;) ? &#39; rules&#39; : &#39; sucks&#39;),
          &amp;quot;!\n&amp;quot;;
    __END__
    __Python__
    import sys
    import re
    def match(str, regex):
        f = re.compile(regex);
        if f.match(str): return 1
        return 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This program uses a Python regex to show that ``Perl rules!&amp;ldquo;.&lt;/p&gt;

&lt;p&gt;Since Python supports its own versions of Perl scalars, arrays, and hashes, Inline::Python can flip-flop between them easily and logically. If you pass a hash reference to python, it will turn it into a dictionary, and vice-versa. Neil even has mechanisms for calling back to Perl from Python code. See the Inline::Python docs for more info.&lt;/p&gt;

&lt;h3 id=&#34;span-id-see-perl-run-run-perl-run-see-perl-run-run-perl-run-span&#34;&gt;&lt;span id=&#34;see perl run. run perl, run!&#34;&gt;See Perl Run. Run Perl, Run!&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Inline is a great way to write C extensions for Perl. But is there an equally simple way to embed a Perl interpreter in a C program? I pondered this question myself one day. Writing Inline functionality for C would not be my cup of tea.&lt;/p&gt;

&lt;p&gt;The normal way to embed Perl into C involves jumping through a lot of hoops to bootstrap a perl interpreter. Too messy for one-liners. And you need to compile the C. Not very Inlinish. But what if you could pass your C program to a perl program that could pass it to Inline? Then you could write this program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #!/usr/bin/cpr
    int main(void) {
        printf(&amp;quot;Hello, world\n&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and just run it from the command line. Interpreted C!&lt;/p&gt;

&lt;p&gt;And thus, a new programming language was born. &lt;strong&gt;CPR&lt;/strong&gt;. ``C Perl Run&amp;rdquo;. The Perl module that gives it life is called &lt;code&gt;Inline::CPR&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Of course, CPR is not really its own language, in the strict sense. But you can think of it that way. CPR is just like C except that you can call out to the Perl5 API at any time, without any extra code. In fact, CPR redefines this API with its own CPR wrapper API.&lt;/p&gt;

&lt;p&gt;There are several ways to think of CPR: ``a new language&amp;rdquo;, ``an easy way to embed Perl in C&amp;rdquo;, or just ``a cute hack&amp;rdquo;. I lean towards the latter. CPR is probably a far stretch from meeting most peoples embedding needs. But at the same time its a very easy way to play around with, and perhaps redefine, the Perl5 internal API. The best compliment I&amp;rsquo;ve gotten for CPR is when my ActiveState coworker Adam Turoff said, ``I feel like my head has just been wrapped around a brick&amp;rdquo;. I hope this next example makes you feel that way too:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #!/usr/bin/cpr
    int main(void) {
        CPR_eval(&amp;quot;use Inline (C =&amp;gt; q{
            char* greet() {
                return \&amp;quot;Hello world\&amp;quot;;
            }
        })&amp;quot;);

        printf(&amp;quot;%s, I&#39;m running under Perl version %s\n&amp;quot;,
               CPR_eval(&amp;quot;&amp;amp;greet&amp;quot;),
               CPR_eval(&amp;quot;use Config; $Config{version}&amp;quot;));
        return 0;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running this program prints:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Hello world, I&#39;m running under Perl version 5.6.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using the &lt;code&gt;eval()&lt;/code&gt; call this CPR program calls Perl and tells it to use Inline C to add a new function, which the CPR program subsequently calls. I think I have a headache myself.&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-future-of-inline-the-future-of-inline-span&#34;&gt;&lt;span id=&#34;the future of inline&#34;&gt;The Future of Inline&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Inline version 0.30 was written specifically so that it would be easy for other people in the Perl community to contribute new language bindings for Perl. On the day of that release, I announced the birth of the Inline mailing list, &lt;a href=&#34;mailto:inline@perl.org.&#34;&gt;inline@perl.org.&lt;/a&gt; This is intended to be the primary forum for discussion on all Inline issues, including the proposal of new features, and the authoring of new ILSMs.&lt;/p&gt;

&lt;p&gt;In the year 2001, I would like to see bindings for Java, Ruby, Fortran and Bash. I don&amp;rsquo;t plan on authoring all of these myself. But I may kickstart some of them, and see if anyone&amp;rsquo;s interested in taking over. If &lt;em&gt;you&lt;/em&gt; have a desire to get involved with Inline development, please join the mailing list (&lt;a href=&#34;mailto:inline-subscribe@perl.org&#34;&gt;inline-subscribe@perl.org&lt;/a&gt;) and speak up.&lt;/p&gt;

&lt;p&gt;My primary focus at the present time, is to make the base Inline module as simple, flexible, and stable as possible. Also I want to see Inline::C become an acceptable replacement for XS; at least for most situations.&lt;/p&gt;

&lt;h3 id=&#34;span-id-conclusion-conclusion-span&#34;&gt;&lt;span id=&#34;conclusion&#34;&gt;Conclusion&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Using XS is just too hard. At least when you compare it to the rest of the Perl we know and love. Inline takes advantage of the existing frameworks for combining Perl and C, and packages it all up into one easy to swallow pill. As an added bonus, it provides a great framework for binding other programming languages to Perl. You might say, ``It&amp;rsquo;s a &amp;lsquo;Perl-fect&amp;rsquo; solution!&amp;rdquo;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

