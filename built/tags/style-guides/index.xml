<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Style Guides on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/style-guides/</link>
    <description>Recent content in Style Guides on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 14 Jul 2005 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/style-guides/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Ten Essential Development Practices</title>
      <link>http://localhost:1313/pub/2005/07/14/bestpractices.html/</link>
      <pubDate>Thu, 14 Jul 2005 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2005/07/14/bestpractices.html/</guid>
      <description>

&lt;p&gt;The following ten tips come from &lt;em&gt;&lt;a href=&#34;http://www.oreilly.com/catalog/perlbp/&#34;&gt;Perl Best Practices&lt;/a&gt;&lt;/em&gt;, a new book of Perl coding and development guidelines by Damian Conway.&lt;/p&gt;

&lt;h3 id=&#34;1-design-the-module-s-interface-first&#34;&gt;1. Design the Module&amp;rsquo;s Interface First&lt;/h3&gt;

&lt;p&gt;The most important aspect of any module is not how it implements the facilities it provides, but the way in which it provides those facilities in the first place. If the module&amp;rsquo;s API is too awkward, or too complex, or too extensive, or too fragmented, or even just poorly named, developers will avoid using it. They&amp;rsquo;ll write their own code instead. In that way, a poorly designed module can actually reduce the overall maintainability of a system.&lt;/p&gt;

&lt;p&gt;Designing module interfaces requires both experience and creativity. Perhaps the easiest way to work out how an interface should work is to &amp;ldquo;play test&amp;rdquo; it: to write examples of code that will use the module before implementing the module itself. These examples will not be wasted when the design is complete. You can usually recycle them into demos, documentation examples, or the core of a test suite.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://conferences.oreillynet.com/os2005/&#34;&gt;&lt;img src=&#34;http://conferences.oreillynet.com/images/os2005/banners/120x240.gif&#34; alt=&#34;O&amp;#39;Reilly Open Source Convention 2005.&#34; width=&#34;120&#34; height=&#34;240&#34; /&gt;&lt;/a&gt;
The key, however, is to write that code as if the module were already available, and write it the way you&amp;rsquo;d most like the module to work.&lt;/p&gt;

&lt;p&gt;Once you have some idea of the interface you want to create, convert your &amp;ldquo;play tests&amp;rdquo; into actual tests (see Tip #2). Then it&amp;rsquo;s just a Simple Matter Of Programming to make the module work the way that the code examples and the tests want it to.&lt;/p&gt;

&lt;p&gt;Of course, it may not be possible for the module to work the way you&amp;rsquo;d most like, in which case attempting to implement it that way will help you determine what aspects of your API are not practical, and allow you to work out what might be an acceptable alternative.&lt;/p&gt;

&lt;h3 id=&#34;2-write-the-test-cases-before-the-code&#34;&gt;2. Write the Test Cases Before the Code&lt;/h3&gt;

&lt;p&gt;Probably the single best practice in all of software development is writing your test suite first.&lt;/p&gt;

&lt;p&gt;A test suite is an executable, self-verifying specification of the behavior of a piece of software. If you have a test suite, you can&amp;ndash;at any point in the development process&amp;ndash;verify that the code works as expected. If you have a test suite, you can&amp;ndash;after any changes during the maintenance cycle&amp;ndash;verify that the code still works as expected.&lt;/p&gt;

&lt;p&gt;Write the tests first. Write them as soon as you know what your interface will be (see #1). Write them before you start coding your application or module. Unless you have tests, you have no unequivocal specification of what the software should do, and no way of knowing whether it does it.&lt;/p&gt;

&lt;p&gt;Writing tests always seems like a chore, and an unproductive chore at that: you don&amp;rsquo;t have anything to test yet, so why write tests? Yet most developers will&amp;ndash;almost automatically&amp;ndash;write driver software to test their new module in an ad hoc way:&lt;span id=&#34;OLE_LINK428&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; cat try_inflections.pl

# Test my shiny new English inflections module...

use Lingua::EN::Inflect qw( inflect );

# Try some plurals (both standard and unusual inflections)...

my %plural_of = (
   &#39;house&#39;         =&amp;gt; &#39;houses&#39;,
   &#39;mouse&#39;         =&amp;gt; &#39;mice&#39;,
   &#39;box&#39;           =&amp;gt; &#39;boxes&#39;,
   &#39;ox&#39;            =&amp;gt; &#39;oxen&#39;,
   &#39;goose&#39;         =&amp;gt; &#39;geese&#39;,
   &#39;mongoose&#39;      =&amp;gt; &#39;mongooses&#39;,
   &#39;law&#39;           =&amp;gt; &#39;laws&#39;,
   &#39;mother-in-law&#39; =&amp;gt; &#39;mothers-in-law&#39;,
);

# For each of them, print both the expected result and the actual inflection...

for my $word ( keys %plural_of ) {
   my $expected = $plural_of{$word};
   my $computed = inflect( &amp;quot;PL_N($word)&amp;quot; );

   print &amp;quot;For $word:\n&amp;quot;,
         &amp;quot;\tExpected: $expected\n&amp;quot;,
         &amp;quot;\tComputed: $computed\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A driver like that is actually harder to write than a test suite, because you have to worry about formatting the output in a way that is easy to read. It&amp;rsquo;s also much harder to use the driver than it would be to use a test suite, because every time you run it you have to wade though that formatted output and verify &amp;ldquo;by eye&amp;rdquo; that everything is as it should be. That&amp;rsquo;s also error-prone; eyes are not optimized for picking out small differences in the middle of large amounts of nearly identical text.&lt;/p&gt;

&lt;p&gt;Instead of hacking together a driver program, it&amp;rsquo;s easier to write a test program using the standard &lt;a href=&#34;https://metacpan.org/pod/Test::Simple&#34;&gt;Test::Simple&lt;/a&gt; module. Instead of &lt;code&gt;print&lt;/code&gt; statements showing what&amp;rsquo;s being tested, you just write calls to the &lt;code&gt;ok()&lt;/code&gt; subroutine, specifying as its first argument the condition under which things are okay, and as its second argument a description of what you&amp;rsquo;re actually testing:&lt;span id=&#34;OLE_LINK429&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; cat inflections.t

use Lingua::EN::Inflect qw( inflect);

use Test::Simple qw( no_plan);

my %plural_of = (
   &#39;mouse&#39;         =&amp;gt; &#39;mice&#39;,
   &#39;house&#39;         =&amp;gt; &#39;houses&#39;,
   &#39;ox&#39;            =&amp;gt; &#39;oxen&#39;,
   &#39;box&#39;           =&amp;gt; &#39;boxes&#39;,
   &#39;goose&#39;         =&amp;gt; &#39;geese&#39;,
   &#39;mongoose&#39;      =&amp;gt; &#39;mongooses&#39;,
   &#39;law&#39;           =&amp;gt; &#39;laws&#39;,
   &#39;mother-in-law&#39; =&amp;gt; &#39;mothers-in-law&#39;,
);

for my $word ( keys %plural_of ) {
   my $expected = $plural_of{$word};
   my $computed = inflect( &amp;quot;PL_N($word)&amp;quot; );

   ok( $computed eq $expected, &amp;quot;$word -&amp;gt; $expected&amp;quot; );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that this code loads &lt;code&gt;Test::Simple&lt;/code&gt; with the argument &lt;code&gt;qw( no_plan )&lt;/code&gt;. Normally that argument would be &lt;code&gt;tests =&amp;gt; count&lt;/code&gt;, indicating how many tests to expect, but here the tests are generated from the &lt;code&gt;%plural_of&lt;/code&gt; table at run time, so the final count will depend on how many entries are in that table. Specifying a fixed number of tests when loading the module is useful if you happen know that number at compile time, because then the module can also &amp;ldquo;meta-test:&amp;rdquo; verify that you carried out all the tests you expected to.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Test::Simple&lt;/code&gt; program is slightly more concise and readable than the original driver code, and the output is much more compact and informative:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; perl inflections.t

ok 1 - house -&amp;gt; houses
ok 2 - law -&amp;gt; laws
not ok 3 - mongoose -&amp;gt; mongooses
#     Failed test (inflections.t at line 21)
ok 4 - goose -&amp;gt; geese
ok 5 - ox -&amp;gt; oxen
not ok 6 - mother-in-law -&amp;gt; mothers-in-law
#     Failed test (inflections.t at line 21)
ok 7 - mouse -&amp;gt; mice
ok 8 - box -&amp;gt; boxes
1..8
# Looks like you failed 2 tests of 8.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More importantly, this version requires far less effort to verify the correctness of each test. You just scan down the left margin looking for a &lt;code&gt;not&lt;/code&gt; and a comment line.&lt;/p&gt;

&lt;p&gt;You might prefer to use the &lt;a href=&#34;https://metacpan.org/pod/Test::More&#34;&gt;Test::More&lt;/a&gt; module instead of &lt;code&gt;Test::Simple&lt;/code&gt;. Then you can specify the actual and expected values separately, by using the &lt;code&gt;is()&lt;/code&gt; subroutine, rather than &lt;code&gt;ok()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Lingua::EN::Inflect qw( inflect );
use Test::More qw( no_plan ); # Now using more advanced testing tools

my %plural_of = (
   &#39;mouse&#39;         =&amp;gt; &#39;mice&#39;,
   &#39;house&#39;         =&amp;gt; &#39;houses&#39;,
   &#39;ox&#39;            =&amp;gt; &#39;oxen&#39;,
   &#39;box&#39;           =&amp;gt; &#39;boxes&#39;,
   &#39;goose&#39;         =&amp;gt; &#39;geese&#39;,
   &#39;mongoose&#39;      =&amp;gt; &#39;mongooses&#39;,
   &#39;law&#39;           =&amp;gt; &#39;laws&#39;,
   &#39;mother-in-law&#39; =&amp;gt; &#39;mothers-in-law&#39;,
);

for my $word ( keys %plural_of ) {
   my $expected = $plural_of{$word};
   my $computed = inflect( &amp;quot;PL_N($word)&amp;quot; );

   # Test expected and computed inflections for string equality...
   is( $computed, $expected, &amp;quot;$word -&amp;gt; $expected&amp;quot; );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apart from no longer having to type the &lt;code&gt;eq&lt;/code&gt; yourself, this version also produces more detailed error messages:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; perl inflections.t

ok 1 - house -&amp;gt; houses
ok 2 - law -&amp;gt; laws
not ok 3 - mongoose -&amp;gt; mongooses
#     Failed test (inflections.t at line 20)
#          got: &#39;mongeese&#39;
#     expected: &#39;mongooses&#39;
ok 4 - goose -&amp;gt; geese
ok 5 - ox -&amp;gt; oxen
not ok 6 - mother-in-law -&amp;gt; mothers-in-law
#     Failed test (inflections.t at line 20)
#          got: &#39;mothers-in-laws&#39;
#     expected: &#39;mothers-in-law&#39;
ok 7 - mouse -&amp;gt; mice
ok 8 - box -&amp;gt; boxes
1..8
# Looks like you failed 2 tests of 8.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;a href=&#34;https://metacpan.org/pod/Test::Tutorial&#34;&gt;Test::Tutorial&lt;/a&gt; documentation that comes with Perl 5.8 provides a gentle introduction to both &lt;code&gt;Test::Simple&lt;/code&gt; and &lt;code&gt;Test::More&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;3-create-standard-pod-templates-for-modules-and-applications&#34;&gt;3. Create Standard POD Templates for Modules and Applications&lt;/h3&gt;

&lt;p&gt;One of the main reasons documentation can often seem so unpleasant is the &amp;ldquo;blank page effect.&amp;rdquo; Many programmers simply don&amp;rsquo;t know how to get started or what to say.&lt;/p&gt;

&lt;p&gt;Perhaps the easiest way to make writing documentation less forbidding (and hence, more likely to actually occur) is to circumvent that initial empty screen by providing a template that developers can cut and paste into their code.&lt;/p&gt;

&lt;p&gt;For a module, that documentation template might look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;=head1 NAME

&amp;lt;Module::Name&amp;gt; - &amp;lt;One-line description of module&#39;s purpose&amp;gt;

=head1 VERSION

The initial template usually just has:

This documentation refers to &amp;lt;Module::Name&amp;gt; version 0.0.1.

=head1 SYNOPSIS

   use &amp;lt;Module::Name&amp;gt;;

   # Brief but working code example(s) here showing the most common usage(s)
   # This section will be as far as many users bother reading, so make it as
   # educational and exemplary as possible.

=head1 DESCRIPTION

A full description of the module and its features.

May include numerous subsections (i.e., =head2, =head3, etc.).

=head1 SUBROUTINES/METHODS

A separate section listing the public components of the module&#39;s interface.

These normally consist of either subroutines that may be exported, or methods
that may be called on objects belonging to the classes that the module
provides.

Name the section accordingly.

In an object-oriented module, this section should begin with a sentence (of the
form &amp;quot;An object of this class represents ...&amp;quot;) to give the reader a high-level
context to help them understand the methods that are subsequently described.

=head1 DIAGNOSTICS

A list of every error and warning message that the module can generate (even
the ones that will &amp;quot;never happen&amp;quot;), with a full explanation of each problem,
one or more likely causes, and any suggested remedies.

=head1 CONFIGURATION AND ENVIRONMENT

A full explanation of any configuration system(s) used by the module, including
the names and locations of any configuration files, and the meaning of any
environment variables or properties that can be set. These descriptions must
also include details of any configuration language used.

=head1 DEPENDENCIES

A list of all of the other modules that this module relies upon, including any
restrictions on versions, and an indication of whether these required modules
are part of the standard Perl distribution, part of the module&#39;s distribution,
or must be installed separately.

=head1 INCOMPATIBILITIES

A list of any modules that this module cannot be used in conjunction with.
This may be due to name conflicts in the interface, or competition for system
or program resources, or due to internal limitations of Perl (for example, many
modules that use source code filters are mutually incompatible).

=head1 BUGS AND LIMITATIONS

A list of known problems with the module, together with some indication of
whether they are likely to be fixed in an upcoming release.

Also, a list of restrictions on the features the module does provide: data types
that cannot be handled, performance issues and the circumstances in which they
may arise, practical limitations on the size of data sets, special cases that
are not (yet) handled, etc.

The initial template usually just has:

There are no known bugs in this module.

Please report problems to &amp;lt;Maintainer name(s)&amp;gt; (&amp;lt;contact address&amp;gt;)

Patches are welcome.

=head1 AUTHOR

&amp;lt;Author name(s)&amp;gt;  (&amp;lt;contact address&amp;gt;)

=head1 LICENSE AND COPYRIGHT

Copyright (c) &amp;lt;year&amp;gt; &amp;lt;copyright holder&amp;gt; (&amp;lt;contact address&amp;gt;).
All rights reserved.

followed by whatever license you wish to release it under.

For Perl code that is often just:

This module is free software; you can redistribute it and/or modify it under
the same terms as Perl itself. See L&amp;lt;perlartistic&amp;gt;.  This program is
distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, the specific details that your templates provide may vary from those shown here, according to your other coding practices. The most likely variation will be in the license and copyright, but you may also have specific in-house conventions regarding version numbering, the grammar of diagnostic messages, or the attribution of authorship.&lt;/p&gt;

&lt;h3 id=&#34;4-use-a-revision-control-system&#34;&gt;4. Use a Revision Control System&lt;/h3&gt;

&lt;p&gt;Maintaining control over the creation and modification of your source code is utterly essential for robust team-based development. And not just over source code: you should be revision controlling your documentation, and data files, and document templates, and makefiles, and style sheets, and change logs, and any other resources your system requires.&lt;/p&gt;

&lt;p&gt;Just as you wouldn&amp;rsquo;t use an editor without an Undo command or a word processor that can&amp;rsquo;t merge documents, so too you shouldn&amp;rsquo;t use a file system you can&amp;rsquo;t rewind, or a development environment that can&amp;rsquo;t integrate the work of many contributors.&lt;/p&gt;

&lt;p&gt;Programmers make mistakes, and occasionally those mistakes will be catastrophic. They will reformat the disk containing the most recent version of the code. Or they&amp;rsquo;ll mistype an editor macro and write zeros all through the source of a critical core module. Or two developers will unwittingly edit the same file at the same time and half their changes will be lost. Revision control systems can prevent those kinds of problems.&lt;/p&gt;

&lt;p&gt;Moreover, occasionally the very best debugging technique is to just give up, stop trying to get yesterday&amp;rsquo;s modifications to work correctly, roll the code back to a known stable state, and start over again. Less drastically, comparing the current condition of your code with the most recent stable version from your repository (even just a line-by-line &lt;code&gt;diff&lt;/code&gt;) can often help you isolate your recent &amp;ldquo;improvements&amp;rdquo; and work out which of them is the problem.&lt;/p&gt;

&lt;p&gt;Revision control systems such as RCS, CVS, Subversion, Monotone, &lt;code&gt;darcs&lt;/code&gt;, Perforce, GNU arch, or BitKeeper can protect against calamities, and ensure that you always have a working fallback position if maintenance goes horribly wrong. The various systems have different strengths and limitations, many of which stem from fundamentally different views on what exactly revision control is. It&amp;rsquo;s a good idea to audition the various revision control systems, and find the one that works best for you. &lt;em&gt;Pragmatic Version Control Using Subversion&lt;/em&gt;, by Mike Mason (Pragmatic Bookshelf, 2005) and &lt;a href=&#34;http://www.oreilly.com/catalog/cvs/&#34;&gt;&lt;em&gt;Essential CVS&lt;/em&gt;&lt;/a&gt;, by Jennifer Vesperman (O&amp;rsquo;Reilly, 2003) are useful starting points.&lt;/p&gt;

&lt;h3 id=&#34;5-create-consistent-command-line-interfaces&#34;&gt;5. Create Consistent Command-Line Interfaces&lt;/h3&gt;

&lt;p&gt;Command-line interfaces have a strong tendency to grow over time, accreting new options as you add features to the application. Unfortunately, the evolution of such interfaces is rarely designed, managed, or controlled, so the set of flags, options, and arguments that a given application accepts are likely to be ad hoc and unique.&lt;/p&gt;

&lt;p&gt;This also means they&amp;rsquo;re likely to be inconsistent with the unique ad hoc sets of flags, options, and arguments that other related applications provide. The result is inevitably a suite of programs, each of which is driven in a distinct and idiosyncratic way. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; orchestrate source.txt -to interim.orc

&amp;gt; remonstrate +interim.rem -interim.orc

&amp;gt; fenestrate  --src=interim.rem --dest=final.wdw
Invalid input format

&amp;gt; fenestrate --help
Unknown option: --help.
Type &#39;fenestrate -hmo&#39; for help
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, the &lt;code&gt;orchestrate&lt;/code&gt; utility expects its input file as its first argument, while the &lt;code&gt;-to&lt;/code&gt; flag specifies its output file. The related &lt;code&gt;remonstrate&lt;/code&gt; tool uses &lt;code&gt;-infile&lt;/code&gt; and &lt;code&gt;+outfile&lt;/code&gt; options instead, with the output file coming first. The &lt;code&gt;fenestrate&lt;/code&gt; program seems to require GNU-style &amp;ldquo;long options:&amp;rdquo; &lt;code&gt;--src=infile&lt;/code&gt; and &lt;code&gt;--dest=outfile&lt;/code&gt;, except, apparently, for its oddly named help flag. All in all, it&amp;rsquo;s a mess.&lt;/p&gt;

&lt;p&gt;When you&amp;rsquo;re providing a suite of programs, all of them should appear to work the same way, using the same flags and options for the same features across all applications. This enables your users to take advantage of existing knowledge&amp;ndash;instead of continually asking you.&lt;/p&gt;

&lt;p&gt;Those three programs should work like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; orchestrate -i source.txt -o dest.orc

&amp;gt; remonstrate -i source.orc -o dest.rem

&amp;gt; fenestrate  -i source.rem -o dest.wdw
Input file (&#39;source.rem&#39;) not a valid Remora file
(type &amp;quot;fenestrate --help&amp;quot; for help)

&amp;gt; fenestrate --help
fenestrate - convert Remora .rem files to Windows .wdw format
Usage: fenestrate [-i &amp;lt;infile&amp;gt;] [-o &amp;lt;outfile&amp;gt;] [-cstq] [-h|-v]
Options:
   -i &amp;lt;infile&amp;gt; Specify input source [default: STDIN]
   -o &amp;lt;outfile&amp;gt; Specify output destination [default: STDOUT]
   -c Attempt to produce a more compact representation
   -h Use horizontal (landscape) layout
   -v Use vertical (portrait) layout
   -s Be strict regarding input
   -t Be extra tolerant regarding input
   -q Run silent
   --version Print version information
   --usage Print the usage line of this summary
   --help Print this summary
   --man Print the complete manpage
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, every application that takes input and output files uses the same two flags to do so. A user who wants to use the &lt;code&gt;substrate&lt;/code&gt; utility (to convert that final .wdw file to a subroutine) is likely to be able to guess correctly the required syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; substrate  -i dest.wdw -o dest.sub
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Anyone who can&amp;rsquo;t guess that probably can guess that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; substrate --help
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is likely to render aid and comfort.&lt;/p&gt;

&lt;p&gt;A large part of making interfaces consistent is being consistent in specifying the individual components of those interfaces. Some conventions that may help to design consistent and predictable interfaces include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Require a flag preceding every piece of command-line data, except filenames.&lt;/p&gt;

&lt;p&gt;Users don&amp;rsquo;t want to have to remember that your application requires &amp;ldquo;input file, output file, block size, operation, fallback strategy,&amp;rdquo; and requires them in that precise order:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; lustrate sample_data proc_data 1000 normalize log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;They want to be able to say explicitly what they mean, in any order that suits them:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; lustrate sample_data proc_data -op=normalize -b1000 --fallback=log
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Provide a flag for each filename, too, especially when a program can be given files for different purposes.&lt;/p&gt;

&lt;p&gt;Users might also not want to remember the order of the two positional filenames, so let them label those arguments as well, and specify them in whatever order they prefer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; lustrate -i sample_data -op normalize -b1000 --fallback log -o proc_data
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use a single &lt;code&gt;-&lt;/code&gt; prefix for short-form flags, up to three letters (&lt;code&gt;-v&lt;/code&gt;, &lt;code&gt;-i&lt;/code&gt;, &lt;code&gt;-rw&lt;/code&gt;, &lt;code&gt;-in&lt;/code&gt;, &lt;code&gt;-out&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Experienced users appreciate short-form flags as a way of reducing typing and limiting command-line clutter. Don&amp;rsquo;t make them type two dashes in these shortcuts.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use a double &lt;code&gt;--&lt;/code&gt; prefix for longer flags (&lt;code&gt;--verbose&lt;/code&gt;, &lt;code&gt;--interactive&lt;/code&gt;, &lt;code&gt;--readwrite&lt;/code&gt;, &lt;code&gt;--input&lt;/code&gt;, &lt;code&gt;--output&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Flags that are complete words improve the readability of a command line (in a shell script, for example). The double dash also helps to distinguish between the longer flag name and any nearby file names.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If a flag expects an associated value, allow an optional &lt;code&gt;=&lt;/code&gt; between the flag and the value.&lt;/p&gt;

&lt;p&gt;Some people prefer to visually associate a value with its preceding flag:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; lustrate -i=sample_data -op=normalize -b=1000 --fallback=log -o=proc_data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Others don&amp;rsquo;t:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; lustrate -i sample_data -op normalize -b1000 --fallback log -o proc_data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Still others want a bit each way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; lustrate -i sample_data -o proc_data -op=normalize -b=1000 --fallback=log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let the user choose.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Allow single-letter options to be &amp;ldquo;bundled&amp;rdquo; after a single dash.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s irritating to have to type repeated dashes for a series of flags:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; lustrate -i sample_data -v -l -x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Allow experienced users to also write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; lustrate -i sample_data -vlx
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Provide a multi-letter version of every single-letter flag.&lt;/p&gt;

&lt;p&gt;Short-form flags may be nice for experienced users, but they can be troublesome for new users: hard to remember and even harder to recognize. Don&amp;rsquo;t force people to do either. Give them a verbose alternative to every concise flag; full words that are easier to remember, and also more self-documenting in shell scripts.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Always allow &lt;code&gt;-&lt;/code&gt; as a special filename.&lt;/p&gt;

&lt;p&gt;A widely used convention is that a dash (&lt;code&gt;-&lt;/code&gt;) where an input file is expected means &amp;ldquo;read from standard input,&amp;rdquo; and a dash where an output file is expected means &amp;ldquo;write to standard output.&amp;rdquo;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Always allow &lt;code&gt;--&lt;/code&gt; as a file list marker.&lt;/p&gt;

&lt;p&gt;Another widely used convention is that the appearance of a double dash (&lt;code&gt;--&lt;/code&gt;) on the command line marks the end of any flagged options, and indicates that the remaining arguments are a list of filenames, even if some of them look like flags.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;6-agree-upon-a-coherent-layout-style-and-automate-it-with-perltidy&#34;&gt;6. Agree Upon a Coherent Layout Style and Automate It with &lt;code&gt;perltidy&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Formatting. Indentation. Style. Code layout. Whatever you choose to call it, it&amp;rsquo;s one of the most contentious aspects of programming discipline. More and bloodier wars have been fought over code layout than over just about any other aspect of coding.&lt;/p&gt;

&lt;p&gt;What is the best practice here? Should you use classic Kernighan and Ritchie style? Or go with BSD code formatting? Or adopt the layout scheme specified by the GNU project? Or conform to the Slashcode coding guidelines?&lt;/p&gt;

&lt;p&gt;Of course not! Everyone knows that &lt;em&gt;&amp;lt;insert your personal coding style here&amp;gt;&lt;/em&gt; is the One True Layout Style, the only sane choice, as ordained by &lt;em&gt;&amp;lt;insert your favorite Programming Deity here&amp;gt;&lt;/em&gt; since Time Immemorial! Any other choice is manifestly absurd, willfully heretical, and self-evidently a Work of Darkness!&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s precisely the problem. When deciding on a layout style, it&amp;rsquo;s hard to decide where rational choices end and rationalized habits begin.&lt;/p&gt;

&lt;p&gt;Adopting a coherently designed approach to code layout, and then applying that approach consistently across all your coding, is fundamental to best-practice programming. Good layout can improve the readability of a program, help detect errors within it, and make the structure of your code much easier to comprehend. Layout matters.&lt;/p&gt;

&lt;p&gt;However, most coding styles&amp;ndash;including the four mentioned earlier&amp;ndash;confer those benefits almost equally well. While it&amp;rsquo;s true that having a consistent code layout scheme matters very much indeed, the particular code layout scheme you ultimately decide upon does not matter at all! All that matters is that you adopt a single, coherent style; one that works for your entire programming team, and, having agreed upon that style, that you then apply it consistently across all your development.&lt;/p&gt;

&lt;p&gt;In the long term, it&amp;rsquo;s best to train yourself and your team to code in a consistent, rational, and readable style. However, the time and commitment necessary to accomplish that isn&amp;rsquo;t always available. In such cases, a reasonable compromise is to prescribe a standard code-formatting tool that must be applied to all code before it&amp;rsquo;s committed, reviewed, or otherwise displayed in public.&lt;/p&gt;

&lt;p&gt;There is now an excellent code formatter available for Perl: &lt;a href=&#34;http://perltidy.sourceforge.net/&#34;&gt;&lt;code&gt;perltidy&lt;/code&gt;&lt;/a&gt;. It provides an extensive range of user-configurable options for indenting, block delimiter positioning, column-like alignment, and comment positioning.&lt;/p&gt;

&lt;p&gt;Using &lt;code&gt;perltidy&lt;/code&gt;, you can convert code like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if($sigil eq &#39;$&#39;){
   if($subsigil eq &#39;?&#39;){
       $sym_table{substr($var_name,2)}=delete $sym_table{locate_orig_var($var)};
       $internal_count++;$has_internal{$var_name}++
   } else {
       ${$var_ref} =
           q{$sym_table{$var_name}}; $external_count++; $has_external{$var_name}++;
}} elsif ($sigil eq &#39;@&#39;&amp;amp;&amp;amp;$subsigil eq &#39;?&#39;) {
   @{$sym_table{$var_name}} = grep
       {defined $_} @{$sym_table{$var_name}};
} elsif ($sigil eq &#39;%&#39; &amp;amp;&amp;amp; $subsigil eq &#39;?&#39;) {
delete $sym_table{$var_name}{$EMPTY_STR}; } else
{
${$var_ref}
=
q{$sym_table{$var_name}}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;into something readable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ( $sigil eq &#39;$&#39; ) {
   if ( $subsigil eq &#39;?&#39; ) {
       $sym_table{ substr( $var_name, 2 ) }
           = delete $sym_table{ locate_orig_var($var) };
       $internal_count++;
       $has_internal{$var_name}++;
   }
   else {
       ${$var_ref} = q{$sym_table{$var_name}};
       $external_count++;
       $has_external{$var_name}++;
   }
}
elsif ( $sigil eq &#39;@&#39; &amp;amp;&amp;amp; $subsigil eq &#39;?&#39; ) {
   @{ $sym_table{$var_name} }
       = grep {defined $_} @{ $sym_table{$var_name} };
}
elsif ( $sigil eq &#39;%&#39; &amp;amp;&amp;amp; $subsigil eq &#39;?&#39; ) {
   delete $sym_table{$var_name}{$EMPTY_STR};
}
else {
   ${$var_ref} = q{$sym_table{$var_name}};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mandating that everyone use a common tool to format their code can also be a simple way of sidestepping the endless objections, acrimony, and dogma that always surround any discussion on code layout. If &lt;code&gt;perltidy&lt;/code&gt; does all the work for them, then it will cost developers almost no effort to adopt the new guidelines. They can simply set up an editor macro that will &amp;ldquo;straighten&amp;rdquo; their code whenever they need to.&lt;/p&gt;

&lt;h3 id=&#34;7-code-in-commented-paragraphs&#34;&gt;7. Code in Commented Paragraphs&lt;/h3&gt;

&lt;p&gt;A paragraph is a collection of statements that accomplish a single task: in literature, it&amp;rsquo;s a series of sentences conveying a single idea; in programming, a series of instructions implementing a single step of an algorithm.&lt;/p&gt;

&lt;p&gt;Break each piece of code into sequences that achieve a single task, placing a single empty line between each sequence. To further improve the maintainability of the code, place a one-line comment at the start of each such paragraph, describing what the sequence of statements does. Like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Process an array that has been recognized...
sub addarray_internal {
   my ($var_name, $needs_quotemeta) = @_;

   # Cache the original...
   $raw .= $var_name;

   # Build meta-quoting code, if requested...
   my $quotemeta = $needs_quotemeta ?  q{map {quotemeta $_} } : $EMPTY_STR;

   # Expand elements of variable, conjoin with ORs...
   my $perl5pat = qq{(??{join q{|}, $quotemeta \@{$var_name}})};

   # Insert debugging code if requested...
   my $type = $quotemeta ? &#39;literal&#39; : &#39;pattern&#39;;
   debug_now(&amp;quot;Adding $var_name (as $type)&amp;quot;);
   add_debug_mesg(&amp;quot;Trying $var_name (as $type)&amp;quot;);

   return $perl5pat;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Paragraphs are useful because humans can focus on only a few pieces of information at once. Paragraphs are one way of aggregating small amounts of related information, so that the resulting &amp;ldquo;chunk&amp;rdquo; can fit into a single slot of the reader&amp;rsquo;s limited short-term memory. Paragraphs enable the physical structure of a piece of writing to reflect and emphasize its logical structure.&lt;/p&gt;

&lt;p&gt;Adding comments at the start of each paragraph further enhances the chunking by explicitly summarizing the purpose of each chunk (note: the purpose, not the behavior). Paragraph comments need to explain why the code is there and what it achieves, not merely paraphrase the precise computational steps it&amp;rsquo;s performing.&lt;/p&gt;

&lt;p&gt;Note, however, that the contents of paragraphs are only of secondary importance here. It is the vertical gaps separating each paragraph that are critical. Without them, the readability of the code declines dramatically, even if the comments are retained:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub addarray_internal {
   my ($var_name, $needs_quotemeta) = @_;
   # Cache the original...
   $raw .= $var_name;
   # Build meta-quoting code, if required...
   my $quotemeta = $needs_quotemeta ?  q{map {quotemeta $_} } : $EMPTY_STR;
   # Expand elements of variable, conjoin with ORs...
   my $perl5pat = qq{(??{join q{|}, $quotemeta \@{$var_name}})};
   # Insert debugging code if requested...
   my $type = $quotemeta ? &#39;literal&#39; : &#39;pattern&#39;;
   debug_now(&amp;quot;Adding $var_name (as $type)&amp;quot;);
   add_debug_mesg(&amp;quot;Trying $var_name (as $type)&amp;quot;);
   return $perl5pat;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;8-throw-exceptions-instead-of-returning-special-values-or-setting-flags&#34;&gt;8. Throw Exceptions Instead of Returning Special Values or Setting Flags&lt;/h3&gt;

&lt;p&gt;Returning a special error value on failure, or setting a special error flag, is a very common error-handling technique. Collectively, they&amp;rsquo;re the basis for virtually all error notification from Perl&amp;rsquo;s own built-in functions. For example, the built-ins &lt;code&gt;eval&lt;/code&gt;, &lt;code&gt;exec&lt;/code&gt;, &lt;code&gt;flock&lt;/code&gt;, &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;stat&lt;/code&gt;, and &lt;code&gt;system&lt;/code&gt; all return special values on error. Unfortunately, they don&amp;rsquo;t all use the same special value. Some of them also set a flag on failure. Sadly, it&amp;rsquo;s not always the same flag. See the &lt;a href=&#34;https://perldoc.perl.org/perlfunc.html&#34;&gt;perlfunc&lt;/a&gt; manpage for the gory details.&lt;/p&gt;

&lt;p&gt;Apart from the obvious consistency problems, error notification via flags and return values has another serious flaw: developers can silently ignore flags and return values, and ignoring them requires absolutely no effort on the part of the programmer. In fact, in a void context, ignoring return values is Perl&amp;rsquo;s default behavior. Ignoring an error flag that has suddenly appeared in a special variable is just as easy: you simply don&amp;rsquo;t bother to check the variable.&lt;/p&gt;

&lt;p&gt;Moreover, because ignoring a return value is the void-context default, there&amp;rsquo;s no syntactic marker for it. There&amp;rsquo;s no way to look at a program and immediately see where a return value is deliberately being ignored, which means there&amp;rsquo;s also no way to be sure that it&amp;rsquo;s not being ignored accidentally.&lt;/p&gt;

&lt;p&gt;The bottom line: regardless of the programmer&amp;rsquo;s (lack of) intention, an error indicator is being ignored. That&amp;rsquo;s not good programming.&lt;/p&gt;

&lt;p&gt;Ignoring error indicators frequently causes programs to propagate errors in entirely the wrong direction. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Find and open a file by name, returning the filehandle
# or undef on failure...
sub locate_and_open {
   my ($filename) = @_;

   # Check acceptable directories in order...
   for my $dir (@DATA_DIRS) {
       my $path = &amp;quot;$dir/$filename&amp;quot;;

       # If file exists in an acceptable directory, open and return it...
       if (-r $path) {
           open my $fh, &#39;&amp;lt;&#39;, $path;
           return $fh;
       }
   }

   # Fail if all possible locations tried without success...
   return;
}

# Load file contents up to the first &amp;lt;DATA/&amp;gt; marker...
sub load_header_from {
   my ($fh) = @_;

   # Use DATA tag as end-of-&amp;quot;line&amp;quot;...
   local $/ = &#39;&amp;lt;DATA/&amp;gt;&#39;;

   # Read to end-of-&amp;quot;line&amp;quot;...
   return &amp;lt;$fh&amp;gt;;
}

# and later...
for my $filename (@source_files) {
   my $fh = locate_and_open($filename);
   my $head = load_header_from($fh);
   print $head;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;locate_and_open()&lt;/code&gt; subroutine simply assumes that the call to &lt;code&gt;open&lt;/code&gt; works, immediately returning the filehandle (&lt;code&gt;$fh&lt;/code&gt;), whatever the actual outcome of the &lt;code&gt;open&lt;/code&gt;. Presumably, the expectation is that whoever calls &lt;code&gt;locate_and_open()&lt;/code&gt; will check whether the return value is a valid filehandle.&lt;/p&gt;

&lt;p&gt;Except, of course, &amp;ldquo;whoever&amp;rdquo; doesn&amp;rsquo;t check. Instead of testing for failure, the main &lt;code&gt;for&lt;/code&gt; loop takes the failure value and immediately propagates it &amp;ldquo;across&amp;rdquo; the block, to the rest of the statements in the loop. That causes the call to &lt;code&gt;loader_header_from()&lt;/code&gt; to propagate the error value &amp;ldquo;downwards.&amp;rdquo; It&amp;rsquo;s in that subroutine that the attempt to treat the failure value as a filehandle eventually kills the program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;readline() on unopened filehandle at demo.pl line 28.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Code like that&amp;ndash;where an error is reported in an entirely different part of the program from where it actually occurred&amp;ndash;is particularly onerous to debug.&lt;/p&gt;

&lt;p&gt;Of course, you could argue that the fault lies squarely with whoever wrote the loop, for using &lt;code&gt;locate_and_open()&lt;/code&gt; without checking its return value. In the narrowest sense, that&amp;rsquo;s entirely correct&amp;ndash;but the deeper fault lies with whoever actually wrote &lt;code&gt;locate_and_open()&lt;/code&gt; in the first place, or at least, whoever assumed that the caller would always check its return value.&lt;/p&gt;

&lt;p&gt;Humans simply aren&amp;rsquo;t like that. Rocks almost never fall out of the sky, so humans soon conclude that they never do, and stop looking up for them. Fires rarely break out in their homes, so humans soon forget that they might, and stop testing their smoke detectors every month. In the same way, programmers inevitably abbreviate &amp;ldquo;almost never fails&amp;rdquo; to &amp;ldquo;never fails,&amp;rdquo; and then simply stop checking.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s why so very few people bother to verify their &lt;code&gt;print&lt;/code&gt; statements:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!print &#39;Enter your name: &#39;) {
   print {*STDLOG} warning =&amp;gt; &#39;Terminal went missing!&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s human nature to &amp;ldquo;trust but not verify.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Human nature is why returning an error indicator is not best practice. Errors are (supposed to be) unusual occurrences, so error markers will almost never be returned. Those tedious and ungainly checks for them will almost never do anything useful, so eventually they&amp;rsquo;ll be quietly omitted. After all, leaving the tests off almost always works just fine. It&amp;rsquo;s so much easier not to bother. Especially when not bothering is the default!&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t return special error values when something goes wrong; throw an exception instead. The great advantage of exceptions is that they reverse the usual default behaviors, bringing untrapped errors to immediate and urgent attention. On the other hand, ignoring an exception requires a deliberate and conspicuous effort: you have to provide an explicit &lt;code&gt;eval&lt;/code&gt; block to neutralize it.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;locate_and_open()&lt;/code&gt; subroutine would be much cleaner and more robust if the errors within it threw exceptions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Find and open a file by name, returning the filehandle
# or throwing an exception on failure...
sub locate_and_open {
   my ($filename) = @_;

   # Check acceptable directories in order...
   for my $dir (@DATA_DIRS) {
       my $path = &amp;quot;$dir/$filename&amp;quot;;

       # If file exists in acceptable directory, open and return it...
       if (-r $path) {
           open my $fh, &#39;&amp;lt;&#39;, $path
               or croak( &amp;quot;Located $filename at $path, but could not open&amp;quot;);
           return $fh;
       }
   }

   # Fail if all possible locations tried without success...
   croak( &amp;quot;Could not locate $filename&amp;quot; );
}

# and later...
for my $filename (@source_files) {
   my $fh = locate_and_open($filename);
   my $head = load_header_from($fh);
   print $head;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that the main &lt;code&gt;for&lt;/code&gt; loop didn&amp;rsquo;t change at all. The developer using &lt;code&gt;locate_and_open()&lt;/code&gt; still assumes that nothing can go wrong. Now there&amp;rsquo;s some justification for that expectation, because if anything does go wrong, the thrown exception will automatically terminate the loop.&lt;/p&gt;

&lt;p&gt;Exceptions are a better choice even if you are the careful type who religiously checks every return value for failure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SOURCE_FILE:
for my $filename (@source_files) {
   my $fh = locate_and_open($filename);
   next SOURCE_FILE if !defined $fh;
   my $head = load_header_from($fh);
   next SOURCE_FILE if !defined $head;
   print $head;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Constantly checking return values for failure clutters your code with validation statements, often greatly decreasing its readability. In contrast, exceptions allow an algorithm to be implemented without having to intersperse any error-handling infrastructure at all. You can factor the error-handling out of the code and either relegate it to after the surrounding &lt;code&gt;eval&lt;/code&gt;, or else dispense with it entirely:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for my $filename (@directory_path) {

   # Just ignore any source files that don&#39;t load...
   eval {
       my $fh = locate_and_open($filename);
       my $head = load_header_from($fh);
       print $head;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;9-add-new-test-cases-before-you-start-debugging&#34;&gt;9. Add New Test Cases Before you Start Debugging&lt;/h3&gt;

&lt;p&gt;The first step in any debugging process is to isolate the incorrect behavior of the system, by producing the shortest demonstration of it that you reasonably can. If you&amp;rsquo;re lucky, this may even have been done for you:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;To: DCONWAY@cpan.org
From: sascha@perlmonks.org
Subject: Bug in inflect module

Zdravstvuite,

I have been using your Lingua::EN::Inflect module to normalize terms in a
data-mining application I am developing, but there seems to be a bug in it,
as the following example demonstrates:

   use Lingua::EN::Inflect qw( PL_N );
   print PL_N(&#39;man&#39;), &amp;quot;\n&amp;quot;;       # Prints &amp;quot;men&amp;quot;, as expected
   print PL_N(&#39;woman&#39;), &amp;quot;\n&amp;quot;;     # Incorrectly prints &amp;quot;womans&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once you have distilled a short working example of the bug, convert it to a series of tests, such as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Lingua::EN::Inflect qw( PL_N );
use Test::More qw( no_plan );
is(PL_N(&#39;man&#39;) ,  &#39;men&#39;, &#39;man -&amp;gt; men&#39;     );
is(PL_N(&#39;woman&#39;), &#39;women&#39;, &#39;woman -&amp;gt; women&#39; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Don&amp;rsquo;t try to fix the problem straight away, though. Instead, immediately add those tests to your test suite. If that testing has been well set up, that can often be as simple as adding a couple of entries to a table:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my %plural_of = (
   &#39;mouse&#39;         =&amp;gt; &#39;mice&#39;,
   &#39;house&#39;         =&amp;gt; &#39;houses&#39;,
   &#39;ox&#39;            =&amp;gt; &#39;oxen&#39;,
   &#39;box&#39;           =&amp;gt; &#39;boxes&#39;,
   &#39;goose&#39;         =&amp;gt; &#39;geese&#39;,
   &#39;mongoose&#39;      =&amp;gt; &#39;mongooses&#39;,
   &#39;law&#39;           =&amp;gt; &#39;laws&#39;,
   &#39;mother-in-law&#39; =&amp;gt; &#39;mothers-in-law&#39;,

   # Sascha&#39;s bug, reported 27 August 2004...
   &#39;man&#39;           =&amp;gt; &#39;men&#39;,
   &#39;woman&#39;         =&amp;gt; &#39;women&#39;,
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The point is: if the original test suite didn&amp;rsquo;t report this bug, then that test suite was broken. It simply didn&amp;rsquo;t do its job (finding bugs) adequately. Fix the test suite first by adding tests that cause it to fail:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; perl inflections.t
ok 1 - house -&amp;gt; houses
ok 2 - law -&amp;gt; laws
ok 3 - man -&amp;gt; men
ok 4 - mongoose -&amp;gt; mongooses
ok 5 - goose -&amp;gt; geese
ok 6 - ox -&amp;gt; oxen
not ok 7 - woman -&amp;gt; women
#     Failed test (inflections.t at line 20)
#          got: &#39;womans&#39;
#     expected: &#39;women&#39;
ok 8 - mother-in-law -&amp;gt; mothers-in-law
ok 9 - mouse -&amp;gt; mice
ok 10 - box -&amp;gt; boxes
1..10
# Looks like you failed 1 tests of 10.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once the test suite is detecting the problem correctly, then you&amp;rsquo;ll be able to tell when you&amp;rsquo;ve correctly fixed the actual bug, because the tests will once again fall silent.&lt;/p&gt;

&lt;p&gt;This approach to debugging is most effective when the test suite covers the full range of manifestations of the problem. When adding test cases for a bug, don&amp;rsquo;t just add a single test for the simplest case. Make sure you include the obvious variations as well:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my %plural_of = (
   &#39;mouse&#39;         =&amp;gt; &#39;mice&#39;,
   &#39;house&#39;         =&amp;gt; &#39;houses&#39;,
   &#39;ox&#39;            =&amp;gt; &#39;oxen&#39;,
   &#39;box&#39;           =&amp;gt; &#39;boxes&#39;,
   &#39;goose&#39;         =&amp;gt; &#39;geese&#39;,
   &#39;mongoose&#39;      =&amp;gt; &#39;mongooses&#39;,
   &#39;law&#39;           =&amp;gt; &#39;laws&#39;,
   &#39;mother-in-law&#39; =&amp;gt; &#39;mothers-in-law&#39;,

   # Sascha&#39;s bug, reported 27 August 2004...
   &#39;man&#39;           =&amp;gt; &#39;men&#39;,
   &#39;woman&#39;         =&amp;gt; &#39;women&#39;,
   &#39;human&#39;         =&amp;gt; &#39;humans&#39;,
   &#39;man-at-arms&#39;   =&amp;gt; &#39;men-at-arms&#39;,
   &#39;lan&#39;           =&amp;gt; &#39;lans&#39;,
   &#39;mane&#39;          =&amp;gt; &#39;manes&#39;,
   &#39;moan&#39;          =&amp;gt; &#39;moans&#39;,
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The more thoroughly you test the bug, the more completely you will fix it.&lt;/p&gt;

&lt;h3 id=&#34;10-don-t-optimize-code-benchmark-it&#34;&gt;10. Don&amp;rsquo;t Optimize Code&amp;ndash;Benchmark It&lt;/h3&gt;

&lt;p&gt;If you need a function to remove duplicate elements of an array, it&amp;rsquo;s natural to think that a &amp;ldquo;one-liner&amp;rdquo; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub uniq { return keys %{ { map {$_=&amp;gt;1} @_ } } }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will be more efficient than two statements:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub uniq {
   my %seen;
   return grep {!$seen{$_}++} @_;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unless you are deeply familiar with the internals of the Perl interpreter (in which case you already have far more serious personal issues to deal with), intuitions about the relative performance of two constructs are exactly that: unconscious guesses.&lt;/p&gt;

&lt;p&gt;The only way to know for sure which of two&amp;ndash;or more&amp;ndash;alternatives will perform better is to actually time each of them. The standard &lt;a href=&#34;https://metacpan.org/pod/Benchmark&#34;&gt;Benchmark&lt;/a&gt; module makes that easy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# A short list of not-quite-unique values...
our @data = qw( do re me fa so la ti do );

# Various candidates...
sub unique_via_anon {
   return keys %{ { map {$_=&amp;gt;1} @_ } };
}

sub unique_via_grep {
   my %seen;
   return grep { !$seen{$_}++ } @_;
}

sub unique_via_slice {
   my %uniq;
   @uniq{@_} = ();
   return keys %uniq;
}

# Compare the current set of data in @data
sub compare {
   my ($title) = @_;
   print &amp;quot;\n[$title]\n&amp;quot;;

   # Create a comparison table of the various timings, making sure that
   # each test runs at least 10 CPU seconds...
   use Benchmark qw( cmpthese );
   cmpthese -10, {
       anon  =&amp;gt; &#39;my @uniq = unique_via_anon(@data)&#39;,
       grep  =&amp;gt; &#39;my @uniq = unique_via_grep(@data)&#39;,
       slice =&amp;gt; &#39;my @uniq = unique_via_slice(@data)&#39;,
   };

   return;
}

compare(&#39;8 items, 10% repetition&#39;);

# Two copies of the original data...
@data = (@data) x 2;
compare(&#39;16 items, 56% repetition&#39;);

# One hundred copies of the original data...
@data = (@data) x 50;
compare(&#39;800 items, 99% repetition&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;cmpthese()&lt;/code&gt; subroutine takes a number, followed by a reference to a hash of tests. The number specifies either the exact number of times to run each test (if the number is positive), or the absolute number of CPU seconds to run the test for (if the number is negative). Typical values are around 10,000 repetitions or ten CPU seconds, but the module will warn you if the test is too short to produce an accurate benchmark.&lt;/p&gt;

&lt;p&gt;The keys of the test hash are the names of your tests, and the corresponding values specify the code to be tested. Those values can be either strings (which are &lt;code&gt;eval&lt;/code&gt;&amp;rsquo;d to produce executable code) or subroutine references (which are called directly).&lt;/p&gt;

&lt;p&gt;The benchmarking code shown above would print out something like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[8 items, 10% repetitions]
        Rate anon  grep slice
anon  28234/s --  -24%  -47%
grep  37294/s   32% --  -30%
slice 53013/s   88% 42%    --

[16 items, 50% repetitions]
        Rate anon  grep slice
anon  21283/s --  -28%  -51%
grep  29500/s   39% --  -32%
slice 43535/s  105% 48%    --

[800 items, 99% repetitions]
       Rate  anon grep slice
anon   536/s --  -65%  -89%
grep  1516/s  183% --  -69%
slice 4855/s  806%  220% --
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each of the tables printed has a separate row for each named test. The first column lists the absolute speed of each candidate in repetitions per second, while the remaining columns allow you to compare the relative performance of any two tests. For example, in the final test tracing across the &lt;code&gt;grep&lt;/code&gt; row to the &lt;code&gt;anon&lt;/code&gt; column reveals that the &lt;code&gt;grep&lt;/code&gt;ped solution was 1.83 times (183 percent) faster than using an anonymous hash. Tracing further across the same row also indicates that &lt;code&gt;grep&lt;/code&gt;ping was 69 percent slower (-69 percent faster) than slicing.&lt;/p&gt;

&lt;p&gt;Overall, the indication from the three tests is that the slicing-based solution is consistently the fastest for this particular set of data on this particular machine. It also appears that as the data set increases in size, slicing also scales much better than either of the other two approaches.&lt;/p&gt;

&lt;p&gt;However, those two conclusions are effectively drawn from only three data points (namely, the three benchmarking runs). To get a more definitive comparison of the three methods, you&amp;rsquo;d also need to test other possibilities, such as a long list of non-repeating items, or a short list with nothing but repetitions.&lt;/p&gt;

&lt;p&gt;Better still, test on the real data that you&amp;rsquo;ll actually be &amp;ldquo;unique-ing.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;For example, if that data is a sorted list of a quarter of a million words, with only minimal repetitions, and which has to remain sorted, then test exactly that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;our @data = slurp &#39;/usr/share/biglongwordlist.txt&#39;;

use Benchmark qw( cmpthese );

cmpthese 10, {
    # Note: the non-grepped solutions need a post-uniqification re-sort
    anon  =&amp;gt; &#39;my @uniq = sort(unique_via_anon(@data))&#39;,
    grep  =&amp;gt; &#39;my @uniq = unique_via_grep(@data)&#39;,
    slice =&amp;gt; &#39;my @uniq = sort(unique_via_slice(@data))&#39;,
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not surprisingly, this benchmark indicates that the &lt;code&gt;grep&lt;/code&gt;ped solution is markedly superior on a large sorted data set:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s/iter anon slice  grep
anon    4.28 --   -3%  -46%
slice   4.15 3%    --  -44%
grep    2.30 86%   80%    --
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perhaps more interestingly, the &lt;code&gt;grep&lt;/code&gt;ped solution still benchmarks as being marginally faster when the two hash-based approaches aren&amp;rsquo;t re-sorted. This suggests that the better scalability of the sliced solution as seen in the earlier benchmark is a localized phenomenon, and is eventually undermined by the growing costs of allocation, hashing, and bucket-overflows as the sliced hash grows very large.&lt;/p&gt;

&lt;p&gt;Above all, that last example demonstrates that benchmarks only benchmark the cases you actually benchmark, and that you can only draw useful conclusions about performance from benchmarking real data.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A Refactoring Example</title>
      <link>http://localhost:1313/pub/2003/10/09/refactoring.html/</link>
      <pubDate>Thu, 09 Oct 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/10/09/refactoring.html/</guid>
      <description>

&lt;p&gt;About a year ago, a person asked the &lt;a href=&#34;http://www.technofile.org/technofile/depts/mlists/fwp.html&#34;&gt;Fun With Perl&lt;/a&gt; mailing list about some code they had written to do database queries. It&amp;rsquo;s important to note that this person was posting from an .it address; why will become apparent later. The code was reading records in from a text file and then doing a series of queries based on that information. They wanted to make it faster.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s his code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($riga=&amp;lt;INPUT&amp;gt;){
$nump++;
chop($riga);
$pagina[$nump] = $riga;

$sth= $dbh-&amp;gt;prepare(&amp;quot;SELECT count(*) FROM lognew WHERE
pageid=&#39;$pagina[$nump]&#39; and data&amp;gt;=&#39;$startdate&#39;&amp;quot;);
$sth-&amp;gt;execute;
$totalvisit[$nump] = $sth-&amp;gt;fetchrow_array();

$sth = $dbh-&amp;gt;prepare(&amp;quot;SELECT count(*) FROM lognew WHERE
(pageid=&#39;$pagina[$nump]&#39; and data=&#39;$dataoggi&#39;)&amp;quot;);
$sth-&amp;gt;execute;
$totalvisittoday[$nump] = $sth-&amp;gt;fetchrow_array();

 $sth = $dbh-&amp;gt;prepare(&amp;quot;SELECT count(*) FROM lognew WHERE
(pageid=&#39;$pagina[$nump]&#39; and data=&#39;$dataieri&#39;)&amp;quot;);
$sth-&amp;gt;execute;
$totalyvisit[$nump] = $sth-&amp;gt;fetchrow_array();

 $sth= $dbh-&amp;gt;prepare(&amp;quot;SELECT count(*) FROM lognew WHERE
(pageid=&#39;$pagina[$nump]&#39; and data&amp;lt;=&#39;$fine30gg&#39; and data&amp;gt;=&#39;$inizio30gg&#39;)&amp;quot;);
$sth-&amp;gt;execute;
$totalmvisit[$nump] = $sth-&amp;gt;fetchrow_array();

 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I decided that rather than try to read through this code and figure out what it&amp;rsquo;s doing and how to make it faster, I&amp;rsquo;d clean it up first. Clean it up &lt;strong&gt;before&lt;/strong&gt; you figure out how it works? Yes, using a technique called &lt;em&gt;Refactoring&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;refactoring&#34;&gt;Refactoring?&lt;/h3&gt;

&lt;p&gt;In his book, Martin Fowler defines Refactoring as &lt;em&gt;&amp;ldquo;the process of changing a software system in such a way that it does not alter the external behavior of the code yet improves its internal structure.&amp;rdquo;&lt;/em&gt; In other words, you clean up your code but don&amp;rsquo;t change what it does.&lt;/p&gt;

&lt;p&gt;Refactoring can be as simple as changing this code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$exclamation = &#39;I like &#39;.$pastry.&#39;!&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$exclamation = &amp;quot;I like $pastry!&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Still does the same thing, but it&amp;rsquo;s easier to read.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s important to note that I don&amp;rsquo;t need to know anything about the contents of &lt;code&gt;$pastry&lt;/code&gt; or how &lt;code&gt;$exclamation&lt;/code&gt; is used. The change is completely self-contained and does not affect surrounding code or change what it does. This is Refactoring.&lt;/p&gt;

&lt;p&gt;On the principle of &amp;ldquo;show me don&amp;rsquo;t tell me,&amp;rdquo; rather than talk about it, we&amp;rsquo;ll dive right into refactoring our bit of code.&lt;/p&gt;

&lt;h3 id=&#34;fix-the-indentation&#34;&gt;Fix the Indentation&lt;/h3&gt;

&lt;p&gt;Your first impulse when faced with a hunk of code slammed against the left margin is to indent it. This is our first refactoring.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($riga=&amp;lt;INPUT&amp;gt;){
    $nump++;
    chop($riga);
    $pagina[$nump] = $riga;

    $sth= $dbh-&amp;gt;prepare(&amp;quot;SELECT count(*) FROM lognew WHERE
                         pageid=&#39;$pagina[$nump]&#39; and data&amp;gt;=&#39;$startdate&#39;&amp;quot;);
    $sth-&amp;gt;execute;
    $totalvisit[$nump] = $sth-&amp;gt;fetchrow_array();

    $sth = $dbh-&amp;gt;prepare(&amp;quot;SELECT count(*) FROM lognew WHERE
                          (pageid=&#39;$pagina[$nump]&#39; and data=&#39;$dataoggi&#39;)&amp;quot;);
    $sth-&amp;gt;execute;
    $totalvisittoday[$nump] = $sth-&amp;gt;fetchrow_array();

    $sth = $dbh-&amp;gt;prepare(&amp;quot;SELECT count(*) FROM lognew WHERE
                          (pageid=&#39;$pagina[$nump]&#39; and data=&#39;$dataieri&#39;)&amp;quot;);
    $sth-&amp;gt;execute;
    $totalyvisit[$nump] = $sth-&amp;gt;fetchrow_array();

    $sth= $dbh-&amp;gt;prepare(&amp;quot;SELECT count(*) FROM lognew WHERE
                         (pageid=&#39;$pagina[$nump]&#39; and data&amp;lt;=&#39;$fine30gg&#39; 
                         and data&amp;gt;=&#39;$inizio30gg&#39;)&amp;quot;);
    $sth-&amp;gt;execute;
    $totalmvisit[$nump] = $sth-&amp;gt;fetchrow_array();
}

close (INPUT);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Already it looks better. We can see that we&amp;rsquo;re iterating over a file, performing some SELECTs on each line and shoving the results into a bunch of arrays.&lt;/p&gt;

&lt;h3 id=&#34;a-single-simple-change&#34;&gt;A Single, Simple Change&lt;/h3&gt;

&lt;p&gt;One of the most important principles of Refactoring is that you work in small steps. This re-indentation is a single step. And part of this single step includes running the test suite, logging the change, and checking it into CVS.&lt;/p&gt;

&lt;p&gt;Checking into CVS after something this simple? Yes. Many programmers ask the question, &amp;ldquo;When should I check in?&amp;rdquo; When you&amp;rsquo;re refactoring it&amp;rsquo;s simple: check in when you&amp;rsquo;ve done one refactoring and have tested that it works. Our re-indentation is one thing; we test that it works and check it in.&lt;/p&gt;

&lt;p&gt;This may seem excessive, but it prevents us from entangling two unrelated changes together. By doing one change at a time we know that any new bugs were introduced by that one change. Also, you will often decide in the middle of a refactoring that it&amp;rsquo;s not such a good idea. When you&amp;rsquo;ve checked in at every one you can simply rollback to the last version rather than having to undo it by hand. Convenient, and you&amp;rsquo;re sure no stray bits of your aborted change are hanging around.&lt;/p&gt;

&lt;p&gt;So our procedure for doing a proper refactoring is:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Make one logical change to the code.&lt;/li&gt;
&lt;li&gt;Make sure it passes tests.&lt;/li&gt;
&lt;li&gt;Log and check in.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;big-refactorings-from-small&#34;&gt;Big Refactorings from Small&lt;/h3&gt;

&lt;p&gt;The goal of this refactoring is to make the code go faster. One of the simplest ways to do achieve that is to pull necessary code out of the loop. Preparing four new statements in every iteration of the loop seems really unnecessary. We&amp;rsquo;d like to pull those &lt;code&gt;prepare()&lt;/code&gt; statements out of the loop. This is a refactoring. To achieve this larger refactoring, a series of smaller refactorings must be done.&lt;/p&gt;

&lt;h3 id=&#34;use-bind-variables&#34;&gt;Use Bind Variables&lt;/h3&gt;

&lt;p&gt;Each time through the loop, a new set of SQL statements is created based on the line read in. But they&amp;rsquo;re all basically the same, just the data is changing. If we could pull that data out of the statement we&amp;rsquo;d be closer to our goal of pulling the &lt;code&gt;prepare()&lt;/code&gt;s out of the loop.&lt;/p&gt;

&lt;p&gt;So my next refactoring pulls variables out of the SQL statements and replaces them with placeholders. Then the data is bound to the statement using bind variables. This means we&amp;rsquo;re now &lt;code&gt;prepare()&lt;/code&gt;ing the same statements every time through the loop.&lt;/p&gt;

&lt;p&gt;Before refactoring:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$sth= $dbh-&amp;gt;prepare(&amp;quot;SELECT count(*) FROM lognew WHERE
                     pageid=&#39;$pagina[$nump]&#39; and data&amp;gt;=&#39;$startdate&#39;&amp;quot;);
$sth-&amp;gt;execute;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After refactoring:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$sth= $dbh-&amp;gt;prepare(&#39;SELECT count(*) FROM lognew WHERE 
                     pageid=? and data&amp;gt;=?&#39;);
$sth-&amp;gt;execute($pagina[$nump], $startdate);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bind variables also protect against a naughty user from trying to slip some extra SQL into your program via the data you read in. As a side-effect of our code cleanup, we&amp;rsquo;ve closed a potential security hole.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($riga=&amp;lt;INPUT&amp;gt;){
    $nump++;
    chop($riga);
    $pagina[$nump] = $riga;

    $sth= $dbh-&amp;gt;prepare(&#39;SELECT count(*) FROM lognew WHERE 
                         pageid=? and data&amp;gt;=?&#39;);
    $sth-&amp;gt;execute($pagina[$nump], $startdate);
    $totalvisit[$nump] = $sth-&amp;gt;fetchrow_array();

    $sth = $dbh-&amp;gt;prepare(&#39;SELECT count(*) FROM lognew WHERE
                          (pageid=? and data=?)&#39;);
    $sth-&amp;gt;execute($pagina[$nump], $dataoggi);
    $totalvisittoday[$nump] = $sth-&amp;gt;fetchrow_array();

    $sth = $dbh-&amp;gt;prepare(&#39;SELECT count(*) FROM lognew WHERE
                          (pageid=? and data=?)&#39;);
    $sth-&amp;gt;execute($pagina[$nump], $dataieri);
    $totalyvisit[$nump] = $sth-&amp;gt;fetchrow_array();

    $sth= $dbh-&amp;gt;prepare(&#39;SELECT count(*) FROM lognew WHERE
                         (pageid=? and data&amp;lt;=? and data&amp;gt;=?)&#39;);
    $sth-&amp;gt;execute($pagina[$nump], $fine30gg, $inizio30gg);
    $totalmvisit[$nump] = $sth-&amp;gt;fetchrow_array();
}

close (INPUT);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test. Log. Check in.&lt;/p&gt;

&lt;h3 id=&#34;split-a-poorly-reused-variable&#34;&gt;Split a Poorly Reused Variable&lt;/h3&gt;

&lt;p&gt;The next stumbling block to pulling the &lt;code&gt;prepare()&lt;/code&gt; statements out of the loop is that they all use the same variable, &lt;code&gt;$sth&lt;/code&gt;. We&amp;rsquo;ll have to change it so they all use different variables. While we&amp;rsquo;re at it, we&amp;rsquo;ll name those statement handles something more descriptive of what the statement does. Since at this point we haven&amp;rsquo;t figured out what the statements do, we can base the name on the array it gets assigned to.&lt;/p&gt;

&lt;p&gt;While we&amp;rsquo;re at it, throw in some &lt;code&gt;my()&lt;/code&gt; declarations to limit the scope of these variables to just the loop.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($riga=&amp;lt;INPUT&amp;gt;){
    $nump++;
    chop($riga);
    $pagina[$nump] = $riga;

    my $totalvisit_sth = $dbh-&amp;gt;prepare(&#39;SELECT count(*) FROM lognew WHERE 
                                        pageid=? and data&amp;gt;=?&#39;);
    $totalvisit_sth-&amp;gt;execute($pagina[$nump], $startdate);
    $totalvisit[$nump] = $totalvisit_sth-&amp;gt;fetchrow_array();

    my $totalvisittoday_sth = $dbh-&amp;gt;prepare(&#39;SELECT count(*) FROM lognew WHERE
                                             (pageid=? and data=?)&#39;);
    $totalvisittoday_sth-&amp;gt;execute($pagina[$nump], $dataoggi);
    $totalvisittoday[$nump] = $totalvisittoday_sth-&amp;gt;fetchrow_array();

    my $totalyvisit_sth = $dbh-&amp;gt;prepare(&#39;SELECT count(*) FROM lognew WHERE
                                         (pageid=? and data=?)&#39;);
    $totalyvisit_sth-&amp;gt;execute($pagina[$nump], $dataieri);
    $totalyvisit[$nump] = $totalyvisit_sth-&amp;gt;fetchrow_array();

    my $totalmvisit_sth= $dbh-&amp;gt;prepare(&#39;SELECT count(*) FROM lognew WHERE
                                        (pageid=? and data&amp;lt;=? and data&amp;gt;=?)&#39;);
    $totalmvisit_sth-&amp;gt;execute($pagina[$nump], $fine30gg, $inizio30gg);
    $totalmvisit[$nump] = $totalmvisit_sth-&amp;gt;fetchrow_array();
}

close (INPUT);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test. Log. Check in.&lt;/p&gt;

&lt;h3 id=&#34;getting-better-all-the-time&#34;&gt;Getting Better All the Time&lt;/h3&gt;

&lt;p&gt;The new names are better, but they&amp;rsquo;re not great. This is ok. Naming is something people often get hung up on. One can spend hours wracking their brains thinking of the perfect name for a variable or a function. If you can think of a better one than what&amp;rsquo;s there right now, use it. The beauty of Refactoring is you an always improve upon it later.&lt;/p&gt;

&lt;p&gt;This is an important lesson of Refactoring. Voltare said, &amp;ldquo;the best is the enemy of the good&amp;rdquo;. We often get so wound up trying to make code &lt;em&gt;great&lt;/em&gt; that we fail to improve it at all. In refactoring, it&amp;rsquo;s not so important to make your code great in one leap, just a little better all the time (it&amp;rsquo;s a little known fact John Lennon was into Refactoring.) These small improvements will build up into a clean piece of code, with less bugs, more surely than a large-scale code cleanup would.&lt;/p&gt;

&lt;h3 id=&#34;pull-code-out-of-the-loop&#34;&gt;Pull Code Out of the Loop&lt;/h3&gt;

&lt;p&gt;Now it&amp;rsquo;s a simple cut and paste to pull the four &lt;code&gt;prepare()&lt;/code&gt; statements out of the loop.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $totalvisit_sth = $dbh-&amp;gt;prepare(&#39;SELECT count(*) FROM lognew WHERE 
                                    pageid=? and data&amp;gt;=?&#39;);

my $totalvisittoday_sth = $dbh-&amp;gt;prepare(&#39;SELECT count(*) FROM lognew WHERE
                                         (pageid=? and data=?)&#39;);

my $totalyvisit_sth = $dbh-&amp;gt;prepare(&#39;SELECT count(*) FROM lognew WHERE
                                     (pageid=? and data=?)&#39;);

my $totalmvisit_sth = $dbh-&amp;gt;prepare(&#39;SELECT count(*) FROM lognew WHERE
                                     (pageid=? and data&amp;lt;=? and data&amp;gt;=?)&#39;);

open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($riga=&amp;lt;INPUT&amp;gt;){
    $nump++;
    chop($riga);
    $pagina[$nump] = $riga;

    $totalvisit_sth-&amp;gt;execute($pagina[$nump], $startdate);
    $totalvisit[$nump] = $totalvisit_sth-&amp;gt;fetchrow_array();

    $totalvisittoday_sth-&amp;gt;execute($pagina[$nump], $dataoggi);
    $totalvisittoday[$nump] = $totalvisittoday_sth-&amp;gt;fetchrow_array();

    $totalyvisit_sth-&amp;gt;execute($pagina[$nump], $dataieri);
    $totalyvisit[$nump] = $totalyvisit_sth-&amp;gt;fetchrow_array();

    $totalmvisit_sth-&amp;gt;execute($pagina[$nump], $fine30gg, $inizio30gg);
    $totalmvisit[$nump] = $totalmvisit_sth-&amp;gt;fetchrow_array();
}

close (INPUT);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Already the code is looking better. With the SQL separated, the inner workings of the loop are much less daunting.&lt;/p&gt;

&lt;p&gt;Test. Log. Check in.&lt;/p&gt;

&lt;h3 id=&#34;a-place-to-stop&#34;&gt;A Place to Stop&lt;/h3&gt;

&lt;p&gt;Remember our goal, to make this code run faster. By pulling the &lt;code&gt;prepare()&lt;/code&gt; statements outside the loop we&amp;rsquo;ve likely achieved this goal. Additionally, it still does exactly what it did before even though we still don&amp;rsquo;t fully understand what that is. If this were a real project, you&amp;rsquo;d do some benchmarking to see if the code is fast enough and move on to another task.&lt;/p&gt;

&lt;p&gt;Since this is an example, I&amp;rsquo;ll continue with more refactorings with the goal of clarifying the code further and figuring out what it does.&lt;/p&gt;

&lt;p&gt;Keep in mind that after every refactoring the code still does &lt;em&gt;exactly what it did before&lt;/em&gt;. This means we can stop choose to stop after any refactoring. If a more pressing task suddenly pops up we can pause our refactoring work and attend to that feeling confident we didn&amp;rsquo;t leave any broken code lying around.&lt;/p&gt;

&lt;h3 id=&#34;reformat-sql-for-better-readability&#34;&gt;Reformat SQL for Better Readability&lt;/h3&gt;

&lt;p&gt;In order to make sense of the code, we have to make sense of the SQL. The simplest way to better understand the SQL is to put it into a clearer format.&lt;/p&gt;

&lt;p&gt;The three major parts of an SQL SELECT statement are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The rows (ie. &lt;code&gt;SELECT count(*)&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;The table (ie. &lt;code&gt;FROM lognew&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;The predicate (ie. &lt;code&gt;WHERE pageid = ...&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I&amp;rsquo;ve chosen a new format that highlights these parts.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve also removed some unnecessary parenthesis because they just serve to clutter things up rather than disambiguate an expression.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve also decided to change the quoting style from single quotes to a here-doc. It would have also been okay to use &lt;code&gt;q{}&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $totalvisit_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*)
FROM   lognew 
WHERE  pageid =  ? AND 
       data   &amp;gt;= ?
SQL

my $totalvisittoday_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid = ? AND 
       data   = ?
SQL

my $totalyvisit_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid = ? AND 
       data   = ?
SQL

my $totalmvisit_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid =  ? AND
       data   &amp;lt;= ? AND 
       data   &amp;gt;= ?
SQL

open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($riga=&amp;lt;INPUT&amp;gt;){
    $nump++;
    chop($riga);
    $pagina[$nump] = $riga;

    $totalvisit_sth-&amp;gt;execute($pagina[$nump], $startdate);
    $totalvisit[$nump] = $totalvisit_sth-&amp;gt;fetchrow_array();

    $totalvisittoday_sth-&amp;gt;execute($pagina[$nump], $dataoggi);
    $totalvisittoday[$nump] = $totalvisittoday_sth-&amp;gt;fetchrow_array();

    $totalyvisit_sth-&amp;gt;execute($pagina[$nump], $dataieri);
    $totalyvisit[$nump] = $totalyvisit_sth-&amp;gt;fetchrow_array();

    $totalmvisit_sth-&amp;gt;execute($pagina[$nump], $fine30gg, $inizio30gg);
    $totalmvisit[$nump] = $totalmvisit_sth-&amp;gt;fetchrow_array();
}

close (INPUT);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test. Log. Check in.&lt;/p&gt;

&lt;h3 id=&#34;remove-redundancy&#34;&gt;Remove Redundancy&lt;/h3&gt;

&lt;p&gt;With the SQL in a more readable format, some commonalities become clear.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;All the statements are doing a &lt;code&gt;count(*)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;They&amp;rsquo;re all using the &lt;code&gt;lognew&lt;/code&gt; table&lt;/li&gt;
&lt;li&gt;They&amp;rsquo;re all looking for a certain &lt;code&gt;pageid&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In fact, &lt;code&gt;$totalvisittoday_sth&lt;/code&gt; and &lt;code&gt;$totalyvisit_sth&lt;/code&gt; are exactly the same! Let&amp;rsquo;s eliminate one of them, doesn&amp;rsquo;t matter which, we&amp;rsquo;re going to rename them in a moment anyway. &lt;code&gt;$totalyvisit_sth&lt;/code&gt; goes away, making sure to change all references to it to &lt;code&gt;$totalvisittoday_sth&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $totalvisit_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*)
FROM   lognew 
WHERE  pageid =  ? AND 
       data   &amp;gt;= ?
SQL

my $totalvisittoday_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid = ? AND 
       data   = ?
SQL

my $totalmvisit_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid =  ? AND
       data   &amp;lt;= ? AND 
       data   &amp;gt;= ?
SQL

open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($riga=&amp;lt;INPUT&amp;gt;){
    $nump++;
    chop($riga);
    $pagina[$nump] = $riga;

    $totalvisit_sth-&amp;gt;execute($pagina[$nump], $startdate);
    $totalvisit[$nump] = $totalvisit_sth-&amp;gt;fetchrow_array();

    $totalvisittoday_sth-&amp;gt;execute($pagina[$nump], $dataoggi);
    $totalvisittoday[$nump] = $totalvisittoday_sth-&amp;gt;fetchrow_array();

    $totalvisittoday_sth-&amp;gt;execute($pagina[$nump], $dataieri);
    $totalyvisit[$nump] = $totalvisittoday_sth-&amp;gt;fetchrow_array();

    $totalmvisit_sth-&amp;gt;execute($pagina[$nump], $fine30gg, $inizio30gg);
    $totalmvisit[$nump] = $totalmvisit_sth-&amp;gt;fetchrow_array();
}

close (INPUT);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test. Log. Check in.&lt;/p&gt;

&lt;h3 id=&#34;fix-conflicting-styles&#34;&gt;Fix Conflicting Styles&lt;/h3&gt;

&lt;p&gt;Now the only difference between the statements is the choice of &lt;code&gt;data&lt;/code&gt; ranges.&lt;/p&gt;

&lt;p&gt;Using the variables are passed into each statement we can make some more deductions. Let&amp;rsquo;s have a look&amp;hellip;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$startdate&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$dataoggi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$dataieri&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$fine30gg, $inizio30gg&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;One of these things is not like the other.&lt;/em&gt; What&amp;rsquo;s &lt;code&gt;$startdate&lt;/code&gt; doing there? Everything else is talking about &amp;lsquo;data&amp;rsquo;. What&amp;rsquo;s &amp;lsquo;ieri&amp;rsquo;? &amp;lsquo;oggi&amp;rsquo;? Remember, the programmer who submitted this code is Italian. Maybe the names are in Italian. Grabbing an &lt;a href=&#34;http://dictionaries.travlang.com/ItalianEnglish/&#34;&gt;Italian-English dictionary&lt;/a&gt; we find out that &amp;lsquo;data&amp;rsquo; is Italian for &amp;lsquo;date&amp;rsquo;! Now it makes sense, this code was probably originally written in English, then worked on by an Italian (or vice-versa).&lt;/p&gt;

&lt;p&gt;This code has committed a cardinal stylistic sin. It uses two different languages for naming variables. Not just different languages, languages which have different meanings for the same words. Taken out of context, we can&amp;rsquo;t know if &lt;code&gt;$data&lt;/code&gt; represents a hunk of facts or &amp;ldquo;Thursday.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Since the styles conflict, one of them has to go. Since I don&amp;rsquo;t speak Italian, I&amp;rsquo;m going to translate it into English.&lt;/p&gt;

&lt;p&gt;Pulling out our Italian-to-English dictionary&amp;hellip;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;riga&amp;rdquo; is &amp;ldquo;line&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;pagina&amp;rdquo; is &amp;ldquo;page&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;nump&amp;rdquo; is probably short for &amp;ldquo;numero pagina&amp;rdquo; which is &amp;ldquo;page number&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;data&amp;rdquo; is &amp;ldquo;date&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;oggi&amp;rdquo; is &amp;ldquo;today&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;ieri&amp;rdquo; is &amp;ldquo;yesterday&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;inizio&amp;rdquo; is &amp;ldquo;start&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;fine&amp;rdquo; is &amp;ldquo;end&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;gg&amp;rdquo; is probably short for &amp;ldquo;giorni&amp;rdquo; which is &amp;ldquo;days&amp;rdquo;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;fine30gg&amp;rdquo; would then be &amp;ldquo;the end of 30 days&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;inizio30gg&amp;rdquo; would be &amp;ldquo;the beginning of 30 days&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It would be a straightforward matter of a bunch of search-and-replaces in any good editor but for one snag, the SQL column &amp;lsquo;data.&amp;rsquo; We&amp;rsquo;d like to change this to its English &amp;lsquo;date&amp;rsquo;, but databases are very global with possibly lots of other programs using it. So we can&amp;rsquo;t change the column name without breaking other code. While in a well-organized programming shop you might have the ability to find all the code which uses your database, we won&amp;rsquo;t assume we have that luxury here. For the moment then, we&amp;rsquo;ll leave that be and deal with it in a separate refactoring.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $totalvisit_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*)
FROM   lognew 
WHERE  pageid =  ? AND 
       data   &amp;gt;= ?
SQL

my $totalvisittoday_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid = ? AND 
       data   = ?
SQL

my $totalmvisit_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid =  ? AND
       data   &amp;lt;= ? AND 
       data   &amp;gt;= ?
SQL

open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($line=&amp;lt;INPUT&amp;gt;){
    $page_num++;
    chop($line);
    $pages[$page_num] = $line;

    $totalvisit_sth-&amp;gt;execute($pages[$page_num], $start_date);
    $totalvisit[$page_num] = $totalvisit_sth-&amp;gt;fetchrow_array();

    $totalvisittoday_sth-&amp;gt;execute($pages[$page_num], $today);
    $totalvisittoday[$page_num] = $totalvisittoday_sth-&amp;gt;fetchrow_array();

    $totalvisittoday_sth-&amp;gt;execute($pages[$page_num], $yesterday);
    $totalyvisit[$page_num] = $totalvisittoday_sth-&amp;gt;fetchrow_array();

    $totalmvisit_sth-&amp;gt;execute($pages[$page_num], $end_of_30_days,
                                                 $start_of_30_days);
    $totalmvisit[$page_num] = $totalmvisit_sth-&amp;gt;fetchrow_array();
}

close (INPUT);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test. Log. Check in.&lt;/p&gt;

&lt;h3 id=&#34;better-names&#34;&gt;Better Names&lt;/h3&gt;

&lt;p&gt;With decent variable names in place, the purpose of the program becomes &lt;strong&gt;much&lt;/strong&gt; clearer. This is a program to calculate the number of visits to a page for various date ranges. Based on this new information we can give the statement handles and the arrays they put data into better names.&lt;/p&gt;

&lt;p&gt;Looking at the SQL we see we&amp;rsquo;ve got:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;One to get all the visits up to a single day.&lt;/li&gt;
&lt;li&gt;One to get the visits for a certain date.&lt;/li&gt;
&lt;li&gt;One to get the visits for a range of dates.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A good set of new names would be:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;daily&lt;/li&gt;
&lt;li&gt;up to&lt;/li&gt;
&lt;li&gt;range&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Also, Total Visits is too long. We could shorten that to just Visits, or even shorter to Hits.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $hits_upto_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*)
FROM   lognew 
WHERE  pageid =  ? AND 
       data   &amp;gt;= ?
SQL

my $hits_daily_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid = ? AND 
       data   = ?
SQL

my $hits_range_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid =  ? AND
       data   &amp;lt;= ? AND 
       data   &amp;gt;= ?
SQL

open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($line=&amp;lt;INPUT&amp;gt;){
    $page_num++;
    chop($line);
    $pages[$page_num] = $line;

    $hits_upto_sth-&amp;gt;execute($pages[$page_num], $start_date);
    $totalvisit[$page_num] = $hits_upto_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($pages[$page_num], $today);
    $totalvisittoday[$page_num] = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($pages[$page_num], $yesterday);
    $totalyvisit[$page_num] = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_range_sth-&amp;gt;execute($pages[$page_num], $end_of_30_days,
                                                $start_of_30_days);
    $totalmvisit[$page_num] = $hits_range_sth-&amp;gt;fetchrow_array();
}

close (INPUT);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test. Log. Check in.&lt;/p&gt;

&lt;h3 id=&#34;changing-global-variable-names&#34;&gt;Changing Global Variable Names&lt;/h3&gt;

&lt;p&gt;The array names need work, too. Currently, they&amp;rsquo;re rather ambiguous. &lt;code&gt;@totalyvisit&lt;/code&gt;, what does the &lt;em&gt;y&lt;/em&gt; mean? Looking at each variable name and the variables that got passed to &lt;code&gt;execute()&lt;/code&gt; to produce it&amp;hellip;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@totalvisit&lt;/code&gt; comes up to a &lt;code&gt;$start_date&lt;/code&gt;. So that can be &lt;code&gt;@hits_upto&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@totalvisittoday&lt;/code&gt; comes from &lt;code&gt;$today&lt;/code&gt; and is pretty obvious. &lt;code&gt;@hits_today&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@totalyvisit&lt;/code&gt; comes from &lt;code&gt;$yesterday&lt;/code&gt; so &amp;lsquo;y&amp;rsquo; must be for &amp;lsquo;yesterday&amp;rsquo;. &lt;code&gt;@hits_yesterday&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@totalmvisit&lt;/code&gt; comes from the range produced by the $start_of_30_days and the $end_of_30_days. So &amp;rsquo;m&amp;rsquo; must be &amp;lsquo;month&amp;rsquo;. &lt;code&gt;@hits_monthly&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- --&gt;

&lt;pre&gt;&lt;code&gt;my $hits_upto_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*)
FROM   lognew 
WHERE  pageid =  ? AND 
       data   &amp;gt;= ?
SQL

my $hits_daily_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid = ? AND 
       data   = ?
SQL

my $hits_range_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid =  ? AND
       data   &amp;lt;= ? AND 
       data   &amp;gt;= ?
SQL

open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($line=&amp;lt;INPUT&amp;gt;){
    $page_num++;
    chop($line);
    $pages[$page_num] = $line;

    $hits_upto_sth-&amp;gt;execute($pages[$page_num], $start_date);
    $hits_upto[$page_num] = $hits_upto_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($pages[$page_num], $today);
    $hits_today[$page_num] = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($pages[$page_num], $yesterday);
    $hits_yesterday[$page_num] = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_range_sth-&amp;gt;execute($pages[$page_num], $end_of_30_days,
                                                $start_of_30_days);
    $hits_monthly[$page_num] = $hits_range_sth-&amp;gt;fetchrow_array();
}

close (INPUT);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test&amp;hellip; uh-oh, test failed!&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s something &lt;strong&gt;very&lt;/strong&gt; different about this change compared to the others. The variables we changed were &lt;em&gt;not&lt;/em&gt; declared in our little code block. Likely they&amp;rsquo;re used in other parts of the code, such as our test which caused it to break.&lt;/p&gt;

&lt;p&gt;In the Real World, we would be sure to &lt;strong&gt;replace all occurrences of the variable&lt;/strong&gt;. The simplest way to do this is to use your editor to perform a search and replace rather than doing it by your all too fallible hands. If it could be used over a set of files, grepping through those files for all occurrences of it and changing those as well would be necessary.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# If you don&#39;t have rgrep, grep -r does the same thing.
rgrep &#39;[@$]totalvisit&#39; /path/to/your/project
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I do this so often that I&amp;rsquo;ve taken to calling grep -r, &amp;lsquo;Refactoring Grep&amp;rsquo;. Other languages who&amp;rsquo;s syntax is &amp;ndash; ummm &amp;ndash; not as inspired as Perl&amp;rsquo;s, such as Java, C++ and Python, have tools for doing this sort of thing automatically. Because of the complexity of Perl&amp;rsquo;s syntax, we still have to do it mostly by hand, though there are some efforts underway to rectify this.&lt;/p&gt;

&lt;p&gt;Changing the array names in our test as well we get them to pass.&lt;/p&gt;

&lt;p&gt;Log. Check in.&lt;/p&gt;

&lt;h3 id=&#34;improve-overly-generic-names&#34;&gt;Improve Overly Generic Names&lt;/h3&gt;

&lt;p&gt;Continuing with our variable name improvements, we&amp;rsquo;re left with the last few unimproved names. Let&amp;rsquo;s start with &lt;code&gt;$line&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Since we can see clearly that &lt;code&gt;$line = &amp;lt;INPUT&amp;gt;&lt;/code&gt;, calling the variable &amp;lsquo;line&amp;rsquo; tells us nothing new. A better name might be what each line contains. Looking at how the line is used we see &lt;code&gt;$pages[$page_num] = $line&lt;/code&gt; and how that is then used in the SQL. It&amp;rsquo;s a page id.&lt;/p&gt;

&lt;p&gt;But it doesn&amp;rsquo;t make much sense to put a page id into an array called &lt;code&gt;@pages&lt;/code&gt;. It doesn&amp;rsquo;t contain pages, it contains &lt;code&gt;@page_ids&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;What about &lt;code&gt;$page_num&lt;/code&gt;? It doesn&amp;rsquo;t contain a page number, it contains the line number of the file we&amp;rsquo;re reading in. Or more conventionally, an &lt;code&gt;$index&lt;/code&gt; or &lt;code&gt;$idx&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $hits_upto_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*)
FROM   lognew 
WHERE  pageid =  ? AND 
       data   &amp;gt;= ?
SQL

my $hits_daily_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid = ? AND 
       data   = ?
SQL

my $hits_range_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid =  ? AND
       data   &amp;lt;= ? AND 
       data   &amp;gt;= ?
SQL

open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($page_id=&amp;lt;INPUT&amp;gt;){
    $idx++;
    chop($page_id);
    $page_ids[$idx] = $page_id;

    $hits_upto_sth-&amp;gt;execute($page_ids[$idx], $start_date);
    $hits_upto[$idx] = $hits_upto_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($page_ids[$idx], $today);
    $hits_today[$idx] = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($page_ids[$idx], $yesterday);
    $hits_yesterday[$idx] = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_range_sth-&amp;gt;execute($page_ids[$idx], $end_of_30_days,
                                                   $start_of_30_days);
    $hits_monthly[$idx] = $hits_range_sth-&amp;gt;fetchrow_array();
}

close (INPUT);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test. Log. Check in.&lt;/p&gt;

&lt;h3 id=&#34;fixing-odd-interfaces&#34;&gt;Fixing Odd Interfaces&lt;/h3&gt;

&lt;p&gt;What&amp;rsquo;s wrong with this picture?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$hits_range_sth-&amp;gt;execute($page_ids[$idx], $end_of_30_days,
                                               $start_of_30_days);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Isn&amp;rsquo;t it a little odd to specify a date range with the end first? Sure is. It also guarantees someone is going to get it backwards. Reverse it. Don&amp;rsquo;t forget the SQL, too.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $hits_upto_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*)
FROM   lognew 
WHERE  pageid =  ? AND 
       data   &amp;gt;= ?
SQL

my $hits_daily_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid = ? AND 
       data   = ?
SQL

my $hits_range_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid =  ? AND
       data   &amp;gt;= ? AND
       data   &amp;lt;= ? 
SQL

open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($page_id=&amp;lt;INPUT&amp;gt;){
    $idx++;
    chop($page_id);
    $page_ids[$idx] = $page_id;

    $hits_upto_sth-&amp;gt;execute($page_ids[$idx], $start_date);
    $hits_upto[$idx] = $hits_upto_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($page_ids[$idx], $today);
    $hits_today[$idx] = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($page_ids[$idx], $yesterday);
    $hits_yesterday[$idx] = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_range_sth-&amp;gt;execute($page_ids[$idx], $start_of_30_days,
                                                   $end_of_30_days);
    $hits_monthly[$idx] = $hits_range_sth-&amp;gt;fetchrow_array();
}

close (INPUT);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test. Log. Check in.&lt;/p&gt;

&lt;h3 id=&#34;s-chop-chomp&#34;&gt;s/chop/chomp/&lt;/h3&gt;

&lt;p&gt;Now that we&amp;rsquo;ve stared at the code for a while, you might have noticed the use of &lt;code&gt;chop()&lt;/code&gt;. Using &lt;code&gt;chop()&lt;/code&gt; to strip a newline is asking for portability problems, so let&amp;rsquo;s fix it by using &lt;code&gt;chomp()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Technically this &lt;em&gt;isn&amp;rsquo;t&lt;/em&gt; a refactoring since we altered the behavior of the code by fixing the bug. But using &lt;code&gt;chop()&lt;/code&gt; where you meant &lt;code&gt;chomp()&lt;/code&gt; is such a common mistake we&amp;rsquo;ll make it an honorary refactoring.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $hits_upto_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*)
FROM   lognew 
WHERE  pageid =  ? AND 
       data   &amp;gt;= ?
SQL

my $hits_daily_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid = ? AND 
       data   = ?
SQL

my $hits_range_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid =  ? AND
       data   &amp;gt;= ? AND
       data   &amp;lt;= ? 
SQL

open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($page_id=&amp;lt;INPUT&amp;gt;){
    $idx++;
    chomp($page_id);
    $page_ids[$idx] = $page_id;

    $hits_upto_sth-&amp;gt;execute($page_ids[$idx], $start_date);
    $hits_upto[$idx] = $hits_upto_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($page_ids[$idx], $today);
    $hits_today[$idx] = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($page_ids[$idx], $yesterday);
    $hits_yesterday[$idx] = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_range_sth-&amp;gt;execute($page_ids[$idx], $start_of_30_days,
                                                   $end_of_30_days,);
    $hits_monthly[$idx] = $hits_range_sth-&amp;gt;fetchrow_array();
}

close (INPUT);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test. Log. Check in.&lt;/p&gt;

&lt;h3 id=&#34;collect-related-variables-into-hashes&#34;&gt;Collect Related Variables into Hashes&lt;/h3&gt;

&lt;p&gt;The common prefix &lt;code&gt;hits_&lt;/code&gt; is a dead giveaway that much of the data in this code is related. Related variables should be grouped together into a single structure, probably a hash to make the relation obvious and allow them to be passed around to subroutines more easily. Its easier to move around one hash than four arrays.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve decided to collect together all the &lt;code&gt;@hit_&lt;/code&gt; arrays into a single hash &lt;code&gt;%hits&lt;/code&gt; since they&amp;rsquo;ll probably be used together parts of the program. If this code snippet represents a function it means I can return one hash reference rather than four array refs. It also makes future expansion easier, rather than returning an additional array it simply becomes another key in the hash.&lt;/p&gt;

&lt;p&gt;Before.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$hits{upto}[$idx] = $hits_upto_sth-&amp;gt;fetchrow_array();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$hits_upto[$idx]  = $hits_upto_sth-&amp;gt;fetchrow_array();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s interesting to note what a small, natural change this is. Circumstantial evidence that this is a good refactoring.&lt;/p&gt;

&lt;p&gt;As before, since these arrays are global data, we must be sure to change them everywhere. This includes the tests.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $hits_upto_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*)
FROM   lognew 
WHERE  pageid =  ? AND 
       data   &amp;gt;= ?
SQL

my $hits_daily_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid = ? AND 
       data   = ?
SQL

my $hits_range_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid =  ? AND
       data   &amp;gt;= ? AND
       data   &amp;lt;= ? 
SQL

open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($page_id=&amp;lt;INPUT&amp;gt;){
    $idx++;
    chomp($page_id);
    $page_ids[$idx] = $page_id;

    $hits_upto_sth-&amp;gt;execute($page_ids[$idx], $start_date);
    $hits{upto}[$idx] = $hits_upto_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($page_ids[$idx], $today);
    $hits{today}[$idx] = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($page_ids[$idx], $yesterday);
    $hits{yesterday}[$idx] = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_range_sth-&amp;gt;execute($page_ids[$idx], $start_of_30_days,
                                                   $end_of_30_days,);
    $hits{monthly}[$idx] = $hits_range_sth-&amp;gt;fetchrow_array();
}

close (INPUT);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test. Log. Check in.&lt;/p&gt;

&lt;h3 id=&#34;when-not-to-refactor&#34;&gt;When Not to Refactor&lt;/h3&gt;

&lt;p&gt;The statement handles are also related, but I&amp;rsquo;m not going to collect them together into a hash. The statement handles are short-lived lexicals, they&amp;rsquo;re never likely to be passed around. Their short scope and grouping within the code makes their relationship obvious. The design would not be improved by the refactoring.&lt;/p&gt;

&lt;p&gt;Refactoring is not a set of rules to be slavishly followed, it&amp;rsquo;s a collection of tools. And like any other tool you must carefully consider when and when not to use it. Since collecting the statement handles together doesn&amp;rsquo;t improve the design, I won&amp;rsquo;t do it.&lt;/p&gt;

&lt;h3 id=&#34;eliminate-unnecessary-longhand&#34;&gt;Eliminate Unnecessary Longhand&lt;/h3&gt;

&lt;p&gt;Boy, we sure use &lt;code&gt;$page_ids[$idx]&lt;/code&gt; a lot. It&amp;rsquo;s the current page ID. But don&amp;rsquo;t we have a variable for that?&lt;/p&gt;

&lt;p&gt;Replace all the unnecessary array accesses and just use the more concise and descriptive &lt;code&gt;$page_id&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $hits_upto_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*)
FROM   lognew 
WHERE  pageid =  ? AND 
       data   &amp;gt;= ?
SQL

my $hits_daily_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid = ? AND 
       data   = ?
SQL

my $hits_range_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid =  ? AND
       data   &amp;gt;= ? AND
       data   &amp;lt;= ? 
SQL

open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($page_id=&amp;lt;INPUT&amp;gt;){
    $idx++;
    chomp($page_id);
    $page_ids[$idx] = $page_id;

    $hits_upto_sth-&amp;gt;execute($page_id, $start_date);
    $hits{upto}[$idx] = $hits_upto_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($page_id, $today);
    $hits{today}[$idx] = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($page_id, $yesterday);
    $hits{yesterday}[$idx] = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_range_sth-&amp;gt;execute($page_id, $start_of_30_days,
                                       $end_of_30_days,);
    $hits{monthly}[$idx] = $hits_range_sth-&amp;gt;fetchrow_array();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test. Log. Check in.&lt;/p&gt;

&lt;h3 id=&#34;rearrange-data-structures-to-fit-their-use&#34;&gt;Rearrange Data Structures to Fit Their Use&lt;/h3&gt;

&lt;p&gt;Currently, &lt;code&gt;%hits&lt;/code&gt; is accessed by the order the page ID was read out of the file. Well, that doesn&amp;rsquo;t seem very useful at all. Its purpose seems to be for listing the page counts in exactly the same order as you read them in. Even then you need to iterate through &lt;code&gt;@page_ids&lt;/code&gt; simultaneously because no where in &lt;code&gt;%hits&lt;/code&gt; is the page ID stored.&lt;/p&gt;

&lt;p&gt;Consider a common operation, looking up the hit counts for a given page ID. You have to iterate through the whole list of page IDs to do it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foreach my $idx (0..$#page_ids) {
    if( $page_ids[$idx] eq $our_page_id ) {
        print &amp;quot;Hits for $our_page_id today: $hits{today}[$idx]\n&amp;quot;;
        last;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cumbersome. A much better layout would be a hash keyed on the page ID.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$hits{upto}{$page_id} = $hits_upto_sth-&amp;gt;fetchrow_array();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can directly access the data for a given page ID. If necessary, we can still list the hits in the same order they were read in by iterating through &lt;code&gt;@page_ids&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $hits_upto_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*)
FROM   lognew 
WHERE  pageid =  ? AND 
       data   &amp;gt;= ?
SQL

my $hits_daily_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid = ? AND 
       data   = ?
SQL

my $hits_range_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid =  ? AND
       data   &amp;gt;= ? AND
       data   &amp;lt;= ? 
SQL

open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($page_id=&amp;lt;INPUT&amp;gt;){
    $idx++;
    chomp($page_id);
    $page_ids[$idx] = $page_id;

    $hits_upto_sth-&amp;gt;execute($page_id, $start_date);
    $hits{upto}{$page_id} = $hits_upto_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($page_id, $today);
    $hits{today}{$page_id} = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($page_id, $yesterday);
    $hits{yesterday}{$page_id} = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_range_sth-&amp;gt;execute($page_id, $start_of_30_days,
                                       $end_of_30_days,);
    $hits{monthly}{$page_id} = $hits_range_sth-&amp;gt;fetchrow_array();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test. Log. Check in.&lt;/p&gt;

&lt;h3 id=&#34;eliminate-unnecessary-variables&#34;&gt;Eliminate Unnecessary Variables&lt;/h3&gt;

&lt;p&gt;Now that &lt;code&gt;%hits&lt;/code&gt; is no longer ordered by how it was read in, &lt;code&gt;$idx&lt;/code&gt; isn&amp;rsquo;t used much anymore. It&amp;rsquo;s only used to stick &lt;code&gt;$page_id&lt;/code&gt; onto the end of &lt;code&gt;@page_ids&lt;/code&gt;, but we can do that with &lt;code&gt;push&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This is minor but little things build up to cause big messes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $hits_upto_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*)
FROM   lognew 
WHERE  pageid =  ? AND 
       data   &amp;gt;= ?
SQL

my $hits_daily_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid = ? AND 
       data   = ?
SQL

my $hits_range_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid =  ? AND
       data   &amp;gt;= ? AND
       data   &amp;lt;= ? 
SQL

open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($page_id=&amp;lt;INPUT&amp;gt;){
    chomp($page_id);
    push @page_ids, $page_id;

    $hits_upto_sth-&amp;gt;execute($page_id, $start_date);
    $hits{upto}{$page_id} = $hits_upto_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($page_id, $today);
    $hits{today}{$page_id} = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_daily_sth-&amp;gt;execute($page_id, $yesterday);
    $hits{yesterday}{$page_id} = $hits_daily_sth-&amp;gt;fetchrow_array();

    $hits_range_sth-&amp;gt;execute($page_id, $start_of_30_days,
                                       $end_of_30_days,);
    $hits{monthly}{$page_id} = $hits_range_sth-&amp;gt;fetchrow_array();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test. Log. Check in.&lt;/p&gt;

&lt;h3 id=&#34;pull-logical-chunks-out-into-functions&#34;&gt;Pull Logical Chunks Out into Functions&lt;/h3&gt;

&lt;p&gt;Our final refactoring is one of the most common and most useful.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s assume that we need to generate page counts somewhere else in the code. Rather than repeat the code to do this, we want to put it in a subroutine so it can be reused. One subroutine for each statement.&lt;/p&gt;

&lt;p&gt;In order to do this, start by identifying the code that would go into the routine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$hits_upto_sth-&amp;gt;execute($page_id, $start_date);
$hits{upto}{$page_id} = $hits_upto_sth-&amp;gt;fetchrow_array();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then wrap a subroutine around it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub hits_upto {
    $hits_upto_sth-&amp;gt;execute($page_id, $start_date);
    $hits{upto}{$page_id} = $hits_upto_sth-&amp;gt;fetchrow_array();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now look at all the variables used.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$hits_upto_sth&lt;/code&gt; is a global (well, file-scoped lexical) and is defined entirely outside the function. We can keep using it in our subroutine in the same way we are now.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$hits{upto}{$page_id}&lt;/code&gt; is receiving the result of the calculation. It contains the return value. So it goes outside the function to receive the return value. Where its assignment was, we put a &lt;code&gt;return&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub hits_upto {
    $hits_upto_sth-&amp;gt;execute($page_id, $start_date);
    return $hits_upto_sth-&amp;gt;fetchrow_array();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$page_id&lt;/code&gt; and &lt;code&gt;$start_date&lt;/code&gt; vary from call to call. These are our function arguments.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub hits_upto {
    my($page_id, $start_date) = @_;
    $hits_upto_sth-&amp;gt;execute($page_id, $start_date);
    return $hits_upto_sth-&amp;gt;fetchrow_array();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, rename things in a more generic manner. This is a subroutine for calculating the number of hits up to a certain date. Instead of &lt;code&gt;$start_date&lt;/code&gt; which was specific to one calculation, we&amp;rsquo;d call it &lt;code&gt;$date&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub hits_upto {
    my($page_id, $date) = @_;
    $hits_upto_sth-&amp;gt;execute($page_id, $date);
    return $hits_upto_sth-&amp;gt;fetchrow_array();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that&amp;rsquo;s our new subroutine, does the same thing as the original code. Then it&amp;rsquo;s a simple matter to use it in the code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $hits{upto}{$page_id} = hits_upto($page_id, $start_date);


my $hits_upto_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*)
FROM   lognew 
WHERE  pageid =  ? AND 
       data   &amp;gt;= ?
SQL

my $hits_daily_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid = ? AND 
       data   = ?
SQL

my $hits_range_sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;&#39;SQL&#39;);
SELECT count(*) 
FROM   lognew 
WHERE  pageid =  ? AND
       data   &amp;gt;= ? AND
       data   &amp;lt;= ? 
SQL

open (INPUT, &amp;quot;&amp;lt; $filepageid&amp;quot;) || &amp;amp;file_open_error(&amp;quot;$filepageid&amp;quot;);

while ($page_id=&amp;lt;INPUT&amp;gt;){
    chomp($page_id);
    push @page_ids, $page_id;

    $hits{upto}{$page_id}      = hits_upto($page_id, $start_date);
    $hits{today}{$page_id}     = hits_daily($page_id, $today);
    $hits{yesterday}{$page_id} = hits_daily($page_id, $yesterday);
    $hits{monthly}{$page_id}   = hits_range($page_id, $start_of_30_days,
                                                        $end_of_30_days,);
}

sub hits_upto {
    my($page_id, $date) = @_;
    $hits_upto_sth-&amp;gt;execute($page_id, $date);
    return scalar $hits_upto_sth-&amp;gt;fetchrow_array();
}

sub hits_daily {
    my($page_id, $date) = @_;
    $hits_daily_sth-&amp;gt;execute($page_id, $date);
    return scalar $hits_daily_sth-&amp;gt;fetchrow_array();
}

sub hits_range {
    my($page_id, $start, $end) = @_;
    $hits_range_sth-&amp;gt;execute($page_id, $start, $end);
    return scalar $hits_range_sth-&amp;gt;fetchrow_array();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test. Log. Check in.&lt;/p&gt;

&lt;h3 id=&#34;undo&#34;&gt;Undo.&lt;/h3&gt;

&lt;p&gt;Some may balk at putting that small of a snippet of code into a subroutine like that. There are definite performance concerns about adding four subroutine calls to a loop. But I&amp;rsquo;m not worried about that at all.&lt;/p&gt;

&lt;p&gt;One of the beauties of Refactoring is that it&amp;rsquo;s reversible. Refactorings don&amp;rsquo;t change how the program works. We can reverse any of these refactorings and the code will work exactly the same. If a refactoring turns out to be a bad idea, undo it. Logging each refactoring in version control makes the job even easier.&lt;/p&gt;

&lt;p&gt;So if it turns out moving the executes into their own functions causes a performance problem the change can easily be undone.&lt;/p&gt;

&lt;h3 id=&#34;done&#34;&gt;Done?&lt;/h3&gt;

&lt;p&gt;At this point, things are looking pretty nice. The code is well structured, readable, and efficient. The variables are sensibly named. The data is organized in a fairly flexible manner.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s good enough. This is not to say that there&amp;rsquo;s not more that could be done, but we don&amp;rsquo;t need to. And Refactoring is about doing as much redesign as you need instead of what you might need.&lt;/p&gt;

&lt;h3 id=&#34;refactoring-and-the-swiss-army-knife&#34;&gt;Refactoring and the Swiss Army Knife&lt;/h3&gt;

&lt;p&gt;As programmers we have a tendency towards over-design. We like to design our code to deal with any possible situation that might arise, since it was hard to change the design later. This is known as Big Design Up Front (BDUF). It&amp;rsquo;s like one of those &lt;a href=&#34;http://www.victorinox.com/newsite/en/produkte/neu/inhalt2.cfm?pid=1-6795-XLT&#34;&gt;enormous Swiss Army Knives with 50 functions&lt;/a&gt;. Most of the time all you need is &lt;a href=&#34;http://www.victorinox.com/newsite/en/produkte/neu/inhalt2.cfm?pid=2-2363&#34;&gt;a knife with something to open your beer with and then maybe pick your teeth afterwards&lt;/a&gt; but you never know. So you over-engineer because it&amp;rsquo;s hard to improve it later. If it never gets used then a lot of effort has been wasted.&lt;/p&gt;

&lt;p&gt;Refactoring turns design on its ear. Now you can continually evolve your design as needed. There&amp;rsquo;s no longer a need to write for every possible situation up front so you can focus on just what you need right now. If you need more flexibility later, you can add that flexibility through refactoring. It&amp;rsquo;s like having a Swiss Army knife that you can add tools to as you need them.&lt;/p&gt;

&lt;h3 id=&#34;further-reference&#34;&gt;Further Reference&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://groups.google.com/groups?th=11b4e3caaafb9849&amp;amp;seekm=20021005063711.GE15102%40ool-18b93024.dyn.optonline.net#link1&#34;&gt;The original thread on Fun With Perl&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The &lt;a href=&#34;http://www.c2.com/cgi/wiki?WelcomeVisitors&#34;&gt;Portland Pattern Repository&lt;/a&gt; answers the question &amp;ndash; &lt;a href=&#34;http://www.c2.com/cgi/wiki?WhatIsRefactoring&#34;&gt;WhatIsRefactoring?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.com/exec/obidos/tg/detail/-/0201485672&#34;&gt;The Refactoring Book&lt;/a&gt; by &lt;a href=&#34;http://www.martinfowler.com&#34;&gt;Martin Fowler&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Program Repair Shop and Red Flags</title>
      <link>http://localhost:1313/pub/2000/11/repair3.html/</link>
      <pubDate>Tue, 14 Nov 2000 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2000/11/repair3.html/</guid>
      <description>

&lt;p&gt;&lt;span id=&#34;__index__&#34;&gt;&lt;/span&gt;
&lt;a href=&#34;#what&#39;s%20wrong%20with%20this%20picture&#34;&gt;What&amp;rsquo;s wrong with this picture?&lt;/a&gt;
&lt;a href=&#34;#the%20interface&#34;&gt;The Interface&lt;/a&gt;
&lt;a href=&#34;#the%20code&#34;&gt;The Code&lt;/a&gt;
-   &lt;a href=&#34;#open_info_file&#34;&gt;&lt;code&gt;open_info_file&lt;/code&gt;&lt;/a&gt;
-   &lt;a href=&#34;#start_info_file&#34;&gt;&lt;code&gt;start_info_file&lt;/code&gt;&lt;/a&gt;
-   &lt;a href=&#34;#start_next_part&#34;&gt;&lt;code&gt;start_next_part&lt;/code&gt;&lt;/a&gt;
-   &lt;a href=&#34;#read_next_node&#34;&gt;&lt;code&gt;read_next_node&lt;/code&gt;&lt;/a&gt;
-   &lt;a href=&#34;#looking%20for%20the%20menu&#34;&gt;Looking for the menu&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;#putting%20it%20all%20together&#34;&gt;Putting It All Together&lt;/a&gt;
&lt;a href=&#34;#red%20flags&#34;&gt;Red Flags&lt;/a&gt;
-   &lt;a href=&#34;#don&#39;t%20repeat%20code&#34;&gt;Don&amp;rsquo;t Repeat Code&lt;/a&gt;
-   &lt;a href=&#34;#eof()&#34;&gt;&lt;code&gt;eof()&lt;/code&gt;&lt;/a&gt;
-   &lt;a href=&#34;#return%200%20and%20return%20undef&#34;&gt;&lt;code&gt;return 0&lt;/code&gt; and &lt;code&gt;return undef&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;#brief%20confession&#34;&gt;Brief Confession&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-what-s-wrong-with-this-picture-what-s-wrong-with-this-picture-span&#34;&gt;&lt;span id=&#34;what&#39;s wrong with this picture&#34;&gt;What&amp;rsquo;s wrong with this picture?&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Once again I&amp;rsquo;m going to have a look at a program written by a Perl beginner and see what I can do to improve it.&lt;/p&gt;

&lt;p&gt;This month&amp;rsquo;s program comes from a very old Usenet post. It was posted seven years ago - on Nov. 12, 1993, to be exact - on the &lt;code&gt;comp.lang.perl&lt;/code&gt; newsgroup. (At that time &lt;code&gt;comp.lang.perl.misc&lt;/code&gt; had not yet been created.)&lt;/p&gt;

&lt;p&gt;The program is a library of code for reading GNU ``info&amp;rdquo; files. Info files are a form of structured documentation used by the GNU project. If you use the emacs editor, you can browse info files by using the &lt;code&gt;C-h i&lt;/code&gt; command, for example. An info file is made up of many &lt;em&gt;nodes&lt;/em&gt;, each containing information about a certain topic. The nodes are arranged in a tree structure. Each node has a header with some meta-information; one item recorded in the header of each node is the name of that node&amp;rsquo;s parent in the documentation tree. Most nodes also have a menu of their child nodes. Each node also has pointers to the following and preceding nodes so that you can read through all the nodes in order.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-the-interface-the-interface-span&#34;&gt;&lt;span id=&#34;the interface&#34;&gt;The Interface&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The code we&amp;rsquo;ll see has functions for opening info files and for reading in nodes and parsing the information in their headers and menus. But before I start discussing the code, I&amp;rsquo;ll show the documentation. Here it is, copied directly from that 7-year-old Usenet posting, typos and all:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    To use the functions:  Call



            &amp;amp;open_info_file(INFO_FILENAME);


    to open the filehandle `INFO&#39; to the named info file.
    Then call


            &amp;amp;get_next_node;


    repeatedly to read the next node in the info file; variables
            $info_file
            $info_node
            $info_prev
            $info_next
            $info_up


    are set if the corresponding fields appear in the node&#39;s
    header, and if the node has a menu, it is loaded into
    %info_menu.  When `get_next-node&#39; returns false, you have
    reached end-of-file or there has been an error.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Right away, we can see a major problem. The code is supposed to be a library of utility functions. But the only communication between the library and the main program is through a series of global variables with names like &lt;code&gt;$info_up&lt;/code&gt;. This, of course, is terrible style. The functions cannot be used in any program that happens to have a variable named &lt;code&gt;$info_up&lt;/code&gt;, and if you do use it in such a program, you can introduce bizarre, hard-to-find bugs that result from the way the library smashes whatever value that variable had before. The library might even interfere with itself! If you had something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        &amp;amp;get_next_node;
        foo();
        print $info_node;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then you might not get the results you expect. If &lt;code&gt;foo()&lt;/code&gt; happens to &lt;em&gt;also&lt;/em&gt; call &lt;code&gt;get_next_node&lt;/code&gt;, it will discard the value of &lt;code&gt;$info_node&lt;/code&gt; that the main code was planning to print.&lt;/p&gt;

&lt;p&gt;These are the types of problems that functions and local variables were intended to solve. In this case, it&amp;rsquo;s easy to solve the problems: Just have &lt;code&gt;get_next_node&lt;/code&gt; return a list of the node information, instead of setting a bunch of hardwired global variables. If the caller of the function wants to set the variables itself, it is still free to do that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        %next_node = &amp;amp;get_next_node;
        ($info_file, $info_node, $info_prev, $info_next, $info_up)
            = @next_node{qw(File Node Prev Next Up)};
        %info_menu = %{$next_node{Menu}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or not:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        my (%node) = &amp;amp;get_next_node;
        my ($next) = $node{Next};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If for some reason the caller of &lt;code&gt;get_next_node&lt;/code&gt; &lt;em&gt;likes&lt;/em&gt; the global variables, they can still have the original interface:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        sub get_next_node_orig {
          my %next_node = &amp;amp;get_next_node;
          ($info_file, $info_node, $info_prev, $info_next, $info_up)
              = @next_node{qw(File Node Prev Next Up)};
          %info_menu = %{$next_node{Menu}}
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This shows that no functionality has been lost; it is just as powerful to return a list of values as it is to set the global variables directly.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-the-code-the-code-span&#34;&gt;&lt;span id=&#34;the code&#34;&gt;The Code&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Now we&amp;rsquo;ll see the code itself. &lt;a href=&#34;http://localhost:1313/media/_pub_2000_11_repair3/info.pl&#34;&gt;The entire program is available here&lt;/a&gt;. We will be looking at one part at a time.&lt;/p&gt;

&lt;h4 id=&#34;span-id-open-info-file-open-info-file-span&#34;&gt;&lt;span id=&#34;open_info_file&#34;&gt;&lt;code&gt;open_info_file&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The first function that the user calls is the &lt;code&gt;open_info_file&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    83  sub open_info_file {
    84      ($info_filename) = @_;
    85      (open(INFO, &amp;quot;$info_filename&amp;quot;)) 
          || die &amp;quot;Couldn&#39;t open $info_filename: $!&amp;quot;;
    86      return &amp;amp;start_info_file;
    87  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before I discuss the design problems here, there&amp;rsquo;s a minor syntactic issue: The quotation marks around &lt;code&gt;&amp;quot;$info_filename&amp;quot;&lt;/code&gt; are useless. Perl uses the &lt;code&gt;&amp;quot;...&amp;quot;&lt;/code&gt; notation to say ``Construct a string.&amp;rdquo; But &lt;code&gt;$info_filename&lt;/code&gt; is &lt;em&gt;already&lt;/em&gt; a string, so making it into a string is at best a waste of time. Moreover, the extra quotation marks can sometimes cause subtle bugs. Consider this innocuous-looking code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        my ($x) = @_;
        do_something(&amp;quot;$x&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If &lt;code&gt;$x&lt;/code&gt; was a string, this still works. But if &lt;code&gt;$x&lt;/code&gt; was a &lt;em&gt;reference&lt;/em&gt;, it probably fails. Why? Because &lt;code&gt;&amp;quot;$x&amp;quot;&lt;/code&gt; constructs a string that looks like a reference but isn&amp;rsquo;t, and if &lt;code&gt;do_something&lt;/code&gt; is expecting a reference, it will be disappointed. Such errors can be hard to debug, because the string that &lt;code&gt;do_something&lt;/code&gt; gets looks like a reference when you print it out. The &lt;code&gt;use strict &#39;refs&#39;&lt;/code&gt; pragma was designed to catch exactly this error. With &lt;code&gt;use strict &#39;refs&#39;&lt;/code&gt; in scope, &lt;code&gt;do_something&lt;/code&gt; will probably raise an error like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Can&#39;t use string (&amp;quot;SCALAR(0x8149bbc)&amp;quot;) as an ARRAY ref...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Without &lt;code&gt;use strict &#39;refs&#39;&lt;/code&gt;, you get a subtle and silent bug.&lt;/p&gt;

&lt;p&gt;But back to the code. &lt;code&gt;open_info_file&lt;/code&gt; calls &lt;code&gt;die&lt;/code&gt; if it can&amp;rsquo;t open the specified file for any reason. It would probably be more convenient and consistent to have it simply return a failure code in this case; this is what it does if the &lt;code&gt;open&lt;/code&gt; succeeds, but then &lt;code&gt;start_next_part&lt;/code&gt; fails. It&amp;rsquo;s usually easier for the calling code to deal with a simple error return than with an exception, all the more so in 1993, when Perl didn&amp;rsquo;t have exception handling. I would rewrite the function like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        sub open_info_file {
            ($info_filename) = @_;
            open(INFO, $info_filename) || return;
            return start_info_file();
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I also got rid of some superfluous parentheses and changed the 1993 &lt;code&gt;&amp;amp;function&lt;/code&gt; syntax to a more modern &lt;code&gt;function()&lt;/code&gt; syntax. It&amp;rsquo;s tempting to try to make &lt;code&gt;$info_filename&lt;/code&gt; into a private variable, but it turns out that other functions need to see it later, so the best we can do is make it a file-scoped lexical, private to the library, but shared among all the functions in the library.&lt;/p&gt;

&lt;p&gt;Finally, a design issue: The filehandle name &lt;code&gt;INFO&lt;/code&gt; is hard-wired into the function. Since filehandle names are global variables, this is best avoided for the same reason that we wanted to get rid of the &lt;code&gt;$info_node&lt;/code&gt; variable earlier: If some other part of the program happens to have a filehandle named &lt;code&gt;INFO&lt;/code&gt;, it&amp;rsquo;s going to be very surprised to find it suddenly attached to a new file.&lt;/p&gt;

&lt;p&gt;There are a number of ways to solve this. The best one available in Perl 4 is to have the caller pass in the filehandle it wants to use, as an argument to &lt;code&gt;open_info_file&lt;/code&gt;. Then the call is effectively using the filehandle as an object. In this case, however, this doesn&amp;rsquo;t work as well as we&amp;rsquo;d like, because, as we&amp;rsquo;ll see later, the library needs to be able to associate the name of the file with the filehandle. In the original library, this was easy, because the filename was always stored in the global variable &lt;code&gt;$info_filename&lt;/code&gt; and the filehandle was always &lt;code&gt;INFO&lt;/code&gt;. The downside of this simple solution is the library couldn&amp;rsquo;t have two info files open at once. There are solutions to this in Perl 4, but they&amp;rsquo;re only of interest to Perl 4 programmers, so I won&amp;rsquo;t go into detail.&lt;/p&gt;

&lt;p&gt;The solution in Perl 5 is to use an &lt;em&gt;object&lt;/em&gt; to represent an open info file. Whenever the caller wants to operate on the file, it passes the object into the library as an argument. The object can carry around the open filehandle and the filename. Since the data inside the object is private, it doesn&amp;rsquo;t interfere with any other data in the program. The caller can have several files open at once, and distinguish between them because each file is represented by its own object.&lt;/p&gt;

&lt;p&gt;To make this library into an object-oriented class only requires a few small changes. We add&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        package Info_File;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;at the top, and rewrite &lt;code&gt;open_info_file&lt;/code&gt; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub open_info_file {
        my ($class, $info_filename) = @_;
        my $fh = new FileHandle;        
        open($fh, $info_filename) || return;
        my $object = { FH =&amp;gt; $fh, NAME =&amp;gt; $info_filename };
        bless $object =&amp;gt; $class;
        return unless $object-&amp;gt;start_info_file;            
        return $object;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now invoke the function like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     $object = Info_File-&amp;gt;new(&#39;camel.info&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;new FileHandle&lt;/code&gt; line constructs a fresh new filehandle. The next line opens the filehandle, as usual. The line&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     my $object = { FH =&amp;gt; $fh, NAME =&amp;gt; $info_filename };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;constructs the object, which is simply a hash. The object contains all the information that the library will need to use in order to deal with the info file - in this case, the open filehandle and the original filename. The &lt;code&gt;bless&lt;/code&gt; function converts the hash into a full-fledged object of the &lt;code&gt;Info_File&lt;/code&gt; class. Finally, the&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        $object-&amp;gt;start_info_file;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;invokes the &lt;code&gt;start_info_file&lt;/code&gt; function with &lt;code&gt;$object&lt;/code&gt; as its argument, just like calling &lt;code&gt;start_info_file($object)&lt;/code&gt;. The special ``arrow&amp;rdquo; syntax for objects is enabled by the &lt;code&gt;bless&lt;/code&gt; on the previous line. This notation indicates a &lt;em&gt;method call&lt;/em&gt; on the object; &lt;code&gt;start_info_file&lt;/code&gt; is the &lt;em&gt;method&lt;/em&gt;. A method is just an ordinary subroutine. A method call on an object is like any other subroutine call, except that the object itself is passed as an argument to the subroutine.&lt;/p&gt;

&lt;p&gt;That was a lot of space to spend on one three-line function, but many of the same issues are going to pop up over and over, and it&amp;rsquo;s good to see them in a simple context.&lt;/p&gt;

&lt;h3 id=&#34;span-id-start-info-file-start-info-file-span&#34;&gt;&lt;span id=&#34;start_info_file&#34;&gt;&lt;code&gt;start_info_file&lt;/code&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;    47  # Discard commentary before first node of info file
    48  sub start_info_file {
    49      $_ = &amp;lt;INFO&amp;gt; until (/^\037/ || eof(INFO));
    50      return &amp;amp;start_next_part if (eof(INFO)) ;
    51      return 1;
    52  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An info file typically has a preamble before the first node, usually containing a copyright notice and a license. When the user opens an info file, the library needs to skip this preamble to get to the nodes, which are the parts of interest. That is what &lt;code&gt;start_info_file&lt;/code&gt; does. The preamble is separated from the first node by a line that begins with the obscure &lt;code&gt;\037&lt;/code&gt; character, which is control-underscore. The function will read through the file line by line, looking for the first line that begins with the obscure character. If it finds such a line, it immediately returns success. Otherwise, it moves on to the next ``part,&amp;rdquo; which I&amp;rsquo;ll explain later.&lt;/p&gt;

&lt;p&gt;As I explained in earlier articles, a ``red flag&amp;rdquo; is an immediate warning sign that you have done something wrong. Use of the &lt;code&gt;eof()&lt;/code&gt; function is one of the clearest and brightest red flags in Perl. It is almost always a mistake to use &lt;code&gt;eof()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The problem with &lt;code&gt;eof()&lt;/code&gt; is that it tries to see into the future, whether the &lt;em&gt;next&lt;/em&gt; read from the filehandle will return an end-of-file condition. It&amp;rsquo;s impossible to actually see the future, so what it really does is try to read some data. If there isn&amp;rsquo;t any, it reports that the next read will also report end-of-file. If not, it has to put back the data that it just read. This can cause weird problems, because &lt;code&gt;eof()&lt;/code&gt; is reading extra data that you might not have meant to read.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;eof()&lt;/code&gt; is one of those functions like &lt;code&gt;goto&lt;/code&gt; that looks useful at first, but then it turns out that there is almost always a better way to accomplish the same thing. In this case, the code is more straightforward and idiomatic like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub start_info_file {
        while (&amp;lt;INFO&amp;gt;) {
          return 1  if /^\037/;
        }
        &amp;amp;start_next_part;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perl will automatically exit the &lt;code&gt;while&lt;/code&gt; loop when it reaches the end of the file, and in that case we can unconditionally call &lt;code&gt;start_next_part&lt;/code&gt;. Inside the loop, we examine the current line to see whether it is the separator, and return success if it is. The assignment to &lt;code&gt;$_&lt;/code&gt; and the check for end-of-file are now all implicit.&lt;/p&gt;

&lt;p&gt;In the object-oriented style, &lt;code&gt;start_info_file&lt;/code&gt; expects to get an object, originally constructed by &lt;code&gt;open_info_file&lt;/code&gt;, as its argument. This object will contain the filehandle that the function will read from in place of &lt;code&gt;INFO&lt;/code&gt;. The rewriting into OO style is straightforward:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub start_info_file {
        my ($object) = @_;
        my $fh = $object-&amp;gt;{FH};
        while (&amp;lt;$fh&amp;gt;) {
          return 1 if /^\037/;
        }
        $object-&amp;gt;start_next_part;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we extract the filehandle from the object by asking for &lt;code&gt;$object-&amp;gt;{$fh}&lt;/code&gt;, and then use the filehandle &lt;code&gt;$fh&lt;/code&gt; in place of &lt;code&gt;INFO&lt;/code&gt;. The call to &lt;code&gt;start_next_part&lt;/code&gt; changes into a method call on the object, which means that the object is implicitly passed to the &lt;code&gt;start_next_part&lt;/code&gt; function so that &lt;code&gt;start_next_part&lt;/code&gt; &lt;em&gt;also&lt;/em&gt; has access to the object, including the filehandle buried inside it.&lt;/p&gt;

&lt;h3 id=&#34;span-id-start-next-part-start-next-part-span&#34;&gt;&lt;span id=&#34;start_next_part&#34;&gt;&lt;code&gt;start_next_part&lt;/code&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;I promised to explain what &lt;code&gt;start_next_part&lt;/code&gt; does, and now we&amp;rsquo;re there. An info file is not a single file; it might be split into several separate files, each containing some of the nodes. If the main info file is named &lt;code&gt;camel.info&lt;/code&gt;, there might be additional nodes in the files &lt;code&gt;camel.info-1&lt;/code&gt;, &lt;code&gt;camel.info-2&lt;/code&gt; and so on. This means that when we get to the end of an info file we are not finished; we have to check to see whether it continues in a different file. &lt;code&gt;start_next_part&lt;/code&gt; does this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    54  # Look for next part of multi-part info file.  Return 0
    55  # (normal failure) if it isn&#39;t there---that just means
    56  # we ran out of parts.  die on some other kind of failure.
    57  sub start_next_part {
    58      local($path, $basename, $ext);
    59      if ($info_filename =~ /\//) {
    60          ($path, $basename) 
            = ( $info_filename =~ /^(.*)\/(.*)$/ );
    61      } else {
    62          $basename = $info_filename;
    63          $path = &amp;quot;&amp;quot;;
    64      }
    65      if ($basename =~ /-\d*$/) {
    66          ($basename, $ext) 
            = ($basename =~ /^([^-]*)-(\d*)$/);
    67      } else {
    68          $ext = 0;
    69      }
    70      $ext++;
    71      $info_filename = &amp;quot;$path/$basename-$ext&amp;quot;;
    72      close(INFO);
    73      if (! (open(INFO, &amp;quot;$info_filename&amp;quot;)) ) {
    74          if ($! eq &amp;quot;No such file or directory&amp;quot;) {
    75              return 0;
    76          } else {
    77              die &amp;quot;Couldn&#39;t open $info_filename: $!&amp;quot;;
    78          }
    79      }
    80      return &amp;amp;start_info_file;
    81  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The main point of this code is to take a filename like &lt;code&gt;/usr/info/camel.info-3&lt;/code&gt; and change it into &lt;code&gt;/usr/info/camel.info-4&lt;/code&gt;. It has to handle a special case: &lt;code&gt;/usr/info/camel.info&lt;/code&gt; must become &lt;code&gt;/usr/info/camel.info-1&lt;/code&gt;. After computing the new filename, it tries to open the next part of the info file. If successful, it calls &lt;code&gt;start_info_file&lt;/code&gt; to skip the preamble in the new part.&lt;/p&gt;

&lt;p&gt;The first thing to notice here is that the function is performing more work than it needs to. It carefully separates the filename into a directory name and a base name, typically &lt;code&gt;/usr/info&lt;/code&gt; and &lt;code&gt;camel.info-3&lt;/code&gt;. But this step is unnecessary, so let&amp;rsquo;s eliminate it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub start_next_part {
        local($name, $ext);
        if ($info_filename =~ /-\d*$/) {
            ($name, $ext) 
                = ($info_filename =~ /^([^-]*)-(\d*)$/);
        } else {
            $ext = 0;
        }
        $ext++;
        $info_filename = &amp;quot;$name-$ext&amp;quot;;
        # ... no more changes ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This immediately reduces the size of the function by 25 percent. Now we notice that the two pattern matches that remain are almost the same. This is the red flag of all red flags: Any time a program does something twice, look to see whether you can get away with doing it only once. Sometimes you can&amp;rsquo;t. This time, we can:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub start_next_part {
        local($name, $ext);
        if ($info_filename =~ /^([^-]*)-(\d*)$/) {
            ($name, $ext) = ($1, $2);
        } else {
            $name = $info_filename; $ext = 0;
        }
        $ext++;
        $info_filename = &amp;quot;$name-$ext&amp;quot;;
        # ... no more changes ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is somewhat simpler, and it paves the way for a big improvement: The &lt;code&gt;$name&lt;/code&gt; variable is superfluous, because its only purpose is to hold an intermediate result. The real variable of interest is &lt;code&gt;$info_filename&lt;/code&gt;. &lt;code&gt;$name&lt;/code&gt; is what I call a &lt;em&gt;synthetic variable&lt;/em&gt;: It&amp;rsquo;s an artifact of the way we solve the problem, and is inessential to the problem itself. In this case, it&amp;rsquo;s easy to eliminate:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub start_next_part {
        if ($info_filename =~ /^([^-]*)-(\d*)$/) {
            $info_filename = $1 . &#39;-&#39; . ($2 + 1);
        } else {
            $info_filename .= &#39;-1&#39;;
        }
        # ... no more changes ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the pattern matches, then &lt;code&gt;$1&lt;/code&gt; contains the base name, typically &lt;code&gt;/usr/info/camel.info&lt;/code&gt;, and &lt;code&gt;$2&lt;/code&gt; contains the numeric suffix, typically &lt;code&gt;3&lt;/code&gt;. There is no need to copy these into named variables before using them; we can construct the new filename, &lt;code&gt;/usr/info/camel.info-4&lt;/code&gt; directly from &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt;. If the pattern doesn&amp;rsquo;t match, we construct the new file name by appending &lt;code&gt;-1&lt;/code&gt; to the old file name; this turns &lt;code&gt;/usr/info/camel.info&lt;/code&gt; into &lt;code&gt;/usr/info/camel.info-1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;That takes care of the top half of the function; now let&amp;rsquo;s look at the bottom half:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub start_next_part {
        if ($info_filename =~ /^([^-]*)-(\d*)$/) {
            $info_filename = $1 . &#39;-&#39; . ($2 + 1);
        } else {
            $info_filename .= &#39;-1&#39;;
        }
        close(INFO);
        if (! (open(INFO, &amp;quot;$info_filename&amp;quot;)) ) {
            if ($! eq &amp;quot;No such file or directory&amp;quot;) {
                return 0;
            } else {
                die &amp;quot;Couldn&#39;t open $info_filename: $!&amp;quot;;
            }
        }
        return &amp;amp;start_info_file;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;close(INFO)&lt;/code&gt; is unnecessary, because the &lt;code&gt;open&lt;/code&gt; on the following line will perform an implicit close. If the file can&amp;rsquo;t be opened the function looks to find out why. If the reason is that the next part doesn&amp;rsquo;t exist, then we&amp;rsquo;re really at the end, and it quietly returns failure, but if there was some other sort of error, it aborts. In keeping with our change to &lt;code&gt;open_info_file&lt;/code&gt;, we will eliminate the &lt;code&gt;die&lt;/code&gt; and let the caller die itself, if that is desirable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub start_next_part {
        if ($info_filename =~ /^([^-]*)-(\d*)$/) {
            $info_filename = $1 . &#39;-&#39; . ($2 + 1);
        } else {
            $info_filename .= &#39;-1&#39;;
        }
        return unless open(INFO, $info_filename);
        return &amp;amp;start_info_file;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I made a few other minor changes here: Superfluous quotation marks around &lt;code&gt;$info_filename&lt;/code&gt; are gone, and &lt;code&gt;if !&lt;/code&gt; has turned into &lt;code&gt;unless&lt;/code&gt;. Also, I replaced &lt;code&gt;return 0&lt;/code&gt; with &lt;code&gt;return&lt;/code&gt;. &lt;code&gt;return 0&lt;/code&gt; and &lt;code&gt;return undef&lt;/code&gt; are red flags: They are attempts to make a function that returns a false value. But if the function is invoked in a list context, return values of &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;undef&lt;/code&gt; are interpreted as true, not false, because they are one-element lists, and the only false lists are empty ones:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub false {
      return 0;
    }

    @a = false();
    if (@a) {          
      print &amp;quot;ooops!\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The correct way for a function to return a boolean false value in Perl is almost always a simple &lt;code&gt;return&lt;/code&gt; as we have here. In scalar context, this returns an undefined value; in list context, it returns an empty list.&lt;/p&gt;

&lt;p&gt;The function has gone from 20 lines to 7. Refitting it for object-oriented style does not make it much bigger:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub start_next_part {
        my ($object) = @_;
        my $info_filename = $object-&amp;gt;{NAME};
        if ($info_filename =~ /^([^-]*)-(\d*)$/) {
            $info_filename = $1 . &#39;-&#39; . ($2 + 1);
        } else {
            $info_filename .= &#39;-1&#39;;
        }
        my $fh = $object-&amp;gt;{FH};
        return unless open($fh, $info_filename);
        $object-&amp;gt;{NAME} = $info_filename;         # ***
        return $object-&amp;gt;start_info_file;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we extract the info file&amp;rsquo;s filename from the object using &lt;code&gt;$object-&amp;gt;{NAME}&lt;/code&gt;, which we originally set up back in &lt;code&gt;open_info_file&lt;/code&gt;. We also extract the filehandle from the object using &lt;code&gt;$object-&amp;gt;{FH}&lt;/code&gt; as we did in &lt;code&gt;start_info_file&lt;/code&gt;. If we successfully open the new file, we store the changed filename back into the object, for next time; this occurs on the line marked &lt;code&gt;***&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-read-next-node-read-next-node-span&#34;&gt;&lt;span id=&#34;read_next_node&#34;&gt;&lt;code&gt;read_next_node&lt;/code&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Finally, we get to the heart of the library. &lt;code&gt;read_next_node&lt;/code&gt; actually reads a nodeful of information and returns it to the caller. (The first thing to notice is that the documentation calls this function &lt;code&gt;get_next_node&lt;/code&gt;, which is wrong. But that&amp;rsquo;s an easy fix.)&lt;/p&gt;

&lt;p&gt;As far as this function is concerned, the node has three parts. The first line is the header of the node, which contains the name of the node; pointers to the previous and next nodes; and other metainformation. Then there&amp;rsquo;s a long stretch of text, which is the documentation that the node was intended to contain. Somewhere near the bottom of the text is a menu of pointers to other nodes. &lt;code&gt;read_next_node&lt;/code&gt; is interested in the header line and the menu. It has three sections: One section to handle the header line, one section to skip the following text until it sees the menu and one section to parse the menu. We&amp;rsquo;ll deal with these one at a time.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     1  # Read next node into global variables.  Assumes that file 
     2  # pointer is positioned at the header line that starts a 
     3  # node.  Leaves file pointer positioned at header line of 
     4  # next node. Programmer: note that nodes are separated by 
     5  # a &amp;quot;\n\037\n&amp;quot; sequence.  Reutrn true on 
      success, false on failure
     6  sub read_next_node {
     7      undef %info_menu;
     8      $_ = &amp;lt;INFO&amp;gt;;                # Header line
     9      if (eof(INFO)) {
    10          return &amp;amp;start_next_part &amp;amp;&amp;amp; &amp;amp;read_next_node;
    11      }
    12  
    13      ($info_file) = /File:\s*([^,]*)/;
    14      ($info_node) = /Node:\s*([^,]*)/;
    15      ($info_prev) = /Prev:\s*([^,]*)/;
    16      ($info_next) = /Next:\s*([^,]*)/;
    17      ($info_up)   = /Up:\s*([^,]*)/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not much needs to change here. The &lt;code&gt;undef %info_menu&lt;/code&gt; was an appropriate initialization when &lt;code&gt;%info_menu&lt;/code&gt; was a global variable, but our function isn&amp;rsquo;t going to use global variables; it&amp;rsquo;s going to return the menu information as part of its return list, so we replace this line with &lt;code&gt;my %info_menu&lt;/code&gt;. The &lt;code&gt;eof()&lt;/code&gt; test is a red flag again; it&amp;rsquo;s probably more straightforward to simply check whether &lt;code&gt;$_&lt;/code&gt; is defined. If it&amp;rsquo;s undefined, then the function has reached the end of the file, and needs to try to open the next part. If that succeeds, then it calls itself recursively to read the first node from the new part. The &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; used here to sequence those two operations is concise, if a little peculiar. Unfortunately, it won&amp;rsquo;t work any more now that &lt;code&gt;read_next_node&lt;/code&gt; returns a list of data, because &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; always evaluates its arguments in scalar context. This section of the code needs to change to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        $_ = &amp;lt;INFO&amp;gt;;                # Header line
        if (! defined $_) {
            return unless  &amp;amp;start_next_part;      
            return &amp;amp;read_next_node;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The recursive call might be considered a little strange, because it&amp;rsquo;s essentially performing a &lt;code&gt;goto&lt;/code&gt; back up to the top of the function, and some people might express that with a simple &lt;code&gt;while&lt;/code&gt; loop. But it&amp;rsquo;s not really obvious that that would be clearer, so I decided to leave the recursive call in.&lt;/p&gt;

&lt;p&gt;The subsequent lines extract parts of the header into the global variables &lt;code&gt;$info_file&lt;/code&gt;, &lt;code&gt;$info_node&lt;/code&gt; and so on. Since we need to make these items into a data structure to be returned from the function, rather than a set of global variables, it&amp;rsquo;s natural to try this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        ($header{File}) = /File:\s*([^,]*)/;
        ($header{Node}) = /Node:\s*([^,]*)/;
        ($header{Prev}) = /Prev:\s*([^,]*)/;
        ($header{Next}) = /Next:\s*([^,]*)/;
        ($header{Up})   =   /Up:\s*([^,]*)/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works, but as I mentioned before, repeated code is the biggest red flag of all. The similarity of these five lines suggests that we should try a loop instead:
            for my $label (qw(File Node Prev Next Up)) {
              ($header{$label}) = /$label:\s&lt;em&gt;([^,]&lt;/em&gt;)/;
            }&lt;/p&gt;

&lt;p&gt;Here five lines have become two. The downside, however, is that Perl has to recompile the pattern five times for each node, because the value of &lt;code&gt;$label&lt;/code&gt; keeps changing. There are three things we can do to deal with this. We can ignore it, we can apply the &lt;code&gt;qr//&lt;/code&gt; operator to precompile the patterns, or we can try to make the five variable patterns into a single constant pattern. My vote here, as for most questions of micro-optimization, is to ignore it unless it proves to be a real problem. The &lt;code&gt;qr//&lt;/code&gt; solution will be an adequate fallback in that case.&lt;/p&gt;

&lt;p&gt;I did also consider combining them into one pattern, but that turns into a disaster:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ($file, $node, $prev, $next, $up) = 
      /File:\s*([^,]*),\s*Node:\s*([^,]*),\s*
       Next:\s*([^,]*),\s*Prev:\s*([^,]*),\s*
       Up:\s*([^,]*)/x;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Actually, it&amp;rsquo;s worse than that, because some of the five items might be missing from the header line, so we must make each part optional:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ($file, $node, $prev, $next, $up) = 
      /(?:File:\s*([^,]*),)?\s*(?:Node:\s*([^,]*),)?\s*
       (?:Next:\s*([^,]*),)?\s*(?:Prev:\s*([^,]*),)?\s*
       (?:Up:\s*([^,]*))?/x;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Actually, it&amp;rsquo;s even worse, because the original author was programming in Perl 4 and didn&amp;rsquo;t have &lt;code&gt;(?:...)&lt;/code&gt; or &lt;code&gt;/x&lt;/code&gt;. So that tactic really didn&amp;rsquo;t work out.&lt;/p&gt;

&lt;p&gt;This brings up an important point that I don&amp;rsquo;t always emphasize as much as I should: It&amp;rsquo;s not always obvious what tactics are best until you have tried them. When I write these articles, I make false starts. I rewrite the code one way, and discover that there are unexpected problems and the gains aren&amp;rsquo;t as big as I thought they were. Then, I try another way and see if it looks better. Sometimes it turns out I was wrong, and the original code wins, as it did in this case.&lt;/p&gt;

&lt;p&gt;When you&amp;rsquo;re writing your own code, it won&amp;rsquo;t always be clear how best to proceed. Try it both ways and see which looks better, then throw away the one you don&amp;rsquo;t like as much.&lt;/p&gt;

&lt;p&gt;In this article, I had originally planned to rework the library into something that would still have functioned under Perl 4. I wrote a lot of text explaining how to do this. But it turned out that the only good solution was objects, so I did it over, and that&amp;rsquo;s what you see.&lt;/p&gt;

&lt;p&gt;The moral: Never be afraid to do it over.&lt;/p&gt;

&lt;h3 id=&#34;span-id-looking-for-the-menu-looking-for-the-menu-span&#34;&gt;&lt;span id=&#34;looking for the menu&#34;&gt;Looking for the menu&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;OK, end of digression. The function has processed the header line; now it needs to skip the intervening text until it finds the menu part of the node:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    19      $_ = &amp;lt;INFO&amp;gt; until /^(\* Menu:|\037)/ || eof(INFO);
    20      if (eof(INFO)) {
    21          return &amp;amp;start_next_part;
    22      } elsif (/^\037/) { 
    23          return 1; # end of node, so return success.
    24      }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The menu follows a line labeled &lt;code&gt;* Menu:&lt;/code&gt;. If the function sees the end of the node or the end of the file before it sees &lt;code&gt;* Menu&lt;/code&gt;, then the node has no menu. There&amp;rsquo;s a bug here: The function should return immediately at the end of the node, regardless of whether it is also the end of the file. As originally written, it calls &lt;code&gt;start_next_part&lt;/code&gt; at the end of the file, which might fail (if the current node was the last one) and reports the failure back to the caller when it should have reported success. Fixing the bug and eliminating &lt;code&gt;eof()&lt;/code&gt; yields this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $_ = &amp;lt;INFO&amp;gt; until !defined($_) || /^(\* Menu:|\037)/;
    return @header if !defined($_) || /^\037/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The repeated tests bothered me there, but the best alternative formulation I could come up with was:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    while (&amp;lt;INFO&amp;gt;) {
      last if /^\* Menu:/;
      return %header if /^\037/;
    }
    return %header unless defined $_;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I asked around, and Simon Cozens suggested&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    do { 
      $_ = &amp;lt;INFO&amp;gt;; 
      return %header if /^\037/ || ! defined $_ 
    } until /^\* Menu:/ ;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I think I like this best, because it makes the &lt;code&gt;/^\* Menu:/&lt;/code&gt; into the main termination condition, which is as it should be. On the other hand, &lt;code&gt;do...until&lt;/code&gt; is unusual, and you don&amp;rsquo;t get the implicit read into &lt;code&gt;$_&lt;/code&gt;. But four versions of the same code is plenty, so let&amp;rsquo;s move on.&lt;/p&gt;

&lt;p&gt;Finally our function is ready to read the menu. A typical menu looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        * Menu:

        * Numerical types::
        * Exactness::
        * Implementation restrictions::
        * Syntax of numerical constants::
        * Numerical operations::
        * Numerical input and output::
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each item has a title (which is displayed to the user) and a node name (which is the node that the user visits next if they select that menu item). If the title and node name are different, the menu item looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        * The title:       The node name.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If they&amp;rsquo;re the same (as is often the case) the menu item ends in &lt;code&gt;::&lt;/code&gt; as in the examples above. The menu-reading code has to handle both cases:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    27      local($key, $ref);
    28      while (&amp;lt;INFO&amp;gt;) {    
    29          return 1 if /^\037/;    # end of node, success.
    30          next unless /^\* \S/;   # skip non-menu-items
    31          if (/^\* ([^:]*)::/) {  # menu item ends with ::
    32              $key = $ref = $1;
    33          } elsif (/^\* ([^:]*):\s*([^.]*)[.]/) {
    34              ($key, $ref) = ($1, $2);
    35          } else {
    36              print STDERR &amp;quot;Couldn&#39;t parse menu item\n\t$_&amp;quot;;
    37              next;
    38          }
    39          $info_menu{$key} = $ref;
    40      }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I think this code is lovely. I would do only two things differently. First, I would change the error message to include the filename and line number of the malformed menu entry. Perl&amp;rsquo;s built-in &lt;code&gt;$.&lt;/code&gt; variable makes this easy, and the current behavior makes it too difficult for the programmer to locate the source of the problem. And second, instead of &lt;code&gt;return&lt;/code&gt;ing directly out of the loop, I would use &lt;code&gt;last&lt;/code&gt;, because the return value &lt;code&gt;(%header, Menu =&amp;gt; \%menu)&lt;/code&gt; is rather complicated and the code below the loop will have to return the same thing anyway.&lt;/p&gt;

&lt;p&gt;In the original prgram, that &lt;code&gt;return&lt;/code&gt; line calls &lt;code&gt;start_info_file&lt;/code&gt; again if the function reads to the end of the current part while still reading the menu. This isn&amp;rsquo;t correct; it should simply return success and let the next call to &lt;code&gt;read_next_node&lt;/code&gt; worry about opening the new part.&lt;/p&gt;

&lt;p&gt;The rewritten version of &lt;code&gt;read_next_node&lt;/code&gt; looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub read_next_node {
        $_ = &amp;lt;INFO&amp;gt;;                # Header line
        if (! defined $_) {
            return unless  &amp;amp;start_next_part;      
            return &amp;amp;read_next_node;
        }

        my (%header, %menu);
        for my $label (qw(File Node Prev Next Up)) {
          ($header{$label}) = /$label:\s*([^,]*)/;
        }

        do { 
          $_ = &amp;lt;INFO&amp;gt;; 
          return %header if /^\037/ || ! defined $_ 
        } until /^\* Menu:/ ;



        while (&amp;lt;INFO&amp;gt;) {    
            my ($key, $ref);
            last if /^\037/;        # end of node
            next unless /^\* \S/;   # skip non-menu-items
            if (/^\* ([^:]*)::/) {  # menu item ends with ::
                $key = $ref = $1;
            } elsif (/^\* ([^:]*):\s*([^.]*)[.]/) {
                ($key, $ref) = ($1, $2);
            } else {
                warn &amp;quot;Couldn&#39;t parse menu item at line $. 
                      of file $info_file_name&amp;quot;;
                next;
            }
            $menu{$key} = $ref;
        }

        return (%header, Menu =&amp;gt; \%menu);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code didn&amp;rsquo;t get shorter this time, but that&amp;rsquo;s because it was pretty good to begin with. After making a few straightforward changes to convert it to object-oriented style, we get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub read_next_node {
        my ($object) = @_;
        my ($fh) = $object-&amp;gt;{FH};
        local $_ = &amp;lt;$fh&amp;gt;;           # Header line
        if (! defined $_) {
            return unless  $object-&amp;gt;start_next_part;      
            return $object-&amp;gt;read_next_node;
        }

        my (%header, %menu);
        for my $label (qw(File Node Prev Next Up)) {
          ($header{$label}) = /$label:\s*([^,]*)/;
        }

        do { 
          $_ = &amp;lt;$fh&amp;gt;; 
          return %header if /^\037/ || ! defined $_ 
        } until /^\* Menu:/ ;

        while (&amp;lt;$fh&amp;gt;) {    
            my ($key, $ref);
            last if /^\037/;        # end of node
            next unless /^\* \S/;   # skip non-menu-items
            if (/^\* ([^:]*)::/) {  # menu item ends with ::
                $key = $ref = $1;
            } elsif (/^\* ([^:]*):\s*([^.]*)[.]/) {
                ($key, $ref) = ($1, $2);
            } else {
                warn &amp;quot;Couldn&#39;t parse menu item at line $. 
                      of file $object-&amp;gt;{NAME}&amp;quot;;
                next;
            }
            $menu{$key} = $ref;
        }

        return (%header, Menu =&amp;gt; \%menu);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2000_11_repair3/Info_File.pm&#34;&gt;The entire object-oriented module is available here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A simple example program that demonstrates the use of the library:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Info_File;
    my $file = shift;
    my $info = Info_File-&amp;gt;open_info_file($file)
      or die &amp;quot;Couldn&#39;t open $file: $!; aborting&amp;quot;;
    while (my %node = $info-&amp;gt;read_next_node) {
      print $node{Node},&amp;quot;\n&amp;quot;;  # print the node name
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-putting-it-all-together-putting-it-all-together-span&#34;&gt;&lt;span id=&#34;putting it all together&#34;&gt;Putting It All Together&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;This time the code hasn&amp;rsquo;t gotten any smaller; it&amp;rsquo;s the same size as it was before. Some parts got smaller, but there was some overhead associated with the conversion to object-oriented style that made the code bigger again.&lt;/p&gt;

&lt;p&gt;But the OO style got us several big wins. The interface got better; the library no longer communicates through global variables and no longer smashes &lt;code&gt;INFO&lt;/code&gt;. It also gained the capability to process two or more info files simultaneously, or the same info file more than once, which is essential if it&amp;rsquo;s to be useful in any large project. Flexibility has increased also: It would require only a few extra lines to provide the ability to search for any node or to seek back to a node by name.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-red-flags-red-flags-span&#34;&gt;&lt;span id=&#34;red flags&#34;&gt;Red Flags&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;A summary of the red flags we saw this time:&lt;/p&gt;

&lt;p&gt;The Cardinal Rule of Computer Programming is that if you wrote the same code twice, you probably did something wrong. At the very least, you may be setting yourself up for a maintenance problem later on when someone changes the code in one place and not in another.&lt;/p&gt;

&lt;p&gt;Programming languages are chock-full of features designed to prevent code duplication from the very lowest levels (features such as &lt;code&gt;$a[3] += $b&lt;/code&gt; instead of &lt;code&gt;$a[3] = $a[3] + $b&lt;/code&gt; to the very highest (features such as DLLs and pipes.) In between these levels are essential features such as subroutines and modules.&lt;/p&gt;

&lt;p&gt;Each time you see you have written the same code more than once, give serious thought to how you might eliminate all but one instance.&lt;/p&gt;

&lt;h4 id=&#34;span-id-eof-eof-span&#34;&gt;&lt;span id=&#34;eof()&#34;&gt;&lt;code&gt;eof()&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The Perl &lt;code&gt;eof()&lt;/code&gt; function is almost always a bad choice. It&amp;rsquo;s typically overused by beginners and by people who have been programming in Pascal for too long.&lt;/p&gt;

&lt;p&gt;Perl returns an unambiguous end-of-file condition by yielding an undefined value. Perl&amp;rsquo;s I/O operators are designed to make it convenient to check for this. The &lt;code&gt;while(&amp;lt;FH&amp;gt;)&lt;/code&gt; construction even does so automatically. Explicit checking of &lt;code&gt;eof()&lt;/code&gt; is almost never required or desirable.&lt;/p&gt;

&lt;h4 id=&#34;span-id-return-0-and-return-undef-return-0-and-return-undef-span&#34;&gt;&lt;span id=&#34;return 0 and return undef&#34;&gt;&lt;code&gt;return 0&lt;/code&gt; and &lt;code&gt;return undef&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;This is often an attempt to return a value that will be perceived by the caller as a Boolean false. But in list context, it will test as true, not false. Unless the function &lt;em&gt;always&lt;/em&gt; returns a single scalar, even in list context, it is usually a better choice to use plain &lt;code&gt;return;&lt;/code&gt; to yield a false value.&lt;/p&gt;

&lt;p&gt;Some programmers write &lt;code&gt;wantarray() ? () : undef&lt;/code&gt;, which does the same thing but is more verbose and confusing.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-brief-confession-brief-confession-span&#34;&gt;&lt;span id=&#34;brief confession&#34;&gt;Brief Confession&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The program discussed in this article was indeed written by a Perl beginner. I wrote it in 1993 when I had only been programming in Perl for a few months. I must have been pleased with it, because it was the first Perl program that I posted in a public forum.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

