<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Io on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/io/</link>
    <description>Recent content in Io on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 11 Mar 2004 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/io/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Simple IO Handling with IO::All</title>
      <link>http://localhost:1313/pub/2004/03/12/ioall.html/</link>
      <pubDate>Thu, 11 Mar 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/03/12/ioall.html/</guid>
      <description>

&lt;p&gt;One of my favorite things about Perl is how flexible it is. When I don&amp;rsquo;t like something about the language, I don&amp;rsquo;t let it get me down. I just change the language!&lt;/p&gt;

&lt;p&gt;The secret to doing this lies in Perl modules. Modules make this easy. Let&amp;rsquo;s say you have a Perl idiom that you use everyday in your programming, but it just seems clumsier than it needs to be. Usually, with a little cleverness, you can simply hide a few hundred lines of code inside a module, thereby turning your 3-line idiom into a 2-line one!&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m joking here, but at the same time I&amp;rsquo;m not joking. While it may seem like a recipe for scratching your itch with a backhoe, if you share your module on CPAN, you end up potentially scratching a million itches simultaneously. So perhaps the backhoe is the appropriate solution. Let me give you an example.&lt;/p&gt;

&lt;h3 id=&#34;span-id-slurp-me-up-scotty-slurp-me-up-scotty-span&#34;&gt;&lt;span id=&#34;Slurp_Me_Up_Scotty&#34;&gt;Slurp Me Up, Scotty&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;One of the most common idioms in my day-to-day programming is to read the contents of a file into a single scalar. This is often referred to by Perl geeks as a &lt;strong&gt;slurp&lt;/strong&gt; operation. Usually it looks something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    open my $file_handle, &#39;./Scotty&#39;
      or die &amp;quot;Scotty can&#39;t be slurped:\n$!&amp;quot;;
    local $/;   # Set input to &amp;quot;slurp&amp;quot; mode.
    my $big_string = &amp;lt;$file_handle&amp;gt;;
    close $file_handle;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So it would seem that slurping is a big deal. I mean, it took me 5 lines of code to do. Five lines is a &lt;strong&gt;lot&lt;/strong&gt; in Perl. Surely, there could be an easier way. If I had my druthers, I would be able to just do this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $big_string &amp;lt;&amp;lt; &#39;./Scotty&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And be done with it. Unfortunately, this doesn&amp;rsquo;t work the way I want it to, even though it is valid (albeit useless) Perl. How do I know it&amp;rsquo;s useless? Perl told me so when I turned on warnings: &amp;ldquo;Useless use of left bitshift (&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;) in void context.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Now even though I could write a source filter to make the above code do what I wanted, it wouldn&amp;rsquo;t be the right approach. Surely there is something just as simple, that uses valid Perl constructs. After thinking about it for a couple hours, I came up with this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $big_string = io(&#39;./Scotty&#39;)-&amp;gt;slurp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Being quite satisfied with my new idiom, I sat down for a few more weeks, and wrote a few hundred lines of code, and hid it in a module called &lt;code&gt;IO::All&lt;/code&gt; and uploaded it to CPAN. Now I can do my 5-line slurp in 1 line. Phew!&lt;/p&gt;

&lt;h3 id=&#34;span-id-extreme-simplicity-extreme-simplicity-span&#34;&gt;&lt;span id=&#34;Extreme_Simplicity&#34;&gt;Extreme Simplicity&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;How on earth could a module to perform the slurp idiom be several hundred lines long? Well, &lt;code&gt;IO::All&lt;/code&gt; does slurping and a whole lot more. The motivating idea behind this module is to simplify all of the Perl IO idioms as much as possible, and also to create new idioms for common-use cases that weren&amp;rsquo;t really idiomatic to begin with.&lt;/p&gt;

&lt;p&gt;In recent years, I&amp;rsquo;ve become a fan and student of Extreme Programming (XP). One of the principles of XP is to constantly refactor your code to make it simpler, easier to read, and ultimately more maintainable. In striving to do so I found that as my code became as clean as I could make it, the parts that still looked &lt;em&gt;dirty&lt;/em&gt; were constructs imposed on me by the Perl language itself; especially the IO stuff. I didn&amp;rsquo;t let it get me down. I changed the language!&lt;/p&gt;

&lt;h4 id=&#34;span-id-what-s-going-on-here-what-s-going-on-here-span&#34;&gt;&lt;span id=&#34;What&#39;s_Going_On_Here?&#34;&gt;What&amp;rsquo;s Going on Here?&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The basic idea of &lt;code&gt;IO::All&lt;/code&gt; is that it exports a function called &lt;code&gt;io&lt;/code&gt;, which returns a new &lt;code&gt;IO::All&lt;/code&gt; object. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use IO::All;

    my $io = io(&#39;file1&#39;);
    # Is the same thing as:
    my $io = IO::All-&amp;gt;new(&#39;file1&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another principle of IO::All is that it takes as many cues as possible from its context. Consider the following example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @lines = io(&#39;stuff&#39;)-&amp;gt;slurp;
    my @good_lines = grep {not /bad/} @lines;
    io(&#39;good-stuff&#39;)-&amp;gt;print(@good_lines);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we are basically censoring a file, removing all the &lt;em&gt;bad&lt;/em&gt; lines. The first statement slurps up the file, but since it is called in list context, it returns all the lines instead of one long string. The second statement weeds out any filth, and the third statement writes the good lines to a new file.&lt;/p&gt;

&lt;p&gt;But the question arises, &amp;ldquo;How did &lt;code&gt;IO::All&lt;/code&gt; know to open the output file for output?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;The answer is that &lt;code&gt;IO::All&lt;/code&gt; delays the open until the first IO operation and uses the operation to determine the context. The opening and closing of files happens automatically and you almost never need to indicate the file mode, although you can do all of this manually if you really want to.&lt;/p&gt;

&lt;h3 id=&#34;span-id-directory-assistance-directory-assistance-span&#34;&gt;&lt;span id=&#34;Directory_Assistance&#34;&gt;Directory Assistance&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;I never really liked the directory commands in Perl. You know, &lt;code&gt;opendir&lt;/code&gt;, &lt;code&gt;readdir&lt;/code&gt;, and &lt;code&gt;closedir&lt;/code&gt;. I thought, well why not let an IO::All object act as a directory in addition to a file? How would IO::All know the difference? Context, of course!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $dir = io(&#39;mydir&#39;);
    while (my $io = $dir-&amp;gt;read) {
        print $io-&amp;gt;name, &amp;quot;\n&amp;quot;
          if $io-&amp;gt;is_file;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example, IO::All opens a directory for reading and returns one entry at a time, much like &lt;code&gt;readdir&lt;/code&gt;. The difference is that instead of a file or subdirectory name, you get back another IO::All object. This is really cool, because you can immediately perform actions on the new objects. In the above code, we print the filename (returned by an IO::All method) if the object represents a file rather than a subdirectory (which is also returned by an IO::All Method).&lt;/p&gt;

&lt;h4 id=&#34;span-id-file-find-file-find-span&#34;&gt;&lt;span id=&#34;File::Find&#34;&gt;File::Find&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Ask any experienced Perl programmer which core module has the most abysmal interface, and they&amp;rsquo;d probably say &lt;code&gt;File::Find&lt;/code&gt;. Rather than explain how &lt;code&gt;File::Find&lt;/code&gt; works (which would take me an hour of research to figure out again), here&amp;rsquo;s an easy way to roll your own search.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @wanted_file_names = map {
        $_-&amp;gt;name
    } grep {
        $_-&amp;gt;name =~ /\.\w{3}/ &amp;amp;&amp;amp;
        $_-&amp;gt;slurp =~ /ingy/
    } io(&#39;my/directory&#39;)-&amp;gt;all_files;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This search finds all the file names in a directory that have a three-character extension and contain the string &amp;lsquo;ingy&amp;rsquo;. The &lt;code&gt;all_files&lt;/code&gt; method is a shortcut that returns only the files. There are also &lt;code&gt;all_dirs&lt;/code&gt;, &lt;code&gt;all_links&lt;/code&gt;, and simply &lt;code&gt;all&lt;/code&gt; methods.&lt;/p&gt;

&lt;h4 id=&#34;span-id-a-poor-man-s-tar-a-poor-man-s-tar-span&#34;&gt;&lt;span id=&#34;A_Poor_Man&#39;s_tar&#34;&gt;A Poor Man&amp;rsquo;s tar&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;This example reads all the files under a directory, and dumps them into one big file, separated by a line containing the file&amp;rsquo;s name and size. This is analogous to what the Unix &lt;code&gt;tar&lt;/code&gt; command does.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use IO::All;
    for my $file (io(&#39;mydir&#39;)-&amp;gt;all_files(&#39;-r&#39;)) {
        my $output = sprintf(&amp;quot;--- %s (%s)\n&amp;quot;, $file-&amp;gt;name, -s $file-&amp;gt;name)
                     . $file-&amp;gt;slurp;
        io(&#39;tar_like&#39;)-&amp;gt;append($output);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this usage, we pass a special flag, &lt;code&gt;-r&lt;/code&gt;, that tells &lt;code&gt;all_files&lt;/code&gt; to be recursive. That is, to find all files in all subdirectories. Also notice the &lt;code&gt;append&lt;/code&gt; method. This is the same as &lt;code&gt;print&lt;/code&gt;, but the file is opened for concatenation.&lt;/p&gt;

&lt;h3 id=&#34;span-id-double-standards-string-cheese-and-temporary-insanity-double-standards-string-cheese-and-temporary-insanity-span&#34;&gt;&lt;span id=&#34;Double_STanDards,_String_Cheese_and_Temporary_Insanity&#34;&gt;Double STanDards, String Cheese, and Temporary Insanity&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;IO::All has some handy shortcut names. In the Unix tradition, it uses a dash to mean STDIN, but it also uses it to mean STDOUT. Check out this one liner:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    io(&#39;-&#39;)-&amp;gt;print(io(&#39;-&#39;)-&amp;gt;slurp);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This just prints everything on STDIN to STDOUT. Once again context is used to determine which file handle the dash is actually referring to. A potentially more efficient way to write this is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $stdin = io(&#39;-&#39;);
    my $stdout = io(&#39;-&#39;);
    $stdout-&amp;gt;buffer($stdin-&amp;gt;buffer);
    $stdout-&amp;gt;write while $stdin-&amp;gt;read;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;read&lt;/code&gt; and &lt;code&gt;write&lt;/code&gt; methods work from an internal buffer, which defaults to 1k in size. What we&amp;rsquo;ve done in this example is to set the two objects to use the same buffer. Since the write method clears the buffer after writing it, the above idiom works nicely.&lt;/p&gt;

&lt;p&gt;Another special character is the dollar sign. This means that the IO::All object will read/write to a Perl scalar rather than a file. This can be useful when you have a code base that writes to a file, but you want to fake it out and capture all the output in a string without changing the code base.&lt;/p&gt;

&lt;p&gt;Finally, if you pass no arguments at all to the &lt;code&gt;io&lt;/code&gt; function it will work as a temporary or nameless file. This is somewhat similar in effect to writing to a string, except that the data is actually going to your disk. The temporary file is opened for both read and write modes.&lt;/p&gt;

&lt;p&gt;Here is a somewhat contrived example using all of these special cases.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $temp = io;
    $temp-&amp;gt;print(io(&#39;-&#39;)-&amp;gt;slurp);
    $temp-&amp;gt;seek(0, 0);
    my $str = io(&#39;$&#39;);
    $str-&amp;gt;print($_) for $temp-&amp;gt;getline;
    my $data = ${$str-&amp;gt;string_ref};
    $data =~ s/hate/love/;
    io(&#39;-&#39;)-&amp;gt;print($data);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK, listen up and repeat after me:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We slurp up all of STDIN, and slam it in a temp. We seek back to the start of it, and shove it a string. We suck the soul right out of string and save it from its sin. Then ship the lot to STDOUT, and sing it once again.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;span-id-socket-to-me-socket-to-me-span&#34;&gt;&lt;span id=&#34;Socket_To_Me&#34;&gt;Socket to Me&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;If IO::All objects can represent files, directories, streams, and strings then they can surely do the same for sockets. This example prints the header lines from an HTTP GET call:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $io = io(&#39;www.google.com:80&#39;);
    $io-&amp;gt;print(&amp;quot;GET / HTTP/1.1\n\n&amp;quot;);
    print while ($_ = $io-&amp;gt;getline) ne &amp;quot;\r\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, the context comes into play. Since &lt;code&gt;www.google.com:80&lt;/code&gt; looks like a socket address, the IO::All object does the right thing. It is worth noting that if you really wanted to open a &lt;strong&gt;file&lt;/strong&gt; called &lt;code&gt;&#39;www.google.com:80&#39;&lt;/code&gt; or &lt;code&gt;&#39;-&#39;&lt;/code&gt; or &lt;code&gt;&#39;$&#39;&lt;/code&gt;, you can explicitly override the IO::All heuristics like such:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $io1 = io(-filename =&amp;gt; &#39;www.google.com:80&#39;);
    my $io2 = io(-filename =&amp;gt; &#39;-&#39;);
    my $io3 = io(-filename =&amp;gt; &#39;$&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-for-fork-s-sake-for-fork-s-sake-span&#34;&gt;&lt;span id=&#34;For_Fork&#39;s_Sake&#34;&gt;For Fork&amp;rsquo;s Sake&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The one thing I always use O&amp;rsquo;Reilly&amp;rsquo;s &lt;em&gt;Perl Cookbook&lt;/em&gt; for is creating a forking socket server. Not because it&amp;rsquo;s that hard, but it&amp;rsquo;s just something I don&amp;rsquo;t keep in my head. With IO::All I have no problem remembering how to do it because it&amp;rsquo;s been made dead simple:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use IO::All;
    my $server = io(&#39;:12345&#39;)-&amp;gt;accept(&#39;-fork&#39;);
    $server-&amp;gt;print($_) while &amp;lt;DATA&amp;gt;;
    $server-&amp;gt;close;
    __DATA__
    One File, Two File
    Red File, Blue File
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This server sits and listens for connections on port 12345. When it gets a connection, it forks off a sub-process and sends two lines to the receiver.&lt;/p&gt;

&lt;p&gt;The client code to call this server might look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use IO::All;
    my $io = io(&#39;localhost:12345&#39;);
    print while $_ = $io-&amp;gt;getline;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-io-all-of-it-to-graham-io-all-of-it-to-graham-span&#34;&gt;&lt;span id=&#34;IO::All_Of_It_To_Graham&#34;&gt;IO::All of It to Graham&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;It may strike you as silly, vain, or even foolish for someone to rewrite all of the Perl IO functions as a new module when older, more mature modules exist. But therein lies the beauty of IO::All: it &lt;strong&gt;doesn&amp;rsquo;t&lt;/strong&gt; rewrite anything. It simply provides a keen new interface to &lt;code&gt;IO::File&lt;/code&gt;, &lt;code&gt;IO::Directory&lt;/code&gt;, &lt;code&gt;IO::Socket&lt;/code&gt;, &lt;code&gt;IO::String&lt;/code&gt;, &lt;code&gt;IO::Handle&lt;/code&gt;, and others. It ties all of these robust modules together into one cohesive unit. So even though &lt;code&gt;IO::All&lt;/code&gt; is relatively new, it hopefully inherits well from this legacy of stability.&lt;/p&gt;

&lt;p&gt;As far as I know, almost all of these modules we&amp;rsquo;re written by Perl superhero Graham Barr. I&amp;rsquo;ve met Graham personally and I don&amp;rsquo;t think it would be too forward of me to suggest that you send him a beer to thank him for making Perl so great. Unfortunately I don&amp;rsquo;t know his address.&lt;/p&gt;

&lt;h3 id=&#34;span-id-tie-me-up-and-lock-me-tie-me-up-and-lock-me-span&#34;&gt;&lt;span id=&#34;Tie_Me_Up_and_Lock_Me&#34;&gt;Tie Me Up and Lock Me&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;I learned a neat trick from Gisle Aas by reading the code of his &lt;code&gt;IO::String&lt;/code&gt; module. The trick is that you can tie an object to itself. This is especially handy when the object is IO handle. It means that you can use the object as a regular file handle with all Perl built-in IO functions. And you can &lt;em&gt;also&lt;/em&gt; use it as a regular object by calling methods on it. It&amp;rsquo;s TMTOWTDI at its finest.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use IO::All &#39;-tie&#39;;
    my $file = io(&#39;myfile&#39;);
    my $line1 = $file-&amp;gt;getline;
    my $line2 = &amp;lt;$file&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pretty nifty, eh? Note that you need to request that IO::All perform the tie with the &lt;code&gt;-tie&lt;/code&gt; option. That&amp;rsquo;s because a bug in Perl 5.8.0 caused things tied to themselves to not go out of scope.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s another nifty feature: &lt;em&gt;automatic file locking&lt;/em&gt;. If you specify the &lt;code&gt;-lock&lt;/code&gt; option, IO::All will call flock after every file open. You still have to worry about things like deadlock, but at least the mechanism is simple. Here is a sample where all messages written to a log file then lock the file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use IO::All &#39;-lock&#39;;
    io(&#39;log&#39;)-&amp;gt;appendln(localtime() . &amp;quot; - I&#39;m still here&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;appendln&lt;/code&gt; method is a cousin of the &lt;code&gt;println&lt;/code&gt; method. Both print a new line after your output. Note that the above code is the same as the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use IO::All;
    io(-lock =&amp;gt; &#39;log&#39;)-&amp;gt;appendln(localtime() . &amp;quot; - I&#39;m still here&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s because any parameters that are passed to IO::All are simply passed along to all invocations of the &lt;code&gt;io&lt;/code&gt; function.&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-methods-in-my-madness-the-methods-in-my-madness-span&#34;&gt;&lt;span id=&#34;The_Methods_in_My_Madness&#34;&gt;The Methods in My Madness&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;IO::All has over 60 methods that you can call to perform various IO-related actions. Not all methods make sense in all contexts for all flavors of IO. Most of the methods are simply direct proxies for methods found in the core modules that IO::All is built upon.&lt;/p&gt;

&lt;p&gt;Some of the methods have been enhanced to be more flexible than their ancestors. Take the &lt;code&gt;getline&lt;/code&gt; function, for example. The IO::Handle version simply gets the next line. The IO::All version takes an optional argument that is used as the record separator. To read a paragraph of text you could do this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $paragraph = io(&#39;myfile&#39;)-&amp;gt;getline(&#39;&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lots of the methods have been presented in this article. For complete information on all the available IO::All methods, see the IO::All documentation.&lt;/p&gt;

&lt;h3 id=&#34;span-id-it-s-not-just-keen-it-s-spiffy-it-s-not-just-keen-it-s-spiffy-span&#34;&gt;&lt;span id=&#34;It&#39;s_Not_Just_Keen,_It&#39;s_Spiffy&#34;&gt;It&amp;rsquo;s Not Just Keen, It&amp;rsquo;s Spiffy&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;IO::All is a little bit different from most Perl modules in that it &lt;em&gt;exports&lt;/em&gt; the &lt;code&gt;io&lt;/code&gt; function. As I said before, the &lt;code&gt;io&lt;/code&gt; function acts as an object constructor, returning a new IO::All object for each invocation. This property is gained from IO::All&amp;rsquo;s base class, &lt;code&gt;Spiffy.pm&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Spiffy&lt;/code&gt; is a new kind of generic base class. Its primary magic trick is that it supports a unique feature that I call &lt;strong&gt;inheritable exporting&lt;/strong&gt;. Normally if you use a module as a base class, it is strictly an object-oriented thing. You don&amp;rsquo;t also export functions. Furthermore, if you were to export some functions, your subclasses would need to manually export those functions to its subclasses.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Spiffy&lt;/code&gt; is set up so that all of the &lt;code&gt;@EXPORT&lt;/code&gt; arrays in all the modules in the &lt;code&gt;@ISA&lt;/code&gt; tree of a class, are combined together to act as one big export list. The magic is then taken one step further. Functions like &lt;code&gt;io&lt;/code&gt; that act as an object constructor are &lt;em&gt;smart&lt;/em&gt; enough to return an object of a subclass; not just an IO::All object.&lt;/p&gt;

&lt;p&gt;This is demonstrated in the next section. See the Spiffy documentation for details on this and other exciting features.&lt;/p&gt;

&lt;h3 id=&#34;span-id-eie-io-eie-io-span&#34;&gt;&lt;span id=&#34;EIE::IO&#34;&gt;EIE::IO&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s write an extension of IO::All that adds a new method called &lt;code&gt;pruls&lt;/code&gt;, which is &lt;code&gt;slurp&lt;/code&gt; backwards. Its purpose will be to return the whole file with its lines in reverse order. Here is the code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package EIE::IO;
    use IO::All &#39;-base&#39;;
    sub pruls {
        my $self = shift;
        my @lines = reverse $self-&amp;gt;slurp;
        wantarray ? @lines : join &#39;&#39;, @lines;
    }
    1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s all there is to it. This module will act just like &lt;code&gt;IO::All&lt;/code&gt;, except with one more method. You would use it just like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use EIE::IO;
    print io(&#39;mystuff&#39;)-&amp;gt;pruls;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the &lt;code&gt;io&lt;/code&gt; function is still exported, but it returns a new &lt;strong&gt;EIE::IO&lt;/strong&gt; object. That&amp;rsquo;s Spiffy!&lt;/p&gt;

&lt;h3 id=&#34;span-id-conclusion-conclusion-span&#34;&gt;&lt;span id=&#34;Conclusion&#34;&gt;Conclusion&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;IO::All&lt;/code&gt; is still quite a young module. There is room for many, many more idioms. There is also the possibility of including even more types of IO, like shared memory, IPC, and Unix sockets. If you have a use case that you think would make a nice addition to this Swiss Army Light Sabre of Perl IO, please Let&amp;rsquo;s change the Perl language for the better.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

