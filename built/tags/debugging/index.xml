<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Debugging on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/debugging/</link>
    <description>Recent content in Debugging on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 15 May 2014 12:19:51 +0000</lastBuildDate>
    <atom:link href="/tags/debugging/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Debunk Perl&#39;s magic with B::Deparse</title>
      <link>http://localhost:1313/article/89/2014/5/15/Debunk-Perl-s-magic-with-B--Deparse/</link>
      <pubDate>Thu, 15 May 2014 12:19:51 +0000</pubDate>
      
      <guid>http://localhost:1313/article/89/2014/5/15/Debunk-Perl-s-magic-with-B--Deparse/</guid>
      <description>

&lt;p&gt;&lt;em&gt;The &lt;a href=&#34;https://metacpan.org/pod/B::Deparse&#34;&gt;B::Deparse&lt;/a&gt; module compiles a Perl program and then deparses it, producing the internally generated source code. What&amp;rsquo;s the point of that you say? Well it let&amp;rsquo;s you look behind the curtain and inspect how Perl is structuring the program code which can help you debug it, among other things.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Consider the slurpy parameter optimization from this week&amp;rsquo;s subroutine signatures &lt;a href=&#34;http://perltricks.com/article/88/2014/5/12/Benchmarking-subroutine-signatures&#34;&gt;article&lt;/a&gt;. We know from speed benchmarks that the signature becomes ~30% faster with a slurpy parameter, and we can reason about why that is the case, but B::Deparse can &lt;em&gt;show&lt;/em&gt; us why. Here is the code for two signatures, one normal and one using the slurpy parameter:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; feature &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;signatures&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;normal_signature&lt;/span&gt; ($foo) {}

&lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;slurpy_signature&lt;/span&gt; ($foo, @) {}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now if we save the code as signatures.pl, we can use B::Deparse to inspect it at the command line:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ perl &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;MO&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;Deparse signatures&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pl&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This generates the following output:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;normal_signature&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; feature &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;signatures&amp;#39;&lt;/span&gt;;
    die &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Too many arguments for subroutine&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;unless&lt;/span&gt; @_ &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    die &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Too few arguments for subroutine&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;unless&lt;/span&gt; @_ &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $foo &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; $_[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;];
    ();
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;slurpy_signature&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; feature &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;signatures&amp;#39;&lt;/span&gt;;
    die &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Too few arguments for subroutine&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;unless&lt;/span&gt; @_ &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $foo &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; $_[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;];
    ();
}
signatures&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pl syntax OK&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The generated code shows how Perl structured the signatures.pl code internally. You can see how &amp;ldquo;slurpy_signature&amp;rdquo; has one fewer die statement. This explains the improved performance as the subroutine has less to do. Magic debunked!&lt;/p&gt;

&lt;h3 id=&#34;more-on-b-deparse&#34;&gt;More on B::Deparse&lt;/h3&gt;

&lt;p&gt;B::Deparse comes with extensive &lt;a href=&#34;https://metacpan.org/pod/B::Deparse&#34;&gt;documentation&lt;/a&gt; and has some useful options for altering the output.&lt;/p&gt;

&lt;p&gt;One of the many gems in brian d foy&amp;rsquo;s &lt;a href=&#34;http://www.amazon.com/gp/product/144939311X/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=144939311X&amp;amp;linkCode=as2&amp;amp;tag=perltrickscom-20&#34;&gt;Mastering Perl&lt;/a&gt; book is the B::Deparse entry in the &amp;ldquo;Cleaning up Perl&amp;rdquo; chapter (affiliate link). In the book brian shows several uses for B::Deparse including debugging one-liners and decoding obfuscated code. You can read a draft version of the chapter online &lt;a href=&#34;http://chimera.labs.oreilly.com/books/1234000001527/ch07.html&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;PerlMonks has an &lt;a href=&#34;http://www.perlmonks.org/?node_id=804232&#34;&gt;interesting&lt;/a&gt; entry for those curious as to why the command line use of B::Deparse is &amp;ldquo;-MO=Deparse&amp;rdquo; and not &amp;ldquo;-MB::Deparse&amp;rdquo;.&lt;/p&gt;

&lt;h3 id=&#34;thanks&#34;&gt;Thanks&lt;/h3&gt;

&lt;p&gt;Thanks again to Perl Pumpking and &lt;a href=&#34;http://www.youtube.com/watch?v=Sp102BECq8s&#34;&gt;teflon&lt;/a&gt; man Ricardo Signes who put me on to using B::Deparse on subroutine signatures.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Cover image &lt;a href=&#34;https://creativecommons.org/licenses/by/2.0/&#34;&gt;Â©&lt;/a&gt; &lt;a href=&#34;https://www.flickr.com/photos/barkbud/4165385634&#34;&gt;bark&lt;/a&gt; image has been digitaly altered&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Installing Perl modules with C library dependencies</title>
      <link>http://localhost:1313/article/19/2013/4/15/Installing-Perl-modules-with-C-library-dependencies/</link>
      <pubDate>Mon, 15 Apr 2013 18:37:26 +0000</pubDate>
      
      <guid>http://localhost:1313/article/19/2013/4/15/Installing-Perl-modules-with-C-library-dependencies/</guid>
      <description>

&lt;p&gt;Some Perl modules have specific C library dependencies that need to be met or else they won&amp;rsquo;t install. These issues can be tricky to solve as CPAN is not able to automatically install or report on non-Perl dependencies and Google isn&amp;rsquo;t good at returning useful results for these types of issues (&lt;a href=&#34;https://metacpan.org/pod/Net::SSLeay&#34;&gt;Net::SSLeay&lt;/a&gt; is a common example of a tricky module to install). Usually you will only find out about missing dependencies when trying to install the module, as the install will fail. What you need to do at this point is &lt;strong&gt;identify&lt;/strong&gt; and &lt;strong&gt;install&lt;/strong&gt; the missing C libraries.&lt;/p&gt;

&lt;h3 id=&#34;identifying-c-library-dependencies&#34;&gt;Identifying C Library dependencies&lt;/h3&gt;

&lt;p&gt;Here are some places to check for dependencies:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Install error message&lt;/strong&gt; - scan the command line output from the failed install: often Perl developers will write specific error messages that indicate the missing C library.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Module documentation&lt;/strong&gt; - check the main POD page for the module on &lt;a href=&#34;https://metacpan.org/&#34;&gt;metacpan&lt;/a&gt; it may indicate which C libraries are required.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Distribution files&lt;/strong&gt; - check the README and INSTALL files that come with the distribution for the module you are trying to install. If available they will be in the root directory of the tarball. You can browse these files online at &lt;a href=&#34;https://metacpan.org/&#34;&gt;metacpan&lt;/a&gt; by searching for the module, then clicking the &amp;lsquo;browse&amp;rsquo; link on the module&amp;rsquo;s main page.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Search your package manager&lt;/strong&gt; - look at the technologies and keywords associated with the module. For example &lt;a href=&#34;https://metacpan.org/pod/Net::SSLeay&#34;&gt;Net::SSLeay&lt;/a&gt; probably has something to do with SSL, so search for Perl-related SSL packages (example below).&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;installing-c-library-dependencies&#34;&gt;Installing C library dependencies&lt;/h3&gt;

&lt;p&gt;Once you have identified the missing C libraries, you need to install them. If you are on Linux, this can be done using a package manager and searching for and installing the package containing the C library:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# yum package manager&lt;/span&gt;
$ sudo yum search ssl
&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
sudo yum install openssl&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;perl&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;x86_64 perl&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;Net&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;SSLeay&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;x86_64 perl&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;Crypt&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;SSLeay&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;x86_64&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you are not on Linux, try downloading the library directly from the C library&amp;rsquo;s homepage - these are easy to find via Google and usually have specific Windows / OSX distributions.&lt;/p&gt;

&lt;p&gt;Once you have installed the requisite libraries, try installing the Perl module again with CPAN.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Check your module POD using perldoc</title>
      <link>http://localhost:1313/article/9/2013/4/1/Check-your-module-POD-using-perldoc/</link>
      <pubDate>Mon, 01 Apr 2013 22:45:35 +0000</pubDate>
      
      <guid>http://localhost:1313/article/9/2013/4/1/Check-your-module-POD-using-perldoc/</guid>
      <description>&lt;p&gt;Perl ships with a command-line program called perldoc that makes it easier to search and read Perl&amp;rsquo;s vast documentation in the POD markup language. If perldoc is called with the -F flag, it will display the POD markup of an input file - this can be useful when your are developing a new Perl distribution and want to check the appearance of the POD in your module before it appears on CPAN for all to see.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Pass a local file to perldoc&lt;/span&gt;

perldoc &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;F ProxyManager&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pm&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This will then display the POD markup:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;ProxyManager(&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;)                                            

NAME
       Net::OpenVPN::ProxyManager &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; connect to proxy servers using OpenVPN&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;

SYNOPSIS
       &lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Net::OpenVPN::ProxyManager;
       &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $pm &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Net::OpenVPN::ProxyManager&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;;

       &lt;span style=&#34;color:#75715e&#34;&gt;# Create a config object to capture proxy server details&lt;/span&gt;
       &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $config_object &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; $pm&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;create_config({remote &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;100.120.3.34 53&amp;#39;&lt;/span&gt;, proto &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;udp&amp;#39;&lt;/span&gt;});

       &lt;span style=&#34;color:#75715e&#34;&gt;# Launch OpenVPN and connect to the proxy&lt;/span&gt;
       $pm&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;connect($config_object);
       &lt;span style=&#34;color:#75715e&#34;&gt;# do some stuff&lt;/span&gt;

       &lt;span style=&#34;color:#75715e&#34;&gt;# Disconnect from the proxy server&lt;/span&gt;
       $pm&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;disconnect();

DESCRIPTION
       Net::OpenVPN::ProxyManager is an object oriented module that provides methods to simplify the management of proxy connections that support OpenVPN&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;

This is a base generic class, see Net::OpenVPN::ProxyManager::HMA &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; additional methods to interact with hidemyass&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;com proxy servers&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;

METHODS
   &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;
       The constructor accepts an anonymous hash &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; two optional parameters: config_path &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; warning_flag&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt; config_path is the path that ProxyManager&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pm will &lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; to create the config file when the create_config method is called&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt; By default config_path is set to &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/tmp/openvpn-config.conf&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Unraveling Code with the Debugger</title>
      <link>http://localhost:1313/pub/2006/04/06/debugger.html/</link>
      <pubDate>Thu, 06 Apr 2006 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2006/04/06/debugger.html/</guid>
      <description>

&lt;p&gt;Many people who work with Perl code never touch the debugger. My goal in this article is to provide reasoned argument for adding the Perl debugger to your set of tools, as well as pointers on how to do so. Many people are most comfortable with adding debugging variables and print statements to their code. These are fine techniques; I use them too, when they are appropriate. At other times, the debugger has saved me from tearing my hair out.&lt;/p&gt;

&lt;p&gt;To mangle an old saying, with apologies to Sartre, &amp;ldquo;Hell is other people&amp;rsquo;s code.&amp;rdquo; Other people think differently than I do; they use weird idioms, and sometimes their comments are incomprehensible. Invoking the debugger on someone&amp;rsquo;s code is like having a conversation with the author. It opens the code to the questions I want answered, in real time&amp;ndash;and there&amp;rsquo;s another party in the conversation, the Perl interpreter. The debugger makes it easy to try things out, even quicker than writing a one-liner, because the environment&amp;rsquo;s already set up for the running program.&lt;/p&gt;

&lt;p&gt;This article is a case example of using the Perl debugger in a production environment. In this situation, we had problems with CGI scripts on a machine I don&amp;rsquo;t maintain. I wanted to go in, solve the problem, and get out quickly, without unnecessarily changing anybody&amp;rsquo;s code.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve written the article so that you can follow along yourself, if you wish. To do so, you need a Linux/Unix system with Perl 5.8, Apache (any version), and a basic &lt;a href=&#34;http://www.twiki.org/&#34;&gt;TWiki&lt;/a&gt; installation. (I&amp;rsquo;m using version 20040902-3.) TWiki is quite easy to install from packages; it took me 3 minutes under Ubuntu, including answering a few installation questions. If you&amp;rsquo;re installing for this walk-through, enable the sample data set, which installs into the default TWiki directories (&lt;em&gt;/var/lib/twiki/data&lt;/em&gt; and &lt;em&gt;/var/www/twiki/pub&lt;/em&gt; on Debian and Ubuntu).&lt;/p&gt;

&lt;p&gt;Additionally, for any use of the debugger, you should install the Perl modules &lt;a href=&#34;https://metacpan.org/pod/Term::ReadLine&#34;&gt;Term::ReadLine&lt;/a&gt; and &lt;a href=&#34;https://metacpan.org/pod/Term::ReadKey&#34;&gt;Term::ReadKey&lt;/a&gt; from &lt;a href=&#34;https://metacpan.org/&#34;&gt;MetaCPAN&lt;/a&gt;. These will give you bash/csh-like cursor control, history browsing with up and down arrows, and tab completion on variables and functions.&lt;/p&gt;

&lt;h3 id=&#34;statement-of-the-problem&#34;&gt;Statement of the Problem&lt;/h3&gt;

&lt;p&gt;Our production installation of TWiki had a problem with a hidden web: a section that users could reach only by using its URL, rather than through the usual list of public webs (on the left side of each page). The problem appeared when we tried to make the hidden web public; it remained hidden. We lived with this for a few weeks, convinced that TWiki had a sticky setting somewhere that we didn&amp;rsquo;t know about, or perhaps TWiki had a bug. The documentation, while excellent, didn&amp;rsquo;t seem to address our problem. A number of people looked at the configuration files without seeing the solution.&lt;/p&gt;

&lt;p&gt;Above all, it was important to fix this quickly, because we couldn&amp;rsquo;t spend much effort on this relatively minor annoyance. We were almost at the point of asking for help within the TWiki community, but as we didn&amp;rsquo;t find evidence anybody else was having this problem, it likely wouldn&amp;rsquo;t be a quick fix. (As you&amp;rsquo;re reading, you may see the answer, but please keep reading; the utility of the debugger extends far beyond such an easy problem.)&lt;/p&gt;

&lt;h3 id=&#34;initial-look&#34;&gt;Initial Look&lt;/h3&gt;

&lt;p&gt;To create a hidden web within TWiki, set &lt;code&gt;NOSEARCHALL = yes&lt;/code&gt; in the web&amp;rsquo;s &lt;code&gt;WebPreferences&lt;/code&gt; page. Setting &lt;code&gt;NOSEARCHALL = no&lt;/code&gt; still left the web hidden.&lt;/p&gt;

&lt;p&gt;The documentation suggested that the only configuration variable involved was &lt;code&gt;NOSEARCHALL&lt;/code&gt;. My next step was grepping the data directory, and then the TWiki source code&amp;ndash;which turned up the likely code responsible, a certain function &lt;code&gt;TWiki::getPublicWebList&lt;/code&gt;. Looking at that code didn&amp;rsquo;t make the answer clear. (If you&amp;rsquo;re following along, go ahead and run &lt;code&gt;perldoc -m TWiki&lt;/code&gt; to see if you can spot the problem by inspection.)&lt;/p&gt;

&lt;p&gt;Back in the web browser, I noted that the URL for normal TWiki page viewing was &lt;code&gt;http://hostname/cgi-bin/twiki/view/Main/WebHome&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;From my initial look at the code, I knew the CGI that produced this was in &lt;em&gt;/usr/lib/cgi-bin/twiki/view&lt;/em&gt;. Could I run it from the command line? Changing to that directory, I ran &lt;code&gt;./view&lt;/code&gt; and saw the expected HTML for the front page.&lt;/p&gt;

&lt;h3 id=&#34;debugger&#34;&gt;Debugger&lt;/h3&gt;

&lt;p&gt;Next, I fired up the debugger on the file: &lt;code&gt;perl -d view&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;hellip; which didn&amp;rsquo;t work, because the program uses taint mode. (If you try, you&amp;rsquo;ll see the warning, &lt;em&gt;&amp;rdquo;-T&amp;rdquo; is on the #! line, it must also be used on the command line at view line 1.&lt;/em&gt;) That was easy to fix by running &lt;code&gt;perl -dT view&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If you try that, you&amp;rsquo;ll see the debugger interface:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Loading DB routines from perl5db.pl version 1.28
Editor support available.

Enter h or `h h&#39; for help, or `man perldebug&#39; for more help.

main::(view:38):        my $query = new CGI;
  DB&amp;lt;1&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The major elements here are: an introductory message; the package, filename, and line number; the command the debugger is about to run; and a prompt showing your command-history number.&lt;/p&gt;

&lt;p&gt;Press &lt;code&gt;c&lt;/code&gt; (for continue) and Enter. The program will run through to completion, finishing with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Debugged program terminated.  Use q to quit or R to restart,
  use O inhibit_exit to avoid stopping after program termination,
  h q, h R or h O to get additional info.
  DB&amp;lt;1&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Press &lt;code&gt;R&lt;/code&gt; to restart the program &amp;hellip; which normally would work, but you can&amp;rsquo;t restart programs with taint mode enabled. No matter. Restart the debugger with &lt;code&gt;perl -dT view&lt;/code&gt; again.&lt;/p&gt;

&lt;p&gt;Next, press &lt;code&gt;l&lt;/code&gt; for a code listing with line numbers. The default is ten lines of code. You&amp;rsquo;ll notice an arrow by the line prepared to execute next. Some lines have a trailing colon (&lt;code&gt;:&lt;/code&gt;), which means that you can interrupt execution at that line. Pressing &lt;code&gt;l&lt;/code&gt; again will show the next ten lines, and so on. &lt;code&gt;l&lt;/code&gt; can also handle listing a range (such as &lt;code&gt;l 1-40&lt;/code&gt;) or a function (such as &lt;code&gt;l TWiki::initialize&lt;/code&gt;). You can move the current display back to the execution point with a period (&lt;code&gt;.&lt;/code&gt;) or back ten lines with minus (&lt;code&gt;-&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Start running the program, slowly. Press &lt;code&gt;n&lt;/code&gt;, for next, and the display will change to show the subsequent line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  DB&amp;lt;8&amp;gt; n
main::(view:40):        my $thePathInfo = $query-&amp;gt;path_info();
  DB&amp;lt;8&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;n&lt;/code&gt; will always bring you to the next executable line. This command is used frequently enough that you can press Enter to repeat it. If you try this, on the fifth execution you&amp;rsquo;ll see that multiline commands break up nicely on the screen:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  DB&amp;lt;1&amp;gt;
main::(view:45):       my( $topic, $webName, $scriptUrlPath, $userName ) =
main::(view:46):          TWiki::initialize( $thePathInfo, $theRemoteUser,
main::(view:47):                             $theTopic, $theUrl, $query );
  DB&amp;lt;1&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Only the first of those lines is breakable, however. Another &lt;code&gt;n&lt;/code&gt; would skip ahead to line 49; but don&amp;rsquo;t do that yet.&lt;/p&gt;

&lt;p&gt;The next feature is code evaluation. At the debugger prompt, you may enter any Perl code to execute in the current context. This can include modifying the running program, such as defining functions or variables.&lt;/p&gt;

&lt;p&gt;You can also run functions or examine data using normal Perl syntax. There is a special command to evaluate and dump expressions in a list context, &lt;code&gt;x&lt;/code&gt;. Try it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  DB&amp;lt;1&amp;gt; x $query-&amp;gt;url;
0  &#39;http://localhost/view&#39;
  DB&amp;lt;2&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that the command history number increments from 1 to 2, because this is the first nontrivial command you&amp;rsquo;ve executed. Reexecute any prior command with the shortcut &lt;code&gt;!number&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;0&lt;/code&gt; signifies the array index of each element, which is useful with lists. &lt;code&gt;x&lt;/code&gt; will also do the right thing for data structures. Try viewing your CGI object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  DB&amp;lt;2&amp;gt; x $query
0  CGI=HASH(0x8aef668)
   &#39;.charset&#39; =&amp;gt; &#39;ISO-8859-1&#39;
   &#39;.fieldnames&#39; =&amp;gt; HASH(0x8a83034)
        empty hash
   &#39;.parameters&#39; =&amp;gt; ARRAY(0x8b32aa4)
        empty array
   &#39;.path_info&#39; =&amp;gt; &#39;&#39;
   &#39;escape&#39; =&amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For deep data, you might prefer restricting the depth walking to two levels: &lt;code&gt;x 2 $query&lt;/code&gt; .&lt;/p&gt;

&lt;p&gt;The next feature, which goes along with &lt;code&gt;n&lt;/code&gt;, is &lt;code&gt;s&lt;/code&gt;, for single-stepping &lt;em&gt;into&lt;/em&gt; a function. &lt;code&gt;s&lt;/code&gt; will replace the current running context with that context of the subroutine. After one &lt;code&gt;s&lt;/code&gt;, you&amp;rsquo;re within &lt;code&gt;TWiki::initialize&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  DB&amp;lt;4&amp;gt; s
TWiki::initialize(/usr/share/perl5/TWiki.pm:333):
333:        my ( $thePathInfo, $theRemoteUser, $theTopic,
                               $theUrl, $theQuery ) = @_;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The description line has changed, showing that you&amp;rsquo;re in a new package, function, and file. Press Enter; note that &lt;code&gt;s&lt;/code&gt; also repeats with Enter. Three more repeats will get you two levels deeper:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  DB&amp;lt;4&amp;gt;
TWiki::initialize(/usr/share/perl5/TWiki.pm:336):
336:            basicInitialize();
  DB&amp;lt;4&amp;gt;
TWiki::basicInitialize(/usr/share/perl5/TWiki.pm:490):
490:        setupLocale();
  DB&amp;lt;4&amp;gt;
TWiki::setupLocale(/usr/share/perl5/TWiki.pm:515):
515:        $siteCharset = &#39;ISO-8859-1&#39;;
               # Default values if locale mis-configured
  DB&amp;lt;4&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you are deep inside the TWiki module. Imagine tracking this program execution by hand; it would be considerably more tedious. Instead, you have the sometimes challenging task of figuring out where the program has taken you. Fortunately, the debugger has tools for making this easier. Note that the indenting isn&amp;rsquo;t any judge of the execution depth; to find that, use &lt;code&gt;T&lt;/code&gt; for trace:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  DB&amp;lt;1&amp;gt; T
. = TWiki::setupLocale() called from file
    `/usr/share/perl5/TWiki.pm&#39; line 490
. = TWiki::basicInitialize() called from file
    `/usr/share/perl5/TWiki.pm&#39; line 336
@ = TWiki::initialize(&#39;&#39;, undef, undef, &#39;http://localhost/view&#39;,
    ref(CGI)) called from file `view&#39; line 45
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The backtrace has the following format: the first character is the calling context; &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;$&lt;/code&gt;, and &lt;code&gt;@&lt;/code&gt; signify void, scalar, and list contexts respectively. Next is function name, including the arguments passed, if any. Finally comes the calling filename and line number. These lines go from deepest to shallowest execution depth.&lt;/p&gt;

&lt;p&gt;Perhaps you went too deep. Use &lt;code&gt;r&lt;/code&gt; to return from a function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  DB&amp;lt;8&amp;gt; r
void context return from TWiki::setupLocale
TWiki::basicInitialize(/usr/share/perl5/TWiki.pm:491):
491:        setupRegexes();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here you can see that &lt;code&gt;r&lt;/code&gt; shows the return value and its context. This can be quite useful, as the calling context can occasionally surprise even experienced programmers. With inspection, you can verify that this output makes sense compared to the trace above, because it&amp;rsquo;s one line beyond the caller from the first line of that trace.&lt;/p&gt;

&lt;p&gt;Use &lt;code&gt;r&lt;/code&gt; again twice, to get back to the top. Now it&amp;rsquo;s clear that &lt;code&gt;initialize()&lt;/code&gt; returns a list to the caller:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  DB&amp;lt;1&amp;gt; r
list context return from TWiki::initialize:
0  &#39;WebHome&#39;
1  &#39;Main&#39;
2  &#39;/cgi-bin/twiki&#39;
3  &#39;guest&#39;
4  &#39;/var/lib/twiki/data&#39;
main::(view:49):        TWiki::UI::View::view( $webName,
                            $topic, $userName, $query );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you were tracking the initialization routine, you might remind yourself what the caller was doing with the command &lt;code&gt;-&lt;/code&gt; to show the calling line again; but that&amp;rsquo;s not necessary now, so continue!&lt;/p&gt;

&lt;p&gt;Take a step back. You know you&amp;rsquo;re looking for the function &lt;code&gt;TWiki::getPublicWebList&lt;/code&gt;. You can take a shortcut to get there. The debugger command &lt;code&gt;c&lt;/code&gt; can take arguments, either line numbers or subroutine names.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  DB&amp;lt;5&amp;gt; c TWiki::getPublicWebList
TWiki::getPublicWebList(/usr/share/perl5/TWiki.pm:2559):
2559:       if( ! @publicWebList ) {
  DB&amp;lt;6&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, you&amp;rsquo;ve switched modules again, into &lt;em&gt;TWiki.pm&lt;/em&gt;. Take a look around:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  DB&amp;lt;3&amp;gt; l
2559==&amp;gt;     if( ! @publicWebList ) {
2560            # build public web list, e.g. exclude hidden
                # webs, but include current web
2561:           my @list = &amp;amp;TWiki::Store::getAllWebs( &amp;quot;&amp;quot; );
2562:           my $item = &amp;quot;&amp;quot;;
2563:           my $hidden = &amp;quot;&amp;quot;;
2564:           foreach $item ( @list ) {
2565:               $hidden =
  &amp;amp;TWiki::Prefs::getPreferencesValue( &amp;quot;NOSEARCHALL&amp;quot;, $item );
2566                # exclude topics that are hidden or start
                    # with . or _ unless current web
2567:               if( ( $item eq $TWiki::webName  ) ||
                        ( ( ! $hidden ) &amp;amp;&amp;amp; ( $item =~
                                      /^[^\.\_]/ ) ) ) {
2568:                   push( @publicWebList, $item );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This looks promising. &lt;code&gt;c 2562&lt;/code&gt; and then &lt;code&gt;x @list&lt;/code&gt; to see that there are five list items.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  DB&amp;lt;15&amp;gt; c 2562
TWiki::getPublicWebList(/usr/share/perl5/TWiki.pm:2562):
2562:           my $item = &amp;quot;&amp;quot;;
  DB&amp;lt;16&amp;gt; x @list
0  &#39;Main&#39;
1  &#39;Sandbox&#39;
2  &#39;TWiki&#39;
3  &#39;Trash&#39;
4  &#39;_default&#39;
  DB&amp;lt;17&amp;gt; n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, the &lt;code&gt;foreach()&lt;/code&gt; in line 2,564 will identify which of these are public. Getting warmer! You can &lt;code&gt;n&lt;/code&gt; several times to see the program flow. (Remember, after the first, you can press Enter.) If you run other commands, Enter still keeps its shortcut of &lt;code&gt;n&lt;/code&gt; or &lt;code&gt;s&lt;/code&gt;. If you &lt;code&gt;x $hidden&lt;/code&gt; after you&amp;rsquo;ve passed line 2,565 in each loop, you will see that they contain the empty string because &lt;code&gt;NOSEARCHALL&lt;/code&gt; is unset.&lt;/p&gt;

&lt;p&gt;The expression in the following line tests the truth of &lt;code&gt;$hidden&lt;/code&gt; as per the comment.&lt;/p&gt;

&lt;p&gt;Here is the solution. In my team&amp;rsquo;s original problem, we changed &lt;code&gt;NOSEARCHALL&lt;/code&gt; from &lt;code&gt;Yes&lt;/code&gt; to &lt;code&gt;No&lt;/code&gt;. The string &lt;code&gt;No&lt;/code&gt; certainly is still true. It took me a few runs through the code, testing values each time, to find it.&lt;/p&gt;

&lt;p&gt;When I changed &lt;code&gt;NOSEARCHALL&lt;/code&gt; to &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt; from &lt;code&gt;Yes&lt;/code&gt; in the config file, the hidden web immediately became unhidden. Problem solved. The entire process took no more than 45 minutes. Considering the number of lines of code in TWiki and its relative complexity, that isn&amp;rsquo;t bad.&lt;/p&gt;

&lt;h3 id=&#34;results&#34;&gt;Results&lt;/h3&gt;

&lt;p&gt;Yes, the problem was that we overlooked something &amp;ldquo;obvious.&amp;rdquo; True, I didn&amp;rsquo;t actually debug the code; I debugged my configuration. No matter. This is the way of a lot of debugging; the problem isn&amp;rsquo;t where you expect, and it&amp;rsquo;s obvious in retrospect. I hope with this simple example, I&amp;rsquo;ve shown how the debugger can tell you things you may not notice by code inspection or reading documentation.&lt;/p&gt;

&lt;p&gt;This article has barely scratched the surface of the debugger&amp;rsquo;s capabilities; it can also do such things as automatically insert code that runs whenever you step forward, or automatically stop execution when an expression becomes true. You can insert lines of code into the program that exist only in the debugging instance. You can record your actions and play them back in other debugging sessions; or customize the debugger with your own preferences and aliases. There are also methods to run a debugger GUI on a remote server, and modules to harness debugging mod_perl and other programs that don&amp;rsquo;t run on the command line. Please see the references for more information about these features.&lt;/p&gt;

&lt;h3 id=&#34;references-introductory-debugger-information-online&#34;&gt;References: Introductory Debugger Information Online&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.linuxjournal.com/article/7581/&#34;&gt;The Perl Debugger. Linux Journal. March 2005, 73-76&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://perldoc.perl.org/perldebtut.html&#34;&gt;perldebtut&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://perldoc.perl.org/perldebug.html&#34;&gt;perldebug&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/11/24/debugger_ref.html&#34;&gt;Perl Debugger Quick Reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>More Lightning Articles</title>
      <link>http://localhost:1313/pub/2005/03/31/lightning2.html/</link>
      <pubDate>Thu, 31 Mar 2005 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2005/03/31/lightning2.html/</guid>
      <description>

&lt;h3 id=&#34;span-id-emacsperl-customizing-emacs-with-perl-span&#34;&gt;&lt;span id=&#34;emacsperl&#34;&gt;Customizing Emacs with Perl&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;by Bob DuCharme&lt;/p&gt;

&lt;p&gt;Over time, I&amp;rsquo;ve accumulated a list of Emacs customizations I wanted to implement when I got the chance. For example, I&amp;rsquo;d like macros to perform certain global replaces just within a marked block, and I&amp;rsquo;d like a macro to reformat an Outlook formatted date to an ISO 8609 formatted date. I&amp;rsquo;m not overly intimidated by the elisp language used to customize Emacs behavior; I&amp;rsquo;ve copied elisp code and modified it to make some tweaks before, I had a healthy dose of Scheme and LISP programming in school, and I&amp;rsquo;ve done extensive work with XSLT, a descendant of these grand old languages. Still, as with a lot of postponed editor customization work, I knew I&amp;rsquo;d have to use these macros many, many times before they earned back the time invested in creating them, because I wasn&amp;rsquo;t that familiar with string manipulation and other basic operations in a LISP-based language. I kept thinking to myself, &amp;ldquo;This would be so easy if I could just do the string manipulation in Perl!&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Then, I figured out how I could write Emacs functions that called Perl to operate on a marked block (or, in Emacs parlance, a &amp;ldquo;region&amp;rdquo;). Many Emacs users are familiar with the &lt;code&gt;Escape+|&lt;/code&gt; keystroke, which invokes the &lt;code&gt;shell-command-on-region&lt;/code&gt; function. It brings up a prompt in the minibuffer where you enter the command to run on the marked region, and after you press the Enter key Emacs puts the command&amp;rsquo;s output in the minibuffer if it will fit, or into a new &amp;ldquo;*Shell Command Output*&amp;rdquo; buffer if not. For example, after you mark part of an HTML file you&amp;rsquo;re editing as the region, pressing &lt;code&gt;Escape+|&lt;/code&gt; and entering &lt;code&gt;wc&lt;/code&gt; (for &amp;ldquo;word count&amp;rdquo;) at the minibuffer&amp;rsquo;s &amp;ldquo;Shell command on region:&amp;rdquo; prompt will feed the text to this command line utility if you have it in your path, and then display the number of lines, words, and characters in the region at the minibuffer. If you enter &lt;code&gt;sort&lt;/code&gt; at the same prompt, Emacs will run that command instead of &lt;code&gt;wc&lt;/code&gt; and display the result in a buffer.&lt;/p&gt;

&lt;p&gt;Entering &lt;code&gt;perl /some/path/foo.pl&lt;/code&gt; at the same prompt will run the named Perl script on the marked region and display the output appropriately. This may seem like a lot of keystrokes if you just want to do a global replace in a few paragraphs, but remember: &lt;code&gt;Ctrl+|&lt;/code&gt; calls Emacs&amp;rsquo;s built-in &lt;code&gt;shell-command-on-region&lt;/code&gt; function, and you can call this same function from a new function that you define yourself. My recent great discovery was that along with parameters identifying the region boundaries and the command to run on the region, &lt;code&gt;shell-command-on-region&lt;/code&gt; takes an optional parameter that lets you tell it to replace the input region with the output region. When you&amp;rsquo;re editing a document with Emacs, this allows you to pass a marked region outside of Emacs to a Perl script, let the Perl script do whatever you like to the text, and then Emacs will replace the original text with the processed version. (If your Perl script mangled the text, Emacs&amp;rsquo; excellent &lt;code&gt;undo&lt;/code&gt; command can come to the rescue.)&lt;/p&gt;

&lt;p&gt;Consider an example. When I take notes about a project at work, I might write that Joe R. sent an e-mail telling me that a certain system won&amp;rsquo;t need any revisions to handle the new data. I want to make a note of when he told me this, so I copy and paste the date from the e-mail he sent. We use Microsoft Outlook at work, and the dates have a format following the model &amp;ldquo;Tue 2/22/2005 6:05 PM&amp;rdquo;. I already have an Emacs macro bound to &lt;code&gt;alt+d&lt;/code&gt; to insert the current date and time (also handy when taking notes) and I wanted the date format that refers to e-mails to be the same format as the ones inserted with my &lt;code&gt;alt+d&lt;/code&gt; macro: an ISO 8609 format of the form &amp;ldquo;2005-02-22T18:05&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;.emacs&lt;/em&gt; startup file holds customized functions that you want available during your Emacs session. The following shows a bit of code that I put in mine so that I could convert these dates:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defun OLDate2ISO ()
  (interactive)
  (shell-command-on-region (point)
         (mark) &amp;quot;perl c:/util/OLDate2ISO.pl&amp;quot; nil t))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;(interactive)&lt;/code&gt; declaration tells Emacs that the function being defined can be invoked interactively as a command. For example, I can enter &amp;ldquo;OLDate2ISO&amp;rdquo; at the Emacs minibuffer command prompt, or I can press a keystroke or select a menu choice bound to this function. The &lt;code&gt;point&lt;/code&gt; and &lt;code&gt;mark&lt;/code&gt; functions are built into Emacs to identify the boundaries of the currently marked region, so they&amp;rsquo;re handy for the first and second arguments to &lt;code&gt;shell-command-on-region&lt;/code&gt;, which tell it which text is the region to act on. The third argument is the actual command to execute on the region; enter any command available on your operating system that can accept standard input. To define your own Emacs functions that call Perl functions, just change the script name in this argument from &lt;code&gt;OLDate2ISO&lt;/code&gt; to anything you like and then change this third argument to &lt;code&gt;shell-command-on-region&lt;/code&gt; to call your own Perl script.&lt;/p&gt;

&lt;p&gt;Leave the last two arguments as &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt;. Don&amp;rsquo;t worry about the fourth parameter, which controls the buffer where the shell output appears. (Setting it to &lt;code&gt;nil&lt;/code&gt; means &amp;ldquo;don&amp;rsquo;t bother.&amp;rdquo;) The fifth parameter is the key to the whole trick: when non-nil, it tells Emacs to replace the marked text in the editing buffer with the output of the command described in the third argument instead of sending the output to a buffer.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re familiar with Perl, there&amp;rsquo;s nothing particularly interesting about the &lt;em&gt;OLDate2ISO.pl&lt;/em&gt; script. It does some regular expression matching to split up the string, converts the time to a 24 hour clock, and rearranges the pieces:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Convert Outlook format date to ISO 8309 date 
#(e.g. Wed 2/16/2005 5:27 PM to 2005-02-16T17:27)
while (&amp;lt;&amp;gt;) {
  if (/\w+ (\d+)\/(\d+)\/(\d{4}) (\d+):(\d+) ([AP])M/) {
     $AorP = $6;
     $minutes = $5;
     $hour = $4;
     $year = $3;
     $month = $1;
     $day = $2;
     $day = &#39;0&#39; . $day if ($day &amp;lt; 10);
     $month = &#39;0&#39; . $month if ($month &amp;lt; 10);
     $hour = $hour + 12 if ($6 eq &#39;P&#39;);
     $hour = &#39;0&#39; . $hour if ($hour &amp;lt; 10);
     $_ = &amp;quot;$year-$month-$day&amp;quot; . &amp;quot;T$hour:$minutes&amp;quot;;
  }
  print;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you start up Emacs with a function definition like the &lt;code&gt;defun OLDate2ISO&lt;/code&gt; one shown above in your &lt;em&gt;.emacs&lt;/em&gt; file, the function is available to you like any other in Emacs. Press &lt;code&gt;Escape+x&lt;/code&gt; to bring up the Emacs minibuffer command line and enter &amp;ldquo;OLDate2ISO&amp;rdquo; there to execute it on the currently marked buffer. Like any other interactive command, you can also assign it to a keystroke or a menu choice.&lt;/p&gt;

&lt;p&gt;There might be a more efficient way to do the Perl coding shown above, but I didn&amp;rsquo;t spend too much time on it. That&amp;rsquo;s the beauty of it: with five minutes of Perl coding and one minute of elisp coding, I had a new menu choice to quickly do the transformation I had always wished for.&lt;/p&gt;

&lt;p&gt;Another example of something I always wanted is the following &lt;em&gt;txt2htmlp.pl&lt;/em&gt; script, which is useful after plugging a few paragraphs of plain text into an HTML document:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Turn lines of plain text into HTML p elements.
while (&amp;lt;&amp;gt;) {
  chop($_);
  # Turn ampersands and &amp;lt; into entity references.
  s/\&amp;amp;/\&amp;amp;amp\;/g;
  s/&amp;lt;/\&amp;amp;lt\;/g;
  # Wrap each non-blank line in a &amp;quot;p&amp;quot; element.
  print &amp;quot;&amp;lt;p&amp;gt;$_&amp;lt;/p&amp;gt;\n\n&amp;quot; if (!(/^\s*$/));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, it&amp;rsquo;s not a particularly innovative Perl script, but with the following bit of elisp in my &lt;em&gt;.emacs&lt;/em&gt; file, I have something that greatly speeds up the addition of hastily written notes into a web page, especially when I create an Emacs menu choice to call this function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defun txt2htmlp ()
  (interactive)
  (shell-command-on-region (point) 
         (mark) &amp;quot;perl c:/util/txt2htmlp.pl&amp;quot; nil t))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sometimes when I hear about hot new editors, I wonder whether they&amp;rsquo;ll ever take the place of Emacs in my daily routine. Now that I can so easily add the power of Perl to my use of Emacs, it&amp;rsquo;s going to be a lot more difficult for any other editor to compete with Emacs on my computer.&lt;/p&gt;

&lt;h3 id=&#34;span-id-linetrace-debug-your-programs-with-devel-linetrace-span&#34;&gt;&lt;span id=&#34;linetrace&#34;&gt;Debug Your Programs with Devel::LineTrace&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;by Shlomi Fish&lt;/p&gt;

&lt;p&gt;Often, programmers find a need to use print statements to output information to the screen, in order to help them analyze what went wrong in running the script. However, including these statements verbatim in the script is not such a good idea. If not promptly removed, these statements can have all kinds of side-effects: slowing down the script, destroying the correct format of its output (possibly ruining test-cases), littering the code, and confusing the user. It would be a better idea not to place them within the code in the first place. How, though, can you debug without debugging?&lt;/p&gt;

&lt;p&gt;Enter &lt;a href=&#34;https://metacpan.org/pod/Devel::LineTrace&#34;&gt;Devel::LineTrace&lt;/a&gt;, a Perl module that can assign portions of code to execute at arbitrary lines within the code. That way, the programmer can add print statements in relevant places in the code without harming the program&amp;rsquo;s integrity.&lt;/p&gt;

&lt;h4 id=&#34;verifying-that-use-lib-has-taken-effect&#34;&gt;Verifying That &lt;code&gt;use lib&lt;/code&gt; Has Taken Effect&lt;/h4&gt;

&lt;p&gt;One example I recently encountered was that I wanted to use a module I wrote from the specialized directory where I placed it, while it was already installed in the Perl&amp;rsquo;s global include path. I used a &lt;code&gt;use lib &amp;quot;./MyPath&amp;quot;&lt;/code&gt; directive to make sure this was the case, but now had a problem. What if there was a typo in the path of the &lt;code&gt;use lib&lt;/code&gt; directive, and as a result, Perl loaded the module from the global path instead? I needed a way to verify it.&lt;/p&gt;

&lt;p&gt;To demonstrate how &lt;code&gt;Devel::LineTrace&lt;/code&gt; can do just that, consider a similar script that tries to use a module named &lt;code&gt;CGI&lt;/code&gt; from the path &lt;em&gt;./MyModules&lt;/em&gt; instead of the global Perl path. (It is a bad idea to name your modules after names of modules from CPAN or from the Perl distribution, but this is just for the sake of the demonstration.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/perl -w

use strict;
use lib &amp;quot;./MyModules&amp;quot;;

use CGI;

my $q = CGI-&amp;gt;new();

print $q-&amp;gt;header();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Name this script &lt;em&gt;good.pl&lt;/em&gt;. To test that Perl loaded the &lt;code&gt;CGI&lt;/code&gt; module from the &lt;em&gt;./MyModules&lt;/em&gt; directory, direct &lt;code&gt;Devel::LineTrace&lt;/code&gt; to print the relevant entry from the &lt;code&gt;%INC&lt;/code&gt; internal variable, at the first line after the &lt;code&gt;use CGI&lt;/code&gt; one.&lt;/p&gt;

&lt;p&gt;To do so, prepare this file and call it &lt;em&gt;test-good.txt&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;good.pl:8
    print STDERR &amp;quot;\$INC{CGI.pm} == &amp;quot;, $INC{&amp;quot;CGI.pm&amp;quot;}, &amp;quot;\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Place the file and the line number at which the trace should be inserted on the first line. Then comes the code to evaluate, indented from the start of the line. After the first trace, you can put other traces, by starting the line with the filename and line number, and putting the code in the following (indented) lines. This example is simple enough not to need that though.&lt;/p&gt;

&lt;p&gt;After you have prepared &lt;em&gt;test-good.txt&lt;/em&gt;, run the script through &lt;code&gt;Devel::LineTrace&lt;/code&gt; by executing the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ PERL5DB_LT=&amp;quot;test-good.txt&amp;quot; perl -d:LineTrace good.pl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(This assumes a Bourne-shell derivative.). The &lt;code&gt;PERL5DB_LT&lt;/code&gt; environment variable contains the path of the file to use for debugging, and the &lt;code&gt;-d:LineTrace&lt;/code&gt; directive to Perl instructs it to debug the script through the &lt;code&gt;Devel::LineTrace&lt;/code&gt; package.&lt;/p&gt;

&lt;p&gt;As a result, you should see either the following output to standard error:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$INC{CGI.pm} == MyModules/CGI.pm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;meaning that Perl indeed loaded the module from the &lt;em&gt;MyModules&lt;/em&gt; sub-directory of the current directory. Otherwise, you&amp;rsquo;ll see something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$INC{CGI.pm} == /usr/lib/perl5/vendor_perl/5.8.4/CGI.pm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;which means that it came from the global path and something went wrong.&lt;/p&gt;

&lt;h4 id=&#34;limitations-of-devel-linetrace&#34;&gt;Limitations of &lt;code&gt;Devel::LineTrace&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Devel::LineTrace&lt;/code&gt; has two limitations:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Because it uses the Perl debugger interface and stops at every line (to check whether it contains a trace), program execution is considerably slower when the program is being run under it.&lt;/li&gt;
&lt;li&gt;It assigns traces to line numbers, and therefore you must update it if the line numbering of the file changes.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Nevertheless, it is a good solution for keeping those pesky &lt;code&gt;print&lt;/code&gt; statements out of your programs. Happy LineTracing!&lt;/p&gt;

&lt;h3 id=&#34;span-id-mockdbi-using-test-mockdbi-span&#34;&gt;&lt;span id=&#34;mockdbi&#34;&gt;Using Test::MockDBI&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;by Mark Leighton Fisher&lt;/p&gt;

&lt;p&gt;What if you could test your program&amp;rsquo;s use of the DBI just by creating a set of rules to guide the DBI&amp;rsquo;s behaviorâwithout touching a database (unless you want to)? That is the promise of &lt;a href=&#34;https://metacpan.org/pod/Test::MockDBI&#34;&gt;Test::MockDBI&lt;/a&gt;, which by mocking-up the entire DBI API gives you unprecedented control over every aspect of the DBI&amp;rsquo;s interface with your program.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Test::MockDBI&lt;/code&gt; uses &lt;a href=&#34;https://metacpan.org/pod/Test::MockObject::Extends&#34;&gt;Test::MockObject::Extends&lt;/a&gt; to mock all of the DBI transparently. The rest of the program knows nothing about using &lt;code&gt;Test::MockDBI&lt;/code&gt;, making &lt;code&gt;Test::MockDBI&lt;/code&gt; ideal for testing programs that you are taking over, because you only need to add the &lt;code&gt;Test::MockDBI&lt;/code&gt; invocation codeâ you do not have to modify any of the other program code. (I have found this very handy as a consultant, as I often work on other people&amp;rsquo;s code.)&lt;/p&gt;

&lt;p&gt;Rules are invoked when the current SQL matches the rule&amp;rsquo;s SQL pattern. For finer control, there is an optional numeric DBI testing type for each rule, so that a rule only fires when the SQL matches &lt;em&gt;and&lt;/em&gt; the current DBI testing type is the specified DBI testing type. You can specify this numeric DBI testing type (a simple integer matching &lt;code&gt;/^\d+$/&lt;/code&gt;) from the command line or through &lt;code&gt;Test::MockDBI::set_dbi_test_type()&lt;/code&gt;. You can also set up rules to fail a transaction if a specific &lt;code&gt;DBI::bind_param()&lt;/code&gt; parameter is a specific value. This means there are three types of conditions for &lt;code&gt;Test::MockDBI&lt;/code&gt; rules:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The current SQL&lt;/li&gt;
&lt;li&gt;The current DBI testing type&lt;/li&gt;
&lt;li&gt;The current &lt;code&gt;bind_param()&lt;/code&gt; parameter values&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Under &lt;code&gt;Test::MockDBI&lt;/code&gt;, &lt;code&gt;fetch*()&lt;/code&gt; and &lt;code&gt;select*()&lt;/code&gt; methods default to returning nothing (the empty array, the empty hash, or undef for scalars). &lt;code&gt;Test::MockDBIM&lt;/code&gt; lets you take control of their returned data with the methods &lt;code&gt;set_retval_scalar()&lt;/code&gt; and &lt;code&gt;set_retval_array()&lt;/code&gt;. You can specify the returned data directly in the &lt;code&gt;set_retval_*()&lt;/code&gt; call, or pass a CODEREF that generates a return value to use for each call to the matching &lt;code&gt;fetch*()&lt;/code&gt; or &lt;code&gt;select*()&lt;/code&gt; method. CODEREFs let you both simulate DBI&amp;rsquo;s interaction with the database more accurately (as you can return a few rows, then stop), and add in any kind of state machine or other processing needed to precisely test your code.&lt;/p&gt;

&lt;p&gt;When you need to test that your code handles database or DBI failures, &lt;code&gt;bad_method()&lt;/code&gt; is your friend. It can fail any DBI method, with the failures dependent on the current SQL and (optionally) the current DBI testing type. This capability is necessary to test code that handles bad database &lt;code&gt;UPDATE&lt;/code&gt;s, &lt;code&gt;INSERT&lt;/code&gt;s, or &lt;code&gt;DELETE&lt;/code&gt;s, along with being handy for testing failing &lt;code&gt;SELECT&lt;/code&gt;s.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Test::MockDBI&lt;/code&gt; extends your testing capabilities to testing code that is difficult or impossible to test on a live, working database. &lt;code&gt;Test::MockDBI&#39;s&lt;/code&gt; mock-up of the entire DBI API lets you add &lt;code&gt;Test::MockDBI&lt;/code&gt; to your programs without having to modify their current DBI code. Although it is not finished (not all of the DBI is mocked-up yet), &lt;code&gt;Test::MockDBI&lt;/code&gt; is already a powerful tool for testing DBI programs.&lt;/p&gt;

&lt;h3 id=&#34;unnecessary-unbuffering-unbuffering&#34;&gt;&lt;a href=&#34;#unbuffering&#34;&gt;Unnecessary Unbuffering&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;by chromatic&lt;/p&gt;

&lt;p&gt;A great joy in a programmer&amp;rsquo;s life is removing useless code, especially when its absence improves the program. Often this happens in old codebases or codebases thrown together hastily. Sometimes it happens in code written by novice programmers who try several different ideas all together and fail to undo their changes.&lt;/p&gt;

&lt;p&gt;One such persistent idiom is wholesale, program-wide unbuffering, which can take the form of any of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;local $| = 1;
$|++;
$| = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sometimes this is valuable. Sometimes it&amp;rsquo;s vital. It&amp;rsquo;s not the default for very good reason, though, and at best, including one of these lines in your program is useless code.&lt;/p&gt;

&lt;h4 id=&#34;what-s-unbuffering&#34;&gt;What&amp;rsquo;s Unbuffering?&lt;/h4&gt;

&lt;p&gt;By default, modern operating systems don&amp;rsquo;t send information to output devices directly, one byte at a time, nor do they read information from input devices directly, one byte at a time. IO is so slow, especially for networks, compared to processors and memory that adding buffers and trying to fill them before sending and receiving information can improve performance.&lt;/p&gt;

&lt;p&gt;Think of trying to fill a bathtub from a hand pump. You &lt;em&gt;could&lt;/em&gt; pump a little water into a bucket and walk back and forth to the bathtub, or you could fill a trough at the pump and fill the bucket from the trough. If the trough is empty, pumping a little bit of water into the bucket will give you a faster start, but it&amp;rsquo;ll take longer in between bucket loads than if you filled the trough at the start and carried water back and forth between the trough and the bathtub.&lt;/p&gt;

&lt;p&gt;Information isn&amp;rsquo;t exactly like water, though. Sometimes it&amp;rsquo;s more important to deliver a message immediately even if it doesn&amp;rsquo;t fill up a bucket. &amp;ldquo;Help, fire!&amp;rdquo; is a very short message, but waiting to send it when you have a full load of messages might be the wrong thing.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s why modern operating systems also let you unbuffer specific filehandles. When you print to an unbuffered filehandle, the operating system will handle the message immediately. That doesn&amp;rsquo;t guarantee that whoever&amp;rsquo;s on the other side of the handle will respond immediately; there might be a pump and a trough there.&lt;/p&gt;

&lt;h4 id=&#34;what-s-the-damage&#34;&gt;What&amp;rsquo;s the Damage?&lt;/h4&gt;

&lt;p&gt;According to Mark-Jason Dominus&amp;rsquo; &lt;a href=&#34;http://perl.plover.com/FAQs/Buffering.html&#34;&gt;Suffering from Buffering?&lt;/a&gt;, one sample showed that buffered reading was 40% faster than unbuffered reading, and buffered writing was 60% faster. The latter number may only improve when considering network communications, where the overhead of sending and receiving a single packet of information can overwhelm short messages.&lt;/p&gt;

&lt;p&gt;In simple interactive applications though, there may be no benefit. When attached to a terminal, such as a command line, Perl operates in line-buffered mode. Run the following program and watch the output carefully:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/perl

use strict;
use warnings;

# buffer flushed at newline
loop_print( 5, &amp;quot;Line-buffered\n&amp;quot; );

# buffer not flushed until newline
loop_print( 5, &amp;quot;Buffered  &amp;quot; );
print &amp;quot;\n&amp;quot;;

# buffer flushed with every print
{
    local $| = 1;
    loop_print( 5, &amp;quot;Unbuffered  &amp;quot; );
}

sub loop_print
{
    my ($times, $message) = @_;

    for (1 .. $times)
    {
        print $message;
        sleep 1;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first five greetings appear individually and immediately. Perl flushes the buffer for STDOUT when it sees the newlines. The second set appears after five seconds, all at once, when it sees the newline after the loop. The third set appears individually and immediately because Perl flushes the buffer after every &lt;code&gt;print&lt;/code&gt; statement.&lt;/p&gt;

&lt;p&gt;Terminals are different from everything else, though. Consider the case of writing to a file. In one terminal window, create a file named &lt;em&gt;buffer.log&lt;/em&gt; and run &lt;code&gt;tail -f buffer.log&lt;/code&gt; or its equivalent to watch the growth of the file in real time. Then add the following lines to the previous program and run it again:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open( my $output, &#39;&amp;gt;&#39;, &#39;buffer.log&#39; ) or die &amp;quot;Can&#39;t open buffer.log: $!&amp;quot;;
select( $output );
loop_print( 5, &amp;quot;Buffered\n&amp;quot; );
{
      local $| = 1;
      loop_print( 5, &amp;quot;Unbuffered\n&amp;quot; );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first five messages appear in the log in a batch, all at once, even though they all have newlines. Five messages aren&amp;rsquo;t enough to fill the buffer. Perl only flushes it when it unbuffers the filehandle on assignment to &lt;code&gt;$|&lt;/code&gt;. The second set of messages appear individually, one second after another.&lt;/p&gt;

&lt;p&gt;Finally, the STDERR filehandle is hot by default. Add the following lines to the previous program and run it yet again:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select( STDERR );
loop_print( 5, &amp;quot;Unbuffered STDERR &amp;quot; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Though no code disables the buffer on STDERR, the five messages should print immediately, just as in the other unbuffered cases. (If they don&amp;rsquo;t, your OS is weird.)&lt;/p&gt;

&lt;h4 id=&#34;what-s-the-solution&#34;&gt;What&amp;rsquo;s the Solution?&lt;/h4&gt;

&lt;p&gt;Buffering exists for a reason; it&amp;rsquo;s almost always the right thing to do. When it&amp;rsquo;s the wrong thing to do, you can disable it. Here are some rules of thumb:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Never disable buffering by default.&lt;/li&gt;
&lt;li&gt;Disable buffering when and while you have multiple sources writing to the same output and their order matters.&lt;/li&gt;
&lt;li&gt;Never disable buffering for network outputs by default.&lt;/li&gt;
&lt;li&gt;Disable buffering for network outputs only when the expected time between full buffers exceeds the expected client timeout length.&lt;/li&gt;
&lt;li&gt;Don&amp;rsquo;t disable buffering on terminal outputs. For STDERR, it&amp;rsquo;s useless, dead code. For STDOUT, you probably don&amp;rsquo;t need it.&lt;/li&gt;
&lt;li&gt;Disable buffering if it&amp;rsquo;s more important to print messages regularly than efficiently.&lt;/li&gt;
&lt;li&gt;Don&amp;rsquo;t disable buffering until you know that the buffer is a problem.&lt;/li&gt;
&lt;li&gt;Disable buffering in the smallest scope possible.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Beginners Intro to Perl - Part 6</title>
      <link>http://localhost:1313/pub/2001/01/begperl6.html/</link>
      <pubDate>Tue, 09 Jan 2001 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2001/01/begperl6.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this venerable series is undergoing updates. You might be interested in the newer versions, available at:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2008/04/23/a-beginners-introduction-to-perl-510.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Perl 5.10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2008/05/07/beginners-introduction-to-perl-510-part-2.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Files and Strings with Perl 5.10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://news.oreilly.com/2008/06/a-beginners-introduction-to-pe.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Regular Expressions with Perl 5.10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://broadcast.oreilly.com/2008/09/a-beginners-introduction-to-pe.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Perl Web Programming&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Table of Contents&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;â¢&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/10/begperl1.html&#34;&gt;Part 1 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
â¢&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/11/begperl2.html&#34;&gt;Part 2 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
â¢&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/11/begperl3.html&#34;&gt;Part 3 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
â¢&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/12/begperl4.html&#34;&gt;Part 4 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
â¢&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/12/begperl5.html&#34;&gt;Part 5 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;br /&gt;
â¢&lt;a href=&#34;#doing%20it%20right%20the%20first%20time&#34;&gt;Doing It Right the First Time&lt;/a&gt;&lt;br /&gt;
â¢&lt;a href=&#34;#comments&#34;&gt;Comments&lt;/a&gt;&lt;br /&gt;
â¢&lt;a href=&#34;#warnings&#34;&gt;Warnings&lt;/a&gt;&lt;br /&gt;
â¢&lt;a href=&#34;#taint&#34;&gt;Taint&lt;/a&gt;&lt;br /&gt;
â¢&lt;a href=&#34;#stuff%20taint%20doesn&amp;#39;t%20catch&#34;&gt;Stuff Taint Doesn&#39;t Catch&lt;/a&gt;&lt;br /&gt;
â¢&lt;a href=&#34;#use%20strict&#34;&gt;&lt;code&gt;use strict&lt;/code&gt;&lt;/a&gt;&lt;br /&gt;
Â Â â¢&lt;a href=&#34;#strict%20vars&#34;&gt;Strict vars&lt;/a&gt;&lt;br /&gt;
Â Â â¢&lt;a href=&#34;#strict%20subs&#34;&gt;Strict subs&lt;/a&gt;&lt;br /&gt;
Â Â â¢&lt;a href=&#34;#want%20a%20sub,%20get%20a%20string&#34;&gt;Want a Sub, Get a String&lt;/a&gt;&lt;br /&gt;
Â Â â¢&lt;a href=&#34;#the%20one%20exception&#34;&gt;The One Exception&lt;/a&gt;&lt;br /&gt;
â¢&lt;a href=&#34;#is%20this%20overkill&#34;&gt;Is This Overkill?&lt;/a&gt;&lt;br /&gt;
â¢&lt;a href=&#34;#play%20around!&#34;&gt;Play Around!&lt;/a&gt;&lt;br /&gt;
&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;span-id-doing-it-right-the-first-time-doing-it-right-the-first-time-span&#34;&gt;&lt;span id=&#34;doing it right the first time&#34;&gt;Doing It Right the First Time&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;Perl is a useful tool, which many people use to write some good software. But like all programming languages, Perl can also be used to create &lt;em&gt;bad&lt;/em&gt; software. Bad software contains bugs, has security holes and is hard to fix or extend.&lt;/p&gt;

&lt;p&gt;Fortunately, Perl offers you many ways to increase the quality of the programs you write. In this last installment in the Beginner&amp;rsquo;s Intro series, we&amp;rsquo;ll take a look at a few of them.&lt;/p&gt;

&lt;h3 id=&#34;span-id-comments-comments-span&#34;&gt;&lt;span id=&#34;comments&#34;&gt;Comments&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In the first part of this series, we looked at the lowly &lt;code&gt;#&lt;/code&gt;, which indicates a comment. Comments are your first line of defense against bad software, because they help answer the two questions that people always have when they look at source code: What does this program do and how does it do it? Comments should &lt;em&gt;always&lt;/em&gt; be part of any software you write. Complex code with no comments is not &lt;em&gt;automatically&lt;/em&gt; evil, but bring some holy water just in case.&lt;/p&gt;

&lt;p&gt;Good comments are short, but instructive. They tell you things that aren&amp;rsquo;t clear from reading the code. For example, here&amp;rsquo;s some obscure code that could use a comment or two:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        for $i (@q) {
            my ($j) = fix($i);
            transmit($j);
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bad comments would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        for $i (@q) { # @q is list from last sub
            my ($j) = fix($i);  # Gotta fix $j...
            transmit($j);  # ...and then it goes over the wire
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that you don&amp;rsquo;t &lt;em&gt;learn&lt;/em&gt; anything from these comments. &lt;code&gt;my  ($j) = fix($i); # Gotta fix $j...&lt;/code&gt; is meaningless, the equivalent of a dictionary that contains a definition like &lt;em&gt;widget (n.): A widget&lt;/em&gt;. &lt;em&gt;What&lt;/em&gt; is &lt;code&gt;@q&lt;/code&gt;? &lt;em&gt;Why&lt;/em&gt; do you have to fix its values? That may be clear from the larger context of the program, but you don&amp;rsquo;t want to skip all around a program to find out what one little line does!&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s something a little clearer. Notice that we actually have &lt;em&gt;fewer&lt;/em&gt; comments, but they&amp;rsquo;re more instructive:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       # Now that we&#39;ve got prices from database, let&#39;s send them to the buyer
       for $i (@q) {
           my ($j) = fix($i);  # Add local taxes, perform currency exchange
           transmit($j);
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now it&amp;rsquo;s obvious where &lt;code&gt;@q&lt;/code&gt; comes from, and what &lt;code&gt;fix()&lt;/code&gt; does.&lt;/p&gt;

&lt;h3 id=&#34;span-id-warnings-warnings-span&#34;&gt;&lt;span id=&#34;warnings&#34;&gt;Warnings&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Comments are good, but the most important tool for writing good Perl is the ``warnings&amp;rdquo; flag, the &lt;code&gt;-w&lt;/code&gt; command line switch. You can turn on warnings by placing &lt;code&gt;-w&lt;/code&gt; on the first line of your programs like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;         #!/usr/local/bin/perl -w
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or, if you&amp;rsquo;re running a program from the command line, you can use &lt;code&gt;-w&lt;/code&gt; there, as in &lt;code&gt;perl -w myprogram.pl&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Turning on warnings will make Perl yelp and complain at a &lt;em&gt;huge&lt;/em&gt; variety of things that are almost always sources of bugs in your programs. Perl normally takes a relaxed attitude toward things that may be problems; it assumes that you know what you&amp;rsquo;re doing, even when you don&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an example of a program that Perl will be perfectly happy to run without blinking, even though it has an error on almost every line! (See how many you can spot.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       #!/usr/local/bin/perl

       $filename = &amp;quot;./logfile.txt&amp;quot;;
       open (LOG, $fn);
       print LOG &amp;quot;Test\n&amp;quot;;
       close LOGFILE;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, add the &lt;code&gt;-w&lt;/code&gt; switch to the first line, and run it again. You should see something like this:&lt;/p&gt;

&lt;p&gt;Name ``main::filename&amp;rdquo; used only once: possible typo at ./a6-warn.pl line 3. Name ``main::LOGFILE&amp;rdquo; used only once: possible typo at ./a6-warn.pl line 6. Name ``main::fn&amp;rdquo; used only once: possible typo at ./a6-warn.pl line 4. Use of uninitialized value at ./a6-warn.pl line 4. print on closed filehandle main::LOG at ./a6-warn.pl line 5.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s what each of these errors means:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Name ``main::filename&amp;rdquo; used only once: possible typo at ./a6-warn.pl line 3.&lt;/em&gt; and &lt;em&gt;Name ``main::fn&amp;rdquo; used only once: possible typo at ./a6-warn.pl line 4.&lt;/em&gt; Perl notices that &lt;code&gt;$filename&lt;/code&gt; and &lt;code&gt;$fn&lt;/code&gt; both only get used once, and guesses that you&amp;rsquo;ve misspelled or misnamed one or the other. This is because this almost always happens because of typos or bugs in your code, like using &lt;code&gt;$filenmae&lt;/code&gt; instead of &lt;code&gt;$filename&lt;/code&gt;, or using &lt;code&gt;$filename&lt;/code&gt; throughout your program except for one place where you use &lt;code&gt;$fn&lt;/code&gt; (like in this program).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;Name ``main::LOGFILE&amp;rdquo; used only once: possible typo at ./a6-warn.pl line 6.&lt;/em&gt; In the same way that we made our &lt;code&gt;$filename&lt;/code&gt; typo, we mixed up the names of our filehandles: We use &lt;code&gt;LOG&lt;/code&gt; for the filehandle while we&amp;rsquo;re writing the log entry, but we try to close &lt;code&gt;LOGFILE&lt;/code&gt; instead.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;Use of uninitialized value at ./a6-warn.pl line 4.&lt;/em&gt; This is one of Perl&amp;rsquo;s more cryptic complaints, but it&amp;rsquo;s not difficult to fix. This means that you&amp;rsquo;re trying to use a variable before you&amp;rsquo;ve assigned a value to it, and that is almost always an error. When we first mentioned &lt;code&gt;$fn&lt;/code&gt; in our program, it hadn&amp;rsquo;t been given a value yet. You can avoid this type of warning by always setting a &lt;em&gt;default&lt;/em&gt; value for a variable before you first use it.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;print on closed filehandle main::LOG at ./a6-warn.pl line 5.&lt;/em&gt; We didn&amp;rsquo;t successfully open &lt;code&gt;LOG&lt;/code&gt;, because &lt;code&gt;$fn&lt;/code&gt; was empty. When Perl sees that we are trying to print something to the &lt;code&gt;LOG&lt;/code&gt; filehandle, it would normally just ignore it and assume that we know what we&amp;rsquo;re doing. But when &lt;code&gt;-w&lt;/code&gt; is enabled, Perl warns us that it suspects there&amp;rsquo;s something afoot.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So, how do we fix these warnings? The first step, obviously, is to fix these problems in our script. (And while we&amp;rsquo;re at it, I deliberately violated our rule of always checking if &lt;code&gt;open()&lt;/code&gt; succeeded! Let&amp;rsquo;s fix that, too.) This turns it into:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        #!/usr/local/bin/perl -w

        $filename = &amp;quot;./logfile.txt&amp;quot;;
        open (LOG, $filename) or die &amp;quot;Couldn&#39;t open $filename: $!&amp;quot;;
        print LOG &amp;quot;Test\n&amp;quot;;
        close LOG;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we run our corrected program, and get this back from it:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Filehandle main::LOG opened only for input at ./a6-warn2.pl line 5.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Where did &lt;em&gt;this&lt;/em&gt; error come from? Look at our &lt;code&gt;open()&lt;/code&gt;. Since we&amp;rsquo;re not preceding the filename with &amp;gt; or &amp;gt;&amp;gt;, Perl opens the file for &lt;em&gt;reading&lt;/em&gt;, but in the next line we&amp;rsquo;re trying to &lt;em&gt;write&lt;/em&gt; to it with a &lt;code&gt;print&lt;/code&gt;. Perl will normally let this pass, but when warnings are in place, it alerts you to possible problems. Change line 4 to this instead and everything will be great:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       open (LOG, &amp;quot;&amp;gt;&amp;gt;$filename&amp;quot;) or die &amp;quot;Couldn&#39;t open $filename: $!&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;&amp;lt;-w&amp;gt;&lt;/code&gt; flag is your friend. Keep it on at all times. You may also want to read the &lt;code&gt;&amp;lt;perldiag&amp;gt;&lt;/code&gt; man page, which contains a listing of all the various messages (including warnings) Perl will spit out when it encounters a problem. Each message is accompanied by a detailed description of what the message means and how to fix it.&lt;/p&gt;

&lt;h3 id=&#34;span-id-taint-taint-span&#34;&gt;&lt;span id=&#34;taint&#34;&gt;Taint&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Using &lt;code&gt;-w&lt;/code&gt; will help make your Perl programs correct, but it won&amp;rsquo;t help make them &lt;em&gt;secure&lt;/em&gt;. It&amp;rsquo;s possible to write a program that doesn&amp;rsquo;t emit a single warning, but is totally insecure!&lt;/p&gt;

&lt;p&gt;For example, let&amp;rsquo;s say that you are writing a CGI program that needs to write a user&amp;rsquo;s comment to a user-specified file. You might use something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       #!/usr/local/bin/perl -w

       use CGI &#39;:standard&#39;;

       $file = param(&#39;file&#39;);
       $comment = param(&#39;comment&#39;);

       unless ($file) { $file = &#39;file.txt&#39;; }
       unless ($comment) { $comment = &#39;No comment&#39;; }

       open (OUTPUT, &amp;quot;&amp;gt;&amp;gt;/etc/webstuff/storage/&amp;quot; . $file) or die &amp;quot;$!&amp;quot;;
       print OUTPUT $comment . &amp;quot;\n&amp;quot;;
       close OUTPUT;

       print header, start_html;
       print &amp;quot;&amp;lt;P&amp;gt;Thanks!&amp;lt;/P&amp;gt;\n&amp;quot;;       
       print end_html;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you read the CGI programming installment, alarm bells are already ringing loud enough to deafen you. This program trusts the user to specify only a ``correct&amp;rdquo; filename, and you know better than to trust the user. But nothing in this program will cause &lt;code&gt;-w&lt;/code&gt; to bat an eye; as far as warnings are concerned, this program is completely correct.&lt;/p&gt;

&lt;p&gt;Fortunately, there&amp;rsquo;s a way to block these types of bugs before they become a problem. Perl offers a mechanism called &lt;em&gt;taint&lt;/em&gt; that marks any variable that the user can possibly control as being insecure. This includes user input, file input and environment variables. Anything that you set within your own program is considered safe:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     $taint = &amp;lt;STDIN&amp;gt;;   # This came from user input, so it&#39;s tainted
     $taint2 = $ARGV[1]; # The @ARGV array is considered tainted too.
     $notaint = &amp;quot;Hi&amp;quot;;    # But this is in your program... it&#39;s untainted
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You enable taint checking with the &lt;code&gt;-T&lt;/code&gt; flag, which you can combine with &lt;code&gt;-w&lt;/code&gt; like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      #!/usr/local/bin/perl -Tw
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-T&lt;/code&gt; will prevent Perl from running most code that may be insecure. If you try to do various dangerous things with tainted variables, like open a file for writing or use the &lt;code&gt;system()&lt;/code&gt; or &lt;code&gt;exec()&lt;/code&gt; functions to run external commands, Perl will stop right away and complain.&lt;/p&gt;

&lt;p&gt;You &lt;em&gt;untaint&lt;/em&gt; a variable by running it through a regex with matching subexpressions, and using the results from the subexpressions. Perl will consider &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt; and so forth to be safe for your program.&lt;/p&gt;

&lt;p&gt;For example, our file-writing CGI program may expect that ``sane&amp;rdquo; filenames contain only the alphanumeric characters that are matched by the &lt;code&gt;\w&lt;/code&gt; metacharacter (this would prevent a malicious user from passing a filename like &lt;code&gt;~/.bashrc&lt;/code&gt;, or even &lt;code&gt;../test&lt;/code&gt;). We&amp;rsquo;d use a filter like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       $file = param(&#39;file&#39;);
       if ($file) {
           $file =~ /^(\w+)$/;
           $file = $1;
       }

       unless ($file) { $file = &amp;quot;file.txt&amp;quot;; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, &lt;code&gt;$file&lt;/code&gt; is guaranteed to be untainted. If the user passed us a filename, we don&amp;rsquo;t use it until we&amp;rsquo;ve made sure it matches only &lt;code&gt;\w+&lt;/code&gt;. If there was no filename, then we specify a default in our program. As for &lt;code&gt;$comment&lt;/code&gt;, we never actually do anything that would cause Perl&amp;rsquo;s taint checking to worry, so it doesn&amp;rsquo;t need to be checked to pass &lt;code&gt;-T&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-stuff-taint-doesn-t-catch-stuff-taint-doesn-t-catch-span&#34;&gt;&lt;span id=&#34;stuff taint doesn&#39;t catch&#34;&gt;Stuff Taint Doesn&amp;rsquo;t Catch&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Be careful! Even when you&amp;rsquo;ve turned on taint checking, you can still write an insecure program. Remember that taint only gets looked at when you try to &lt;em&gt;modify&lt;/em&gt; the system, by opening a file or running a program. Reading from a file will not trigger taintedness! A &lt;em&gt;very&lt;/em&gt; common breed of security hole exploits code that doesn&amp;rsquo;t look very different from this small program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        #!/usr/local/bin/perl -Tw

        use CGI &#39;:standard&#39;;

        $file = param(&#39;filename&#39;);
        unless ($file) { $file = &#39;file.txt&#39;; }

        open (FILE, &amp;quot;&amp;lt;/etc/webstuff/storage/&amp;quot; . $file) or die &amp;quot;$!&amp;quot;;

        print header();
        while ($line = &amp;lt;FILE&amp;gt;) {
            print $line;
        }

        close FILE;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just imagine the joy when the ``filename&amp;rdquo; parameter contains &lt;code&gt;../../../../../../etc/passwd&lt;/code&gt;. (If you don&amp;rsquo;t see the problem: On a Unix system, the &lt;code&gt;/etc/passwd&lt;/code&gt; file contains a list of all the usernames on the system, and may also contain an encrypted list of their passwords. This is great information for crackers who want to get into a machine for further mischief.) Since you are only reading the file, Perl&amp;rsquo;s taint checking doesn&amp;rsquo;t kick in. Similarly, &lt;code&gt;print&lt;/code&gt; doesn&amp;rsquo;t trigger taint checking, so you&amp;rsquo;ll have to write your own value-checking code when you write any user input to a file!&lt;/p&gt;

&lt;p&gt;Taint is a good &lt;em&gt;first&lt;/em&gt; step in security, but it&amp;rsquo;s not the last.&lt;/p&gt;

&lt;h3 id=&#34;span-id-use-strict-use-strict-span&#34;&gt;&lt;span id=&#34;use strict&#34;&gt;&lt;code&gt;use strict&lt;/code&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Warnings and taint are two excellent tools for preventing your programs from doing bad things. If you want to go &lt;em&gt;further&lt;/em&gt;, Perl offers &lt;code&gt;use  strict&lt;/code&gt;. These two simple words can be put at the beginning of any program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        #!/usr/local/bin/perl -wT

        use strict;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A command like &lt;code&gt;use strict&lt;/code&gt; is called a &lt;em&gt;pragma&lt;/em&gt;. Pragmas are instructions to the Perl interpreter to do something special when it runs your program. &lt;code&gt;use strict&lt;/code&gt; does two things that make it harder to write bad software: It makes you declare all your variables (``strict vars&amp;rdquo;), and it makes it harder for Perl to mistake your intentions when you are using subs (``strict subs&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;If you only want to use one or two types of strictness in your program, you can list them in the &lt;code&gt;use strict&lt;/code&gt; pragma, or you can use a special &lt;code&gt;no strict&lt;/code&gt; pragma to turn off any or all of the strictness you enabled earlier.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        use strict &#39;vars&#39;;   # We want to require variables to be declared
        no strict &#39;vars&#39;;    # We&#39;ll go back to normal variable rules now

        use strict &#39;subs&#39;;   # We want Perl to distrust barewords (see below).

        no strict;           # Turn it off. Turn it all off. Go away, strict.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(There&amp;rsquo;s actually a third type of strictness - strict refs - which prevents you from using symbolic references. Since we haven&amp;rsquo;t really dealt with references, we&amp;rsquo;ll concentrate on the other two types of strictness.)&lt;/p&gt;

&lt;h3 id=&#34;span-id-strict-vars-strict-vars-span&#34;&gt;&lt;span id=&#34;strict vars&#34;&gt;Strict vars&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Perl is generally trusting about variables. It will alllow you to create them out of thin air, and that&amp;rsquo;s what we&amp;rsquo;ve been doing in our programs so far. One way to make your programs more correct is to use &lt;em&gt;strict vars&lt;/em&gt;, which means that you must always &lt;em&gt;declare&lt;/em&gt; variables before you use them. You declare variables by using the &lt;code&gt;my&lt;/code&gt; keyword, either when you assign values to them or before you first mention them:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        my ($i, $j, @locations);
        my $filename = &amp;quot;./logfile.txt&amp;quot;;
        $i = 5;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This use of &lt;code&gt;my&lt;/code&gt; doesn&amp;rsquo;t interfere with using it elsewhere, like in subs, and remember that a &lt;code&gt;my&lt;/code&gt; variable in a sub will be used instead of the one from the rest of your program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        my ($i, $j, @locations);
        # ... stuff skipped ...
        sub fix {
            my ($q, $i) = @_;  # This doesn&#39;t interfere with the program $i!
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you end up using a variable &lt;em&gt;without&lt;/em&gt; declaring it, you&amp;rsquo;ll see an error before your program runs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        use strict;
        $i = 5;
        print &amp;quot;The value is $i.\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you try to run this program, you see an error message similar to &lt;em&gt;Global symbol ``$i&amp;rdquo; requires explicit package name at a6-my.pl line 3.&lt;/em&gt; You fix this by declaring &lt;code&gt;$i&lt;/code&gt; in your program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        use strict;
        my $i = 5;   # Or &amp;quot;my ($i); $i = 5;&amp;quot;, if you prefer...
        print &amp;quot;The value is $i.\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Keep in mind that &lt;em&gt;some&lt;/em&gt; of what strict vars does will overlap with the &lt;code&gt;-w&lt;/code&gt; flag, but not all of it. Using the two together makes it much more difficult, but not impossible, to use an incorrect variable name. For example, strict vars &lt;em&gt;won&amp;rsquo;t&lt;/em&gt; catch it if you accidentally use the &lt;em&gt;wrong&lt;/em&gt; variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;         my ($i, $ii) = (1, 2);
         print &#39;The value of $ii is &#39;, $i, &amp;quot;\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code has a bug, but neither strict vars nor the &lt;code&gt;-w&lt;/code&gt; flag will catch it.&lt;/p&gt;

&lt;h3 id=&#34;span-id-strict-subs-strict-subs-span&#34;&gt;&lt;span id=&#34;strict subs&#34;&gt;Strict subs&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;During the course of this series, I&amp;rsquo;ve deliberately avoided mentioning all sorts of tricks that allow you to write more &lt;em&gt;compact&lt;/em&gt; Perl. This is because of a simple rule: &lt;em&gt;readability always wins&lt;/em&gt;. Not only can compactness make it difficult to read code, it can sometimes have weird side effects! The way Perl looks up subs in your program is an example. Take a look at this pair of three-line programs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       $a = test_value;
       print &amp;quot;First program: &amp;quot;, $a, &amp;quot;\n&amp;quot;;
       sub test_value { return &amp;quot;test passed&amp;quot;; }

       sub test_value { return &amp;quot;test passed&amp;quot;; }
       $a = test_value;
       print &amp;quot;Second program: &amp;quot;, $a, &amp;quot;\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The same program with one little, insignificant line moved, right? In both cases we have a &lt;code&gt;test_value()&lt;/code&gt; sub and we want to put its result into &lt;code&gt;$a&lt;/code&gt;. And yet, when we run the two programs, we get two different results:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       First program&#39;s result: test_value
       Second program&#39;s result: test passed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reason &lt;em&gt;why&lt;/em&gt; we get two different results is a little convoluted.&lt;/p&gt;

&lt;p&gt;In the first program, at the point we get to &lt;code&gt;$a = test_value;&lt;/code&gt;, Perl doesn&amp;rsquo;t know of any &lt;code&gt;test_value()&lt;/code&gt; sub, because it hasn&amp;rsquo;t gotten that far yet. This means that &lt;code&gt;test_value&lt;/code&gt; is interpreted as if it were the string &amp;lsquo;test_value&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;In the second program, the definition of &lt;code&gt;test_value()&lt;/code&gt; comes &lt;em&gt;before&lt;/em&gt; the &lt;code&gt;$a = test_value;&lt;/code&gt; line. Since Perl has a &lt;code&gt;test_value()&lt;/code&gt; sub to call, that&amp;rsquo;s what it thinks &lt;code&gt;test_value&lt;/code&gt; means.&lt;/p&gt;

&lt;p&gt;The technical term for isolated words like &lt;code&gt;test_value&lt;/code&gt; that might be subs and might be strings depending on context, by the way, is &lt;em&gt;bareword&lt;/em&gt;. Perl&amp;rsquo;s handling of barewords can be confusing, and it can cause two different types of bug.&lt;/p&gt;

&lt;h3 id=&#34;span-id-want-a-sub-get-a-string-want-a-sub-get-a-string-span&#34;&gt;&lt;span id=&#34;want a sub, get a string&#34;&gt;Want a Sub, Get a String&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The first type of bug is what we encountered in our first program, which I&amp;rsquo;ll repeat here:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        $a = test_value;
        print &amp;quot;First program: &amp;quot;, $a, &amp;quot;\n&amp;quot;;
        sub test_value { return &amp;quot;test passed&amp;quot;; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remember that Perl won&amp;rsquo;t look forward to find &lt;code&gt;test_value()&lt;/code&gt;, so since it hasn&amp;rsquo;t &lt;em&gt;already&lt;/em&gt; seen &lt;code&gt;test_value()&lt;/code&gt;, it assumes that you want a string. Strict subs will cause this program to die with an error:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        use strict;

        my $a = test_value;
        print &amp;quot;Third program: &amp;quot;, $a, &amp;quot;\n&amp;quot;;
        sub test_value { &amp;quot;test passed&amp;quot;; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Notice the &lt;code&gt;my&lt;/code&gt; put in to make sure that strict vars won&amp;rsquo;t complain about &lt;code&gt;$a&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;Now you get an error message like &lt;em&gt;Bareword ``test_value&amp;rdquo; not allowed while ``strict subs&amp;rdquo; in use at ./a6-strictsubs.pl line 3.&lt;/em&gt; This is easy to fix, and there are two ways to do it:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Use parentheses to make it clear you&amp;rsquo;re calling a sub. If Perl sees &lt;code&gt;$a = test_value();&lt;/code&gt;, it will assume that even if it hasn&amp;rsquo;t seen &lt;code&gt;test_value()&lt;/code&gt; defined yet, it will sometime between now and the end of the program. (If there isn&amp;rsquo;t any &lt;code&gt;test_value()&lt;/code&gt; in your program, Perl will die while it&amp;rsquo;s running.) This is the easiest thing to do, and often the most readable.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Declare your sub before you first use it, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use strict;

    sub test_value;  # Declares that there&#39;s a test_value() coming later ...
    my $a = test_value;  # ...so Perl will know this line is okay.
    print &amp;quot;Fourth program: &amp;quot;, $a, &amp;quot;\n&amp;quot;;
    sub test_value { return &amp;quot;test_passed&amp;quot;; }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Declaring your subs has the advantage of allowing you to maintain the &lt;code&gt;$a =  test_value;&lt;/code&gt; syntax if that&amp;rsquo;s what you find more readable, but it&amp;rsquo;s also a little obscure. Other programmers may not see why you have &lt;code&gt;sub  test_value;&lt;/code&gt; in your code.&lt;/p&gt;

&lt;p&gt;Of course, you could always move the definition of your sub &lt;em&gt;before&lt;/em&gt; the line where you want to call it. This isn&amp;rsquo;t quite as good as either of the other two methods, because now you are moving code around instead of making your existing code clearer. Also, it can cause &lt;em&gt;other&lt;/em&gt; problems, which we&amp;rsquo;ll discuss now &amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;span-id-want-a-string-get-a-sub-want-a-string-get-a-sub-span&#34;&gt;&lt;span id=&#34;want a string, get a sub&#34;&gt;Want a String, Get a Sub&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ve seen how &lt;code&gt;use strict&lt;/code&gt; can help prevent an error where you intend to call a sub, but instead get a string value. It also helps prevent the opposite error: wanting a string value, but calling a sub instead. This is a more dangerous class of bug, because it can be &lt;em&gt;very&lt;/em&gt; hard to trace, and it often pops up in the most unexpected places. Take a look at this excerpt from a long program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        #!/usr/local/bin/perl -Tw

        use strict;

        use SomeModule;
        use SomeOtherModule;
        use YetAnotherModule;

        # ... (and then there&#39;s hundreds of lines of code) ...

        # Now we get to line 400 of the program, which tests if we got an &amp;quot;OK&amp;quot;
        # before we act on a request from the user.
        if ($response_code eq OK) {
            act_on($request);
        } else {
            throw_away($request);
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This program works without a hitch for a long time, because Perl sees the bareword &lt;code&gt;OK&lt;/code&gt; and considers it to be a literal string. Then, two years later someone needs to add code to make this program understand HTTP status codes. They stick this in at line 2, or line 180, or line 399 (it doesn&amp;rsquo;t matter &lt;em&gt;exactly&lt;/em&gt; where, just that it comes before line 400):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        sub OK { return 200; } # HTTP &amp;quot;request ok, response follows&amp;quot; code
        sub NOT_FOUND { return 404; } # &amp;quot;URL not found&amp;quot; code
        sub SERVER_ERROR { return 500; } # &amp;quot;Server can&#39;t handle request&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Take a moment to guess what happens to our program now. Try to work the word ``disaster&amp;rdquo; into it.&lt;/p&gt;

&lt;p&gt;Thanks to this tiny change, our program now throws away every request that comes in to it. The &lt;code&gt;if ($response eq OK)&lt;/code&gt; test now calls the &lt;code&gt;OK()&lt;/code&gt; sub, which returns a value of 200. The &lt;code&gt;if&lt;/code&gt; now fails every time! The programmer, if they still have a job after this fiasco, must hunt through the entire program to find out exactly when the behavior of &lt;code&gt;if ($response eq OK)&lt;/code&gt; changed, and why.&lt;/p&gt;

&lt;p&gt;By the way, if the programmer is &lt;em&gt;really&lt;/em&gt; unlucky, that new &lt;code&gt;OK()&lt;/code&gt; sub wouldn&amp;rsquo;t even be in &lt;em&gt;their&lt;/em&gt; code at all, but defined somewhere in a new version of &lt;code&gt;SomeOtherModule.pm&lt;/code&gt; that just got installed!&lt;/p&gt;

&lt;p&gt;Barewords are dangerous because of this unpredictable behavior. &lt;code&gt;use  strict&lt;/code&gt; (or &lt;code&gt;use strict &#39;subs&#39;&lt;/code&gt;) makes them predictable, because barewords that might cause strange behavior in the future will make your program die before they can wreak havoc.&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-one-exception-the-one-exception-span&#34;&gt;&lt;span id=&#34;the one exception&#34;&gt;The One Exception&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;There&amp;rsquo;s &lt;em&gt;one&lt;/em&gt; place where it&amp;rsquo;s OK to use barewords even when you&amp;rsquo;ve turned on strict subs: when you are assigning hash keys.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        $hash{sample} = 6;   # Same as $hash{&#39;sample&#39;} = 6
        %other_hash = ( pie =&amp;gt; &#39;apple&#39; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Barewords in hash keys are always interpreted as strings, so there is no ambiguity.&lt;/p&gt;

&lt;h3 id=&#34;span-id-is-this-overkill-is-this-overkill-span&#34;&gt;&lt;span id=&#34;is this overkill&#34;&gt;Is This Overkill?&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;There are times when using all of the quality enforcement functionality (or ``correctness police,&amp;rdquo; if you like to anthropmorphize) Perl offers seems like overkill. If you&amp;rsquo;re just putting together a quick, three-line tool that you&amp;rsquo;ll use once and then never touch again, you probably don&amp;rsquo;t care about whether it&amp;rsquo;ll run properly under &lt;code&gt;use strict&lt;/code&gt;. When you&amp;rsquo;re the only person who will run a program, you generally don&amp;rsquo;t care if the &lt;code&gt;-T&lt;/code&gt; flag will show that you&amp;rsquo;re trying to do something unsafe with a piece of user input.&lt;/p&gt;

&lt;p&gt;Still, it&amp;rsquo;s a good idea to use every tool at your disposal to write good software. Here are three reasons to be concerned about correctness when you write just about &lt;em&gt;anything&lt;/em&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;One-off programs aren&amp;rsquo;t.&lt;/em&gt; There are few programs worth writing that only get run once. Software tools tend to accumulate, and get used. You&amp;rsquo;ll find that the more you use a program, the more you want it to do.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;Other people will read your code.&lt;/em&gt; Whenever programmers write something really good, they tend to keep it around, and give it to friends who have the same problem. More importantly, most projects aren&amp;rsquo;t one-person jobs; there are teams of programmers who need to work together, reading, fixing and extennding one another&amp;rsquo;s code. Unless your plans for the future include always working alone and having no friends, you should expect that other people will someday read and modify your code.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;*&lt;strong&gt;You&lt;/strong&gt; will read your code.* Don&amp;rsquo;t think you have a special advantage in understanding your code just because you wrote it! Often you&amp;rsquo;ll need to go back to software you wrote months or even years earlier to fix it or extend it. During that time you&amp;rsquo;ll have forgotten all those clever little tricks you came up with during that caffeine-fueled all-nighter and all the little gotchas that you noticed but thought you would fix later.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These three points all have one thing in common: Your programs &lt;em&gt;will&lt;/em&gt; be rewritten and enhanced by people who will appreciate every effort you make to make their job easier. When you make sure your code is readable and correct, it tends to start out much more secure and bug-free, and it tends to stay that way, too!&lt;/p&gt;

&lt;h3 id=&#34;span-id-play-around-play-around-span&#34;&gt;&lt;span id=&#34;play around!&#34;&gt;Play Around!&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;During the course of this series, we&amp;rsquo;ve only scratched the surface of what Perl can do. Don&amp;rsquo;t take these articles as being definitive - they&amp;rsquo;re just an introduction! Read the &lt;code&gt;perlfunc&lt;/code&gt; page to learn about all of Perl&amp;rsquo;s built-in functions and see what ideas they inspire. My biography page tells you how to get in touch with me if you have any questions.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

