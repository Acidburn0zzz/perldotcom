<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Simon Cozens on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/authors/simon-cozens/</link>
    <description>Recent content in Simon Cozens on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 02 Nov 2006 00:00:00 -0800</lastBuildDate>
    <atom:link href="/authors/simon-cozens/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Hash Crash Course</title>
      <link>http://localhost:1313/pub/2006/11/02/all-about-hashes.html/</link>
      <pubDate>Thu, 02 Nov 2006 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2006/11/02/all-about-hashes.html/</guid>
      <description>

&lt;p&gt;When I teach about hashes, I do what most Perl tutors and tutorials do: I introduce the hash as a &amp;ldquo;dictionary&amp;rdquo;: a mapping between one thing and another. The classic example, for instance, is to have a set of English words mapped to French words:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %french = (
        apple  =&amp;gt; &amp;quot;pomme&amp;quot;,
        pear   =&amp;gt; &amp;quot;poivre&amp;quot;,
        orange =&amp;gt; &amp;quot;Leon Brocard&amp;quot;
    );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yet the more I look at my code&amp;ndash;and more often, the more I look at how to tidy up other people&amp;rsquo;s code&amp;ndash;I realize that this is perhaps the least common use of a hash. Much more often, I use hashes in particular idioms which have very little in common with this concept of a mapping. It&amp;rsquo;s interesting to consider the ways that programmers &lt;em&gt;actually&lt;/em&gt; use hashes in Perl code.&lt;/p&gt;

&lt;h3 id=&#34;counting&#34;&gt;Counting&lt;/h3&gt;

&lt;p&gt;Many of the uses of hashes are to &amp;ldquo;answer questions about lists.&amp;rdquo; When you have an array or list of values and you need to ask about its properties, you will often find yourself using a hash. Start simply by counting the number of particular elements in a list. Here&amp;rsquo;s the na√Øve approach:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $count = 0;
    for (@list) {
        $count++ if $_ eq &amp;quot;apple&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can smarten this up with the use of the &lt;code&gt;grep&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $count = grep $_ eq &amp;quot;apple&amp;quot;, @list;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; but when you need the number of pears in the list, then you have to do the same again:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $count_apples = grep $_ eq &amp;quot;apple&amp;quot;, @list;
    $count_pears  = grep $_ eq &amp;quot;pear&amp;quot;,  @list;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now there are two passes over the list, and the situation isn&amp;rsquo;t going to get any prettier from here. What you want is basically a histogram of the data, and you can get that with a hash:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my %histogram;
    $histogram{$_}++ for @list;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This hash associates each individual item with its count, and it only traverses the list once.&lt;/p&gt;

&lt;p&gt;In a recent case, I was looking at a list of tags associated with various photographs. To lay out the data for display, it was useful to know how many different tags there are in the list. I could get that simply from the number of keys in the histogram:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $unique = keys %histogram;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I could also delete the duplicates and end up with a list of the unique tags:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @unique = keys %histogram;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, I could show the five most popular tags from the list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @popular = 
        (sort { $histogram{$b} &amp;lt;=&amp;gt; $histogram{$b} } @unique)[0..4];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This sorts the list of unique tags based on their popularity in the original list, and pulls out the top five.&lt;/p&gt;

&lt;h3 id=&#34;uniqueness&#34;&gt;Uniqueness&lt;/h3&gt;

&lt;p&gt;Another idiom to get the unique elements from a list is a variation on the &amp;ldquo;counting things&amp;rdquo; idiom; but this time you don&amp;rsquo;t care how many of each item there is, just that there&amp;rsquo;s at least one. This allows you to say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for (@list) { $unique{$_} = 1 }
    @unique = keys %unique;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which reduces to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %unique = map { $_ =&amp;gt; 1 } @list;
    @unique = keys %unique;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can take this a stage further with a slightly non-standard idiom to do the whole thing in one operation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @unique = keys %{{ map { $_ =&amp;gt; 1 } @list }};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;keys&lt;/code&gt; requires a hash, so this funny-looking line creates an anonymous hash (&lt;code&gt;{ map ... @list }&lt;/code&gt;) and then turns it into a real hash (&lt;code&gt;%{ $hash_ref }&lt;/code&gt;) to feed it to &lt;code&gt;keys&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The advantage of this trick is that you can use a variation of it to work with lists which include objects as well as ordinary scalars. Here&amp;rsquo;s an example of the problem:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @tags;
    push @tags, Memories::Tag-&amp;gt;retrieve_random for 1..10;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This should get ten random &lt;code&gt;Memories::Tag&lt;/code&gt; objects. However, some of them might be the same, and, assuming that you want to see the unique ones:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %unique = map { $_ =&amp;gt; 1 } @tags;
    @unique = keys %unique;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unfortunately, if you then try to do anything with the tags, it all goes horribly wrong:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print $unique[0]-&amp;gt;name;

    # Can&#39;t locate object method &amp;quot;test&amp;quot; via package &amp;quot;Memories::Tag(0x1801380)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What&amp;rsquo;s happened is that hash keys can only be strings; once you put the object into a hash as the key, then it&amp;rsquo;s not an object any more. Perl turns it into a string. There&amp;rsquo;s no (easy) way to get the strings back into an object. What you need is some kind of data structure to map these broken strings into the original objects. Thankfully, there is one in the form of the hash itself! So the code becomes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %unique = map { $_ =&amp;gt; $_ } @tags;
    @unique = values %unique;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, map the object&amp;ndash;which Perl will smash into a string&amp;ndash;with another copy of the object, which will retain its object-ness. Then instead of getting the strings out of the hash, which are useless to us, you get the objects.&lt;/p&gt;

&lt;p&gt;Of course, this doesn&amp;rsquo;t quite work, because even if &lt;code&gt;retrieve_random&lt;/code&gt; retrieves the same tag name twice, it will return two different objects with the same data. (That&amp;rsquo;s true unless the underlying database abstraction layer uses caching, which is another good use for a hash.)&lt;/p&gt;

&lt;p&gt;The solution is to make the list unique based on a property of the tag, such as its name. This time, the code is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %unique = map { $_-&amp;gt;name =&amp;gt; $_ } @tags;
    @unique = values %unique;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Okay, now you have a list of objects which you&amp;rsquo;ve retrieved randomly, but which have unique names. The only problem is that you retrieved ten of them to start with, and then whittled the list down to get rid of duplicates. What if you actually wanted 10?&lt;/p&gt;

&lt;p&gt;The solution is to keep track of ones that you&amp;rsquo;ve already seen, so that you don&amp;rsquo;t create any duplicates in the first place. The question &amp;ldquo;Have I seen this before?&amp;rdquo; is easy to answer using another hash-based idiom:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @tags;
    my %seen;
    while (@tags &amp;lt; 10) {
        my $candidate = Memories::Tag-&amp;gt;retrieve_random;
        next if $seen{$candidate-&amp;gt;name}++;
        push @tags, $candidate;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once again you&amp;rsquo;re collecting unique values by putting them into a hash. Suppose that the first candidate tag that comes along is &lt;code&gt;japan&lt;/code&gt;. At this point the hash is empty, and so &lt;code&gt;$seen{japan}&lt;/code&gt; is zero. Because it&amp;rsquo;s zero, the code continues through the loop with &lt;code&gt;next&lt;/code&gt;, but still increments the hash value. Now &lt;code&gt;$seen{japan}&lt;/code&gt; stands at 1, and the tag goes into the list. If &lt;code&gt;japan&lt;/code&gt; comes past again, &lt;code&gt;$seen{japan}&lt;/code&gt; will be positive so the &lt;code&gt;next&lt;/code&gt; code will activate, and the tag will not go into the list again. (Don&amp;rsquo;t try this if you have fewer than 10 distinct tags, of course!)&lt;/p&gt;

&lt;h3 id=&#34;caching&#34;&gt;Caching&lt;/h3&gt;

&lt;p&gt;A special case of &amp;ldquo;have I seen this before?&amp;rdquo; comes when you want to create a cache: if I have seen this before, what was the answer I saw last time? Here&amp;rsquo;s how to do that.&lt;/p&gt;

&lt;p&gt;I mentioned that the underlying database abstraction layer in the tags example might cache look-ups and return the same object if you requested the same tag multiple times:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my %cache;

    sub retrieve {
        my ($self, $id) = @_;
        return $cache{$id} if exists $cache{$id};
        return $cache{$id} = $self-&amp;gt;_hard_retrieve($id);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This checks to see if it has seen the &lt;code&gt;$id&lt;/code&gt; before; if so have, return the value from the hash. If not, work out what the value should be, then store it in the hash for next time, then return the whole lot.&lt;/p&gt;

&lt;p&gt;Of course, for heavy-duty applications like a database abstraction layer, you need to do a little more work, such as pruning the cache to make sure it doesn&amp;rsquo;t get out of date or get so full of data that it eats all your memory. The &lt;a href=&#34;https://metacpan.org/pod/Cache::Cache&#34;&gt;Cache::Cache&lt;/a&gt; suite of modules from CPAN takes care of all of this for you, and the core &lt;a href=&#34;https://metacpan.org/pod/Memoize&#34;&gt;Memoize&lt;/a&gt; module adds this kind of caching to a function without you specifically having to write the cache-getting and -setting code.&lt;/p&gt;

&lt;h3 id=&#34;searching&#34;&gt;Searching&lt;/h3&gt;

&lt;p&gt;Finally, you can use hashes for searching.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;ve done any computer science, you&amp;rsquo;ll probably know about a couple of common searching algorithms. (Even if you haven&amp;rsquo;t, they&amp;rsquo;re so common that you&amp;rsquo;ve probably reinvented them without knowing it.) One is linear search, where you start at the beginning of a list and work your way toward the end, looking for the target item:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $index;
    for $index (0..@chambers) {
        last if $chambers[$index] == $bullet;
    }
    print &amp;quot;Found at index $index&amp;quot; if $index &amp;lt; @chambers;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another is binary search, where you start in the middle of a sorted list, and work out whether you should go higher or lower than the current element, like players in some demented version of &lt;em&gt;Card Sharks&lt;/em&gt;. This is basically the way to look up names in a phone book&amp;ndash;it&amp;rsquo;s faster, but a bit more complicated to implement:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @names = qw(Able Baker Charlie Dog ...);
    my $index;

    my $target = &amp;quot;Roger&amp;quot;;

    sub search {
        my ($lower, $upper) = (0, $#names);
        while ($lower &amp;lt;= $upper) {
            my $index = ($lower + $upper) / 2;
            if ($names[$index] lt $target) {
                $lower = $index + 1;
            } elsif ($names[$index] gt $target) {
                $upper = $index--1;
            } else { return $index }
        }
        # Not found!
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This starts in the middle, at &amp;ldquo;Mike&amp;rdquo;. &amp;ldquo;Go higher!&amp;rdquo; shouts the crowd, so it goes half-way between there and the end, to &amp;ldquo;Tare&amp;rdquo;. Then it needs to go lower, so looks half-way between &amp;ldquo;Mike&amp;rdquo; and &amp;ldquo;Tare&amp;rdquo; and gets to &amp;ldquo;Peter&amp;rdquo;. Now it needs to go higher again, between &amp;ldquo;Peter&amp;rdquo; and &amp;ldquo;Tare&amp;rdquo;, and finds &amp;ldquo;Roger&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;That takes four comparisons, which is not bad. Can you do it any better? How about&amp;hellip; oh, none?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my %search = map { $names[$_] =&amp;gt; $_ } 0..$#names;
    print $names{&amp;quot;Roger&amp;quot;};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I&amp;rsquo;m cheating somewhat here because setting up the hash requires iterating over the whole array, but once you&amp;rsquo;ve done that, the searches are basically free.&lt;/p&gt;

&lt;p&gt;Of course, if you need to look up an array index by its contents, then maybe you&amp;rsquo;re doing something wrong in the first place, and should have used a hash to start with. Consider, for instance, in a configuration file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    force-v3-sigs
    escape-from-lines
    lock-once
    load-extension rndlinux
    keyserver wwwkeys.eu.pgp.net
    keyserver the.earth.li
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Yes, that&amp;rsquo;s from GnuPG.) Each line has a key and optionally a value, but you can have multiple values for each key. At the end of the day, you might want to look through and say &amp;ldquo;tell me all the keyservers&amp;rdquo;&amp;ndash;but not just the keyservers, you want to read the whole config in and be able to say that about any key. That&amp;rsquo;s a search problem, and a tricky one. Here&amp;rsquo;s one solution:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    while (&amp;lt;&amp;gt;) {
        chomp;
        my ($key, $value) = split /\s+/, $_, 2;
        push @config, [$key, $value];
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you have to say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @keyservers = map { $_-&amp;gt;[1] } grep { $_-&amp;gt;[0] eq &amp;quot;keyserver&amp;quot; } @config;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is actually a linear search in disguise. (&lt;code&gt;grep&lt;/code&gt; does a linear search for you.)&lt;/p&gt;

&lt;p&gt;With hashes, the issue is much simpler:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    while (&amp;lt;&amp;gt;) {
        chomp;
        my ($key, $value) = split /\s+/, $_, 2;
        push @{$config{$key}}, $value;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This treats every key as a separate array reference, and pushes values into that array. Now to retrieve the list of keyservers, just look up the array inside the hash:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @keyservers = @{$config{&amp;quot;keyservers&amp;quot;}};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This process is very remniscient of the final pattern&amp;ndash;using a hash as a portable symbol table.&lt;/p&gt;

&lt;h3 id=&#34;dispatch-tables&#34;&gt;Dispatch Tables&lt;/h3&gt;

&lt;p&gt;Instead of having the configuration reader create a bunch of arrays&amp;ndash;&lt;code&gt;@keyservers&lt;/code&gt;, &lt;code&gt;@load_extension&lt;/code&gt; and so on&amp;ndash;I created a hash which held the arrays so as to look them up indirectly but more efficiently. In effect, instead of using the Perl symbol table, you can use a hash as a portable symbol table.&lt;/p&gt;

&lt;p&gt;Suppose you have a script that does several related things: it manages your to-do list by adding, editing, listing, and deleting to-do items:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    % todo add &amp;quot;Email Samuel about photos&amp;quot;
    Todo item 129 created
    % todo done 129
    Item 129 marked as done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You might expect the script to look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $command = shift @ARGV;
    if    ($command eq &amp;quot;add&amp;quot;)  { add(@ARGV)  }
    elsif ($command eq &amp;quot;list&amp;quot;) { list(@ARGV) }
    elsif ($command eq &amp;quot;done&amp;quot;) { done(@ARGV) }
    elsif ($command eq &amp;quot;edit&amp;quot;) { edit(@ARGV) }
    ...
    else { die &amp;quot;Unknown command: $command&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is quite tedious; you need to edit the program in several places every time you add a new command. You &lt;em&gt;could&lt;/em&gt; use symbolic references&amp;ndash;that is, tell Perl to call a function named &lt;code&gt;$command&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $command = shift @ARGV;
    sub AUTOLOAD { die &amp;quot;Unknown command: $AUTOLOAD&amp;quot; }
    no strict &#39;refs&#39;;
    &amp;amp;{$command}(@ARGV);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But that&amp;rsquo;s somewhat crazy. It allows the user to get at any subroutine in the main package, which you may not want, and to keep any error checking you have to assume that &lt;em&gt;any&lt;/em&gt; undefined subroutine call comes from the command line.&lt;/p&gt;

&lt;p&gt;The middle way is to copy the commands into a hash, mapped to a function reference:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %commands = (
        add  =&amp;gt; \&amp;amp;add,
        list =&amp;gt; \&amp;amp;list,
        edit =&amp;gt; \&amp;amp;edit,
        done =&amp;gt; \&amp;amp;done,
    );
    my $command = shift @ARGV;
    if (!exists $commands{$command}) { die &amp;quot;Unknown command: $command&amp;quot; }
    $commands{$command}-&amp;gt;(@ARGV);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This keeps &lt;code&gt;strict&lt;/code&gt; happy, it&amp;rsquo;s safe in the way it restricts what subroutines users can call, and it allows for error checking that doesn&amp;rsquo;t mess everything else up. Mark Jason Dominus&amp;rsquo; &lt;em&gt;Higher Order Perl&lt;/em&gt; shows how you can define commands at runtime if you use dispatch tables, something you can&amp;rsquo;t do if you hard-code your dispatch.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;ve explored some of the most common hash-based patterns: using hashes for counting, uniqueness, searching, and dispatch&amp;ndash;rather a lot more than just mapping from one thing to another. Of course, that is what a hash does at one level, but the uses of such a data structure are a lot more diverse than just that.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s how you improve your Perl programming&amp;ndash;you take elements of the language which ostensibly do one thing, and you find that they&amp;rsquo;re great for more complicated uses as well. Maybe after these ideas you&amp;rsquo;ll be able to find a few more hash idioms of your own!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>More Advancements in Perl Programming</title>
      <link>http://localhost:1313/pub/2006/01/26/more_advanced_perl.html/</link>
      <pubDate>Thu, 26 Jan 2006 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2006/01/26/more_advanced_perl.html/</guid>
      <description>

&lt;p&gt;Around Easter last year, I finished writing the second edition of &lt;a href=&#34;http://www.oreilly.com/catalog/advperl2/&#34;&gt;Advanced Perl Programming&lt;/a&gt;, a task that had been four years in the making. The aim of this new edition was to reflect the way that Perl programming had changed since the first edition. Much of what Sriram wrote in the original edition was still true, but to be honest, not too much of it was useful anymore&amp;ndash;the Perl world has changed dramatically since the original publication.&lt;/p&gt;

&lt;p&gt;The first edition was very much about how to do things yourself; it operated at a very low level by current Perl standards. With the explosion of CPAN modules in the interim, &amp;ldquo;advanced Perl programming&amp;rdquo; now consists of plugging all of the existing components together in the right order, rather than necessarily writing the components from scratch. So the nature of the book had to change a lot.&lt;/p&gt;

&lt;p&gt;However, CPAN is still expanding, and the Perl world continues to change; &lt;em&gt;Advanced Perl Programming&lt;/em&gt; can never be a finished book, but only a snapshot in time. On top of all that, I&amp;rsquo;ve been learning more, too, and discovering more tricks to get work done smarter and faster. Even during the writing of the book, some of the best practices changed and new modules were developed.&lt;/p&gt;

&lt;p&gt;The book is still, I believe, an excellent resource for learning how to master Perl programming, but here, if you like, I want to add to that resource. I&amp;rsquo;ll try to say something about the developments that have happened in each chapter of the book.&lt;/p&gt;

&lt;h3 id=&#34;advanced-perl&#34;&gt;Advanced Perl&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;m actually very happy with this chapter. The only thing I left out of the first chapter which may have been useful there is a section on &lt;code&gt;tie&lt;/code&gt;; but this is covered strongly in &lt;em&gt;Programming Perl&lt;/em&gt; anyway.&lt;/p&gt;

&lt;p&gt;On the other hand, although it&amp;rsquo;s not particularly advanced, one of the things I wish I&amp;rsquo;d written about in the book was best practices for creating object-oriented modules. My fellow O&amp;rsquo;Reilly author Damian Conway has already written two books about these topics, so, again, I didn&amp;rsquo;t get too stressed out about having to leave those sections out. That said, the two modules I would recommend for building OO classes don&amp;rsquo;t appear to get a mention in &lt;em&gt;Perl Best Practices&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;First, we all know it&amp;rsquo;s a brilliant idea to create accessors for our data members in a class; however, it&amp;rsquo;s also a pain in the neck to create them yourself. There seem to be hundreds of CPAN modules that automate the process for you, but the easiest is the &lt;a href=&#34;https://metacpan.org/pod/Class::Accessor&#34;&gt;&lt;code&gt;Class::Accessor&lt;/code&gt;&lt;/a&gt; module. With this module, you declare which accessors you want, and it will automatically create them. As a useful bonus, it creates a default &lt;code&gt;new()&lt;/code&gt; method for you if you don&amp;rsquo;t want to write one of those, either.&lt;/p&gt;

&lt;p&gt;Instead of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package MyClass;

sub new { bless { %{@_} }, shift; }

sub name {
    my $self = shift;
    if (@_) { $self-&amp;gt;{name} = shift; }
    $self-&amp;gt;{name}
}

sub address {
    my $self = shift;
    if (@_) { $self-&amp;gt;{address} = shift; }
    $self-&amp;gt;{address}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you can now say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package MyClass;
use base qw(Class::Accessor);

MyClass-&amp;gt;mk_accessors(qw( name address ));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Class::Accessor&lt;/code&gt; also contains methods for making read-only accessors and for creating separate read and write accessors, and everything is nicely overrideable. Additionally, there are subclasses that extend &lt;code&gt;Class::Accessor&lt;/code&gt; in various ways: &lt;a href=&#34;https://metacpan.org/pod/Class::Accessor::Fast&#34;&gt;&lt;code&gt;Class::Accessor::Fast&lt;/code&gt;&lt;/a&gt; trades off a bit of the extensibility for an extra speed boost, &lt;a href=&#34;https://metacpan.org/pod/Class::Accessor::Chained&#34;&gt;&lt;code&gt;Class::Accessor::Chained&lt;/code&gt;&lt;/a&gt; returns the object when called with parameters, and &lt;a href=&#34;https://metacpan.org/pod/Class::Accessor::Assert&#34;&gt;&lt;code&gt;Class::Accessor::Assert&lt;/code&gt;&lt;/a&gt; does rudimentary type checking on the parameter values. There are many, many modules on the CPAN that do this sort of thing, but this one is, in my opinion, the most flexible and simple.&lt;/p&gt;

&lt;p&gt;Speaking of flexibility, one way to encourage flexibility in your modules and applications is to make them pluggable&amp;ndash;that is, to allow other pieces of code to respond to actions that you define. &lt;a href=&#34;https://metacpan.org/pod/Module::Pluggable&#34;&gt;&lt;code&gt;Module::Pluggable&lt;/code&gt;&lt;/a&gt; is a simple but powerful little module that searches for installed modules in a given namespace. Here&amp;rsquo;s an example of its use in &lt;a href=&#34;https://metacpan.org/pod/Email::FolderType&#34;&gt;&lt;code&gt;Email::FolderType&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Module::Pluggable 
    search_path =&amp;gt; &amp;quot;Email::FolderType&amp;quot;, 
    require     =&amp;gt; 1, 
    sub_name    =&amp;gt; &#39;matchers&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This looks for all modules underneath the &lt;code&gt;Email::FolderType::&lt;/code&gt; namespace, &lt;code&gt;require&lt;/code&gt;s them, and assembles a list of their classes into the &lt;code&gt;matchers&lt;/code&gt; method. The module later determines the type of an email folder by passing it to each of the recognizers and seeing which of them handles it, with the moral equivalent of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub folder_type {
    my ($self, $folder) = @_;
    for my $class ($self-&amp;gt;matchers) {
        return $class if $class-&amp;gt;match($folder);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This means you don&amp;rsquo;t need to know, when you&amp;rsquo;re writing the code, what folder types you support; you can start off with no recognizers and add them later. If a new type of email folder comes along, the user can install a third-party module from CPAN that deals with it, and &lt;code&gt;Email::FolderType&lt;/code&gt; requires no additional coding to add support for it.&lt;/p&gt;

&lt;h3 id=&#34;parsing&#34;&gt;Parsing&lt;/h3&gt;

&lt;p&gt;Perhaps the biggest change of heart I had between writing a chapter and its publication was in the parsing chapter. That chapter had very little about parsing HTML, and what it did have was not very friendly. Since then, Gisle Aas and Sean Burke&amp;rsquo;s &lt;a href=&#34;https://metacpan.org/pod/HTML::TreeBuilder&#34;&gt;&lt;code&gt;HTML::TreeBuilder&lt;/code&gt;&lt;/a&gt; and the corresponding &lt;a href=&#34;https://metacpan.org/pod/XML::TreeBuilder&#34;&gt;&lt;code&gt;XML::TreeBuilder&lt;/code&gt;&lt;/a&gt; have established themselves as much simpler and more flexible ways to navigate HTML and XML documents.&lt;/p&gt;

&lt;p&gt;The basic concept in &lt;code&gt;HTML::TreeBuilder&lt;/code&gt; is the HTML element, represented as an object of the &lt;code&gt;HTML::Element&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$a = HTML::Element-&amp;gt;new(&#39;a&#39;, href =&amp;gt; &#39;http://www.perl.com/&#39;);
$html = $a-&amp;gt;as_HTML;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This creates a new element that is an anchor tag, with an &lt;code&gt;href&lt;/code&gt; attribute. The HTML equivalent in &lt;code&gt;$html&lt;/code&gt; would be &lt;code&gt;&amp;lt;a href=&amp;quot;http://www.perl.com&amp;quot;/&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now you can add some content to that tag:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$a-&amp;gt;push_content(&amp;quot;The Perl Homepage&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This time, the object represents &lt;code&gt;&amp;lt;a href=&amp;quot;http://www.perl.com&amp;quot;&amp;gt; The Perl Homepage &amp;lt;/a&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can ask this element for its tag, its attributes, its content, and so on:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$tag = $a-&amp;gt;tag;
$link = $a-&amp;gt;attr(&amp;quot;href&amp;quot;);
@content = $a-&amp;gt;content_list; # More HTML::Element nodes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, when you are parsing HTML, you won&amp;rsquo;t be creating those elements manually. Instead, you&amp;rsquo;ll be navigating a tree of them, built out of your HTML document. The top-level module &lt;code&gt;HTML::TreeBuilder&lt;/code&gt; does this for you:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use HTML::TreeBuilder;
my $tree = HTML::TreeBuilder-&amp;gt;new();
$tree-&amp;gt;parse_file(&amp;quot;index.html&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now &lt;code&gt;$tree&lt;/code&gt; is a &lt;code&gt;HTML::Element&lt;/code&gt; object representing the &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; tag and all its contents. You can extract all of the links with the &lt;code&gt;extract_links()&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (@{ $tree-&amp;gt;extract_links() || [] }) {
     my($link, $element, $attr, $tag) = @$_;
     print &amp;quot;Found link to $link in $tag\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although the real workhorse of this module is the &lt;code&gt;look_down()&lt;/code&gt; method, which helps you pull elements out of the tree by their tags or attributes. For instance, in a search engine indexer, indexing HTML files, I have the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for my $tag ($tree-&amp;gt;look_down(&amp;quot;_tag&amp;quot;,&amp;quot;meta&amp;quot;)) {
    next unless $tag-&amp;gt;attr(&amp;quot;name&amp;quot;);
    $hash{$tag-&amp;gt;attr(&amp;quot;name&amp;quot;)} .= $tag-&amp;gt;attr(&amp;quot;content&amp;quot;). &amp;quot; &amp;quot;;
}

$hash{title} .= $_-&amp;gt;as_text.&amp;quot; &amp;quot; for $tree-&amp;gt;look_down(&amp;quot;_tag&amp;quot;,&amp;quot;title&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This finds all &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; tags and puts their attributes as name-value pairs in a hash; then it puts all the text inside of &lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; tags together into another hash element. Similarly, you can look for tags by attribute value, spit out sub-trees as HTML or as text, and much more, besides. For reaching into HTML text and pulling out just the bits you need, I haven&amp;rsquo;t found anything better.&lt;/p&gt;

&lt;p&gt;On the XML side of things, &lt;a href=&#34;https://metacpan.org/pod/XML::Twig&#34;&gt;&lt;code&gt;XML::Twig&lt;/code&gt;&lt;/a&gt; has emerged as the usual &amp;ldquo;middle layer,&amp;rdquo; when &lt;a href=&#34;https://metacpan.org/pod/XML::Simple&#34;&gt;&lt;code&gt;XML::Simple&lt;/code&gt;&lt;/a&gt; is too simple and &lt;a href=&#34;https://metacpan.org/pod/XML::Parser&#34;&gt;&lt;code&gt;XML::Parser&lt;/code&gt;&lt;/a&gt; is, well, too much like hard work.&lt;/p&gt;

&lt;h3 id=&#34;templating&#34;&gt;Templating&lt;/h3&gt;

&lt;p&gt;There&amp;rsquo;s not much to say about templating, although in retrospect, I would have spent more of the paper expended on &lt;a href=&#34;https://metacpan.org/pod/HTML::Mason&#34;&gt;&lt;code&gt;HTML::Mason&lt;/code&gt;&lt;/a&gt; talking about the &lt;a href=&#34;http://www.template-toolkit.org/&#34;&gt;Template Toolkit&lt;/a&gt; instead. Not that there&amp;rsquo;s anything wrong with &lt;code&gt;HTML::Mason&lt;/code&gt;, but the world seems to be moving away from templates that include code in a specific language (say, Perl&amp;rsquo;s) towards separate templating little languages, like &lt;a href=&#34;https://metacpan.org/pod/Template::TAL&#34;&gt;TAL&lt;/a&gt; and Template Toolkit.&lt;/p&gt;

&lt;p&gt;The only thing to report is that Template Toolkit finally received a bit of attention from its maintainer a couple of months ago, but the long-awaited Template Toolkit 3 is looking as far away as, well, Perl 6.&lt;/p&gt;

&lt;h3 id=&#34;natural-language-processing&#34;&gt;Natural Language Processing&lt;/h3&gt;

&lt;p&gt;Who would have thought that the big news of 2005 would be that Yahoo is relevant again? Not only are they coming up with interesting new search technologies such as Y!Q, but they&amp;rsquo;re releasing a lot of the guts behind what they&amp;rsquo;re doing as public APIs. One of those that is particularly relevant for NLP is the &lt;a href=&#34;http://developer.yahoo.net/search/content/V1/termExtraction.html&#34;&gt;Term Extraction web service&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This takes a chunk of text and pulls out the distinctive terms and phrases. Think of this as a step beyond something like &lt;a href=&#34;https://metacpan.org/pod/Lingua::EN::Keywords&#34;&gt;&lt;code&gt;Lingua::EN::Keywords&lt;/code&gt;&lt;/a&gt;, with the firepower of Yahoo behind it. To access the API, simply send a HTTP &lt;code&gt;POST&lt;/code&gt; request to a given URL:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use LWP::UserAgent;
use XML::Twig;
my $uri  = &amp;quot;http://api.search.yahoo.com/ContentAnalysisService/V1/termExtraction&amp;quot;;
my $ua   = LWP::UserAgent-&amp;gt;new();
my $resp = $ua-&amp;gt;post($uri, {
    appid   =&amp;gt; &amp;quot;PerlYahooExtractor&amp;quot;,
    context =&amp;gt; &amp;lt;&amp;lt;EOF
Two Scottish towns have seen the highest increase in house prices in the
UK this year, according to new figures. 
Alexandria in West Dunbartonshire and Coatbridge in North Lanarkshire
both saw an average 35% rise in 2005. 
EOF
});
if ($resp-&amp;gt;is_success) { 
    my $xmlt = XML::Twig-&amp;gt;new( index =&amp;gt; [ &amp;quot;Result&amp;quot; ]);
    $xmlt-&amp;gt;parse($resp-&amp;gt;content);
    for my $result (@{ $xmlt-&amp;gt;index(&amp;quot;Result&amp;quot;) || []}) {
        print $result-&amp;gt;text;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This produces:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;north lanarkshire
scottish towns
west dunbartonshire
house prices
coatbridge
dunbartonshire
alexandria
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once I had informed the London Perl Mongers of this amazing discovery, Simon Wistow immediately bundled it up into a Perl module called &lt;a href=&#34;https://metacpan.org/pod/Lingua::EN::Keywords::Yahoo&#34;&gt;&lt;code&gt;Lingua::EN::Keywords::Yahoo&lt;/code&gt;&lt;/a&gt;, coming soon to a CPAN mirror near you.&lt;/p&gt;

&lt;h3 id=&#34;unicode&#34;&gt;Unicode&lt;/h3&gt;

&lt;p&gt;The best news about Unicode over the last year is that you should not have noticed any major changes. By now, the core Unicode support in Perl just works, and most of the CPAN modules that deal with external data have been updated to work with Unicode.&lt;/p&gt;

&lt;p&gt;If you don&amp;rsquo;t see or hear anything about Unicode, that&amp;rsquo;s a good thing: it means it&amp;rsquo;s all working properly.&lt;/p&gt;

&lt;h3 id=&#34;poe&#34;&gt;POE&lt;/h3&gt;

&lt;p&gt;The chapter on POE was a great introduction to how POE works and some of the things that you can do with it, but it focused on using POE for networking applications and for daemons. This is only half the story. Recently a lot of interest has centered on using POE for graphical and command-line applications: Randal Schwartz takes over from the RSS aggregator at the end of the chapter by integrating it with a graphical interface in &amp;ldquo;&lt;a href=&#34;http://www.stonehenge.com/merlyn/PerlJournal/col11.html&#34;&gt;Graphical interaction with POE and Tk&lt;/a&gt;.&amp;rdquo; Here, I want to consider command-line applications.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://metacpan.org/pod/Term::Visual&#34;&gt;&lt;code&gt;Term::Visual&lt;/code&gt;&lt;/a&gt; module is a POE component for creating applications with a split-screen interface; at the bottom of the interface, you type your input, and the output appears above a status line. The module handles all of the history, status bar updates, and everything else for you. Here&amp;rsquo;s an application that uses &lt;a href=&#34;https://metacpan.org/pod/Chatbot::Eliza&#34;&gt;&lt;code&gt;Chatbot::Eliza&lt;/code&gt;&lt;/a&gt; to provide therapeutic session with everyone&amp;rsquo;s favorite digital psychiatrist.&lt;/p&gt;

&lt;p&gt;First, set up the chatbot and create a new &lt;code&gt;Term::Visual&lt;/code&gt; object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/perl -w
use POE;
use POSIX qw(strftime);
use Term::Visual;
use Chatbot::Eliza;
my $eliza = Chatbot::Eliza-&amp;gt;new();
my $vt    = Term::Visual-&amp;gt;new( Alias =&amp;gt; &amp;quot;interface&amp;quot; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now create the window, which will have space on its status bar for a clock:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $window_id = $vt-&amp;gt;create_window(
   Status =&amp;gt; { 0 =&amp;gt; { format =&amp;gt; &amp;quot;[%8.8s]&amp;quot;, fields =&amp;gt; [&amp;quot;time&amp;quot;] } },
   Title =&amp;gt; &amp;quot;Eliza&amp;quot; 
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You also need a &lt;a href=&#34;https://metacpan.org/pod/POE::Session&#34;&gt;&lt;code&gt;POE::Session&lt;/code&gt;&lt;/a&gt;, which will do all the work. It will have three states; the first is the &lt;code&gt;_start&lt;/code&gt; state, to tell &lt;code&gt;Term::Visual&lt;/code&gt; what to do with any input it gets from the keyboard and to update the clock:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;POE::Session-&amp;gt;create
(inline_states =&amp;gt;
  { _start          =&amp;gt; sub {
        $_[KERNEL]-&amp;gt;post( interface =&amp;gt; send_me_input =&amp;gt; &amp;quot;got_term_input&amp;quot; );
        $_[KERNEL]-&amp;gt;yield( &amp;quot;update_time&amp;quot; );
    },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Updating the clock is simply a matter of setting the &lt;code&gt;time&lt;/code&gt; field declared earlier to the current time, and scheduling another update at the top of the next minute:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    update_time     =&amp;gt; sub {
        $vt-&amp;gt;set_status_field( $window_id,
                               time =&amp;gt; strftime(&amp;quot;%I:%M %p&amp;quot;, localtime) );
        $_[KERNEL]-&amp;gt;alarm( update_time =&amp;gt; int(time() / 60) * 60 + 60 );
    },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, you need to handle the input from the user. Do that in a separate subroutine to make things a big clearer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    got_term_input  =&amp;gt; \&amp;amp;handle_term_input,
  }
);

$poe_kernel-&amp;gt;run();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When &lt;code&gt;Term::Visual&lt;/code&gt; gets a line of text from the user, it passes it to the state declared in the &lt;code&gt;_start&lt;/code&gt; state. The code takes that text, prints it to the terminal as an echo, and then passes it through Eliza:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub handle_term_input {
  my ($heap, $input) = @_[HEAP, ARG0];
  if ($input =~ m{^/quit}i) {
    $vt-&amp;gt;delete_window($window_id); 
    exit;
  }

  $vt-&amp;gt;print($window_id, &amp;quot;&amp;gt; $input&amp;quot;);
  $vt-&amp;gt;print($window_id, $eliza-&amp;gt;transform($input));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In just a few lines of code you have a familiar interface, similar to many IRC or MUD clients, with POE hiding all of the event handling away.&lt;/p&gt;

&lt;h3 id=&#34;testing&#34;&gt;Testing&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Advanced Perl Programming&lt;/em&gt; showed how to write tests so that we all can be more sure that our code is doing what it should. How do you know your tests are doing enough? Enter Paul Johnson&amp;rsquo;s &lt;a href=&#34;https://metacpan.org/pod/Devel::Cover&#34;&gt;&lt;code&gt;Devel::Cover&lt;/code&gt;&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Devel::Cover&lt;/code&gt; makes a record of each time a Perl operation or statement is executed, and then compares this against the statements in your code. So when you&amp;rsquo;re running your tests, you can see which of the code paths in your module get exercised and which don&amp;rsquo;t; if you have big branches of code that never get tested, maybe you should write more tests for them!&lt;/p&gt;

&lt;p&gt;To use it on an uninstalled module:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cover -delete
$ HARNESS_PERL_SWITCHES=-MDevel::Cover make test
$ cover
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will give you a textual summary of code coverage; &lt;code&gt;cover -report html&lt;/code&gt; produces a colorized, navigable hypertext summary, useful for showing to bosses.&lt;/p&gt;

&lt;p&gt;This ensures that your code works&amp;ndash;or at least, that it does what your tests specify. The next step is to ensure that your code is actually of relatively decent quality. Because &amp;ldquo;quality&amp;rdquo; is a subjective metric when it comes to the art of programming, Perl folk have introduced the objective of &amp;ldquo;Kwalitee&amp;rdquo; instead, which may or may not have any bearing on quality.&lt;/p&gt;

&lt;p&gt;All modules on CPAN have their Kwalitee measured as part of the &lt;a href=&#34;http://cpants.dev.zsi.at/&#34;&gt;CPANTS&lt;/a&gt; (CPAN Testing Service) website. One way to test for and increase your Kwalitee is to use the &lt;a href=&#34;https://metacpan.org/pod/Module::Build::Kwalitee&#34;&gt;&lt;code&gt;Module::Build::Kwalitee&lt;/code&gt;&lt;/a&gt; module; this copies some boilerplate tests into your distribution that ensure that you have adequate and syntactically correct documentation, that you &lt;code&gt;use strict&lt;/code&gt; and &lt;code&gt;warnings&lt;/code&gt;, and so on.&lt;/p&gt;

&lt;p&gt;All of this ought to go a fair way to improving the Kwalitee of your code, if not its actual quality!&lt;/p&gt;

&lt;h3 id=&#34;inline&#34;&gt;Inline&lt;/h3&gt;

&lt;p&gt;One of the things that has come over into Perl 5 from Perl 6 development is the concept of the Native Call Interface (NCI). This hasn&amp;rsquo;t fully been developed yet, but chromatic (yes, the editor of this very site) has been working on it.&lt;/p&gt;

&lt;p&gt;The idea is that, instead of having something like Inline or XS that creates a &amp;ldquo;buffer&amp;rdquo; between Perl and C libraries, you just call those libraries directly. At the moment, you need to compile any XS module against the library you&amp;rsquo;re using. This is particularly awkward for folk on cut-down operating systems that do not ship a compiler, such as Palm OS or Windows.&lt;/p&gt;

&lt;p&gt;The strength of NCI is that it doesn&amp;rsquo;t require a compiler; instead, it uses the operating system&amp;rsquo;s normal means of making calls into libraries. (Hence &amp;ldquo;Native Call.&amp;rdquo;) It uses Perl&amp;rsquo;s &lt;code&gt;DynaLoader&lt;/code&gt; to find libraries, load them, and then find the address of symbols inside of the library. Then it calls a generic &amp;ldquo;thunk&amp;rdquo; function to turn the symbol&amp;rsquo;s address into a call. For instance:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $lib = P5NCI::Library-&amp;gt;new( library =&amp;gt; &#39;nci_test&#39;, package =&amp;gt; &#39;NCI&#39; );
$lib-&amp;gt;install_function( &#39;double_int&#39;, &#39;ii&#39; );

my $two = NCI::double_int( 1 );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These lines find the &lt;code&gt;nci_test&lt;/code&gt; shared library and get ready to put its functions into the &lt;code&gt;NCI&lt;/code&gt; namespace. It then installs the function &lt;code&gt;double_int&lt;/code&gt;, which is of signature &lt;code&gt;int double_int(int)&lt;/code&gt; (hence &lt;code&gt;ii&lt;/code&gt;). Once this is done, you can call the function from Perl. It&amp;rsquo;s not much trickier than Inline, but without the intermediate step of compilation.&lt;/p&gt;

&lt;p&gt;NCI isn&amp;rsquo;t quite there yet, and it only supports very simple function signatures. However, because of its portability, it&amp;rsquo;s definitely the one to watch for Perl-C interfaces in the future.&lt;/p&gt;

&lt;h3 id=&#34;everything-else&#34;&gt;Everything Else&lt;/h3&gt;

&lt;p&gt;The last chapter is &amp;ldquo;Fun with Perl.&amp;rdquo; Now, much has happened in the world of Perl fun, but much has happened all over Perl. There were many other things I wanted to write about, as well: CPAN best practices for date/time handling and email handling, Perl 6 and Pugs, the very latest web application frameworks such as Catalyst and Jifty, and so on. But all these would fill another book&amp;ndash;and if I ever finished that, it too would require an update like this one. So I hope this is enough for you to be getting on with!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lightning Articles</title>
      <link>http://localhost:1313/pub/2004/09/09/lightning.html/</link>
      <pubDate>Thu, 09 Sep 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/09/09/lightning.html/</guid>
      <description>

&lt;h4 id=&#34;simon-cozens&#34;&gt;Simon Cozens&lt;/h4&gt;

&lt;p&gt;Serendipity &amp;ndash; it means those occasions when things come together to give you moments of inspiration. While preparing perl.com one week, I was editing an article on how to give lightning talks by Mark Fowler and at the same time I was dealing with another author who said he was having difficulty stretching out an article &amp;ndash; a very good article, on a topic I wanted to see covered &amp;ndash; to a full 2,500-words-or-so length.&lt;/p&gt;

&lt;p&gt;I then realized there were probably a load of people out there with interesting things to say about what they&amp;rsquo;re doing with Perl, but who couldn&amp;rsquo;t or didn&amp;rsquo;t want to write a full-sized article. This is, after all, the principle that makes lightning talks so popular. Maybe we could create a forum where people could have short, informal articles published on an interesting Perl topic of their choice &amp;ndash; lightning articles.&lt;/p&gt;

&lt;p&gt;In the same vein as lightning talks, they can be both about an interesting use of the technology, or social commentary on Perl and its community, or just a bit of fun. If you&amp;rsquo;ve got something you want to get off your chest, or you&amp;rsquo;ve got an interesting new idea you want to talk about, but don&amp;rsquo;t think you could fill 2,500 words, try writing a lightning article. You have an absolute maximum of 500 words &amp;ndash; as measured by &lt;code&gt;wc -w&lt;/code&gt; (or &lt;code&gt;perl -0lne    &#39;print scalar split/\s+/&#39;&lt;/code&gt;) on your POD or plain text file &amp;ndash; to say what you need to say.&lt;/p&gt;

&lt;p&gt;Send them to &lt;code&gt;chromatic@oreilly.com&lt;/code&gt;, and when we&amp;rsquo;ve got a good batch of five or six together, we&amp;rsquo;ll publish them here.&lt;/p&gt;

&lt;h3 id=&#34;span-id-detecting-problem-automatically-detecting-problems-automatically-span&#34;&gt;&lt;span id=&#34;detecting_problem_automatically&#34;&gt;Detecting Problems Automatically&lt;/span&gt;&lt;/h3&gt;

&lt;h4 id=&#34;mark-fowler&#34;&gt;Mark Fowler&lt;/h4&gt;

&lt;p&gt;How many times have you shipped something, and then as soon as it&amp;rsquo;s gone live you&amp;rsquo;ve spotted a glaring mistake that, despite staring you in the face the entire time you were developing the code, you&amp;rsquo;ve somehow overlooked?&lt;/p&gt;

&lt;p&gt;One thing we have problems with at work is double-encoded HTML entities in our web pages. We often use HTML entities to encode letters that aren&amp;rsquo;t ASCII, since this way we then don&amp;rsquo;t have to worry about the text encoding we&amp;rsquo;re using.&lt;/p&gt;

&lt;p&gt;For example, we want to render the string &lt;code&gt;Hello L√©on&lt;/code&gt;&amp;gt; into our HTML document. So, instead of including the √© into our document directly we transform it into its entity form, replacing it with &lt;code&gt;&amp;amp;eacute;&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;p&amp;gt;Hello L&amp;amp;eacute;on&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This can be done automatically by Perl in numerous ways, e.g. with &lt;strong&gt;HTML::Entities&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use HTML::Entities;

  my $string = &amp;quot;Hello $name&amp;quot;;
  encode_entity($string);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or if you&amp;rsquo;re using the Template Toolkit through the &lt;code&gt;html_entity&lt;/code&gt; filter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;p&amp;gt;Hello [% name | html_entity %]&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The root of the troubles we were experiencing was that entity encoding could occur in our code in multiple, different places depending on where the string we were about to render came from. And if we accidentally did it more than once then we ended up with HTML that looked like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   &amp;lt;p&amp;gt;Hello L&amp;amp;amp;eactue;on&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This means the web browser sees the &lt;code&gt;&amp;amp;amp;&lt;/code&gt; and converts it to an ampersand and then renders the rest of the &lt;code&gt;eacute;&lt;/code&gt; as normal text:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Hello L&amp;amp;eacute;on
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not exactly what we wanted. Of course, these things are fairly trivial to fix once you spot them. The real problem we were having is that these errors kept repeatedly popping up, and having our testing department coming back to us every release with another one of these errors was getting embarrassing. We&amp;rsquo;d gone blind to the errors &amp;ndash; working so closely with the web site we&amp;rsquo;d glance at the page and not notice what should have been staring us in the face.&lt;/p&gt;

&lt;p&gt;So we decided to automatically test for the problem.&lt;/p&gt;

&lt;p&gt;In the end I decided to write &lt;strong&gt;Test::DoubleEncodedEntities&lt;/strong&gt;, a &lt;strong&gt;Test::Builder&lt;/strong&gt; module that would test for these errors and run under &lt;strong&gt;Test::Harness&lt;/strong&gt; like all our other tests. The &lt;code&gt;ok_dee&lt;/code&gt; function relies on the fact that none of our web sites would ever use strings like &lt;code&gt;&amp;amp;amp;eacute;&lt;/code&gt; (this is true of most web sites - the only web sites that do are ones like this that feature articles on how to encode HTML).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use LWP::Simple qw(get);
  use Test::More tests =&amp;gt; 2;
  use Test::DoubleEncodedEntities;

  my $page = get &amp;quot;http://testserver/index.html&amp;quot;;
  ok($page, &amp;quot;got page okay&amp;quot;);
  ok_dee($page, &amp;quot;check for double encoded entities&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the test fails then we get some useful diagnostic output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  1..2
  ok 1 - got page okay
  not ok 2 - check for double encoded entities
  #     Failed test (t/website.t at line 7)
  # Found 1 &amp;quot;&amp;amp;amp;eacute;&amp;quot;
  # Looks like you failed 1 test of 2.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now we don&amp;rsquo;t even have to look for these things. Our test suite catches double-encoded entities for us and brings them to our attention. Problem solved.&lt;/p&gt;

&lt;h3 id=&#34;span-id-cpan-miniaturized-cpan-miniaturized-span&#34;&gt;&lt;span id=&#34;cpan_miniaturized&#34;&gt;CPAN, Miniaturized&lt;/span&gt;&lt;/h3&gt;

&lt;h4 id=&#34;ricardo-signes&#34;&gt;Ricardo Signes&lt;/h4&gt;

&lt;p&gt;Everyone has seen a problem too boring to solve. Rather than keep a stiff upper lip and trudge forward, you head to the CPAN and find the pre-packaged solution that probably already exists. It&amp;rsquo;s just another display of your complete impatience and laziness, and that&amp;rsquo;s great: with the CPAN at your side, you can solve boring problems effortlessly.&lt;/p&gt;

&lt;p&gt;The problem, of course, is that CPAN isn&amp;rsquo;t always at your side. Sure, a simple &lt;code&gt;install Class::DBI&lt;/code&gt; might be enough to implement half of your project, but when you&amp;rsquo;re offline and stuck on the plane, good luck getting to your usual mirror. I&amp;rsquo;ve found myself in that position a number of times, and usually when I&amp;rsquo;ve most wanted to get some work done. On the way home from conventions, I&amp;rsquo;ve sat in cars and planes, wishing I&amp;rsquo;d remembered to install &lt;code&gt;Test::Smoke&lt;/code&gt; or &lt;code&gt;DBD::SQLite&lt;/code&gt; before leaving home.&lt;/p&gt;

&lt;p&gt;The solution, of course, is to just mirror the whole CPAN. It&amp;rsquo;s only three gigs, and if you&amp;rsquo;ve got a week to spare on your dial-up, that&amp;rsquo;s just fine. After all, later rsyncs are just a few hours a week!&lt;/p&gt;

&lt;p&gt;Other problems loom, not the least of which is the possibility of losing those three gigs when your drive crashes on the road. You can always back up the mirror to a DVD in case you need to re-mirror it quickly&amp;hellip; but by this point the solution to your problem has become tedious, and I know how you feel about solving tedious problems.&lt;/p&gt;

&lt;p&gt;A better solution to this problem was published a few years ago by Randal Schwartz: mini-CPAN. Its guiding principle is an old programmer standard: &amp;ldquo;You aren&amp;rsquo;t going to need 90 percent of that crap.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Randal&amp;rsquo;s script only retrieves the CPAN indices, and then the modules listed in the package index &amp;ndash; basically, only the newest version of every distribution &amp;ndash; the only files ever used by CPAN.pm and CPANPLUS to install modules. On subsequent runs, only those distributions that have changed are updated.&lt;/p&gt;

&lt;p&gt;With this miniature CPAN, you&amp;rsquo;ve cut CPAN down to about 400 MB. Not only does it take a fraction of the time to mirror, but it fits nicely onto a CD. You can stick it in your bag, right behind your rescue disk, and know that no matter what happens, the CPAN will be right by your side.&lt;/p&gt;

&lt;p&gt;With the script configured and run, you&amp;rsquo;ll have your own personal CPAN sitting on your machine, ready to be used. Pointing CPAN.pm at it is easy as can be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        cpan&amp;gt; o conf urllist unshift file:///home/japh/minicpan
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternately, just edit your CPAN::Config or CPANPLUS::Config.&lt;/p&gt;

&lt;p&gt;The only problem left with mini-CPAN is that it was so hard to find. It&amp;rsquo;s been such a fantastic addition to my toolbox that I feel slighted, having spent two years oblivious to its existence. To help others avoid this pain, I&amp;rsquo;ve tweaked the script, shoved its guts into a module, and stuck it onto CPAN. Just by installing &lt;a href=&#34;https://metacpan.org/pod/CPAN::Mini&#34;&gt;CPAN::Mini&lt;/a&gt;, you can have &lt;code&gt;minicpan&lt;/code&gt; dropped into place and ready to go:
&amp;ldquo; &amp;gt;}}
     minicpan -r &lt;a href=&#34;http://your.favorite.mirror/of/cpan&#34;&gt;http://your.favorite.mirror/of/cpan&lt;/a&gt; -l /home/japh/minicpan&lt;/p&gt;

&lt;p&gt;&amp;hellip;and your personal CPAN is waiting.&lt;/p&gt;

&lt;h3 id=&#34;span-id-database-bittwiddling-bit-twiddling-in-your-database-span&#34;&gt;&lt;span id=&#34;database_bittwiddling&#34;&gt;Bit-twiddling in your Database&lt;/span&gt;&lt;/h3&gt;

&lt;h4 id=&#34;aaron-trevena&#34;&gt;Aaron Trevena&lt;/h4&gt;

&lt;p&gt;Why would you use a bit mask in your database ?&lt;/p&gt;

&lt;p&gt;They can be useful where you have a many-to-many relationship where one side changes rarely and the other frequently. A good example is facilities provided by a Tourist Resort, where the actual amenities change rarely but resorts are added and updated often.&lt;/p&gt;

&lt;p&gt;Normalization would add an intermediate table between them, but that can be painfully slow if you have a significant number of amenities and frequently queried records about many of them.&lt;/p&gt;

&lt;p&gt;The same problem can occur to a lesser degree within a single table; perhaps you are doing some statistical analysis on demographics with columns representing gender, marital status, etc. For more than a few thousand records, querying subsets of the table based on these criteria can become expensive very quickly.&lt;/p&gt;

&lt;p&gt;How would you use bit masks?&lt;/p&gt;

&lt;p&gt;Instead of holding information in a separate table or a group of columns, use a bit mask with each bit representing a column in the table or a record in a second table. For example, use 8 bits to represent gender, marital status, employment status, smoker, drinker, driver, car-owner, and house-owner. A query to find drivers under 25 who don&amp;rsquo;t drink or smoke and own their own car contains six conditions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    select id, age from people where age &amp;lt; 25 and employment_status =
    &#39;employed&#39; and smoker = &#39;N&#39; and drinker = &#39;N&#39; and car_owner = &#39;Y&#39;
    and driver = &#39;Y&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While a bitmap would use two:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    select id, age from people where age &amp;lt; 25 where bitmap_col &amp;amp; 00000110
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To allow employment status to have values for child, student, unemployed, employed, and retired, you would add extra bits representing each value. This applies to any column with a low number of potential values.&lt;/p&gt;

&lt;p&gt;This is a simple bitmap index, and you can use all kinds of bitwise operations on your queries against it. Complex queries can be simplified to a couple of binary operations. Of course, there is a downside. It&amp;rsquo;s harder to maintain, and if mapping a many-to-many relationship, you need to ensure consistency between the bit mask order and the contents of the other table. This can be enforced using a trigger or within the application.&lt;/p&gt;

&lt;p&gt;If you split the bitmap into individual columns and rotate it you can make a compressed bitmap index that only stores ranges of records that are true for each column or value of a column. Oracle provides this feature.&lt;/p&gt;

&lt;p&gt;These compressed bitmap indexes are even faster to query when used together in combination, and take up very little space. However, as multiple records&amp;rsquo; values can be held in a single entry in the index, updates to indexed columns can be slower and suffer from excessive locking on the index itself.&lt;/p&gt;

&lt;p&gt;Well-designed bitmap indices can have a huge impact on the performance of queries, as they are much smaller than standard b-tree indices and much faster on queries where a large proportion of that dataset is being queried.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jlcomp.demon.co.uk/bitmaps.doc&#34; class=&#34;uri&#34; class=&#34;podlinkurl&#34;&gt;&lt;a href=&#34;http://www.jlcomp.demon.co.uk/bitmaps.doc&#34;&gt;http://www.jlcomp.demon.co.uk/bitmaps.doc&lt;/a&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.dbazine.com/jlewis3.shtml&#34; class=&#34;uri&#34; class=&#34;podlinkurl&#34;&gt;&lt;a href=&#34;http://www.dbazine.com/jlewis3.shtml&#34;&gt;http://www.dbazine.com/jlewis3.shtml&lt;/a&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.oracle.com/technology/oramag/oracle/02-may/o32expert.html&#34; class=&#34;uri&#34; class=&#34;podlinkurl&#34;&gt;&lt;a href=&#34;http://www.oracle.com/technology/oramag/oracle/02-may/o32expert.html&#34;&gt;http://www.oracle.com/technology/oramag/oracle/02-may/o32expert.html&lt;/a&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;span-id-goodbye-farewell-amen-goodbye-farewell-amen-span&#34;&gt;&lt;span id=&#34;goodbye_farewell_amen&#34;&gt;Goodbye, Farewell, Amen&lt;/span&gt;&lt;/h3&gt;

&lt;h4 id=&#34;simon-cozens-1&#34;&gt;Simon Cozens&lt;/h4&gt;

&lt;p&gt;Let me first apologize for this personal note; I won&amp;rsquo;t do it again.&lt;/p&gt;

&lt;p&gt;Around the time I was busy being born, or maybe just a little after, Larry Wall was planning to be a missionary with the Wycliffe Bible Translators. Working on a degree in &amp;ldquo;Natural and Artificial Languages,&amp;rdquo; and then in linguistics graduate school, he learned about the ideas of tagmemics, semantics, and the cultural and anthropological concepts that have found their expression in the Perl language and culture. Unfortunately due to health problems, Larry couldn&amp;rsquo;t do the missionary thing, so he invented Perl. That&amp;rsquo;s why we&amp;rsquo;re all here.&lt;/p&gt;

&lt;p&gt;It was the beginning of May 2001 when Mark Dominus asked me if I&amp;rsquo;d be interesting in taking over the job of managing editor here at perl.com. I was delighted, and excited about the thought of working with the Perl community and hopefully producing and publishing some great resources for Perl programmers. I hope I&amp;rsquo;ve done a fair bit of that over the last three years, but now my time is up. I&amp;rsquo;m moving on, and starting next week the man simply known as &amp;ldquo;chromatic&amp;rdquo; will become Mr. Perl.com. Please treat him as well as you&amp;rsquo;ve treated me!&lt;/p&gt;

&lt;p&gt;I need to thank a bunch of people, who&amp;rsquo;ve done all the hard work behind the scenes that you don&amp;rsquo;t hear about: Mark, of course, for getting me involved here; Chris Coleman and Bruce Stewart from the O&amp;rsquo;Reilly Network who&amp;rsquo;ve had the curious experience of trying to manage me; Steve McCannell and Chris Valdez have been the producers of perl.com, and worked incessantly to get articles up on the site, often on shockingly short notice; Tara McGoldrick and others have been the copy editors; and of course, I&amp;rsquo;ve worked with a wide range of great authors and contributors. Thank you all. And thanks, of course, to the Perl community &amp;ndash; that&amp;rsquo;s &lt;strong&gt;you&lt;/strong&gt; &amp;ndash; without whom this wouldn&amp;rsquo;t be half as much fun.&lt;/p&gt;

&lt;p&gt;And about that missionary thing? Well, if Larry&amp;rsquo;s not going to be able to do it, someone has to. Like many Perl programmers, and indeed Larry himself, I&amp;rsquo;ve been interested in Japan for a very long time. In fact, I lived in Japan for a year, and was studying Japanese for my university major back when I started at perl.com; last year I decided that the time was right to prepare to move back to Japan, as a fulltime missionary.&lt;/p&gt;

&lt;p&gt;So in two weeks I&amp;rsquo;ll be going to All Nations University here in England for a two-year course to get me ready, and then I shall be off! I&amp;rsquo;m sure you won&amp;rsquo;t have heard the last of me, though, and I certainly won&amp;rsquo;t be stopping programming &amp;ndash; missionaries have things they need to automate too&amp;hellip; But for now, farewell! It&amp;rsquo;s been fun, and now it&amp;rsquo;s going to be fun in a different way.&lt;/p&gt;

&lt;p&gt;Take care out there, and happy hacking!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Profiling Perl</title>
      <link>http://localhost:1313/pub/2004/06/25/profiling.html/</link>
      <pubDate>Thu, 24 Jun 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/06/25/profiling.html/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; &lt;a href=&#34;http://www.perl.org/about/whitepapers/perl-profiling.html&#34;&gt;Perl Profiling&lt;/a&gt; has evolved since this article was written, please see &lt;a href=&#34;http://www.perl.org/about/whitepapers/perl-profiling.html&#34;&gt;http://www.perl.org/about/whitepapers/perl-profiling.html&lt;/a&gt; for the latest information.&lt;/p&gt;

&lt;p&gt;Everyone wants their Perl code to run faster. Unfortunately, without understanding why the code is taking so long to start with, it&amp;rsquo;s impossible to know where to start optimizing it. This is where &amp;ldquo;profiling&amp;rdquo; comes in; it lets us know what our programs are doing.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll look at why and how to profile programs, and then what to do with the profiling information once we&amp;rsquo;ve got it.&lt;/p&gt;

&lt;h3 id=&#34;span-id-why-profile-why-profile-span&#34;&gt;&lt;span id=&#34;Why_Profile?&#34;&gt;Why Profile?&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;There&amp;rsquo;s nothing worse than setting off a long-running Perl program and then not knowing what it&amp;rsquo;s doing. I&amp;rsquo;ve recently been working on a new, mail-archiving program for the &lt;code&gt;perl.org&lt;/code&gt; mailing lists, and so I&amp;rsquo;ve had to import a load of old email into the database. Here&amp;rsquo;s the code I used to do this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use File::Slurp;
    use Email::Store &amp;quot;dbi:SQLite:dbname=mailstore.db&amp;quot;;
    use File::Find::Rule;

    for (File::Find::Rule-&amp;gt;file-&amp;gt;name(qr/\d+/)-&amp;gt;in(&amp;quot;perl6-language&amp;quot;)) {
        Email::Store::Mail-&amp;gt;store(scalar read_file($_));
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s an innocent little program &amp;ndash; it looks for all the files in the &lt;em&gt;perl6-language&lt;/em&gt; directory whose names are purely numeric (this is how messages are stored in an ezmlm archive), reads the contents of the files into memory with &lt;code&gt;File::Slurp::read_file&lt;/code&gt;, and then uses &lt;a href=&#34;https://metacpan.org/pod/Email::Store&#34;&gt;&lt;code&gt;Email::Store&lt;/code&gt;&lt;/a&gt; to put them into a database. You start it running, and come back a few hours later and it&amp;rsquo;s done.&lt;/p&gt;

&lt;p&gt;All through, though, you have this nervous suspicion that it&amp;rsquo;s not doing the right thing; or at least, not doing it very quickly. Sure there&amp;rsquo;s a lot of mail, but should it really be taking this long? What&amp;rsquo;s it actually spending its time doing? We can add some &lt;code&gt;print&lt;/code&gt; statements to help us feel more at ease:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use File::Slurp;
    use Email::Store &amp;quot;dbi:SQLite:dbname=mailstore.db&amp;quot;;
    use File::Find::Rule;

    print &amp;quot;Starting run...\n&amp;quot;;
    $|++;
    for (File::Find::Rule-&amp;gt;file-&amp;gt;name(qr/\d+/)-&amp;gt;in(&amp;quot;perl6-language&amp;quot;)) {
        print &amp;quot;Indexing $_...&amp;quot;;
        Email::Store::Mail-&amp;gt;store(scalar read_file($_));
        print &amp;quot; done\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can at least see more progress, but we still don&amp;rsquo;t know if this program is working to full efficiency, and the reason for this is that there&amp;rsquo;s an awful lot going on in the underlying modules that we can&amp;rsquo;t immediately see. Is it the &lt;code&gt;File::Find::Rule&lt;/code&gt; that&amp;rsquo;s taking up all the time? Is it the storing process? Which part of the storing process? By profiling the code we&amp;rsquo;ll identify, and hopefully smooth over, some of the bottlenecks.&lt;/p&gt;

&lt;h3 id=&#34;span-id-simple-profiling-simple-profiling-span&#34;&gt;&lt;span id=&#34;Simple_Profiling&#34;&gt;Simple Profiling&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The granddaddy of Perl profiling tools is &lt;a href=&#34;https://metacpan.org/pod/Devel::DProf&#34;&gt;&lt;code&gt;Devel::DProf&lt;/code&gt;&lt;/a&gt;. To profile a code run, add the &lt;code&gt;-d:DProf&lt;/code&gt; argument to your Perl command line and let it go:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    % perl -d:DProf store_archive
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The run will now take slightly longer than normal as Perl collects and writes out information on your program&amp;rsquo;s subroutine calls and exits, and at the end of your job, you&amp;rsquo;ll find a file called &lt;em&gt;tmon.out&lt;/em&gt; in the current directory; this contains all the profiling information.&lt;/p&gt;

&lt;p&gt;A couple of notes about this:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It&amp;rsquo;s important to control the length of the run; in this case, I&amp;rsquo;d probably ensure that the mail archive contained about ten or fifteen mails to store. (I used seven in this example.) If your run goes on too long, you will end up processing a vast amount of profiling data, and not only will it take a lot time to read back in, it&amp;rsquo;ll take far too long for you to wade through all the statistics. On the other hand, if the run&amp;rsquo;s too short, the main body of the processing will be obscured by startup and other &amp;ldquo;fixed costs.&amp;rdquo;&lt;/li&gt;
&lt;li&gt;The other problem you might face is that &lt;code&gt;Devel::DProf&lt;/code&gt;, being somewhat venerable, occasionally has problems keeping up on certain recent Perls, (particularly the 5.6.x series) and may end up segfaulting all over the place. If this affects you, download the &lt;a href=&#34;https://metacpan.org/pod/Devel::Profiler&#34;&gt;&lt;code&gt;Devel::Profiler&lt;/code&gt;&lt;/a&gt; module from CPAN, which is a pure-Perl replacement for it.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The next step is to run the preprocessor for the profiler output, &lt;code&gt;dprofpp&lt;/code&gt;. This will produce a table of where our time has been spent:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Total Elapsed Time = 13.89525 Seconds
    User+System Time = 9.765255 Seconds
  Exclusive Times
  %Time ExclSec CumulS #Calls sec/call Csec/c  Name
   24.1   2.355  4.822     38   0.0620 0.1269  File::Find::_find_dir
   20.5   2.011  2.467  17852   0.0001 0.0001  File::Find::Rule::__ANON__
   7.82   0.764  0.764    531   0.0014 0.0014  DBI::st::execute
   4.73   0.462  0.462  18166   0.0000 0.0000  File::Spec::Unix::splitdir
   2.92   0.285  0.769    109   0.0026 0.0071  base::import
   2.26   0.221  0.402    531   0.0004 0.0008  Class::DBI::transform_sql
   2.09   0.204  0.203   8742   0.0000 0.0000  Class::Data::Inheritable::__ANON__
   1.72   0.168  0.359  18017   0.0000 0.0000  Class::DBI::Column::name_lc
   1.57   0.153  0.153  18101   0.0000 0.0000  Class::Accessor::get
   1.42   0.139  0.139     76   0.0018 0.0018  Cwd::abs_path
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first two lines tell us how long the program ran for: around 14 seconds, but it was actually only running for about 10 of those &amp;ndash; the rest of the time other programs on the system were in the foreground.&lt;/p&gt;

&lt;p&gt;Next we have a table of subroutines, in descending order of time spent; perhaps surprisingly, we find that &lt;code&gt;File::Find&lt;/code&gt; and &lt;code&gt;File::Find::Rule&lt;/code&gt; are the culprits for eating up 20% of running time each. We&amp;rsquo;re also told the number of &amp;ldquo;exclusive seconds,&amp;rdquo; which is the amount of time spent in one particular subroutine, and &amp;ldquo;cumulative seconds.&amp;rdquo; This might better be called &amp;ldquo;inclusive seconds,&amp;rdquo; since it&amp;rsquo;s the amount of time the program spent in a particular subroutine and all the other routines called from it.&lt;/p&gt;

&lt;p&gt;From the statistics above, we can guess that &lt;code&gt;File::Find::_find_dir&lt;/code&gt; itself took up 2 seconds of time, but during its execution, it called an anonymous subroutine created by &lt;code&gt;File::Find::Rule&lt;/code&gt;, and this subroutine also took up 2 seconds, making a cumulative time of 4 seconds. We also notice that we&amp;rsquo;re making an awful lot of calls to &lt;code&gt;File::Find::Rule&lt;/code&gt;, &lt;code&gt;splitdir&lt;/code&gt;, and some &lt;code&gt;Class::DBI&lt;/code&gt; and &lt;code&gt;Class::Accessor&lt;/code&gt; routines.&lt;/p&gt;

&lt;h3 id=&#34;span-id-what-to-do-now-what-to-do-now-span&#34;&gt;&lt;span id=&#34;What_to_do_now&#34;&gt;What to Do Now&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Now we have some profiling information, and we see a problem with &lt;code&gt;File::Find::Rule&lt;/code&gt;. &amp;ldquo;Aha,&amp;rdquo; we might think, &amp;ldquo;Let&amp;rsquo;s replace our use of &lt;code&gt;File::Find::Rule&lt;/code&gt; with a simple globbing operation, and we can shave 4 seconds off our runtime!&amp;ldquo;. So, just for an experiment, we try it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use File::Slurp;
    use Email::Store &amp;quot;dbi:SQLite:dbname=mailstore.db&amp;quot;;
    $|=1;
    for (&amp;lt;perl6-language/archive/0/*&amp;gt;) {
        next unless /\d+/;
        print &amp;quot;$_ ...&amp;quot;;
        Email::Store::Mail-&amp;gt;store(scalar read_file($_));
        print &amp;quot;\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now this looks a bit better:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; Total Elapsed Time = 9.559537 Seconds
   User+System Time = 5.329537 Seconds
 Exclusive Times
 %Time ExclSec CumulS #Calls sec/call Csec/c  Name
  13.1   0.703  0.703    531   0.0013 0.0013  DBI::st::execute
  5.54   0.295  0.726    109   0.0027 0.0067  base::import
  5.52   0.294  0.294  18101   0.0000 0.0000  Class::Accessor::get
  3.45   0.184  1.930  19443   0.0000 0.0001  Class::Accessor::__ANON__
  3.13   0.167  0.970    531   0.0003 0.0018  DBIx::ContextualFetch::st::_untain
                                              t_execute
  3.10   0.165  1.324   1364   0.0001 0.0010  Class::DBI::get
  2.98   0.159  0.376    531   0.0003 0.0007  Class::DBI::transform_sql
  2.61   0.139  0.139     74   0.0019 0.0019  Cwd::abs_path
  2.23   0.119  0.119   8742   0.0000 0.0000  Class::Data::Inheritable::__ANON__
  2.06   0.110  0.744   2841   0.0000 0.0003  Class::DBI::__ANON__
  1.95   0.104  0.159   2669   0.0000 0.0001  Class::DBI::ColumnGrouper::group_cols
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now to be honest, I would never have guessed that removing &lt;code&gt;File::Find::Rule&lt;/code&gt; would shave 4 seconds off my code run. This is the first rule of profiling: You actually need to profile before optimizing, because &lt;strong&gt;you never know where the hotspots are going to turn out to be.&lt;/strong&gt; We&amp;rsquo;ve also exercised the second rule of profiling: &lt;strong&gt;Review what you&amp;rsquo;re using.&lt;/strong&gt; By using another technique instead of &lt;code&gt;File::Find::Rule&lt;/code&gt;, we&amp;rsquo;ve reduced our running time by a significant amount.&lt;/p&gt;

&lt;p&gt;This time, it looks as though we&amp;rsquo;re doing reasonably well &amp;ndash; the busiest thing is writing to a database, and that&amp;rsquo;s basically what this application does, so that&amp;rsquo;s fair enough. There&amp;rsquo;s also a lot of busy calls that are to do with &lt;code&gt;Class::DBI&lt;/code&gt;, and we know that we use &lt;code&gt;Class::DBI&lt;/code&gt; as a deliberate tradeoff between convenience and efficiency. If we were being ruthlessly determined to make this program faster, we&amp;rsquo;d start looking at using plain &lt;code&gt;DBI&lt;/code&gt; instead of &lt;code&gt;Class::DBI&lt;/code&gt;, but that&amp;rsquo;s a tradeoff I don&amp;rsquo;t think is worth making at the moment.&lt;/p&gt;

&lt;p&gt;This is the third rule of profiling: &lt;strong&gt;Hotspots happen.&lt;/strong&gt; If you got rid of all the hotspots in your code, it wouldn&amp;rsquo;t do anything. There are a certain reasonable number of things that your program should be doing for it to be useful, and you simply can&amp;rsquo;t get rid of them; additionally there are any number of tradeoffs that we deliberately or subconsciously make in order to make our lives easier at some potential speed cost &amp;ndash; for instance, writing in Perl or C instead of machine code.&lt;/p&gt;

&lt;h3 id=&#34;span-id-from-exclusive-to-inclusive-from-exclusive-to-inclusive-span&#34;&gt;&lt;span id=&#34;From_exclusive_to_inclusive&#34;&gt;From Exclusive to Inclusive&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The default report produced by &lt;em&gt;dprofpp&lt;/em&gt; is sorted by exclusive subroutine time, and is therefore good at telling us about individual subroutines that are called a lot and take up disproportionate amounts of time. This can be useful, but it doesn&amp;rsquo;t actually give us an overall view of what our code is doing. If we want to do that, we need to move from looking at exclusive to looking at inclusive times, and we do this by adding the &lt;code&gt;-I&lt;/code&gt; option to &lt;em&gt;dprofpp&lt;/em&gt;. This produces something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; Total Elapsed Time = 9.559537 Seconds
   User+System Time = 5.329537 Seconds
 Inclusive Times
 %Time ExclSec CumulS #Calls sec/call Csec/c  Name
  83.8   0.009  4.468      7   0.0013 0.6383  Email::Store::Mail::store
  80.8   0.061  4.308     35   0.0017 0.1231  Module::Pluggable::Ordered::__ANON
                                              __
  46.3       -  2.472      3        - 0.8239  main::BEGIN
  43.4       -  2.314      7        - 0.3306  Mail::Thread::thread
  43.4       -  2.314      7        - 0.3305  Email::Store::Thread::on_store
  36.2   0.184  1.930  19443   0.0000 0.0001  Class::Accessor::__ANON__
  28.9   0.006  1.543    531   0.0000 0.0029  Email::Store::Thread::Container::_
                                              _ANON__
  27.3   0.068  1.455    105   0.0006 0.0139  UNIVERSAL::require
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This tells us a number of useful facts. First, we find that 84% of the program&amp;rsquo;s runtime is spent in the &lt;code&gt;Email::Store::Mail::store&lt;/code&gt; subroutine and its descendants, which is the main, tight loop of the program. This means, quite logically, that 16% is not spent in the main loop, and that&amp;rsquo;s a good sign &amp;ndash; this means that we have a 1-second fixed cost in starting up and loading the appropriate modules, and this will amortize nicely against a longer run than 10 seconds. After all, if processing a massive amount of mail takes 20 minutes, the first 1-second startup becomes insignificant. It means we can pretty much ignore everything outside the main loop.&lt;/p&gt;

&lt;p&gt;We also find that threading the emails is costly; threading involves a lot of manipulation of &lt;code&gt;Email::Store::Thread::Container&lt;/code&gt; objects, which are database backed. This means that a lot of the database stores and executes that we saw in the previous, exclusive report are probably something to do with threading. After all, we now spend 2 seconds out of our 4 seconds of processing time on threading in &lt;code&gt;Mail::Thread::thread&lt;/code&gt;, and even though we only call this seven times, we do 531 things with the container objects. This is bad.&lt;/p&gt;

&lt;p&gt;Now, I happen to know (because I wrote the module) that &lt;code&gt;Email::Store::Thread::Container&lt;/code&gt; uses a feature of &lt;code&gt;Class::DBI&lt;/code&gt; called &lt;code&gt;autoupdate&lt;/code&gt;. This means that while we do a lot of fetches and stores that we could conceivably do in memory and commit to the database once we&amp;rsquo;re done, we instead hit the database every single time.&lt;/p&gt;

&lt;p&gt;So, just as an experiment, we do two things to optimize &lt;code&gt;Email::Store::Thread::Container&lt;/code&gt;. First, we know that we&amp;rsquo;re going to be doing a lot of database fetches, sometimes of the same container multiple times, so we cache the fetch. We turn this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub new { 
        my ($class, $id) = @_;
        $class-&amp;gt;find_or_create({ message =&amp;gt; $id });
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Into this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my %container_cache = ();
    sub new {
        my ($class, $id) = @_;
        $container_cache{$id} 
            ||= $class-&amp;gt;find_or_create({ message =&amp;gt; $id });
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a standard caching technique, and will produce another tradeoff: we trade memory (in filling up &lt;code&gt;%container_cache&lt;/code&gt; with a bunch of objects) for speed (in not having to do as many costly database fetches).&lt;/p&gt;

&lt;p&gt;Then we turn &lt;code&gt;autoupdate&lt;/code&gt; off, and provide a way of updating the database manually. The reason we wanted to turn off &lt;code&gt;autoupdate&lt;/code&gt; is that because all these containers form a tree structure (since they represent mails in a thread which, naturally, form a tree structure), it&amp;rsquo;s a pain to traverse the tree and update all the containers once we&amp;rsquo;re done.&lt;/p&gt;

&lt;p&gt;However, with this cache in place, we know that we already have a way to get at all the containers in one go: we just look at the values of &lt;code&gt;%container_hash&lt;/code&gt;, and there are all the objects we&amp;rsquo;ve used. So we can now add a &lt;code&gt;flush&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub flush {
        (delete $container_cache{$_})-&amp;gt;update for keys %container_cache;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This both empties the cache and updates the database. The only remaining problem is working out where to call &lt;code&gt;flush&lt;/code&gt;. If we&amp;rsquo;re dealing with absolutely thousands of emails, it might be worth calling &lt;code&gt;flush&lt;/code&gt; after every &lt;code&gt;store&lt;/code&gt;, or else &lt;code&gt;%container_hash&lt;/code&gt; will get huge. However, since we&amp;rsquo;re not, we just call &lt;code&gt;flush&lt;/code&gt; in an &lt;code&gt;END&lt;/code&gt; block to catch the container objects before they get destroyed by the garbage collector:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    END { Email::Store::Thread::Container-&amp;gt;flush; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running &lt;em&gt;dprofpp&lt;/em&gt; again:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; Total Elapsed Time = 7.741969 Seconds
   User+System Time = 3.911969 Seconds
 Inclusive Times
 %Time ExclSec CumulS #Calls sec/call Csec/c  Name
  65.4       -  2.559      7        - 0.3656  Email::Store::Mail::store
  62.9   0.014  2.461     35   0.0004 0.0703  Module::Pluggable::Ordered::__ANON
                                              __
  56.2   0.020  2.202      3   0.0065 0.7341  main::BEGIN
  31.8   0.028  1.247    105   0.0003 0.0119  UNIVERSAL::require
  29.4   0.004  1.150      7   0.0006 0.1642  Email::Store::Entity::on_store
  22.7   0.025  0.890    100   0.0003 0.0089  Class::DBI::create
  21.0   0.031  0.824    100   0.0003 0.0082  Class::DBI::_create
  18.3   0.235  0.716    109   0.0022 0.0066  base::import
  15.1       -  0.594    274        - 0.0022  DBIx::ContextualFetch::st::execute
  15.1       -  0.592      7        - 0.0846  Mail::Thread::thread
  15.1       -  0.592      7        - 0.0845  Email::Store::Thread::on_store
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We find that we&amp;rsquo;ve managed to shave another second-and-a-half off, and we&amp;rsquo;ve also swapped a per-mail cost (of updating the threading containers every time) to a once-per-run fixed cost (of updating them all at the end of the run). This has taken the business of threading down from two-and-a-half seconds per run to half a second per run, and it means that 35% of our running time is outside the main loop; again, this will amortize nicely on large runs.&lt;/p&gt;

&lt;p&gt;We started with a program that runs for 10 seconds, and now it runs for 4. Through judicious use of the profiler, we&amp;rsquo;ve identified the hotspots and eliminated the most troublesome ones. We&amp;rsquo;ve looked at both exclusive and inclusive views of the profiling data, but there are still a few other things that &lt;em&gt;dprofpp&lt;/em&gt; can tell us. For instance, the &lt;code&gt;-S&lt;/code&gt; option gives us a call tree, showing what gets called from what. These trees can be incredibly long and tedious, but if the two views we&amp;rsquo;ve already looked at haven&amp;rsquo;t identified potential trouble spots, then wading through the tree might be your only option.&lt;/p&gt;

&lt;h3 id=&#34;span-id-writing-your-own-profiler-writing-your-own-profiler-span&#34;&gt;&lt;span id=&#34;Writing_your_own_profiler&#34;&gt;Writing your Own Profiler&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;At least, that is, if you want to use &lt;em&gt;dprofpp&lt;/em&gt;; until yesterday, that was the only way of reading profiling data. Yesterday, however, I released &lt;a href=&#34;https://metacpan.org/pod/Devel::DProfPP&#34;&gt;&lt;code&gt;Devel::DProfPP&lt;/code&gt;&lt;/a&gt;, which provides an event-driven interface to reading &lt;em&gt;tmon.out&lt;/em&gt; files. I intended to use it to write a new version of &lt;em&gt;dprofpp&lt;/em&gt; because I find the current profiler intolerably slow; ironically, though, I haven&amp;rsquo;t profiled it yet.&lt;/p&gt;

&lt;p&gt;Anyway, &lt;code&gt;Devel::DProfPP&lt;/code&gt; allows you to specify callbacks to be run every time the profiling data shows Perl entering or exiting a subroutine, and provides access to the same timing and call stack information used by &lt;em&gt;dprofpp&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;So, for instance, I like visualization of complicated data. I&amp;rsquo;d prefer to see what&amp;rsquo;s calling what as a graph that I can print out and pore over, rather than as a listing. So, I pull together &lt;code&gt;Devel::DProfPP&lt;/code&gt; and the trusty &lt;a href=&#34;https://metacpan.org/pod/GraphViz&#34;&gt;&lt;code&gt;Graphviz&lt;/code&gt;&lt;/a&gt; module, and create my own profiler:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; use GraphViz;
 use Devel::DProfPP;

 my $graph = GraphViz-&amp;gt;new();
 my %edges = ();
 Devel::DProfPP-&amp;gt;new(enter =&amp;gt; sub {
     my $pp = shift;
     my @stack = $pp-&amp;gt;stack;
     my $to = $stack[-1]-&amp;gt;sub_name;
     my $from = @stack &amp;gt; 1 ? $stack[-2]-&amp;gt;sub_name : &amp;quot;MAIN BODY&amp;quot;;
     $graph-&amp;gt;add_edge($from =&amp;gt; $to) unless $edges{$from.&amp;quot; -&amp;gt; &amp;quot;.$to}++;
 })-&amp;gt;parse;

 print $graph-&amp;gt;as_png;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Every time we enter a subroutine, we look at the call stack so far. We pick the top frame of the stack, and ask for its subroutine name. If there&amp;rsquo;s another subroutine on the stack, we take that off too; otherwise we&amp;rsquo;re being called from the main body of the code. Then we add an edge on our graph between the two subroutines, unless we&amp;rsquo;ve already got one. Finally, we print out the graph as a PNG file for me to print out and stick on the wall.&lt;/p&gt;

&lt;p&gt;There are any number of other things you can do with &lt;code&gt;Devel::DProfPP&lt;/code&gt; if the ordinary profiler doesn&amp;rsquo;t suit your needs for some reason; but as we&amp;rsquo;ve seen, just judicious application of profiling and highlighting hotspots in your code can cut the running time of a long-running Perl program by 50% or so, and can also help you to understand what your code is spending all its time doing.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Evolution of Perl Email Handling</title>
      <link>http://localhost:1313/pub/2004/06/10/email.html/</link>
      <pubDate>Thu, 10 Jun 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/06/10/email.html/</guid>
      <description>

&lt;p&gt;I spend the vast majority of my time at a computer working with email, whether it&amp;rsquo;s working through the ones I send and receive each day, or working on my interest in analyzing, indexing, organizing, and mining email content. Naturally, Perl helps out with this.&lt;/p&gt;

&lt;p&gt;There are many modules on the CPAN for slicing and dicing email, and we&amp;rsquo;re going to take a whistlestop tour of the major ones. We&amp;rsquo;ll also concentrate on an effort started by myself, Richard Clamp, Simon Wistow, and others, called the Perl Email Project, to produce simple, efficient and accurate mail handling modules.&lt;/p&gt;

&lt;h3 id=&#34;span-id-message-handling-message-handling-span&#34;&gt;&lt;span id=&#34;Message_handling&#34;&gt;Message Handling&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ll begin with those modules that represent an individual message, giving you access to the headers and body, and usually allowing you to modify these.&lt;/p&gt;

&lt;p&gt;The granddaddy of these modules is &lt;a href=&#34;https://metacpan.org/pod/Mail::Internet&#34;&gt;&lt;code&gt;Mail::Internet&lt;/code&gt;&lt;/a&gt;, originally created by Graham Barr and now maintained by Mark Overmeer. This module offers a constructor that takes either an array of lines or a filehandle, reads a message, and returns a &lt;code&gt;Mail::Internet&lt;/code&gt; object representing the message. Throughout these examples, we&amp;rsquo;ll use the variable &lt;code&gt;$rfc2822&lt;/code&gt; to represent a mail message as a string.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $obj = Mail::Internet-&amp;gt;new( [ split /\n/, $rfc2822 ] );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Mail::Internet&lt;/code&gt; splits a message into a header object in the &lt;a href=&#34;https://metacpan.org/pod/Mail::Header&#34;&gt;&lt;code&gt;Mail::Header&lt;/code&gt;&lt;/a&gt; class, plus a body. You can get and set individual headers through this object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $subject = $obj-&amp;gt;head-&amp;gt;get(&amp;quot;Subject&amp;quot;);
    $obj-&amp;gt;head-&amp;gt;replace(&amp;quot;Subject&amp;quot;, &amp;quot;New subject&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reading and editing the body is done through the &lt;code&gt;body&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $old_body = $obj-&amp;gt;body;
    $obj-&amp;gt;body(&amp;quot;Wasn&#39;t worth reading anyway.&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;ve not said anything about MIME yet. &lt;code&gt;Mail::Internet&lt;/code&gt; is reasonably handy for simple tasks, but it doesn&amp;rsquo;t handle MIME at all. Thankfully, &lt;a href=&#34;https://metacpan.org/pod/MIME::Entity&#34;&gt;&lt;code&gt;MIME::Entity&lt;/code&gt;&lt;/a&gt; is a MIME-aware subclass of &lt;code&gt;Mail::Internet&lt;/code&gt;; it allows you to read individual parts of a MIME message:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $num_parts = $obj-&amp;gt;parts;
    for (0..$num_parts) {
        my $part = $obj-&amp;gt;parts($_);
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If &lt;code&gt;Mail::Internet&lt;/code&gt; and &lt;code&gt;MIME::Entity&lt;/code&gt; don&amp;rsquo;t cut it for you, you can try Mark Overmeer&amp;rsquo;s own &lt;a href=&#34;https://metacpan.org/pod/Mail::Message&#34;&gt;&lt;code&gt;Mail::Message&lt;/code&gt;&lt;/a&gt;, part of the impressive &lt;a href=&#34;https://metacpan.org/pod/Mail::Box&#34;&gt;&lt;code&gt;Mail::Box&lt;/code&gt;&lt;/a&gt; suite. &lt;code&gt;Mail::Message&lt;/code&gt; is extremely featureful and comprehensive, but that is not always meant as a compliment.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Mail::Message&lt;/code&gt; objects are usually constructed by &lt;code&gt;Mail::Box&lt;/code&gt; as part of reading in an email folder, but can also be generated from an email using the &lt;code&gt;read&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $obj = Mail::Message-&amp;gt;read($rfc2822);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Like &lt;code&gt;Mail::Internet&lt;/code&gt;, messages are split into headers and bodies; unlike &lt;code&gt;Mail::Internet&lt;/code&gt;, the body of a &lt;code&gt;Mail::Message&lt;/code&gt; object is also an object. We read headers like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $obj-&amp;gt;head-&amp;gt;get(&amp;quot;Subject&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or, for &lt;code&gt;Subject&lt;/code&gt; and other common headers:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $obj-&amp;gt;subject;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I couldn&amp;rsquo;t find a way to set headers directly, and ended up doing this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $obj-&amp;gt;head-&amp;gt;delete($header);
    $obj-&amp;gt;head-&amp;gt;add($header, $_) for @data;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reading the body as a string is only marginally more difficult:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $obj-&amp;gt;decoded-&amp;gt;string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While setting the body is an absolute nightmare&amp;ndash;we have to create a new &lt;code&gt;Mail::Message::Body&lt;/code&gt; object and replace our current one with it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $obj-&amp;gt;body(Mail::Message::Body-&amp;gt;new(data =&amp;gt; [split /\n/, $body]));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Mail::Message&lt;/code&gt; may be slow, but it&amp;rsquo;s certainly hard to use. It&amp;rsquo;s also rather complex; the operations we&amp;rsquo;ve looked at so far involved the use of 16 classes (&lt;code&gt;Mail::Address&lt;/code&gt;, &lt;code&gt;Mail::Box::Parser&lt;/code&gt;, &lt;code&gt;Mail::Box::Parser::Perl&lt;/code&gt;, &lt;code&gt;Mail::Message&lt;/code&gt;, &lt;code&gt;Mail::Message::Body&lt;/code&gt;, &lt;code&gt;Mail::Message::Body::File&lt;/code&gt;, &lt;code&gt;Mail::Message::Body::Lines&lt;/code&gt;, &lt;code&gt;Mail::Message::Body::Multipart&lt;/code&gt;, &lt;code&gt;Mail::Message::Body::Nested&lt;/code&gt;, &lt;code&gt;Mail::Message::Construct&lt;/code&gt;, &lt;code&gt;Mail::Message::Field&lt;/code&gt;, &lt;code&gt;Mail::Message::Field::Fast&lt;/code&gt;, &lt;code&gt;Mail::Message::Head&lt;/code&gt;, &lt;code&gt;Mail::Message::Head::Complete&lt;/code&gt;, &lt;code&gt;Mail::Message::Part&lt;/code&gt;, and &lt;code&gt;Mail::Reporter&lt;/code&gt;) and 4400 lines of code. It does have a lot of features, though.&lt;/p&gt;

&lt;p&gt;Foolishly, I thought that email parsing shouldn&amp;rsquo;t be so complex, and so I sat down to write the simplest possible functional mail handling library. The result is &lt;a href=&#34;https://metacpan.org/pod/Email::Simple&#34;&gt;&lt;code&gt;Email::Simple&lt;/code&gt;&lt;/a&gt;, and its interface looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $obj = Email::Simple-&amp;gt;new($rfc2822);
    my $subject = $obj-&amp;gt;header(&amp;quot;Subject&amp;quot;);
    $obj-&amp;gt;header_set(&amp;quot;Subject&amp;quot;, &amp;quot;A new subject&amp;quot;);
    my $old_body = $obj-&amp;gt;body;
    $obj-&amp;gt;body_set(&amp;quot;A new body\n&amp;quot;);
    print $obj-&amp;gt;as_string;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It doesn&amp;rsquo;t do a lot, but it does it simply and efficiently. If you need MIME handling, there&amp;rsquo;s a subclass called &lt;a href=&#34;https://metacpan.org/pod/Email::MIME&#34;&gt;&lt;code&gt;Email::MIME&lt;/code&gt;&lt;/a&gt;, which adds the &lt;code&gt;parts&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;Realistically, the choice of which mail handling library to use ought to be up to you, the end user, but this isn&amp;rsquo;t always true. Auxilliary modules, which mess about with email at a higher level, can ask for the mail to be presented in a particular representation. For instance, until recently, the wonderful &lt;code&gt;Mail::ListDetector&lt;/code&gt; module, which we&amp;rsquo;ll examine later, required mails passed in to it to be &lt;code&gt;Mail::Internet&lt;/code&gt; objects, since this gave it a known API to work with the objects. I don&amp;rsquo;t want to work with &lt;code&gt;Mail::Internet&lt;/code&gt; objects, but I want to use &lt;code&gt;Mail::ListDetector&lt;/code&gt;&amp;rsquo;s functionality. What can I do?&lt;/p&gt;

&lt;p&gt;In order to enable the user to have the choice again, I wrote an abstraction layer across all of the above modules, called &lt;a href=&#34;https://metacpan.org/pod/Email::Abstract&#34;&gt;&lt;code&gt;Email::Abstract&lt;/code&gt;&lt;/a&gt;. Given any of the above objects, we can say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     my $subject = Email::Abstract-&amp;gt;get_header($obj, &amp;quot;Subject&amp;quot;);
     Email::Abstract-&amp;gt;set_header($obj, &amp;quot;Subject&amp;quot;, &amp;quot;My new subject&amp;quot;);
     my $body = Email::Abstract-&amp;gt;get_body($obj);
     Email::Abstract-&amp;gt;set_body($message, &amp;quot;Hello\nTest message\n&amp;quot;);
     $rfc2822 = Email::Abstract-&amp;gt;as_string($obj);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Email::Abstract&lt;/code&gt; knows how to perform these operations on the major types of mail representation objects. It also abstracts out the process of constructing a message, and allows you to change the interface of a message using the &lt;code&gt;cast&lt;/code&gt; class method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $obj = Email::Abstract-&amp;gt;cast($rfc2822, &amp;quot;Mail::Internet&amp;quot;);
    my $mm = Email::Abstract-&amp;gt;cast($obj, &amp;quot;Mail::Message&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This allows module authors to write their mail handling libraries in an interface-agnostic way, and I&amp;rsquo;m grateful to Michael Stevens for taking up &lt;code&gt;Email::Abstract&lt;/code&gt; in &lt;code&gt;Mail::ListDetector&lt;/code&gt; so quickly. Now I can pass in &lt;code&gt;Email::Simple&lt;/code&gt; objects to &lt;code&gt;Mail::ListDetector&lt;/code&gt; and it will work fine.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Email::Abstract&lt;/code&gt; also gives us the opportunity to create some benchmarks for all of the above modules. Here was the benchmarking code I used:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Email::Abstract;
    my $message = do { local $/; &amp;lt;DATA&amp;gt;; };
    my @classes =
        qw(Email::MIME Email::Simple MIME::Entity Mail::Internet Mail::Message);

    eval &amp;quot;require $_&amp;quot; or die $@ for @classes;

    use Benchmark;
    my %h;
    for my $class (@classes) {
        $h{$class} = sub {
            my $obj = Email::Abstract-&amp;gt;cast($message, $class);
            Email::Abstract-&amp;gt;get_header($obj, &amp;quot;Subject&amp;quot;);
            Email::Abstract-&amp;gt;get_body($obj);
            Email::Abstract-&amp;gt;set_header($obj, &amp;quot;Subject&amp;quot;, &amp;quot;New Subject&amp;quot;);
            Email::Abstract-&amp;gt;set_body($obj, &amp;quot;A completely new body&amp;quot;);
            Email::Abstract-&amp;gt;as_string($obj);
        }
    }
    timethese(1000, \%h);

    __DATA__
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I put a short email in the &lt;code&gt;DATA&lt;/code&gt; section and ran the same simple operations a thousand times: construct a message, read a header, read the body, set the header, set the body, and return the message as a string.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Benchmark: timing 1000 iterations of Email::MIME, Email::Simple, 
    MIME::Entity, Mail::Internet, Mail::Message...
    Email::MIME: 10 wallclock secs ( 7.97 usr +  0.24 sys =  8.21 CPU) 
        @ 121.80/s (n=1000)
    Email::Simple:  9 wallclock secs ( 7.49 usr +  0.05 sys =  7.54 CPU) 
        @ 132.63/s (n=1000)
    MIME::Entity: 33 wallclock secs (23.76 usr +  0.35 sys = 24.11 CPU) 
        @ 41.48/s (n=1000)
    Mail::Internet: 24 wallclock secs (17.34 usr +  0.30 sys = 17.64 CPU) 
        @ 56.69/s (n=1000)
    Mail::Message: 20 wallclock secs (17.12 usr +  0.27 sys = 17.39 CPU) 
        @ 57.50/s (n=1000)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Perl Email Project was a success: &lt;code&gt;Email::MIME&lt;/code&gt; and &lt;code&gt;Email::Simple&lt;/code&gt; were twice as fast as their nearest competitors. However, it should be stressed that they&amp;rsquo;re both very low level; if you&amp;rsquo;re doing anything more complex than the operations we&amp;rsquo;ve seen, you might consider one of the older &lt;code&gt;Mail::&lt;/code&gt; modules.&lt;/p&gt;

&lt;h3 id=&#34;span-id-mailbox-handling-mailbox-handling-span&#34;&gt;&lt;span id=&#34;Mailbox_handling&#34;&gt;Mailbox Handling&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;So much for individual messages; let&amp;rsquo;s move on to handling groups of messages, or folders. We&amp;rsquo;ve mentioned &lt;code&gt;Mail::Box&lt;/code&gt; already, and this is truly the king of folder handling, supporting local and remote folders, editing folders, and all sorts of other things besides. To use it, we first need a &lt;code&gt;Mail::Box::Manager&lt;/code&gt;, which is a factory object for creating &lt;code&gt;Mail::Box&lt;/code&gt;es.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Mail::Box::Manager
    my $mgr = Mail::Box::Manager-&amp;gt;new;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we need to open the folder using the manager:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $folder = $mgr-&amp;gt;open(folder =&amp;gt; $folder_file);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now we can get at the individual messages as &lt;code&gt;Mail::Message&lt;/code&gt; objects:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for ($folder-&amp;gt;messages) {
        print $_-&amp;gt;subject,&amp;quot;\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With its more minimalist approach, my favorite mail box manager until recently was &lt;code&gt;Mail::Util&lt;/code&gt;&amp;rsquo;s &lt;code&gt;read_mbox&lt;/code&gt; function, which takes the name of a Unix &lt;code&gt;mbox&lt;/code&gt; file, and returns a list of array references; each reference is the array of lines of a message, suitable for feeding to &lt;code&gt;Mail::Internet-&amp;gt;new&lt;/code&gt; or similar:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for (read_mbox($folder_file)) {
        my $obj = Mail::Internet-&amp;gt;new($_);
        print $_-&amp;gt;head-&amp;gt;get(&amp;quot;Subject&amp;quot;),&amp;quot;\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These two are both really handy, but there seemed to be room for something in between the simplicity of &lt;code&gt;Mail::Util&lt;/code&gt; and the functionality of &lt;code&gt;Mail::Box&lt;/code&gt;, and so the Email Project struck again with &lt;a href=&#34;https://metacpan.org/pod/Email::Folder&#34;&gt;&lt;code&gt;Email::Folder&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://metacpan.org/pod/Email::LocalDelivery&#34;&gt;&lt;code&gt;Email::LocalDelivery&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;Email::Folder&lt;/code&gt; handles mbox and maildir folders, with more types planned, and has a reasonably simple interface:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $folder = Email::Folder-&amp;gt;new($folder_file);
    for ($folder-&amp;gt;messages) {
        print $_-&amp;gt;header(&amp;quot;Subject&amp;quot;),&amp;quot;\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By default it returns &lt;code&gt;Email::Simple&lt;/code&gt; objects for the messages, but this can be changed by subclassing. For instance, if we want raw RFC2822 strings, we can do this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package Email::Folder::Raw; use base &#39;Email::Folder&#39;;
    sub bless_message { my ($self, $rfc2822) = @_; return $rfc2822; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perhaps in the future, we will change &lt;code&gt;bless_message&lt;/code&gt; to use &lt;code&gt;Email::Abstract-&amp;gt;cast&lt;/code&gt; to make the representation of messages easier to select without necessarily having to subclass.&lt;/p&gt;

&lt;p&gt;The other side of folder handling is writing to a folder, or &amp;ldquo;local delivery&amp;rdquo;. &lt;a href=&#34;https://metacpan.org/pod/Email::LocalDelivery&#34;&gt;&lt;code&gt;Email::LocalDelivery&lt;/code&gt;&lt;/a&gt; was written to assist &lt;code&gt;Email::Filter&lt;/code&gt;, of which more later. The problem is harder than it sounds, as it has to deal with locking, escaping mail bodies, and specific problems due to mailbox and maildir formats. &lt;code&gt;LocalDelivery&lt;/code&gt; hides all of these things beneath a simple interface:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Email::LocalDelivery-&amp;gt;deliver($rfc2822, @mailboxes);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Both &lt;code&gt;Email::LocalDelivery&lt;/code&gt; and &lt;code&gt;Email::Folder&lt;/code&gt; use the &lt;a href=&#34;https://metacpan.org/pod/Email::FolderType&#34;&gt;&lt;code&gt;Email::FolderType&lt;/code&gt;&lt;/a&gt; helper module to determine the type of a folder based on its filename.&lt;/p&gt;

&lt;h3 id=&#34;span-id-address-handling-address-handling-span&#34;&gt;&lt;span id=&#34;Address_handling&#34;&gt;Address Handling&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;To come down to a lower level of abstraction again, there are a number of modules for handling email addresses. The old favorite is &lt;a href=&#34;https://metacpan.org/pod/Mail::Address&#34;&gt;&lt;code&gt;Mail::Address&lt;/code&gt;&lt;/a&gt;. A mail address appearing in the fields of an email can be made up of several elements: the actual address, a phrase or name, and a comment. For instance:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Example user &amp;lt;example@example.com&amp;gt; (Not a real user)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Mail::Address&lt;/code&gt; parses these addresses, separating out the phrase and comments, allowing you to get at the individual components:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for (Mail::Address-&amp;gt;parse($from_line)) {
        print $_-&amp;gt;name, &amp;quot;\t&amp;quot;, $_-&amp;gt;address, &amp;quot;\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unfortunately, like many of the mail modules, it tries really hard to be helpful.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my ($addr) = Mail::Address-&amp;gt;parse(&#39;&amp;quot;eBay, Inc.&amp;quot; &amp;lt;support@ebay.com&amp;gt;&#39;);
    print $addr-&amp;gt;name # Inc. eBay
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which, while better than the &amp;ldquo;Inc Ebay&amp;rdquo; that previous versions would produce, isn&amp;rsquo;t really acceptable. Casey West joined our merry band of renegades and produced &lt;a href=&#34;https://metacpan.org/pod/Email::Address&#34;&gt;&lt;code&gt;Email::Address&lt;/code&gt;&lt;/a&gt;. It has exactly the same interface as &lt;code&gt;Mail::Address&lt;/code&gt;, but it works, and is about twice to three times as fast.&lt;/p&gt;

&lt;p&gt;One thing we often want to do when handling mail addresses is to make sure that they&amp;rsquo;re valid. If, for instance, a user is registering for content at a web site, we need to check that the address they&amp;rsquo;ve given is capable of receiving mail. &lt;a href=&#34;https://metacpan.org/pod/Email::Valid&#34;&gt;&lt;code&gt;Email::Valid&lt;/code&gt;&lt;/a&gt;, the original inhabitant of the &lt;code&gt;Email::&lt;/code&gt; namespace before our bunch of disaffected squatters moved in, does just this. In its most simple use, we can say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if (not Email::Valid-&amp;gt;address(&#39;test@example.com&#39;)) {
        die &amp;quot;Not a valid address&amp;quot;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can turn on additional checks, such as ensuring there&amp;rsquo;s a valid MX record for the domain, correcting common AOL and Compuserve addressing mistakes, on so on:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if (not Email::Valid-&amp;gt;address(-address =&amp;gt; &#39;test@example.com&#39;,
                                  -mxcheck =&amp;gt; 1)) {
        die &amp;quot;Not a valid address&amp;quot;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-mail-munging-mail-munging-span&#34;&gt;&lt;span id=&#34;Mail_munging&#34;&gt;Mail Munging&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Once we have our emails, what are we going to do with them? A lot of what I&amp;rsquo;ve been looking at has been textual analysis of email, and there are three modules that particularly help with this.&lt;/p&gt;

&lt;p&gt;This first is &lt;code&gt;Text::Quoted&lt;/code&gt;; it takes the body text of an email message, or any other text really, and tries to figure out which parts of the message are quotations from other messages. It then separates these out into a nested data structure. For instance, if we have&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $message = &amp;lt;&amp;lt;EOF
    &amp;gt; foo
    &amp;gt; # Bar
    &amp;gt; baz

    quux
    EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then running &lt;code&gt;extract($message)&lt;/code&gt; will return a data structure like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [
      [
        { text =&amp;gt; &#39;foo&#39;, quoter =&amp;gt; &#39;&amp;gt;&#39;, raw =&amp;gt; &#39;&amp;gt; foo&#39; },
        [ 
            { text =&amp;gt; &#39;Bar&#39;, quoter =&amp;gt; &#39;&amp;gt; #&#39;, raw =&amp;gt; &#39;&amp;gt; # Bar&#39; } 
        ],
        { text =&amp;gt; &#39;baz&#39;, quoter =&amp;gt; &#39;&amp;gt;&#39;, raw =&amp;gt; &#39;&amp;gt; baz&#39; }
      ],

      { empty =&amp;gt; 1 },
      { text =&amp;gt; &#39;quux&#39;, quoter =&amp;gt; &#39;&#39;, raw =&amp;gt; &#39;quux&#39; }
    ];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is extremely useful for highlighting different levels of quoting in different colors when displaying a message. A similar concept is &lt;a href=&#34;https://metacpan.org/pod/Text::Original&#34;&gt;&lt;code&gt;Text::Original&lt;/code&gt;&lt;/a&gt;, which looks for the start of original, non-quoted content in an email. It knows about many kinds of attribution lines, so with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $message = &amp;lt;&amp;lt;EOF
    You wrote:
    &amp;gt; Why are there so many different mail modules?

    There&#39;s more than one way to do it! Different modules have different
    focuses, and operate at different levels; some lower, some higher.
    EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the &lt;code&gt;first_sentence($message)&lt;/code&gt; would be &lt;code&gt;There&#39;s more than one way to do it!&lt;/code&gt;. The Mariachi mailing list archiver uses this technique to give a &amp;ldquo;prompt&amp;rdquo; for each message in a thread.&lt;/p&gt;

&lt;p&gt;And speaking of threads, the &lt;a href=&#34;https://metacpan.org/pod/Mail::Thread&#34;&gt;&lt;code&gt;Mail::Thread&lt;/code&gt;&lt;/a&gt; module is a Perl implementation of Jamie Zawinski&amp;rsquo;s mail threading algorithm, as used by Mozilla as well as many other mail clients since then. It&amp;rsquo;s also used by Mariachi, and has recently been updated to use &lt;code&gt;Email::Abstract&lt;/code&gt; to handle any kind of mail object you want to throw at it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $threader = Mail::Thread-&amp;gt;new(@mails);
    $threader-&amp;gt;thread; # Compute threads
    for ($threader-&amp;gt;rootset) { # Original mails in a thread
        dump_thread($_);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-mail-filtering-mail-filtering-span&#34;&gt;&lt;span id=&#34;Mail_filtering&#34;&gt;Mail Filtering&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The classic Perl mail filtering tool is &lt;a href=&#34;https://metacpan.org/pod/Mail::Audit&#34;&gt;&lt;code&gt;Mail::Audit&lt;/code&gt;&lt;/a&gt;, and I&amp;rsquo;ve written articles here about using Mail::Audit on its own (&lt;a href=&#34;http://www.perl.com/pub/2001/07/17/mailfiltering.html&#34;&gt;http://www.perl.com/pub/2001/07/17/mailfiltering.html&lt;/a&gt;) and using it in conjunction with &lt;a href=&#34;https://metacpan.org/pod/Mail::SpamAssassin&#34;&gt;&lt;code&gt;Mail::SpamAssassin&lt;/code&gt;&lt;/a&gt; (&lt;a href=&#34;http://www.perl.com/pub/2002/03/06/spam.html&#34;&gt;http://www.perl.com/pub/2002/03/06/spam.html&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ve mentioned &lt;a href=&#34;https://metacpan.org/pod/Mail::ListDetector&#34;&gt;&lt;code&gt;Mail::ListDetector&lt;/code&gt;&lt;/a&gt; a couple of times already, and I use this with &lt;code&gt;Mail::Audit&lt;/code&gt; to do most of the filtering automatically for me. The &lt;code&gt;Mail::Audit::List&lt;/code&gt; plugin uses &lt;code&gt;ListDetector&lt;/code&gt; to look for mailing list headers in a message; these are things like &lt;code&gt;List-Id&lt;/code&gt;, &lt;code&gt;X-Mailman-Version&lt;/code&gt;, and the like, which identify a mail as having come through a mailing list. This means I can filter out all mailing list posts to their own folders, like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $list = Mail::ListDetector-&amp;gt;new($obj);
    if ($list) {
        my $name = $list-&amp;gt;listname;
        $item-&amp;gt;accept(&amp;quot;mail/$name.-$date&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, &lt;code&gt;Mail::Audit&lt;/code&gt; itself is getting a little long in the tooth, and so new installations are encouraged to use the Email Project&amp;rsquo;s &lt;a href=&#34;https://metacpan.org/pod/Email::Filter&#34;&gt;&lt;code&gt;Email::Filter&lt;/code&gt;&lt;/a&gt; instead; it has the same interface for the most part, although not all of the same features, and it uses the new-fangled &lt;code&gt;Email::Simple&lt;/code&gt; mail representation for speed and cleanliness.&lt;/p&gt;

&lt;h3 id=&#34;span-id-mail-mining-mail-mining-span&#34;&gt;&lt;span id=&#34;Mail_mining&#34;&gt;Mail Mining&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Finally, the most high-level thing I do with email is develop frameworks to automatically categorize, organize, and index mail into a database, and attempt to analyze it for interesting nuggets of information.&lt;/p&gt;

&lt;p&gt;My first module to do this with was &lt;a href=&#34;https://metacpan.org/pod/Mail::Miner&#34;&gt;&lt;code&gt;Mail::Miner&lt;/code&gt;&lt;/a&gt;, which consists of three major parts. The first part takes an email, removes any attachments, and stores the lot in a database. The second looks over the email and runs a set of &amp;ldquo;Recogniser&amp;rdquo; modules on it; these find addresses, phone numbers, keywords and phrases, and so on, and store them in a separate database table. The third part is a command-line tool to query the database for mail and information.&lt;/p&gt;

&lt;p&gt;For instance, if I need to find Tim O&amp;rsquo;Reilly&amp;rsquo;s postal address, I ask the query tool, &lt;code&gt;mm&lt;/code&gt;, to find addresses in emails from him:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; % mm --from &amp;quot;Tim O&amp;quot; --address              
 Address found in message 1835 from &amp;quot;Tim O&#39;Reilly&amp;quot; &amp;lt;tim@oreilly.com&amp;gt;:
 Tim O&#39;Reilly @ O&#39;Reilly &amp;amp; Associates, Inc.
 1005 Gravenstein Highway North, Sebastopol, CA 95472
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To retrieve the whole email, I&amp;rsquo;d say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; % mm --id 1835
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And if it originally contained an attachment, we&amp;rsquo;d see something like this as part of the email:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; [ text/xml attachment something.xml detached - use
   mm --detach 208
   to recover ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I paste that middle line &lt;code&gt;mm --detach 208&lt;/code&gt; into a shell, and hey presto, &lt;em&gt;something.xml&lt;/em&gt; is written to disk.&lt;/p&gt;

&lt;p&gt;Now &lt;code&gt;Mail::Miner&lt;/code&gt; is all very well, but having the three ideas in one tight package&amp;ndash;filing mail, mining mail, and interfacing to the database&amp;ndash;makes it difficult to develop and extend any one of them. And of course, it uses the old-school &lt;code&gt;Mail::&lt;/code&gt; modules.&lt;/p&gt;

&lt;p&gt;This brings us to our final module on the mail modules tour, and the most recently released: &lt;a href=&#34;https://metacpan.org/pod/Email::Store&#34;&gt;&lt;code&gt;Email::Store&lt;/code&gt;&lt;/a&gt;. This is a framework, based on &lt;a href=&#34;https://metacpan.org/pod/Class::DBI&#34;&gt;&lt;code&gt;Class::DBI&lt;/code&gt;&lt;/a&gt;, for storing email in a database and indexing it in various ways:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   use Email::Store &#39;dbi:SQLite:mail.db&#39;;
   Email::Store-&amp;gt;setup;
   Email::Store::Mail-&amp;gt;store($rfc2822);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then later&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   my ($name) = Email::Store::Name-&amp;gt;search( name =&amp;gt; &amp;quot;Simon Cozens&amp;quot; )
   @mails_from_simon = $name-&amp;gt;addressings( role =&amp;gt; &amp;quot;From&amp;quot; )-&amp;gt;mails;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It can be used to build a mailing list archive tool such as Mariachi, or a data mining setup like &lt;code&gt;Mail::Miner&lt;/code&gt;. It&amp;rsquo;s still very much in development, and makes use of a new idea in module extensibility.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll be bringing more information when we&amp;rsquo;ve written the first mail archiving and searching tool using &lt;code&gt;Email::Store&lt;/code&gt;, which I&amp;rsquo;m going to be doing as a new interface to the Perl mailing lists at &lt;code&gt;perl.org&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-conclusion-conclusion-span&#34;&gt;&lt;span id=&#34;Conclusion&#34;&gt;Conclusion&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ve looked at the major modules for mail handling on CPAN, and there are many more. I am obviously biased towards those which I wrote, and particularly the Perl Email Project modules in the &lt;code&gt;Email::*&lt;/code&gt; namespace. These modules are specifically designed to be simple, efficient, and correct, but may not always be a good substitute for the more thorough &lt;code&gt;Mail::*&lt;/code&gt; modules, particularly &lt;code&gt;Mail::Box&lt;/code&gt;. However, I hope you&amp;rsquo;re now a little more aware of the diversity of mail handling tools out there, and know where to look next time you need to manipulate email with Perl.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Return of Quiz of the Week</title>
      <link>http://localhost:1313/pub/2004/05/28/testing.html/</link>
      <pubDate>Fri, 28 May 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/05/28/testing.html/</guid>
      <description>

&lt;p&gt;Recently, Perl trainer and former &lt;em&gt;perl.com&lt;/em&gt; editor Mark-Jason Dominus revived his &lt;a href=&#34;http://perl.plover.com/qotw/&#34;&gt;Quiz of the Week&lt;/a&gt; mailing list; every week, subscribers are sent a Perl task of either &amp;ldquo;regular&amp;rdquo; or &amp;ldquo;expert&amp;rdquo; level. There are no prizes, but the submitted solutions are collated, discussed, and analyzed. In a way, the prize is the knowledge you gain from looking at various different techniques and approaches to the same problem. Each week, we&amp;rsquo;re going to bring you the analysis from the previous week and the question for you to think about the current week; if you want to join in and submit some solutions, see the Quiz of the Week page above.&lt;/p&gt;

&lt;h3 id=&#34;this-week-s-quiz&#34;&gt;This Week&amp;rsquo;s Quiz&lt;/h3&gt;

&lt;p&gt;The regular quiz this week was submitted by Marco Baringer:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;When I was in elementary school I wasted many an hour playing Hangman with my friends.&lt;/p&gt;

&lt;p&gt;The goal of the game is to guess a word with a certain (limited) number of wrong guesses. If we fail the &amp;ldquo;man&amp;rdquo; gets &amp;ldquo;hanged&amp;rdquo;; if we succeed he is set free. (We&amp;rsquo;re not going to discuss the lesson&amp;rsquo;s of life or the justice this game teaches to the 8 year olds who play it regularly).&lt;/p&gt;

&lt;p&gt;The game starts out with one person (not the player) choosing a &amp;ldquo;mystery&amp;rdquo; word at random and telling the player how many letters the mystery word contains. The player then guesses letters, one at a time, and the mystery word&amp;rsquo;s letters are filled in until a) the entire word is filled in, or b) the maximum number of wrong guesses are reached and the the player loses (man is hanged).&lt;/p&gt;

&lt;p&gt;Write a Perl program that lets the user play Hangman. The program should take the following arguments:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The dictionary file to use&lt;/li&gt;
&lt;li&gt;The maximum number of wrong guesses to give the player&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The program must then chose a mystery word from the dictionary file and print out as many underscores (&amp;rdquo;_&amp;rdquo;) as there are letters in the mystery word. The program will then read letters from the user one at a time. After each guess the program must print the word with properly guessed letters filled in. If the word has been guessed (all the letters making up the word have been guessed) then the program must print &amp;ldquo;LIFE!&amp;rdquo; and exit. If the word is not guessed before the maximum number of guesses is reached then the program must print &amp;ldquo;DEATH!&amp;rdquo; and exit.&lt;/p&gt;

&lt;p&gt;Some additional requirements:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The dictionary file will contain one word per line and use only 7-bit ASCII characters. It may contain randomly generated words. The dictionary will contain only words longer than 1 character. The size of the dictionary may be very large.&lt;/li&gt;
&lt;li&gt;The dictionary file used for the test (or the program for generating it) will be made available along with the write-up.&lt;/li&gt;
&lt;li&gt;If a letter appears more than once in the mystery word, all occurrences of that letter must be filled in. So, if the word is &amp;lsquo;bokonon&amp;rsquo; and the player guesses &amp;lsquo;o&amp;rsquo; the output must be &amp;lsquo;&lt;code&gt;_o_o_o_&lt;/code&gt;&amp;rsquo;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;The concensus on the discussion list seems to be that minor alterations and improvements to the user interface are OK, and that the expert quiz will be to write a program that efficiently implements the other side of the interface: to play the game of Hangman against the server.&lt;/p&gt;

&lt;p&gt;And now, onto the discussion of last week&amp;rsquo;s quiz&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;last-week-s-regular-quiz&#34;&gt;Last Week&amp;rsquo;s Regular Quiz&lt;/h3&gt;

&lt;p&gt;Geoffrey Rommel sent the following question:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The usual way to look for a character string in files in Unix is to use grep. For instance, let&amp;rsquo;s say you want to search for the word &amp;lsquo;summary&amp;rsquo; without regard to case in all files in a certain directory. You might say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grep -i summary *
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But if there is a very large number of files in your directory, you will get something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ksh: /usr/bin/grep: arg list too long
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, you could just issue multiple commands, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grep -i summary [A-B]*
grep -i summary [C-E]*
etc.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; but that&amp;rsquo;s so tedious.&lt;/p&gt;

&lt;p&gt;Write a Perl program that allows you to search all files in such a directory with one command.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;And Geoffrey&amp;rsquo;s solution:&lt;/p&gt;

&lt;p&gt;This quiz was suggested to me by a directory on one of my servers where all of our executable scripts are stored. This directory now has over 4,200 scripts and has gotten too big to search.&lt;/p&gt;

&lt;p&gt;The solution shown here works for my purposes, but I do not wish to depreciate the ingenious solutions found on the discussion list. I will try to evaluate and discuss them in a separate message.&lt;/p&gt;

&lt;p&gt;As MJD mentioned, Perl regex matching is clearly superior to the alternatives. Since the original purpose was to search a directory of scripts, the search is not case-sensitive; that option could be added easily enough. We search only files (-f) in the specified directory, not in lower directories. I also test for &amp;ldquo;text&amp;rdquo; files (-T) because my Telnet client gets hopelessly confused if you start displaying non-ASCII characters.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/perl
# The bin directory is too large to search all at once, so this does
# it in pieces.
($PAT, $DIR) = @ARGV[0,1];
$DIR ||= &amp;quot;&amp;quot;;
die &amp;quot;Syntax:  q16 pattern directory\n&amp;quot; unless $PAT;

open(LS, &amp;quot;ls -1 $DIR |&amp;quot;) or die &amp;quot;Could not ls: $!&amp;quot;;

@list = ();
while (&amp;lt;LS&amp;gt;) {
   chomp;
   push @list , (($DIR eq &amp;quot;&amp;quot;) ? $_ : &amp;quot;$DIR/$_&amp;quot;);
   if (@list &amp;gt;= 800) {
      greptext($PAT, @list);
      @list = ();
   }
}
greptext($PAT, @list);

close LS;
exit;

sub greptext {
 my ($pattern, @files) = @_;

 foreach $fname (@files) {
    next unless -f $fname &amp;amp;&amp;amp; -T _;
    open FI, $fname;
    while (&amp;lt;FI&amp;gt;) {
       chomp;
       print &amp;quot;$fname [$.]: $_\n&amp;quot; if m/$pattern/oi;
    }
    close FI;
 }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For what it&amp;rsquo;s worth, here is my take on the solutions offered for the week&amp;rsquo;s quiz. This quiz was a humbling reminder that we should specify our requirements exactly. Although I deliberately left some of the design open, I apparently did not make the requirements clear. Three of the submissions failed on the very task they were intended to solve&amp;ndash;namely, running through all files in a large directory of files. Instead of specifying a directory name, you had to specify a list of file names on the command line, which of course resulted in the dreaded &amp;ldquo;arg list too long&amp;rdquo; message. As someone pointed out, this is really a shell limitation, but there it is. (For the record, I am running MP-RAS, an svr4 variant, with the Korn shell.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;           1   2   3   4   5   F    CPU                                         
brent      1   1   1   1   1   1  65.01                                         
dunham     1   1   1   0   2   2   2.92                                         
fish       1   1   1   0   2   2   3.32                                         
mjd        0   0   0   0   2   2     --                                         
rommel     1   1   1   1   2   0   2.66                                         
scott      1   0   1   1   2   2     --                                         
sims       0   0   0   0   2   2     --                                         
wett       0   0   0   0   2   0     --  

1. Did it work when there was a named pipe in the directory?                    
2. Did it work as desired on the large directory?                               
3. Did it work when only a directory name was specified?                        
4. Did it work (as ls does) when no directory name was specified?               
5. Aesthetics of output (error messages, line numbers, etc.)                    
F. Flexibility of program                                                       
CPU: to search large directory; in seconds as reported by timex                 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tests 1-2 were requirements. Tests 3-4 were nice to have. Peter Scott&amp;rsquo;s program worked nicely on a small directory but produced unexpected output on the large directory: it seemed to be executing some scripts rather than searching them, so I deemed it to have failed. Brent Royal-Gordon&amp;rsquo;s script got a lower score for aesthetics because it produced a number of lines saying &amp;ldquo;UX:grep: ERROR: Cannot open &amp;ndash;&amp;ldquo;.&lt;/p&gt;

&lt;p&gt;I was particularly impressed with the flexibility of many of the scripts; my own submission, although the fastest, was also the least flexible. I am quite in agreement with James Wetterau&amp;rsquo;s defense of minimalism. A program like this would not even be necessary if the shell allowed us to pass 4,200 arguments. Since it doesn&amp;rsquo;t, however, we must do some of the work ourselves.&lt;/p&gt;

&lt;h3 id=&#34;last-week-s-expert-quiz&#34;&gt;Last Week&amp;rsquo;s Expert Quiz&lt;/h3&gt;

&lt;p&gt;This was sent by Shlomi Fish:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You will write a Perl program that schedules the semester of courses at Haifa University. &lt;code&gt;@courses&lt;/code&gt; is an array of course names, such as &amp;ldquo;Advanced Basket Weaving&amp;rdquo;. &lt;code&gt;@slots&lt;/code&gt; is an array of time slots at which times can be scheduled, such as &amp;ldquo;Monday mornings&amp;rdquo; or &amp;ldquo;Tuesdays and Thursdays from 1:00 to 2:30&amp;rdquo;. (Time slots are guaranteed not to overlap.)&lt;/p&gt;

&lt;p&gt;You are also given a schedule that says when each course meets. &lt;code&gt;$schedule[$n][$m]&lt;/code&gt; is true if course &lt;code&gt;$n&lt;/code&gt; meets during time slot &lt;code&gt;$m&lt;/code&gt;, and false if not.&lt;/p&gt;

&lt;p&gt;Your job is to write a function, &amp;lsquo;&lt;code&gt;allocate_minimal_rooms&lt;/code&gt;&amp;rsquo;, to allocate classrooms to courses. Each course must occupy the same room during every one of its time slots. Two courses cannot occupy the same room at the same time. Your function should produce a schedule that allocates as few rooms as possible.&lt;/p&gt;

&lt;p&gt;The &amp;lsquo;&lt;code&gt;allocate_minimal_rooms&lt;/code&gt;&amp;rsquo; function will get three arguments:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The number of courses&lt;/li&gt;
&lt;li&gt;The number of different time slots&lt;/li&gt;
&lt;li&gt;A reference to the &lt;code&gt;@schedule&lt;/code&gt; array&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;It should return a reference to an array, say &lt;code&gt;$room&lt;/code&gt;, which indicates the schedule. &lt;code&gt;$room-&amp;gt;[$n]&lt;/code&gt; will be the number of the room in which course &lt;code&gt;$n&lt;/code&gt; will meet during all of its time slots. If courses &lt;code&gt;$n&lt;/code&gt; and &lt;code&gt;$m&lt;/code&gt; meet at the same time, then &lt;code&gt;$room-&amp;gt;[$n]&lt;/code&gt; must be different from &lt;code&gt;$room-&amp;gt;[$m]&lt;/code&gt;, because the two courses cannot use the same room at the same time.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Well, this quiz generated several solutions from several people.&lt;/p&gt;

&lt;p&gt;MJD sent a &lt;a href=&#34;http://article.gmane.org/gmane.comp.lang.perl.qotw.discuss/1661&#34;&gt;test suite&lt;/a&gt;, and I sent a &lt;a href=&#34;http://article.gmane.org/gmane.comp.lang.perl.qotw.discuss/1662&#34;&gt;test suite of my own&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Roger Burton West sent an &lt;a href=&#34;http://perl.plover.com/~alias/list.cgi?1:mss:1599&#34;&gt;exhaustive search solution&lt;/a&gt;; Ronald J. Kimball also sent an exhaustive search one, &lt;a href=&#34;http://perl.plover.com/~alias/list.cgi?1:mmn:1600&#34;&gt;this time&lt;/a&gt; using string operations to represent the schedule array.&lt;/p&gt;

&lt;p&gt;Christian Duhl identified that the problem was NP-Complete, transformed it to a graph coloring problem, and solved it using &lt;a href=&#34;http://article.gmane.org/gmane.comp.lang.perl.qotw.discuss/1666&#34;&gt;this&lt;/a&gt;. I sent my own solution. &lt;a href=&#34;http://perl.plover.com/~alias/list.cgi?1:mmn:1603&#34;&gt;This one&lt;/a&gt; uses intermediate truth tables between courses and rooms.&lt;/p&gt;

&lt;p&gt;Finally, Mark Jason Dominus posted &lt;a href=&#34;http://perl.plover.com/~alias/list.cgi?1:mmn:1604&#34;&gt;his solution&lt;/a&gt;, which also used recursion as well as string operations.&lt;/p&gt;

&lt;p&gt;My solution is smarter than the brute-force method, but still recursive and may explode for certain schedules.&lt;/p&gt;

&lt;p&gt;It works by assigning a room to a course, and then finding a course that requires a different room. It then assigns another room to this course. The algorithm maintains a truth table of which courses can be allocated to specific rooms. Once a room was allocated to a class, all of the classes that share time-slots with this class are marked as being unable to use the room. If all the rooms that were allocated so far are unusable by a certain class, then it is allocated a new room.&lt;/p&gt;

&lt;p&gt;If the algorithm reaches a place where a room can be allocated to any of several classes, it recurses with each possibility.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>An Interview with Allison Randal</title>
      <link>http://localhost:1313/pub/2004/05/19/allison.html/</link>
      <pubDate>Fri, 21 May 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/05/19/allison.html/</guid>
      <description>&lt;p&gt;This week, Perl.com has the pleasure of interviewing Allison Randal, one of the key figures in the Perl community. Allison has been active in the Perl 6 design process since its inception, and is the President of the Perl Foundation. Let&amp;rsquo;s hear more from Allison about what all of this means to her.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;perl.com&lt;/strong&gt;: &lt;em&gt;To begin with, please tell us a little about yourself.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Allison Randal&lt;/strong&gt;: I&amp;rsquo;m a Perl programmer from Portland, Oregon. I&amp;rsquo;m the president of the Perl Foundation, project manager for Perl 6 (as well as a code and design contributor), and run a small consulting company. I lead a rather hermit-like life. In the rare moments when I&amp;rsquo;m not working on some project or another, you&amp;rsquo;re far more likely to find me reading or puttering in the garden than anything else.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pc&lt;/strong&gt;: &lt;em&gt;For those who don&amp;rsquo;t know, what is the Perl Foundation and what does it do?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AR&lt;/strong&gt;: The Perl Foundation is a supporting structure for Perl development and the legal entity behind Perl. It is the copyright holder for Perl 6 and Parrot, and carries the legal responsibility for Larry Wall&amp;rsquo;s copyright in Perl 5.&lt;/p&gt;

&lt;p&gt;TPF is the central organization for perl.org, Perl Mongers, and Perl Monks. Through perl.org we support the mailing lists, bug tracking, source control, and web sites critical to Perl development. Perl.org has had several significant upgrades over the past year thanks to generous donations of hardware.&lt;/p&gt;

&lt;p&gt;Through Perl Mongers and Perl Monks, we support grassroots involvement in Perl. Perl has always been community-centered, and the face-to-face and online interaction of these two groups play a big part in keeping the community strong and active. TPF also gives the yearly White Camel awards, recognizing significant contributions from individuals in the Perl community.&lt;/p&gt;

&lt;p&gt;TPF directly funds Perl development through our quarterly grants. These grants range in size from $500 or less, for a particular project, up to full funding for a year of Perl development work.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pc&lt;/strong&gt;: &lt;em&gt;And what do you do, as President of TPF, from day to day?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AR&lt;/strong&gt;: I spend 10 to 20 hours a week making sure the plates keep spinning. Sometimes this is as simple as sending out reminder messages. More often, it means pitching in on whatever odd task needs to be done. I&amp;rsquo;ve been known to: write press releases, work on the web site, set up and man TPF booths at conferences, edit grant proposals, organize votes, coordinate with donors, talk to lawyers, talk to artists, and work with companies on licensing arrangements, among other things.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pc&lt;/strong&gt;: &lt;em&gt;That sounds like a lot! Aren&amp;rsquo;t there people who can help out?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AR&lt;/strong&gt;: More and more, the responsibilities that have traditionally belonged to the president are moving to other shoulders. As TPF continues to grow, we need a coordinated team to handle the load. In addition to the familiar faces, we&amp;rsquo;ve added several great new volunteers this year: Larry Hixon on donor relations, Gavin Estey on public relations, and Baden Hughes as secretary of the grants committee. The complete list is up on the &amp;ldquo;&lt;a href=&#34;http://www.perlfoundation.org/who.html&#34;&gt;Who&amp;rsquo;s Who&lt;/a&gt;&amp;rdquo; page at perlfoundation.org.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pc&lt;/strong&gt;: &lt;em&gt;You are on other committees of the Perl Foundation, such as the steering committee; what&amp;rsquo;s the day-to-day role of that?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AR&lt;/strong&gt;: The steering committee is responsible for the daily operations of the foundation. Except for some legal and financial decisions, the steering committee has the same powers as the board of directors.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pc&lt;/strong&gt;: &lt;em&gt;There&amp;rsquo;s also a YAPC committee. What&amp;rsquo;s TPF&amp;rsquo;s role in the many YAPCs that seem to be springing up around the world?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AR&lt;/strong&gt;: TPF directly runs the North American YAPC. The rest of the worldwide YAPCs are largely independent. We offer assistance and seed funding where we can, but so far, the conferences have all donated back more funds than we&amp;rsquo;ve given.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pc&lt;/strong&gt;: &lt;em&gt;We used to talk about &amp;ldquo;Yet Another Society,&amp;rdquo; but now much of the community impetus comes from &amp;ldquo;The Perl Foundation.&amp;rdquo; What&amp;rsquo;s the relationship between these two groups?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AR&lt;/strong&gt;: &amp;ldquo;The Perl Foundation&amp;rdquo; and &amp;ldquo;Yet Another Society&amp;rdquo; are really just two names for the same organization. These days we mainly use the name &amp;ldquo;The Perl Foundation,&amp;rdquo; because it does a better job of explaining what we do.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pc&lt;/strong&gt;: &lt;em&gt;Tell us a bit more about the grants process &amp;ndash; who can apply, how grantees are chosen, what sort of projects TPF is looking to support, and so on.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AR&lt;/strong&gt;: Anyone can submit a proposal. The details are up on the &amp;ldquo;How to Write a Proposal&amp;rdquo; page at perlfoundation.org. Proposals are reviewed by the grants committee every quarter. We tend to focus on core Perl development, but other Perl projects are also welcome.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pc&lt;/strong&gt;: &lt;em&gt;Where do TPF&amp;rsquo;s resources come from?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AR&lt;/strong&gt;: TPF has a small number of big corporate sponsors, a larger number of medium-sized corporations, and an even larger number of individual sponsors, so the resources we get from each group is about equal. It&amp;rsquo;s easy for individuals to think &amp;ldquo;I&amp;rsquo;m just one person, I can&amp;rsquo;t make any difference,&amp;rdquo; but if every Perl user around the world donated $25, we could fund Larry full-time for several years. Really, even the corporate donations ultimately start with individuals, because someone took the time to think &amp;ldquo;Hey, our company has gained so much from Perl, let&amp;rsquo;s give something back.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pc&lt;/strong&gt;: &lt;em&gt;Turning to Perl 6, what&amp;rsquo;s TPF&amp;rsquo;s role in supporting the Perl 6 project?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AR&lt;/strong&gt;: We try to keep a good balance between Perl 5 and Perl 6 projects. The most significant way we support Perl 6 is by funding Larry Wall to work on Perl 6 design. We were able to fund him for a full year in 2002, half of the year in 2003, and hope to fund him for a full year again in 2004. We also funded Damian Conway in 2001 and 2002, and Dan Sugalski for half of the year in 2002.&lt;/p&gt;

&lt;p&gt;The Ponie project (Perl 5 on Parrot) is part of the larger Perl 6 project. It runs on developer time donated to the Perl Foundation by Fotango.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pc&lt;/strong&gt;: &lt;em&gt;What does it mean to be the Perl 6 project manager?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AR&lt;/strong&gt;: Project management is all about making sure people have what they need to keep moving forward. It&amp;rsquo;s not about giving orders, it&amp;rsquo;s about listening for where people need help. It&amp;rsquo;s about encouraging people to do the best job they can with the available resources, without stressing about what they can&amp;rsquo;t do.&lt;/p&gt;

&lt;p&gt;We have a great team: intelligent, motivated, and profoundly funny. You might expect ego wars in a team this brilliant, but they simply don&amp;rsquo;t exist. It&amp;rsquo;s a joy to work with this group.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pc&lt;/strong&gt;: *What goes on inside the Perl 6 design process &amp;ndash; between the discussions on &lt;em&gt;perl6-language&lt;/em&gt; and an Apocalypse or Exegesis being produced?*&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AR&lt;/strong&gt;: The design process is a constant stream of ideas bouncing around, some accepted, some rejected, some reshaped. It reminds me of grad school. You don&amp;rsquo;t just forget the ideas once you leave the classroom &amp;ndash; you eat, drink, and breathe ideas every moment. Aside from messages on and off the lists, the design team meets in a conference call every week, and face-to-face whenever we can. The next design meetings will be in late July.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pc&lt;/strong&gt;: &lt;em&gt;How is the Perl 6 process running, from your point of view?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AR&lt;/strong&gt;: It&amp;rsquo;s quite healthy. The key to completing a marathon is simple: just keep moving. It&amp;rsquo;s the same in software, especially in a project this size. Move too fast and you burn out your key players; move too slow and you lose momentum. We&amp;rsquo;ve set a nice maintainable pace and just keep rolling.&lt;/p&gt;

&lt;p&gt;Luke Palmer is working on a first draft of Synopsis 12 now. Damian will start work on Exegesis 12 during his summer tour to the U.S. Larry is taking a bit of a breather and pondering which Apocalypse to work on next. His next step may be to work on Synopses as previews for the remaining Apocalypses to speed implementation work. Parrot has just recently taken a huge leap forward in objects and Unicode support. Dan currently has his eye on Events.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pc&lt;/strong&gt;: &lt;em&gt;Finally, when do you think that a complete Perl 6 beta will be available?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AR&lt;/strong&gt;: That&amp;rsquo;s a tough question to answer, because there are so many factors that could delay or speed up the process. With the state of Parrot and the design work completed so far, though, I&amp;rsquo;d say there&amp;rsquo;s a good chance we&amp;rsquo;ll see one within the next two years.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Affrus: An OS X Perl IDE</title>
      <link>http://localhost:1313/pub/2004/05/14/affrus.html/</link>
      <pubDate>Fri, 14 May 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/05/14/affrus.html/</guid>
      <description>&lt;p&gt;When I &lt;a href=&#34;http://localhost:1313/pub/2002/10/09/komodo.html&#34;&gt;last reviewed&lt;/a&gt; a Perl IDE, ActiveState&amp;rsquo;s Komodo, I was nearly convinced; the only problem was that I use Mac OS X. Now, &lt;a href=&#34;http://www.latenightsw.com/&#34;&gt;Late Night Software&lt;/a&gt;, more commonly known for their AppleScript tools, have taken their Mac programming experience and applied it to create &lt;a href=&#34;http://www.latenightsw.com/affrus/index.html&#34;&gt;Affrus&lt;/a&gt;, a Perl IDE for the Mac. And I&amp;rsquo;m a little closer to being convinced.&lt;/p&gt;

&lt;p&gt;Affrus differs from Komodo in some substantial ways. Where Komodo couples its editor tightly with a Perl interpreter to allow background syntax checking and on-the-fly warnings highlighting, Affrus takes a more traditional, detached approach: syntax checks are performed on demand, with errors and warnings placed in a separate panel. Fans of &lt;code&gt;emacs&lt;/code&gt;&amp;rsquo;s debugging modes will be happier to see this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2004_05_14_affrus/affrus-stricterror.jpg&#34; width=&#34;500&#34; height=&#34;280&#34; /&gt;
It took me quite awhile to discover the control-click contextual menu &amp;ndash; since the downside of &amp;ldquo;intuitive&amp;rdquo; applications is that we don&amp;rsquo;t get a nice manual to read any more &amp;ndash; but when I did I was amazingly impressed. Right-clicking on a package name does just what you want; it allows you to edit that package&amp;rsquo;s file, or to view its documentation with perldoc. Similarly, right-clicking on a built-in offers to bring up perldoc for that function.&lt;/p&gt;

&lt;p&gt;Right-clicking on the name of a subroutine lets you navigate to the definition of that routine &amp;ndash; even doing a remarkably good job at working out what class a method will come from. And right-clicking on a variable name takes you to where that variable was declared. Right-clicking on the navigation bar at the bottom of the window brings up a &amp;ldquo;table of contents&amp;rdquo; for the program, allowing you to navigate to any of the modules it uses and any of the subroutines it defines. If you right-click on empty space, however, you get a listing of variables and subroutine names that can be inserted at that location. Full marks for this, and the more time I spend with the Affrus editor, the more neat things like this I find.&lt;/p&gt;

&lt;p&gt;On the whole, though, the Affrus editor is relatively basic. While its syntax highlighting is more sophisticated than most, distinguishing between package, lexical, and special variables, for instance, it does not handle code folding, nor does it have &amp;ldquo;smart&amp;rdquo; auto-indenting. It&amp;rsquo;s quite comparable to the original &lt;code&gt;emacs&lt;/code&gt; &lt;code&gt;perl-mode&lt;/code&gt;. However, this isn&amp;rsquo;t necessarily a problem, due to Affrus&amp;rsquo; integration with other editors such as BBEdit and TextWrangler; additionally, Late Night&amp;rsquo;s AppleScript experience has enabled them to design Affrus to be extensible and scriptable. Script plugins provided with Affrus allow it to reformat code with &lt;code&gt;perltidy&lt;/code&gt;, as well as to insert control structures and other snippets into the current file.&lt;/p&gt;

&lt;p&gt;As well as its scriptability, the real boon in Affrus is in its debugging console; on top of the usual debugging actions of stepping over a script, jumping in and out of subroutines, setting breakpoints, and so on, it presents at every step a detailed listing of all the variables in play, allowing you to look inside complex data structures with OS X&amp;rsquo;s familiar disclosure triangles:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2004_05_14_affrus/affrus-debug.jpg&#34; width=&#34;500&#34; height=&#34;337&#34; /&gt;
As one would expect, it automatically loads up modules and other external Perl code while debugging, allowing you to step over their code, too. You can also change the value of variables during debugging, as well as enter arbitrary Perl expressions in the &amp;ldquo;Expressions&amp;rdquo; pane.&lt;/p&gt;

&lt;p&gt;Affrus offers a few other interesting little features, such as the debugger&amp;rsquo;s ability to detect and highlight circular references, and the bundled command line tool. This utility enables you to debug a Perl program in Affrus while having complete control over the environment and standard IO redirections &amp;ndash; a major bridge between GUI-based debugging and the &amp;ldquo;real world&amp;rdquo; of complex Perl program deployments.&lt;/p&gt;

&lt;p&gt;There are a few things Affrus doesn&amp;rsquo;t do which I&amp;rsquo;d like, but to be honest they&amp;rsquo;re a part of the way I use Perl &amp;ndash; an IDE with integrated debugger and Perl-aware editor is a great environment for creating standalone Perl scripts where you&amp;rsquo;re running through a process, breaking at significant moments, inspecting the control flow and the state of the variables. However, when you work primarily at the level of Perl modules and Apache handlers, there is no real top-level &amp;ldquo;process&amp;rdquo; to step through, and a traditional debugging environment becomes much less useful.&lt;/p&gt;

&lt;p&gt;That said, in such a debugging environment, I&amp;rsquo;d love to see Affrus have a Perl debugger pane at which one could execute Perl code during a debugger run; inspecting the variables is great, but there ought to be a way to change them, too! There are other changes I&amp;rsquo;d like to see in the future, ranging from something as trivial as a color scheme palette &amp;ndash; the first thing I did on running Affrus was to spend 10 minutes configuring it with a set of colors that look nice on a black background instead of a white one! &amp;ndash; to full-blown integration with either CVS or even Apple&amp;rsquo;s Xcode IDE.&lt;/p&gt;

&lt;p&gt;On the whole, however, I&amp;rsquo;m very impressed by Affrus, and I&amp;rsquo;m convinced that, even if it&amp;rsquo;s not to your taste yet, it is certain to grow into a mature and powerful Perl IDE for OS X.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rapid Web Application Deployment with Maypole : Part 2</title>
      <link>http://localhost:1313/pub/2004/04/29/maypole.html/</link>
      <pubDate>Thu, 29 Apr 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/04/29/maypole.html/</guid>
      <description>

&lt;p&gt;When we &lt;a href=&#34;http://localhost:1313/pub/2004/04/15/maypole.html&#34;&gt;last&lt;/a&gt; left our intrepid web developer, he had successfully set up an online sales catalogue in 11 lines of code. Now, however, he has to move on to turning this into a sales site with a shopping cart and all the usual trimmings. It&amp;rsquo;s time to see some of that flexibility we talked about last week; unfortunately this means we&amp;rsquo;re going to have to write some more code, but we can&amp;rsquo;t have everything.&lt;/p&gt;

&lt;h3 id=&#34;span-id-who-am-i-who-am-i-span&#34;&gt;&lt;span id=&#34;Who_Am_I?&#34;&gt;Who Am I?&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In order to add the shopping cart to the site, we need to introduce the concept of a current user. This will allow viewers of the site to log in and have their own cart. We will be adding two new tables to the database, a table to store details about the user, and one to represent the cart. Our tables will look like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  CREATE TABLE user (
    id int not null auto_increment primary key,
    first_name varchar(64),
    last_name varchar(64),
    email varchar(255),
    password varchar(64),
    address1 varchar(255),
    address2 varchar(255),
    state varchar(255),
    postal_code varchar(64),
    country varchar(64)
  );

  CREATE TABLE cart_item (
    id int not null auto_increment primary key,
    user int,
    item int
  );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As before, Maypole automatically creates classes for the tables. We use &lt;code&gt;Class::DBI&lt;/code&gt; relationships to tell Maypole what&amp;rsquo;s going on with these tables:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ISellIt::User-&amp;gt;has_many( &amp;quot;cart_items&amp;quot; =&amp;gt; &amp;quot;ISellIt::BasketItem&amp;quot;);
  ISellIt::BasketItem-&amp;gt;has_a( &amp;quot;user&amp;quot; =&amp;gt; &amp;quot;ISellit::User&amp;quot; );
  ISellIt::BasketItem-&amp;gt;has_a( &amp;quot;item&amp;quot; =&amp;gt; &amp;quot;ISellit::Product&amp;quot; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now need a way to tell our application about the current user. There&amp;rsquo;s a long explanation of Maypole&amp;rsquo;s authentication system in the &lt;a href=&#34;http://maypole.simon-cozens.org/doc/authentication.html&#34;&gt;Maypole documentation&lt;/a&gt;, but one of the easiest ways to do add the concept of the current user is with the &lt;code&gt;Maypole::Authentication::UserSessionCookie&lt;/code&gt; module.&lt;/p&gt;

&lt;p&gt;As its name implies, this module takes care of associating a user with a session, and issuing a cookie to the user&amp;rsquo;s browser. It also manages validating the user&amp;rsquo;s login credentials, by default by looking up the user name and password in a database table; precisely what we need!&lt;/p&gt;

&lt;p&gt;Maypole provides an authentication method for us to override, and it&amp;rsquo;s here that we&amp;rsquo;re going to intercept any request that requires a user &amp;ndash; viewing the shopping cart, adding items to an order, and so on:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  sub authenticate {
    my ($self, $r) = @_;
    unless ($r-&amp;gt;{table} eq &amp;quot;cart&amp;quot; or $r-&amp;gt;{action} eq &amp;quot;buy&amp;quot;) {
      return OK;
    }

    # Else we need a user
    $r-&amp;gt;get_user;
    if (!$r-&amp;gt;{user}) {
      $r-&amp;gt;template(&amp;quot;login&amp;quot;);
    }
    return OK;
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;get_user&lt;/code&gt; method, which does all the work of setting the cookie and setting the credentials, is provided by the &lt;code&gt;UserSessionCookie&lt;/code&gt; module. The only thing we need to tell it is that we&amp;rsquo;re going to use the user&amp;rsquo;s email address and password as login credentials, rather than some arbitrary user name. We can do this in the configuration for our application, as described in the &lt;code&gt;UserSessionCookie&lt;/code&gt; documentation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ISellIt-&amp;gt;{config}-&amp;gt;{auth}-&amp;gt;{user_field} = &amp;quot;email&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we set up a login template, which will present the users with a form to enter their credentials; there&amp;rsquo;s one in the Maypole manual, in the &lt;a href=&#34;http://maypole.simon-cozens.org/doc/Request.html&#34;&gt;Request chapter&lt;/a&gt;, which we can modify to suit our needs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  [% INCLUDE header %]

    &amp;lt;h2&amp;gt; You need to log in before buying anything &amp;lt;/h2&amp;gt;

  &amp;lt;DIV class=&amp;quot;login&amp;quot;&amp;gt;
  [% IF login_error %]
     &amp;lt;FONT COLOR=&amp;quot;#FF0000&amp;quot;&amp;gt; [% login_error %] &amp;lt;/FONT&amp;gt;
  [% END %]
    &amp;lt;FORM ACTION=&amp;quot;/[% request.path%]&amp;quot; METHOD=&amp;quot;post&amp;quot;&amp;gt;
  Email Address:
    &amp;lt;INPUT TYPE=&amp;quot;text&amp;quot; NAME=&amp;quot;email&amp;quot;&amp;gt; &amp;lt;BR&amp;gt;
  Password: &amp;lt;INPUT TYPE=&amp;quot;password&amp;quot; NAME=&amp;quot;password&amp;quot;&amp;gt; &amp;lt;BR&amp;gt;
  &amp;lt;INPUT TYPE=&amp;quot;submit&amp;quot;&amp;gt;
  &amp;lt;/FORM&amp;gt;
  &amp;lt;/DIV&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now logging in is sorted out; if a user presents the correct credentials, &lt;code&gt;get_user&lt;/code&gt; will put the user&amp;rsquo;s &lt;code&gt;ISellIt::User&lt;/code&gt; object in the Maypole request object as &lt;code&gt;$r-&amp;gt;{user}&lt;/code&gt;, and the user&amp;rsquo;s request will continue to where it was going.&lt;/p&gt;

&lt;p&gt;Now, of course, since we have a user object we can play with, we can use the user&amp;rsquo;s information in other contexts:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  [% IF request.user %]
    &amp;lt;DIV class=&amp;quot;messages&amp;quot;&amp;gt;
    Welcome back, [% request.user.first_name %]!
    &amp;lt;/DIV&amp;gt;
  [% END %]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since we&amp;rsquo;re going to be referring to the user a lot, we pass it to the template as an additional argument, &lt;code&gt;my&lt;/code&gt;. Maypole has an open-ended &amp;ldquo;hook&amp;rdquo; method, &lt;code&gt;additional_data&lt;/code&gt;, which is perfect for doing just this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  sub additional_data {
    my $r = shift;
    $r-&amp;gt;{template_args}{my} = $r-&amp;gt;{user};
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We call it &lt;code&gt;my&lt;/code&gt; so that we can say, for instance:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;DIV class=&amp;quot;messages&amp;quot;&amp;gt;
    Welcome back, [% my.first_name %]!
    &amp;lt;/DIV&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So now we have a user. We can add a new action, &lt;code&gt;order&lt;/code&gt;, to add an item to the user&amp;rsquo;s shopping cart:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  package ISellIt::Product;

  sub order :Exported {
    my ($self, $r, $product) = @_;
    $r-&amp;gt;{user}-&amp;gt;add_to_cart_items({ item =&amp;gt; $product });
    $r-&amp;gt;{template} = &amp;quot;view&amp;quot;;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This adds an entry in the &lt;code&gt;cart_item&lt;/code&gt; table associating the item with the user, and then sends us back to viewing the item.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ve sent our user back shopping without an indication that we actually did add an item to his shopping cart; we can give such an indication by passing information into the template:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  sub order :Exported {
    my ($self, $r, $product) = @_;
    $r-&amp;gt;{user}-&amp;gt;add_to_cart_items({ item =&amp;gt; $product });
    $r-&amp;gt;{template} = &amp;quot;view&amp;quot;;
    $r-&amp;gt;{template_args}{bought} = 1;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then displaying it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  [% IF bought %]
  &amp;lt;DIV class=&amp;quot;messages&amp;quot;&amp;gt;
    We&#39;ve just added this item to your shopping cart. To complete
    your transaction, please &amp;lt;A HREF=&amp;quot;/user/view_cart&amp;quot;&amp;gt;view your
    cart&amp;lt;/A&amp;gt; and check out.
  &amp;lt;/DIV&amp;gt;
  [% END %]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So now we need to allow the user to view a cart.&lt;/p&gt;

&lt;h3 id=&#34;span-id-displaying-the-cart-displaying-the-cart-span&#34;&gt;&lt;span id=&#34;Displaying_the_Cart&#34;&gt;Displaying the Cart&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;This also turns out to be relatively easy &amp;ndash; most things in Maypole are &amp;ndash; involving an action on the user class. We need to fill our Maypole request object with the items in the user&amp;rsquo;s cart:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  package ISellIt::User;

  sub view_cart :Exported {
    my ($self, $r) = @_;
    $r-&amp;gt;{objects} = [ $r-&amp;gt;{user}-&amp;gt;cart_items ];
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then we need to produce a &lt;em&gt;user/view_cart&lt;/em&gt; template that displays them:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  [% PROCESS header %]

  &amp;lt;h2&amp;gt; Your Shopping Cart &amp;lt;/h2&amp;gt;

  &amp;lt;TABLE&amp;gt;
  &amp;lt;TR&amp;gt; &amp;lt;TH&amp;gt; Product &amp;lt;/TH&amp;gt; &amp;lt;TH&amp;gt; Price &amp;lt;/TH&amp;gt; &amp;lt;/TR&amp;gt;
  [% SET count = 0;
  FOR item = objects;
    SET count = count + 1;
    &amp;quot;&amp;lt;tr&amp;quot;;
    &#39; class=&amp;quot;alternate&amp;quot;&#39; IF count % 2;
    &amp;quot;&amp;gt;&amp;quot;;
  %]
    &amp;lt;TD&amp;gt; [% item.product.name %] &amp;lt;/TD&amp;gt;
    &amp;lt;TD&amp;gt; [% item.product.price %] &amp;lt;/TD&amp;gt;
    &amp;lt;TD&amp;gt;
      &amp;lt;FORM ACTION=&amp;quot;/cart_item/delete/[% item.id %]&amp;quot;&amp;gt;
      &amp;lt;INPUT TYPE=&amp;quot;submit&amp;quot; VALUE=&amp;quot;Remove from cart&amp;quot;&amp;gt;
      &amp;lt;/FORM&amp;gt;
    &amp;lt;/TD&amp;gt;
  &amp;lt;/tr&amp;gt;
  [% END %]
  &amp;lt;/TABLE&amp;gt;

  &amp;lt;A HREF=&amp;quot;/user/checkout&amp;quot;&amp;gt; Check out! &amp;lt;/A&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once again, the HTML isn&amp;rsquo;t great, but it gives us something we can pass to the design people to style up nicely. Now on to checking out the cart&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;span-id-check-out-check-out-span&#34;&gt;&lt;span id=&#34;Check_out&#34;&gt;Check Out&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The hardest part about building an e-commerce application is interacting with the payment and credit-card fulfillment service. We&amp;rsquo;ll use the &lt;a href=&#34;https://metacpan.org/pod/Business::OnlinePayment&#34;&gt;Business::OnlinePayment&lt;/a&gt; module to handle that side of things, and handle the order fulfillment by simply sending an email.&lt;/p&gt;

&lt;p&gt;The actual check-out page needs to collect credit card and delivery information, and so it doesn&amp;rsquo;t actually need any objects; the only object we actually need is the &lt;code&gt;ISellIt::User&lt;/code&gt;, and that was stashed away in the request object by the authentication routine. However, we do want to display the total cost. So to make things easier we&amp;rsquo;ll add an action and compute this in Perl. We make the total cost a method on the user, so we can use this later:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  package ISellIt::User;
  use List::Util qw(sum);
  sub basket_cost {
    my $self = shift;
    sum map { $_-&amp;gt;item-&amp;gt;price }
    $self-&amp;gt;basket_items
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And define &lt;code&gt;checkout&lt;/code&gt; to add this total to our template:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  sub checkout :Exported {
    my ($self, $r) = @_;
    $r-&amp;gt;{template_args}{total_cost} = $r-&amp;gt;{user}-&amp;gt;basket_cost;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we write our &lt;em&gt;user/checkout&lt;/em&gt; template:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  [% PROCESS header %]
  &amp;lt;h2&amp;gt; Check out &amp;lt;/h2&amp;gt;

  &amp;lt;p&amp;gt; Please enter your credit card and delivery details. &amp;lt;/p&amp;gt;

  &amp;lt;form method=&amp;quot;post&amp;quot; action=&amp;quot;https://www.isellit.com/user/do_checkout&amp;quot;&amp;gt;
    &amp;lt;P&amp;gt;
    First name: &amp;lt;input name=&amp;quot;first_name&amp;quot; value=&amp;quot;[% my.first_name %]&amp;quot;&amp;gt;&amp;lt;BR&amp;gt;
    Last name: &amp;lt;input name=&amp;quot;last_name&amp;quot; value=&amp;quot;[% my.last_name %]&amp;quot;&amp;gt;&amp;lt;/P&amp;gt;
    &amp;lt;P&amp;gt;
    Street address: &amp;lt;input name=&amp;quot;address&amp;quot; value=&amp;quot;[% my.address1 %]&amp;quot;&amp;gt;&amp;lt;BR&amp;gt;
    City: &amp;lt;input name=&amp;quot;city&amp;quot; value=&amp;quot;[% my.address2 %]&amp;quot;&amp;gt;&amp;lt;BR&amp;gt;
    State: &amp;lt;input name=&amp;quot;state&amp;quot; value=&amp;quot;[% my.state %]&amp;quot;&amp;gt;
    Zip: &amp;lt;input name=&amp;quot;zip&amp;quot; value=&amp;quot;[% my.postal_code %]&amp;quot;&amp;gt;
    &amp;lt;/P&amp;gt;

    &amp;lt;P&amp;gt;
    Card type: &amp;lt;select name=&amp;quot;type&amp;quot;&amp;gt;
      &amp;lt;option&amp;gt;Visa&amp;lt;/option&amp;gt;
      &amp;lt;option&amp;gt;Mastercard&amp;lt;/option&amp;gt;
      ...
    &amp;lt;/select&amp;gt;

    Card number: &amp;lt;input name=&amp;quot;card_number&amp;quot;&amp;gt;
    Expiration: &amp;lt;input name=&amp;quot;expiration&amp;quot;&amp;gt; &amp;lt;BR&amp;gt;
    Total: $ [% total_price %]
    &amp;lt;/P&amp;gt;
    &amp;lt;P&amp;gt;
    Please click &amp;lt;B&amp;gt;once&amp;lt;/B&amp;gt; and wait for the payment to be
    authorised.... &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;order&amp;quot;&amp;gt;
  &amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What happens when this data is sent to the &lt;code&gt;do_checkout&lt;/code&gt; action? (Over SSL, you&amp;rsquo;ll notice.) First of all, we&amp;rsquo;ll check if the user has entered address details for the first time, and if so, store them in the database. Perhaps unnecessary in this day of browsers that auto-fill forms, but it&amp;rsquo;s still a convenience. Maypole stores the POST&amp;rsquo;ed in parameters in &lt;code&gt;params&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  sub do_checkout :Exported {
    my ($self, $r) = @_;
    my %params = %{$r-&amp;gt;{params}};
    my $user = $r-&amp;gt;{user};

    $user-&amp;gt;address1($params{address}) unless $user-&amp;gt;address1;
    $user-&amp;gt;address2($params{city})  unless $user-&amp;gt;address2;
    $user-&amp;gt;state($params{state})    unless $user-&amp;gt;state;
    $user-&amp;gt;postal_code($params{zip})  unless $user-&amp;gt;postal_code;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We need to construct a request to go out via &lt;code&gt;Business::OnlinePayment&lt;/code&gt;; thankfully, the form parameters we&amp;rsquo;ve received are going to be precisely in the format that &lt;code&gt;OnlinePayment&lt;/code&gt; wants, thanks to careful form design. All we need to do is to insert our account details and the total:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $tx = new Business::OnlinePayment(&amp;quot;TCLink&amp;quot;);
    $tx-&amp;gt;content(%params,
      type   =&amp;gt; &amp;quot;cc&amp;quot;,
      login  =&amp;gt; VENDOR_LOGIN,
      password =&amp;gt; VENDOR_PASSWORD,
      action   =&amp;gt; &#39;Normal Authorization&#39;
      amount   =&amp;gt; $r-&amp;gt;{user}-&amp;gt;basket_total
    );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can submit the payment and see what happens. If there&amp;rsquo;s a problem, we add a message to the template and send the user back again:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $tx-&amp;gt;submit;
    if (!$tx-&amp;gt;is_success) {
      $r-&amp;gt;{template_args}{message} =
        &amp;quot;There was a problem authorizing your transaction: &amp;quot;.
        $tx-&amp;gt;error_message;
      $r-&amp;gt;{template} = &amp;quot;checkout&amp;quot;;
      return;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Otherwise, we have our money; we probably want to tell the box-shifters about it, or we lose customers fast:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    fulfill_order(
      address_details =&amp;gt; $r-&amp;gt;{params},
      order_details   =&amp;gt; [ map { $_-&amp;gt;item } $r-&amp;gt;{user}-&amp;gt;cart_items ],
      cc_auth     =&amp;gt; $tx-&amp;gt;authorization
    );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now we empty the shopping cart, and send the user on his way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $_-&amp;gt;delete for $r-&amp;gt;{user}-&amp;gt;cart_items;
    $r-&amp;gt;{template} = &amp;quot;frontpage&amp;quot;;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Done! We&amp;rsquo;ve taken a user from logging in, adding goods to the cart, credit card validation, and checkout. But&amp;hellip; wait. How did we get our user in the first place?&lt;/p&gt;

&lt;h3 id=&#34;span-id-registering-a-user-registering-a-user-span&#34;&gt;&lt;span id=&#34;Registering_a_User&#34;&gt;Registering a User&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;We have to find a way to sign a user up. This is actually not that hard, particularly since we can use the example of &lt;a href=&#34;https://metacpan.org/pod/Maypole::Manual::Flox&#34;&gt;Flox&lt;/a&gt; in the Maypole manual. First, we&amp;rsquo;ll add a &amp;ldquo;register&amp;rdquo; link to our login template:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;P&amp;gt;New user? &amp;lt;A HREF=&amp;quot;/user/register&amp;quot;&amp;gt;Sign up!&amp;lt;/A&amp;gt;&amp;lt;/P&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This page doesn&amp;rsquo;t require any objects to be loaded up, since it&amp;rsquo;s just going to display a registration form; we can just add our template in &lt;em&gt;/user/register&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  [% INCLUDE header %]
  &amp;lt;P&amp;gt;Welcome to buying with iSellIt!&amp;lt;/P&amp;gt;

  &amp;lt;P&amp;gt;To set up your account, we only need a few details from you:
  &amp;lt;/P&amp;gt;

  &amp;lt;FORM METHOD=&amp;quot;POST&amp;quot; ACTION=&amp;quot;/user/do_register&amp;quot;&amp;gt;
    &amp;lt;P&amp;gt;Your name:
    &amp;lt;input name=&amp;quot;first_name&amp;quot;&amp;gt;
    &amp;lt;input name=&amp;quot;last_name&amp;quot;&amp;gt; &amp;lt;/P&amp;gt;
    &amp;lt;P&amp;gt;Your email address: &amp;lt;input name=&amp;quot;email&amp;quot;&amp;gt; &amp;lt;/P&amp;gt;
    &amp;lt;P&amp;gt;Please choose a password: &amp;lt;input name=&amp;quot;password&amp;quot;&amp;gt; &amp;lt;/P&amp;gt;
    &amp;lt;input type=&amp;quot;submit&amp;quot; name=&amp;quot;Register&amp;quot; value=&amp;quot;Register&amp;quot;&amp;gt;
  &amp;lt;/FORM&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As before, we need to explain to &lt;a href=&#34;https://metacpan.org/pod/Class::DBI::FromCGI&#34;&gt;Class::DBI::FromCGI&lt;/a&gt; how these fields are to be edited:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ISellIt::User-&amp;gt;untaint_columns(
    printable =&amp;gt; [qw/first_name last_name password/],
    email   =&amp;gt; [qw/email/],
  );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now we can write our &lt;code&gt;do_register&lt;/code&gt; event, using the &lt;code&gt;FromCGI&lt;/code&gt; style:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  sub do_register :Exported {
    my ($self, $r) = @_;
    my $h = CGI::Untaint-&amp;gt;new(%{$r-&amp;gt;{params}});
    my $user = $self-&amp;gt;create_from_cgi($h);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If there were any problems, we send them back to the register form again:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if (my %errors = $obj-&amp;gt;cgi_update_errors) {
      $r-&amp;gt;{template_args}{cgi_params} = $r-&amp;gt;{params};
      $r-&amp;gt;{template_args}{errors} = \%errors;
      $r-&amp;gt;{template} = &amp;quot;register&amp;quot;;
      return;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Otherwise, we now have a user; we need to issue the cookie as if the user had logged in normally. Again, this is something that &lt;code&gt;UserSessionCookie&lt;/code&gt; looks after for us:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $r-&amp;gt;{user} = $user;
    $r-&amp;gt;login_user($user-&amp;gt;id);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally we send the user on his or her way again:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $r-&amp;gt;{template} = &amp;quot;frontpage&amp;quot;;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There we go: now we can create new users; provision of a password reminder function is an exercise for the interested reader.&lt;/p&gt;

&lt;h3 id=&#34;span-id-maypole-summary-maypole-summary-span&#34;&gt;&lt;span id=&#34;Maypole_Summary&#34;&gt;Maypole Summary&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ve done it &amp;ndash; we&amp;rsquo;ve created an e-commerce store in a very short space of time and with a minimal amount of code. One of the things that I like about Maypole is the extent to which you only need to code your business logic; all of the display templates can be mocked up and then shipped off to professionals, and the rest of the work is just handled magically behind the scenes by Maypole.&lt;/p&gt;

&lt;p&gt;Thanks to the TPF funding of Maypole, we now have an extensive user manual with several case studies (this one included), and a lively user and developer community. I hope you too will be joining it soon!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rapid Web Application Deployment with Maypole</title>
      <link>http://localhost:1313/pub/2004/04/15/maypole.html/</link>
      <pubDate>Thu, 22 Apr 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/04/15/maypole.html/</guid>
      <description>

&lt;p&gt;You have a database. You have a web server. You have a deadline.&lt;/p&gt;

&lt;p&gt;Whether it&amp;rsquo;s bringing up an e-commerce storefront for a new venture, implementing a new front-end to HR&amp;rsquo;s employee database, or even providing a neat way to track citations for U.S. English slang terms, it&amp;rsquo;s always the same story &amp;ndash; and the deadline is always yesterday.&lt;/p&gt;

&lt;p&gt;For this month of April, I&amp;rsquo;m working on a Perl Foundation sponsorship to develop a project of mine called Maypole, which enables Perl programmers to get web front-ends to databases, as well as complex web-based applications, up and running quickly.&lt;/p&gt;

&lt;p&gt;Extremely quickly, and with very little Perl coding required. I&amp;rsquo;ve used Maypole to set up an Intranet portal, a database and display system for choosing menus and recipes, song lyric and chord sheet projection software, an open-source social network site, and a web database of beer-tasting notes; and that just was in the past two weeks.&lt;/p&gt;

&lt;p&gt;Maypole&amp;rsquo;s flexibility stems from three fundamentals:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#Separation_of_concerns&#34;&gt;Clear separation of concerns&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/15/maypole.html#Sensible_defaults&#34;&gt;Intelligent defaults&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/15/maypole.html#Ease_of_Extensibility&#34;&gt;Ease of extensibility&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To demonstrate these three principles, we&amp;rsquo;re going to look at a bread-and-butter web application &amp;ndash; an online shop&amp;rsquo;s product catalogue &amp;ndash; and see how quickly we can put it together with Maypole.&lt;/p&gt;

&lt;h2 id=&#34;span-id-separation-of-concerns-separation-of-concerns-span&#34;&gt;&lt;span id=&#34;Separation_of_concerns&#34;&gt;Separation of Concerns&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;Maypole was originally called &lt;code&gt;Apache::MVC&lt;/code&gt;, reflecting its basis in the Model-View-Controller design pattern. (I had to change it firstly because Maypole isn&amp;rsquo;t tied to Apache, and secondly because &lt;code&gt;Apache::MVC&lt;/code&gt; is a really dull name.) It&amp;rsquo;s the same design pattern that forms the foundation of similar projects in other languages, such as Java&amp;rsquo;s Struts framework.&lt;/p&gt;

&lt;p&gt;This design pattern is found primarily in graphical applications; the idea is that you have a Model class that represents and manipulates your data, a View class that is responsible for displaying that data to the user, and a Controller class that controls the other classes in response to events triggered by the user. This analogy doesn&amp;rsquo;t correspond precisely to a web-based application, but we can take an important principle from it. As Andy Wardley explains:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What the MVC-for-the-web crowd is really trying to achieve is a clear separation of concerns. Put your database code in one place, your application code in another, your presentation code in a third place. That way, you can chop and change different elements at will, hopefully without affecting the other parts (depending on how well your concerns are separated, of course). This is common sense and good practice. MVC achieves this separation of concerns as a byproduct of clearly separating inputs (controls) and outputs (views).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is what Maypole does. It has a number of database drivers, a number of front-end drivers, and a number of templating presentation drivers. In common cases, Maypole provides precisely what you need for all of these areas, and you get to concentrate on writing just the business logic of your application. This is one of the reasons why Maypole lets you develop so rapidly &amp;ndash; because most of the time, you don&amp;rsquo;t need to do any development at all.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s begin, then, by choosing what elements are going to make up our product database. We will actually be using what is by far the most common configuration of model, view, and controller classes: Maypole provides a model class based on &lt;code&gt;Class::DBI&lt;/code&gt;, a view class based on &lt;code&gt;Template::Toolkit&lt;/code&gt;, and a controller class based on Apache &lt;code&gt;mod_perl&lt;/code&gt;. We&amp;rsquo;ll come to what all of this means in a second, but because this configuration is so common, it is the default; no code is required to set that up.&lt;/p&gt;

&lt;p&gt;We will, however, need a database. Our client is going to be &lt;code&gt;iSellIt&lt;/code&gt;, a fictitious supplier of computer components and software. We will have database tables for products, manufacturers, and categories of stuff, and subcategories of categories. Here&amp;rsquo;s what that database might look like.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    CREATE TABLE product (
        id int NOT NULL auto_increment primary key,
        category int,
        subcategory int,
        manufacturer int,
        part_number varchar(50),
        name varchar(50),
        cost decimal(6,2),
        description text
    );

    CREATE TABLE manufacturer (
        id int NOT NULL auto_increment primary key,
        name varchar(50),
        url varchar(255),
        notes text
    );

    CREATE TABLE category (
        id int NOT NULL auto_increment primary key,
        name varchar(50)
    );

    CREATE TABLE subcategory (
        id int NOT NULL auto_increment primary key,
        name varchar(50),
        category integer
    );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;re going to assume that we&amp;rsquo;ve loaded some data into this database already, but we&amp;rsquo;re going to want the sales people to update it themselves over a web interface.&lt;/p&gt;

&lt;p&gt;In order to use Maypole, we need what&amp;rsquo;s called a driver module. This is a very short Perl module that defines the application we&amp;rsquo;re working with. I say it&amp;rsquo;s a Perl module, and that may make you think this is about writing code, but to be honest, most of it is actually configuration in disguise. Here&amp;rsquo;s the driver module for our ISellIt application. (The client may be called &lt;code&gt;iSellIt&lt;/code&gt;, but many years exposure to Perl module names makes me allergic to starting one with a lowercase letter.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package ISellIt;
    use base &#39;Apache::MVC&#39;;
    use Class::DBI::Loader::Relationship;

    ISellIt-&amp;gt;setup(&amp;quot;dbi:mysql:isellit&amp;quot;);
    ISellIt-&amp;gt;config-&amp;gt;{uri_base} = &amp;quot;http://localhost/isellit&amp;quot;;
    ISellIt-&amp;gt;config-&amp;gt;{rows_per_page} = 10;
    ISellIt-&amp;gt;config-&amp;gt;{loader}-&amp;gt;relationship($_) for 
        (&amp;quot;a manufacturer has products&amp;quot;, &amp;quot;a category has products&amp;quot;,
         &amp;quot;a subcategory has products&amp;quot;, &amp;quot;a category has subcategories&amp;quot;);

    1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ten lines of code; that&amp;rsquo;s the sort of size you should expect a Maypole application to be. Let&amp;rsquo;s take it apart, a line at a time:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package ISellIt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the name of our application, and it&amp;rsquo;s what we&amp;rsquo;re going to tell Apache to use as the Perl handler for our web site.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use base &#39;Apache::MVC&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This says that we&amp;rsquo;re using the Apache front-end to Maypole, and so we&amp;rsquo;re writing a &lt;code&gt;mod_perl&lt;/code&gt; application.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Class::DBI::Loader::Relationship;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we use a Perl module that I wrote to help put together Maypole driver classes. It allows us to declare the relationships between our database tables in a straightforward way.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ISellIt-&amp;gt;setup(&amp;quot;dbi:mysql:isellit&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We tell &lt;code&gt;ISellIt&lt;/code&gt; to go connect to the database and work out the tables and columns in our application. In addition, because we haven&amp;rsquo;t changed any class defaults, it&amp;rsquo;s assumed that we&amp;rsquo;re going to use &lt;code&gt;Class::DBI&lt;/code&gt; and Template Toolkit. We could have said that we want to use &lt;code&gt;Apache::MVC&lt;/code&gt; with &lt;code&gt;DBIx::SearchBuilder&lt;/code&gt; and &lt;code&gt;HTML::Mason&lt;/code&gt;, but we don&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;Maypole&amp;rsquo;s &lt;code&gt;Class::DBI&lt;/code&gt;-based class uses &lt;a href=&#34;https://metacpan.org/pod/Class::DBI::Loader&#34;&gt;&lt;code&gt;Class::DBI::Loader&lt;/code&gt;&lt;/a&gt; to investigate the structure of the database, and then map the &lt;code&gt;product&lt;/code&gt; table onto a &lt;code&gt;ISellIt::Product&lt;/code&gt; class, and so on. You can read more about how &lt;code&gt;Class::DBI&lt;/code&gt;&amp;rsquo;s table-class mapping works in &lt;a href=&#34;http://www.perl.com/pub/2002/11/27/classdbi.html&#34;&gt;Tony&amp;rsquo;s article about it&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ISellIt-&amp;gt;config-&amp;gt;{uri_base} = &amp;quot;http://localhost/isellit&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ISellIt&lt;/code&gt; sometimes needs to know where it lives, so that it can properly produce links to other pages inside the application.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ISellIt-&amp;gt;config-&amp;gt;{rows_per_page} = 10;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This says that we don&amp;rsquo;t want to display the whole product list on one page; there&amp;rsquo;ll be a maximum of 10 items on a page, before we get a page-view of the list.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ISellIt-&amp;gt;config-&amp;gt;{loader}-&amp;gt;relationship($_) for 
        (&amp;quot;a manufacturer has products&amp;quot;, &amp;quot;a category has products&amp;quot;,
         &amp;quot;a subcategory has products&amp;quot;, &amp;quot;a category has subcategories&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we define our relationship constraints, in reasonably natural syntax: a manufacturer has a number of products, and a category will delimit a collection of products, and so on.&lt;/p&gt;

&lt;p&gt;Ten lines of code. What has it got us?&lt;/p&gt;

&lt;h2 id=&#34;span-id-sensible-defaults-sensible-defaults-span&#34;&gt;&lt;span id=&#34;Sensible_defaults&#34;&gt;Sensible Defaults&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;The second foundation of Maypole is its use of sensible defaults. It has a system of generic templates that &amp;ldquo;do the right thing&amp;rdquo; for viewing and editing data in a database. In many cases, web application programmers won&amp;rsquo;t need to change the default behavior at all; in the majority of cases, they only need to change a few of the templates, and in the best cases, they can declare that the templating is the web design group&amp;rsquo;s problem and not need to do any work at all.&lt;/p&gt;

&lt;p&gt;So, if we install the application and the default templates, and go to our site, &lt;code&gt;http://localhost/isellit&lt;/code&gt;; we should see this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2004_04_15_maypole/maypole1.png&#34; alt=&#34;&#34; /&gt;
Which is only fair for 10 lines of code. But it gets better, because if we click on, say, the product listing, we get a screen like so:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2004_04_15_maypole/maypole2.png&#34; alt=&#34;&#34; /&gt;
Now that&amp;rsquo;s something we could probably give to the sales team with no further alterations needed, and they could happily add, edit, and delete products.&lt;/p&gt;

&lt;p&gt;Similarly, if we then click on a manufacturer in that products table, we see a handy page about the manufacturer, their products, and so on:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2004_04_15_maypole/maypole3.png&#34; alt=&#34;&#34; /&gt;
Now I think we are getting some worth from our 10 lines. Next, we give the templates to the web designers. Maypole searches for templates in three different places: first, it looks for a template specific to a class; then it looks for a custom template for the whole application; finally, it looks in the &lt;em&gt;factory&lt;/em&gt; directory to use the totally generic, do-the-right-thing template.&lt;/p&gt;

&lt;p&gt;So, to make a better manufacturer view, we tell them to copy the &lt;em&gt;factory/view&lt;/em&gt; template into &lt;em&gt;manufacturer/view&lt;/em&gt; and customize it. We copy &lt;em&gt;factory/list&lt;/em&gt; into &lt;em&gt;product/list&lt;/em&gt; and customize it as a listing of products; we copy &lt;em&gt;factory/header&lt;/em&gt; and &lt;em&gt;factory/footer&lt;/em&gt; into the &lt;em&gt;custom/&lt;/em&gt; directory, and turn them into the boilerplate HTML surrounding every page, and so on.&lt;/p&gt;

&lt;p&gt;Now, I am not very good at HTML design, which is why I like Maypole &amp;ndash; it makes it someone else&amp;rsquo;s problem &amp;ndash; but this means I&amp;rsquo;m not very good at showing you what sort of thing you can do with the templates. But here&amp;rsquo;s a mock-up; I created &lt;code&gt;product/view&lt;/code&gt; with the following template:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [% INCLUDE header %]
    [% PROCESS macros %]

    &amp;lt;DIV class=&amp;quot;nav&amp;quot;&amp;gt; You are in: [% maybe_link_view(product.category) %] &amp;gt; 
    [% maybe_link_view(product.subcategory) %] &amp;lt;/DIV&amp;gt;

    &amp;lt;h2&amp;gt; [% product.name %]&amp;lt;/h2&amp;gt;
    &amp;lt;DIV class=&amp;quot;manufacturer&amp;quot;&amp;gt; By [% maybe_link_view(product.manufacturer) %] 
    &amp;lt;/DIV&amp;gt;
    &amp;lt;DIV class=&amp;quot;description&amp;quot;&amp;gt; [% product.description %] &amp;lt;/DIV&amp;gt;

    &amp;lt;TABLE class=&amp;quot;view&amp;quot;&amp;gt;
    &amp;lt;TR&amp;gt;
        &amp;lt;TD class=&amp;quot;field&amp;quot;&amp;gt; Price (ex. VAT) &amp;lt;/TD&amp;gt; 
        &amp;lt;TD&amp;gt; &amp;amp;pound; [% product.cost %] &amp;lt;/TD&amp;gt;
    &amp;lt;/TR&amp;gt;
    &amp;lt;TR&amp;gt;
        &amp;lt;TD class=&amp;quot;field&amp;quot;&amp;gt; Part number  &amp;lt;/TD&amp;gt; 
        &amp;lt;TD&amp;gt; [% product.part_number %] &amp;lt;/TD&amp;gt;
    &amp;lt;/TR&amp;gt;
    &amp;lt;/TABLE&amp;gt;

    [% button(product, &amp;quot;order&amp;quot;) %]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Producing the following screenshot. It may not look better, but at least it proves things can be made to look different.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2004_04_15_maypole/maypole4.png&#34; alt=&#34;&#34; /&gt;
We&amp;rsquo;ve written a Template Toolkit template; the parts surrounded in &lt;code&gt;[% ... %]&lt;/code&gt; are templating directives. If you&amp;rsquo;re not too familiar with the Template Toolkit, the Maypole manual&amp;rsquo;s &lt;a href=&#34;http://maypole.simon-cozens.org/doc/View.html&#34;&gt;view documentation&lt;/a&gt; has a good introduction to TT in the Maypole context.&lt;/p&gt;

&lt;p&gt;Maypole provides a number of default Template macros, such as &lt;code&gt;maybe_link_view&lt;/code&gt;, which links an object to a page viewing that object, although all of these can be overridden. It also passes in the object &lt;code&gt;product&lt;/code&gt;, which it knows to be the one we&amp;rsquo;re talking about.&lt;/p&gt;

&lt;p&gt;In fact, that&amp;rsquo;s what Maypole is really about: we&amp;rsquo;ve described it in terms of putting a web front-end onto a database, but fundamentally, it&amp;rsquo;s responsible for using the URL &lt;code&gt;/product/view/210&lt;/code&gt; to load up the &lt;code&gt;product&lt;/code&gt; object with ID &lt;code&gt;210&lt;/code&gt;, call the &lt;code&gt;view&lt;/code&gt; method on its class, and pass it to the &lt;code&gt;view&lt;/code&gt; template. Similarly, &lt;code&gt;/product/list&lt;/code&gt; calls the &lt;code&gt;list&lt;/code&gt; method on the product class, which populates the template with a page full of products.&lt;/p&gt;

&lt;p&gt;The interesting thing about this template is that very last line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [% button(product, &amp;quot;order&amp;quot;) %]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This produces a button which will produce a POST to the URL &lt;code&gt;/product/order/210&lt;/code&gt;, which does the same as &lt;code&gt;view&lt;/code&gt; except this time calls the &lt;code&gt;order&lt;/code&gt; method. But Maypole doesn&amp;rsquo;t yet know how to &lt;code&gt;order&lt;/code&gt; a product. This is OK, because we can tell it.&lt;/p&gt;

&lt;h2 id=&#34;span-id-ease-of-extensibility-ease-of-extensibility-span&#34;&gt;&lt;span id=&#34;Ease_of_Extensibility&#34;&gt;Ease of Extensibility&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;Maypole&amp;rsquo;s third principle is ease of extensibility. That is to say, Maypole makes it very easy to go from a simple database front-end to a full-fledged web application. Which is just as well; as has been simulated above, once the templates come back from the web designers, you find that what you thought was just going to be a product database has become an online shop. And you&amp;rsquo;ve still got a deadline.&lt;/p&gt;

&lt;p&gt;But before we start extending our catalogue application to take on the new specifications (which we&amp;rsquo;ll do in the second article about this), let&amp;rsquo;s take a look at what we&amp;rsquo;ve achieved so far and what we need immediately.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ve got a way to list all the products, manufacturers, categories, and subcategories in our database; we have a way to add, edit and delete all of these things; we can search for products by manufacturer, price, and so on. What&amp;rsquo;s to stop us deploying this as a customer-facing web site, as well as for Intranet updates to the product catalogue?&lt;/p&gt;

&lt;p&gt;The immediate problem is security. We can add, edit, and delete products &amp;ndash; but so can anyone else. We want to allow those coming from the outside world only to view, list and search; for everything else, we require the user to be coming from an IP address in our internal range. (For now; we&amp;rsquo;ll add the concept of a user when we&amp;rsquo;re adding the shopping cart, and the idea of privileged user won&amp;rsquo;t be far off that.)&lt;/p&gt;

&lt;p&gt;Unfortunately, now we want some user-defined behavior, we have to start writing code. Thankfully, we don&amp;rsquo;t have to write much of it. We add a few lines to our driver class, first to define our private IP address space as a &lt;code&gt;NetAddr::IP&lt;/code&gt; object, since that provides a handy way of determining if an address is in a network:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use constant INTERNAL_RANGE =&amp;gt; &amp;quot;10.0.0.0/8&amp;quot;;
    use NetAddr::IP;
    my $range = NetAddr::IP-&amp;gt;new(INTERNAL_RANGE);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we write our authentication method; Maypole&amp;rsquo;s default &lt;code&gt;authenticate&lt;/code&gt; allows everyone access to everything, so we need to override this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Maypole::Constants;
    sub authenticate {
        my ($self, $r) = @_;

        # Everyone can view, search, list
        return OK if $r-&amp;gt;action =~ /^(view|search|list)$/;

        # Else they have to be in the internal network
        my $ip = NetAddr-&amp;gt;IP-&amp;gt;new($r-&amp;gt;{ar}-&amp;gt;connection-&amp;gt;remote_ip);
        return OK if $ip-&amp;gt;within($range);
        return DECLINED;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;authenticate&lt;/code&gt; class method gets passed a Maypole request object; this is like an Apache request object, but at a much, much higher level &amp;ndash; it contains information about the web request, the class that&amp;rsquo;s going to be used to fulfill the request, the method we need to call on the class, the template that&amp;rsquo;s going to be processed, any objects, form parameters, and query parameters, and so on.&lt;/p&gt;

&lt;p&gt;At this point, Maypole has already parsed the URI into its component database table, action, and additional arguments, so we first check to see if the action is one of the universally permitted ones.&lt;/p&gt;

&lt;p&gt;If not, we extract the &lt;code&gt;Apache::Request&lt;/code&gt; object stashed inside the Maypole object, and ask it for the remote IP address. If it&amp;rsquo;s in the private range, we can do everything. If not, we can do nothing. Simple enough.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s almost ready to go live, when the design guys tell you that they&amp;rsquo;d really love to put a picture alongside the description of a product. No problem.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s two ways to do this; the way that seems really easy uses the file system to store the pictures, and has you put something like this in the template:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;IMG SRC=&amp;quot;/static/product_pictures/[% product.id %].png&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But while that&amp;rsquo;s very simple for viewing pictures, and makes a great mockup, it&amp;rsquo;s not that easy to upload pictures. So you decide to put the pictures in the database. You add a &amp;ldquo;picture&amp;rdquo; binary column to the product table, and then you consult the Maypole manual.&lt;/p&gt;

&lt;p&gt;One of the great things about this Perl Foundation sponsorship is that it&amp;rsquo;s allowing me to put together a really great manual, which contains all sorts of tricks for dealing with Maypole; the &lt;a href=&#34;http://maypole.simon-cozens.org/doc/Request.html&#34;&gt;Request&lt;/a&gt; chapter contains a couple of recipes for uploading and displaying photos.&lt;/p&gt;

&lt;p&gt;What we need to do is create some new actions &amp;ndash; one to upload a picture, and one to display it again. We&amp;rsquo;ll only show the one to display a picture, since you can get them both from the manual, and because looking at this turns out to be a handy way to understand how to extend Maypole more generally.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s useful to visualize what we&amp;rsquo;re going to end up with, and work backwards. We&amp;rsquo;ll have a URL like &lt;code&gt;/product/view_picture/210&lt;/code&gt; producing an &lt;code&gt;image/png&lt;/code&gt; or similar page with the product&amp;rsquo;s image. This allows us to put in our templates:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;IMG SRC=&amp;quot;/product/view_picture/[% product.id %]/&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And have the image displayed on our product view page. In fact, we&amp;rsquo;re more likely to want to say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [% IF product.picture %]
    &amp;lt;IMG SRC=&amp;quot;/product/view_picture/[% product.id %]/&amp;quot;&amp;gt;
    [% ELSE %]
    &amp;lt;IMG SRC=&amp;quot;/static/no_picture.png&amp;quot;&amp;gt;
    [% END %]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we&amp;rsquo;ve explained that Maypole turns URLs into method calls, so we&amp;rsquo;re going to be putting a &lt;code&gt;view_picture&lt;/code&gt; method in the product&amp;rsquo;s class; this class is &lt;code&gt;ISellIt::Product&lt;/code&gt;, so we begin like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package ISellIt::Product;
    sub view_picture {
        my ($self, $r) = @_;
        # ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This has a big problem. We don&amp;rsquo;t actually want people to be able to call any method on our class over the web; that would be unwise. Maypole will refuse to do this. So in order to tell Maypole that we&amp;rsquo;re allowed to call this method remotely, we decorate it with an attribute:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub view_picture :Exported {
        my ($self, $r) = @_;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point, we can call &lt;code&gt;view_picture&lt;/code&gt; over the Web; we now need to make it populate the Maypole request with the appropriate data:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub view_picture :Exported {
        my ($self, $r, $product) = @_;
        if ($product) {
            $r-&amp;gt;{content_type} = &amp;quot;image/png&amp;quot;;
            $r-&amp;gt;{content} = $product-&amp;gt;picture;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a slightly unusual Maypole method, because we&amp;rsquo;re bypassing the whole view class processing and templating stages, and generating content manually, but it serves to illustrate one thing: Maypole arranges for the appropriate object to be passed into the method; we&amp;rsquo;ve gone from URL to object without requiring any code of our own.&lt;/p&gt;

&lt;p&gt;When we come to implementing ordering, in our next article, we&amp;rsquo;ll be adding more actions like this to place the product in a user&amp;rsquo;s shopping cart, check out, validate his credit card and so on. But this should be good enough for now: a templated, web-editable product database, with pictures, without stress, without too much code, and within the deadline. Well, almost.&lt;/p&gt;

&lt;h2 id=&#34;span-id-summary-summary-span&#34;&gt;&lt;span id=&#34;Summary&#34;&gt;Summary&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;Maypole is evolving rapidly, thanks primarily to the Perl Foundation who have enabled me to work on it for this month; it&amp;rsquo;s allowed me to write many thousands of words of articles, sample applications, and Maypole-related code, and this has helped Maypole to become an extremely useful framework for developing web applications.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Find What You Want with Plucene</title>
      <link>http://localhost:1313/pub/2004/02/19/plucene.html/</link>
      <pubDate>Thu, 19 Feb 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/02/19/plucene.html/</guid>
      <description>

&lt;p&gt;For the past few months, my &lt;a href=&#34;http://www.kasei.com&#34;&gt;former employers&lt;/a&gt; and I have been working on a port of the Java &lt;a href=&#34;http://jakarta.apache.org/lucene/&#34;&gt;Lucene&lt;/a&gt; search engine toolkit.&lt;/p&gt;

&lt;p&gt;On the February 3rd, &lt;a href=&#34;https://metacpan.org/pod/Plucene&#34;&gt;Plucene&lt;/a&gt; was released to the world, implementing almost all of the functionality of the Java equivalent. Satisfied with a job done, I parted company with Kasei to pursue some projects of my own &amp;ndash; about which I&amp;rsquo;m sure you&amp;rsquo;ll be hearing more later.&lt;/p&gt;

&lt;p&gt;Very soon after, the phone rang, and it turned out that someone actually wanted to use this Plucene thing; they needed to add a search engine to a web-based book that they had produced, and had some pretty complex requirements that meant that the usual tools &amp;ndash; HTDig, Glimpse and friends &amp;ndash; couldn&amp;rsquo;t quite do the job. Could I come around and write a Plucene-based search engine for them?&lt;/p&gt;

&lt;p&gt;Well, this turned out to have its challenges, and these turned out to make an interesting introduction to using Plucene, so I decided to share them with you. I won&amp;rsquo;t tell you how to do all of the complicated things we had to do for this custom engine, but I should give you enough to get your own Plucene indexes up and running.&lt;/p&gt;

&lt;h3 id=&#34;span-id-making-it-easy-plucene-simple-making-it-easy-plucene-simple-span&#34;&gt;&lt;span id=&#34;Making_it_easy_-_Plucene::Simple&#34;&gt;Making It Easy: Plucene::Simple&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The easiest way to use Plucene is through the &lt;code&gt;Plucene::Simple&lt;/code&gt; module. To write our index, we say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Plucene::Simple;

    my $index = Plucene::Simple-&amp;gt;open( &amp;quot;/var/plucene/site&amp;quot; );
    for my $id (keys %documents) {
        $index-&amp;gt;add($id =&amp;gt; $documents{$id});
    }
    $index-&amp;gt;optimize;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But what goes in our &lt;code&gt;%documents&lt;/code&gt; hash?&lt;/p&gt;

&lt;p&gt;One difference between Plucene and other search systems like HTDig is that Plucene only provides a toolkit; it doesn&amp;rsquo;t provide a complete indexer to suck up a directory of files, for instance. You have to make your own representation of the content of a document, and then add that to the index. For instance, we want to end up with a hash like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; %documents = (
    &amp;quot;chapter5.html&amp;quot; =&amp;gt; { chapter =&amp;gt; 5,
                         title =&amp;gt; &amp;quot;In which Piglet meets a Heffalump&amp;quot;,
                         content =&amp;gt; &amp;quot;One day, when Christopher Robin...&amp;quot;,
                       }
 );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This means that we can&amp;rsquo;t simply index the book by providing a list of files to a command-line program. We have to actually write some code.&lt;/p&gt;

&lt;p&gt;Some people may think this is a problem, but I see it as an opportunity. For instance, most web pages these days (this one included) are surrounded in a template with banners, titles, and navigation bars down the side. These things are static and appear on every page, so can only harm search engine results; we don&amp;rsquo;t want to index them. Our indexing code can look at the structure of the document, extract some metadata from it, and construct a hash reference that represents just the important bits of content.&lt;/p&gt;

&lt;p&gt;The HTML files I had to deal with looked a bit like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;head&amp;gt;
        &amp;lt;meta name=&amp;quot;chapter&amp;quot; value=&amp;quot;...&amp;quot;&amp;gt;
        &amp;lt;!-- other useful metadata here --&amp;gt;
        &amp;lt;title&amp;gt; ... &amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;div id=&amp;quot;navigation&amp;quot;&amp;gt;...&amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;content&amp;quot;&amp;gt;...&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I wanted to extract what was in the &lt;code&gt;meta&lt;/code&gt; tags, the &lt;code&gt;title&lt;/code&gt;, and everything in the &lt;code&gt;content&lt;/code&gt; div. One of the nicest ways to do this in Perl is with the &lt;a href=&#34;https://metacpan.org/pod/HTML::TreeBuilder&#34;&gt;&lt;code&gt;HTML::TreeBuilder&lt;/code&gt;&lt;/a&gt;, which allows us to &amp;ldquo;dig down&amp;rdquo; for the elements that we want to find:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use HTML::TreeBuilder;
    my $tree = HTML::TreeBuilder-&amp;gt;new-&amp;gt;parse_file(&amp;quot;chapter1.html&amp;quot;);
    my $document = { chapter =&amp;gt; 1 };

    my $title_tag = $tree-&amp;gt;look_down( _tag =&amp;gt; &amp;quot;title&amp;quot; );
    $document-&amp;gt;{title} = $title_tag-&amp;gt;as_text;

    my $content_tag = $tree-&amp;gt;look_down( _tag =&amp;gt; &amp;quot;div&amp;quot;, id =&amp;gt; &amp;quot;content&amp;quot; );
    $document-&amp;gt;{content} = $content_tag-&amp;gt;as_text;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It also allows us to extract attributes from tags:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for my $tag ($tree-&amp;gt;look_down( _tag =&amp;gt; &amp;quot;meta&amp;quot;)) {
        $document{$tag-&amp;gt;attr(&amp;quot;name&amp;quot;)} = $tag-&amp;gt;attr(&amp;quot;content&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have the salient parts of the chapter extracted as a hash reference, and we can add this to our index, keyed by the filename:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $index-&amp;gt;add( &amp;quot;chapter1.html&amp;quot; =&amp;gt; $document );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To do this for a whole directory tree of files, we can use the wonderful &lt;a href=&#34;https://metacpan.org/pod/File::Find::Rule&#34;&gt;&lt;code&gt;File::Find::Rule&lt;/code&gt;&lt;/a&gt; module:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for my $filename (File::Find::Rule-&amp;gt;file
                      -&amp;gt;name( qr/^(?!index).*\.html/ )-&amp;gt;in(&amp;quot;.&amp;quot;)) {
        print &amp;quot;Processing $filename...\n&amp;quot;;
        $writer-&amp;gt;writer( $filename =&amp;gt; file2hash($filename) );
    }
    $index-&amp;gt;optimize;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This finds all files underneath the current directory called &lt;code&gt;*.html&lt;/code&gt; that don&amp;rsquo;t start with the characters &lt;code&gt;index&lt;/code&gt;. (We needed some special treatment on the index of the book itself, since providing search results to pages in the index would not be helpful.)&lt;/p&gt;

&lt;h3 id=&#34;span-id-running-the-search-running-the-search-span&#34;&gt;&lt;span id=&#34;Running_the_Search&#34;&gt;Running the Search&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The search part of the operation is now pretty easy. We have a CGI script or equivalent that gets the search query string, and then we say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Plucene::Simple;

    my (@ids, $error);
    if (!$query) {
        $error = &amp;quot;Your search term was empty&amp;quot;;
    } else {
        $index = Plucene::Simple-&amp;gt;open( &amp;quot;/var/plucene/site&amp;quot; );
        @ids = $index-&amp;gt;search($query);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and this returns the list of filenames that matched the query. Because I tend to use Template Toolkit for pretty much everything these days, it became:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $t = Template-&amp;gt;new();
    $t-&amp;gt;process(&amp;quot;searchResult.html&amp;quot;, {
        query   =&amp;gt; $query,
        results =&amp;gt; \@ids,
        error   =&amp;gt; $error,
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the relevant part of the template is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [% IF error %]
       &amp;lt;H2&amp;gt; Search had errors &amp;lt;/H2&amp;gt;
       &amp;lt;FONT COLOR=&amp;quot;#ff0000&amp;quot;&amp;gt; [% error %] &amp;lt;/FONT&amp;gt;
    [% ELSE %]
       &amp;lt;H2&amp;gt; Search results for [% query %] &amp;lt;/H2&amp;gt;
        [% IF results.size &amp;gt; 0 %]
            &amp;lt;OL&amp;gt;
              [% FOR result = results %]
              &amp;lt;LI&amp;gt;
                  &amp;lt;A HREF=&amp;quot;/[% filename %]&amp;quot;&amp;gt; [% filename %] &amp;lt;/A&amp;gt;
              &amp;lt;/LI&amp;gt;
              [% END %]
            &amp;lt;/OL&amp;gt;
        [% ELSE %]
            &amp;lt;P&amp;gt;No results found&amp;lt;/P&amp;gt;
        [% END %]
    [% END %]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, this isn&amp;rsquo;t very pretty, for a couple of reasons. The first reason is that we&amp;rsquo;re linking the result to a filename, rather than displaying something friendly like the name of the chapter. The second is that when you get results from a web search engine, you generally also expect to see some context for the terms that you&amp;rsquo;ve just searched for, so you know how the terms appear on the page.&lt;/p&gt;

&lt;p&gt;We can&amp;rsquo;t easily solve the first problem with &lt;code&gt;Plucene::Simple&lt;/code&gt;, so we&amp;rsquo;ll come back to it. But contextualizing search results is something we can do.&lt;/p&gt;

&lt;h3 id=&#34;span-id-contextualising-results-contextualizing-results-span&#34;&gt;&lt;span id=&#34;Contextualising_results&#34;&gt;Contextualizing Results&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&#34;https://metacpan.org/pod/Text::Context&#34;&gt;&lt;code&gt;Text::Context&lt;/code&gt;&lt;/a&gt; module was written to solve a similar contextualizing problem; it takes a bunch of keywords and a source document, and produces a paragraph-sized chunk of text highlighting where the keywords occur.&lt;/p&gt;

&lt;p&gt;Since it works by trying to subdivide the text into paragraphs, it&amp;rsquo;s helpful to have a text-only version of the document available. If we don&amp;rsquo;t, we can use &lt;code&gt;HTML::TreeBuilder&lt;/code&gt; again to produce them:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub snippet {
        my $filename = shift;
        use HTML::Tree;
        my $tree = HTML::TreeBuilder-&amp;gt;new();
        $tree-&amp;gt;parse_file(DOCUMENT_ROOT . &amp;quot;/&amp;quot; . $filename)
            or die &amp;quot;Couldn&#39;t parse file&amp;quot;;
        my $content;
        my($div) = $tree-&amp;gt;look_down(&amp;quot;_tag&amp;quot;,&amp;quot;div&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;content&amp;quot;);
        for my $p ($div-&amp;gt;look_down(sub { shift-&amp;gt;tag() =~ /^(h\d+|p)/i })) {
            $content . = $p-&amp;gt;as_text.&amp;quot;\n\n&amp;quot;;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This looks for headings and paragraphs and extracts the text from them. Now we can split the search query into individual terms, and then call our &lt;code&gt;Text::Context&lt;/code&gt; module to get a snippet to pass to the templater:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        my @terms = split /\s+/, $query;
        my $snippet = Text::Context-&amp;gt;new($stuff, @terms)-&amp;gt;as_html();
        return $snippet;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far, so good! Then, of course, the specifications changed &amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;span-id-plucene-components-plucene-components-span&#34;&gt;&lt;span id=&#34;Plucene_Components&#34;&gt;Plucene Components&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;One of the things that makes a good search engine into a great search engine is the ability to automatically search for variations and inflections of the terms. For instance, if you search for &amp;ldquo;looking good,&amp;rdquo; you should also find documents that contain &amp;ldquo;looked good,&amp;rdquo; &amp;ldquo;looks good,&amp;rdquo; and so on.&lt;/p&gt;

&lt;p&gt;There are two ways to deal with this; the way HTDig chooses is to replace the &amp;ldquo;looking&amp;rdquo; with &amp;ldquo;(look OR looked OR looks OR looking),&amp;rdquo; but this isn&amp;rsquo;t particularly efficient or comprehensive.&lt;/p&gt;

&lt;p&gt;A second way is to index the words a little differently; filtering them through a stemmer which takes off the suffixes, so that all of the above collapse to &amp;ldquo;look.&amp;rdquo; &lt;a href=&#34;https://metacpan.org/pod/Lingua::Stem::En::stem&#34;&gt;&lt;code&gt;Lingua::Stem::En::stem&lt;/code&gt;&lt;/a&gt; does this, but we can&amp;rsquo;t plug it into &lt;code&gt;Plucene::Simple&lt;/code&gt; directly. To do this, we need to slip under the covers of &lt;code&gt;Plucene::Simple&lt;/code&gt; and meddle with the Plucene API itself.&lt;/p&gt;

&lt;p&gt;Before we see how to do this, let&amp;rsquo;s look at the various components of Plucene.&lt;/p&gt;

&lt;p&gt;The indexing part of the process is handled by &lt;code&gt;Plucene::Index::Writer&lt;/code&gt;; this takes in &lt;code&gt;Plucene::Document&lt;/code&gt; objects, and uses a &lt;code&gt;Plucene::Analysis::Analyzer&lt;/code&gt; subclass to break up the text of the document into tokens. The default analyzer as used by &lt;code&gt;Plucene::Simple&lt;/code&gt; is &lt;code&gt;Plucene::Analysis::SimpleAnalyzer&lt;/code&gt;, which breaks up words on non-letter boundaries and then forces them to lowercase them. The broken-up tokens are put into &lt;code&gt;Plucene::Index::Term&lt;/code&gt; to have a field associated with them; for instance, in our example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;TITLE&amp;gt;In which Pooh goes visiting and gets into a tight place&amp;lt;/HEAD&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will be turned by our &lt;code&gt;HTML::TreeBuilder&lt;/code&gt; munging into&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    {
    title =&amp;gt; &amp;quot;In which Pooh goes visiting and gets into a tight place&amp;quot;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and &lt;code&gt;Plucene::Simple&lt;/code&gt; turns this into a &lt;code&gt;Plucene::Document::Field&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    bless {name =&amp;gt; &amp;quot;title&amp;quot;,
    string =&amp;gt; &amp;quot;In which Pooh goes visiting and gets into a tight place&amp;quot;},
    &amp;quot;Plucene::Document::Field&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then into a set of &lt;code&gt;Plucene::Index::Term&lt;/code&gt; objects like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    bless { field =&amp;gt; &amp;quot;title&amp;quot;, text =&amp;gt; &amp;quot;in&amp;quot; }, &amp;quot;Plucene::Document::Term&amp;quot;
    bless { field =&amp;gt; &amp;quot;title&amp;quot;, text =&amp;gt; &amp;quot;which&amp;quot; }, &amp;quot;Plucene::Document::Term&amp;quot;
    bless { field =&amp;gt; &amp;quot;title&amp;quot;, text =&amp;gt; &amp;quot;pooh&amp;quot; }, &amp;quot;Plucene::Document::Term&amp;quot;
    bless { field =&amp;gt; &amp;quot;title&amp;quot;, text =&amp;gt; &amp;quot;goes&amp;quot; }, &amp;quot;Plucene::Document::Term&amp;quot;
    bless { field =&amp;gt; &amp;quot;title&amp;quot;, text =&amp;gt; &amp;quot;visiting&amp;quot; }, &amp;quot;Plucene::Document::Term&amp;quot;
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then various classes write out the terms and their frequencies into the index.&lt;/p&gt;

&lt;p&gt;When we come to searching, the &lt;code&gt;Plucene::Search::IndexSearcher&lt;/code&gt; acts as the top-level classes. It calls a &lt;code&gt;Plucene::QueryParser&lt;/code&gt; to turn the query into a set of &lt;code&gt;Plucene::Search::Query&lt;/code&gt; objects: this allows Plucene to differentiate between phrase queries such as &lt;code&gt;&amp;quot;looks good&amp;quot;&lt;/code&gt;, negated queries (&lt;code&gt;looks -good&lt;/code&gt;), queries in different fields (&lt;code&gt;looks title:good&lt;/code&gt;), and so on.&lt;/p&gt;

&lt;p&gt;This &lt;code&gt;QueryParser&lt;/code&gt;, in turn, uses the same analyzer as the indexer to break up the search terms into tokens. This is because if our indexer has seen &lt;code&gt;BORN2run&lt;/code&gt; and turned it into two tokens, &lt;code&gt;born&lt;/code&gt; and &lt;code&gt;run&lt;/code&gt;, and then we do a search on &lt;code&gt;BORN2run&lt;/code&gt;, we aren&amp;rsquo;t going to find it unless we transform the search terms to &lt;code&gt;born&lt;/code&gt; and &lt;code&gt;run&lt;/code&gt; in the same way.&lt;/p&gt;

&lt;h3 id=&#34;span-id-using-the-porter-analyzer-using-the-porter-analyzer-span&#34;&gt;&lt;span id=&#34;Using_the_Porter_Analyzer&#34;&gt;Using the Porter Analyzer&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;We need to replace the &lt;code&gt;SimpleAnalyzer&lt;/code&gt; with an analyzer that filters through &lt;code&gt;Lingua::Stem::En&lt;/code&gt;. Thankfully, here&amp;rsquo;s one I prepared earlier: &lt;code&gt;Plucene::Plugin::Analyzer::Porter&lt;/code&gt;. However, since &lt;code&gt;Plucene::Simple&lt;/code&gt; doesn&amp;rsquo;t allow us to change analyzers, we have to do everything manually.&lt;/p&gt;

&lt;p&gt;First, we produce a &lt;code&gt;Plucene::Index::Writer&lt;/code&gt;, with the appropriate analyzer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $writer = Plucene::Index::Writer-&amp;gt;new(
        &amp;quot;/var/plucene/site&amp;quot;,
        Plucene::Plugin::Analyzer::PorterAnalyzer-&amp;gt;new(),
        1 # Create the index from scratch
    );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we have to build up the &lt;code&gt;Plucene::Document&lt;/code&gt; ourselves, instead of just feeding a hash of attributes to &lt;code&gt;Plucene::Simple-&amp;gt;add&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my $doc = Plucene::Document-&amp;gt;new();
  $doc-&amp;gt;add(Plucene::Document::Field-&amp;gt;Keyword(filename =&amp;gt; $filename));

  my $title_tag = $tree-&amp;gt;look_down( _tag =&amp;gt; &amp;quot;title&amp;quot; );
  $doc-&amp;gt;add(Plucene::Document::Field-&amp;gt;Text( title =&amp;gt; $title_tag-&amp;gt;as_text ));

  for my $tag ($tree-&amp;gt;look_down( _tag =&amp;gt; &amp;quot;meta&amp;quot;)) {
      $document{$tag-&amp;gt;attr(&amp;quot;name&amp;quot;)} = $tag-&amp;gt;attr(&amp;quot;content&amp;quot;);
  }

  my $content_tag = $tree-&amp;gt;look_down( _tag =&amp;gt; &amp;quot;div&amp;quot;, id =&amp;gt; &amp;quot;content&amp;quot; );
  $doc-&amp;gt;add(Plucene::Document::Field-&amp;gt;UnStored( title =&amp;gt; $content_tag-&amp;gt;as_text ));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;ll notice that there are three different constructors for &lt;code&gt;Plucene::Document::Field&lt;/code&gt; objects &amp;ndash; the &lt;code&gt;Keyword&lt;/code&gt; is stored and can be retrieved, but isn&amp;rsquo;t broken up into tokens; this is used for things like filenames, where you want to get them back from the index verbatim. Fields constructed using &lt;code&gt;Text&lt;/code&gt; can be retrieved, but are also broken up into tokens for searching in the index. &lt;code&gt;UnStored&lt;/code&gt; text can&amp;rsquo;t be retrieved, but is indexed, so we use this for the content, the main bulk of the book.&lt;/p&gt;

&lt;p&gt;This will also solve our problem with the English description of the link, since it will allow us to retrieve the title field for a search hit.&lt;/p&gt;

&lt;p&gt;Once we have our document object, we can add it into the index:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $writer-&amp;gt;add($doc);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have the text filtered through the Porter stemmer, the tokens indexed will look like &amp;ldquo;&lt;code&gt;in which pooh goe visit&lt;/code&gt;.&amp;rdquo; Now we need to make sure that the same filter is used in searching, which means we also have to rewrite the search code to use this analyzer. First, we open the index for searching:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $searcher = Plucene::Search::IndexSearcher-&amp;gt;new( &amp;quot;/var/plucene/site&amp;quot; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we parse the query, specifying that any unqualified terms should be sought in the &lt;code&gt;content&lt;/code&gt; field:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $parser = Plucene::QueryParser-&amp;gt;new({
            analyzer =&amp;gt; Plucene::Plugin::PorterAnalyzer-&amp;gt;new(),
            default  =&amp;gt; &amp;quot;content&amp;quot;
        });
    my $parsed = $parser-&amp;gt;parse($query);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we declare a &lt;code&gt;Plucene::Search::HitCollector&lt;/code&gt;; this is a callback which is called every time a search hit is found. We use it to populate an array of information about hits:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @docs;
    my $hc       = Plucene::Search::HitCollector-&amp;gt;new(
        collect =&amp;gt; sub {
            my ($self, $doc, $score) = @_;
            my $res = eval { $searcher-&amp;gt;doc($doc) };
            push @docs, $res if $res;
        });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we do the search:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $searcher-&amp;gt;search_hc($parsed, $hc);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This fills &lt;code&gt;@docs&lt;/code&gt; with &lt;code&gt;Plucene::Document&lt;/code&gt; objects; from these, we want to extract the filename and the title fields, to pass to the templates:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @results = map {{ 
        filename =&amp;gt; $_-&amp;gt;get(&amp;quot;filename&amp;quot;)-&amp;gt;string,
        title =&amp;gt; $_-&amp;gt;get(&amp;quot;title&amp;quot;)-&amp;gt;string,
    }} @docs;

    for (@results) {
        $_-&amp;gt;{snippet} = snippet($_-&amp;gt;{filename})
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can put together a more impressive display for each result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;LI&amp;gt;
    &amp;lt;BLOCKQUOTE&amp;gt;
    [% result.snippet %]
    &amp;lt;/BLOCKQUOTE&amp;gt;
    &amp;lt;P&amp;gt;In &amp;lt;A HREF=&amp;quot;/[% result.filename %]&amp;quot;&amp;gt; [% result.title %]&amp;lt;/A&amp;gt;&amp;lt;/P&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This ends up looking like the following:&lt;/p&gt;

&lt;h3 id=&#34;search-results-for-bears-build&#34;&gt;Search results for &amp;ldquo;bears build&amp;rdquo;&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;It&amp;rsquo;s a very funny thought that, if &lt;strong&gt;Bears&lt;/strong&gt; were Bees, they&amp;rsquo;d &lt;strong&gt;build&lt;/strong&gt; their nests are the bottom of trees.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In &lt;em&gt;We are introduced&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Which looks quite nice and professional. Except for one slight matter.&lt;/p&gt;

&lt;p&gt;Suppose we had looked for &lt;code&gt;bear builds&lt;/code&gt;. We&amp;rsquo;d still match the same bit of text, thanks to stemming. However, the exact words that we&amp;rsquo;re looking for aren&amp;rsquo;t in that bit of text, so the contextualizer won&amp;rsquo;t do the right thing. What we need, then, is a version of &lt;code&gt;Text::Context&lt;/code&gt; that knows about Porter stemming. Thankfully, &lt;a href=&#34;https://metacpan.org/pod/Text::Context::Stemmer&#34;&gt;&lt;code&gt;Text::Context::Stemmer&lt;/code&gt;&lt;/a&gt; steps into the breach.&lt;/p&gt;

&lt;p&gt;We have a web search engine that understands Porter stemming. The first part of my job is done.&lt;/p&gt;

&lt;h3 id=&#34;span-id-and-everything-else-and-everything-else-span&#34;&gt;&lt;span id=&#34;And_everything_else&#34;&gt;And Everything Else&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;There are plenty of other things we can do with Plucene: use the metadata to restrict the search to particular chapters, for instance; filter out stop words with the &lt;code&gt;Plucene::Analysis::StopFilter&lt;/code&gt;; restrict the search to a series of dates, using the &lt;code&gt;Plucene::Document::DateSerializer&lt;/code&gt; module, and so on.&lt;/p&gt;

&lt;p&gt;Plucene is a general-purpose search engine; while the &lt;code&gt;Plucene::Simple&lt;/code&gt; interface to it allows you to get a good search tool up and running very quickly, that&amp;rsquo;s very much only the tip of the iceberg. By getting into the Plucene API itself, we can build a complex, customized search engine for any application.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introducing Mac::Glue</title>
      <link>http://localhost:1313/pub/2004/01/23/macglue.html/</link>
      <pubDate>Fri, 23 Jan 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/01/23/macglue.html/</guid>
      <description>

&lt;p&gt;Thanks to the popularity of Mac OS X, the new iBook, and the PowerBook G4, it&amp;rsquo;s no longer uncool to talk about owning an Apple. Longtime Mac devotees have now been joined by longtime Unix devotees and pretty much anyone who wants computers to be shiny, and speakers at conferences such as the &lt;a href=&#34;http://conferences.oreillynet.com/os2004/&#34;&gt;Open Source Convention&lt;/a&gt; are beginning to get used to looking down over a sea of Apple laptops.&lt;/p&gt;

&lt;p&gt;One of the great features about Apple&amp;rsquo;s Mac OS is its support for flexible inter-process communication (IPC), which Apple calls inter-application communication (IAC). One of the components of IAC is called Apple events, and allows applications to command each other to perform various tasks. On top of the raw Apple events layer, Apple has developed the &lt;strong&gt;Open Scripting Architecture&lt;/strong&gt;, an architecture for scripting languages such as Apple&amp;rsquo;s own AppleScript.&lt;/p&gt;

&lt;p&gt;But this is &lt;code&gt;perl.com&lt;/code&gt;, and we don&amp;rsquo;t need inferior scripting languages! The &lt;code&gt;Mac::Glue&lt;/code&gt; module provides OSA compatibility and allows us to talk to Mac applications with Perl code. Let&amp;rsquo;s take a look at how to script Mac tools at a high level in Perl.&lt;/p&gt;

&lt;h3 id=&#34;the-pre-history-of-mac-glue&#34;&gt;The Pre-History of &lt;code&gt;Mac::Glue&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;In the beginning, there was &lt;code&gt;Mac::AppleEvents&lt;/code&gt;. This module wrapped the raw Apple events API, with its cryptic four-character codes to describe applications and their capabilities, and its collection of awkward constants. You had to find out the four-character identifiers yourself, you had to manage and dispose of memory yourself, but at least it got you talking Apple events. Here&amp;rsquo;s some &lt;code&gt;Mac::AppleEvents&lt;/code&gt; code to open your System Folder in the Finder::&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Mac::AppleEvents;

my $evt = AEBuildAppleEvent(&#39;aevt&#39;, &#39;odoc&#39;, typeApplSignature, 
             &#39;MACS&#39;, kAutoGenerateReturnID, kAnyTransactionID,
             &amp;quot;&#39;----&#39;: obj{want:type(prop), from:&#39;null&#39;(),&amp;quot; .
                &amp;quot;form:prop, seld:type(macs)}&amp;quot;
          );
my $rep = AESend($evt, kAEWaitReply);

AEDisposeDesc($evt);
AEDisposeDesc($rep);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Obviously this isn&amp;rsquo;t putting the computer to its full use; in a high-level language like Perl, we shouldn&amp;rsquo;t have to concern ourselves with clearing up descriptors when they&amp;rsquo;re no longer in use, or providing low-level flags. We just want to send the message to the Finder. So along came &lt;code&gt;Mac::AppleEvents::Simple&lt;/code&gt;, which does more of the work:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Mac::AppleEvents::Simple;
do_event(qw(aevt odoc MACS),
     &amp;quot;&#39;----&#39;: obj{want:type(prop), from:&#39;null&#39;(),&amp;quot; .
     &amp;quot;form:prop, seld:type(macs)}&amp;quot;
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a bit better; at least we&amp;rsquo;re just talking the IAC language now, instead of having to emulate the raw API. But those troublesome identifiers &amp;ndash; &amp;ldquo;aevt&amp;rdquo; for the Finder, &amp;ldquo;odoc&amp;rdquo; to open a document, and &amp;ldquo;MACS&amp;rdquo; for the System folder.&lt;/p&gt;

&lt;p&gt;Maybe we&amp;rsquo;d be better off in AppleScript after all &amp;ndash; the AppleScript code for the same operation looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tell application &amp;quot;Finder&amp;quot; to open folder &amp;quot;System Folder&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And before &lt;code&gt;Mac::Glue&lt;/code&gt; was ported to Mac OS X, this is exactly what we had to do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Mac::AppleScript qw(RunAppleScript);
RunAppleScript(&#39;tell application &amp;quot;Finder&amp;quot; to open folder &amp;quot;System Folder&amp;quot;&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is considerably easier to understand, but it&amp;rsquo;s just not Perl. &lt;code&gt;Mac::Glue&lt;/code&gt; uses the same magic that allows AppleScript to use names instead of identifiers, but wraps it in Perl syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Mac::Glue;
my $finder = Mac::Glue-&amp;gt;new(&#39;Finder&#39;);
$finder-&amp;gt;open( $finder-&amp;gt;prop(&#39;System Folder&#39;) );
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;setting-up-and-creating-glues&#34;&gt;Setting Up and Creating Glues&lt;/h3&gt;

&lt;p&gt;On Mac OS 9, MacPerl comes with &lt;code&gt;Mac::Glue&lt;/code&gt;. However, OS X users will need to install it themselves. &lt;code&gt;Mac::Glue&lt;/code&gt; requires several other CPAN modules to be installed, including the &lt;code&gt;Mac-Carbon&lt;/code&gt; distribution.&lt;/p&gt;

&lt;p&gt;Because this in turn requires the Carbon headers to be available, you need to install the correct Apple developer kits; if you don&amp;rsquo;t have the Developer Tools installed already, you can download them from &lt;a href=&#34;https://connect.apple.com/&#34;&gt;the ADC site&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Once you have the correct headers installed, the best way to get &lt;code&gt;Mac::Glue&lt;/code&gt; up and running is through the CPAN or CPANPLUS modules:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% perl -MCPAN -e &#39;install &amp;quot;Mac::Glue&amp;quot;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This should download and install all the prerequisites and then the &lt;code&gt;Mac::Glue&lt;/code&gt; module itself.&lt;/p&gt;

&lt;p&gt;When it installs itself, &lt;code&gt;Mac::Glue&lt;/code&gt; also creates &amp;ldquo;glue&amp;rdquo; files for the core applications &amp;ndash; Finder, the System Events library, and so on. A glue file is used to describe the resources available to an application and what can be done to the properties that it has.&lt;/p&gt;

&lt;p&gt;If you try to use &lt;code&gt;Mac::Glue&lt;/code&gt; to control an application for which it doesn&amp;rsquo;t currently have a glue file, it will say something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;No application glue for &#39;JEDict&#39; found in 
&#39;/Library/Perl/5.8.1/Mac/Glue/glues&#39; at -e line 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To create glues for additional applications that are not installed by default, you can drop them onto the Mac OS 9 droplet &amp;ldquo;macglue.&amp;rdquo; On Mac OS X, run the &lt;code&gt;gluemac&lt;/code&gt; command.&lt;/p&gt;

&lt;h3 id=&#34;what-s-a-property&#34;&gt;What&amp;rsquo;s a Property?&lt;/h3&gt;

&lt;p&gt;Once you have all your glues set up, you can start scripting Mac applications in Perl. It helps if you already have some knowledge of how AppleScript works before doing this, because sometimes &lt;code&gt;Mac::Glue&lt;/code&gt; doesn&amp;rsquo;t behave the way you expect it to.&lt;/p&gt;

&lt;p&gt;For instance, we want to dump all the active to-do items from iCal. To-dos are associated with calendars, so first we need a list of all the calendars:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Mac::Glue;
my $ical = new Mac::Glue(&amp;quot;iCal&amp;quot;);

my @cals = $ical-&amp;gt;prop(&amp;quot;calendars&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem we face immediately is that &lt;code&gt;$ical-&amp;gt;prop(&amp;quot;calendars&amp;quot;)&lt;/code&gt; doesn&amp;rsquo;t give us the calendars. Instead, it gives us a way to talk about the calendars&amp;rsquo; property. It&amp;rsquo;s an object. To get the value of that property, we call its &lt;code&gt;get&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my @cals = $ical-&amp;gt;prop(&amp;quot;calendars&amp;quot;)-&amp;gt;get;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This returns a list of objects that allow us to talk about individual calendars. We can get their titles like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for my $cal (@cals) {
    my $name = $cal-&amp;gt;prop(&amp;quot;title&amp;quot;)-&amp;gt;get;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now we want to get the to-dos in each calendar that haven&amp;rsquo;t yet been completed or have no completion date:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @todos = grep { !$_-&amp;gt;prop(&amp;quot;completion_date&amp;quot;)-&amp;gt;get }
                       $cal-&amp;gt;prop(&amp;quot;todos&amp;quot;)-&amp;gt;get;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we then store the summary for each of the to-do items in a hash keyed by the calendar name:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $todos{$name} = [ map { $_-&amp;gt;prop(&amp;quot;summary&amp;quot;)-&amp;gt;get } @todos ]
    if @todos;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we can print out the summary of all the outstanding to-do items in each calendar:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for my $cal(keys %todo) {
    print &amp;quot;$cal:\n&amp;quot;;
    print &amp;quot;\t$_\n&amp;quot; for @{$todo{$cal}};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Putting it all together, the code looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Mac::Glue;
my $ical = new Mac::Glue(&amp;quot;iCal&amp;quot;);

my @cals = $ical-&amp;gt;prop(&amp;quot;calendars&amp;quot;)-&amp;gt;get;
for my $cal (@cals) {
    my $name = $cal-&amp;gt;prop(&amp;quot;title&amp;quot;)-&amp;gt;get;
    my @todos = map  { $_-&amp;gt;prop(&amp;quot;summary&amp;quot;)-&amp;gt;get }
                grep { !$_-&amp;gt;prop(&amp;quot;completion_date&amp;quot;)-&amp;gt;get }
                       $cal-&amp;gt;prop(&amp;quot;todos&amp;quot;)-&amp;gt;get;
    $todo{$name} = \@todos if @todos;
}

for my $cal(keys %todo) {
    print &amp;quot;$cal:\n&amp;quot;;
    print &amp;quot;\t$_\n&amp;quot; for @{$todo{$cal}};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The question is, where did we get the property names like &lt;code&gt;summary&lt;/code&gt; and &lt;code&gt;completion_date&lt;/code&gt; from? How did we know that the calendars had &lt;code&gt;titles&lt;/code&gt; but the to-do items had &lt;code&gt;summaries&lt;/code&gt;, and so on?&lt;/p&gt;

&lt;p&gt;There are two answers to this: the first is to use the documentation created when the glue is installed. Typing &lt;code&gt;gluedoc iCal&lt;/code&gt; on Mac OS X or using Shuck on Mac OS 9, you will find the verbs, properties, and objects that the application supports. For instance, under the calendar class, you should see:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This class represents a calendar&lt;/p&gt;

&lt;p&gt;Properties:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    description (wr12/utxt): This is the calendar
description. (read-only)
    inheritance (c@#^/item): All of the properties of the
superclass. (read-only)
    key (wr03/utxt): An unique calendar key (read-only)
    tint (wr04/utxt): The calendar color (read-only)
    title (wr02/utxt): This is the calendar title.
    writable (wr05/bool): If this calendar is writable
(read-only)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Elements:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    event, todo
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;This tells us that we can ask a calendar for its &lt;code&gt;title&lt;/code&gt; property, and also for the &lt;code&gt;events&lt;/code&gt; or &lt;code&gt;todos&lt;/code&gt; contained within it.&lt;/p&gt;

&lt;p&gt;Similarly, when we get the events back, we can look up the &amp;ldquo;event&amp;rdquo; class in the documentation and see what properties are available on it.&lt;/p&gt;

&lt;p&gt;The second, and perhaps easier, way to find out what you can do with an application is to open the AppleScript Script Editor application, select Open Dictionary from the File menu, and choose the application you want to script. Now you can browse a list of the classes and commands associated with the application:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2004_01_23_macglue/glue.jpg&#34; width=&#34;450&#34; height=&#34;343&#34; /&gt;
When you need to know how to translate those back into Perl, you can then consult the glue documentation. It takes a few attempts to get used to the way &lt;code&gt;Mac::Glue&lt;/code&gt; works, but once you&amp;rsquo;ve done that, you&amp;rsquo;ll find that you can translate between the AppleScript documentation and a &lt;code&gt;Mac::Glue&lt;/code&gt; equivalent in your head.&lt;/p&gt;

&lt;h3 id=&#34;some-examples&#34;&gt;Some Examples&lt;/h3&gt;

&lt;p&gt;In a couple of weeks, we&amp;rsquo;ll be presenting a &amp;ldquo;Mac::Glue Hacks&amp;rdquo; article in the spirit of the O&amp;rsquo;Reilly &lt;a href=&#34;http://hacks.oreilly.com&#34;&gt;hacks books&lt;/a&gt; series, with several simple &lt;code&gt;Mac::Glue&lt;/code&gt;-based application scripting tricks to whet your appetite and explore what &lt;code&gt;Mac::Glue&lt;/code&gt; can do. But to get you started, here&amp;rsquo;s a couple we found particularly useful.&lt;/p&gt;

&lt;p&gt;First, iTunes allows you to give a rating to your favorite songs, on the scale of zero to five stars. Actually, internally, this is stored in the iTunes database as a number between 0 and 100. Simon keeps iTunes playing randomly over his extensive music collection, and every time an interesting track comes up, he runs this script:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $itunes = Mac::Glue-&amp;gt;new(&amp;quot;iTunes&amp;quot;);
exit unless $itunes-&amp;gt;prop(&amp;quot;player state&amp;quot;)-&amp;gt;get eq &amp;quot;playing&amp;quot;;

my $rating = $itunes-&amp;gt;prop(&amp;quot;current track&amp;quot;)-&amp;gt;prop(&amp;quot;rating&amp;quot;);
$rating-&amp;gt;set(to =&amp;gt; ($rating-&amp;gt;get + 20))
  if $rating-&amp;gt;get &amp;lt; 81;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As well as getting properties from &lt;code&gt;Mac::Glue&lt;/code&gt;, we can also set them back with the &lt;code&gt;set&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;One more complex example is the &lt;a href=&#34;http://dev.macperl.org/files/scripts/happening&#34;&gt;happening&lt;/a&gt; script Chris uses to publish details of what&amp;rsquo;s going on at his computer. As well as simply reporting the current foremost application, it dispatches based on that application to report more information. For instance, if Safari has the focus, it reports what web page is being looked at; if it&amp;rsquo;s the Terminal, what program is currently being run. It also contacts iTunes to see what song is playing, and if there&amp;rsquo;s nothing playing on a local iTunes, asks likely other computers on the network if they&amp;rsquo;re playing anything.&lt;/p&gt;

&lt;p&gt;Once &lt;code&gt;happening&lt;/code&gt; has discovered what&amp;rsquo;s going on, it checks to see if the iChat status is set to &amp;ldquo;Available,&amp;rdquo; and if so, resets itself it to report this status. Let&amp;rsquo;s break down &lt;code&gt;happening&lt;/code&gt; and see how it accomplishes each of these tasks.&lt;/p&gt;

&lt;p&gt;First, to work out the name of the currently focused application:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $system = get_app(&#39;System Events&#39;) or return;
$app    ||= $system-&amp;gt;prop(name =&amp;gt; item =&amp;gt; 1,
    application_process =&amp;gt; whose(frontmost =&amp;gt; equals =&amp;gt; 1)
);

$app-&amp;gt;get;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;get_app&lt;/code&gt; is just a utility function that memorizes the process of calling &lt;code&gt;Mac::Glue-&amp;gt;new($app_name)&lt;/code&gt;; since loading up the glue file is quite expensive, keeping around application glue objects is a big speed-saving approach.&lt;/p&gt;

&lt;p&gt;The next incantation shows you how natural &lt;code&gt;Mac::Glue&lt;/code&gt; programming can look, but also how much you need to know about how the Apple environment works. We&amp;rsquo;re asking the System Events library to tell us about the application process that matches a certain condition. &lt;code&gt;Mac::Glue&lt;/code&gt; exports the &lt;code&gt;whose&lt;/code&gt; function to create conditions.&lt;/p&gt;

&lt;p&gt;The important thing about this is the fact that we use &lt;code&gt;$app ||= ...&lt;/code&gt;. The construction that we saved in &lt;code&gt;$app&lt;/code&gt; does not give us &amp;ldquo;the name of the front-most application at this moment,&amp;rdquo; but it represents the whole concept of &amp;ldquo;the name of the front-most application.&amp;rdquo; At any time in the future, we can call &lt;code&gt;get&lt;/code&gt; on it, and it will find out and return the name of the front-most application at that time, even if it has changed since the last time you called &lt;code&gt;get&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now that we know what the front-most application is, we can look it up in a hash that contains subroutines returning information specific to that application. For instance, here&amp;rsquo;s the entry for Safari:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Safari =&amp;gt; sub { my ($glue) = @_;
                my $obj = $glue-&amp;gt;prop(url =&amp;gt; document =&amp;gt; 1 =&amp;gt; window =&amp;gt; 1);
                my $url = $obj-&amp;gt;get;
                return URI-&amp;gt;new($url)-&amp;gt;host if $url;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This returns the host part of the URL in the first document in the first window. For &lt;code&gt;ircle&lt;/code&gt;, an IRC client, this code will get the channel and server name for the current connection:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ircle       =&amp;gt; sub { sprintf(&amp;quot;%s:%s&amp;quot;,
               $_[0]-&amp;gt;prop(&#39;currentchannel&#39;)-&amp;gt;get,
               $_[0]-&amp;gt;prop(servername =&amp;gt; connection =&amp;gt;
                   $_[0]-&amp;gt;prop(&#39;currentconnection&#39;)-&amp;gt;get
               )-&amp;gt;get
              )
            },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A decent default action is to return the window title:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;default     =&amp;gt; sub { my($glue) = @_;
                     my $obj = $objs{$glue-&amp;gt;{APPNAME}} ||=
                               $glue-&amp;gt;prop(name =&amp;gt; window =&amp;gt; 1);
                     $obj-&amp;gt;get;
                   },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As before, we cache the concept of &amp;ldquo;the name of the current window&amp;rdquo; and only create it when we don&amp;rsquo;t have one already.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s look at the &amp;ldquo;Now playing in iTunes&amp;rdquo; part:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$state  ||= $itunes-&amp;gt;prop(&#39;player state&#39;);
return unless $state-&amp;gt;get eq &amp;quot;playing&amp;quot;;

$track  ||= $itunes-&amp;gt;prop(&#39;current track&#39;);
%props    = map { $_ =&amp;gt; $track-&amp;gt;prop($_) } qw(name artist)
            unless keys %props;

my %info;
for my $prop (keys %props) {
    $info{$prop} = $props{$prop}-&amp;gt;get;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This first checks to see if iTunes is playing, and returns unless it is. Next, we look for the current track, and get handles to the name and artist properties of that track, as in our previous iTunes example.&lt;/p&gt;

&lt;p&gt;Finally, when we&amp;rsquo;ve set up all the handles we need, we call &lt;code&gt;get&lt;/code&gt; to turn them into real data. This populates &lt;code&gt;%info&lt;/code&gt; with the name and artist of the currently playing track.&lt;/p&gt;

&lt;p&gt;Now that we have the current application name, the extra information, and the current track, we can publish them as the iChat status, with this subroutine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Mac::Apps::Launch qw(IsRunning);

sub ichat {
    my($output) = @_;

    my $ichat = get_app(&#39;iChat&#39;) or return;
    return unless IsRunning($ichat-&amp;gt;{ID});

    $status  ||= $ichat-&amp;gt;prop(&#39;status&#39;);
    return unless $status-&amp;gt;get eq &#39;available&#39;;

    $message ||= $ichat-&amp;gt;prop(&#39;status message&#39;);
    $message-&amp;gt;set(to =&amp;gt; $output);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, we have the &lt;code&gt;IsRunning&lt;/code&gt; subroutine from &lt;code&gt;Mac::AppleEvents::Simple&lt;/code&gt;, which takes the old-style four-character ID of the application we want to ask about. The &lt;code&gt;ID&lt;/code&gt; slot of the glue object will tell us this ID, and so we can immediately give up setting the iChat status if iChat isn&amp;rsquo;t even running. Then we use &lt;code&gt;set&lt;/code&gt; as before to change the status to whatever we want.&lt;/p&gt;

&lt;p&gt;Finally, we mentioned that &lt;code&gt;happening&lt;/code&gt; can also ask other hosts what&amp;rsquo;s playing on their iTunes as well. This is because, if &amp;ldquo;Remote Apple Events&amp;rdquo; is turned on in the Sharing preferences, Macs support passing these Apple events between machines. Of course, this often requires authentication, so when it first contacts a host to send an Event, &lt;code&gt;happening&lt;/code&gt; will pop-up a login box to ask for credentials &amp;ndash; this is all handled internally by the operating system. Here&amp;rsquo;s the code that &lt;code&gt;happening&lt;/code&gt; actually uses:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $found = 0;
if (IsRunning($itunes-&amp;gt;{ID})) {
    $itunes-&amp;gt;ADDRESS;
    $found = 1 if $state-&amp;gt;get eq &#39;playing&#39;;
}

unless ($found) {
    for my $host (@hosts) {
        next unless $hosts{$host} + 60 &amp;lt; time();
        $itunes-&amp;gt;ADDRESS(eppc =&amp;gt; iTunes =&amp;gt; $host);
        $found = 1, last if $state-&amp;gt;get eq &#39;playing&#39;;
        $hosts{$host} = time();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first paragraph checks to see if iTunes is running locally. If so, we&amp;rsquo;re done. If not, we&amp;rsquo;re going to have to ask the hosts specified in the &lt;code&gt;@hosts&lt;/code&gt; array about it. The first and last lines inside the &lt;code&gt;for&lt;/code&gt; loop simple ensure that hosts are only tried every minute at most. The second line in there is the interesting one, though:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$itunes-&amp;gt;ADDRESS(eppc =&amp;gt; iTunes =&amp;gt; $host);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This changes the &lt;code&gt;iTunes&lt;/code&gt; glue handle from being a local one to being one that contacts the &amp;ldquo;iTunes&amp;rdquo; application on host &lt;code&gt;$host&lt;/code&gt; over EPPC, the remote Apple events transport.&lt;/p&gt;

&lt;p&gt;Because &lt;code&gt;$state&lt;/code&gt; is the player status of &lt;code&gt;$itunes&lt;/code&gt;, it will now return the correct status even though &lt;code&gt;$itunes&lt;/code&gt; now refers to an application on a different computer! Similarly, all the handles we have to the artist and name of the current track will correctly refer to &lt;code&gt;$itunes&lt;/code&gt;, no matter which iTunes instance that means.&lt;/p&gt;

&lt;p&gt;We hope you&amp;rsquo;ll join us next time for more &lt;code&gt;Mac::Glue&lt;/code&gt; tips and tricks, as we look at real-life applications of scripting Mac applications in Perl.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Blosxoms, Bryars and Blikis</title>
      <link>http://localhost:1313/pub/2003/12/18/bryar.html/</link>
      <pubDate>Thu, 18 Dec 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/12/18/bryar.html/</guid>
      <description>

&lt;p&gt;Recently we heard from Kake Pugh about the &lt;a href=&#34;http://localhost:1313/pub/2003/10/31/openguides.html&#34;&gt;OpenGuides project&lt;/a&gt;, a wiki-based collaborative city guide system; previously, we heard from Brian Ingerson about his Kwiki wiki implementation. Guides, wikis, blogs &amp;hellip; the new fashion in software engineering at the moment is the use of software to help organize, document, and facilitate collaboration &amp;ndash; the social software movement is gaining momentum, and Perl is one of the best languages for it.&lt;/p&gt;

&lt;p&gt;In this article we&amp;rsquo;ll look not just at some of the existing social software tools in Perl (focusing, naturally, on my own Bryar blog toolkit), but we&amp;rsquo;ll look at some ways to break, bend, and embed them in other tasks.&lt;/p&gt;

&lt;h3 id=&#34;span-id-basic-blogging-with-blosxom-basic-blogging-with-blosxom-span&#34;&gt;&lt;span id=&#34;Basic_Blogging_with_Blosxom&#34;&gt;Basic Blogging with Blosxom&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;When I finally decided that the world would benefit from hearing my internal monologue, I naturally looked around for nice, simple blogging programs. Blogs are, essentially, simple things, and so I didn&amp;rsquo;t want all-singing, all-dancing web-based database-backed content management systems. I knew that if I were going to blog, it would have to be easy for me to do so, and there&amp;rsquo;s nothing easier than firing up a text editor in the next available terminal window and doodling my thoughts into it.&lt;/p&gt;

&lt;p&gt;Thankfully, &lt;a href=&#34;http://www.raelity.org/&#34;&gt;Rael Dornfest&lt;/a&gt; has the same sort of laziness as I, and created &lt;a href=&#34;http://www.blosxom.com/&#34;&gt;Blosxom&lt;/a&gt;, a very simple blogging tool, which simply reads a bunch of files from the file system, finds the most recent and relevant, packages them up together, and sends them at a browser. That was how I saw blogging.&lt;/p&gt;

&lt;p&gt;Getting Blosxom up and running is, in keeping with the whole theme of Blosxom, quite simple. You need to download the &lt;a href=&#34;http://www.blosxom.com/downloads/blosxom.zip&#34;&gt;blosxom zip file&lt;/a&gt;, unpack it, drop the &lt;code&gt;blosxom.cgi&lt;/code&gt; file in your web server&amp;rsquo;s cgi-bin directory, and then edit the first few lines of it to tell it the name of your blog and where the entries will live, and you&amp;rsquo;re done.&lt;/p&gt;

&lt;p&gt;Posting into the blog is just a matter of creating a file called &lt;code&gt;something.txt&lt;/code&gt; in the blog directory. It doesn&amp;rsquo;t even matter what the &lt;code&gt;something&lt;/code&gt; is. All that matters is the first line of the file, which becomes the title, and the rest, which becomes the story in raw HTML:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;First post!

&amp;lt;p&amp;gt; Today I set up a blosxom blog. It was really easy! &amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can then, if you like, &lt;a href=&#34;http://www.blosxom.com/documentation/users/flavour.html&#34;&gt;style your blog&lt;/a&gt; with custom header and footer files, CSS, custom HTML for each blog post, and so on.&lt;/p&gt;

&lt;h3 id=&#34;span-id-enter-bryar-enter-bryar-span&#34;&gt;&lt;span id=&#34;Enter_Bryar&#34;&gt;Enter Bryar&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Of course, back when I started using Blosxom, things were not quite so easy, and templating required hacking the Blosxom CGI file itself, and things just didn&amp;rsquo;t seem as neat as I wanted them to be. I liked Blosxom&amp;rsquo;s simplicity, but didn&amp;rsquo;t want to pay the price for it in terms of flexibility.&lt;/p&gt;

&lt;p&gt;At the same time, I was learning the wonders of the &lt;a href=&#34;http://localhost:1313/pub/2001/01/tt2.html&#34;&gt;Template Toolkit&lt;/a&gt;, and thought that a well-designed blog should merely collect Post objects and send them to a user-defined template to do what it wants with them.&lt;/p&gt;

&lt;p&gt;So I started writing Bryar, which is designed to be a modular, extensible replacement for Blosxom. To make this happen, I needed to provide a default set of components that simply Does The Right Thing. Let&amp;rsquo;s take a look at that default set before we go any further.&lt;/p&gt;

&lt;p&gt;When we install Bryar from CPAN, we&amp;rsquo;re encouraged to run a command to set up a new blog:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;You probably want to run bryar-newblog in a likely home for
your blog once we&#39;ve finished installing.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;bryar-newblog&lt;/code&gt; command simply sets up a decent default set of templates, creates a first blog post, and drops in a &lt;code&gt;bryar.cgi&lt;/code&gt; driver, similar to &lt;code&gt;blosxom&lt;/code&gt;. At this point, we&amp;rsquo;re ready to go.&lt;/p&gt;

&lt;p&gt;Bryar&amp;rsquo;s default collection of modules consists of a &lt;code&gt;Bryar::DataSource::FlatFile&lt;/code&gt;, which emulates Blosxom&amp;rsquo;s use of text files in the file system as a database of blog posts; there are &lt;code&gt;Bryar::Frontend::CGI&lt;/code&gt; and &lt;code&gt;Bryar::Frontend::mod_perl&lt;/code&gt;, which describe how URL parameters are retrieved from the server translated into a request for documents, &lt;code&gt;Bryar::Document&lt;/code&gt; which represents each post, and &lt;code&gt;Bryar::Collector&lt;/code&gt; which ties it all together. With the benefit of hindsight, that should have been called a &lt;code&gt;Bryar::Controller&lt;/code&gt;, since the whole thing can be described as a Model-View-Controller application. But more on that later!&lt;/p&gt;

&lt;p&gt;Since all of these things can be overridden, we need something to keep track of which classes we&amp;rsquo;re using, and the &lt;code&gt;Bryar::Config&lt;/code&gt; class does that, reading an optional configuration file but otherwise providing mostly sensible defaults.&lt;/p&gt;

&lt;p&gt;In the rest of this article we&amp;rsquo;re going to look at some interesting ways to override those classes, and build some more funky tools out of this social software framework.&lt;/p&gt;

&lt;h3 id=&#34;span-id-blogging-the-past-blogging-the-past-span&#34;&gt;&lt;span id=&#34;Blogging_the_Past&#34;&gt;Blogging the Past&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Now it may surprise some people to find that I&amp;rsquo;m not really a programmer, although it may not come as a surprise to some of my colleagues.&lt;/p&gt;

&lt;p&gt;I was trained in modern and classical Japanese language and literature, with a side order of linguistics. Programming was a hobby that turned out to make a bit more cash than conjugating 10th century verbs.&lt;/p&gt;

&lt;p&gt;But as I began thinking a bit about blogging, I found an old Japanese diary of a lady-in-waiting to the Emperor, called the &amp;ldquo;Pillow Book&amp;rdquo;, by Sei Shonagon. It was something I&amp;rsquo;d read before and found quite interesting, but picking it up again in a blog context put it in a completely new light. It read just like a 10th century LiveJournal.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a sample entry:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Small children and babies should be fat. Provincial governors should be fat too, and other people who have done well for themselves. If they&amp;rsquo;re too thin, it makes you think they&amp;rsquo;re miserable.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As well as thoughts, observations, tales of life at the court, the book contains a large number of random lists, which really made me think of LiveJournal polls and surveys. Here&amp;rsquo;s another example:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Things I think are elegant&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A white coat over a violet waistcoat&lt;/li&gt;
&lt;li&gt;Duck&amp;rsquo;s eggs&lt;/li&gt;
&lt;li&gt;Sherbet ice, liana syrup, in a nice new silver bowl&lt;/li&gt;
&lt;li&gt;Rock crystal&lt;/li&gt;
&lt;li&gt;Wisteria&lt;/li&gt;
&lt;li&gt;Snow on plum blossoms&lt;/li&gt;
&lt;li&gt;A pretty little girl eating strawberries&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;I decided that it would be quite fun to translate the blog &amp;ndash; uh, book &amp;ndash; in a fairly modern, relaxed style, use fictitious but plausible dates for the entries, and run it as a real blog.&lt;/p&gt;

&lt;p&gt;Naturally, I wanted to do this with Bryar, but there was going to be a slight problem; Bryar takes its entry dates from the Unix timestamp of the file, and try as I might, I could not persuade Unix to recognize epoch times a thousand years before the epoch. I had to find another way of getting the times.&lt;/p&gt;

&lt;p&gt;But since Bryar is extensible, this is really easy &amp;ndash; I just write a new data source class that gets the entry timestamp from somewhere else. I simply created a subclass of &lt;code&gt;Bryar::DataSource::FlatFile&lt;/code&gt; called &lt;code&gt;...FlatFile::Dated&lt;/code&gt;, which takes its date from the first line, and title from the next line.&lt;/p&gt;

&lt;p&gt;Telling the Bryar blog to use the new data source was simply a matter of writing a little config file called &lt;code&gt;bryar.conf&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source: Bryar::DataSource::FlatFile::Dated
name: Notes on a Pillow - Sei Shonagon&#39;s blog
baseurl: http://blog.simon-cozens.org/shonagon/bryar.cgi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the rest, of course, is just a simple matter of classical Japanese translation.&lt;/p&gt;

&lt;h3 id=&#34;span-id-blogging-the-house-blogging-the-house-span&#34;&gt;&lt;span id=&#34;Blogging_the_House&#34;&gt;Blogging the House&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;But as well as a linguist, I&amp;rsquo;m also a geek, and I use Perl to control various things around the house &amp;ndash; the house network, the division of the phone bill, and so on. This is all driven by Template Toolkit and &lt;a href=&#34;http://localhost:1313/pub/2002/11/27/classdbi.html&#34;&gt;&lt;code&gt;Class::DBI&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It seemed useful, at the time, to add a blog into this great mass of centralized control, so we could pass phone messages around. Of course, in the end, it was easier to just put a big whiteboard in the lounge. XP&amp;rsquo;s &amp;ldquo;the simplest thing that could possibly work&amp;rdquo; wins again.&lt;/p&gt;

&lt;p&gt;But it was fun, and it allowed me to use Bryar in a new way. This time, we&amp;rsquo;re using the original data source, collector, and other modules, but we&amp;rsquo;re plugging them into an existing templating system. We already have code to deal with the web server, handle the URL processing, and the output; we already have code to transform objects into HTML; all we need is to collect the recent documents and hand them on to the templates.&lt;/p&gt;

&lt;p&gt;I did this by adding a Bryar object to our template variables, and calling the &lt;code&gt;collect_current&lt;/code&gt; method on the Bryar collector, using Richard Clamp&amp;rsquo;s &lt;code&gt;Template::Plugin::Class&lt;/code&gt; module. This gave a bunch of &lt;code&gt;Bryar::Documents&lt;/code&gt;, which the template system could manipulate however it desired:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[% INCLUDE header %]
[% PROCESS blogmacros %]

&amp;lt;h2&amp;gt; Recent blog postings&amp;lt;/h2&amp;gt;

[%
USE c = Class(&amp;quot;Bryar::Collector&amp;quot;);
FOR post = c.collect_current(blog);
    display_post(post);
END;
%]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-everything-s-a-wiki-everything-s-a-wiki-span&#34;&gt;&lt;span id=&#34;Everything&#39;s_a_wiki&#34;&gt;Everything&amp;rsquo;s a Wiki&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;So much for blogs, for the time being. The other movement in social software at the moment is Ward Cunningham&amp;rsquo;s wiki. A wiki has three important characteristics: a simple mark-up language, the ability for the viewer to modify the page, and the ability to create links from one wiki page to another.&lt;/p&gt;

&lt;p&gt;Despite initial predictions that they&amp;rsquo;d be unusable due to widespread graffiti, vandalism, and other kinds of kicking down the sandcastle, wikis have turned out to work quite well in practice, with sites like &lt;a href=&#34;http://www.wikipedia.com/&#34;&gt;Wikipedia&lt;/a&gt; collecting a great store of information from contributors both regular and occasional.&lt;/p&gt;

&lt;p&gt;CPAN has a fair collection of wiki implementations, including Kwiki, &lt;a href=&#34;https://metacpan.org/pod/CGI::Wiki&#34;&gt;CGI::Wiki&lt;/a&gt;, &lt;a href=&#34;https://metacpan.org/pod/Apache::MiniWiki&#34;&gt;Apache::MiniWiki&lt;/a&gt;, and others. However, there may well be times when it makes sense to create a new implementation, particularly when the wiki is to be embedded in another application.&lt;/p&gt;

&lt;p&gt;What does it mean to embed a wiki? An example will demonstrate it best. Imagine a web-mail system like IMP or SquirrelMail. Now we want to add the ability to write a short note or annotation on a given message, so that it can be referred back to later. If I get a mail from my friend Al arranging to meet up for a drink at the pub, I&amp;rsquo;d want to annotate the mail with Al&amp;rsquo;s mobile phone number, directions to the pub, and the fact that I need to take the book that I borrowed from him last month. Then, in an ideal world, the mail system would collect all the notes, work out the date and time of the meeting, and tell my calendaring software about it, but that&amp;rsquo;s another story for a different time.&lt;/p&gt;

&lt;p&gt;The fact is that once we have these sticky notes for mail, we might want to use them to refer to other mail, group them together in fluid topics, and so on. For instance, if I mentioned in the annotation that this was an &lt;code&gt;AlMeeting&lt;/code&gt;, I would expect that text to be magically marked up as a link to all the other &lt;code&gt;AlMeeting&lt;/code&gt; mails. Here we&amp;rsquo;ve got the three elements of a wiki &amp;ndash; annotation editing, a simple markup language, and the ability to link.&lt;/p&gt;

&lt;p&gt;While the editing is a simple matter of linking your CGI parameters with your database, something that should be second nature to those who want to &lt;a href=&#34;http://localhost:1313/pub/2003/07/15/nocode.html&#34;&gt;avoid writing code&lt;/a&gt;, the other two components take a little bit of work. Thankfully, chromatic has written a handy module, &lt;a href=&#34;https://metacpan.org/pod/Text::WikiFormat&#34;&gt;Text::WikiFormat&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;With &lt;code&gt;WikiFormat&lt;/code&gt;, you can pass a text string marked up in wiki format to &lt;code&gt;Text::WikiFormat::format&lt;/code&gt;, and it will return you HTML:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print Text::WikiFormat::format(&amp;lt;&amp;lt;EOF);
= A Test Post =

I found this &#39;&#39;&#39;very&#39;&#39;&#39; interesting WikiLink recently.

EOF

__DATA__
&amp;lt;h1&amp;gt;A Test Post&amp;lt;/h1&amp;gt;

&amp;lt;p&amp;gt; &amp;lt;br /&amp;gt;
I found this &amp;lt;strong&amp;gt;very&amp;lt;/strong&amp;gt; interesting
&amp;lt;a href=&amp;quot;WikiLink&amp;quot;&amp;gt;WikiLink&amp;lt;/a&amp;gt; recently. &amp;lt;br /&amp;gt;
  &amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This gives us the simple markup, but it doesn&amp;rsquo;t do much about the linkability; for an embedded wiki, we&amp;rsquo;re going to need finer-grained control over how the links are constructed. For instance, we might want to pass the link name to a particular URL with a particular CGI parameter. Thankfully, &lt;code&gt;Text::WikiFormat&lt;/code&gt; supports two optional parameters in addition to the text to be formatted: the first is a hash reference overriding how the wiki text is marked up to HTML, and the second is a hash reference of options, such as the URL prefix for links.&lt;/p&gt;

&lt;p&gt;So, if we have an application that displays a page given a parameter in the URL, we can just say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Text::WikiFormat::format($text, {},
        { prefix =&amp;gt; &amp;quot;http://www.myhost.int/wiki?page=&amp;quot; });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And there we have it, an instant wiki.&lt;/p&gt;

&lt;p&gt;Of course, in the context of our webmail application, we may have to do something more convoluted. For instance, we might want a link to &lt;code&gt;SimonCozens&lt;/code&gt; to resolve to all mail from that person, if it can be understood as a person who sends email, or to a similarly marked-up set of messages, like an &lt;code&gt;AlMeeting&lt;/code&gt;, if it can&amp;rsquo;t. For this, we need to introduce a bit of logic and decide how to form the link.&lt;/p&gt;

&lt;p&gt;As we mentioned above, &lt;code&gt;Text::WikiFormat&lt;/code&gt; allows us to specify replacements for the way markup is translated to HTML. &lt;code&gt;WikiFormat&lt;/code&gt; uses a hash-ref internally to turn wiki &amp;ldquo;tags&amp;rdquo; into HTML, and we can, in fact, put in a subroutine reference for the &lt;code&gt;link&lt;/code&gt; tag and have that emit the appropriate HTML link.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub markup {
    my $text = shift;
    Text::WikiFormat::format(shift, { link =&amp;gt; \&amp;amp;my_link });
}

sub my_link {
    my $linkname = shift;
    my $name = $linkname;
    ($name=$linkname) =~ s/(?&amp;lt;=[a-z])(?=[A-Z])/ /g;
    if (have_mail_from($name)) {
       # Valid correspondent, link to page of their mail
       my $id = correspondent_id($name);
       return qq{&amp;lt;A HREF=&amp;quot;/mail/search?correspondent=$id&amp;quot;&amp;gt;}.$name.
              &amp;quot;&amp;lt;/A&amp;gt;&amp;quot;;
    }
    # Not a correspondent, just a wiki page
    return qq{&amp;lt;A HREF=&amp;quot;/wiki?$linkname&amp;quot;&amp;gt;}.$linkname.
           &amp;quot;&amp;lt;/A&amp;gt;&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What&amp;rsquo;s going on here? First, we receive the link name in StudlyCaps every time &lt;code&gt;format&lt;/code&gt; sees a link. We then convert it to a real name, by inserting a space in the gaps between a lowercase character and an uppercase one. Now we have a name like &amp;ldquo;Simon Cozens&amp;rdquo; that we can search our mailstore for, and if we find someone, we can return the URL to a page about their mail. Otherwise, we return a wiki page. We&amp;rsquo;ve used our webmail annotations to refer to either real people or to other annotations, stealthily embedding a wiki in the application, with minimal effort.&lt;/p&gt;

&lt;h3 id=&#34;span-id-creating-the-bliki-creating-the-bliki-span&#34;&gt;&lt;span id=&#34;Creating_the_Bliki&#34;&gt;Creating the Bliki&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;With that example of how to create a custom wiki from an existing application, let&amp;rsquo;s return to Bryar and our blogging software.&lt;/p&gt;

&lt;p&gt;The concept of a bliki &amp;ndash; a cross between a wiki and a blog &amp;ndash; may seem like a bizarre one at first, but it&amp;rsquo;s such a natural synergy that it&amp;rsquo;s been independently invented by multiple people, including &lt;a href=&#34;http://www.martinfowler.com/bliki/WhatIsaBliki.html&#34;&gt;Martin Fowler&lt;/a&gt; and &lt;a href=&#34;http://www.rollerweblogger.org/page/roller/20020906&#34;&gt;many others&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Depending on how you look at it, a bliki is either an ordinary wiki with a blog-style front-end showing the latest posts, or an ordinary blog with wiki-like markup and interconnections between the posts. The only difference between these views is how easy it is to edit the posts. We&amp;rsquo;ll stick with the &amp;ldquo;ordinary blog&amp;rdquo; viewpoint, since editing posts over the Web is a boring and solved problem, and one not really related to the technology we&amp;rsquo;re looking at today.&lt;/p&gt;

&lt;p&gt;How are we going to extend Bryar to become a bliki? It&amp;rsquo;s obvious that &lt;code&gt;Text::WikiFormat&lt;/code&gt; is going to be involved somewhere, and it would be helpful to use the &lt;code&gt;Bryar::DataSource::FlatFile&lt;/code&gt; class too. First, we inherit from the &lt;code&gt;FlatFile&lt;/code&gt; class, and override the &lt;code&gt;make_document&lt;/code&gt; method, which is responsible for turning a filename into a &lt;code&gt;Bryar::Document&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package Bryar::DataSource::FlatFile::Bliki;
use base &#39;Bryar::DataSource::FlatFile&#39;;
use strict;
use Text::WikiFormat;

sub make_document {
    my ($self, $filename) = @_;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here the format will be slightly different &amp;ndash; the filename (such as &amp;ldquo;&lt;code&gt;MyWikiPost.txt&lt;/code&gt;&amp;rdquo;) will be used to form both the title and the ID of the document, and the content of the document will be transformed via &lt;code&gt;WikiFormatter&lt;/code&gt; wholesale.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub make_document {
    my ($self, $file) = @_;
    return unless $file and open my $in, $file;
    my $when = (stat $file)[9];
    my $who = getpwuid((stat $file)[4]);
    $file =~ s/\.txt$//;

    my $dir = dirname($file);
    $dir =~ s{^\./?}{};
    my $category = $dir || &amp;quot;main&amp;quot;;

    local $/;
    my $text = &amp;lt;$in&amp;gt;;

    return Bryar::Document-&amp;gt;new(
        title    =&amp;gt; $file,
        content  =&amp;gt; Text::WikiFormat::format($text, {}, {prefix =&amp;gt; &amp;quot;id_&amp;quot;}),
        epoch    =&amp;gt; $when,
        author   =&amp;gt; $who,
        id       =&amp;gt; $file,
        category =&amp;gt; $category,
    );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We change the prefix for links to be a relative link of the form &lt;code&gt;id_PostName&lt;/code&gt;, since this is how Bryar deals with references to other blog posts, by default. (Of course, we could change this by modifying the FrontEnd class, but this seems to work fine.)&lt;/p&gt;

&lt;p&gt;It took 30 lines of code to convert Bryar into a simple bliki, many of which were stolen from the superclass. Now let&amp;rsquo;s look at something a bit different.&lt;/p&gt;

&lt;h3 id=&#34;everything-s-a-blog&#34;&gt;Everything&amp;rsquo;s a Blog&lt;/h3&gt;

&lt;p&gt;I mentioned when introducing Bryar that it was based on the Model-View-Controller (MVC) pattern, although I didn&amp;rsquo;t realize this while designing it.&lt;/p&gt;

&lt;p&gt;The MVC pattern is described in &lt;a href=&#34;http://c2.com/cgi-bin/wiki?ModelViewController&#34;&gt;this entry&lt;/a&gt; in Ward Cunningham&amp;rsquo;s own wiki, as being made up of three parts:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;strong&gt;model&lt;/strong&gt;, therefore is an object representing data or even activity, e.g. a database table or even some plant-floor production-machine process.&lt;/li&gt;
&lt;li&gt;A &lt;strong&gt;view&lt;/strong&gt; is some form of visualization of the state of the model.&lt;/li&gt;
&lt;li&gt;A &lt;strong&gt;controller&lt;/strong&gt; offers facilities to change the state of the model.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;All kinds of things follow the MVC design. In Bryar, the model is the data source object; the view is the templating object; the controller is the Collector object. A web browser might be described as a controller that contains all its logic, a view which contains the user interface, and the pane of rendered HTML, and the model of the entire Worldwide Web.&lt;/p&gt;

&lt;p&gt;But some web-based applications follow Bryar&amp;rsquo;s MVC approach particularly closely. Imagine, for instance, a company&amp;rsquo;s product catalog on the Web. The catalog data will be stored in some kind of database, and will be presented via a templating system, with a controller that will decide which products to show. Isn&amp;rsquo;t that exactly the same as reading some blog posts from a database (albeit potentially one that looks a lot like a filesystem), rendering them via templating system, with a controller deciding which posts to show?&lt;/p&gt;

&lt;p&gt;Indeed, many of the views you will want of the catalog data are exactly what you&amp;rsquo;d want from a blog: display the most recent products, display all products, search by product name or description, and a detailed display of a single product.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ve seen it take 30 lines to turn a blog into a bliki. To turn a blog into a complete product catalog web site takes a subclass of the &lt;code&gt;Bryar::DataSource::DBI&lt;/code&gt; class (to talk to the product database) and the &lt;code&gt;Bryar::Document&lt;/code&gt; class (to take more details, a URL to a photo, and so on). The rest is a matter of templating, and that&amp;rsquo;s a designer&amp;rsquo;s job!&lt;/p&gt;

&lt;h3 id=&#34;social-software&#34;&gt;Social Software&lt;/h3&gt;

&lt;p&gt;I consider the emergence of interest in social software to be one of the most fascinating trends in software engineering this year. Two of the most powerful and popular aspects of this, wikis and blogs, are particularly well-suited for extension and embedding, and Perl is a particularly well-suited language for achieving this.&lt;/p&gt;

&lt;p&gt;Although part of the point of this article was to demonstrate Bryar, there were several other important points. First, that there are plenty of Perl implementations of both wikis and blogs that you can choose from; second, that Perl makes it really easy to create your own blog or wiki and customize to your own purposes, including embedding them in an existing application.&lt;/p&gt;

&lt;p&gt;But finally, the point was to encourage you to think about good design and the power of extensible applications; if you can create a tool that is both powerful and generalizable &amp;ndash; just like Perl itself &amp;ndash; it may end up doing wildly different things to what you initially intended!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How Perl Powers the Squeezebox</title>
      <link>http://localhost:1313/pub/2003/12/05/slimp3.html/</link>
      <pubDate>Fri, 05 Dec 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/12/05/slimp3.html/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.slimdevices.com/&#34;&gt;Slim Devices&lt;/a&gt; made their name in 2001 with the SLIMP3, a networked MP3 and Internet radio player. The SLIMP3 won a five-out-of-five mouse rating in &lt;em&gt;Macworld&lt;/em&gt; magazine, and was featured in &lt;em&gt;GQ&lt;/em&gt; magazine and on TechTV&amp;rsquo;s &lt;em&gt;The Screen Savers&lt;/em&gt;. This year, they&amp;rsquo;re trying to repeat the success with Squeezebox, an 802.11-enabled version.&lt;/p&gt;

&lt;p&gt;The interesting thing about the SLIMP3 and the Squeezebox from our point of view, though, is that the server which drives the player is written in Perl, and developers are allowed &amp;ndash; in fact, encouraged &amp;ndash; to hack on it and make the devices do interesting things. A &lt;a href=&#34;http://www.slimdevices.com/dev_overview.html&#34;&gt;developer community&lt;/a&gt; has sprung up around the SLIMP3, and some &lt;a href=&#34;http://www.slimdevices.com/dev_third_party.html&#34;&gt;interesting third-party hacks&lt;/a&gt; have been produced.&lt;/p&gt;

&lt;p&gt;We caught up with Dean Blackketter from Slim Devices, who took some time out from moving Squeezeboxes to answer a few of our questions.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;perl.com: What made you decide, first of all, to write the server code in Perl?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Dean&lt;/strong&gt;: Sean [Adams, Slim Devices founder] wrote the very first version of the software in Perl because he was able to get it up and running quickly. When I first encountered Sean and SLIMP3, I was a little afraid of Perl, having been primarily a C and C++ programmer, mostly because when I tried to read it, I got confused by idiomatic usage.&lt;/p&gt;

&lt;p&gt;I first decided to rewrite the thing in C, but I couldn&amp;rsquo;t really get started until I could read the existing code. So I bought a copy of &lt;em&gt;Learning Perl&lt;/em&gt; and read it in two evenings. Halfway through the first chapter something clicked and I said, &amp;ldquo;That&amp;rsquo;s so cool!&amp;rdquo; Then, about every 10 pages after I&amp;rsquo;d repeat, &amp;ldquo;That&amp;rsquo;s so cool!&amp;rdquo; again, but a little louder. By the end, I was sold. At that point I dug in and started making the software better.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What features of Perl were particularly helpful when you were writing the SlimServer?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The greatest feature of Perl, for us, is that so many people know it. Since our software is open source, we benefit from as many users as possible being able to read and improve our code base. Anybody who&amp;rsquo;s thrown together a little Perl CGI or script is a potential contributor to our software.&lt;/p&gt;

&lt;p&gt;Second, the ability for us to offer our software on a wide array of platforms (Mac OS X, Windows 98/ME/NT/2000/XP, BSD, Linux, Solaris) and also be deployed on server appliances makes it possible for us to get our product running as broadly as possible.&lt;/p&gt;

&lt;p&gt;Third, even though our product&amp;rsquo;s primary feature is playing back audio, the bulk of the software really is processing text. Our built-in HTTP server, command-line interface, device-user interface, and even music meta-information is all text-based, and Perl is nearly the perfect language for this.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What issues did you have to face when considering how to distribute a Perl-based consumer application, and how did you approach them?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Distributing a Perl application on the traditional Unix-like platforms (BSD, Solaris, Linux) is easy. Things got a bit harder on Mac OS X, since command-line solutions aren&amp;rsquo;t acceptable to Mac users. Initially, I wrote a simple graphical application (in AppleScript!) that acted as a launcher for our server software, but this was really not good enough for Mac users. One of our Open Source contributors, Dave Nanian, came to the rescue and built us a System Preferences pane and installer application that work as they should on a Mac.&lt;/p&gt;

&lt;p&gt;Windows is the hardest platform for us to support. Luckily we had another Open Source contributor, Sam Saffron, who decided that building a shell application for the server software would be a great way to learn MFC, and he contributed a nice little app for this. Another contributor, Chris Eastwood, put together an installer for us. But it was the fine folks at &lt;a href=&#34;http://www.activestate.com/&#34;&gt;ActiveState&lt;/a&gt; with their &lt;a href=&#34;http://www.activestate.com/Products/Perl_Dev_Kit/&#34;&gt;Perl Dev Kit&lt;/a&gt; that really made it possible for us to release on Windows with their PerlApp (for making Perl-based .exe files) and PerlSvc (for making Perl-based Windows Services).&lt;/p&gt;

&lt;p&gt;Even with all this help, Perl on Windows is different enough in subtle ways to make it a real pain to maintain. Maybe if we had more hardcore in-house Windows experience things would be easier, but it&amp;rsquo;s a struggle.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;For consumer devices like the SLIMP3, the manufacturer has a choice between open and hackable, and &amp;ldquo;sealed box.&amp;rdquo; You guys went for the hackable approach, GPLing the code and setting up developers&amp;rsquo; forums. What was the rationale behind that?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;When I got into this, the total of my Open Source experience was running a Linux server in my basement. Sean initially released the SLIMP3 software under the GPL, which made it possible for me to help out. I quickly realized that our customers have a lot of talent and energy that they are willing to contribute to make the product better. We&amp;rsquo;re lucky to have a business model where we can make money on the hardware and give the software away. When our customers contribute, they make their own SLIMP3s (and now Squeezeboxes) more valuable to themselves and make the new units we sell to new customers more valuable as well. Everybody wins.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How did you go about building a developer community behind the SlimServer project?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I like to think that the community built itself. We provided a forum (our discussion lists) and Sean and I participate on a daily basis; acting on the requests, suggestions, bug reports, and patches that people post. We&amp;rsquo;re spending more effort lately setting up our own list server and CVS system, as we had problems with our previous forums (Yahoo Groups and SourceForge, respectively), but these will give us a little more control of our virtual spaces.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How do you decide which developer extensions to keep as third-party projects and which to integrate?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If a contribution will make the product better for a substantial portion of our customers and won&amp;rsquo;t make the product worse for any of them, then, generally speaking, it&amp;rsquo;s included. Submitted features that make the software harder or less intuitive to use, require obscure or platform-specific software or hardware to be installed, generally don&amp;rsquo;t make it in. Contributions that are useful to a large fraction of our customers and don&amp;rsquo;t diminish the product&amp;rsquo;s ability to play back music, make it in.&lt;/p&gt;

&lt;p&gt;I act as final arbiter and (hopefully) benevolent dictator, and the community has been really supportive of this.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Finally, we notice that you&amp;rsquo;ve decided to donate 10 percent of your profits to the EFF. What&amp;rsquo;s the motivation behind this?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Digital freedoms are important to the folks at Slim Devices, both personally and at a corporate level. We&amp;rsquo;ve been frustrated by not being able to offer our customers the ability to play the music that they&amp;rsquo;ve bought due to digital rights management systems and onerous licensing fees for various patents. The EFF shares our goal to free our customers&amp;rsquo; music.&lt;/p&gt;

&lt;p&gt;The Squeezebox is available from &lt;a href=&#34;http://www.slimdevices.com/&#34;&gt;Slim Devices&lt;/a&gt; and their resellers, and the server code can be downloaded from their &lt;a href=&#34;http://www.slimdevices.com/su_downloads.html&#34;&gt;downloads site&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Database Programming with Perl</title>
      <link>http://localhost:1313/pub/2003/10/23/databases.html/</link>
      <pubDate>Thu, 23 Oct 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/10/23/databases.html/</guid>
      <description>

&lt;h3 id=&#34;span-id-an-embarrassing-confession-an-embarrassing-confession-span&#34;&gt;&lt;span id=&#34;an_embarrassing_confession&#34;&gt;An Embarrassing Confession&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;d like to think that I&amp;rsquo;m a reasonably decent Perl programmer now. I&amp;rsquo;d like to think that I have a good grasp of how to solve relatively common problems in Perl. But, you know, it hasn&amp;rsquo;t always been this way. Oh no.&lt;/p&gt;

&lt;p&gt;A long, long time ago, when I was a tiny little programmer, I worked as a trainee Perl coder and systems administrator for a large database company. Naturally, at a database company, a lot of what we had to do was talking to databases in Perl. As a fresh-faced programmer, the only way I knew to interface with databases was through a command-line SQL client.&lt;/p&gt;

&lt;p&gt;I won&amp;rsquo;t embarrass the company in question by giving away the name of the database, so let&amp;rsquo;s call this SQL client &lt;code&gt;sqlstar&lt;/code&gt;. Very soon I was writing horrendous Perl programs that did things like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @rows = `sqlstar $database &amp;quot;select * from $table&amp;quot;`;
    for (@rows) {
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, things got terribly confused when we had complex &lt;code&gt;where&lt;/code&gt; clauses, and needed to escape metacharacters, and &amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @rows = `sqlstar $database &amp;quot;select * from $table where
        $row LIKE \&amp;quot;%pattern%\&amp;quot;&amp;quot;`;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code rapidly got ugly, error-prone, and dangerously unsafe. If someone had decided to search for a value with a double quote in it, I don&amp;rsquo;t know where we&amp;rsquo;d have been. But for the most part it worked, so nobody really worried about it.&lt;/p&gt;

&lt;p&gt;Looking back on programs like that makes me cringe today. Of course, a better solution is obvious &amp;ndash; but only once someone tells you about it. And if nobody tells you about it, you could end up writing horrible code like this until someone does tell you or you get fired.&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-obvious-solution-the-obvious-solution-span&#34;&gt;&lt;span id=&#34;the_obvious_solution&#34;&gt;The Obvious Solution&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;So in case anyone hasn&amp;rsquo;t told you yet: there&amp;rsquo;s a better way. The better way is called the &lt;a href=&#34;http://dbi.perl.org/&#34;&gt;DBI&lt;/a&gt;, the DataBase Interface module. It was initially written between 1992 and 1994, long before I was messing about with &lt;code&gt;sqlstar&lt;/code&gt; &amp;ndash; so I really have no excuse.&lt;/p&gt;

&lt;p&gt;You see, there were many problems with my code. Not only was it ugly, susceptible to shell breakage, conceptually wrong, and inefficient, but it tied my code to the particular database engine we were using. Now, given we were a database company, it&amp;rsquo;s unlikely that we&amp;rsquo;d ever be using a different database at anytime, but the principle of the thing remains.&lt;/p&gt;

&lt;p&gt;Historically, Perl had several different ways to talk to databases; back in the days of Perl 4, the best way to communicate with a database &amp;ndash; even better than my horrible command-line utility hack &amp;ndash; was to use one of the specially compiled Perl binaries that included functions for driving a database. For instance, there was one called &lt;code&gt;oraperl&lt;/code&gt;, which allowed you to write code like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$lda = &amp;amp;ora_login(&amp;quot;master&amp;quot;, $user, $pass);
$csr = &amp;amp;ora_open($lda, &amp;quot;select * from $table&amp;quot;);
while (@data = &amp;amp;ora_fetch($csr)) {
    # ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is obviously a bit of an improvement over the code I was writing &amp;ndash; it&amp;rsquo;s a lot more robust, it allows you to do error checking on several different levels, and it saves you a lot of hassle parsing the output of the command-line tool. It&amp;rsquo;s also more efficient, since everything stays inside the one Perl process, which again reduces the number of &amp;ldquo;moving parts&amp;rdquo; and things that can go wrong.&lt;/p&gt;

&lt;p&gt;So these things were a good solution for Perl 4, but along came Perl 5 and plug-in modules, and suddenly people found a way to solve one of the big problems with these compiled-in database libraries.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ve just seen an example of &lt;code&gt;oraperl&lt;/code&gt;, which works great if you&amp;rsquo;re using Oracle &amp;ndash; and, of course, the version of Oracle your Perl was compiled for. If you decide to move your program to Informix, you don&amp;rsquo;t have much option than to rewrite all your database code; this isn&amp;rsquo;t very practical, especially if you want to write code that can be deployed to third parties.&lt;/p&gt;

&lt;p&gt;The Perl 5 solution was Tim Bunce&amp;rsquo;s DBI. As well as providing a handy set of functions for all kinds of database access, DBI provides an abstraction layer between the Perl code and the underlying database, allowing you to switch database implementations really easily.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a little conceptual diagram of how the DBI does its stuff:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://dbi.perl.org/images/dbiarch.gif&#34; alt=&#34;&#34; /&gt;
Your Perl program talks to the DBI, and the DBI talks to whichever Database Driver (DBD) is right for your backend database. This means that to use the DBI, you need to have four things:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A C compiler to compile the XS code for DBI and the DBD drivers.&lt;/li&gt;
&lt;li&gt;A copy of the &lt;code&gt;DBI&lt;/code&gt; module compiled and installed.&lt;/li&gt;
&lt;li&gt;A copy of the relevant client libraries and header files for the database you want to talk to. For instance, on my Debian system, to talk to mysql, I install the &lt;code&gt;libmysqlclient10-dev&lt;/code&gt; package.&lt;/li&gt;
&lt;li&gt;The relevant DBD library compiled and installed &amp;ndash; for example, &lt;code&gt;DBD::MySQL&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once that&amp;rsquo;s all up and working, we can start writing some database code using the DBI.&lt;/p&gt;

&lt;h3 id=&#34;span-id-using-the-dbi-using-the-dbi-span&#34;&gt;&lt;span id=&#34;using_the_dbi&#34;&gt;Using the DBI&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;To connect to a database with the DBI, we need to first construct a string that identifies the database we want to connect to; this is called a data source name, or DSN. Let&amp;rsquo;s assume we&amp;rsquo;re going to be working with a MySQL database called &amp;ldquo;phonebill.&amp;rdquo; (Simply because that&amp;rsquo;s what I was working with yesterday.) The DSN for this is made up of three parts, joined by colons: first, &lt;code&gt;dbi&lt;/code&gt;, since that&amp;rsquo;s what we&amp;rsquo;re using to get our data; &lt;code&gt;mysql&lt;/code&gt;, since that&amp;rsquo;s the name of the driver we want to use to get it; and &lt;code&gt;phonebill&lt;/code&gt;, since that&amp;rsquo;s the database we&amp;rsquo;re getting it from.&lt;/p&gt;

&lt;p&gt;So, to connect to a database with the DBI, we&amp;rsquo;d write something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use DBI;
my $dbh = DBI-&amp;gt;connect(&amp;quot;dbi:mysql:phonebill&amp;quot;, $user, $password);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In a lot of cases, you can do without the username and password if you&amp;rsquo;re connecting as a local user. However, for a serious application, you&amp;rsquo;ll probably want to create a specific user or prompt for a password.&lt;/p&gt;

&lt;p&gt;Now we have connected to the database, DBI returns us a database handle, which is typically stored into a variable called &lt;code&gt;$dbh&lt;/code&gt;. (Of course, if you&amp;rsquo;re connecting to multiple different databases, you may prefer to give it a name that identifies it to a particular database.) Now we have a database handle, and we can use it to make queries.&lt;/p&gt;

&lt;p&gt;Making a query in the DBI takes place in three stages. First, you &lt;strong&gt;prepare&lt;/strong&gt; some SQL; then you &lt;strong&gt;execute&lt;/strong&gt; the query; finally, you &lt;strong&gt;get&lt;/strong&gt; the results. Let&amp;rsquo;s do that now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;SQL);
   select recipient, calldate, calltime, duration
   from call 
   where duration &amp;gt; 60
   order by duration desc
SQL

$sth-&amp;gt;execute;

my %calls;
while (my @row = $sth-&amp;gt;fetchrow_array()) {
   my ($recipient, $calldate, $calltime, $duration) = @row;
   $calls{$recipient} += $duration;
   print &amp;quot;Called $recipient on $calldate\n&amp;quot;;
}

# Now do something with the total times here.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Why, you might think, do we have to go through these three stages just to make an SQL query? Isn&amp;rsquo;t Perl supposed to make things easy? Well it does, but it makes different things easy to what you&amp;rsquo;re expecting. For instance, suppose you&amp;rsquo;re inserting a lot of rows into a table. This is precisely the sort of thing you don&amp;rsquo;t want to do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;![CDATA[
while (my $data = &amp;lt;FILE&amp;gt;) {
    my ($recipient, $date, $time, $duration) = split /:/, $data;
    # DON&#39;T DO THIS
    my $sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;SQL);
INSERT INTO call (recipient, calldate, calltime, duration)
VALUES (&amp;quot;$recipient&amp;quot;, &amp;quot;$date&amp;quot;, &amp;quot;$time&amp;quot;, &amp;quot;$duration&amp;quot;);
SQL
    # NO REALLY, DON&#39;T DO THIS

    $sth-&amp;gt;execute;
}
]]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are two reasons why this is BAD, BAD, BAD. The first, of course, is that the moment someone comes along with a double-quote in the file, we&amp;rsquo;re in big trouble. In fact, the moment someone comes along with &lt;code&gt;&amp;quot;; DROP DATABASE;&lt;/code&gt; in the table, we&amp;rsquo;re out of a job.&lt;/p&gt;

&lt;p&gt;The second is that it&amp;rsquo;s really inefficient to set up a statement, execute it, tear it down, set up a statement, execute it, tear it down, and round we go again.&lt;/p&gt;

&lt;p&gt;The reason for the disconnect between preparing a statement and executing it is to enable us to use the same statement multiple times with slightly different values; we do this by using what DBI calls &amp;ldquo;bind parameters&amp;rdquo; &amp;ndash; portions of the SQL that will be replaced later. For instance, the right way to do our mass inserts would be something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $sth = $dbh-&amp;gt;prepare(&amp;lt;&amp;lt;SQL);
INSERT INTO call (recipient, calldate, calltime, duration)
VALUES (?, ?, ?, ?)
SQL

while (my $data = &amp;lt;FILE&amp;gt;) {
    my ($recipient, $date, $time, $duration) = split /:/, $data;
    $sth-&amp;gt;execute($recipient, $date, $time, $duration);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Isn&amp;rsquo;t that just so much &lt;em&gt;neater&lt;/em&gt;? We&amp;rsquo;ve hoisted the statement outside the loop, so it only gets prepared once &amp;ndash; much more efficient. We specify the parameters we want bound to the SQL using question marks, and we pass in the values to the &lt;code&gt;execute&lt;/code&gt; call.&lt;/p&gt;

&lt;p&gt;As an additional bonus, when &lt;code&gt;execute&lt;/code&gt; substitutes in the bind values to the SQL, it calls the database handle&amp;rsquo;s &lt;code&gt;quote&lt;/code&gt; method on each one; this is a database-specific method, which escapes any nasty characters like quotes and semicolons in the input, and makes our code safe against the &lt;code&gt;&amp;quot;;drop database&lt;/code&gt; attack.&lt;/p&gt;

&lt;h3 id=&#34;span-id-making-things-easier-making-things-easier-span&#34;&gt;&lt;span id=&#34;making_things_easier&#34;&gt;Making Things Easier&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;But in many cases, the prepare-execute-fetch process &lt;strong&gt;is&lt;/strong&gt; a pain in the neck. Thankfully, DBI provides some easier ways to perform SQL statements; it has some canned methods that do prepare, execute, and fetch in one go.&lt;/p&gt;

&lt;p&gt;The first of these is &lt;code&gt;do&lt;/code&gt;, which executes a statement when you don&amp;rsquo;t care about the return value, when you&amp;rsquo;re not trying to get results back, such as a &lt;code&gt;DELETE&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Ignore short calls.
$dbh-&amp;gt;do(&amp;quot;delete from calls where duration &amp;lt; 5&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For &lt;code&gt;SELECT&lt;/code&gt; statements, there are a variety of methods that can help out. Perhaps the easiest to use is &lt;code&gt;selectall_arrayref&lt;/code&gt;. This returns the results of the &lt;code&gt;SELECT&lt;/code&gt; as an array of arrays:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $results = $dbh-&amp;gt;selectall_arrayref(&amp;lt;&amp;lt;SQL);
   select recipient, calldate, calltime, $duration 
   from call  
   where duration &amp;gt; 60 
   order by duration desc 
SQL

for my $row (@$results) {
   my ($recipient, $calldate, $calltime, $duration) = @$row;
   ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are many other DBI tricks, too many to go into here; for more information check out the &lt;a href=&#34;https://metacpan.org/pod/DBI&#34;&gt;DBI documentation page&lt;/a&gt;, or the &lt;a href=&#34;http://dbi.perl.org/&#34;&gt;DBI home page&lt;/a&gt;; there&amp;rsquo;s also &lt;a href=&#34;http://www.oreilly.com/catalog/perldbi/&#34;&gt;Programming the Perl DBI&lt;/a&gt;, which was co-authored by the creator of DBI.&lt;/p&gt;

&lt;h3 id=&#34;span-id-where-to-from-here-where-to-from-here-span&#34;&gt;&lt;span id=&#34;where_to_from_here&#34;&gt;Where to from Here?&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;These days, I actually don&amp;rsquo;t write very much SQL; there are many more Perlish abstraction layers on top of SQL, such as Tony Bowden&amp;rsquo;s &lt;a href=&#34;http://localhost:1313/pub/2002/11/27/classdbi.html&#34;&gt;&lt;code&gt;Class::DBI&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&#34;http://localhost:1313/pub/2001/02/dbix.html&#34;&gt;&lt;code&gt;DBIx::RecordSet&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://metacpan.org/pod/DBIx::SearchBuilder&#34;&gt;&lt;code&gt;DBIx::SearchBuilder&lt;/code&gt;&lt;/a&gt; and many more.&lt;/p&gt;

&lt;p&gt;Additionally, there are some very interesting things going on in the world of database servers &amp;ndash; &lt;a href=&#34;http://www.hwaci.com/sw/sqlite/&#34;&gt;SQLite&lt;/a&gt; is a very fast embedded SQL engine which doesn&amp;rsquo;t require an external server process, and there are Perl bindings to that in the form of &lt;code&gt;DBD::SQLite&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll look at some more of these techniques at a later date, but hopefully this should be enough to get you started using relational databases in Perl &amp;hellip; and of course, the most important lesson of this article: don&amp;rsquo;t worry if you look back at your code after five years and cringe &amp;ndash; so do I!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

