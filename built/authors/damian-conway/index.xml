<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Damian Conway on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/authors/damian-conway/</link>
    <description>Recent content in Damian Conway on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 14 Jul 2005 00:00:00 -0800</lastBuildDate>
    <atom:link href="/authors/damian-conway/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Ten Essential Development Practices</title>
      <link>http://localhost:1313/pub/2005/07/14/bestpractices.html/</link>
      <pubDate>Thu, 14 Jul 2005 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2005/07/14/bestpractices.html/</guid>
      <description>

&lt;p&gt;The following ten tips come from &lt;em&gt;&lt;a href=&#34;http://www.oreilly.com/catalog/perlbp/&#34;&gt;Perl Best Practices&lt;/a&gt;&lt;/em&gt;, a new book of Perl coding and development guidelines by Damian Conway.&lt;/p&gt;

&lt;h3 id=&#34;1-design-the-module-s-interface-first&#34;&gt;1. Design the Module&amp;rsquo;s Interface First&lt;/h3&gt;

&lt;p&gt;The most important aspect of any module is not how it implements the facilities it provides, but the way in which it provides those facilities in the first place. If the module&amp;rsquo;s API is too awkward, or too complex, or too extensive, or too fragmented, or even just poorly named, developers will avoid using it. They&amp;rsquo;ll write their own code instead. In that way, a poorly designed module can actually reduce the overall maintainability of a system.&lt;/p&gt;

&lt;p&gt;Designing module interfaces requires both experience and creativity. Perhaps the easiest way to work out how an interface should work is to &amp;ldquo;play test&amp;rdquo; it: to write examples of code that will use the module before implementing the module itself. These examples will not be wasted when the design is complete. You can usually recycle them into demos, documentation examples, or the core of a test suite.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://conferences.oreillynet.com/os2005/&#34;&gt;&lt;img src=&#34;http://conferences.oreillynet.com/images/os2005/banners/120x240.gif&#34; alt=&#34;O&amp;#39;Reilly Open Source Convention 2005.&#34; width=&#34;120&#34; height=&#34;240&#34; /&gt;&lt;/a&gt;
The key, however, is to write that code as if the module were already available, and write it the way you&amp;rsquo;d most like the module to work.&lt;/p&gt;

&lt;p&gt;Once you have some idea of the interface you want to create, convert your &amp;ldquo;play tests&amp;rdquo; into actual tests (see Tip #2). Then it&amp;rsquo;s just a Simple Matter Of Programming to make the module work the way that the code examples and the tests want it to.&lt;/p&gt;

&lt;p&gt;Of course, it may not be possible for the module to work the way you&amp;rsquo;d most like, in which case attempting to implement it that way will help you determine what aspects of your API are not practical, and allow you to work out what might be an acceptable alternative.&lt;/p&gt;

&lt;h3 id=&#34;2-write-the-test-cases-before-the-code&#34;&gt;2. Write the Test Cases Before the Code&lt;/h3&gt;

&lt;p&gt;Probably the single best practice in all of software development is writing your test suite first.&lt;/p&gt;

&lt;p&gt;A test suite is an executable, self-verifying specification of the behavior of a piece of software. If you have a test suite, you can&amp;ndash;at any point in the development process&amp;ndash;verify that the code works as expected. If you have a test suite, you can&amp;ndash;after any changes during the maintenance cycle&amp;ndash;verify that the code still works as expected.&lt;/p&gt;

&lt;p&gt;Write the tests first. Write them as soon as you know what your interface will be (see #1). Write them before you start coding your application or module. Unless you have tests, you have no unequivocal specification of what the software should do, and no way of knowing whether it does it.&lt;/p&gt;

&lt;p&gt;Writing tests always seems like a chore, and an unproductive chore at that: you don&amp;rsquo;t have anything to test yet, so why write tests? Yet most developers will&amp;ndash;almost automatically&amp;ndash;write driver software to test their new module in an ad hoc way:&lt;span id=&#34;OLE_LINK428&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; cat try_inflections.pl

# Test my shiny new English inflections module...

use Lingua::EN::Inflect qw( inflect );

# Try some plurals (both standard and unusual inflections)...

my %plural_of = (
   &#39;house&#39;         =&amp;gt; &#39;houses&#39;,
   &#39;mouse&#39;         =&amp;gt; &#39;mice&#39;,
   &#39;box&#39;           =&amp;gt; &#39;boxes&#39;,
   &#39;ox&#39;            =&amp;gt; &#39;oxen&#39;,
   &#39;goose&#39;         =&amp;gt; &#39;geese&#39;,
   &#39;mongoose&#39;      =&amp;gt; &#39;mongooses&#39;,
   &#39;law&#39;           =&amp;gt; &#39;laws&#39;,
   &#39;mother-in-law&#39; =&amp;gt; &#39;mothers-in-law&#39;,
);

# For each of them, print both the expected result and the actual inflection...

for my $word ( keys %plural_of ) {
   my $expected = $plural_of{$word};
   my $computed = inflect( &amp;quot;PL_N($word)&amp;quot; );

   print &amp;quot;For $word:\n&amp;quot;,
         &amp;quot;\tExpected: $expected\n&amp;quot;,
         &amp;quot;\tComputed: $computed\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A driver like that is actually harder to write than a test suite, because you have to worry about formatting the output in a way that is easy to read. It&amp;rsquo;s also much harder to use the driver than it would be to use a test suite, because every time you run it you have to wade though that formatted output and verify &amp;ldquo;by eye&amp;rdquo; that everything is as it should be. That&amp;rsquo;s also error-prone; eyes are not optimized for picking out small differences in the middle of large amounts of nearly identical text.&lt;/p&gt;

&lt;p&gt;Instead of hacking together a driver program, it&amp;rsquo;s easier to write a test program using the standard &lt;a href=&#34;https://metacpan.org/pod/Test::Simple&#34;&gt;Test::Simple&lt;/a&gt; module. Instead of &lt;code&gt;print&lt;/code&gt; statements showing what&amp;rsquo;s being tested, you just write calls to the &lt;code&gt;ok()&lt;/code&gt; subroutine, specifying as its first argument the condition under which things are okay, and as its second argument a description of what you&amp;rsquo;re actually testing:&lt;span id=&#34;OLE_LINK429&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; cat inflections.t

use Lingua::EN::Inflect qw( inflect);

use Test::Simple qw( no_plan);

my %plural_of = (
   &#39;mouse&#39;         =&amp;gt; &#39;mice&#39;,
   &#39;house&#39;         =&amp;gt; &#39;houses&#39;,
   &#39;ox&#39;            =&amp;gt; &#39;oxen&#39;,
   &#39;box&#39;           =&amp;gt; &#39;boxes&#39;,
   &#39;goose&#39;         =&amp;gt; &#39;geese&#39;,
   &#39;mongoose&#39;      =&amp;gt; &#39;mongooses&#39;,
   &#39;law&#39;           =&amp;gt; &#39;laws&#39;,
   &#39;mother-in-law&#39; =&amp;gt; &#39;mothers-in-law&#39;,
);

for my $word ( keys %plural_of ) {
   my $expected = $plural_of{$word};
   my $computed = inflect( &amp;quot;PL_N($word)&amp;quot; );

   ok( $computed eq $expected, &amp;quot;$word -&amp;gt; $expected&amp;quot; );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that this code loads &lt;code&gt;Test::Simple&lt;/code&gt; with the argument &lt;code&gt;qw( no_plan )&lt;/code&gt;. Normally that argument would be &lt;code&gt;tests =&amp;gt; count&lt;/code&gt;, indicating how many tests to expect, but here the tests are generated from the &lt;code&gt;%plural_of&lt;/code&gt; table at run time, so the final count will depend on how many entries are in that table. Specifying a fixed number of tests when loading the module is useful if you happen know that number at compile time, because then the module can also &amp;ldquo;meta-test:&amp;rdquo; verify that you carried out all the tests you expected to.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Test::Simple&lt;/code&gt; program is slightly more concise and readable than the original driver code, and the output is much more compact and informative:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; perl inflections.t

ok 1 - house -&amp;gt; houses
ok 2 - law -&amp;gt; laws
not ok 3 - mongoose -&amp;gt; mongooses
#     Failed test (inflections.t at line 21)
ok 4 - goose -&amp;gt; geese
ok 5 - ox -&amp;gt; oxen
not ok 6 - mother-in-law -&amp;gt; mothers-in-law
#     Failed test (inflections.t at line 21)
ok 7 - mouse -&amp;gt; mice
ok 8 - box -&amp;gt; boxes
1..8
# Looks like you failed 2 tests of 8.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More importantly, this version requires far less effort to verify the correctness of each test. You just scan down the left margin looking for a &lt;code&gt;not&lt;/code&gt; and a comment line.&lt;/p&gt;

&lt;p&gt;You might prefer to use the &lt;a href=&#34;https://metacpan.org/pod/Test::More&#34;&gt;Test::More&lt;/a&gt; module instead of &lt;code&gt;Test::Simple&lt;/code&gt;. Then you can specify the actual and expected values separately, by using the &lt;code&gt;is()&lt;/code&gt; subroutine, rather than &lt;code&gt;ok()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Lingua::EN::Inflect qw( inflect );
use Test::More qw( no_plan ); # Now using more advanced testing tools

my %plural_of = (
   &#39;mouse&#39;         =&amp;gt; &#39;mice&#39;,
   &#39;house&#39;         =&amp;gt; &#39;houses&#39;,
   &#39;ox&#39;            =&amp;gt; &#39;oxen&#39;,
   &#39;box&#39;           =&amp;gt; &#39;boxes&#39;,
   &#39;goose&#39;         =&amp;gt; &#39;geese&#39;,
   &#39;mongoose&#39;      =&amp;gt; &#39;mongooses&#39;,
   &#39;law&#39;           =&amp;gt; &#39;laws&#39;,
   &#39;mother-in-law&#39; =&amp;gt; &#39;mothers-in-law&#39;,
);

for my $word ( keys %plural_of ) {
   my $expected = $plural_of{$word};
   my $computed = inflect( &amp;quot;PL_N($word)&amp;quot; );

   # Test expected and computed inflections for string equality...
   is( $computed, $expected, &amp;quot;$word -&amp;gt; $expected&amp;quot; );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apart from no longer having to type the &lt;code&gt;eq&lt;/code&gt; yourself, this version also produces more detailed error messages:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; perl inflections.t

ok 1 - house -&amp;gt; houses
ok 2 - law -&amp;gt; laws
not ok 3 - mongoose -&amp;gt; mongooses
#     Failed test (inflections.t at line 20)
#          got: &#39;mongeese&#39;
#     expected: &#39;mongooses&#39;
ok 4 - goose -&amp;gt; geese
ok 5 - ox -&amp;gt; oxen
not ok 6 - mother-in-law -&amp;gt; mothers-in-law
#     Failed test (inflections.t at line 20)
#          got: &#39;mothers-in-laws&#39;
#     expected: &#39;mothers-in-law&#39;
ok 7 - mouse -&amp;gt; mice
ok 8 - box -&amp;gt; boxes
1..8
# Looks like you failed 2 tests of 8.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;a href=&#34;https://metacpan.org/pod/Test::Tutorial&#34;&gt;Test::Tutorial&lt;/a&gt; documentation that comes with Perl 5.8 provides a gentle introduction to both &lt;code&gt;Test::Simple&lt;/code&gt; and &lt;code&gt;Test::More&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;3-create-standard-pod-templates-for-modules-and-applications&#34;&gt;3. Create Standard POD Templates for Modules and Applications&lt;/h3&gt;

&lt;p&gt;One of the main reasons documentation can often seem so unpleasant is the &amp;ldquo;blank page effect.&amp;rdquo; Many programmers simply don&amp;rsquo;t know how to get started or what to say.&lt;/p&gt;

&lt;p&gt;Perhaps the easiest way to make writing documentation less forbidding (and hence, more likely to actually occur) is to circumvent that initial empty screen by providing a template that developers can cut and paste into their code.&lt;/p&gt;

&lt;p&gt;For a module, that documentation template might look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;=head1 NAME

&amp;lt;Module::Name&amp;gt; - &amp;lt;One-line description of module&#39;s purpose&amp;gt;

=head1 VERSION

The initial template usually just has:

This documentation refers to &amp;lt;Module::Name&amp;gt; version 0.0.1.

=head1 SYNOPSIS

   use &amp;lt;Module::Name&amp;gt;;

   # Brief but working code example(s) here showing the most common usage(s)
   # This section will be as far as many users bother reading, so make it as
   # educational and exemplary as possible.

=head1 DESCRIPTION

A full description of the module and its features.

May include numerous subsections (i.e., =head2, =head3, etc.).

=head1 SUBROUTINES/METHODS

A separate section listing the public components of the module&#39;s interface.

These normally consist of either subroutines that may be exported, or methods
that may be called on objects belonging to the classes that the module
provides.

Name the section accordingly.

In an object-oriented module, this section should begin with a sentence (of the
form &amp;quot;An object of this class represents ...&amp;quot;) to give the reader a high-level
context to help them understand the methods that are subsequently described.

=head1 DIAGNOSTICS

A list of every error and warning message that the module can generate (even
the ones that will &amp;quot;never happen&amp;quot;), with a full explanation of each problem,
one or more likely causes, and any suggested remedies.

=head1 CONFIGURATION AND ENVIRONMENT

A full explanation of any configuration system(s) used by the module, including
the names and locations of any configuration files, and the meaning of any
environment variables or properties that can be set. These descriptions must
also include details of any configuration language used.

=head1 DEPENDENCIES

A list of all of the other modules that this module relies upon, including any
restrictions on versions, and an indication of whether these required modules
are part of the standard Perl distribution, part of the module&#39;s distribution,
or must be installed separately.

=head1 INCOMPATIBILITIES

A list of any modules that this module cannot be used in conjunction with.
This may be due to name conflicts in the interface, or competition for system
or program resources, or due to internal limitations of Perl (for example, many
modules that use source code filters are mutually incompatible).

=head1 BUGS AND LIMITATIONS

A list of known problems with the module, together with some indication of
whether they are likely to be fixed in an upcoming release.

Also, a list of restrictions on the features the module does provide: data types
that cannot be handled, performance issues and the circumstances in which they
may arise, practical limitations on the size of data sets, special cases that
are not (yet) handled, etc.

The initial template usually just has:

There are no known bugs in this module.

Please report problems to &amp;lt;Maintainer name(s)&amp;gt; (&amp;lt;contact address&amp;gt;)

Patches are welcome.

=head1 AUTHOR

&amp;lt;Author name(s)&amp;gt;  (&amp;lt;contact address&amp;gt;)

=head1 LICENSE AND COPYRIGHT

Copyright (c) &amp;lt;year&amp;gt; &amp;lt;copyright holder&amp;gt; (&amp;lt;contact address&amp;gt;).
All rights reserved.

followed by whatever license you wish to release it under.

For Perl code that is often just:

This module is free software; you can redistribute it and/or modify it under
the same terms as Perl itself. See L&amp;lt;perlartistic&amp;gt;.  This program is
distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, the specific details that your templates provide may vary from those shown here, according to your other coding practices. The most likely variation will be in the license and copyright, but you may also have specific in-house conventions regarding version numbering, the grammar of diagnostic messages, or the attribution of authorship.&lt;/p&gt;

&lt;h3 id=&#34;4-use-a-revision-control-system&#34;&gt;4. Use a Revision Control System&lt;/h3&gt;

&lt;p&gt;Maintaining control over the creation and modification of your source code is utterly essential for robust team-based development. And not just over source code: you should be revision controlling your documentation, and data files, and document templates, and makefiles, and style sheets, and change logs, and any other resources your system requires.&lt;/p&gt;

&lt;p&gt;Just as you wouldn&amp;rsquo;t use an editor without an Undo command or a word processor that can&amp;rsquo;t merge documents, so too you shouldn&amp;rsquo;t use a file system you can&amp;rsquo;t rewind, or a development environment that can&amp;rsquo;t integrate the work of many contributors.&lt;/p&gt;

&lt;p&gt;Programmers make mistakes, and occasionally those mistakes will be catastrophic. They will reformat the disk containing the most recent version of the code. Or they&amp;rsquo;ll mistype an editor macro and write zeros all through the source of a critical core module. Or two developers will unwittingly edit the same file at the same time and half their changes will be lost. Revision control systems can prevent those kinds of problems.&lt;/p&gt;

&lt;p&gt;Moreover, occasionally the very best debugging technique is to just give up, stop trying to get yesterday&amp;rsquo;s modifications to work correctly, roll the code back to a known stable state, and start over again. Less drastically, comparing the current condition of your code with the most recent stable version from your repository (even just a line-by-line &lt;code&gt;diff&lt;/code&gt;) can often help you isolate your recent &amp;ldquo;improvements&amp;rdquo; and work out which of them is the problem.&lt;/p&gt;

&lt;p&gt;Revision control systems such as RCS, CVS, Subversion, Monotone, &lt;code&gt;darcs&lt;/code&gt;, Perforce, GNU arch, or BitKeeper can protect against calamities, and ensure that you always have a working fallback position if maintenance goes horribly wrong. The various systems have different strengths and limitations, many of which stem from fundamentally different views on what exactly revision control is. It&amp;rsquo;s a good idea to audition the various revision control systems, and find the one that works best for you. &lt;em&gt;Pragmatic Version Control Using Subversion&lt;/em&gt;, by Mike Mason (Pragmatic Bookshelf, 2005) and &lt;a href=&#34;http://www.oreilly.com/catalog/cvs/&#34;&gt;&lt;em&gt;Essential CVS&lt;/em&gt;&lt;/a&gt;, by Jennifer Vesperman (O&amp;rsquo;Reilly, 2003) are useful starting points.&lt;/p&gt;

&lt;h3 id=&#34;5-create-consistent-command-line-interfaces&#34;&gt;5. Create Consistent Command-Line Interfaces&lt;/h3&gt;

&lt;p&gt;Command-line interfaces have a strong tendency to grow over time, accreting new options as you add features to the application. Unfortunately, the evolution of such interfaces is rarely designed, managed, or controlled, so the set of flags, options, and arguments that a given application accepts are likely to be ad hoc and unique.&lt;/p&gt;

&lt;p&gt;This also means they&amp;rsquo;re likely to be inconsistent with the unique ad hoc sets of flags, options, and arguments that other related applications provide. The result is inevitably a suite of programs, each of which is driven in a distinct and idiosyncratic way. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; orchestrate source.txt -to interim.orc

&amp;gt; remonstrate +interim.rem -interim.orc

&amp;gt; fenestrate  --src=interim.rem --dest=final.wdw
Invalid input format

&amp;gt; fenestrate --help
Unknown option: --help.
Type &#39;fenestrate -hmo&#39; for help
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, the &lt;code&gt;orchestrate&lt;/code&gt; utility expects its input file as its first argument, while the &lt;code&gt;-to&lt;/code&gt; flag specifies its output file. The related &lt;code&gt;remonstrate&lt;/code&gt; tool uses &lt;code&gt;-infile&lt;/code&gt; and &lt;code&gt;+outfile&lt;/code&gt; options instead, with the output file coming first. The &lt;code&gt;fenestrate&lt;/code&gt; program seems to require GNU-style &amp;ldquo;long options:&amp;rdquo; &lt;code&gt;--src=infile&lt;/code&gt; and &lt;code&gt;--dest=outfile&lt;/code&gt;, except, apparently, for its oddly named help flag. All in all, it&amp;rsquo;s a mess.&lt;/p&gt;

&lt;p&gt;When you&amp;rsquo;re providing a suite of programs, all of them should appear to work the same way, using the same flags and options for the same features across all applications. This enables your users to take advantage of existing knowledge&amp;ndash;instead of continually asking you.&lt;/p&gt;

&lt;p&gt;Those three programs should work like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; orchestrate -i source.txt -o dest.orc

&amp;gt; remonstrate -i source.orc -o dest.rem

&amp;gt; fenestrate  -i source.rem -o dest.wdw
Input file (&#39;source.rem&#39;) not a valid Remora file
(type &amp;quot;fenestrate --help&amp;quot; for help)

&amp;gt; fenestrate --help
fenestrate - convert Remora .rem files to Windows .wdw format
Usage: fenestrate [-i &amp;lt;infile&amp;gt;] [-o &amp;lt;outfile&amp;gt;] [-cstq] [-h|-v]
Options:
   -i &amp;lt;infile&amp;gt; Specify input source [default: STDIN]
   -o &amp;lt;outfile&amp;gt; Specify output destination [default: STDOUT]
   -c Attempt to produce a more compact representation
   -h Use horizontal (landscape) layout
   -v Use vertical (portrait) layout
   -s Be strict regarding input
   -t Be extra tolerant regarding input
   -q Run silent
   --version Print version information
   --usage Print the usage line of this summary
   --help Print this summary
   --man Print the complete manpage
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, every application that takes input and output files uses the same two flags to do so. A user who wants to use the &lt;code&gt;substrate&lt;/code&gt; utility (to convert that final .wdw file to a subroutine) is likely to be able to guess correctly the required syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; substrate  -i dest.wdw -o dest.sub
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Anyone who can&amp;rsquo;t guess that probably can guess that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; substrate --help
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is likely to render aid and comfort.&lt;/p&gt;

&lt;p&gt;A large part of making interfaces consistent is being consistent in specifying the individual components of those interfaces. Some conventions that may help to design consistent and predictable interfaces include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Require a flag preceding every piece of command-line data, except filenames.&lt;/p&gt;

&lt;p&gt;Users don&amp;rsquo;t want to have to remember that your application requires &amp;ldquo;input file, output file, block size, operation, fallback strategy,&amp;rdquo; and requires them in that precise order:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; lustrate sample_data proc_data 1000 normalize log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;They want to be able to say explicitly what they mean, in any order that suits them:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; lustrate sample_data proc_data -op=normalize -b1000 --fallback=log
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Provide a flag for each filename, too, especially when a program can be given files for different purposes.&lt;/p&gt;

&lt;p&gt;Users might also not want to remember the order of the two positional filenames, so let them label those arguments as well, and specify them in whatever order they prefer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; lustrate -i sample_data -op normalize -b1000 --fallback log -o proc_data
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use a single &lt;code&gt;-&lt;/code&gt; prefix for short-form flags, up to three letters (&lt;code&gt;-v&lt;/code&gt;, &lt;code&gt;-i&lt;/code&gt;, &lt;code&gt;-rw&lt;/code&gt;, &lt;code&gt;-in&lt;/code&gt;, &lt;code&gt;-out&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Experienced users appreciate short-form flags as a way of reducing typing and limiting command-line clutter. Don&amp;rsquo;t make them type two dashes in these shortcuts.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use a double &lt;code&gt;--&lt;/code&gt; prefix for longer flags (&lt;code&gt;--verbose&lt;/code&gt;, &lt;code&gt;--interactive&lt;/code&gt;, &lt;code&gt;--readwrite&lt;/code&gt;, &lt;code&gt;--input&lt;/code&gt;, &lt;code&gt;--output&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Flags that are complete words improve the readability of a command line (in a shell script, for example). The double dash also helps to distinguish between the longer flag name and any nearby file names.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If a flag expects an associated value, allow an optional &lt;code&gt;=&lt;/code&gt; between the flag and the value.&lt;/p&gt;

&lt;p&gt;Some people prefer to visually associate a value with its preceding flag:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; lustrate -i=sample_data -op=normalize -b=1000 --fallback=log -o=proc_data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Others don&amp;rsquo;t:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; lustrate -i sample_data -op normalize -b1000 --fallback log -o proc_data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Still others want a bit each way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; lustrate -i sample_data -o proc_data -op=normalize -b=1000 --fallback=log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let the user choose.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Allow single-letter options to be &amp;ldquo;bundled&amp;rdquo; after a single dash.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s irritating to have to type repeated dashes for a series of flags:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; lustrate -i sample_data -v -l -x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Allow experienced users to also write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; lustrate -i sample_data -vlx
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Provide a multi-letter version of every single-letter flag.&lt;/p&gt;

&lt;p&gt;Short-form flags may be nice for experienced users, but they can be troublesome for new users: hard to remember and even harder to recognize. Don&amp;rsquo;t force people to do either. Give them a verbose alternative to every concise flag; full words that are easier to remember, and also more self-documenting in shell scripts.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Always allow &lt;code&gt;-&lt;/code&gt; as a special filename.&lt;/p&gt;

&lt;p&gt;A widely used convention is that a dash (&lt;code&gt;-&lt;/code&gt;) where an input file is expected means &amp;ldquo;read from standard input,&amp;rdquo; and a dash where an output file is expected means &amp;ldquo;write to standard output.&amp;rdquo;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Always allow &lt;code&gt;--&lt;/code&gt; as a file list marker.&lt;/p&gt;

&lt;p&gt;Another widely used convention is that the appearance of a double dash (&lt;code&gt;--&lt;/code&gt;) on the command line marks the end of any flagged options, and indicates that the remaining arguments are a list of filenames, even if some of them look like flags.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;6-agree-upon-a-coherent-layout-style-and-automate-it-with-perltidy&#34;&gt;6. Agree Upon a Coherent Layout Style and Automate It with &lt;code&gt;perltidy&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Formatting. Indentation. Style. Code layout. Whatever you choose to call it, it&amp;rsquo;s one of the most contentious aspects of programming discipline. More and bloodier wars have been fought over code layout than over just about any other aspect of coding.&lt;/p&gt;

&lt;p&gt;What is the best practice here? Should you use classic Kernighan and Ritchie style? Or go with BSD code formatting? Or adopt the layout scheme specified by the GNU project? Or conform to the Slashcode coding guidelines?&lt;/p&gt;

&lt;p&gt;Of course not! Everyone knows that &lt;em&gt;&amp;lt;insert your personal coding style here&amp;gt;&lt;/em&gt; is the One True Layout Style, the only sane choice, as ordained by &lt;em&gt;&amp;lt;insert your favorite Programming Deity here&amp;gt;&lt;/em&gt; since Time Immemorial! Any other choice is manifestly absurd, willfully heretical, and self-evidently a Work of Darkness!&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s precisely the problem. When deciding on a layout style, it&amp;rsquo;s hard to decide where rational choices end and rationalized habits begin.&lt;/p&gt;

&lt;p&gt;Adopting a coherently designed approach to code layout, and then applying that approach consistently across all your coding, is fundamental to best-practice programming. Good layout can improve the readability of a program, help detect errors within it, and make the structure of your code much easier to comprehend. Layout matters.&lt;/p&gt;

&lt;p&gt;However, most coding styles&amp;ndash;including the four mentioned earlier&amp;ndash;confer those benefits almost equally well. While it&amp;rsquo;s true that having a consistent code layout scheme matters very much indeed, the particular code layout scheme you ultimately decide upon does not matter at all! All that matters is that you adopt a single, coherent style; one that works for your entire programming team, and, having agreed upon that style, that you then apply it consistently across all your development.&lt;/p&gt;

&lt;p&gt;In the long term, it&amp;rsquo;s best to train yourself and your team to code in a consistent, rational, and readable style. However, the time and commitment necessary to accomplish that isn&amp;rsquo;t always available. In such cases, a reasonable compromise is to prescribe a standard code-formatting tool that must be applied to all code before it&amp;rsquo;s committed, reviewed, or otherwise displayed in public.&lt;/p&gt;

&lt;p&gt;There is now an excellent code formatter available for Perl: &lt;a href=&#34;http://perltidy.sourceforge.net/&#34;&gt;&lt;code&gt;perltidy&lt;/code&gt;&lt;/a&gt;. It provides an extensive range of user-configurable options for indenting, block delimiter positioning, column-like alignment, and comment positioning.&lt;/p&gt;

&lt;p&gt;Using &lt;code&gt;perltidy&lt;/code&gt;, you can convert code like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if($sigil eq &#39;$&#39;){
   if($subsigil eq &#39;?&#39;){
       $sym_table{substr($var_name,2)}=delete $sym_table{locate_orig_var($var)};
       $internal_count++;$has_internal{$var_name}++
   } else {
       ${$var_ref} =
           q{$sym_table{$var_name}}; $external_count++; $has_external{$var_name}++;
}} elsif ($sigil eq &#39;@&#39;&amp;amp;&amp;amp;$subsigil eq &#39;?&#39;) {
   @{$sym_table{$var_name}} = grep
       {defined $_} @{$sym_table{$var_name}};
} elsif ($sigil eq &#39;%&#39; &amp;amp;&amp;amp; $subsigil eq &#39;?&#39;) {
delete $sym_table{$var_name}{$EMPTY_STR}; } else
{
${$var_ref}
=
q{$sym_table{$var_name}}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;into something readable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ( $sigil eq &#39;$&#39; ) {
   if ( $subsigil eq &#39;?&#39; ) {
       $sym_table{ substr( $var_name, 2 ) }
           = delete $sym_table{ locate_orig_var($var) };
       $internal_count++;
       $has_internal{$var_name}++;
   }
   else {
       ${$var_ref} = q{$sym_table{$var_name}};
       $external_count++;
       $has_external{$var_name}++;
   }
}
elsif ( $sigil eq &#39;@&#39; &amp;amp;&amp;amp; $subsigil eq &#39;?&#39; ) {
   @{ $sym_table{$var_name} }
       = grep {defined $_} @{ $sym_table{$var_name} };
}
elsif ( $sigil eq &#39;%&#39; &amp;amp;&amp;amp; $subsigil eq &#39;?&#39; ) {
   delete $sym_table{$var_name}{$EMPTY_STR};
}
else {
   ${$var_ref} = q{$sym_table{$var_name}};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mandating that everyone use a common tool to format their code can also be a simple way of sidestepping the endless objections, acrimony, and dogma that always surround any discussion on code layout. If &lt;code&gt;perltidy&lt;/code&gt; does all the work for them, then it will cost developers almost no effort to adopt the new guidelines. They can simply set up an editor macro that will &amp;ldquo;straighten&amp;rdquo; their code whenever they need to.&lt;/p&gt;

&lt;h3 id=&#34;7-code-in-commented-paragraphs&#34;&gt;7. Code in Commented Paragraphs&lt;/h3&gt;

&lt;p&gt;A paragraph is a collection of statements that accomplish a single task: in literature, it&amp;rsquo;s a series of sentences conveying a single idea; in programming, a series of instructions implementing a single step of an algorithm.&lt;/p&gt;

&lt;p&gt;Break each piece of code into sequences that achieve a single task, placing a single empty line between each sequence. To further improve the maintainability of the code, place a one-line comment at the start of each such paragraph, describing what the sequence of statements does. Like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Process an array that has been recognized...
sub addarray_internal {
   my ($var_name, $needs_quotemeta) = @_;

   # Cache the original...
   $raw .= $var_name;

   # Build meta-quoting code, if requested...
   my $quotemeta = $needs_quotemeta ?  q{map {quotemeta $_} } : $EMPTY_STR;

   # Expand elements of variable, conjoin with ORs...
   my $perl5pat = qq{(??{join q{|}, $quotemeta \@{$var_name}})};

   # Insert debugging code if requested...
   my $type = $quotemeta ? &#39;literal&#39; : &#39;pattern&#39;;
   debug_now(&amp;quot;Adding $var_name (as $type)&amp;quot;);
   add_debug_mesg(&amp;quot;Trying $var_name (as $type)&amp;quot;);

   return $perl5pat;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Paragraphs are useful because humans can focus on only a few pieces of information at once. Paragraphs are one way of aggregating small amounts of related information, so that the resulting &amp;ldquo;chunk&amp;rdquo; can fit into a single slot of the reader&amp;rsquo;s limited short-term memory. Paragraphs enable the physical structure of a piece of writing to reflect and emphasize its logical structure.&lt;/p&gt;

&lt;p&gt;Adding comments at the start of each paragraph further enhances the chunking by explicitly summarizing the purpose of each chunk (note: the purpose, not the behavior). Paragraph comments need to explain why the code is there and what it achieves, not merely paraphrase the precise computational steps it&amp;rsquo;s performing.&lt;/p&gt;

&lt;p&gt;Note, however, that the contents of paragraphs are only of secondary importance here. It is the vertical gaps separating each paragraph that are critical. Without them, the readability of the code declines dramatically, even if the comments are retained:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub addarray_internal {
   my ($var_name, $needs_quotemeta) = @_;
   # Cache the original...
   $raw .= $var_name;
   # Build meta-quoting code, if required...
   my $quotemeta = $needs_quotemeta ?  q{map {quotemeta $_} } : $EMPTY_STR;
   # Expand elements of variable, conjoin with ORs...
   my $perl5pat = qq{(??{join q{|}, $quotemeta \@{$var_name}})};
   # Insert debugging code if requested...
   my $type = $quotemeta ? &#39;literal&#39; : &#39;pattern&#39;;
   debug_now(&amp;quot;Adding $var_name (as $type)&amp;quot;);
   add_debug_mesg(&amp;quot;Trying $var_name (as $type)&amp;quot;);
   return $perl5pat;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;8-throw-exceptions-instead-of-returning-special-values-or-setting-flags&#34;&gt;8. Throw Exceptions Instead of Returning Special Values or Setting Flags&lt;/h3&gt;

&lt;p&gt;Returning a special error value on failure, or setting a special error flag, is a very common error-handling technique. Collectively, they&amp;rsquo;re the basis for virtually all error notification from Perl&amp;rsquo;s own built-in functions. For example, the built-ins &lt;code&gt;eval&lt;/code&gt;, &lt;code&gt;exec&lt;/code&gt;, &lt;code&gt;flock&lt;/code&gt;, &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;stat&lt;/code&gt;, and &lt;code&gt;system&lt;/code&gt; all return special values on error. Unfortunately, they don&amp;rsquo;t all use the same special value. Some of them also set a flag on failure. Sadly, it&amp;rsquo;s not always the same flag. See the &lt;a href=&#34;https://perldoc.perl.org/perlfunc.html&#34;&gt;perlfunc&lt;/a&gt; manpage for the gory details.&lt;/p&gt;

&lt;p&gt;Apart from the obvious consistency problems, error notification via flags and return values has another serious flaw: developers can silently ignore flags and return values, and ignoring them requires absolutely no effort on the part of the programmer. In fact, in a void context, ignoring return values is Perl&amp;rsquo;s default behavior. Ignoring an error flag that has suddenly appeared in a special variable is just as easy: you simply don&amp;rsquo;t bother to check the variable.&lt;/p&gt;

&lt;p&gt;Moreover, because ignoring a return value is the void-context default, there&amp;rsquo;s no syntactic marker for it. There&amp;rsquo;s no way to look at a program and immediately see where a return value is deliberately being ignored, which means there&amp;rsquo;s also no way to be sure that it&amp;rsquo;s not being ignored accidentally.&lt;/p&gt;

&lt;p&gt;The bottom line: regardless of the programmer&amp;rsquo;s (lack of) intention, an error indicator is being ignored. That&amp;rsquo;s not good programming.&lt;/p&gt;

&lt;p&gt;Ignoring error indicators frequently causes programs to propagate errors in entirely the wrong direction. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Find and open a file by name, returning the filehandle
# or undef on failure...
sub locate_and_open {
   my ($filename) = @_;

   # Check acceptable directories in order...
   for my $dir (@DATA_DIRS) {
       my $path = &amp;quot;$dir/$filename&amp;quot;;

       # If file exists in an acceptable directory, open and return it...
       if (-r $path) {
           open my $fh, &#39;&amp;lt;&#39;, $path;
           return $fh;
       }
   }

   # Fail if all possible locations tried without success...
   return;
}

# Load file contents up to the first &amp;lt;DATA/&amp;gt; marker...
sub load_header_from {
   my ($fh) = @_;

   # Use DATA tag as end-of-&amp;quot;line&amp;quot;...
   local $/ = &#39;&amp;lt;DATA/&amp;gt;&#39;;

   # Read to end-of-&amp;quot;line&amp;quot;...
   return &amp;lt;$fh&amp;gt;;
}

# and later...
for my $filename (@source_files) {
   my $fh = locate_and_open($filename);
   my $head = load_header_from($fh);
   print $head;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;locate_and_open()&lt;/code&gt; subroutine simply assumes that the call to &lt;code&gt;open&lt;/code&gt; works, immediately returning the filehandle (&lt;code&gt;$fh&lt;/code&gt;), whatever the actual outcome of the &lt;code&gt;open&lt;/code&gt;. Presumably, the expectation is that whoever calls &lt;code&gt;locate_and_open()&lt;/code&gt; will check whether the return value is a valid filehandle.&lt;/p&gt;

&lt;p&gt;Except, of course, &amp;ldquo;whoever&amp;rdquo; doesn&amp;rsquo;t check. Instead of testing for failure, the main &lt;code&gt;for&lt;/code&gt; loop takes the failure value and immediately propagates it &amp;ldquo;across&amp;rdquo; the block, to the rest of the statements in the loop. That causes the call to &lt;code&gt;loader_header_from()&lt;/code&gt; to propagate the error value &amp;ldquo;downwards.&amp;rdquo; It&amp;rsquo;s in that subroutine that the attempt to treat the failure value as a filehandle eventually kills the program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;readline() on unopened filehandle at demo.pl line 28.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Code like that&amp;ndash;where an error is reported in an entirely different part of the program from where it actually occurred&amp;ndash;is particularly onerous to debug.&lt;/p&gt;

&lt;p&gt;Of course, you could argue that the fault lies squarely with whoever wrote the loop, for using &lt;code&gt;locate_and_open()&lt;/code&gt; without checking its return value. In the narrowest sense, that&amp;rsquo;s entirely correct&amp;ndash;but the deeper fault lies with whoever actually wrote &lt;code&gt;locate_and_open()&lt;/code&gt; in the first place, or at least, whoever assumed that the caller would always check its return value.&lt;/p&gt;

&lt;p&gt;Humans simply aren&amp;rsquo;t like that. Rocks almost never fall out of the sky, so humans soon conclude that they never do, and stop looking up for them. Fires rarely break out in their homes, so humans soon forget that they might, and stop testing their smoke detectors every month. In the same way, programmers inevitably abbreviate &amp;ldquo;almost never fails&amp;rdquo; to &amp;ldquo;never fails,&amp;rdquo; and then simply stop checking.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s why so very few people bother to verify their &lt;code&gt;print&lt;/code&gt; statements:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!print &#39;Enter your name: &#39;) {
   print {*STDLOG} warning =&amp;gt; &#39;Terminal went missing!&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s human nature to &amp;ldquo;trust but not verify.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Human nature is why returning an error indicator is not best practice. Errors are (supposed to be) unusual occurrences, so error markers will almost never be returned. Those tedious and ungainly checks for them will almost never do anything useful, so eventually they&amp;rsquo;ll be quietly omitted. After all, leaving the tests off almost always works just fine. It&amp;rsquo;s so much easier not to bother. Especially when not bothering is the default!&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t return special error values when something goes wrong; throw an exception instead. The great advantage of exceptions is that they reverse the usual default behaviors, bringing untrapped errors to immediate and urgent attention. On the other hand, ignoring an exception requires a deliberate and conspicuous effort: you have to provide an explicit &lt;code&gt;eval&lt;/code&gt; block to neutralize it.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;locate_and_open()&lt;/code&gt; subroutine would be much cleaner and more robust if the errors within it threw exceptions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Find and open a file by name, returning the filehandle
# or throwing an exception on failure...
sub locate_and_open {
   my ($filename) = @_;

   # Check acceptable directories in order...
   for my $dir (@DATA_DIRS) {
       my $path = &amp;quot;$dir/$filename&amp;quot;;

       # If file exists in acceptable directory, open and return it...
       if (-r $path) {
           open my $fh, &#39;&amp;lt;&#39;, $path
               or croak( &amp;quot;Located $filename at $path, but could not open&amp;quot;);
           return $fh;
       }
   }

   # Fail if all possible locations tried without success...
   croak( &amp;quot;Could not locate $filename&amp;quot; );
}

# and later...
for my $filename (@source_files) {
   my $fh = locate_and_open($filename);
   my $head = load_header_from($fh);
   print $head;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that the main &lt;code&gt;for&lt;/code&gt; loop didn&amp;rsquo;t change at all. The developer using &lt;code&gt;locate_and_open()&lt;/code&gt; still assumes that nothing can go wrong. Now there&amp;rsquo;s some justification for that expectation, because if anything does go wrong, the thrown exception will automatically terminate the loop.&lt;/p&gt;

&lt;p&gt;Exceptions are a better choice even if you are the careful type who religiously checks every return value for failure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SOURCE_FILE:
for my $filename (@source_files) {
   my $fh = locate_and_open($filename);
   next SOURCE_FILE if !defined $fh;
   my $head = load_header_from($fh);
   next SOURCE_FILE if !defined $head;
   print $head;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Constantly checking return values for failure clutters your code with validation statements, often greatly decreasing its readability. In contrast, exceptions allow an algorithm to be implemented without having to intersperse any error-handling infrastructure at all. You can factor the error-handling out of the code and either relegate it to after the surrounding &lt;code&gt;eval&lt;/code&gt;, or else dispense with it entirely:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for my $filename (@directory_path) {

   # Just ignore any source files that don&#39;t load...
   eval {
       my $fh = locate_and_open($filename);
       my $head = load_header_from($fh);
       print $head;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;9-add-new-test-cases-before-you-start-debugging&#34;&gt;9. Add New Test Cases Before you Start Debugging&lt;/h3&gt;

&lt;p&gt;The first step in any debugging process is to isolate the incorrect behavior of the system, by producing the shortest demonstration of it that you reasonably can. If you&amp;rsquo;re lucky, this may even have been done for you:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;To: DCONWAY@cpan.org
From: sascha@perlmonks.org
Subject: Bug in inflect module

Zdravstvuite,

I have been using your Lingua::EN::Inflect module to normalize terms in a
data-mining application I am developing, but there seems to be a bug in it,
as the following example demonstrates:

   use Lingua::EN::Inflect qw( PL_N );
   print PL_N(&#39;man&#39;), &amp;quot;\n&amp;quot;;       # Prints &amp;quot;men&amp;quot;, as expected
   print PL_N(&#39;woman&#39;), &amp;quot;\n&amp;quot;;     # Incorrectly prints &amp;quot;womans&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once you have distilled a short working example of the bug, convert it to a series of tests, such as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Lingua::EN::Inflect qw( PL_N );
use Test::More qw( no_plan );
is(PL_N(&#39;man&#39;) ,  &#39;men&#39;, &#39;man -&amp;gt; men&#39;     );
is(PL_N(&#39;woman&#39;), &#39;women&#39;, &#39;woman -&amp;gt; women&#39; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Don&amp;rsquo;t try to fix the problem straight away, though. Instead, immediately add those tests to your test suite. If that testing has been well set up, that can often be as simple as adding a couple of entries to a table:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my %plural_of = (
   &#39;mouse&#39;         =&amp;gt; &#39;mice&#39;,
   &#39;house&#39;         =&amp;gt; &#39;houses&#39;,
   &#39;ox&#39;            =&amp;gt; &#39;oxen&#39;,
   &#39;box&#39;           =&amp;gt; &#39;boxes&#39;,
   &#39;goose&#39;         =&amp;gt; &#39;geese&#39;,
   &#39;mongoose&#39;      =&amp;gt; &#39;mongooses&#39;,
   &#39;law&#39;           =&amp;gt; &#39;laws&#39;,
   &#39;mother-in-law&#39; =&amp;gt; &#39;mothers-in-law&#39;,

   # Sascha&#39;s bug, reported 27 August 2004...
   &#39;man&#39;           =&amp;gt; &#39;men&#39;,
   &#39;woman&#39;         =&amp;gt; &#39;women&#39;,
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The point is: if the original test suite didn&amp;rsquo;t report this bug, then that test suite was broken. It simply didn&amp;rsquo;t do its job (finding bugs) adequately. Fix the test suite first by adding tests that cause it to fail:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; perl inflections.t
ok 1 - house -&amp;gt; houses
ok 2 - law -&amp;gt; laws
ok 3 - man -&amp;gt; men
ok 4 - mongoose -&amp;gt; mongooses
ok 5 - goose -&amp;gt; geese
ok 6 - ox -&amp;gt; oxen
not ok 7 - woman -&amp;gt; women
#     Failed test (inflections.t at line 20)
#          got: &#39;womans&#39;
#     expected: &#39;women&#39;
ok 8 - mother-in-law -&amp;gt; mothers-in-law
ok 9 - mouse -&amp;gt; mice
ok 10 - box -&amp;gt; boxes
1..10
# Looks like you failed 1 tests of 10.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once the test suite is detecting the problem correctly, then you&amp;rsquo;ll be able to tell when you&amp;rsquo;ve correctly fixed the actual bug, because the tests will once again fall silent.&lt;/p&gt;

&lt;p&gt;This approach to debugging is most effective when the test suite covers the full range of manifestations of the problem. When adding test cases for a bug, don&amp;rsquo;t just add a single test for the simplest case. Make sure you include the obvious variations as well:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my %plural_of = (
   &#39;mouse&#39;         =&amp;gt; &#39;mice&#39;,
   &#39;house&#39;         =&amp;gt; &#39;houses&#39;,
   &#39;ox&#39;            =&amp;gt; &#39;oxen&#39;,
   &#39;box&#39;           =&amp;gt; &#39;boxes&#39;,
   &#39;goose&#39;         =&amp;gt; &#39;geese&#39;,
   &#39;mongoose&#39;      =&amp;gt; &#39;mongooses&#39;,
   &#39;law&#39;           =&amp;gt; &#39;laws&#39;,
   &#39;mother-in-law&#39; =&amp;gt; &#39;mothers-in-law&#39;,

   # Sascha&#39;s bug, reported 27 August 2004...
   &#39;man&#39;           =&amp;gt; &#39;men&#39;,
   &#39;woman&#39;         =&amp;gt; &#39;women&#39;,
   &#39;human&#39;         =&amp;gt; &#39;humans&#39;,
   &#39;man-at-arms&#39;   =&amp;gt; &#39;men-at-arms&#39;,
   &#39;lan&#39;           =&amp;gt; &#39;lans&#39;,
   &#39;mane&#39;          =&amp;gt; &#39;manes&#39;,
   &#39;moan&#39;          =&amp;gt; &#39;moans&#39;,
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The more thoroughly you test the bug, the more completely you will fix it.&lt;/p&gt;

&lt;h3 id=&#34;10-don-t-optimize-code-benchmark-it&#34;&gt;10. Don&amp;rsquo;t Optimize Code&amp;ndash;Benchmark It&lt;/h3&gt;

&lt;p&gt;If you need a function to remove duplicate elements of an array, it&amp;rsquo;s natural to think that a &amp;ldquo;one-liner&amp;rdquo; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub uniq { return keys %{ { map {$_=&amp;gt;1} @_ } } }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will be more efficient than two statements:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub uniq {
   my %seen;
   return grep {!$seen{$_}++} @_;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unless you are deeply familiar with the internals of the Perl interpreter (in which case you already have far more serious personal issues to deal with), intuitions about the relative performance of two constructs are exactly that: unconscious guesses.&lt;/p&gt;

&lt;p&gt;The only way to know for sure which of two&amp;ndash;or more&amp;ndash;alternatives will perform better is to actually time each of them. The standard &lt;a href=&#34;https://metacpan.org/pod/Benchmark&#34;&gt;Benchmark&lt;/a&gt; module makes that easy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# A short list of not-quite-unique values...
our @data = qw( do re me fa so la ti do );

# Various candidates...
sub unique_via_anon {
   return keys %{ { map {$_=&amp;gt;1} @_ } };
}

sub unique_via_grep {
   my %seen;
   return grep { !$seen{$_}++ } @_;
}

sub unique_via_slice {
   my %uniq;
   @uniq{@_} = ();
   return keys %uniq;
}

# Compare the current set of data in @data
sub compare {
   my ($title) = @_;
   print &amp;quot;\n[$title]\n&amp;quot;;

   # Create a comparison table of the various timings, making sure that
   # each test runs at least 10 CPU seconds...
   use Benchmark qw( cmpthese );
   cmpthese -10, {
       anon  =&amp;gt; &#39;my @uniq = unique_via_anon(@data)&#39;,
       grep  =&amp;gt; &#39;my @uniq = unique_via_grep(@data)&#39;,
       slice =&amp;gt; &#39;my @uniq = unique_via_slice(@data)&#39;,
   };

   return;
}

compare(&#39;8 items, 10% repetition&#39;);

# Two copies of the original data...
@data = (@data) x 2;
compare(&#39;16 items, 56% repetition&#39;);

# One hundred copies of the original data...
@data = (@data) x 50;
compare(&#39;800 items, 99% repetition&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;cmpthese()&lt;/code&gt; subroutine takes a number, followed by a reference to a hash of tests. The number specifies either the exact number of times to run each test (if the number is positive), or the absolute number of CPU seconds to run the test for (if the number is negative). Typical values are around 10,000 repetitions or ten CPU seconds, but the module will warn you if the test is too short to produce an accurate benchmark.&lt;/p&gt;

&lt;p&gt;The keys of the test hash are the names of your tests, and the corresponding values specify the code to be tested. Those values can be either strings (which are &lt;code&gt;eval&lt;/code&gt;&amp;rsquo;d to produce executable code) or subroutine references (which are called directly).&lt;/p&gt;

&lt;p&gt;The benchmarking code shown above would print out something like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[8 items, 10% repetitions]
        Rate anon  grep slice
anon  28234/s --  -24%  -47%
grep  37294/s   32% --  -30%
slice 53013/s   88% 42%    --

[16 items, 50% repetitions]
        Rate anon  grep slice
anon  21283/s --  -28%  -51%
grep  29500/s   39% --  -32%
slice 43535/s  105% 48%    --

[800 items, 99% repetitions]
       Rate  anon grep slice
anon   536/s --  -65%  -89%
grep  1516/s  183% --  -69%
slice 4855/s  806%  220% --
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each of the tables printed has a separate row for each named test. The first column lists the absolute speed of each candidate in repetitions per second, while the remaining columns allow you to compare the relative performance of any two tests. For example, in the final test tracing across the &lt;code&gt;grep&lt;/code&gt; row to the &lt;code&gt;anon&lt;/code&gt; column reveals that the &lt;code&gt;grep&lt;/code&gt;ped solution was 1.83 times (183 percent) faster than using an anonymous hash. Tracing further across the same row also indicates that &lt;code&gt;grep&lt;/code&gt;ping was 69 percent slower (-69 percent faster) than slicing.&lt;/p&gt;

&lt;p&gt;Overall, the indication from the three tests is that the slicing-based solution is consistently the fastest for this particular set of data on this particular machine. It also appears that as the data set increases in size, slicing also scales much better than either of the other two approaches.&lt;/p&gt;

&lt;p&gt;However, those two conclusions are effectively drawn from only three data points (namely, the three benchmarking runs). To get a more definitive comparison of the three methods, you&amp;rsquo;d also need to test other possibilities, such as a long list of non-repeating items, or a short list with nothing but repetitions.&lt;/p&gt;

&lt;p&gt;Better still, test on the real data that you&amp;rsquo;ll actually be &amp;ldquo;unique-ing.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;For example, if that data is a sorted list of a quarter of a million words, with only minimal repetitions, and which has to remain sorted, then test exactly that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;our @data = slurp &#39;/usr/share/biglongwordlist.txt&#39;;

use Benchmark qw( cmpthese );

cmpthese 10, {
    # Note: the non-grepped solutions need a post-uniqification re-sort
    anon  =&amp;gt; &#39;my @uniq = sort(unique_via_anon(@data))&#39;,
    grep  =&amp;gt; &#39;my @uniq = unique_via_grep(@data)&#39;,
    slice =&amp;gt; &#39;my @uniq = sort(unique_via_slice(@data))&#39;,
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not surprisingly, this benchmark indicates that the &lt;code&gt;grep&lt;/code&gt;ped solution is markedly superior on a large sorted data set:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s/iter anon slice  grep
anon    4.28 --   -3%  -46%
slice   4.15 3%    --  -44%
grep    2.30 86%   80%    --
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perhaps more interestingly, the &lt;code&gt;grep&lt;/code&gt;ped solution still benchmarks as being marginally faster when the two hash-based approaches aren&amp;rsquo;t re-sorted. This suggests that the better scalability of the sliced solution as seen in the earlier benchmark is a localized phenomenon, and is eventually undermined by the growing costs of allocation, hashing, and bucket-overflows as the sliced hash grows very large.&lt;/p&gt;

&lt;p&gt;Above all, that last example demonstrates that benchmarks only benchmark the cases you actually benchmark, and that you can only draw useful conclusions about performance from benchmarking real data.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exegesis 7</title>
      <link>http://localhost:1313/pub/2004/02/27/exegesis7.html/</link>
      <pubDate>Fri, 27 Feb 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/02/27/exegesis7.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S07.html&#34;&gt;Synopsis 7&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;What a piece of work is Perl 6!
How noble in reason!
How infinite in faculty!
In &lt;code&gt;form&lt;/code&gt; how express and admirable!&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item__w%2e_shakespeare%2c_%22hamlet%22_%28perl_6_revisi&#34;&gt;– W. Shakespeare, &amp;ldquo;Hamlet&amp;rdquo; (Perl 6 revision)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Formats are Perl 5&amp;rsquo;s mechanism for creating text templates with fixed-width fields. Those fields are then filled in using values from prespecified package variables. They&amp;rsquo;re a useful tool for generating many types of plaintext reports – the &lt;em&gt;r&lt;/em&gt; in &lt;em&gt;Perl&lt;/em&gt;, if you will.&lt;/p&gt;

&lt;p&gt;Unlike Perl 5, Perl 6 doesn&amp;rsquo;t have a &lt;code&gt;format&lt;/code&gt; keyword. Or the associated built-in formatting mechanism. Instead it has a Form.pm module. And a &lt;code&gt;form&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;Like a Perl 5 &lt;code&gt;format&lt;/code&gt; statement, the &lt;code&gt;form&lt;/code&gt; function takes a series of format (or &amp;ldquo;picture&amp;rdquo;) strings, each of which is immediately followed by a suitable set of replacement values. It interpolates those values into the placeholders specified within each picture string, and returns the result.&lt;/p&gt;

&lt;p&gt;The general idea is the same as for Perl&amp;rsquo;s two other built-in string formatting functions: &lt;code&gt;sprintf&lt;/code&gt; and &lt;code&gt;pack&lt;/code&gt;. The first argument represents a template with &lt;em&gt;N&lt;/em&gt; placeholders to be filled in, and the next &lt;em&gt;N&lt;/em&gt; arguments are the data that is to be formatted and interpolated into those placeholders:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $text = sprintf $format_s, $datum1, $datum2, $datum3;
    $text =    pack $format_p, $datum1, $datum2, $datum3;
    $text =    form $format_f, $datum1, $datum2, $datum3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, these three functions use quite different mini-languages to specify the templates they fill in, and all three fill in those templates in quite distinct ways.&lt;/p&gt;

&lt;p&gt;Apart from those differences in semantics, &lt;code&gt;form&lt;/code&gt; has a syntactic difference too. With &lt;code&gt;form&lt;/code&gt;, after the first &lt;em&gt;N&lt;/em&gt; data arguments we&amp;rsquo;re allowed to put a second format string and its corresponding data, then a third format and data, and so on:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $text = form $format_f1, $datum1, $datum2, $format_f2, $datum4, $format_f3, $datum5;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And if we prettify that function call a little, it becomes obvious that it has the same basic structure as a Perl 5 &lt;code&gt;format&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    form
         $format_f1,
             $datum1, $datum2, $datum3,
         $format_f2,
             $datum4,
         $format_f3,
             $datum5;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But the Perl 6 version is implemented as a vanilla Perl 6 subroutine, rather than hard-coded into the language with a special keyword and declaration syntax. In this respect it&amp;rsquo;s rather like Perl 5&amp;rsquo;s little-known &lt;code&gt;formline&lt;/code&gt; function – only much, much better.&lt;/p&gt;

&lt;p&gt;So, whereas in Perl 5 we might write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Perl 5 code...

    our ($name, $age, $ID, $comments);

    format STDOUT
     ===================================
    | NAME     |    AGE     | ID NUMBER |
    |----------+------------+-----------|
    | @&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; | @||||||||| | @&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; |
      $name,     $age,        $ID,
    |===================================|
    | COMMENTS                          |
    |-----------------------------------|
    | ^&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; |~~
      $comments,
     ===================================
    .

    write STDOUT;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in Perl 6 we could write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        &amp;quot; =================================== &amp;quot;,
        &amp;quot;| NAME     |    AGE     | ID NUMBER |&amp;quot;,
        &amp;quot;|----------+------------+-----------|&amp;quot;,
        &amp;quot;| {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;} | {||||||||} | {&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;} |&amp;quot;,
           $name,     $age,        $ID,
        &amp;quot;|===================================|&amp;quot;,
        &amp;quot;| COMMENTS                          |&amp;quot;,
        &amp;quot;|-----------------------------------|&amp;quot;,
        &amp;quot;| {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[} |&amp;quot;,
           $comments,
        &amp;quot; =================================== &amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And both of them would print something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     ===================================
    | NAME     |    AGE     | ID NUMBER |
    |----------+------------+-----------|
    | Richard  |     33     |    000003 |
    |===================================|
    | COMMENTS                          |
    |-----------------------------------|
    | Talks to self. Seems to be        |
    | overcompensating for inferiority  |
    | complex rooted in post-natal      |
    | materal rejection due to physical |
    | handicap (congenital or perhaps   |
    | the result of premature birth).   |
    | Shows numerous indications of     |
    | psychotic (esp. nepocidal)        |
    | tendencies. Naturally, subject    |
    | gravitated to career in politics. |
     ===================================
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At first glance the Perl 6 version may seem like something of a backwards step – all those extra quotation marks and commas that the Perl 5 format didn&amp;rsquo;t require. But the new formatting interface does have several distinct advantages:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;it uses the standard Perl 6 subroutine call syntax, so we can use the full power of Perl data structures and control flow when setting up formats;&lt;/li&gt;
&lt;li&gt;it delimits every field specification by braces, which allows for a much wider range of field types;&lt;/li&gt;
&lt;li&gt;it removes the special meanings of &lt;code&gt;&#39;@&#39;&lt;/code&gt;, &lt;code&gt;&#39;^&#39;&lt;/code&gt;, &lt;code&gt;&#39;~&#39;&lt;/code&gt;, and &lt;code&gt;&#39;.&#39;&lt;/code&gt; in formats, leaving only &lt;code&gt;&#39;{&#39;&lt;/code&gt; as special;&lt;/li&gt;
&lt;li&gt;it provides &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=13#define,_define,_welleducated_infant.&#34;&gt;an extension mechanism&lt;/a&gt; for creating new field types;&lt;/li&gt;
&lt;li&gt;it greatly simplifies the common task of formatting data into a string (rather than requiring the format data to be written to an output stream);&lt;/li&gt;
&lt;li&gt;it doesn&amp;rsquo;t destroy the contents of data variables when formatting them across multiple lines;&lt;/li&gt;
&lt;li&gt;it&amp;rsquo;s easy to create new formats on-the-fly, rather than being forced to statically declare them at compile-time (or in a run-time string &lt;code&gt;eval&lt;/code&gt;);&lt;/li&gt;
&lt;li&gt;it allows calls to &lt;code&gt;form&lt;/code&gt; to be nested;&lt;/li&gt;
&lt;li&gt;it supports dynamically computed page headers and footers, which may themselves make use of nested calls to &lt;code&gt;form&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;it doesn&amp;rsquo;t rely on package variables, typeglobs, or a global accumulator;&lt;/li&gt;
&lt;li&gt;it doesn&amp;rsquo;t require a (frequently cryptic) call to the mysterious &lt;code&gt;write&lt;/code&gt; function – and hence frees up &lt;code&gt;write&lt;/code&gt; to be used as the true opposite of &lt;code&gt;read&lt;/code&gt;, should Larry so desire.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Of course, this is Perl, not Puritanism. So those folks who happen to &lt;em&gt;like&lt;/em&gt; package variables, global accumulators, and mysterious writes, can still have them. And, if they&amp;rsquo;re particularly nostalgic, they can also get rid of all the quotation marks and commas, and even retain the dot as a format terminator. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub myster_rite {
        our ($name, $age, $ID, $comments);
        print form :interleave, &amp;lt;&amp;lt;&#39;.&#39;
             ===================================
            | NAME     |    AGE     | ID NUMBER |
            |----------+------------+-----------|
            | {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;} | {||||||||} | {&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;} |
            |===================================|
            | COMMENTS                          |
            |-----------------------------------|
            | {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[} |
             ===================================
            .
              $name,     $age,        $ID,
              $comments;
    }

    # and elsewhere in the same package...

    ($name, $age, $ID, $comments) = get_data();
    myster_rite();

    ($name, $age, $ID, $comments) = get_more_data();
    myster_rite();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s take a look&amp;hellip;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-what-s-in-a-name-what-s-in-a-name-span&#34;&gt;&lt;span id=&#34;what&#39;s_in_a_name&#34;&gt;What&amp;rsquo;s in a name?&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;But before we do, here&amp;rsquo;s a quick run-down of some of the highly arcane technical jargon we&amp;rsquo;ll be using as we talk about formatting:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_format&#34;&gt;Format&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A string that is used as a template for the creation of &lt;em&gt;text&lt;/em&gt;. It will contain zero or more &lt;em&gt;fields&lt;/em&gt;, usually with some literal characters and whitespace between them.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_text&#34;&gt;Text&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A string that is created by replacing the fields of a format with specific &lt;em&gt;data&lt;/em&gt; values. For example, the string that a call to &lt;code&gt;form&lt;/code&gt; returns.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_field&#34;&gt;Field&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A fixed-width slot within a format string, into which &lt;em&gt;data&lt;/em&gt; will be formatted.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_data&#34;&gt;Data&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A string or numeric value (or an array of such values) that is interpolated into a format, in order to fill in a particular field.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_single%2dline_field&#34;&gt;Single-line field&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A field that interpolates only as much of its corresponding data value as will fit inside it within a single line of text.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_block_field&#34;&gt;Block field&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A field that interpolates all of its corresponding data value, over a series of text lines – as many as necessary – producing a &lt;em&gt;text block&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_text_block&#34;&gt;Text block&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The column of newline-separated text lines. A text block is produced when data is formatted into a block field that is too small to contain the data in a single line&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_column&#34;&gt;Column&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The amount of space on an output device required to display one single-width character. One character will occupy one column in most cases, the most obvious exceptions being CJK double-width characters.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S07.html&#34;&gt;Synopsis 7&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-why-how-now-ho-from-whence-ariseth-this-why-how-now-ho-from-whence-ariseth-this-span&#34;&gt;&lt;span id=&#34;why,_how_now,_ho!_from_whence_ariseth_this&#34;&gt;Why, how now, ho! From whence ariseth this?&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Unlike &lt;code&gt;sprintf&lt;/code&gt; and &lt;code&gt;pack&lt;/code&gt;, the &lt;code&gt;form&lt;/code&gt; subroutine isn&amp;rsquo;t built into Perl 6. It&amp;rsquo;s just a regular subroutine, defined in the Form.pm module:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    module Form
    {
        type FormArgs ::= Str|Array|Pair;

        sub form (FormArgs *@args is context(Scalar)) returns Str
            is exported
        {
            ...
        }

        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That means that if we want to use &lt;code&gt;form&lt;/code&gt; we need to be sure we:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Form;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;first.&lt;/p&gt;

&lt;p&gt;Note that the above definition of &lt;code&gt;form&lt;/code&gt; specifies that the subroutine takes a list of arguments (&lt;code&gt;*@args&lt;/code&gt;), each of which must be a string, array or pair (&lt;code&gt;type FormArgs ::= Str|Num|Array|Pair&lt;/code&gt;). And the &lt;code&gt;is context&lt;/code&gt; trait specifies that each of those arguments will be evaluated in a scalar context.&lt;/p&gt;

&lt;p&gt;That last bit is important, because normally a &amp;ldquo;slurpy&amp;rdquo; array parameter like &lt;code&gt;*@args&lt;/code&gt; would impose a list context on the corresponding arguments. We don&amp;rsquo;t want that here, mainly because we&amp;rsquo;re going to want to be able to &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=3#therefore,_put_you_in_your_best_array...&#34;&gt;pass arrays to &lt;code&gt;form&lt;/code&gt;&lt;/a&gt; without having them flattened.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-how-called-you-how-called-you-span&#34;&gt;&lt;span id=&#34;how_called_you...&#34;&gt;How called you&amp;hellip;?&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Like all Perl subroutines, &lt;code&gt;form&lt;/code&gt; can be called in a variety of contexts.&lt;/p&gt;

&lt;p&gt;When called in a scalar or list context, &lt;code&gt;form&lt;/code&gt; returns a string containing the complete formatted text:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $formatted_text = form $format, *@data;

    @texts = ( form($format, *@data1), form($format, *@data2) );  # 2 elems
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When called in a void context, &lt;code&gt;form&lt;/code&gt; waxes lyrical about human frailty, betrayal of trust, and the pointlessness of calling out when nobody&amp;rsquo;s there to heed the reply, before dying in a highly theatrical manner.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-he-doth-fill-fields-he-doth-fill-fields-span&#34;&gt;&lt;span id=&#34;he_doth_fill_fields...&#34;&gt;He doth fill fields&amp;hellip;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The format strings passed to &lt;code&gt;form&lt;/code&gt; determine what the resulting formatted text looks like. Each format consists of a series of field specifiers, which are usually separated by literal characters.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;form&lt;/code&gt; understands a far larger number of field specifiers than &lt;code&gt;format&lt;/code&gt; did, but they&amp;rsquo;re easy to remember because they obey a small number of conventions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Each field is enclosed in a pair of braces.&lt;/li&gt;
&lt;li&gt;Within the braces, left or right angle brackets (&lt;code&gt;&amp;lt;&lt;/code&gt; or &lt;code&gt;&amp;gt;&lt;/code&gt;), bars (&lt;code&gt;|&lt;/code&gt;), and single-quotes (&lt;code&gt;&#39;&lt;/code&gt;) indicate various types of single-line fields.&lt;/li&gt;
&lt;li&gt;Left or right square brackets (&lt;code&gt;[&lt;/code&gt; or &lt;code&gt;]&lt;/code&gt;), I&amp;rsquo;s (&lt;code&gt;I&lt;/code&gt;), and double- quotes (&lt;code&gt;&amp;quot;&lt;/code&gt;) indicate block fields of various types.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The direction of the brackets within a field indicates the direction towards which text will be justified in that field. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}   Justify the text to the left
    {&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;}                  Justify the text to the right
    {&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}                 Centre the text
    {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;}   Fully  justify  the  text  to  both  margins
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is even true for numeric fields, which look like: &lt;code&gt;{&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;.&amp;lt;&amp;lt;}&lt;/code&gt;. The whole digits are right-justified before the dot and the decimals are left-justified after it.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;An &lt;code&gt;=&lt;/code&gt; at either end of a field (or both ends) indicates the data interpolated into the field is to be vertically &amp;ldquo;middled&amp;rdquo; within the resulting block. That is, the text is to be centred vertically on the middle of all the lines produced by the complete format.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;An &lt;code&gt;_&lt;/code&gt; at the start and/or end of a field indicates the interpolated data is to be vertically &amp;ldquo;bottomed&amp;rdquo; within the resulting block. That is, the text is to be pushed to the bottom of the lines produced by the format.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-the-fields-are-fragrant-the-fields-are-fragrant-span&#34;&gt;&lt;span id=&#34;the_fields_are_fragrant...&#34;&gt;The fields are fragrant&amp;hellip;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;That may still seem like quite a lot to remember, but the rules have been chosen so that the resulting fields are visually mnemonic. In other words, they&amp;rsquo;re supposed to look like what they do. The intention is that we simply draw a (stylized) picture of how we want the finished text to look, using fields that look something like the finished product – left or right brackets brackets showing horizontal alignments, a middlish &lt;code&gt;=&lt;/code&gt; or bottomed-out &lt;code&gt;_&lt;/code&gt; indicate middled or bottom vertical alignment, etc., etc. Then &lt;code&gt;form&lt;/code&gt; fits our data into the fields so it looks right.&lt;/p&gt;

&lt;p&gt;The typical field specifications used in a &lt;code&gt;form&lt;/code&gt; format look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                                      Field specifier
    Field type                 One-line             Block
    ==========                ==========          ==========

    left justified            {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}          {[[[[[[[[}
    right justified           {&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;}          {]]]]]]]]}
    centred                   {&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}          {]]]][[[[}
    centred (alternative)     {||||||||}          {IIIIIIII}
    fully justified           {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;}          {[[[[]]]]}
    verbatim                  {&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;}          {&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;}

    numeric                   {&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;.&amp;lt;&amp;lt;}          {]]]]].[[}
    euronumeric               {&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;,&amp;lt;&amp;lt;}          {]]]]],[[}
    comma&#39;d                   {&amp;gt;,&amp;gt;&amp;gt;&amp;gt;,&amp;gt;&amp;gt;&amp;gt;.&amp;lt;&amp;lt;}      {],]]],]]].[[}
    space&#39;d                   {&amp;gt; &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt;.&amp;lt;&amp;lt;}      {] ]]] ]]].[[}
    eurocomma&#39;d               {&amp;gt;.&amp;gt;&amp;gt;&amp;gt;.&amp;gt;&amp;gt;&amp;gt;,&amp;lt;&amp;lt;}      {].]]].]]],[[}
    Swiss Army comma&#39;d        {&amp;gt;&#39;&amp;gt;&amp;gt;&amp;gt;&#39;&amp;gt;&amp;gt;&amp;gt;,&amp;lt;&amp;lt;}      {]&#39;]]]&#39;]]],[[}
    subcontinental            {&amp;gt;&amp;gt;,&amp;gt;&amp;gt;,&amp;gt;&amp;gt;&amp;gt;.&amp;lt;&amp;lt;}      {]],]],]]].[[}

    signed numeric            {-&amp;gt;&amp;gt;&amp;gt;.&amp;lt;&amp;lt;&amp;lt;}          {-]]].[[[}
    post-signed numeric       {&amp;gt;&amp;gt;&amp;gt;&amp;gt;.&amp;lt;&amp;lt;-}          {]]]].[[-}
    paren-signed numeric      {(&amp;gt;&amp;gt;&amp;gt;.&amp;lt;&amp;lt;)}          {(]]].[[)}

    prefix currency           {$&amp;gt;&amp;gt;&amp;gt;.&amp;lt;&amp;lt;&amp;lt;}          {$]]].[[[}
    postfix currency          {&amp;gt;&amp;gt;&amp;gt;.&amp;lt;&amp;lt;&amp;lt;DM}         {]]].[[[DM}
    infix currency            {&amp;gt;&amp;gt;&amp;gt;$&amp;lt;&amp;lt; Esc}        {]]]$[[ Esc}

    left/middled              {=&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;=}          {=[[[[[[=}
    right/middled             {=&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;=}          {=]]]]]]=}
    infix currency/middled    {=&amp;gt;&amp;gt;$&amp;lt;&amp;lt; Esc}        {=]]$[[ Esc}
    eurocomma&#39;d/middled       {&amp;gt;.&amp;gt;&amp;gt;&amp;gt;.&amp;gt;&amp;gt;&amp;gt;,&amp;lt;&amp;lt;=}     {].]]].]]],[[=}
    etc.

    left/bottomed             {_&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;_}          {_[[[[[[_}
    right/bottomed            {_&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;_}          {_]]]]]]_}
    etc.
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-what-a-block-art-thou-what-a-block-art-thou-span&#34;&gt;&lt;span id=&#34;what_a_block_art_thou...&#34;&gt;What a block art thou&amp;hellip;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;When data is interpolated into a line field, the field grabs as much of the data as will fit on a single line, formats that data appropriately, and interpolates it into the format.&lt;/p&gt;

&lt;p&gt;That means that if we use a one-line field, it only shows as much of the data as will fit on one line. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $data1 = &#39;By the pricking of my thumbs, something wicked this way comes&#39;;
    my $data2 = &#39;A horse! A horse! My kingdom for a horse!&#39;;

    print form
        &amp;quot;...{&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}...{&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;}...&amp;quot;,
            $data1,               $data2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;prints:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ...By the pricking of ... A horse!...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the other hand, if our format string used block fields instead, the fields would extract one line of data at a time, repeating that process as many times as necessary to display all the available data. So:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        &amp;quot;...{[[[[[[[[[[[[[[[[[}...{]]]]]]]}...&amp;quot;,
            $data1,               $data2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;would produce:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ...By the pricking of ... A horse!...
    ...my thumbs,         ... A horse!...
    ...something wicked   ...       My...
    ...this way comes     ...  kingdom...
    ...                   ...    for a...
    ...                   ...   horse!...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can mix line fields and block fields in the same format and &lt;code&gt;form&lt;/code&gt; will extract and interpolate only as much data as each field requires. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        &amp;quot;...{&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}...{]]]]]]]}...&amp;quot;,
            $data1,               $data2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which produces:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ...By the pricking of ... A horse!...
    ...                   ... A horse!...
    ...                   ...       My...
    ...                   ...  kingdom...
    ...                   ...    for a...
    ...                   ...   horse!...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that, after the first line, the single-line &lt;code&gt;{&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}&lt;/code&gt; field is simply replaced by the appropriate number of space characters, to keep the columns correctly aligned.&lt;/p&gt;

&lt;p&gt;The usual reason for mixing line and block fields in this way is to allow numbered or bulleted points:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print &amp;quot;I couldn&#39;t do my English Lit homework because...\n\n&amp;quot;;

    for @reasons.kv -&amp;gt; $index, $reason {
        my $n = @reasons - $index ~ &#39;.&#39;;
        print form &amp;quot;   {&amp;gt;}  {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[}&amp;quot;,
                       $n,  $reason,
                   &amp;quot;&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which might produce:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    I couldn&#39;t do my English Lit homework because...

         10. Three witches told me I was going to be
             king.

          9. I was busy explaining wherefore am I Romeo.

          8. I was busy scrubbing the blood off my
             hands.

          7. Some dear friends had to charge once more
             unto the breach.

          6. My so-called best friend tricked me into
             killing my wife.

          5. My so-called best friend tricked me into
             killing Caesar.

          4. My so-called best friend tricked me into
             taming a shrew.

          3. My uncle killed my father and married my
             mother.

          2. I fell in love with my manservant, who was
             actually the disguised twin sister of the
             man that my former love secretly married,
             having mistaken him for my manservant who
             was wooing her on my behalf whilst secretly
             in love with me.

          1. I was abducted by fairies.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S07.html&#34;&gt;Synopsis 7&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-and-mark-what-way-i-make-and-mark-what-way-i-make-span&#34;&gt;&lt;span id=&#34;and_mark_what_way_i_make...&#34;&gt;And mark what way I make&amp;hellip;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Obviously, as a call to &lt;code&gt;form&lt;/code&gt; builds up each line of its output – extracting data from one or more data arguments and formatting it into the corresponding fields – it needs to keep track of where it&amp;rsquo;s up to in each datum. It does this by progressively updating the &lt;code&gt;.pos&lt;/code&gt; of each datum, in exactly the same way as a pattern match does.&lt;/p&gt;

&lt;p&gt;And as with a pattern match, by default that updated &lt;code&gt;.pos&lt;/code&gt; is only used internally and &lt;strong&gt;not&lt;/strong&gt; preserved after the call to &lt;code&gt;form&lt;/code&gt; is finished. So passing a string to &lt;code&gt;form&lt;/code&gt; doesn&amp;rsquo;t interfere with any other pattern matching or text formatting that we might subsequently do with that data.&lt;/p&gt;

&lt;p&gt;However, sometimes we &lt;em&gt;do&lt;/em&gt; want to know how much of our data a call to &lt;code&gt;form&lt;/code&gt; managed to extract and format. Or we may want to split a formatting task into several stages, with separate calls to &lt;code&gt;form&lt;/code&gt; for each stage. So we need a way of telling &lt;code&gt;form&lt;/code&gt; to preserve the &lt;code&gt;.pos&lt;/code&gt; information in our data.&lt;/p&gt;

&lt;p&gt;But, if we want to apply a series of &lt;code&gt;form&lt;/code&gt; calls to the same data we also need to be able to tell &lt;code&gt;form&lt;/code&gt; to &lt;em&gt;respect&lt;/em&gt; the &lt;code&gt;.pos&lt;/code&gt; information of that data – to start extracting from the previously preserved &lt;code&gt;.pos&lt;/code&gt; position, rather than from the start of the string.&lt;/p&gt;

&lt;p&gt;To achieve both those goals, we use a &lt;em&gt;follow-on field&lt;/em&gt;. That is we use an ordinary field but mark it as &lt;code&gt;.pos&lt;/code&gt;-sensitive with a special notation: Unicode ellipses or ASCII colons at either end. So instead of &lt;code&gt;{&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;}&lt;/code&gt;, we&amp;rsquo;d write &lt;code&gt;{…&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;…}&lt;/code&gt; or &lt;code&gt;{:&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;:}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note that each ellipsis is a single, one-column wide Unicode HORIZONTAL ELLIPSIS character (&lt;code&gt;\c[2026]&lt;/code&gt;), &lt;em&gt;not&lt;/em&gt; three separate dots. The connotation of the ellipses is &lt;em&gt;&amp;rdquo;&amp;hellip;then keep on formatting from where you previously left off, remembering there&amp;rsquo;s probably still more to come&amp;hellip;&amp;rdquo;&lt;/em&gt;. And the colons are the ASCII symbol most like a single character ellipsis (try tilting your head and squinting).&lt;/p&gt;

&lt;p&gt;Follow-on fields are most useful when we want to split a formatting task into distinct stages – or iterations – but still allow the contents of the follow-on field to flow uninterrupted from line to line. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print &amp;quot;The best Shakespearean roles are:\n\n&amp;quot;;

    for @roles -&amp;gt; $role {
        print form &amp;quot;   * {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}   *{…&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;…}*&amp;quot;,
                         $role,                            $disclaimer;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which produces:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    The best Shakespearean roles are:

       * Macbeth                          *WARNING:          *
       * King Lear                        *This list of roles*
       * Juliet                           *constitutes      a*
       * Othello                          *personal   opinion*
       * Hippolyta                        *only and is in  no*
       * Don John                         *way  endorsed   by*
       * Katerina                         *Shakespeare&#39;R&#39;Us. *
       * Richard                          *It   may   contain*
       * Malvolio                         *nuts.             *
       * Bottom                           *                  *
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The multiple calls to &lt;code&gt;form&lt;/code&gt; manage to produce a coherent disclaimer because the ellipses in the second field tell each call to start extracting data from &lt;code&gt;$disclaimer&lt;/code&gt; at the offset indicated by &lt;code&gt;$disclaimer.pos&lt;/code&gt;, and then to update &lt;code&gt;$disclaimer.pos&lt;/code&gt; with the final position at which the field extracted data. So the next time &lt;code&gt;form&lt;/code&gt; is called, the follow-on field starts extracting from where it left off in the previous call.&lt;/p&gt;

&lt;p&gt;Follow-on fields are similar to &lt;code&gt;^&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; fields in a Perl 5 format, except they don&amp;rsquo;t destroy the contents of a data source; they merely change that data source&amp;rsquo;s &lt;code&gt;.pos&lt;/code&gt; marker.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-therefore-put-you-in-your-best-array-therefore-put-you-in-your-best-array-span&#34;&gt;&lt;span id=&#34;therefore,_put_you_in_your_best_array...&#34;&gt;Therefore, put you in your best array&amp;hellip;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Data, especially numeric data, is often stored in arrays. So &lt;code&gt;form&lt;/code&gt; also accepts arrays as data arguments. It can do so because its parameter list is defined as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        sub form (Str|Array|Pair *@args is context(Scalar)) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which means that although its arguments may include one or more arrays, each such array argument is nevertheless evaluated in a scalar context. Which, in Perl 6, produces an array reference.&lt;/p&gt;

&lt;p&gt;In other words, array arguments don&amp;rsquo;t get flattened automatically, so &lt;code&gt;form&lt;/code&gt; doesn&amp;rsquo;t losing track of where in the argument list one array finishes and the next begins.&lt;/p&gt;

&lt;p&gt;Once inside &lt;code&gt;form&lt;/code&gt;, each array that was specified as the data source for a field is internally converted to a single string by joining it together with a newline between each element.&lt;/p&gt;

&lt;p&gt;The upshot is that, instead of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print &amp;quot;The best Shakespearean roles are:\n\n&amp;quot;;

    for @roles -&amp;gt; $role {
        print form &amp;quot;   * {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}   *{…&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;…}*&amp;quot;,
                         $role,                            $disclaimer;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we could just write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print &amp;quot;The best Shakespearean roles are:\n\n&amp;quot;;

    print form &amp;quot;   * {[[[[[[[[[[[[[[[[[[[[[[[[[[[[}   *{[[[[[[[[]]]]]]]]}*&amp;quot;,
                     @roles,                           $disclaimer;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the array of roles would be internally converted to a single string, with one role per line. Note that we also changed the disclaimer field to a regular block field, so that the entire disclaimer would be formatted. And there was no longer any need for the disclaimer field to be a follow-on field, since the block field would extract and format the entire disclaimer anyway.&lt;/p&gt;

&lt;p&gt;Note, however, that this block-based approach wouldn&amp;rsquo;t work so well if one of the elements of &lt;code&gt;@roles&lt;/code&gt; was too big to fit on a single line. In that case we might end up with something like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   The best Shakespearean roles are:

      * Either of the &#39;two foolish             *WARNING:          *
      * officers&#39;: Dogberry and Verges         *This list of roles*
      * That dour Scot, the Laird              *constitutes      a*
      * Macbeth                                *personal   opinion*
      * The tragic Moor of Venice,             *only and is in  no*
      * Othello                                *way  endorsed   by*
      * Rosencrantz&#39;s good buddy               *Shakespeare&#39;R&#39;Us. *
      * Guildenstern                           *It   may   contain*
      * The hideous and malevolent             *nuts.             *
      * Richard III                            *                  *
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;rather than:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   The best Shakespearean roles are:

      * Either of the &#39;two foolish             *WARNING:          *
        officers&#39;: Dogberry and Verges         *This list of roles*
      * That dour Scot, the Laird              *constitutes      a*
        Macbeth                                *personal   opinion*
      * The tragic Moor of Venice,             *only and is in  no*
        Othello                                *way  endorsed   by*
      * Rosencrantz&#39;s good buddy               *Shakespeare&#39;R&#39;Us. *
        Guildenstern                           *It   may   contain*
      * The hideous and malevolent             *nuts.             *
        Richard III                            *                  *
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s because the &lt;code&gt;&amp;quot;*&amp;quot;&lt;/code&gt; that&amp;rsquo;s being used as a bullet for the first column is a literal (i.e. mere decoration), and so it will be repeated on &lt;em&gt;every&lt;/em&gt; line that is formatted, regardless of whether that line is the start of a new element of &lt;code&gt;@roles&lt;/code&gt; or merely the broken-and-wrapped remains of the previous element. Happily, as we shall see later, this particular problem has &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=13#these_paper_bullets_of_the_brain...&#34;&gt;a simple solution&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Despite these minor complications, array data sources are particularly useful when formatting, especially if the data is known to fit within the specified width. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        &#39;-------------------------------------------&#39;,
        &#39;Name             Score   Time  | Normalized&#39;,
        &#39;-------------------------------------------&#39;,
        &#39;{[[[[[[[[[[[[}   {III}   {II}  |  {]]].[[} &#39;,
         @name,           @score, @time,   [@score »/« @time];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is a very easy way to produce the table:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    -------------------------------------------
    Name             Score   Time  | Normalized
    -------------------------------------------
    Thomas Mowbray    88      15   |     5.867
    Richard Scroop    54      13   |     4.154
    Harry Percy       99      18   |     5.5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note the use of the Perl6-ish listwise division (&lt;code&gt;»/«&lt;/code&gt;) to produce the array of data for the &amp;ldquo;Normalized&amp;rdquo; column.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-more-particulars-must-justify-my-knowledge-more-particulars-must-justify-my-knowledge-span&#34;&gt;&lt;span id=&#34;more_particulars_must_justify_my_knowledge...&#34;&gt;More particulars must justify my knowledge&amp;hellip;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The most commonly used fields are those that justify their contents: to the left, to the right, to the left &lt;em&gt;and&lt;/em&gt; right, or towards the centre.&lt;/p&gt;

&lt;p&gt;Left-justified and right-justified fields extract from their data source the largest substring that will fit inside them, push that string to the left or right as appropriate, and then pad the string out to the required field width with spaces (or the &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=10#he_doth_fill_fields_with_harness...&#34;&gt;nominated fill character&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Centred fields (&lt;code&gt;{&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}&lt;/code&gt; and &lt;code&gt;{]]]][[[[}&lt;/code&gt;) likewise extract as much data as possible, and then pad both sides of it with (near) equal numbers of spaces. If the amount of padding required is not evenly divisible by 2, the one extra space is added &lt;em&gt;after&lt;/em&gt; the data.&lt;/p&gt;

&lt;p&gt;There is a second syntax for centred fields – a tip-o&amp;rsquo;-the-hat to Perl 5 formats: &lt;code&gt;{|||||||||}&lt;/code&gt; and &lt;code&gt;{IIIIIIII}&lt;/code&gt;. This variant also makes it easier to specify centering fields that are only three columns wide: &lt;code&gt;{|}&lt;/code&gt; and &lt;code&gt;{I}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note, however, that the behaviour of centering fields specified this way is exactly the same in every respect as the bracket-based versions, so we&amp;rsquo;re free to use whichever we prefer.&lt;/p&gt;

&lt;p&gt;Fully justified fields (&lt;code&gt;{&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;}&lt;/code&gt; and &lt;code&gt;{[[[[]]]]}&lt;/code&gt;) extract a maximal substring and then distribute any padding as evenly as possible into the existing whitespace gaps in that data. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form &#39;({&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;})&#39;,
               &amp;quot;A fellow of infinite jest, of most excellent fancy&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;would print:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (A fellow  of  infinite)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A fully-justified block field (&lt;code&gt;{[[[[]]]]}&lt;/code&gt;) does the same across multiple lines, except that the very last line is always left-justified. Hence, this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form &#39;({[[[[[[[[]]]]]]]})&#39;,
               &amp;quot;All the world&#39;s a stage, And all the men and women merely players.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;would print:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (All the world&#39;s a)
    (stage,  And   all)
    (the men and women)
    (merely players.  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By the way, with both centred fields (&lt;code&gt;{&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;lt;&amp;lt;&amp;lt;}&lt;/code&gt;) and fully justified fields (&lt;code&gt;{&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;}&lt;/code&gt;), the actual number of left vs right arrows is irrelevant, so long as there is at least one of each.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-what-is-t-too-short-what-is-t-too-short-span&#34;&gt;&lt;span id=&#34;what,_is&#39;t_too_short&#34;&gt;What, is&amp;rsquo;t too short?&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;One special case we need to consider is an empty set of field delimiters:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    form &#39;ID number: {}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This specification is treated as a two-column-wide, left-justified block field (since that seems to be the type of two-column-wide field most often required).&lt;/p&gt;

&lt;p&gt;Other kinds of two-column (and single-column) fields can also be created using &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=9#what_you_will_command_me_will_i_do...&#34;&gt;imperative field widths&lt;/a&gt; and and &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=13#define,_define,_welleducated_infant.&#34;&gt;user-defined fields&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S07.html&#34;&gt;Synopsis 7&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-command-our-present-numbers-be-muster-d-command-our-present-numbers-be-muster-d-span&#34;&gt;&lt;span id=&#34;command_our_present_numbers_be_muster&#39;d...&#34;&gt;Command our present numbers be muster&amp;rsquo;d&amp;hellip;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;A field specifier of the form &lt;code&gt;{&amp;gt;&amp;gt;&amp;gt;&amp;gt;.&amp;lt;&amp;lt;}&lt;/code&gt; or &lt;code&gt;{]]]].[[}&lt;/code&gt; represents a decimal-aligned numeric field. The decimal marker always appears in exactly the position indicated and the rest of the number is aligned around it. The decimal places are rounded to the specific number of places indicated, but only &amp;ldquo;significant&amp;rdquo; digits are shown. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @nums = (1, 1.2, 1.23, 11.234, 111.235, 1.0001);

    print form &amp;quot;Thy score be: {]]]].[[}&amp;quot;,
                              @nums;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;prints:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Thy score be:     1.0
    Thy score be:     1.2
    Thy score be:     1.23
    Thy score be:    11.234
    Thy score be:   111.235
    Thy score be:     1.000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The points are all aligned, the minimal number of decimal places are shown, and the decimals are rounded (using the same rounding protocol that &lt;code&gt;printf&lt;/code&gt; employs). Note in particular that, even though both &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;1.0001&lt;/code&gt; would normally convert to the same 3-decimal-place value (&lt;code&gt;1.000&lt;/code&gt;), a &lt;code&gt;form&lt;/code&gt; call only shows all three zeros in the second case since only in the second case are they &amp;ldquo;significant&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;In other words, unless we &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=10#but_say_thou_nought...&#34;&gt;tell it otherwise&lt;/a&gt;, &lt;code&gt;form&lt;/code&gt; tries to avoid displaying a number with more accuracy than it actually possesses (within the constraint that it must always show at least one decimal place).&lt;/p&gt;

&lt;h4 id=&#34;span-id-here-are-only-numbers-ratified-here-are-only-numbers-ratified-span&#34;&gt;&lt;span id=&#34;here_are_only_numbers_ratified.&#34;&gt;Here are only numbers ratified.&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;You&amp;rsquo;re probably wondering what happens if we try to format a number that&amp;rsquo;s too large for the available places (as &lt;code&gt;123456.78&lt;/code&gt; would be in the above format). Whereas &lt;code&gt;sprintf&lt;/code&gt; would extend a numeric field to accommodate the number, &lt;code&gt;form&lt;/code&gt; insists on preserving the specified layout; in particular, the position of the decimal point. But it obviously can&amp;rsquo;t just cut off the extra high-order digits; that would change the value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Thy score be: 23456.78
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, instead, it indicates that the number doesn&amp;rsquo;t fit by filling the field with octothorpes (the way many spreadsheets do):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Thy score be: #####.###
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note, however, that it &lt;em&gt;is&lt;/em&gt; possible to &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=9#that_we_our_largest_bounty_may_extend...&#34;&gt;change this behaviour&lt;/a&gt; should we need to.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s also possible that someone (not you, of course!) might attempt to pass a numeric field some data that isn&amp;rsquo;t numeric at all:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @mixed_data = (1, 2, &amp;quot;three&amp;quot;, {4=&amp;gt;5}, &amp;quot;6&amp;quot;, &amp;quot;7-Up&amp;quot;);

    print form &#39;Thy score be: {]]]].[[}&#39;,
                              @mixed_data;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unlike Perl itself, &lt;code&gt;form&lt;/code&gt; doesn&amp;rsquo;t autoconvert non-numeric values. Instead it marks them with another special string, by filling the field with question-marks:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Thy score be:     1.0
    Thy score be:     2.0
    Thy score be: ?????.???
    Thy score be: ?????.???
    Thy score be:     6.0
    Thy score be: ?????.???
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that strings per se aren&amp;rsquo;t a problem – &lt;code&gt;form&lt;/code&gt; will happily convert strings that contain valid numbers, such as &lt;code&gt;&amp;quot;6&amp;quot;&lt;/code&gt; in the above example. But it does reject strings that contain anything else besides a number (even when Perl itself would successfully convert the number – as it would for &lt;code&gt;&amp;quot;7-Up&amp;quot;&lt;/code&gt; above).&lt;/p&gt;

&lt;p&gt;Those who&amp;rsquo;d prefer Perl&amp;rsquo;s usual, more laissez-faire attitude to numerical conversion can just pre-numerify the values themselves using the unary numerification operator (shown here in its list form – &lt;code&gt;+«&lt;/code&gt; – since we have an array of values to be numerified):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form &#39;Thy score be: {]]]].[[}&#39;,
                              +« @mixed_data;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This version would print:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Thy score be:     1.0
    Thy score be:     2.0
    Thy score be:     0.0
    Thy score be:     1.0
    Thy score be:     6.0
    Thy score be:     7.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(The &lt;code&gt;1.0&lt;/code&gt; on the fourth line appears because Perl 6 hashes numerify to the number of entries they contain).&lt;/p&gt;

&lt;h4 id=&#34;span-id-see-how-the-giddy-multitude-do-point-see-how-the-giddy-multitude-do-point-span&#34;&gt;&lt;span id=&#34;see_how_the_giddy_multitude_do_point...&#34;&gt;See how the giddy multitude do point&amp;hellip;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Of course, not everyone uses a dot for their decimal point. The other main contender is the comma, and naturally &lt;code&gt;form&lt;/code&gt; supports that as well. If we specify a numeric field with a comma between the brackets:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @les_nums = (1, 1.2, 1.23, 11.234, 111.235, 1.0001);

    print form &#39;Votre score est: {]]]],[[}&#39;,
                                 @les_nums;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the call prints:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Votre score est:     1,0
    Votre score est:     1,2
    Votre score est:     1,23
    Votre score est:    11,234
    Votre score est:   111,235
    Votre score est:     1,000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, &lt;code&gt;form&lt;/code&gt; is extremely flexible about the characters we&amp;rsquo;re allowed to use as a decimal marker: anything except an angle- or square bracket or &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=9#that_we_our_largest_bounty_may_extend...&#34;&gt;a plus sign&lt;/a&gt; is acceptable.&lt;/p&gt;

&lt;p&gt;As a bonus, &lt;code&gt;form&lt;/code&gt; allows us to use the specified decimal marker in the &lt;em&gt;data&lt;/em&gt; as well as in the format. So this works too:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @les_nums = (&amp;quot;1&amp;quot;, &amp;quot;1,2&amp;quot;, &amp;quot;1,23&amp;quot;, &amp;quot;11,234&amp;quot;, &amp;quot;111,235&amp;quot;, &amp;quot;1,0001&amp;quot;);

    print form &#39;Vos score est: {]]]],[[}&#39;,
                               @les_nums;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-or-else-be-impudently-negative-or-else-be-impudently-negative-span&#34;&gt;&lt;span id=&#34;or_else_be_impudently_negative...&#34;&gt;Or else be impudently negative&amp;hellip;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Negative numbers work as expected, with the minus sign taking up one column of the field&amp;rsquo;s allotted span:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @nums = ( 1, -1.2,  1.23, -11.234,  111.235, -12345.67);

    print form &#39;Thy score be: {]]]].[[}&#39;,
                              @nums;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This would print:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Thy score be:     1.0
    Thy score be:    -1.2
    Thy score be:     1.23
    Thy score be:   -11.234
    Thy score be:   111.235
    Thy score be: #####.###
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, &lt;code&gt;form&lt;/code&gt; can also format numbers so that the minus sign &lt;em&gt;trails&lt;/em&gt; the number. To do that we simple put an explicit minus sign inside the field specification, at the end:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form &#39;Thy score be: {]]]].[[-}&#39;,
                              @nums;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which would then print:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Thy score be:     1.0
    Thy score be:     1.2-
    Thy score be:     1.23
    Thy score be:    11.234-
    Thy score be:   111.235
    Thy score be: 12345.67-
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;form&lt;/code&gt; also understands the common financial usage where negative numbers are represented as positive numbers in parentheses. Once again, we draw an abstract picture of what we want (by putting parens at either end of the field specification):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form &#39;Thy dividend be: {(]]]].[[)}&#39;,
                                 @nums;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and &lt;code&gt;form&lt;/code&gt; obliges:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Thy dividend be:      1.0
    Thy dividend be:     (1.2)
    Thy dividend be:      1.23
    Thy dividend be:    (11.234)
    Thy dividend be:    111.235
    Thy dividend be: (12345.67)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the parens have to go &lt;em&gt;inside&lt;/em&gt; the field&amp;rsquo;s braces. Otherwise, they&amp;rsquo;re just literal parts of the format string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form &#39;Thy dividend be: ({]]]].[[})&#39;,
                                  @nums;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and we&amp;rsquo;d get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Thy dividend be: (    1.0  )
    Thy dividend be: (   -1.2  )
    Thy dividend be: (    1.23 )
    Thy dividend be: (  -11.234)
    Thy dividend be: (  111.235)
    Thy dividend be: (#####.###)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-and-stand-a-comma-tween-their-amities-and-stand-a-comma-tween-their-amities-span&#34;&gt;&lt;span id=&#34;and_stand_a_comma_&#39;tween_their_amities...&#34;&gt;And stand a comma &amp;lsquo;tween their amities&amp;hellip;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;If we add so-called &amp;ldquo;thousands separators&amp;rdquo; inside a numeric field at the usual places, &lt;code&gt;form&lt;/code&gt; includes them appropriately in its output. It can handle the five major formatting conventions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @nums = (0, 1, 1.1, 1.23, 4567.89, 34567.89, 234567.89, 1234567.89);

    print form
        &amp;quot;Brittannic      Continental     Subcontinental   Tyrolean        Asiatic&amp;quot;,
        &amp;quot;_____________   _____________   ______________   _____________   _____________&amp;quot;,
        &amp;quot;{],]]],]]].[}   {].]]].]]],[}    {]],]],]]].[}   {]&#39;]]]&#39;]]],[}   {]]]],]]]].[}&amp;quot;,
         @nums,          @nums,          @nums,           @nums,          @nums;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to produce:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Brittannic      Continental     Subcontinental   Tyrolean        Asiatic
    _____________   _____________   ______________   _____________   _____________
             0.0             0,0              0.0             0,0             0.0
             1.0             1,0              1.0             1,0             1.0
             1.1             1,1              1.1             1,1             1.1
             1.23            1,23             1.23            1,23            1.23
         4,567.89        4.567,89         4,567.89        4&#39;567,89         4567.89
        34,567.89       34.567,89        34,567.89       34&#39;567,89       3,4567.89
       234,567.89      234.567,89      2,34,567.89      234&#39;567,89      23,4567.89
     1,234,567.89    1.234.567,89     12,34,567.89    1&#39;234&#39;567,89     123,4567.89
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It also accepts a space character as a &amp;ldquo;thousands separator&amp;rdquo; (with, of course, any decimal marker we might like):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        &amp;quot;Hyperspatial&amp;quot;,
        &amp;quot;_____________&amp;quot;,
        &amp;quot;{] ]]] ]]]:[}&amp;quot;,
         @nums;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to produce:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Hyperspatial
    _____________
             0:0
             1:0
             1:1
             1:23
         4 567:89
        34 567:89
       234 567:89
     1 234 567:89
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-and-gives-to-airy-nothing-a-local-habitation-and-a-name-and-gives-to-airy-nothing-a-local-habitation-and-a-name-span&#34;&gt;&lt;span id=&#34;and_gives_to_airy_nothing_a_local_habitation_and_a_name&#34;&gt;And gives to airy nothing a local habitation and a name&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Of course, sometimes we don&amp;rsquo;t know ahead of time just where in the world our formatted numbers will be displayed. Locales were invented to address that very problem, and &lt;code&gt;form&lt;/code&gt; supports them.&lt;/p&gt;

&lt;p&gt;If we use the &lt;code&gt;:locale&lt;/code&gt; option, &lt;code&gt;form&lt;/code&gt; detects the current locale and converts any numerical formats it finds to the appropriate layout. For example, if we wrote:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @nums = ( 1, -1.2,  1.23, -11.234,  111.235, -12345.67);

    print form
            &amp;quot;{],]]],]]].[[}&amp;quot;,
            @nums;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then we&amp;rsquo;d get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          1.0
         -1.2
          1.23
        -11.234
        111.235
    -12,345.67
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;wherever the program was run. But if we had written:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
            :locale,
            &amp;quot;{],]]],]]].[[}&amp;quot;,
            @nums;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then we&amp;rsquo;d get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          1.0
         -1.2
          1.23
        -11.234
        111.235
    -12,345.67
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          1,0
          1,2-
          1,23
         11,23-
        111,235
     12.345,67-

or:

          1,0
         (1,2)
          1,23
        (11,23)
        111,235
    (12&#39;345,67)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or whatever else the current locale indicated was the correct local layout for numbers.&lt;/p&gt;

&lt;p&gt;That is, when the &lt;code&gt;:locale&lt;/code&gt; option is specified, &lt;code&gt;form&lt;/code&gt; ignores the actual decimal point, thousands separator, and negation sign we specified in the call, and instead uses the values for these markers that are returned by the POSIX &lt;code&gt;localeconv&lt;/code&gt; function. That means that we can specify our numerical formatting in a style that seems natural to us, and at the same time allow the numbers to be formatted in a style that seems natural to the user.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S07.html&#34;&gt;Synopsis 7&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-thou-shalt-have-my-best-gown-to-make-thee-a-pair-thou-shalt-have-my-best-gown-to-make-thee-a-pair-span&#34;&gt;&lt;span id=&#34;thou_shalt_have_my_best_gown_to_make_thee_a_pair...&#34;&gt;Thou shalt have my best gown to make thee a pair&amp;hellip;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Wait a minute&amp;hellip;&lt;/p&gt;

&lt;p&gt;Where exactly did we conjure that &lt;code&gt;:locale&lt;/code&gt; syntax from? And what, exactly, did it create? What &lt;em&gt;is&lt;/em&gt; an &amp;ldquo;option&amp;rdquo;?&lt;/p&gt;

&lt;p&gt;Well, we&amp;rsquo;re passing &lt;code&gt;:locale&lt;/code&gt; as an argument to &lt;code&gt;form&lt;/code&gt;, and &lt;code&gt;form&lt;/code&gt;&amp;rsquo;s &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=2#why,_how_now,_ho!_from_whence_ariseth_this&#34;&gt;signature&lt;/a&gt; guarantees us that it can only accept a &lt;code&gt;Str&lt;/code&gt;, or an &lt;code&gt;Array&lt;/code&gt;, or a &lt;code&gt;Pair&lt;/code&gt; as an argument. So an &amp;ldquo;option&amp;rdquo; must be one of those three types, and that funky &lt;code&gt;:identifier&lt;/code&gt; syntax must be a constructor for the equivalent data structure.&lt;/p&gt;

&lt;p&gt;And indeed, that&amp;rsquo;s the case. An &amp;ldquo;option&amp;rdquo; is just a pair, and the funky &lt;code&gt;:identifier&lt;/code&gt; syntax is just another way of writing a pair constructor.&lt;/p&gt;

&lt;p&gt;The standard &amp;ldquo;option&amp;rdquo; syntax is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    :key( &amp;quot;value&amp;quot; )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which is identical in effect to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    key =&amp;gt; &amp;quot;value&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Both specify an autoquoted key; both associate that key with a value; both evaluate to a pair object that contains the key and value. So why have a second syntax for pairs?&lt;/p&gt;

&lt;p&gt;Because it allows us to optimize the pair constructor syntax in two different ways. The now-familiar &amp;ldquo;fat arrow&amp;rdquo; pair constructor takes a key and a value, each of which can be of any type. In contrast, the key of an &amp;ldquo;option&amp;rdquo; pair constructor can only be an identifier, which is always autoquoted&amp;hellip;at compile-time. So, if we use the &amp;ldquo;option&amp;rdquo; syntax we&amp;rsquo;re guaranteed that the key of the resulting pair is a string, that the string that contains a valid identifier, and that the compiler can check that validity before the program starts.&lt;/p&gt;

&lt;p&gt;Moreover, whereas the &amp;ldquo;fat arrow&amp;rdquo; has only one syntax, &amp;ldquo;options&amp;rdquo; have several highly useful syntactic variations. For example, &amp;ldquo;fat arrow&amp;rdquo; pairs can be especially annoying when we want to use them to pass named boolean arguments to a subroutine. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    duel( $person1, $person2, to_death=&amp;gt;1, no_quarter=&amp;gt;1, left_handed=&amp;gt;1, bonetti=&amp;gt;1, capoferro=&amp;gt;1 );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In contrast, &amp;ldquo;options&amp;rdquo; have a special default behaviour. If we leave off their parenthesized value entirely, the implied value is &lt;code&gt;1&lt;/code&gt;. So we could rewrite the preceding function call as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    duel( $person1, $person2, :to_death, :no_quarter, :left_handed, :bonetti, :capoferro );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Better still, when we have a series of options, we don&amp;rsquo;t have to put commas between them:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    duel( $person1, $person2, :to_death :no_quarter :left_handed :bonetti :capoferro );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That makes them even more concise and uncluttered, especially in &lt;code&gt;use&lt;/code&gt; statements:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use POSIX :errno_h :fcntl_h :time_h;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are other handy &amp;ldquo;option&amp;rdquo; variants as well, all of which simply substitute the parentheses following their key for some other kind of bracket (and hence some other kind of value). The full list of &amp;ldquo;option&amp;rdquo;&amp;hellip;err&amp;hellip;options is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      Option syntax              Is equivalent to
    ==================     =============================

    :key(&amp;quot;some value&amp;quot;)     key =&amp;gt; &amp;quot;some value&amp;quot;

    :key                   key =&amp;gt; 1

    :key{ a=&amp;gt;1, b=&amp;gt;2 }     key =&amp;gt; { a=&amp;gt;1, b=&amp;gt;2 }

    :key{ $^arg * 2; }     key =&amp;gt; { $^arg * 2; }

    :key[ 1, 2, 3, 4 ]     key =&amp;gt; [ 1, 2, 3, 4 ]

    :key«eat at Joe&#39;s»     key =&amp;gt; [&amp;quot;eat&amp;quot;, &amp;quot;at&amp;quot;, &amp;quot;Joe&#39;s&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Despite the deliberate differences in conciseness and flexibility, we can use &amp;ldquo;options&amp;rdquo; and &amp;ldquo;fat arrows&amp;rdquo; interchangeably in almost every situation where we need to construct a pair (except, of course, where the key needs to be something other than an identifier string, in which case the &amp;ldquo;fat arrow&amp;rdquo; is the only alternative). To illustrate that interchangeability, we&amp;rsquo;ll use the &amp;ldquo;option&amp;rdquo; syntax throughout most of the rest of this discussion, except where using a &amp;ldquo;fat arrow&amp;rdquo; is clearly preferable for code readability.&lt;/p&gt;

&lt;p&gt;Meanwhile, back in the fields&amp;hellip;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-some-tender-money-to-me-some-tender-money-to-me-span&#34;&gt;&lt;span id=&#34;some_tender_money_to_me...&#34;&gt;Some tender money to me&amp;hellip;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Formatting numbers gets even trickier when those numbers represent money. But &lt;code&gt;form&lt;/code&gt; simply lets us specify how the local currency looks – including leading, trailing, or infix currency markers; leading, trailing, or circumfix negation markers; thousands separators; etc. – and then it formats it that way. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @amounts = (0, 1, 1.2345, 1234.56, -1234.56, 1234567.89);

    my %format = (
        &amp;quot;Canadian (English)&amp;quot;    =&amp;gt; q/   {-$],]]],]]].[}/,
        &amp;quot;Canadian (French)&amp;quot;     =&amp;gt; q/    {-] ]]] ]]],[ $}/,
        &amp;quot;Dutch&amp;quot;                 =&amp;gt; q/     {],]]],]]].[-EUR}/,
        &amp;quot;German (pre-euro)&amp;quot;     =&amp;gt; q/    {-].]]].]]],[DM}/,
        &amp;quot;Indian&amp;quot;                =&amp;gt; q/    {-]],]],]]].[ Rs}/,
        &amp;quot;Norwegian&amp;quot;             =&amp;gt; q/ {kr -].]]].]]],[}/,
        &amp;quot;Portuguese (pre-euro)&amp;quot; =&amp;gt; q/    {-].]]].]]]$[ Esc}/,
        &amp;quot;Swiss&amp;quot;                 =&amp;gt; q/{Sfr -]&#39;]]]&#39;]]].[}/,
    );

    for %format.kv -&amp;gt; $nationality, $layout {
        print form &amp;quot;$nationality:&amp;quot;,
                   &amp;quot;    $layout&amp;quot;,
                        @amounts,
                   &amp;quot;\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;produces:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Swiss:
                  Sfr 0.0
                  Sfr 1.0
                  Sfr 1.23
              Sfr 1&#39;234.56
             Sfr -1&#39;234.56
          Sfr 1&#39;234&#39;567.89

    Canadian (French):
                      0,0 $
                      1,0 $
                      1,23 $
                  1 234,56 $
                 -1 234,56 $
              1 234 567,89 $

    Dutch:
                      0.0EUR
                      1.0EUR
                      1.23EUR
                  1,234.56EUR
                  1,234.56-EUR
              1,234,567.89EUR

    Norwegian:
                   kr 0,0
                   kr 1,0
                   kr 1,23
               kr 1.234,56
              kr -1.234,56
           kr 1.234.567,89

    German (pre-euro):
                      0,0DM
                      1,0DM
                      1,23DM
                  1.234,56DM
                 -1.234,56DM
              1.234.567,89DM

    Indian:
                      0.0 Rs
                      1.0 Rs
                      1.23 Rs
                  1,234.56 Rs
                 -1,234.56 Rs
              12,34,567.89 Rs

    Portuguese (pre-euro):
                      0$0 Esc
                      1$0 Esc
                      1$23 Esc
                  1.234$56 Esc
                 -1.234$56 Esc
              1.234.567$89 Esc

    Canadian (English):
                     $0.0
                     $1.0
                     $1.23
                 $1,234.56
                -$1,234.56
             $1,234,567.89
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nice, eh?&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-able-verbatim-to-rehearse-able-verbatim-to-rehearse-span&#34;&gt;&lt;span id=&#34;able_verbatim_to_rehearse...&#34;&gt;Able verbatim to rehearse&amp;hellip;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;But sometimes &lt;em&gt;too&lt;/em&gt; nice. Sometimes all we want is an existing block of data laid out into columns – without any fancy reformatting or rejustification. For example, suppose we have an interesting string like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $diagram = &amp;lt;&amp;lt;EODNA;
       G==C
         A==T
           T=A
           A=T
         T==A
       G===C
      T==A
     C=G
    TA
    AT
     A=T
      T==A
        G===C
          T==A
    EODNA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and we&amp;rsquo;d like to put beside some other text. Because it&amp;rsquo;s already carefully formatted, we really don&amp;rsquo;t want to interpolate it into a left-justified field:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        &#39;{[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]}       {[[[[[[[[[[[[[[[}&#39;,
         $diatribe,                                        $diagram;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because that would squash our lovely helix:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Men at  some  time  are  masters  of  their       G==C
    fates: / the fault, dear Brutus, is not  in       A==T
    our genes, / but in ourselves, that we  are       T=A
    underlings.  /  Brutus  and  Caesar:   what       A=T
    should be in that &#39;Caesar&#39;?  /  Why  should       T==A
    that DNA be sequenced more  than  yours?  /       G===C
    Extract them together, yours is as  fair  a       T==A
    genome; / transcribe them, it  doth  become       C=G
    mRNA as well; / recombine them,  it  is  as       TA
    long; clone with &#39;em, / Brutus will start a       AT
    twin as soon as Caesar. / Now, in the names       A=T
    of all  the  gods  at  once,  /  upon  what       T==A
    proteins doth our Caesar feed, / that he is       G===C
    grown so great?                                   T==A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nor would right-, full-, centre- or numeric- justification help in this instance. What we really need is &amp;ldquo;leave-it-the-hell-alone&amp;rdquo; justification – a field specifier that lays out the data exactly as it is, leading whitespace included.&lt;/p&gt;

&lt;p&gt;And that&amp;rsquo;s the purpose of a &lt;em&gt;verbatim field&lt;/em&gt;. A verbatim single-line field (&lt;code&gt;{&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;}&lt;/code&gt;) grabs the next line of data it&amp;rsquo;s offered and inserts as much of it as will fit in the field&amp;rsquo;s width, preserving whitespace &amp;ldquo;as is&amp;rdquo;. Likewise a verbatim block field (&lt;code&gt;{&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;}&lt;/code&gt;) grabs every line of the data it&amp;rsquo;s offered and interpolates it into the text without any reformatting or justification.&lt;/p&gt;

&lt;p&gt;And that&amp;rsquo;s precisely what we needed for our diagram:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        &#39;{[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]}       {&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;}&#39;,
         $diatribe,                                        $diagram;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to produce:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Men at  some  time  are  masters  of  their          G==C
    fates: / the fault, dear Brutus, is not  in            A==T
    our genes, / but in ourselves, that we  are              T=A
    underlings.  /  Brutus  and  Caesar:   what              A=T
    should be in that &#39;Caesar&#39;?  /  Why  should            T==A
    that DNA be sequenced more  than  yours?  /          G===C
    Extract them together, yours is as  fair  a         T==A
    genome; / transcribe them, it  doth  become        C=G
    mRNA as well; / recombine them,  it  is  as       TA
    long; clone with &#39;em, / Brutus will start a       AT
    twin as soon as Caesar. / Now, in the names        A=T
    of all  the  gods  at  once,  /  upon  what         T==A
    proteins doth our Caesar feed, / that he is           G===C
    grown so great?                                         T==A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that, unlike other types of fields, verbatim fields don&amp;rsquo;t &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=7#a_man_may_break_a_word_with_you,_sir...&#34;&gt;break and wrap their data&lt;/a&gt; if that data doesn&amp;rsquo;t fit on a single line. Instead, they truncate each line to the appropriate field width. So a too-short verbatim field:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        &#39;{[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]}       {&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;}&#39;,
         $diatribe,                                        $diagram;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;results in gene slicing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Men at  some  time  are  masters  of  their          G==C
    fates: / the fault, dear Brutus, is not  in            A==
    our genes, / but in ourselves, that we  are              T
    underlings.  /  Brutus  and  Caesar:   what              A
    should be in that &#39;Caesar&#39;?  /  Why  should            T==
    that DNA be sequenced more  than  yours?  /          G===C
    Extract them together, yours is as  fair  a         T==A
    genome; / transcribe them, it  doth  become        C=G
    mRNA as well; / recombine them,  it  is  as       TA
    long; clone with &#39;em, / Brutus will start a       AT
    twin as soon as Caesar. / Now, in the names        A=T
    of all  the  gods  at  once,  /  upon  what         T==A
    proteins doth our Caesar feed, / that he is           G===
    grown so great?                                         T=
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;rather than teratogenesis:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Men at  some  time  are  masters  of  their          G==C
    fates: / the fault, dear Brutus, is not  in            A=-
    our genes, / but in ourselves, that we  are       =T
    underlings.  /  Brutus  and  Caesar:   what              -
    should be in that &#39;Caesar&#39;?  /  Why  should       T=A
    that DNA be sequenced more  than  yours?  /              -
    Extract them together, yours is as  fair  a       A=T
    genome; / transcribe them, it  doth  become            T=-
    mRNA as well; / recombine them,  it  is  as       =A
    long; clone with &#39;em, / Brutus will start a          G===C
    twin as soon as Caesar. / Now, in the names         T==A
    of all  the  gods  at  once,  /  upon  what        C=G
    proteins doth our Caesar feed, / that he is       TA
    grown so great?                                  AT
                                                   A=T
                                                    T==A
                                                      G==-
                                                  =C
                                                        T-
                                                  ==A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S07.html&#34;&gt;Synopsis 7&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-and-now-at-length-they-overflow-their-banks-and-now-at-length-they-overflow-their-banks-span&#34;&gt;&lt;span id=&#34;and_now_at_length_they_overflow_their_banks.&#34;&gt;And now at length they overflow their banks.&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s not uncommon for a report to need a series of data fields in one column and then a second column with only single field, perhaps containing a summary or discussion of the other data. For example, we might want to produce recipes of the form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    =================[  Hecate&#39;s Broth of Ambition  ]=================

      Preparation time:             Method:
         66.6 minutes                  Remove the legs from the
                                       lizard, the wings from the
      Serves:                          owlet, and the tongue of the
         2 doomed souls                adder. Set them aside.
                                       Refrigerate the remains (they
      Ingredients:                     can be used to make a lovely
         2 snakes (1 fenny, 1          white-meat stock). Drain the
         adder)                        newts&#39; eyes if using pickled.
         2 lizards (1 legless,         Wrap the toad toes in the
         1 regular)                    bat&#39;s wool and immerse in half
         3 eyes of newt (fresh         a pint of vegan stock in
         or pickled)                   bottom of a preheated
         2 toad toes (canned           cauldron. (If you can&#39;t get a
         are fine)                     fresh vegan for the stock, a
         2 cups of bat&#39;s wool          cup of boiling water poured
         1 dog tongue                  over a vegetarian holding a
         1 common or spotted           sprouted onion will do). Toss
         owlet                         in the fenny snake, then the
                                       legless lizard. Puree the
                                       tongues together and fold
                                       gradually into the mixture,
                                       stirring widdershins at all
                                       times.  Allow to bubble for 45
                                       minutes then decant into two
                                       tarnished copper chalices.
                                       Garnish each with an owlet
                                       wing, and serve immediately.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are several ways to achieve that effect. The most obvious is to format each column separately and then lay them out side-by-side with a pair of verbatim fields:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $prep = form &#39;Preparation time:        &#39;,
                    &#39;   {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}&#39;, $prep_time,
                    &#39;                         &#39;,
                    &#39;Serves:                  &#39;,
                    &#39;   {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}&#39;, $serves,
                    &#39;                         &#39;,
                    &#39;Ingredients:             &#39;,
                    &#39;   {[[[[[[[[[[[[[[[[[[[[}&#39;, $ingredients;

    my $make = form &#39;Method:                          &#39;,
                    &#39;   {[[[[[[[[[[[[[[[[[[[[[[[[[[[[}&#39;,
                        $method;

    print form
        &#39;=================[ {||||||||||||||||||||||||||} ]=================&#39;,
                                      $recipe,
        &#39;                                                                  &#39;,
        &#39;  {&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;}     {&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;} &#39;,
           $prep,                        $make;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We could even chain the calls to &lt;code&gt;form&lt;/code&gt; to eliminate the interim variables:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        &#39;=================[ {||||||||||||||||||||||||||} ]=================&#39;,
                                      $recipe,
        &#39;                                                                  &#39;,
        &#39;  {&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;}     {&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;} &#39;,
           form(&#39;Preparation time:        &#39;,
                &#39;   {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}&#39;, $prep_time,
                &#39;                         &#39;,
                &#39;Serves:                  &#39;,
                &#39;   {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}&#39;, $serves
                &#39;                         &#39;,
                &#39;Ingredients:             &#39;,
                &#39;   {[[[[[[[[[[[[[[[[[[[[}&#39;, $ingredients,
               ),
           form(&#39;Method:                          &#39;,
                &#39;   {[[[[[[[[[[[[[[[[[[[[[[[[[[[[}&#39;,
                    $method,
               );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While it&amp;rsquo;s impressive to be able to do that kind of nested formatting (and highly useful in extreme formatting scenarios), it&amp;rsquo;s also far too ungainly for regular use. A cleaner, more maintainable solution is use a single format and just build the method column up piecemeal, like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        &#39;=================[ {||||||||||||||||||||||||||} ]=================&#39;,
                                      $recipe,
        &#39;                                                                  &#39;,
        &#39;Preparation time:               Method:                           &#39;,
        &#39;   {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}          {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;…} &#39;,
            $prep_time,                     $method,
        &#39;                                   {…&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;…} &#39;,
                                            $method,
        &#39;Serves:                            {…&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;…} &#39;,
                                            $method,
        &#39;   {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}          {…&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;…} &#39;,
            $serves,                        $method,
        &#39;                                   {…&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;…} &#39;,
                                            $method,
        &#39;Ingredients:                       {…&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;…} &#39;,
                                            $method,
        &#39;   {[[[[[[[[[[[[[[[[[[[[}          {…[[[[[[[[[[[[[[[[[[[[[[[[[[[} &#39;,
            $ingredients,                   $method;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That produces exactly the same result as the previous versions, because each follow-on &lt;code&gt;{…&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;…}&lt;/code&gt; field in the &amp;ldquo;Method&amp;rdquo; column grabs one extra line from &lt;code&gt;$method&lt;/code&gt;, and then the final follow-on &lt;code&gt;{…[[[[[[…}&lt;/code&gt; field grabs as many more as are required to lay out the rest of the contents of the variable. The only down-side is that the resulting code is still downright ugly. With all those tedious repetitions of the same variable, there&amp;rsquo;s far too much &lt;code&gt;$method&lt;/code&gt; in our madness.&lt;/p&gt;

&lt;p&gt;Having a series of follow-on fields like this – vertically continuing a single column across subsequent format lines – is so common that &lt;code&gt;form&lt;/code&gt; provides a special shortcut: the &lt;code&gt;{VVVVVVVVV}&lt;/code&gt; &lt;em&gt;overflow field&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;An overflow field automagically duplicates the field specification immediately above it. The important point being that, because that duplication includes copying the preceding field&amp;rsquo;s data source, overflow fields don&amp;rsquo;t require a separate data source of their own.&lt;/p&gt;

&lt;p&gt;Using overflow fields, we could rewrite our quotation generator like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        &#39;=================[ {||||||||||||||||||||||||||} ]=================&#39;,
                                      $recipe,
        &#39;                                                                  &#39;,
        &#39;Preparation time:               Method:                           &#39;,
        &#39;   {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}          {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;} &#39;,
            $prep_time,                     $method,
        &#39;                                   {VVVVVVVVVVVVVVVVVVVVVVVVVVVV} &#39;,
        &#39;Serves:                            {VVVVVVVVVVVVVVVVVVVVVVVVVVVV} &#39;,
        &#39;   {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}          {VVVVVVVVVVVVVVVVVVVVVVVVVVVV} &#39;,
            $serves,
        &#39;                                   {VVVVVVVVVVVVVVVVVVVVVVVVVVVV} &#39;,
        &#39;Ingredients:                       {VVVVVVVVVVVVVVVVVVVVVVVVVVVV} &#39;,
        &#39;   {[[[[[[[[[[[[[[[[[[[[}          {VVVVVVVVVVVVVVVVVVVVVVVVVVVV} &#39;,
            $ingredients,
        &#39;                                   {VVVVVVVVVVVVVVVVVVVVVVVVVVVV} &#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which would once again produce the recipe shown earlier.&lt;/p&gt;

&lt;p&gt;Note that the overflow fields interact equally well in formats with single-line and block fields. That&amp;rsquo;s because block overflow fields have one other special feature: they&amp;rsquo;re non-greedy. Unless we &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=10#i_have_got_strength_of_limit&#34;&gt;specify otherwise&lt;/a&gt;, all types of block fields will consume their entire data source. For example, if we wrote:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form :layout«across»,
         &#39;{&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;…}&#39;,
                                  $speech,
         &#39;{…&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;…}&#39;,
                                  $speech,
         &#39;{…[[[[[]]]]]…}   {=&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;=}   {…[[[[[]]]]]]…}&#39;,
             $speech,             $advert,              $speech,
         &#39;{…[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]}&#39;,
                                  $speech;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we&amp;rsquo;d get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Now is the winter of our discontent / Made glorious summer
    by this sun of York; / And all the clouds that lour&#39;d upon
    our house / In                             the deep  bosom
    of  the  ocean                             buried.  /  Now
    are our  brows                             bound      with
    victorious                                 wreaths; /  Our
    bruised   arms                             hung   up   for
    monuments;   /                             Our       stern
    alarums          +---------------------+   changed      to
    merry            |                     |   meetings, / Our
    dreadful         | Eat at Mrs Miggins! |   marches      to
    delightful       |                     |   measures. Grim-
    visaged    war   +---------------------+   hath   smooth&#39;d
    his   wrinkled                             front;  /   And
    now,   instead                             of     mounting
    barded  steeds                             / To fright the
    souls       of                             fearful
    adversaries, /                             He       capers
    nimbly  in   a                             lady&#39;s chamber.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s because the two &lt;code&gt;{…[[[[[]]]]]…}&lt;/code&gt; block fields on either side of the verbatim advertisement field will eat all the data in &lt;code&gt;$speech&lt;/code&gt;, leaving nothing for the final format. Then the advertisement will be centred on the two resulting columns of text.&lt;/p&gt;

&lt;p&gt;But, block overflow fields are different. They only take as many lines as are required to fill the lines generated by the non-overflow fields in their format. So, if we changed our code to use overflows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form :layout«across»
         &#39;{&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;}&#39;, $speech,
         &#39;{VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}&#39;,
         &#39;{VVVVVVVVVVVV}   {=&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;=}   {VVVVVVVVVVVVV}&#39;, $advert,
         &#39;{VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we get both a cleaner specification and a more elegant result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Now is the winter of our discontent / Made glorious summer
    by this sun of York; / And all the clouds that lour&#39;d upon
    our house / In                             the deep  bosom
    of  the  ocean   +---------------------+   buried.  /  Now
    are our  brows   |                     |   bound      with
    victorious       | Eat at Mrs Miggins! |   wreaths; /  Our
    bruised   arms   |                     |   hung   up   for
    monuments;   /   +---------------------+   Our       stern
    alarums                                    changed      to
    merry meetings,  /  Our  dreadful  marches  to  delightful
    measures. Grim-visaged  war  hath  smooth&#39;d  his  wrinkled
    front; / And now, instead of mounting barded steeds  /  To
    fright the souls  of  fearful  adversaries,  /  He  capers
    nimbly in a lady&#39;s chamber.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that, in the third format line of the previous example, the two overflow fields on either side of the advertisement are each overflowing from the single field that&amp;rsquo;s above both of them. This kind of multiple overflow is fine, but it does require that we specify &lt;em&gt;how&lt;/em&gt; the various fields overflow (i.e. as two separate columns of text, or – as in this case – as a single, broken column across the page). That&amp;rsquo;s the purpose of the &lt;code&gt;:layout«across»&lt;/code&gt; option on the first line. This option is explained in detail &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=8#lay_out._lay_out.&#34;&gt;below&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;{VVVVVVVV}&lt;/code&gt; fields only consumed as much data from &lt;code&gt;$speech&lt;/code&gt; as was required to sandwich the output lines created by the verbatim advertisement. This feature is important, because it means we can lay out a series of block fields in one column and a single overflowed field in another column without introducing ugly gaps. For example, because the &lt;code&gt;{VVVVVVVVV}&lt;/code&gt; fields in:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        &amp;quot;Name:                                                  &amp;quot;,
        &amp;quot;  {[[[[[[[[[[[[}                                       &amp;quot;, $name,
        &amp;quot;                  Biography:                           &amp;quot;,
        &amp;quot;Status:             {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}&amp;quot;, $bio,
        &amp;quot;  {[[[[[[[[[[[[}    {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}&amp;quot;, $status,
        &amp;quot;                    {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}&amp;quot;,
        &amp;quot;Comments:           {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}&amp;quot;,
        &amp;quot;  {[[[[[[[[[[[}     {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}&amp;quot;, $comments;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;only consume as much of the overflowing &lt;code&gt;$bio&lt;/code&gt; field as necessary, the result is something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Name:
      William
      Shakespeare
                      Biography:
    Status:             William Shakespeare was born on
      Deceased (1564    April 23, 1564 in Strathford-upon-
      -1616)            Avon, England; he was third of
                        eight children from Father John
    Comments:           Shakespeare and Mother Mary Arden.
      Theories          Shakespeare began his education at
      abound as to      the age of seven when he probably
      the true          attended the Strathford grammar
      author of his     school. The school provided
      plays. The        Shakespeare with his formal
      prime             education. The students chiefly
      alternative       studied Latin rhetoric, logic, and
      candidates        literature. His knowledge and
      being Sir         imagination may have come from his
      Francis           reading of ancient authors and
      Bacon,            poetry. In November 1582,
      Christopher       Shakespeare received a license to
      Marlowe, or       marry Anne Hathaway. At the time of
      Edward de         their marriage, Shakespeare was 18
      Vere              years old and Anne was 26. They had
                        three children, the oldest Susanna,
                        and twins- a boy, Hamneth, and a
                        girl, Judith. Before his death on
                        April 23 1616, William Shakespeare
                        had written thirty-seven plays. He
                        is generally considered the
                        greatest playwright the world has
                        ever known and has always been the
                        world&#39;s most popular author.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If &lt;code&gt;{VVVVVVVVVVV}&lt;/code&gt; fields ate their entire data – the way &lt;code&gt;{[[[[[[[[[}&lt;/code&gt; or &lt;code&gt;{IIIIIIIIII}&lt;/code&gt; fields do – then the output would be much less satisfactory. The first block overflow field for &lt;code&gt;$bio&lt;/code&gt; would have to consume the entire biography, before the comments field was even reached. So our output would be something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Name:
      William
      Shakespeare
                      Biography:
    Status:             William Shakespeare was born on
      Deceased (1564    April 23, 1564 in Strathford-upon-
      -1616)            Avon, England; he was third of
                        eight children from Father John
                        Shakespeare and Mother Mary Arden.
                        Shakespeare began his education at
                        the age of seven when he probably
                        attended the Strathford grammar
                        school. The school provided
                        Shakespeare with his formal
                        education. The students chiefly
                        studied Latin rhetoric, logic, and
                        literature. His knowledge and
                        imagination may have come from his
                        reading of ancient authors and
                        poetry. In November 1582,
                        Shakespeare received a license to
                        marry Anne Hathaway. At the time of
                        their marriage, Shakespeare was 18
                        years old and Anne was 26. They had
                        three children, the oldest Susanna,
                        and twins- a boy, Hamneth, and a
                        girl, Judith. Before his death on
                        April 23 1616, William Shakespeare
                        had written thirty-seven plays. He
                        is generally considered the
                        greatest playwright the world has
                        ever known and has always been the
                        world&#39;s most popular author.

    Comments:
      Theories
      abound as to
      the true
      author of his
      plays. The
      prime
      alternative
      candidates
      being Sir
      Francis
      Bacon,
      Christopher
      Marlowe, or
      Edward de
      Vere
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which is precisely why &lt;code&gt;{VVVVVVVVVVV}&lt;/code&gt; fields don&amp;rsquo;t work that way.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S07.html&#34;&gt;Synopsis 7&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-great-floods-have-flown-from-simple-sources-great-floods-have-flown-from-simple-sources-span&#34;&gt;&lt;span id=&#34;great_floods_have_flown_from_simple_sources...&#34;&gt;Great floods have flown from simple sources&amp;hellip;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;When it comes to specifying the data source for each field in a format, &lt;code&gt;form&lt;/code&gt; offers several alternatives as to where that data placed, several alternatives as to the order in which that data is extracted, and an option that lets us control how the data is fitted into each field.&lt;/p&gt;

&lt;h4 id=&#34;span-id-a-man-may-break-a-word-with-you-sir-a-man-may-break-a-word-with-you-sir-span&#34;&gt;&lt;span id=&#34;a_man_may_break_a_word_with_you,_sir...&#34;&gt;A man may break a word with you, sir&amp;hellip;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Whenever a field is passed more data than it can accommodate in a single line, &lt;code&gt;form&lt;/code&gt; is forced to &amp;ldquo;break&amp;rdquo; that data somewhere.&lt;/p&gt;

&lt;p&gt;If the field in question is &lt;em&gt;W&lt;/em&gt; columns wide, &lt;code&gt;form&lt;/code&gt; first squeezes any whitespace (as specified by the &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=10#within_that_space_you_may_have_drawn_together...&#34;&gt;user&amp;rsquo;s &lt;code&gt;:ws&lt;/code&gt; option&lt;/a&gt;) and then looks at the next &lt;em&gt;W&lt;/em&gt; columns of the string. (Of course, that might actually correspond to less than &lt;em&gt;W&lt;/em&gt; &lt;em&gt;characters&lt;/em&gt; if the string contains wide characters. However, for the sake of exposition we&amp;rsquo;ll pretend that all characters are one column wide here.)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;form&lt;/code&gt;&amp;rsquo;s breaking algorithm then searches for a newline, a carriage return, any other whitespace character, or a hyphen. If it finds a newline or carriage return within the first &lt;em&gt;W&lt;/em&gt; columns, it immediately breaks the data string at that point. Otherwise it locates the &lt;em&gt;last&lt;/em&gt; whitespace or hyphen in the first &lt;em&gt;W&lt;/em&gt; columns and breaks the string immediately after that space or hyphen. If it can&amp;rsquo;t find anywhere suitable to break the string, it breaks it at the (&lt;em&gt;W&lt;/em&gt;-1)th column and appends a hyphen.&lt;/p&gt;

&lt;p&gt;So, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $data = &amp;quot;You can play no part but Pyramus;\nfor Pyramus is a sweet-faced man&amp;quot;;

    print form &amp;quot;|{[[[[[}|&amp;quot;,
                 $data;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;prints:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    |You can|
    |play no|
    |part   |
    |but    |
    |Pyramu-|
    |s;     |
    |for    |
    |Pyramus|
    |is a   |
    |sweet- |
    |faced  |
    |man    |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note the line-breaks after &lt;em&gt;can&lt;/em&gt; (at a whitespace), &lt;em&gt;part&lt;/em&gt; (after a whitespace), &lt;em&gt;sweet-&lt;/em&gt; (after a hyphen), and &lt;em&gt;s;&lt;/em&gt; (at a newline). Note too that &lt;em&gt;Pyramus;&lt;/em&gt; doesn&amp;rsquo;t fit in the field, so it has to be chopped in two and a hyphen inserted.&lt;/p&gt;

&lt;p&gt;Of course, this particular style of line-breaking may not be suitable to all applications, and we might prefer that &lt;code&gt;form&lt;/code&gt; use some other algorithm. For example, if &lt;code&gt;form&lt;/code&gt; used the TeX breaking algorithm it would have broken &lt;em&gt;Pyramus;&lt;/em&gt; less clumsily, yielding:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    |You can|
    |play no|
    |part   |
    |but    |
    |Pyra-  |
    |mus;   |
    |for    |
    |Pyramus|
    |is a   |
    |sweet- |
    |faced  |
    |man    |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To support different line-breaking strategies &lt;code&gt;form&lt;/code&gt; provides the &lt;code&gt;:break&lt;/code&gt; option. The &lt;code&gt;:break&lt;/code&gt; option&amp;rsquo;s value must be a closure/subroutine, which will then be called whenever a data string needs to be broken to fit a particular field width.&lt;/p&gt;

&lt;p&gt;That subroutine is passed three arguments: the data string itself, an integer specifying how wide the field is, and a regex indicating which (if any) characters are to be &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=10#within_that_space_you_may_have_drawn_together...&#34;&gt;squeezed&lt;/a&gt;. It is expected to return a list of two values: a string which is taken as the &amp;ldquo;broken&amp;rdquo; text for the field, and a boolean value indicating whether or not any data remains after the break (so &lt;code&gt;form&lt;/code&gt; knows when to stop breaking the data string). The subroutine is also expected to update the &lt;code&gt;.pos&lt;/code&gt; of the data string to point immediately after the break it has imposed.&lt;/p&gt;

&lt;p&gt;For example, if we always wanted to break at the exact width of the field (with no hyphens), we could do that with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub break_width ($data is rw, $width, $ws) {
        given $data {
            # Treat any squeezed or vertical whitespace as a single character
            # (since they&#39;ll subsequently be squeezed to a single space)
            my rule single_char { &amp;lt;$ws&amp;gt; | \v+ | . }

            # Give up if there are no more characters to grab...
            return (&amp;quot;&amp;quot;, 0) unless m:cont/ (&amp;lt;single_char&amp;gt;&amp;lt;1,$width&amp;gt;) /;

            # Squeeze the resultant substring...
            (my $result = $1) ~~ s:each/ &amp;lt;$ws&amp;gt; | \v+ /\c[SPACE]/;

            # Check for any more data still to come...
            my bool $more = m:cont/ &amp;lt;before: .* \S&amp;gt; /;

            # Return the squeezed substring and the &amp;quot;more&amp;quot; indicator...
            return ($result, $more);
        }
    }

    print form
        :break(&amp;amp;break_width),
        &amp;quot;|{[[[[[}|&amp;quot;,
          $data;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;producing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    |You can|
    |play no|
    |part bu|
    |t Pyram|
    |us; for|
    |Pyramus|
    |is a sw|
    |eet-fac|
    |ed man |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or we might prefer to break on every single whitespace-separated word:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub break_word ($data is rw, $width, $ws) {
        given $data {
            # Locate the next word (no longer than $width cols)
            my $found = m:cont/ \s* $?word:=(\S&amp;lt;1,$width&amp;gt;) /;

            # Fail if no more words...
            return (&amp;quot;&amp;quot;, 0) unless $found{word};

            # Check for any more data still to come...
            my bool $more = m:cont/ &amp;lt;before: .* \S&amp;gt; /;

            # Otherwise, return broken text and &amp;quot;more&amp;quot; flag...
            return ($found{word}, $more);
        }
    }

    print form
        :break(&amp;amp;break_word),
        &amp;quot;|{[[[[[}|&amp;quot;,
          $data;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;producing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    |You    |
    |can    |
    |play   |
    |no     |
    |part   |
    |but    |
    |Pyramus|
    |;      |
    |for    |
    |Pyramus|
    |is     |
    |a      |
    |sweet-f|
    |aced   |
    |man    |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll see yet another application of user-defined breaking when we discuss &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=13#define,_define,_welleducated_infant.&#34;&gt;user-defined fields&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;span-id-he-being-in-the-vaward-placed-behind-he-being-in-the-vaward-placed-behind-span&#34;&gt;&lt;span id=&#34;he,_being_in_the_vaward,_placed_behind...&#34;&gt;He, being in the vaward, placed behind&amp;hellip;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;There are (at least) three schools of thought when it comes to setting out a call to &lt;code&gt;form&lt;/code&gt; that uses more than one format. The &amp;ldquo;traditional&amp;rdquo; way (i.e. the way Perl 5 formats do it) is to interleave each format string with a line containing the data it is to interpolate, with each datum aligned directly under the field into which it is to be fitted. Like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        &amp;quot;Name:                                                  &amp;quot;,
        &amp;quot;  {[[[[[[[[[[[[}                                       &amp;quot;,
           $name,
        &amp;quot;                  Biography:                           &amp;quot;,
        &amp;quot;Status:             {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}&amp;quot;,
                             $bio,
        &amp;quot;  {[[[[[[[[[[[[}    {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}&amp;quot;,
           $status,
        &amp;quot;                    {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}&amp;quot;,
        &amp;quot;Comments:           {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}&amp;quot;,
        &amp;quot;  {[[[[[[[[[[[}     {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}&amp;quot;,
           $comments;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This approach has the advantage that it self-documents: to know what a particular field is supposed to contain, we merely need to look down one line.&lt;/p&gt;

&lt;p&gt;It does, however, break up the &amp;ldquo;abstract picture&amp;rdquo; that the formats portray, which can make it more difficult to envisage what the final formatted text will look like. So some people prefer to put all the data to the right of the formats:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        &amp;quot;Name:                                                  &amp;quot;,
        &amp;quot;  {[[[[[[[[[[[[}                                       &amp;quot;, $name,
        &amp;quot;                  Biography:                           &amp;quot;,
        &amp;quot;Status:             {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}&amp;quot;, $bio,
        &amp;quot;  {[[[[[[[[[[[[}    {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}&amp;quot;, $status,
        &amp;quot;                    {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}&amp;quot;,
        &amp;quot;Comments:           {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}&amp;quot;,
        &amp;quot;  {[[[[[[[[[[[}     {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}&amp;quot;, $comments;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that&amp;rsquo;s perfectly acceptable too.&lt;/p&gt;

&lt;p&gt;Sometimes, however, the data to be interpolated doesn&amp;rsquo;t come neatly pre-packaged in separate variables that are easy to intersperse between the formats. For example, the data might be a list returned by a subroutine call (&lt;code&gt;get_info&lt;/code&gt;) or might be stored in a hash ( &lt;code&gt;%person{« name biog stat comm »}&lt;/code&gt; ). In such cases it&amp;rsquo;s a nuisance to have to tease that data out into separate variables (or hash accesses) and then sprinkle them through the formats:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        &amp;quot;Name:                                                  &amp;quot;,
        &amp;quot;  {[[[[[[[[[[[[}                                       &amp;quot;,%person{name},
        &amp;quot;                  Biography:                           &amp;quot;,
        &amp;quot;Status:             {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}&amp;quot;,%person{biog},
        &amp;quot;  {[[[[[[[[[[[[}    {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}&amp;quot;,%person{stat},
        &amp;quot;                    {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}&amp;quot;,
        &amp;quot;Comments:           {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}&amp;quot;,
        &amp;quot;  {[[[[[[[[[[[}     {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}&amp;quot;,%person{comm};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So &lt;code&gt;form&lt;/code&gt; has an option that lets us put a single, multi-line format at the start of the argument list, place all the data together after it, and have that data automatically interleaved as necessary. Not surprisingly, that option is: &lt;code&gt;:interleave&lt;/code&gt;. It&amp;rsquo;s normally used in conjunction with a heredoc, since that&amp;rsquo;s the easiest way to specify a multi-line string in Perl:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form :interleave, &amp;lt;&amp;lt;&#39;EOFORMAT&#39;,
           Name:
             {[[[[[[[[[[[[}
                             Biography:
           Status:             {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}
             {[[[[[[[[[[[[}    {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}
                               {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}
           Comments:           {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}
             {[[[[[[[[[[[}     {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}
           EOFORMAT
         %person{« name biog stat comm »}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When &lt;code&gt;:interleave&lt;/code&gt; is in effect, &lt;code&gt;form&lt;/code&gt; grabs the first string argument it&amp;rsquo;s passed and breaks that argument up into individual lines. It treats those individual lines as a series of distinct formats and grabs as many of the remaining arguments as are required to provide data for each format.&lt;/p&gt;

&lt;p&gt;Of course, in this example we&amp;rsquo;re also taking advantage of the new indenting behaviour of heredocs. The &amp;ldquo;Name:&amp;ldquo;, &amp;ldquo;Status:&amp;ldquo;, and &amp;ldquo;Comments:&amp;rdquo; titles are actually at the very beginning of their respective lines, because the start of a Perl 6 heredoc terminator marks the left margin of the entire heredoc string.&lt;/p&gt;

&lt;h4 id=&#34;span-id-would-they-were-multitudes-would-they-were-multitudes-span&#34;&gt;&lt;span id=&#34;would_they_were_multitudes...&#34;&gt;Would they were multitudes&amp;hellip;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;It&amp;rsquo;s important to point out that, even when we&amp;rsquo;re using &lt;code&gt;form&lt;/code&gt;&amp;rsquo;s default &lt;strong&gt;non&lt;/strong&gt;-interleaving behaviour, it&amp;rsquo;s still okay to use a format that spans multiple lines. There &lt;em&gt;is&lt;/em&gt; however a significant (and useful) difference in behaviour between the two alternatives.&lt;/p&gt;

&lt;p&gt;The normal behaviour of &lt;code&gt;form&lt;/code&gt; is to take each format string, fill in each field in the format with a substring from the corresponding data source, and then repeat that process until all the data sources have been exhausted. Which means that a multi-line format like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
         &amp;lt;&amp;lt;&#39;EOFORMAT&#39;,
            Name:    {[[[[[[[[[[[[[[[}   Role: {[[[[[[[[[[}
            Address: {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[}
            _______________________________________________
            EOFORMAT
         @names, @roles, @addresses;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;would normally produce this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Name:    King Lear           Role: Protagonist
    Address: The Cliffs, Dover
    _______________________________________________
    Name:    The Three Witches   Role: Plot devices
    Address: Dismal Forest, Scotland
    _______________________________________________
    Name:    Iago                Role: Villain
    Address: Casa d&#39;Otello, Venezia
    _______________________________________________
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;because the entire three-line format is repeatedly filled in as a single unit, line-by-line and datum-by-datum.&lt;/p&gt;

&lt;p&gt;On the other hand, if we tell &lt;code&gt;form&lt;/code&gt; that it&amp;rsquo;s supposed to automatically interleave the data coming after the format, like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form :interleave,
         &amp;lt;&amp;lt;&#39;EOFORMAT&#39;,
            Name:    {[[[[[[[[[[[[[[[}   Role: {[[[[[[[[[[}
            Address: {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[}
            _______________________________________________
            EOFORMAT
         @names, @roles, @addresses;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then the call produces:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Name:    King Lear           Role: Protagonist
    Name:    The Three Witches   Role: Plot devices
    Name:    Iago                Role: Villain
    Address: The Cliffs, Dover
    Address: Dismal Forest, Scotland
    Address: Casa d&#39;Otello, Venezia
    _______________________________________________
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;because that second version is really equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
         &amp;quot;Name:    {[[[[[[[[[[[[[[[}   Role: {[[[[[[[[[[}&amp;quot;,
                   @names,                   @roles,
         &amp;quot;Address: {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[}&amp;quot;,
                   @addresses,
         &amp;quot;_______________________________________________&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s not much use in this particular example, but it was exactly what was needed for the biography example earlier. It&amp;rsquo;s just a matter of choosing the right type of data placement to achieve the particular effect we want.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S07.html&#34;&gt;Synopsis 7&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-lay-out-lay-out-lay-out-lay-out-span&#34;&gt;&lt;span id=&#34;lay_out._lay_out.&#34;&gt;Lay out. Lay out.&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;As we saw earlier, with &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=3#and_mark_what_way_i_make...&#34;&gt;follow-on fields&lt;/a&gt; and &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=6#and_now_at_length_they_overflow_their_banks.&#34;&gt;overflow fields&lt;/a&gt;, &lt;code&gt;form&lt;/code&gt; is perfectly happy to have several fields in a single format that are all fed by the same data source. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        &amp;quot;{[[[[[[[[]]]]]]]]]]…}   {…[[[[[[[]]]]]]]]]]…}   {…[[[[[[[[]]]]]]]]]]}&amp;quot;,
             $soliloquy,             $soliloquy,              $soliloquy;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, that kind of format is particularly useful for creating multi-column outputs (like newspaper columns, for example).&lt;/p&gt;

&lt;p&gt;But a small quandry arises. In what order should &lt;code&gt;form&lt;/code&gt; fill in these fields? Should the data be formatted down the page, filling each column completely before starting the next (and therefore potentially leaving the last column &amp;ldquo;short&amp;rdquo;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Now is the winter  of   torious  wreaths;   /   front; / And now, in-
    our discontent / Made   Our bruised arms hung   stead of mounting ba-
    glorious  summer   by   up for  monuments;  /   rded steeds / To fri-
    this sun of  York;  /   Our stern alarums ch-   ght the souls of fea-
    And  all  the  clouds   anged to merry meeti-   rful  adversaries,  /
    that lour&#39;d upon  our   ngs, /  Our  dreadful   He capers nimbly in a
    house / In  the  deep   marches to delightful   lady&#39;s chamber.
    bosom  of  the  ocean   measures.   /   Grim-
    buried. / Now are our   visaged war hath smo-
    brows bound with vic-   oth&#39;d  his   wrinkled
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or should the data be run line-by-line across all three columns (the way a Perl 5 &lt;code&gt;format&lt;/code&gt; does it), filling one line completely before starting the next:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Now is the winter  of   our discontent / Made   glorious  summer   by
    this sun of  York;  /   And  all  the  clouds   that lour&#39;d upon  our
    house / In  the  deep   bosom  of  the  ocean   buried. / Now are our
    brows bound with vic-   torious  wreaths;   /   Our bruised arms hung
    up for  monuments;  /   Our stern alarums ch-   anged to merry meeti-
    ngs, /  Our  dreadful   marches to delightful   measures.   /   Grim-
    visaged war hath smo-   oth&#39;d  his   wrinkled   front; / And now, in-
    stead of mounting ba-   rded steeds / To fri-   ght the souls of fea-
    rful  adversaries,  /   He capers nimbly in a   lady&#39;s chamber.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or should the text run down the columns, but in such a way as to leave those columns as evenly balanced in length as possible:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Now is the winter  of   brows bound with vic-   visaged war hath smo-
    our discontent / Made   torious  wreaths;   /   oth&#39;d  his   wrinkled
    glorious  summer   by   Our bruised arms hung   front; / And now, in-
    this sun of  York;  /   up for  monuments;  /   stead of mounting ba-
    And  all  the  clouds   Our stern alarums ch-   rded steeds / To fri-
    that lour&#39;d upon  our   anged to merry meeti-   ght the souls of fea-
    house / In  the  deep   ngs, /  Our  dreadful   rful  adversaries,  /
    bosom  of  the  ocean   marches to delightful   He capers nimbly in a
    buried. / Now are our   measures.   /   Grim-   lady&#39;s chamber.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well, of course, there&amp;rsquo;s no &amp;ldquo;right&amp;rdquo; answer to that; it depends entirely on what kind of effect we&amp;rsquo;re trying to achieve.&lt;/p&gt;

&lt;p&gt;The first approach (i.e. lay out the text down each column first) works well if we&amp;rsquo;re formatting a news-column, or a report, or a description of some kind. The second (i.e. lay out the text across each line first), is excellent for putting diagrams or call-outs in the middle of a piece of text (as we did for &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=6#and_now_at_length_they_overflow_their_banks.&#34;&gt;Mrs Miggins&lt;/a&gt;). The third approach (i.e. lay out the data downwards but balance the columns) is best for presenting a single list of data in multiple columns – like &lt;code&gt;ls&lt;/code&gt; does.&lt;/p&gt;

&lt;p&gt;So we need an option with which to tell &lt;code&gt;form&lt;/code&gt; which of these useful alternatives we want for a particular format. That option is named &lt;code&gt;:layout&lt;/code&gt; and can take one of three string values: &lt;code&gt;&amp;quot;down&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;across&amp;quot;&lt;/code&gt;, or &lt;code&gt;&amp;quot;balanced&amp;quot;&lt;/code&gt;. So, for example, to produce three versions of Richard III&amp;rsquo;s famous monologue in the order shown above, we&amp;rsquo;d use:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form :layout«down»,
        &amp;quot;{[[[[[[[[]]]]]]]]]]…}   {…[[[[[[[]]]]]]]]]]…}   {…[[[[[[[[]]]]]]]]]]}&amp;quot;,
             $soliloquy,             $soliloquy,              $soliloquy;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form :layout«across»,
        &amp;quot;{[[[[[[[[]]]]]]]]]]…}   {…[[[[[[[]]]]]]]]]]…}   {…[[[[[[[[]]]]]]]]]]}&amp;quot;,
             $soliloquy,             $soliloquy,              $soliloquy;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form :layout«balanced»,
        &amp;quot;{[[[[[[[[]]]]]]]]]]…}   {…[[[[[[[]]]]]]]]]]…}   {…[[[[[[[[]]]]]]]]]]}&amp;quot;,
             $soliloquy,             $soliloquy,              $soliloquy;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By the way, the default value for the &lt;code&gt;:layout&lt;/code&gt; option is &lt;code&gt;&amp;quot;balanced&amp;quot;&lt;/code&gt; since formatting regular columns of data is more common than formatting news or advertising inserts.&lt;/p&gt;

&lt;h4 id=&#34;span-id-for-the-table-sir-it-shall-be-served-for-the-table-sir-it-shall-be-served-span&#34;&gt;&lt;span id=&#34;for_the_table,_sir,_it_shall_be_served...&#34;&gt;For the table, sir, it shall be served&amp;hellip;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;:layout&lt;/code&gt; option controls one other form of inter-column formatting: tabular layout.&lt;/p&gt;

&lt;p&gt;So far, all the examples of tables we&amp;rsquo;ve created (for example, our &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=3#therefore,_put_you_in_your_best_array...&#34;&gt;normalized scores&lt;/a&gt;) lined up nicely. But that was only because each item in each row happened to take the same number of lines (typically just one). So, a table generator like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @play = map {&amp;quot;$_\r&amp;quot;}  ( &amp;quot;Othello&amp;quot;, &amp;quot;Richard III&amp;quot;, &amp;quot;Hamlet&amp;quot;   );
    my @name = map {&amp;quot;$_\r&amp;quot;}  ( &amp;quot;Iago&amp;quot;,    &amp;quot;Henry&amp;quot;,       &amp;quot;Claudius&amp;quot; );

    print form
         &amp;quot;Character       Appears in  &amp;quot;,
         &amp;quot;____________    ____________&amp;quot;,
         &amp;quot;{[[[[[[[[[[}    {[[[[[[[[[[}&amp;quot;,
          @name,          @play;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;correctly produces:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Character       Appears in
    ____________    ____________
    Iago            Othello

    Henry           Richard III

    Claudius        Hamlet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that we appended &lt;code&gt;&amp;quot;\r&amp;quot;&lt;/code&gt; to each element to add an extra newline after each entry in the table. We can&amp;rsquo;t use &lt;code&gt;&amp;quot;\n&amp;quot;&lt;/code&gt; to specify a line-break within an array element, because &lt;code&gt;form&lt;/code&gt; uses &lt;code&gt;&amp;quot;\n&amp;quot;&lt;/code&gt; as an &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=3#therefore,_put_you_in_your_best_array...&#34;&gt;&amp;ldquo;end-of-element&amp;rdquo; marker&lt;/a&gt;. So, to allow line breaks within a single element of an array datum, &lt;code&gt;form&lt;/code&gt; treats &lt;code&gt;&amp;quot;\r&amp;quot;&lt;/code&gt; as &amp;ldquo;end-of-line-but-not-end-of-element&amp;rdquo; (somewhat like Perl 5&amp;rsquo;s &lt;code&gt;format&lt;/code&gt; does).&lt;/p&gt;

&lt;p&gt;However, if we were to use the full titles for each character and each play:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @play = map {&amp;quot;$_\r&amp;quot;}  ( &amp;quot;Othello, The Moor of Venice&amp;quot;,
                               &amp;quot;The Life and Death of King Richard III&amp;quot;,
                               &amp;quot;Hamlet, Prince of Denmark&amp;quot;,
                             );

    my @name = map {&amp;quot;$_\r&amp;quot;}  ( &amp;quot;Iago&amp;quot;,
                               &amp;quot;Henry,\rEarl of Richmond&amp;quot;,
                               &amp;quot;Claudius,\rKing of Denmark&amp;quot;,
                             );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the same formatter would produce:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Character       Appears in
    ____________    ____________
    Iago            Othello, The
                    Moor of
    Henry,          Venice
    Earl of
    Richmond        The Life and
                    Death of
    Claudius,       King Richard
    King of         III
    Denmark
                    Hamlet,
                    Prince of
                    Denmark
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem is that the two block fields we&amp;rsquo;re using just grab all the data from each array and format it independently into each column. Usually that&amp;rsquo;s fine because the columns &lt;em&gt;are&lt;/em&gt; independent (as we&amp;rsquo;ve &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=5#able_verbatim_to_rehearse...&#34;&gt;previously seen&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;But in a table, the data in each column specifically relates to data in other columns, so corresponding elements from the column&amp;rsquo;s data arrays ought to remain vertically aligned. To achieve this, we simply tell &lt;code&gt;form&lt;/code&gt; that the data in the various columns should be laid out like a table:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form :layout«tabular»,
         &amp;quot;Character       Appears in  &amp;quot;,
         &amp;quot;____________    ____________&amp;quot;,
         &amp;quot;{[[[[[[[[[[}    {[[[[[[[[[[}&amp;quot;,
          @name,          @play;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which then produces the desired result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Character       Appears in
    ____________    ____________
    Iago            Othello, The
                    Moor of
                    Venice

    Henry,          The Life and
    Earl of         Death of
    Richmond        King Richard
                    III

    Claudius,       Hamlet,
    King of         Prince of
    Denmark         Denmark
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-give-him-line-and-scope-give-him-line-and-scope-span&#34;&gt;&lt;span id=&#34;give_him_line_and_scope...&#34;&gt;Give him line and scope&amp;hellip;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Sometimes we want to use a particular option or combination of options in every call we make to &lt;code&gt;form&lt;/code&gt;. Or, more likely, in every call we make within a specific scope. For example, we might wish to default to a different &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=7#a_man_may_break_a_word_with_you,_sir...&#34;&gt;line-breaking algorithm&lt;/a&gt; everywhere, or we might want to make repeated use of &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=13#define,_define,_welleducated_infant.&#34;&gt;a new type of field specifier&lt;/a&gt;, or we might want to &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=12#measure_his_woe_the_length_and_breadth_of_mine...&#34;&gt;reset the standard page length&lt;/a&gt; from a printable 60 to a screenable 24.&lt;/p&gt;

&lt;p&gt;Normally in Perl 6, if we wanted to preset a particular optional argument we&amp;rsquo;d simply make an assumption:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my &amp;amp;down_form := &amp;amp;form.assuming(:layout«down»);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But, of course, &lt;code&gt;form&lt;/code&gt; collects all of its arguments in &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=2#why,_how_now,_ho!_from_whence_ariseth_this&#34;&gt;a single slurpy array&lt;/a&gt;, so it doesn&amp;rsquo;t actually &lt;em&gt;have&lt;/em&gt; a &lt;code&gt;$layout&lt;/code&gt; parameter that we can prebind.&lt;/p&gt;

&lt;p&gt;Fortunately, the &lt;code&gt;.assuming&lt;/code&gt; method is smart enough to recognize when it being applied to a subroutine whose arguments are slurped. In such cases, it just prepends any prebound arguments to the resulting subroutine&amp;rsquo;s argument list. That is, the binding of &lt;code&gt;down_form&lt;/code&gt; shown above is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my &amp;amp;down_form :=
        sub (FormArgs *@args is context(Scalar)) returns Str {
            return form( :layout«down», *@args );
        };
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-this-was-your-default-this-was-your-default-span&#34;&gt;&lt;span id=&#34;this_was_your_default...&#34;&gt;This was your default&amp;hellip;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;form&lt;/code&gt; provides one other mechanism by which options can be prebound. To use it, we (re-)load the Form module with an explicit argument list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Form :layout«down», :locale, :interleave;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This causes the module to export a modified version of &lt;code&gt;form&lt;/code&gt; in which the specified options are prebound. That modified version of &lt;code&gt;form&lt;/code&gt; is exported lexically, and so &lt;code&gt;form&lt;/code&gt; only has the specified defaults preset for the scope in which the &lt;code&gt;use Form&lt;/code&gt; statement appears.&lt;/p&gt;

&lt;p&gt;These default options are handy if we have a series of calls to &lt;code&gt;form&lt;/code&gt; that all need some consistent non-standard behaviour. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Form :layout«across»,
             :interleave,
             :page{ :header(&amp;quot;Draft $(localtime)\n\n&amp;quot;) };

    print form $introduction_format, *@introduction_data;

    for @sections -&amp;gt; $format, @data {
        print form $format, *@data;
    }

    print form $conclusion_format, *@conclusion_data;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another use is to set up a fixed formatting string into which different data is to be interpolated (much in the way Perl 5 formats are typically used). For example, we might want a standard format for errors in a &lt;code&gt;CATCH&lt;/code&gt; block:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    CATCH {
        use Form :interleave, &amp;lt;&amp;lt;EOFORMAT;
                     Error {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}: {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[}
                     ___________________________________________________
                     EOFORMAT

        when /Missing datum/ { warn form &amp;quot;EMISSDAT&amp;quot;, $_.msg }
        when /too large/     { warn form &amp;quot;ETOOBIG&amp;quot;,  $_.msg }
        when .core           { warn form &amp;quot;EINTERN&amp;quot;,  &amp;quot;Internal error&amp;quot; }
        default              { warn form &amp;quot;EUNKNOWN&amp;quot;, &amp;quot;Seek help&amp;quot; }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S07.html&#34;&gt;Synopsis 7&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-and-welcome-to-the-wide-fields-and-welcome-to-the-wide-fields-span&#34;&gt;&lt;span id=&#34;and_welcome_to_the_wide_fields...&#34;&gt;And welcome to the wide fields&amp;hellip;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;All the fields we&amp;rsquo;ve seen so far have been exactly as wide as their specifications. That&amp;rsquo;s the whole point of having fields – they allow us to lay out formats &amp;ldquo;by eye&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;But &lt;code&gt;form&lt;/code&gt; also allows us to specify field widths in other ways. And better yet, to avoid specifying them at all and let &lt;code&gt;form&lt;/code&gt; work out how big they should be.&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-measure-then-of-one-is-easily-told-the-measure-then-of-one-is-easily-told-span&#34;&gt;&lt;span id=&#34;the_measure_then_of_one_is_easily_told.&#34;&gt;The measure then of one is easily told.&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;When specific field widths are required (perhaps by some design document or data formatting protocol) laying out wide fields can be error-prone. For example, most people can&amp;rsquo;t visually distinguish between a 52-column field and a 53-column field and are therefore forced to manually verify the width of the corresponding field specifier in some way.&lt;/p&gt;

&lt;p&gt;When such fields are part of a larger format, errors like that can easily result in a call to &lt;code&gt;form&lt;/code&gt; producing, say, 81-column lines. That would merely be messy if the extra characters wrapped, but could be disasterous if they happened to be chopped instead. Suppose, for example, that the last 4 columns of output contain nuclear reactor core temperatures and then consider the difference between an apparently normal reading of 567 Celsius and what might actually be happening if the reading were in fact a truncated 5678 Celsius.&lt;/p&gt;

&lt;p&gt;To catch mistakes of this kind, fields can be specified with an embedded integer in parentheses (with optional whitespace inside the parens). For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form &#39;{[[[( 15 )[[[[} {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;(17)&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}  {]]](14)]]].[[}&#39;,
               *@data;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The integer in the parentheses acts like a checksum. Its value must be identical to the actual width of the field (including the delimiting braces and the embedded integer itself). Otherwise an exception is thrown. For instance, running the above example produces the error message:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Inconsistent width for field 3.
    Specified as &#39;{]]](14)]]].[[}&#39; but actual width is 15
    in call to &amp;amp;form at demo.pl line 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Numeric fields can be given a decimal checksum, which then also specifies their number of decimal places.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        &#39;{[[[( 15 )[[[[} {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;(17)&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}  {]](14.2)]].[}&#39;,
         *@data;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the digits before the decimal still indicate the total width of the field. So the &lt;code&gt;{]](14.2)]].[}&lt;/code&gt; field in the above example means &lt;em&gt;must be 14 columns wide, including 2 decimal places&lt;/em&gt;, in exactly the same way as a &lt;code&gt;&amp;quot;%14.2f&amp;quot;&lt;/code&gt; specifier would in a &lt;code&gt;sprintf&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;span-id-what-you-will-command-me-will-i-do-what-you-will-command-me-will-i-do-span&#34;&gt;&lt;span id=&#34;what_you_will_command_me_will_i_do...&#34;&gt;What you will command me will I do&amp;hellip;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Of course, in some instances it would be much more convenient if we could simply &lt;em&gt;tell&lt;/em&gt; &lt;code&gt;form&lt;/code&gt; that we want a particular field to be a particular width, instead of having to explicitly &lt;em&gt;show&lt;/em&gt; it.&lt;/p&gt;

&lt;p&gt;So there&amp;rsquo;s another type of integer field annotation that, instead of acting like a checksum, acts like an&amp;hellip;err&amp;hellip;&amp;ldquo;tellsum&amp;rdquo;. That is, we can tell &lt;code&gt;form&lt;/code&gt; to ignore a field&amp;rsquo;s physical width and instead insist that it be magically expanded (or shrunk) to a nominated width. Such a field is said to have an &lt;em&gt;imperative width&lt;/em&gt;. The integer specifying the imperative width is placed in curly braces instead of parens.&lt;/p&gt;

&lt;p&gt;For example, the format in the previous example could be specified imperatively as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        &#39;{[{15}[} {&amp;lt;{17}&amp;lt;&amp;lt;}  {]]]]{14.2}]]]].[[}&#39;,
         *@data;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the actual width of any field becomes irrelevant if it contains an imperative width. The field will be condensed or expanded to the specified width, with subsequent fields pushed left or right accordingly.&lt;/p&gt;

&lt;p&gt;Imperative fields disrupt the WYSIWYG layout of a format, so they&amp;rsquo;re generally only used when the format itself is being generated programmatically. For example, when we were counting down the &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=2#what_a_block_art_thou...&#34;&gt;top ten reasons not to do one&amp;rsquo;s English Lit homework&lt;/a&gt;, we used a fixed-width &lt;code&gt;{&amp;gt;}&lt;/code&gt; field to format each number:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @reasons.kv -&amp;gt; $n, $reason {
        my $n = @reasons - $index ~ &#39;.&#39;;
        print form &amp;quot;   {&amp;gt;}  {[[[[[[[[[[[[[[[[[[[[[[[[[[[[}&amp;quot;,
                       $n,  $reason,
                   &amp;quot;&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But, of course, there&amp;rsquo;s not reason (theoretically, at least) why we couldn&amp;rsquo;t find more than 99 reasons not to do our homework, in which case we&amp;rsquo;d overflow the &lt;code&gt;{&amp;gt;}&lt;/code&gt; field.&lt;/p&gt;

&lt;p&gt;So instead of limiting ourselves that way, we could just tell &lt;code&gt;form&lt;/code&gt; to make the first field wide enough to enumerate however many reasons we come up with, like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $width = length(+@reasons)+1;

    for @reasons.kv -&amp;gt; $n, $reason {
        my $n = @reasons - $index ~ &#39;.&#39;;
        print form &amp;quot;   {&amp;gt;&amp;gt;{$width}&amp;gt;&amp;gt;}  {[[[[[[[[[[[[[[[[[[[[[[[[[[[[}&amp;quot;,
                       $n,             $reason,
                   &amp;quot;&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By evaluating &lt;code&gt;@reasons&lt;/code&gt; in a numeric context (&lt;code&gt;+@reasons&lt;/code&gt;) we determine the number of reasons we have, and hence the largest number that need ever fit into the first field. Taking the length of that number (&lt;code&gt;length&lt;/code&gt;) gives us the number of digits in that largest number and hence the width of a field that can format that number. We add one extra column (for the dot we&amp;rsquo;re appending to each number) and that&amp;rsquo;s our required width. Then we just tell &lt;code&gt;form&lt;/code&gt; to make the first field that wide (&lt;code&gt;{&amp;gt;&amp;gt;{$width}&amp;gt;&amp;gt;}&lt;/code&gt;).&lt;/p&gt;

&lt;h4 id=&#34;span-id-and-every-one-shall-share-and-every-one-shall-share-span&#34;&gt;&lt;span id=&#34;and_every_one_shall_share...&#34;&gt;And every one shall share&amp;hellip;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;A special form of imperative width field is the &lt;em&gt;starred field&lt;/em&gt;. A starred field is one that contains an imperative width specification in which the number is replaced by a single asterisk.&lt;/p&gt;

&lt;p&gt;The width of a starred field is not fixed, but rather is &lt;em&gt;computed&lt;/em&gt; during formatting. That width is whatever is required to cause the entire format to fill the current page width of the format (by default, 78 columns). Consider, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        &#39;{]]]]]]]]]]]]]]} {]]].[[}  {[[{*}[[}  &#39;,
         @names,          @scores,  @comments;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The width of the starred comment field in this case is 49 columns – the default page width of 78 columns minus the 29 columns consumed by the fixed-width portions of the format (including the other two fields).&lt;/p&gt;

&lt;p&gt;If a format contains two or more starred fields, the available space is shared equally between them. So, for example, to create two equal columns (say, to compare the contents of two files), we might use:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
         &amp;quot;{[[[[{*}[[[[}   {[[[[{*}[[[[}&amp;quot;,
          slurp($file1),  slurp($file2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And, yes, Perl 6 does have a built-in &lt;code&gt;slurp&lt;/code&gt; function that takes a filename, opens the file, reads in the entire contents, and returns them as a single string. For more details see the Perl6::Slurp module (now on the CPAN).&lt;/p&gt;

&lt;p&gt;There is one special case for starred fields: a starred verbatim field:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    {&amp;quot;&amp;quot;&amp;quot;&amp;quot;{*}&amp;quot;&amp;quot;&amp;quot;&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It acts like any other starred field, growing according to the available space, except that it will never grow any wider than the widest line of the data it is formatting. For example, whereas a regular starred field:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
         &#39;| {[[{*}[[} |&#39;,
            $monologue;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;expands to the full page width:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    | Now is the winter of our discontent                           |
    | Made glorious summer by this sun of York;                     |
    | And all the clouds that lour&#39;d upon our house                 |
    | In the deep bosom of the ocean buried.                        |
    | Now are our brows bound with victorious wreaths               |
    | Our bruised arms hung up for monuments;                       |
    | Our stern alarums changed to merry meetings,                  |
    | Our dreadful marches to delightful measures.                  |
    | Grim-visaged war hath smooth&#39;d his wrinkled front;            |
    | And now, instead of mounting barded steeds                    |
    | To fright the souls of fearful adversaries,                   |
    | He capers nimbly in a lady&#39;s chamber.                         |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;a starred verbatim field:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
         &#39;| {&amp;quot;&amp;quot;{*}&amp;quot;&amp;quot;} |&#39;,
            $monologue;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;only expands as much as is strictly necessary to accommodate the data:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    | Now is the winter of our discontent                |
    | Made glorious summer by this sun of York;          |
    | And all the clouds that lour&#39;d upon our house      |
    | In the deep bosom of the ocean buried.             |
    | Now are our brows bound with victorious wreaths;   |
    | Our bruised arms hung up for monuments;            |
    | Our stern alarums changed to merry meetings,       |
    | Our dreadful marches to delightful measures.       |
    | Grim-visaged war hath smooth&#39;d his wrinkled front; |
    | And now, instead of mounting barded steeds         |
    | To fright the souls of fearful adversaries,        |
    | He capers nimbly in a lady&#39;s chamber.              |
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-that-we-our-largest-bounty-may-extend-that-we-our-largest-bounty-may-extend-span&#34;&gt;&lt;span id=&#34;that_we_our_largest_bounty_may_extend...&#34;&gt;That we our largest bounty may extend&amp;hellip;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;By now you&amp;rsquo;ve probably noticed that there is quite a large overlap between the functionality of &lt;code&gt;form&lt;/code&gt; and that of &lt;code&gt;(s)printf&lt;/code&gt;. For example, the call:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @procs {
        print form
            &amp;quot;{&amp;gt;&amp;gt;&amp;gt;}  {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;(20)&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}  {&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;}  {&amp;gt;&amp;gt;.}%&amp;quot;,
            .{pid}, .{cmd},               .{time},  .{cpu};
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;has approximately the same effect as the call:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @procs {
        printf &amp;quot;%5d  %-20s  %8s  %5.1f%%\n&amp;quot;,
               .{pid}, .{cmd}, .{time}, .{cpu};
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One is more WYSIWYG, the other more concise, but (placed in a suitable loop), they would both print out lines like these:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     2461  vi -ii henry           0:55.83   11.6%
     2395  ex cathedra            0:06.59    3.5%
     2439  head anne.boleyn       0:00.18    0.1%
     2581  dig -short grave       0:01.04    0.0%
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is, however, a crucial difference between these two formatting facilities; one that only shows up when one of our processes runs over 99 hours. For example, suppose our browser has been running continuously for a few months (or, more precisely, for 1214:23.75 hours). Then the calls to &lt;code&gt;printf&lt;/code&gt; would print:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     2461  vi -ii henry           0:55.83   11.6%
     2395  ex cathedra            0:06.59    3.5%
    27384  lynx www.divorce.com  1214:23.75    0.8%
     2439  head anne.boleyn       0:00.18    0.1%
     2581  dig -short grave       0:01.04    0.0%
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;whilst the calls to &lt;code&gt;form&lt;/code&gt; would print:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     2461  vi -ii henry           0:55.83   11.6%
     2395  ex cathedra            0:06.59    3.5%
    27384  lynx www.divorce.com  1214:23-    0.8%
     2439  head anne.boleyn       0:00.18    0.1%
     2581  dig -short grave       0:01.04    0.0%
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In other words, field widths in a &lt;code&gt;printf&lt;/code&gt; represent &lt;em&gt;minimal&lt;/em&gt; spacing (even if that throws off the overall layout), whereas field widths in a &lt;code&gt;form&lt;/code&gt; represent &lt;em&gt;guaranteed&lt;/em&gt; spacing (even if that truncates some of the data).&lt;/p&gt;

&lt;p&gt;Of course, in a situation like this – where we knew that the data might not fit and we didn&amp;rsquo;t want it truncated – we could use a block field instead:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @procs {
        print form
            &amp;quot;{&amp;gt;&amp;gt;&amp;gt;}  {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;(19)&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}  {]]]]]]}  {&amp;gt;&amp;gt;.%}&amp;quot;,
            .{pid}, .{cmd},              .{time},  .{cpu};
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in which case we&amp;rsquo;d get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     2461  vi -ii henry           0:55.83   11.6%
     2395  ex cathedra            0:06.59    3.5%
    27384  lynx www.divorce.com  1214:23-    0.8%
                                      .75
     2439  head anne.boleyn       0:00.18    0.1%
     2581  dig -short grave       0:01.04    0.0%
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That preserves the data, but the results are still ugly, and it also requires some fancy footwork – making the percentage sign part of the field specification, as if it were &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=5#some_tender_money_to_me...&#34;&gt;a currency marker&lt;/a&gt; – to make the last field work correctly. In other words: it&amp;rsquo;s a kludge. The sad truth is that sometimes variable-width fields are a better solution.&lt;/p&gt;

&lt;p&gt;So &lt;code&gt;form&lt;/code&gt; provides them too. Any field specification may include a plus sign (&lt;code&gt;+&lt;/code&gt;) anywhere between its braces, in which case it specifies an &lt;em&gt;extensible field&lt;/em&gt;: a field whose width is minimal, rather than absolute. So, in the above example, our call to &lt;code&gt;form&lt;/code&gt; should actually look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @procs {
        print form
            &amp;quot;{&amp;gt;&amp;gt;&amp;gt;}  {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;(20)&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}  {&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;+}  {&amp;gt;&amp;gt;.}%&amp;quot;,
            .{pid}, .{cmd},               .{time},  .{cpu};
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and would produce this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     2461  vi -ii henry           0:55.83   11.6%
     2395  ex cathedra            0:06.59    3.5%
    27384  lynx www.divorce.com  1214:23.75    0.8%
     2439  head anne.boleyn       0:00.18    0.1%
     2581  dig -short grave       0:01.04    0.0%
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;just like &lt;code&gt;printf&lt;/code&gt; does.&lt;/p&gt;

&lt;p&gt;Likewise, if we thought the command names might exceed 20 columns we could let that field stretch too:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @procs {
        print form
            &amp;quot;{&amp;gt;&amp;gt;&amp;gt;}  {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;(20+)&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}  {&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;+}  {&amp;gt;&amp;gt;.}%&amp;quot;,
            .{pid}, .{cmd},               .{time},  .{cpu};
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the field width specifier would still warn us if the field&amp;rsquo;s &amp;ldquo;picture&amp;rdquo; was not exactly 20 columns wide, but the resulting field would nevertheless stretch as necessary to accommodate longer data.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S07.html&#34;&gt;Synopsis 7&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-within-that-space-you-may-have-drawn-together-within-that-space-you-may-have-drawn-together-span&#34;&gt;&lt;span id=&#34;within_that_space_you_may_have_drawn_together...&#34;&gt;Within that space you may have drawn together&amp;hellip;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;When a field is being filled in, whitespace is normally left as-is (except for justification, and wrapping of lines in block fields). However, this behaviour can be altered by specifying a &lt;em&gt;whitespace squeezing&lt;/em&gt; strategy. Squeezing replaces those substrings of the data that match a specified pattern (for example: &lt;code&gt;/\s+/&lt;/code&gt;), substituting a single space character.&lt;/p&gt;

&lt;p&gt;If we don&amp;rsquo;t want the default (non-)squeezing strategy we can use the &lt;code&gt;:ws&lt;/code&gt; option specify the particular pattern that is to be used for squeezing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        :ws(/\h+/),            # squeeze any horizontal whitespace
        $format1, *@data1,
        :ws(/&amp;lt;comment&amp;gt;|\s+/),  # now squeeze comments or whitespace
        $format2, *@data2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example, suppose we have a eulogy generator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub eulogize ($who, $to, $blaming) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;that (rather poorly) drops the appropriate names into a pre-formatted template, to produce strings like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Friends,   Romans  , countrymen, lend me your ears;
    I come to bury    Caesar   , not to praise him.
    The evil that men do lives after them;
    The good is oft interred with their bones;
    So let it be with    Caesar    . The noble    Brutus
    Hath told you     Caesar     was ambitious:
    If it were so, it was a grievous fault,
    And grievously hath    Caesar    answer&#39;d it.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we interpolate that string, with its extra spaces and its embedded newlines, into a &lt;code&gt;form&lt;/code&gt; field:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
         &amp;quot;| {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[} |&amp;quot;,
            eulogize(&#39;Caesar&#39;, to=&amp;gt;&#39;Romans&#39;, blaming=&amp;gt;&#39;Brutus&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we&amp;rsquo;d get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    | Friends,   Romans  , countrymen, lend me   |
    | your ears;                                 |
    | I come to bury    Caesar   , not to praise |
    | him.                                       |
    | The evil that men do lives after them;     |
    | The good is oft interred with their bones; |
    | So let it be with    Caesar    . The noble |
    | Brutus                                     |
    | Hath told you     Caesar     was           |
    | ambitious:                                 |
    | If it were so, it was a grievous fault,    |
    | And grievously hath    Caesar    answer&#39;d  |
    | it.                                        |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the extra spaces and the embedded newlines are preserved in the resulting text.&lt;/p&gt;

&lt;p&gt;But, if we told &lt;code&gt;form&lt;/code&gt; to squeeze all whitespaces:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form :ws(/\s+/),
         &amp;quot;| {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[} |&amp;quot;,
            eulogize(&#39;Caesar&#39;, to=&amp;gt;&#39;Romans&#39;, blaming=&amp;gt;&#39;Brutus&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we&amp;rsquo;d get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    | Friends, Romans , countrymen, lend me your |
    | ears; I come to bury Caesar , not to       |
    | praise him. The evil that men do lives     |
    | after them; The good is oft interred with  |
    | their bones; So let it be with Caesar .    |
    | The noble Brutus Hath told you Caesar was  |
    | ambitious: If it were so, it was a         |
    | grievous fault, And grievously hath Caesar |
    | answer&#39;d it.                               |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;with each sequence of characters that match &lt;code&gt;/\s+/&lt;/code&gt; being reduced to a single space.&lt;/p&gt;

&lt;p&gt;On the other hand, if we wanted to preserve the newlines and squeeze only horizontal whitespace, that would be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form :ws(/\h+/),
         &amp;quot;| {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[} |&amp;quot;,
            eulogize(&#39;Caesar&#39;, to=&amp;gt;&#39;Romans&#39;, blaming=&amp;gt;&#39;Brutus&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which produces:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    | Friends, Romans , countrymen, lend me your |
    | ears;                                      |
    | I come to bury Caesar , not to praise him. |
    | The evil that men do lives after them;     |
    | The good is oft interred with their bones; |
    | So let it be with Caesar . The noble       |
    | Brutus                                     |
    | Hath told you Caesar was ambitious:        |
    | If it were so, it was a grievous fault,    |
    | And grievously hath Caesar answer&#39;d it.    |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, for this particular text, none of these solutions is entirely satisfactory since squeezing the whitespaces to a single space still leaves a single space in places like &lt;code&gt;&amp;quot;Caesar .&amp;quot;&lt;/code&gt; and &lt;code&gt;&amp;quot;Romans ,&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To remove those blemishes we need to take advantage of a more sophisticated aspect of &lt;code&gt;form&lt;/code&gt;&amp;rsquo;s whitespace squeezing behaviour. Namely that, when squeezing whitespace using a particular pattern, &lt;code&gt;form&lt;/code&gt; detects if that pattern captures anything and &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; squeeze the captured items.&lt;/p&gt;

&lt;p&gt;More precisely, if the squeeze pattern matches but doesn&amp;rsquo;t capture, &lt;code&gt;form&lt;/code&gt; simply replaces the entire match with a single space character. But if the squeeze pattern &lt;em&gt;does&lt;/em&gt; capture, &lt;code&gt;form&lt;/code&gt; doesn&amp;rsquo;t insert a space character, but instead replaces the entire match with the concatenation of the captured substrings.&lt;/p&gt;

&lt;p&gt;That means we can completely eliminate any whitespace before a punctuation character with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form :ws(/\h+ (&amp;lt;punct&amp;gt;)?/),
         &amp;quot;| {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[} |&amp;quot;,
            eulogize(&#39;Caesar&#39;, to=&amp;gt;&#39;Romans&#39;, blaming=&amp;gt;&#39;Brutus&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which produces the desired:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    | Friends, Romans, countrymen, lend me your  |
    | ears;                                      |
    | I come to bury Caesar, not to praise him.  |
    | The evil that men do lives after them;     |
    | The good is oft interred with their bones; |
    | So let it be with Caesar. The noble Brutus |
    | Hath told you Caesar was ambitious:        |
    | If it were so, it was a grievous fault,    |
    | And grievously hath Caesar answer&#39;d it.    |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works because, in those instances where the pattern &lt;code&gt;/\h+ (&amp;lt;punct&amp;gt;)?/&lt;/code&gt; matches some whitespace followed by a punctuation character, the punctuation character is captured, and the captured character is then used to replace the entire whitespace-plus-punctuator. On the other hand, if the pattern matches whitespace but no punctuator (and it&amp;rsquo;s allowed to do that because the punctuator is optional), then nothing is captured, so &lt;code&gt;form&lt;/code&gt; falls back to replacing the whitespace with a single space.&lt;/p&gt;

&lt;h4 id=&#34;span-id-he-doth-fill-fields-with-harness-he-doth-fill-fields-with-harness-span&#34;&gt;&lt;span id=&#34;he_doth_fill_fields_with_harness...&#34;&gt;He doth fill fields with harness&amp;hellip;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Fields are (almost) always of a fixed width. So, if there isn&amp;rsquo;t enough data to fill a particular field, the unused portions of that field are filled in with spaces to preserve the vertical alignment of other columns of formatted data. However, spaces are only the default. The &lt;code&gt;:hfill&lt;/code&gt; (horizontal fill) option can be used to change fillers. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        :hfill(&amp;quot;=-&amp;quot;),                   # Fill next fields with &amp;quot;=-&amp;quot;
        &amp;quot;{|{*}|}\n&amp;quot;,                    # Full width field for title
        &amp;quot;[ Table of Contents ]&amp;quot;,        # Title
        :hfill(&amp;quot; .&amp;quot;),                   # Fill next fields with spaced dots
        &#39;   {[[[[[{*}[[[[[}{]]]}   &#39;,   # Two indented block fields
            @contents,     @page;       # Data for those blocks
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This fills the empty space either side of the centred title with a repeated &lt;code&gt;=-=-=-&lt;/code&gt; sequence. It then fills the gaps to the right of the left-justified the contents field, and to left of the right-justified pages field, with spaced dots. Which, rather prettily, produces something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    =-=-=-=-=-=-=-[ Table of Contents ]-=-=-=-=-=-=-=

       Foreword. . . . . . . . . . . . . . . . . .i
       Preface . . . . . . . . . . . . . . . . .iii
       Glossary. . . . . . . . . . . . . . . . . vi
       Introduction. . . . . . . . . . . . . . . .1
       The Tempest . . . . . . . . . . . . . . . .7
       Two Gentlemen of Verona . . . . . . . . . 17
       The Merry Wives of Winsor . . . . . . . . 27
       Twelfh Night. . . . . . . . . . . . . . . 39
       Measure for Measure . . . . . . . . . . . 50
       Much Ado About Nothing. . . . . . . . . . 62
       A Midsummer Night&#39;s Dream . . . . . . . . 73
       Love&#39;s Labour&#39;s Lost. . . . . . . . . . . 82
       The Merchant of Venice. . . . . . . . . . 94
       As You Like It. . . . . . . . . . . . . .105
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the fill sequence doesn&amp;rsquo;t have to be a single character and that the fill pattern is consistent across multiple fields and between adjacent lines. That is, it&amp;rsquo;s as if every field is first filled with the same fill pattern, then the actual data written over the top. That&amp;rsquo;s particularly handy in the above example, because it ensures that the fill pattern seamlessly bridges the boundary between the adjacent contents and pages fields.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s also possible to specify separate fill sequences for the left- and right-hand gaps in a particular field, using the &lt;code&gt;:lfill&lt;/code&gt; and &lt;code&gt;:rfill&lt;/code&gt; options. This is particularly common for numerical fields. For example, this call to &lt;code&gt;form&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
      &#39;Name              Bribe (per dastardry)&#39;,
      &#39;=============     =====================&#39;,
      &#39;{[[[[[[[[[[[}         {]],]]].[[[}     &#39;,
      @names,                @bribes;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;would print something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Name              Bribe (per dastardry)
    =============     =====================
    Crookback                  12.676
    Iago                        1.62
    Borachio               45,615.0
    Shylock                    19.0003
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;with the numeric field padded with whitespace and only showing as many decimal places as there are in the data.&lt;/p&gt;

&lt;p&gt;However, in order to prevent subsequent..err&amp;hellip;creative calligraphy (they &lt;em&gt;are&lt;/em&gt;, after all, villains and would presumably not hesitate to add a few digits to the front of each number), we might prefer to put stars before the numbers and show all decimal places. We could do that like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
      &#39;Name              Bribe (per dastardry)&#39;,
      &#39;=============     =====================&#39;,
      &#39;{[[[[[[[[[[[}         {]],]]].[[[}     &#39;,
      @names,                :lfill(&#39;*&#39;), :rfill(&#39;0&#39;),
                             @bribes;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which would then print:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Name              Bribe (per dastardry)
    =============     =====================
    Crookback             *****12.6760
    Iago                  ******1.6200
    Borachio              *45,615.0000
    Shylock               *****19.0003
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the &lt;code&gt;:lfill&lt;/code&gt; and &lt;code&gt;:rfill&lt;/code&gt; options are specified &lt;em&gt;after&lt;/em&gt; the format string and, more particularly, before the data for the second field. This means that those options only take effect for that particular field and the previous fill behaviour is then reasserted for subsequent fields. Many other &lt;code&gt;form&lt;/code&gt; options – for example &lt;code&gt;:ws&lt;/code&gt;, &lt;code&gt;:height&lt;/code&gt;, or &lt;code&gt;:break&lt;/code&gt; – can be specified in this way, so as to apply them only to a particular field.&lt;/p&gt;

&lt;p&gt;There is also a general &lt;code&gt;:fill&lt;/code&gt; option that sets the default sequence for any filling that isn&amp;rsquo;t otherwise specified.&lt;/p&gt;

&lt;h4 id=&#34;span-id-but-say-thou-nought-but-say-thou-nought-span&#34;&gt;&lt;span id=&#34;but_say_thou_nought...&#34;&gt;But say thou nought&amp;hellip;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Filling numeric fields with zeros is so common that &lt;code&gt;form&lt;/code&gt; offers a shorthand notation for it. If the first character inside a numeric field specification is a zero, then the left-fill string for that field is set to &lt;code&gt;&amp;quot;0&amp;quot;&lt;/code&gt;. Likewise if the last character in the field is a zero, it is right-filled with zeros. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @nums = (0, 1, -1.2345, 1234.56, -1234.56, 1234567.89);

    print form
        &amp;quot;{]]]].[[}     {]]]].[0}     {0]]].[[}     {0]]].[0}&amp;quot;,
         @nums,        @nums,        @nums,        @nums;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;prints:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        0.0           0.000     00000.0       00000.000
        1.0           1.000     00001.0       00001.000
       -1.234        -1.234     -0001.234     -0001.234
     1234.56       1234.560     01234.56      01234.560
    -1234.56      -1234.560     -1234.56      -1234.560
    #####.###     #####.###     #####.###     #####.###
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-up-and-down-up-and-down-i-will-lead-them-up-and-down-up-and-down-up-and-down-i-will-lead-them-up-and-down-span&#34;&gt;&lt;span id=&#34;up_and_down,_up_and_down,_i_will_lead_them_up_and_down...&#34;&gt;Up and down, up and down, I will lead them up and down&amp;hellip;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Formatted text blocks are also filled vertically. Empty lines at the end of the block are normally filled with spaces (so as to preserve the alignment of any other fields on the same line). However, this too can be controlled, with the &lt;code&gt;:vfill&lt;/code&gt; option. Alternatively – as with horizontal filling – separate fill sequences can be specified for above and below the text using the &lt;code&gt;:tfill&lt;/code&gt; and &lt;code&gt;:bfill&lt;/code&gt; (&amp;ldquo;top&amp;rdquo; and &amp;ldquo;bottom&amp;rdquo; fill) options.&lt;/p&gt;

&lt;p&gt;For example, if we had six elements in &lt;code&gt;@task&lt;/code&gt;, but only four processors:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        :bfill(&#39;[unallocated]&#39;),
        &#39;Task                      Processor&#39;,
        &#39;====                      =========&#39;,
        &#39;{[[[[[[[[[[[[[[[[[[[[}  {]]]]]][[[[[}&#39;,
         @task,                      [1..4];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we&amp;rsquo;d get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Task                      Processor
    ====                      =========
    Borrow story                  1
    Rename characters             2
    Subdivide into scenes         3
    Write dialogue                4
    Check rhythm and meter  [unallocated]
    Insert puns and japes   [unallocated]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-i-have-got-strength-of-limit-i-have-got-strength-of-limit-span&#34;&gt;&lt;span id=&#34;i_have_got_strength_of_limit...&#34;&gt;I have got strength of limit&amp;hellip;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;It is possible to constrain the minimum and maximum number of lines that a particular format or block field must cover, regardless of how much data it contains. We do that using the &lt;code&gt;:height&lt;/code&gt; option. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        :height(3),
        &#39;{[[[[}{IIII}{]]]]}&#39;,
         $l,   $c,   $r;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will cause the call to &lt;code&gt;form&lt;/code&gt; to generate exactly three output lines, even if the contents of the data variables would normally fit in fewer lines or would actually require more.&lt;/p&gt;

&lt;p&gt;To specify a range of heights we can use the &lt;code&gt;:min&lt;/code&gt; and &lt;code&gt;:max&lt;/code&gt; suboptions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        :height{ :min(3), :max(20) },
        &#39;{[[[[}{IIII}{]]]]}&#39;,
         $l,   $c,   $r;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This specifies that, no matter how much data is available, the output will be no less than three lines and no more than 20.&lt;/p&gt;

&lt;p&gt;Note, however, that the &lt;code&gt;height&lt;/code&gt; option refers to the height of individual fields, not of entire output pages. we&amp;rsquo;ll see how to control the latter &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=12#measure_his_woe_the_length_and_breadth_of_mine...&#34;&gt;anon&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S07.html&#34;&gt;Synopsis 7&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-forbear-and-eat-no-more-forbear-and-eat-no-more-span&#34;&gt;&lt;span id=&#34;forbear,_and_eat_no_more.&#34;&gt;Forbear, and eat no more.&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;As we saw &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=6#and_now_at_length_they_overflow_their_banks.&#34;&gt;earlier&lt;/a&gt;, a block overflow field (&lt;code&gt;{VVVVVVVVV}&lt;/code&gt;) has the special property that it only overflows as much as necessary to fill the output lines generated by other block fields. That enabled us to create an overflowing column of text like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        :interleave, &amp;lt;&amp;lt;EOFORMAT,
            Name:
              {[[[[[[[[[[[[}
                              Biography:
            Status:             {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}
              {[[[[[[[[[[[[}    {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}
                                {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}
            Comments:           {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}
              {[[[[[[[[[[[}     {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}
            EOFORMAT
        $name,
        $biography,
        $status,
        $comments;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;without the first &lt;code&gt;{VVVVVVVVV}&lt;/code&gt; field eating all the data out of &lt;code&gt;$bio&lt;/code&gt; and leaving a large gap between the Status and the Comments.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s a very handy feature, but restricting the &amp;ldquo;minimal height&amp;rdquo; feature to overflow fields turns out to be not good enough in the general case. For instance, suppose we had wanted the biography field to start at the first line of the output text:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Name:             Biography:
      William           William Shakespeare was born on
      Shakespeare       April 23, 1564 in Strathford-upon-
                        Avon, England; he was third of
    Status:             eight children from Father John
      Deceased (1564    Shakespeare and Mother Mary Arden.
      -1616)            Shakespeare began his education at
                        the age of seven when he probably
    Comments:           attended the Strathford grammar
      Theories          school. The school provided
      abound as to      Shakespeare with his formal
      the true          education. The students chiefly
      author of his     studied Latin rhetoric, logic, and
      plays. The        literature. His knowledge and
      prime             imagination may have come from his
      alternative       reading of ancient authors and
      candidates        poetry. In November 1582,
      being Sir         Shakespeare received a license to
      Francis           marry Anne Hathaway. At the time of
      Bacon,            their marriage, Shakespeare was 18
      Christopher       years old and Anne was 26. They had
      Marlowe, or       three children, the oldest Susanna,
      Edward de         and twins- a boy, Hamneth, and a
      Vere              girl, Judith. Before his death on
                        April 23 1616, William Shakespeare
                        had written thirty-seven plays. He
                        is generally considered the greatest
                        playwright the world has ever known
                        and has always been the world&#39;s most
                        popular author.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To do that, we would have required a call to &lt;code&gt;form&lt;/code&gt; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        :interleave, &amp;lt;&amp;lt;EOFORMAT,
            Name:             Biography:
              {[[[[[[[[[[[[}    {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[}
                                {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}
            Status:             {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}
              {[[[[[[[[[[[[}    {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}
                                {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}
            Comments:           {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}
              {[[[[[[[[[[[}     {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}
            EOFORMAT
        $name,
        $biography,
        $status,
        $comments;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the first line of the Biography field now has to be a block field, not a single-line field (as in previous versions). It can&amp;rsquo;t be a single-line, because the Name field is a block field and that would leave a gap in the Biography column:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Name:             Biography:
      William           William Shakespeare was born on
      Shakespeare
                        April 23, 1564 in Strathford-upon-
    Status:             Avon, England; he was third of
                        etc.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So it has to be a block field, to &amp;ldquo;keep up&amp;rdquo; with however much output the multi-line Name field produces. Unfortunately, starting the Biography column with a normal block field doesn&amp;rsquo;t solve the problem either. In fact we get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Name:             Biography:
      William           William Shakespeare was born on
      Shakespeare       April 23, 1564 in Strathford-upon-
                        Avon, England; he was third of
                        eight children from Father John
                        Shakespeare and Mother Mary Arden.
                        Shakespeare began his education at
                        the age of seven when he probably
                        attended the Strathford grammar
                        school. The school provided
                        Shakespeare with his formal
                        education. The students chiefly
                        studied Latin rhetoric, logic, and
                        literature. His knowledge and
                        imagination may have come from his
                        reading of ancient authors and
                        poetry. In November 1582,
                        Shakespeare received a license to
                        marry Anne Hathaway. At the time of
                        their marriage, Shakespeare was 18
                        years old and Anne was 26. They had
                        three children, the oldest Susanna,
                        and twins- a boy, Hamneth, and a
                        girl, Judith. Before his death on
                        April 23 1616, William Shakespeare
                        had written thirty-seven plays. He
                        is generally considered the
                        greatest playwright the world has
                        ever known and has always been the
                        world&#39;s most popular author.

    Status:
      Deceased (1564
      -1616)

    Comments:
      Theories
      abound as to
      the true
      author of his
      plays. The
      prime
      alternative
      candidates
      being Sir
      Francis
      Bacon,
      Christopher
      Marlowe, or
      Edward de
      Vere
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Normal block fields are remorseless in consuming all of their data. So the first Biography field absolutely will not stop formatting, ever, until your entire &lt;code&gt;$biography&lt;/code&gt; string is gone.&lt;/p&gt;

&lt;p&gt;What we really need here, is a kinder, gentler block field; a block field that formats minimally, like an overflow field. And we get that with yet another &lt;code&gt;:height&lt;/code&gt; option: &lt;code&gt;:height«minimal»&lt;/code&gt;. Like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        :interleave, &amp;lt;&amp;lt;EOFORMAT,
            Name:             Biography:
              {[[[[[[[[[[[[}    {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[}
                                {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}
            Status:             {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}
              {[[[[[[[[[[[[}    {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}
                                {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}
            Comments:           {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}
              {[[[[[[[[[[[}     {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}
            EOFORMAT
         $name,
         :height«minimal», $biography,
         $status,
         $comments;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When this option is applied to a particular field (by placing it immediately before the field&amp;rsquo;s data), that field only consumes as much of its data is is required to fill the output lines created by the other (non-minimal) fields in the same format. In this case, that means that the first Biography field only extracts as much data from &lt;code&gt;$biography&lt;/code&gt; as is needed to fill the text lines created by the Name field.&lt;/p&gt;

&lt;p&gt;Note that any kind of block field can be modified in this way: justified, numeric, currency, or verbatim.&lt;/p&gt;

&lt;h4 id=&#34;span-id-now-is-the-jerkin-under-the-line-now-is-the-jerkin-under-the-line-span&#34;&gt;&lt;span id=&#34;now_is_the_jerkin_under_the_line...&#34;&gt;Now is the jerkin under the line&amp;hellip;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;As some of the examples we&amp;rsquo;ve seen so far illustrate, formats frequently consist of a set of column titles, followed by the corresponding columns of data. And, typically, those column titles are underlined to make them stand out:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
      &#39;Name              Bribe (per dastardry)&#39;,
      &#39;=============     =====================&#39;,
      &#39;{[[[[[[[[[[[}         {]],]]].[[[}     &#39;,
      @names,                @bribes;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So &lt;code&gt;form&lt;/code&gt; has an option that automates that process. For example, the payments example above could also have been written:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
      &#39;Name              Bribe (per dastardry)&#39;,
      :under(&amp;quot;=&amp;quot;),
      &#39;{[[[[[[[[[[[}         {]],]]].[[[}     &#39;,
      @names,                @bribes;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;:under&lt;/code&gt; option takes a string and uses it to underline the most recently formatted line. It does this by examining the formats immediately before and after the &lt;code&gt;:under&lt;/code&gt;. It then generates a series of underlines by repeating the specified underlining string as many times as required. The underlines are generated such that every field and every other non-whitespace literal in the preceding format has a underline under it and every field/non-whitespace in the next format has an &amp;ldquo;overline&amp;rdquo; above it.&lt;/p&gt;

&lt;p&gt;For example, this call to &lt;code&gt;form&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        &#39;      Rank Name         Serial Number&#39;,
        :under(&amp;quot;_&amp;quot;),
        &#39;{]]]]]]]]} {[[[[[[[[[}     {IIIII}&#39;,
             @ranks,@names,          @nums;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;prints:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          Rank Name         Serial Number
    __________ ___________  _____________
      Corporal Nym              CMXVII
    Lieutenant Bardolph          CCIV
       Captain Spurio           MMMCDX
       General Pompey             XI
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The usual effect is that the auto-generated underlines always extend to the edges of both the preceding title and the following field, whichever is wider.&lt;/p&gt;

&lt;p&gt;Many people, of course, prefer to draw the underlines themselves, as the results are then much easier to visualize when looking at the code. The &lt;code&gt;:under&lt;/code&gt; option is most useful when we&amp;rsquo;re constructing tables programmatically, with columns and column titles that are only known at run-time.&lt;/p&gt;

&lt;h4 id=&#34;span-id-they-come-like-sacrifices-in-their-trim-they-come-like-sacrifices-in-their-trim-span&#34;&gt;&lt;span id=&#34;they_come_like_sacrifices_in_their_trim...&#34;&gt;They come like sacrifices in their trim&amp;hellip;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The default &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=10#he_doth_fill_fields_with_harness...&#34;&gt;fill-with-spaces behaviour&lt;/a&gt; of fields is useful to preserve the vertical alignment of columns within a formatted text, but it could also potentially increase the size of &lt;code&gt;form&lt;/code&gt;&amp;rsquo;s output unnecessarily. For example, the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        &#39;To Do:&#39;,
        &#39;   {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[}&#39;,
            @todo;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;might produce something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    To Do:
       Dissemble
       Deceive
       Dispute
       Defy
       Duel
       Defeat
       Dispatch                                          
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That looks fine but, because each line is produced by the large left-justified field that is automatically filled with whitespace, the output contains several hundred more space characters than are strictly necessary (you probably didn&amp;rsquo;t notice them, but they&amp;rsquo;re all there – hanging off the right sides of the individual To-Do items).&lt;/p&gt;

&lt;p&gt;Fortunately, however, &lt;code&gt;form&lt;/code&gt; is smarter than that. Extraneous trailing whitespace on the right-hand side of any output line is automatically trimmed. So the above example actually produces:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    To Do:
       Dissemble
       Deceive
       Dispute
       Defy
       Duel
       Defeat
       Dispatch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, if you really do need those &amp;ldquo;invisible&amp;rdquo; trailing whitespaces for some reason, &lt;code&gt;form&lt;/code&gt; provides a way to keep them – the &lt;code&gt;:untrimmed&lt;/code&gt; option:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form :untrimmed,
        &#39;To Do:&#39;,
        &#39;   {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[}&#39;,
            @todo;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S07.html&#34;&gt;Synopsis 7&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-master-page-i-am-glad-to-see-you-master-page-i-am-glad-to-see-you-span&#34;&gt;&lt;span id=&#34;master_page,_i_am_glad_to_see_you...&#34;&gt;Master Page, I am glad to see you&amp;hellip;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Normally, &lt;code&gt;form&lt;/code&gt; assumes that whatever data it is formatting is supposed to produce a single, arbitrarily long, unbroken piece of text. But &lt;code&gt;form&lt;/code&gt; can also format data into multiple pages of fixed length and width, inserting customized, page-specific headers, footers, and pagefeeds for each page.&lt;/p&gt;

&lt;p&gt;All these features are controlled by the the &lt;code&gt;page&lt;/code&gt; option (or more precisely, by its various suboptions):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        :page{ :length( $page_len ),       # Default: 60 lines
               :width( $page_width ),      # Default: 78 columns
               :number( $first_page_num ), # Default: 1
               :header( &amp;amp;make_header ),    # Default: no header
               :footer( &amp;amp;make_footer ),    # Default: no footer
               :feed( &amp;amp;make_pagefeed ),    # Default: no pagefeed
               :body( &amp;amp;adjust_body ),      # Default: no chiropracty
             },
        $format,
        *@args;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-measure-his-woe-the-length-and-breadth-of-mine-measure-his-woe-the-length-and-breadth-of-mine-span&#34;&gt;&lt;span id=&#34;measure_his_woe_the_length_and_breadth_of_mine...&#34;&gt;Measure his woe the length and breadth of mine&amp;hellip;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;:page{ :length(...) }&lt;/code&gt; suboption determines the number of output lines per page (including headers and footers). Normally, this suboption is set to infinity, which produces that single, arbitrarily long, unbroken page of text. But the suboption can be set to any positive integer value, to cause &lt;code&gt;form&lt;/code&gt; to generate distinct pages of that many lines each.&lt;/p&gt;

&lt;p&gt;The value of the &lt;code&gt;:page{ :width(...) }&lt;/code&gt; suboption is used to determine the width of &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=9#and_every_one_shall_share...&#34;&gt;distributive fields&lt;/a&gt; and in some &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=12#do_to_this_body_what_extremes_you_can...&#34;&gt;page body postprocessors&lt;/a&gt;. By default, this suboption is set to 78 (columns), but it may be set to any positive integer value.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;:page{ :number(...) }&lt;/code&gt; suboption specifies the current page number. By default it starts at 1, but may be set to any numeric value. This suboption is generally only of use in headers and footers (see below).&lt;/p&gt;

&lt;h4 id=&#34;span-id-from-the-crown-of-his-head-to-the-sole-of-his-foot-from-the-crown-of-his-head-to-the-sole-of-his-foot-span&#34;&gt;&lt;span id=&#34;from_the_crown_of_his_head_to_the_sole_of_his_foot...&#34;&gt;From the crown of his head to the sole of his foot&amp;hellip;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;:page{ :header(...) }&lt;/code&gt; suboption specifies a hash containing a set of strings or subroutines that are to be used to create page headers. Each key of the hash indicates a particular kind of page that the corresponding value will provide the header for. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    :header{ first =&amp;gt; &amp;quot;           &#39;The Tempest&#39; by W. Shakespeare          &amp;quot;,
             last  =&amp;gt; &amp;quot;                   -- The End --                    &amp;quot;,
             odd   =&amp;gt; &amp;quot;Act $act, Scene $scene                              &amp;quot;,
             even  =&amp;gt; &amp;quot;                                                    &amp;quot;,
             other =&amp;gt; &amp;quot;          [Thys hedder intenshunally blanke]        &amp;quot;,
           }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Given the above specification, &lt;code&gt;form&lt;/code&gt; will:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;use the full title and author as the header of the first page,&lt;/li&gt;
&lt;li&gt;write &lt;code&gt;&amp;quot;-- The End --&amp;quot;&lt;/code&gt; across the top of the last page,&lt;/li&gt;
&lt;li&gt;prepend the act and scene information to the start of any odd page (except, of course, the first or the last), and&lt;/li&gt;
&lt;li&gt;provide an empty line as the header of any even page (except the last, if it happens to be even).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that, in this case, since we&amp;rsquo;ve provided specific headers for every odd and even page, the &lt;code&gt;&amp;quot;other&amp;quot;&lt;/code&gt; header will never be used. On the other hand, if we&amp;rsquo;d specified:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    :header{ first =&amp;gt; &amp;quot;           &#39;The Tempest&#39; by W. Shakespeare          &amp;quot;,
             other =&amp;gt; &amp;quot;                                       &#39;The Tempest&#39;&amp;quot;,
           }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then every page except the first would have just a right-justified title at the top.&lt;/p&gt;

&lt;p&gt;Of course, if we want every page to have the same header, we can just write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    :header{ other =&amp;gt; &amp;quot;                                       &#39;The Tempest&#39;&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But that&amp;rsquo;s a little klunky, so &lt;code&gt;form&lt;/code&gt; also accepts a single string instead of a hash, to specify a header to be used for every page:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    :header(&amp;quot;                                       &#39;The Tempest&#39;&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Headers don&amp;rsquo;t all have to be the same size either. For example, we might prefer a more imposing first header:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    :header{ first =&amp;gt; &amp;quot;                  &#39;The Tempest&#39;                   \n&amp;quot;
                    ~ &amp;quot;                        by                        \n&amp;quot;
                    ~ &amp;quot;                  W. Shakespeare                  \n&amp;quot;
                    ~ &amp;quot;____________________________________________________&amp;quot;,

             other =&amp;gt; &amp;quot;                                       &#39;The Tempest&#39;&amp;quot;,
           }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;form&lt;/code&gt; simply notes the number of lines each header requires and then reduces the available number of lines within the page accordingly, so as to preserve the exact overall page length.&lt;/p&gt;

&lt;p&gt;Often we&amp;rsquo;ll need headers that aren&amp;rsquo;t fixed strings. For example, we might want each page to include the appropriate page number. So instead of a string, we&amp;rsquo;re allowed to specify a particular header as a subroutine. That subroutine is then called each time that particular header is required, and its return value is used as the required header.&lt;/p&gt;

&lt;p&gt;When the subroutine is called, the current set of active formatting options are passed to it as a list of pairs. Typically, then, the subroutine will specify one or more named-only parameters corresponding to the options it cares about, followed by a starred hash parameter to collect the rest. For example if every page should have its (left-justified) page number for a header:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    :header( sub (+$page, *%_) { return $page{number}; } )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, this is also an excellent candidate for the cleaner (but equivalent) syntax of placeholder variables in raw blocks:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    :header{ $^page{number}; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And, naturally, we can mix-and-match static and dynamic headers:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    :header{ odd  =&amp;gt; &amp;quot;                                        &#39;The Tempest&#39;&amp;quot;,
             even =&amp;gt; { $^page{number}; },
           }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Footers work in exactly the same way in almost all respects; the obvious exception being that they&amp;rsquo;re placed at the end of a page, rather than the start.&lt;/p&gt;

&lt;p&gt;Pagefeeds work the same way too. A pagefeed is a string that is placed between the footer of one page and the header of the next. They&amp;rsquo;re like formfeeds, except they can be any string we choose (not just &lt;code&gt;\c[FF]&lt;/code&gt;). They&amp;rsquo;re called &amp;ldquo;pagefeeds&amp;rdquo; instead of &amp;ldquo;formfeeds&amp;rdquo; because they&amp;rsquo;re placed between pages, not between calls to &lt;code&gt;form&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a complete example to illustrate the full set of features:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @tobe = slurp &#39;Soliloquy.txt&#39;  err die;

    my %page = (
        :length(15),
        :header{ first =&amp;gt; &amp;quot;Hamlet&#39;s soliloquy begins...\n\n&amp;quot;,
                 odd   =&amp;gt; &amp;quot;Hamlet&#39;s soliloquy continues...\n\n&amp;quot;,
                 even  =&amp;gt; { form &#39;{&amp;gt;&amp;gt;{*}&amp;gt;&amp;gt;}&#39;, &amp;quot;Hamlet&#39;s soliloquy continues...\n\n&amp;quot;; },
                 last  =&amp;gt; &amp;quot;Hamlet&#39;s soliloquy concludes...\n\n&amp;quot;,
               },
        :footer{
                 last  =&amp;gt; { form &amp;quot;\n{||{*}||}&amp;quot;, &amp;quot;END OF TEXT&amp;quot;; }
                 other =&amp;gt; { form &amp;quot;\n{&amp;gt;&amp;gt;{*}&amp;gt;&amp;gt;}&amp;quot;, &amp;quot;../&amp;quot;~($^page{number}+1); },
               },
        :feed(&amp;quot;\f&amp;quot;),
    );

    print form
        :page(%page),
        &#39;{]]]]]}  {&amp;quot;{*}&amp;quot;}  {[[[[[}&#39;,
        [1..@tobe], @tobe,  [1..@tobe];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which prints:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Hamlet&#39;s soliloquy begins...

          1  To be, or not to be -- that is the question:          1
          2  Whether &#39;tis nobler in the mind to suffer             2
          3  The slings and arrows of outrageous fortune           3
          4  Or to take arms against a sea of troubles             4
          5  And by opposing end them. To die, to sleep --         5
          6  No more -- and by a sleep to say we end               6
          7  The heartache, and the thousand natural shocks        7
          8  That flesh is heir to. &#39;Tis a consummation            8
          9  Devoutly to be wished. To die, to sleep --            9
         10  To sleep -- perchance to dream: ay, there&#39;s the rub,  10
         11  For in that sleep of death what dreams may come       11

                                                                      ../2
    ^L
                                           Hamlet&#39;s soliloquy continues...

         12  When we have shuffled off this mortal coil,           12
         13  Must give us pause. There&#39;s the respect               13
         14  That makes calamity of so long life.                  14
         15  For who would bear the whips and scorns of time,      15
         16  Th&#39; oppressor&#39;s wrong, the proud man&#39;s contumely      16
         17  The pangs of despised love, the law&#39;s delay,          17
         18  The insolence of office, and the spurns               18
         19  That patient merit of th&#39; unworthy takes,             19
         20  When he himself might his quietus make                20
         21  With a bare bodkin? Who would fardels bear,           21
         22  To grunt and sweat under a weary life,                22

                                                                      ../3
    ^L
    Hamlet&#39;s soliloquy continues...

         23  But that the dread of something after death,          23
         24  The undiscovered country, from whose bourn            24
         25  No traveller returns, puzzles the will,               25
         26  And makes us rather bear those ills we have           26
         27  Than fly to others that we know not of?               27
         28  Thus conscience does make cowards of us all,          28
         29  And thus the native hue of resolution                 29
         30  Is sicklied o&#39;er with the pale cast of thought,       30
         31  And enterprise of great pitch and moment              31
         32  With this regard their currents turn awry             32
         33  And lose the name of action. -- Soft you now,         33

                                                                      ../4
    ^L
    Hamlet&#39;s soliloquy concludes...

         34  The fair Ophelia! -- Nymph, in thy orisons            34
         35  Be all my sins remembered.                            35










                                 END OF TEXT
    ^L
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note, in particular, the nested calls to &lt;code&gt;form&lt;/code&gt; within some of the subroutines – to center or right-justify a particular header or footer. Permitting just this kind of &amp;ldquo;recursive&amp;rdquo; formatting is one of the main reasons Perl 5&amp;rsquo;s built-in &lt;code&gt;format&lt;/code&gt; has become the (reentrant) &lt;code&gt;form&lt;/code&gt; subroutine in Perl 6.&lt;/p&gt;

&lt;h4 id=&#34;span-id-do-to-this-body-what-extremes-you-can-do-to-this-body-what-extremes-you-can-span&#34;&gt;&lt;span id=&#34;do_to_this_body_what_extremes_you_can...&#34;&gt;Do to this body what extremes you can&amp;hellip;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Sometimes it&amp;rsquo;s useful to be able to grab the entire body of a page (i.e. the contents of the page between the header and footer) &lt;em&gt;after&lt;/em&gt; it&amp;rsquo;s been formatted together. For example, we might wish to centre those contents, or to crop them at a particular column.&lt;/p&gt;

&lt;p&gt;To this end, the &lt;code&gt;:page{ :body(...) }&lt;/code&gt; suboption allows us to specify a page body post-processor. That is, a subroutine or format that lays out the page&amp;rsquo;s formatted text between the page&amp;rsquo;s header and footer. Like the &lt;code&gt;:header&lt;/code&gt;, &lt;code&gt;:footer&lt;/code&gt;, and &lt;code&gt;:feed&lt;/code&gt; suboptions, the &lt;code&gt;:body&lt;/code&gt; suboption can take either a closure, a hash, or a string.&lt;/p&gt;

&lt;p&gt;If the value of the &lt;code&gt;:body&lt;/code&gt; suboption is a string or a hash of pairs, the text of the body is (recursively) &lt;code&gt;form&lt;/code&gt;&amp;lsquo;ed using that string (or those string values) as its format. A very common usage is to arrange for the formatted text to be horizonally and vertically centred on each page:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    :body(&#39;{=I{*}I=}&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A more sophisticated variation on this is to use a hash to insert a left or right &amp;ldquo;gutter&amp;rdquo; for each page:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $gutter = &amp;quot; &amp;quot; x $gutter_width;

    :body{ odd   =&amp;gt;  $gutter ~ &#39;{&amp;quot;&amp;quot;&amp;quot;{*}&amp;quot;&amp;quot;&amp;quot;}&#39;,
           even  =&amp;gt;  &#39;{&amp;quot;&amp;quot;&amp;quot;{*}&amp;quot;&amp;quot;&amp;quot;}&#39; ~ $gutter,
         }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the other hand, if the value of the &lt;code&gt;:body&lt;/code&gt; suboption is closure, the body text is passed to that closure as an array of lines. A second array is also passed in, containing as many newlines as would be needed to pad out the body text to the correct number of lines for the page. Finally, the current formatting options are passed as a list of pairs. As with the &lt;code&gt;:header&lt;/code&gt; etc. suboption, the closure is expected to return a single string (representing the final formatting of the page body).&lt;/p&gt;

&lt;p&gt;For example, to add line numbers to the text each page (but &lt;em&gt;not&lt;/em&gt; to the headers or footers or filler lines):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub numerate (@lines, @fill, +$page, *%_) {

        # Remember line numbers from call to call...
        state $linenum = 1;

        # Compute range of line numbers
        my @linenums = ($linenum .. $linenum+@lines-1);

        # Reformat body lines verbatim,
        # with a left-justified line number before each...
        my $body = form &#39;{[[[[} {&amp;quot;&amp;quot;&amp;quot;{*}&amp;quot;&amp;quot;&amp;quot;}&#39;,
                         @linenums, @lines,
                        *@fill;

        # Update the final line number and return the new body text...
        $linenum += @lines;
        return $body;
    }

    print form
        :page{ :body(&amp;amp;numerate),
               :header(&amp;quot;\n==========\n\n&amp;quot;),
               :length(12),
             },
        # Left-justify the Briton...
        &amp;quot;{[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[}&amp;quot;,
        %soliloquy{RichardIII},
                         # Right-justify the Dane...
        &amp;quot;                 {]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]}&amp;quot;,
                          %soliloquy{Hamlet};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which produces:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ==========

    1      Now is the winter of our discontent /
    2      Made glorious summer by this sun of
    3      York; / And all the clouds that lour&#39;d
    4      upon our house / In the deep bosom of
    5      the ocean buried. / Now are our brows
    6      bound with victorious wreaths; / Our
    7      bruised arms hung up for monuments; /
    8      Our stern alarums changed to merry
    9      meetings, / Our dreadful marches to

    ==========

    10     delightful measures. Grim-visaged war
    11     hath smooth&#39;d his wrinkled front; / And
    12     now, instead of mounting barded steeds
    13     / To fright the souls of fearful
    14     adversaries, / He capers nimbly in a
    15     lady&#39;s chamber.




    ==========

    16                      To be, or not to be -- that is the question: /
    17                         Whether &#39;tis nobler in the mind to suffer /
    18                       The slings and arrows of outrageous fortune /
    19                         Or to take arms against a sea of troubles /
    20                       And by opposing end them. To die, to sleep --
    21                         / No more -- and by a sleep to say we end /
    22                      The heartache, and the thousand natural shocks
    23                      / That flesh is heir to. &#39;Tis a consummation /
    24                        Devoutly to be wished. To die, to sleep -- /

    ==========

    25                         To sleep -- perchance to dream: ay, there&#39;s
    26                          the rub, / For in that sleep of death what
    27                         dreams may come / When we have shuffled off
    28                             this mortal coil, / Must give us pause.
    29                        There&#39;s the respect / That makes calamity of
    30                                                       so long life.






                    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S07.html&#34;&gt;Synopsis 7&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-define-define-welleducated-infant-define-define-well-educated-infant-span&#34;&gt;&lt;span id=&#34;define,_define,_welleducated_infant.&#34;&gt;Define, define, well-educated infant.&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Laziness is, of course, a major virtue. And one of the Laziest approaches to programming is never to repeat oneself. Which is why Perl 6 has subroutines and macros and classes and constants and dozens of other ways for us to factor out commonalities.&lt;/p&gt;

&lt;p&gt;Occasionally, the same need for factoring arises in formatting. For example, suppose we want a field that masks its data in some way. Perhaps a field that blanks out certain words by replacing them with the corresponding number of X&amp;rsquo;s.&lt;/p&gt;

&lt;p&gt;We could always do that by writing a subroutine that generates the appropriate filter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub expurgate (Str *@hidewords) {
        return sub (Str $data is rw) {
            $data ~~ s:ei/(@hidewords)/$( &#39;X&#39; x length $1 )/;
            return $data;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We could then apply that subroutine to the data of any field that needed bowdlerization:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my &amp;amp;censor := expurgate «villain plot libel treacherous murderer false deadly &#39;G&#39;»;

    print form
        &amp;quot;[Ye following tranfcript hath been cenfored by Order of ye King]\n\n&amp;quot;,
        &amp;quot;         {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[}&amp;quot;,
                  censor($speech);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to produce:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [Ye following tranfcript hath been cenfored by Order of ye King]

             And therefore, since I cannot prove a lover,
             To entertain these fair well-spoken days,
             I am determined to prove a XXXXXXX
             And hate the idle pleasures of these days.
             XXXXs have I laid, inductions dangerous,
             By drunken prophecies, XXXXXs and dreams,
             To set my brother Clarence and the king
             In XXXXXX hate the one against the other:
             And if King Edward be as true and just
             As I am subtle, XXXXX and XXXXXXXXXXX,
             This day should Clarence closely be mew&#39;d up,
             About a prophecy, which says that XXX
             Of Edward&#39;s heirs the XXXXXXXX shall be.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, if this were Puritanism and not Perl, we might have a long list of proscribed words that we needed to excise from &lt;em&gt;every&lt;/em&gt; formatted text. In that case, rather that explicitly running every data source through the same censorious subroutine, it would be handy if &lt;code&gt;form&lt;/code&gt; had a built-in field that did that for us automatically.&lt;/p&gt;

&lt;p&gt;Naturally, &lt;code&gt;form&lt;/code&gt; doesn&amp;rsquo;t have such a field built-in&amp;hellip;but we can certainly give it one.&lt;/p&gt;

&lt;p&gt;User-defined field specifiers can be declared using the &lt;code&gt;:field&lt;/code&gt; option, which takes as its value an array of pairs. The key of each pair is a string or a rule (i.e. regex) that specifies the syntax of the user-defined field. The value of each pair is a closure/subroutine that constructs a standard field specifier to replace the user-defined specifier. Alternatively, the value of a pair may be a string, which is taken as the (static) field specifier to be used instead of the user-defined field.&lt;/p&gt;

&lt;p&gt;In other words, each pair is a macro that maps a user-defined field (specified by the pair&amp;rsquo;s key) onto a standard &lt;code&gt;form&lt;/code&gt; field (specified by the pair&amp;rsquo;s value). For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    :field[ /\{ X+ \}/ =&amp;gt; &amp;amp;censor_field ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This tells &lt;code&gt;form&lt;/code&gt; that whenever it finds a brace-delimited field consisting of one or more X&amp;rsquo;s, it should call a subroutine named &lt;code&gt;censor_field&lt;/code&gt; and use the return value of that call instead of the all-X field.&lt;/p&gt;

&lt;p&gt;When the key of a &lt;code&gt;:field&lt;/code&gt; pair matches some part of a format, its corresponding subroutine is called. That subroutine is passed the result (i.e. &lt;code&gt;$0&lt;/code&gt;) of the rule match, as well as the hash of active options for that field. Changes to the options hash will affect the subsequent formatting behaviour of that field.&lt;/p&gt;

&lt;p&gt;So &lt;code&gt;censor_field&lt;/code&gt; could be implemented like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        # Constructor subroutine for user-defined censor fields...
        sub censor_field ($field_spec, %opts) {

            # Set up the field&#39;s &#39;break&#39; option with a censorious break...
            %opts{break} = break_and_censor(%opts{break});

            # Construct a left-justified field with the appropriate width
            # specified imperatively...
            return &#39;{[[{&#39; ~ length($field_spec) ~ &#39;}[[}&#39;;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;censor_field&lt;/code&gt; subroutine has to change the field&amp;rsquo;s &lt;code&gt;:break&lt;/code&gt; option, creating a new line breaker that also expurgates unsuitable words. To do this it calls &lt;code&gt;break_and_censor&lt;/code&gt;, which returns a new line breaker subroutine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        # Create a new &#39;break&#39; sub...
        sub break_and_censor (&amp;amp;original_breaker) {
            return sub (*@args) {

                # Call the field&#39;s original &#39;break&#39; sub...
                my ($nextline, $more) = original_breaker(*@args);

                # X out any doubleplus ungood words
                $nextline ~~ s:ei/(@proscribed)/$( &#39;X&#39; x length $1 )/;

                # Return the &amp;quot;corrected&amp;quot; version...
                return ($nextline, $more);
            }
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Having created a subroutine to translate censor fields and another to break-and-expurgate the data placed in them, we are now in a position to create a module that encapsulates the new formatting functionality:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    module Ministry::Of::Truth {

        # Internal mechanism (as above)...
        my @proscribed = «villain plot libel treacherous murderer false deadly &#39;G&#39;»;
        sub break_and_censor (&amp;amp;original_breaker) {...}
        sub censor_field ($field_spec, %opts) {...}

        # Make the new field type standard by default in this scope...
        use Form :field[ /\{ X+ \}/ =&amp;gt; &amp;amp;censor_field ];

        # Re-export the specialized &amp;amp;form that was imported above...
        sub form is exported {...}

    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Okay, admittedly that&amp;rsquo;s quite a lot of work. But the pay-off is huge: we can now trample on free speech &lt;em&gt;much&lt;/em&gt; more easily:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Ministry::Of::Truth;

    print form
        &amp;quot;[Ye following tranfcript hath been cenfored by Order of ye King]\n\n&amp;quot;,
        &amp;quot;        {XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX}&amp;quot;,
                  $speech;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we&amp;rsquo;d get the same carefully XXXX&amp;rsquo;ed output as before.&lt;/p&gt;

&lt;h4 id=&#34;span-id-put-thyself-into-the-trick-of-singularity-put-thyself-into-the-trick-of-singularity-span&#34;&gt;&lt;span id=&#34;put_thyself_into_the_trick_of_singularity...&#34;&gt;Put thyself into the trick of singularity&amp;hellip;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;User-defined fields are also a handy way to create single-character markers for single-column fields (in order to preserve the one-to-one spacing of a format). For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        :field{ &#39;^&#39; =&amp;gt; &#39;{&amp;lt;III{1}III}&#39;,   # 1-char-wide, top-justified block
                &#39;=&#39; =&amp;gt; &#39;{&amp;lt;=II{1}II=}&#39;,   # 1-char-wide, middle-justified block
                &#39;_&#39; =&amp;gt; &#39;{&amp;lt;_II{1}II_}&#39;,   # 1-char-wide, bottom-justified block
              },
        &#39;~~~~~~~~~&#39;,
        &#39;^ _ = _ ^&#39;,   *«like round and orient perls»,
        &#39;~~~~~~~~~&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;prints:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ~~~~~~~~~
    l     o p
    i r a r e
    k o n i r
    e u d e l
      n   n s
      d   t
    ~~~~~~~~~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that we needed to use a unary &lt;code&gt;*&lt;/code&gt; to flatten the &lt;code&gt;«like round and orient perls»&lt;/code&gt; data list. That&amp;rsquo;s because every argument of &lt;code&gt;form&lt;/code&gt; is evaluated in scalar context, and an unflattened &lt;code&gt;«...»&lt;/code&gt; list in scalar context becomes an array reference, rather than the five separate strings we needed to fill our five single-character fields.&lt;/p&gt;

&lt;p&gt;Single fields are particularly useful for labelling the vertical axes of a graph:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Form :field[ &#39;=&#39; =&amp;gt; &#39;{&amp;lt;=II{1}II=}&#39; ];

    @vert_label = «Villain&#39;s fortunes»
    $hor_label  = &amp;quot;Time&amp;quot;;

    print form
       &#39;     ^                                        &#39;,
       &#39; = = | {&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;} &#39;, *@vert_label, @data,
       &#39;     +---------------------------------------&amp;gt;&#39;,
       &#39;      {|||||||||||||||||||||||||||||||||||||} &#39;, $hor_label;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which produces:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;         ^
         |
     V   |       *
     i f |     *   *
     l o |    *     *
     l r |
     a t |   *       *
     i u |
     n n |  *         *
     &#39; e |
     s s |
         |
         | *           *
         +---------------------------------------&amp;gt;
                           Time
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Specifying these kinds of single-character block markers is perhaps the commonest use of user-defined fields. But the:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    :field[ &#39;=&#39; =&amp;gt; &#39;{&amp;lt;=II{1}II=}&#39; ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;syntax is uncomfortably verbose for that purpose. So calls to &lt;code&gt;form&lt;/code&gt; can also accept a short-hand notation to define a single-character field:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    :single(&#39;=&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or to define several at once:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    :single[&#39;#&#39;, &#39;*&#39;, &#39;+&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;:single&lt;/code&gt; option does exactly the same thing as the &lt;code&gt;:field&lt;/code&gt; options shown above. It takes a single-character string, or a reference to an array of such strings, as its value. It then turns each of those strings into a single-column field marker. If the character is &lt;code&gt;&#39;=&#39;&lt;/code&gt; then the field is vertically &amp;ldquo;middled&amp;rdquo; within its block. If the character is &lt;code&gt;&#39;_&#39;&lt;/code&gt; then the field is &amp;ldquo;bottomed&amp;rdquo; within its block. If the single character is anything else, the resulting block is top-justified. So our previous example could also have been written:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        :single(&amp;quot;=&amp;quot;),
        &#39;     ^                                        &#39;,
        &#39; = = | {&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;} &#39;, *@vert_label, @data,
        &#39;     +---------------------------------------&amp;gt;&#39;,
        &#39;      {|||||||||||||||||||||||||||||||||||||} &#39;, $hor_label;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-these-paper-bullets-of-the-brain-these-paper-bullets-of-the-brain-span&#34;&gt;&lt;span id=&#34;these_paper_bullets_of_the_brain...&#34;&gt;These paper bullets of the brain&amp;hellip;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Bulleted lists of items are a very common feature of reports, but as we saw &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=3#therefore,_put_you_in_your_best_array...&#34;&gt;earlier&lt;/a&gt; they&amp;rsquo;re surprisingly hard to get right.&lt;/p&gt;

&lt;p&gt;Suppose, for example, we want a list of items bulleted by &amp;ldquo;diamonds&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;&amp;gt; A rubber sword (laminated with mylar to
       look suitably shiny).
    &amp;lt;&amp;gt; Cotton tights (summer performances).
    &amp;lt;&amp;gt; Woolen tights (winter performances or
       those actors who are willing to admit
       to being over 65 years of age).
    &amp;lt;&amp;gt; Talcum powder.
    &amp;lt;&amp;gt; Codpieces (assorted sizes).
    &amp;lt;&amp;gt; Singlet.
    &amp;lt;&amp;gt; Double.
    &amp;lt;&amp;gt; Triplet (Kings and Emperors only).
    &amp;lt;&amp;gt; Supercilious attitude (optional).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Something like this works well enough:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @items -&amp;gt; $item {
        print form
            &#39;&amp;lt;&amp;gt; {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}&#39;, $item;
            &#39;   {VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV}&#39;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first format produces the bullet plus the first line of text for the item, then the second format handles any overflow of the item data.&lt;/p&gt;

&lt;p&gt;Alternatively, we could achieve the same result with a single format string by interpolating the bullet as well:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $bullet = &amp;quot;&amp;lt;&amp;gt;&amp;quot;;

    for @items -&amp;gt; $item {
        print form
            &amp;quot;{&#39;&#39;{*}&#39;&#39;} {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[}&amp;quot;,
             $bullet,  $item;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we use a single-line starred verbatim field (&lt;code&gt;{&#39;&#39;{*}&#39;&#39;}&lt;/code&gt;), so that the bullet is interpolated &amp;ldquo;as-is&amp;rdquo; and the field is only as wide as the bullet itself. Then for the item itself we use a block field, which will format the item data over as many lines as necessary. Meanwhile, because the bullet&amp;rsquo;s field is single-line, after the first line the bullet field will be filled with spaces (instead of a &amp;ldquo;diamond&amp;rdquo;), leaving a bullet only on the first line.&lt;/p&gt;

&lt;p&gt;This second approach also has the advantage that we could change the bullet string at run-time and the format would adapt automatically.&lt;/p&gt;

&lt;p&gt;However, it&amp;rsquo;s still a little irritating that we have to set up a loop and call &lt;code&gt;form&lt;/code&gt; separately for each element of &lt;code&gt;@items&lt;/code&gt;. After all, if we didn&amp;rsquo;t need to bullet our list we could just write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        &amp;quot;{[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[}&amp;quot;,
        @items;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and &lt;code&gt;form&lt;/code&gt; would take care of iterating over the &lt;code&gt;@items&lt;/code&gt; for us. It seems that things ought to be that easy for bulleted lists as well.&lt;/p&gt;

&lt;p&gt;And, of course, things &lt;em&gt;are&lt;/em&gt; that easy.&lt;/p&gt;

&lt;p&gt;All we need to do is tell &lt;code&gt;form&lt;/code&gt; that whenever the string &lt;code&gt;&amp;quot;&amp;lt;&amp;gt;&amp;quot;&lt;/code&gt; appears in a format, it should be treated as a bullet. That is, it should appear only beside the &lt;em&gt;first&lt;/em&gt; line of text produced when formatting each element of the adjacent field&amp;rsquo;s data.&lt;/p&gt;

&lt;p&gt;To tell &lt;code&gt;form&lt;/code&gt; all that we use the &lt;code&gt;:bullet&lt;/code&gt; option:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        :bullet(&amp;quot;&amp;lt;&amp;gt;&amp;quot;),
        &amp;quot;&amp;lt;&amp;gt; {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[}&amp;quot;,
            @items;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or, more permanently:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Form :bullet(&amp;quot;&amp;lt;&amp;gt;&amp;quot;);

    # and later...

    print form
        &amp;quot;&amp;lt;&amp;gt; {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[}&amp;quot;,
            @items;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The presence of this &lt;code&gt;:bullet&lt;/code&gt; option causes &lt;code&gt;form&lt;/code&gt; to treat the sequence &lt;code&gt;&amp;quot;&amp;lt;&amp;gt;&amp;quot;&lt;/code&gt; as a special field. That special field interpolates the string &lt;code&gt;&amp;quot;&amp;lt;&amp;gt;&amp;quot;&lt;/code&gt; when the field immediately to its right begins to format a new data element, but thereafter interpolates only spaces until the adjacent field finishes formatting that data element.&lt;/p&gt;

&lt;p&gt;Or, more simply, if we tell &lt;code&gt;form&lt;/code&gt; that &lt;code&gt;&amp;quot;&amp;lt;&amp;gt;&amp;quot;&lt;/code&gt; is a bullet, &lt;code&gt;form&lt;/code&gt; treats it like a bullet that&amp;rsquo;s attached to the very next field.&lt;/p&gt;

&lt;p&gt;So we could finally fix our &lt;a href=&#34;http://localhost:1313/pub/2004/02/27/exegesis7.html?page=3#therefore,_put_you_in_your_best_array...&#34;&gt;Shakespearean roles example&lt;/a&gt;, like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print &amp;quot;The best Shakespearean roles are:\n\n&amp;quot;;

    print form
        :bullet(&amp;quot;* &amp;quot;),
        &amp;quot;   * {[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[}   *{[[[[[[[[]]]]]]]]}*&amp;quot;,
              @roles,                                 $disclaimer;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This would then produce:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   The best Shakespearean roles are:

      * Either of the &#39;two foolish             *WARNING:          *
        officers&#39;: Dogberry and Verges         *This list of roles*
      * That dour Scot, the Laird              *constitutes      a*
        Macbeth                                *personal   opinion*
      * The tragic Moor of Venice,             *only and is in  no*
        Othello                                *way  endorsed   by*
      * Rosencrantz&#39;s good buddy               *Shakespeare&#39;R&#39;Us. *
        Guildenstern                           *It   may   contain*
      * The hideous and malevolent             *nuts.             *
        Richard III                            *                  *
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice too that the asterisks on either side of the disclaimer &lt;em&gt;aren&amp;rsquo;t&lt;/em&gt; treated as bullets. That&amp;rsquo;s because we defined a bullet to be &lt;code&gt;&amp;quot;* &amp;quot;&lt;/code&gt;, and neither of the disclaimer asterisks has a space after it.&lt;/p&gt;

&lt;p&gt;Bullets can be any string we like, and there can be more than one of them in a single format. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print form
        :bullet(&#39;+&#39;),
        &amp;quot;+ {[[[[[[[[[[[[[[[[[[[…}       + {…[[[[[[[[[[[[[[[[[[[}&amp;quot;,
            @items,                         @items;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;would print:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    + A rubber sword,                65 years of age).
      laminated with mylar         + Talcum powder.
      to look suitably             + Codpieces (assorted
      shiny.                         sizes).
    + Cotton tights (summer        + Singlet.
      performances).               + Double.
    + Woolen tights (winter        + Triplet (Kings and
      performances or those          Emperors only).
      actors who are willing       + Supercilious attitude
      to admit to being over         (optional).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can even change bullets in mid-&lt;code&gt;form&lt;/code&gt;, which is useful for multi-level bulleting. Of course, in that case we&amp;rsquo;re going to need a loop again, since &lt;code&gt;form&lt;/code&gt; itself has only one level of intrinsic looping:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %categories = (
       Animal    =&amp;gt; [&amp;quot;The mighty destrider, ship of the knight&amp;quot;,
                     &amp;quot;The patient cat, warden of the granary&amp;quot;,
                     &amp;quot;Our beloved king, whom we shall soon have to kill&amp;quot;],
       Vegetable =&amp;gt; [&amp;quot;The lovely peony, garland of Eddore&amp;quot;,
                     &amp;quot;The mighty oak, from which tiny acorns grow&amp;quot;,
                     &amp;quot;The humble cabbage, both food and metaphor for the fool&amp;quot;],
       Mineral   =&amp;gt; [&amp;quot;Gold, for which men thirst&amp;quot;,
                     &amp;quot;Salt, by which men thirst&amp;quot;,
                     &amp;quot;Sand, on which men thirst&amp;quot;],
    );

    for %categories.kv -&amp;gt; $category, @examples {
        print form
            :bullet(&#39;*&#39;),  &amp;quot;* {&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;}&amp;quot;,  $category,
            :bullet(&#39;-&#39;),  &amp;quot;    - {[[[[[[[[[[[[[[[[[[[[[[[[}&amp;quot;,  @examples;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This would produce:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    * Mineral
        - Gold, for which men thirst
        - Salt, by which men thirst
        - Sand, on which men thirst
    * Animal
        - The mighty destrider, ship
          of the knight
        - The patient cat, warden of
          the granary
        - Our beloved king, whom we
          shall soon have to kill
    * Vegetable
        - The lovely peony, garland
          of Eddore
        - The mighty oak, from which
          tiny acorns grow
        - The humble cabbage, both
          food and metaphor for the
          fool
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-all-s-well-that-ends-all-s-well-that-ends-span&#34;&gt;&lt;span id=&#34;all&#39;s_well_that_ends...&#34;&gt;All&amp;rsquo;s well that ends&amp;hellip;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Report generation was one of Perl&amp;rsquo;s original &lt;em&gt;raisons d&amp;rsquo;etre&lt;/em&gt;. Over the years we&amp;rsquo;ve found out what &lt;code&gt;format&lt;/code&gt; does well, and where its limitations lurk. The new Perl 6 &lt;code&gt;form&lt;/code&gt; function aims to preserve &lt;code&gt;format&lt;/code&gt;&amp;rsquo;s simple approach to report generation and build on its strengths by adding:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;independence from the I/O system;&lt;/li&gt;
&lt;li&gt;run-time specifiable format strings;&lt;/li&gt;
&lt;li&gt;a wider range of useful field types, including fully justified, verbatim, and overflow fields;&lt;/li&gt;
&lt;li&gt;the ability to define new field types;&lt;/li&gt;
&lt;li&gt;sophisticated formatting of numeric/currency data;&lt;/li&gt;
&lt;li&gt;declarative, imperative, distributive, and extensible field widths;&lt;/li&gt;
&lt;li&gt;more flexible control of headers, footers, and page layout;&lt;/li&gt;
&lt;li&gt;control over line-breaking, whitespace squeezing, and filling of empty fields; and&lt;/li&gt;
&lt;li&gt;support for creating plaintext lists, tables, and graphs.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And because it&amp;rsquo;s now part of a module, rather than a core component, &lt;code&gt;form&lt;/code&gt; will be able to evolve more easily to meet the needs of its community. For example, we are currently investigating how we might add facilities for specifying numerical bullets, for formatting text using variable-width fonts, and for outputting HTML instead of plaintext.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re a regular user of Perl 5&amp;rsquo;s &lt;code&gt;format&lt;/code&gt; you might like to try the &lt;code&gt;form&lt;/code&gt; function instead. It&amp;rsquo;s available right now in the Perl6::Form module, which waits upon thy pleasure at the CPAN.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exegesis 6</title>
      <link>http://localhost:1313/pub/2003/07/29/exegesis6.html/</link>
      <pubDate>Tue, 29 Jul 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/07/29/exegesis6.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 6&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;As soon as she walked through my door I knew her type: she was an argument waiting to happen. I wondered if the argument was required&amp;hellip; or merely optional? Guess I&amp;rsquo;d know the parameters soon enough.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;ldquo;I&amp;rsquo;m Star At Data,&amp;rdquo; she offered.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;She made it sound like a pass. But was the pass by name? Or by position?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;ldquo;I think someone&amp;rsquo;s trying to execute me. Some caller.&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;ldquo;Okay, I&amp;rsquo;ll see what I can find out. Meanwhile, we&amp;rsquo;re gonna have to limit the scope of your accessibility.&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;ldquo;I&amp;rsquo;d prefer not to be bound like that,&amp;rdquo; she replied.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;ldquo;I see you know my methods,&amp;rdquo; I shot back.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;She just stared at me, like I was a block. Suddenly I wasn&amp;rsquo;t surprised someone wanted to dispatch her.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;ldquo;I&amp;rsquo;ll return later,&amp;rdquo; she purred. &amp;ldquo;Meanwhile, I&amp;rsquo;m counting on you to give me some closure.&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;It was gonna be another routine investigation.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;— Dashiell Hammett, &amp;ldquo;The Maltese Camel&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This Exegesis explores the new subroutine semantics described in Apocalypse 6. Those new semantics greatly increase the power and flexibility of subroutine definitions, providing required and optional formal parameters, named and positional arguments, a new and extended operator overloading syntax, a far more sophisticated type system, multiple dispatch, compile-time macros, currying, and subroutine wrappers.&lt;/p&gt;

&lt;p&gt;As if that weren&amp;rsquo;t bounty enough, Apocalypse 6 also covers the object-oriented subroutines: methods and submethods. We will, however, defer a discussion of those until Exegesis 12.&lt;/p&gt;

&lt;h3 id=&#34;playing-our-parts&#34;&gt;Playing Our Parts&lt;/h3&gt;

&lt;p&gt;Suppose we want to be able to partition a list into two arrays (hereafter known as &amp;ldquo;sheep&amp;rdquo; and &amp;ldquo;goats&amp;rdquo;), according to some user-supplied criterion. We&amp;rsquo;ll call the necessary subroutine &lt;code&gt;&amp;amp;part&lt;/code&gt;, because it *part*itions a list into two *part*s.&lt;/p&gt;

&lt;p&gt;In the most general case, we could specify how &lt;code&gt;&amp;amp;part&lt;/code&gt; splits the list up by passing it a subroutine. &lt;code&gt;&amp;amp;part&lt;/code&gt; could then call that subroutine for each element, placing the element in the &amp;ldquo;sheep&amp;rdquo; array if the subroutine returns true, and into the &amp;ldquo;goats&amp;rdquo; array otherwise. It would then return a list of references to the two resulting arrays.&lt;/p&gt;

&lt;p&gt;For example, calling:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;($cats, $chattels) = part &amp;amp;is_feline, @animals;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;would result in &lt;code&gt;$cats&lt;/code&gt; being assigned a reference to an array containing all the animals that are feline and &lt;code&gt;$chattels&lt;/code&gt; being assigned a reference to an array containing everything else that exists merely for the convenience of cats.&lt;/p&gt;

&lt;p&gt;Note that in the above example (and throughout the remainder of this discussion), when we&amp;rsquo;re talking about a subroutine as an object in its own right, we&amp;rsquo;ll use the &lt;code&gt;&amp;amp;&lt;/code&gt; sigil; but when we&amp;rsquo;re talking about a call to the subroutine, there will be no &lt;code&gt;&amp;amp;&lt;/code&gt; before its name. That&amp;rsquo;s a distinction Perl 6 enforces too: subroutine calls never have an ampersand; references to the corresponding &lt;code&gt;Code&lt;/code&gt; object always do.&lt;/p&gt;

&lt;h3 id=&#34;part-the-first&#34;&gt;Part: The First&lt;/h3&gt;

&lt;p&gt;The Perl 6 implementation of &lt;code&gt;&amp;amp;part&lt;/code&gt; would therefore be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub part (Code $is_sheep, *@data) {
    my (@sheep, @goats);
    for @data {
        if $is_sheep($_) { push @sheep, $_ }
        else             { push @goats, $_ }
    }
    return (\@sheep, \@goats);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As in Perl 5, the &lt;code&gt;sub&lt;/code&gt; keyword declares a subroutine. As in Perl 5, the name of the subroutine follows the &lt;code&gt;sub&lt;/code&gt; and — assuming that name doesn&amp;rsquo;t include a package qualifier — the resulting subroutine is installed into the current package.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Un&lt;/strong&gt;like Perl 5, in Perl 6 we are allowed to specify a formal parameter list after the subroutine&amp;rsquo;s name. This list consists of zero or more parameter variables. Each of these parameter variables is really a lexical variable declaration, but because they&amp;rsquo;re in a parameter list we don&amp;rsquo;t need to (and aren&amp;rsquo;t allowed to!) use the keyword &lt;code&gt;my&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Just as with a regular variable, each parameter can be given a storage type, indicating what kind of value it is allowed to store. In the above example, for instance, the &lt;code&gt;$is_sheep&lt;/code&gt; parameter is given the type &lt;code&gt;Code&lt;/code&gt;, indicating that it is restricted to objects of that type (i.e. the first argument must be a subroutine or block).&lt;/p&gt;

&lt;p&gt;Each of these parameter variables is automatically scoped to the body of the subroutine, where it can be used to access the arguments with which the subroutine was called.&lt;/p&gt;

&lt;p&gt;A word about terminology: an &amp;ldquo;argument&amp;rdquo; is a item in the list of data that is passed as part of a subroutine call. A &amp;ldquo;parameter&amp;rdquo; is a special variable inside the subroutine itself. So the subroutine call sends arguments, which the subroutine then accesses via its parameters.&lt;/p&gt;

&lt;p&gt;Perl 5 has parameters too, but they&amp;rsquo;re not user-specifiable. They&amp;rsquo;re always called &lt;code&gt;$_[0]&lt;/code&gt;, &lt;code&gt;$_[1]&lt;/code&gt;, &lt;code&gt;$_[2]&lt;/code&gt;, etc.&lt;/p&gt;

&lt;h4 id=&#34;not-so-secret-alias&#34;&gt;Not-So-Secret Alias&lt;/h4&gt;

&lt;p&gt;However, one way in which Perl 5 and Perl 6 parameters &lt;em&gt;are&lt;/em&gt; similar is that, unlike Certain Other Languages, Perl parameters don&amp;rsquo;t receive copies of their respective arguments. Instead, Perl parameters become &lt;em&gt;aliases&lt;/em&gt; for the corresponding arguments.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s already the case in Perl 5. So, for example, we can write a temperature conversion utility like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Perl 5 code...
sub Fahrenheit_to_Kelvin {
    $_[0] -= 32;
    $_[0] /= 1.8;
    $_[0] += 273.15;
}

# and later...

Fahrenheit_to_Kelvin($reactor_temp);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the subroutine is called, within the body of &lt;code&gt;&amp;amp;Fahrenheit_to_Kelvin&lt;/code&gt; the &lt;code&gt;$_[0]&lt;/code&gt; variable becomes just another name for &lt;code&gt;$reactor_temp&lt;/code&gt;. So the changes the subroutine makes to &lt;code&gt;$_[0]&lt;/code&gt; are really being made to &lt;code&gt;$reactor_temp&lt;/code&gt;, and at the end of the call &lt;code&gt;$reactor_temp&lt;/code&gt; has been converted to the new temperature scale.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s very handy when we intend to change the values of arguments (as in the above example), but it&amp;rsquo;s potentially a very nasty trap too. Many programmers, accustomed to the pass-by-copy semantics of other languages, will unconsciously fall into the habit of treating the contents of &lt;code&gt;$_[0]&lt;/code&gt; as if they were a copy. Eventually that will lead to some subroutine unintentionally changing one of its arguments — a bug that is often very hard to diagnose and frequently even harder to track down.&lt;/p&gt;

&lt;p&gt;So Perl 6 modifies the way parameters and arguments interact. Explicit parameters are still aliases to the original arguments, but in Perl 6 they&amp;rsquo;re &lt;strong&gt;constant&lt;/strong&gt; aliases by default. That means, unless we specifically tell Perl 6 otherwise, it&amp;rsquo;s illegal to change an argument by modifying the corresponding parameter within a subroutine.&lt;/p&gt;

&lt;p&gt;All of which means that a the naïve translation of &lt;code&gt;&amp;amp;Fahrenheit_to_Kelvin&lt;/code&gt; to Perl 6 isn&amp;rsquo;t going to work:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Perl 6 code...
sub Fahrenheit_to_Kelvin(Num $temp) {
    $temp -= 32;
    $temp /= 1.8;
    $temp += 273.15;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s because &lt;code&gt;$temp&lt;/code&gt; (and hence the actual value it&amp;rsquo;s an alias for) is treated as a constant within the body of &lt;code&gt;&amp;amp;Fahrenheit_to_Kelvin&lt;/code&gt;. In fact, we&amp;rsquo;d get a compile time error message like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Cannot modify constant parameter ($temp) in &amp;amp;Fahrenheit_to_Kelvin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to be able to modify arguments via Perl 6 parameters, we have to say so up front, by declaring them &lt;code&gt;is rw&lt;/code&gt; (&amp;ldquo;read-write&amp;rdquo;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub Fahrenheit_to_Kelvin (Num $temp is rw) {
    $temp -= 32;
    $temp /= 1.8;
    $temp += 273.15;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This requires a few extra keystrokes when the old behaviour is needed, but saves a huge amount of hard-to-debug grief in the most common cases. As a bonus, an explicit &lt;code&gt;is rw&lt;/code&gt; declaration means that the compiler can generally catch mistakes like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$absolute_temp = Fahrenheit_to_Kelvin(212);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because we specified that the &lt;code&gt;$temp&lt;/code&gt; argument has to be read-writeable, the compiler can easily catch attempts to pass in a read-only value.&lt;/p&gt;

&lt;p&gt;Alternatively, we might prefer that &lt;code&gt;$temp&lt;/code&gt; not be an alias at all. We might prefer that &lt;code&gt;&amp;amp;Fahrenheit_to_Kelvin&lt;/code&gt; take a &lt;em&gt;copy&lt;/em&gt; of its argument, which we could then modify without affecting the original, ultimately returning it as our converted value. We can do that too in Perl 6, using the &lt;code&gt;is copy&lt;/code&gt; trait:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub Fahrenheit_to_Kelvin(Num $temp is copy) {
    $temp -= 32;
    $temp /= 1.8;
    $temp += 273.15;
    return $temp;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 6&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;defining-the-parameters&#34;&gt;Defining the Parameters&lt;/h4&gt;

&lt;p&gt;Meanwhile, back at the &lt;code&gt;&amp;amp;part&lt;/code&gt;, we have:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub part (Code $is_sheep, *@data) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which means that &lt;code&gt;&amp;amp;part&lt;/code&gt; expects its first argument to be a scalar value of type &lt;code&gt;Code&lt;/code&gt; (or &lt;code&gt;Code&lt;/code&gt; reference). Within the subroutine that first argument will thereafter be accessed via the name &lt;code&gt;$is_sheep&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The second parameter (&lt;code&gt;*@data&lt;/code&gt;) is what&amp;rsquo;s known as a &amp;ldquo;slurpy array&amp;rdquo;. That is, it&amp;rsquo;s an array parameter with the special marker (&lt;code&gt;*&lt;/code&gt;) in front of it, indicating to the compiler that &lt;code&gt;@data&lt;/code&gt; is supposed to grab all the remaining arguments passed to &lt;code&gt;&amp;amp;part&lt;/code&gt; and make each element of &lt;code&gt;@data&lt;/code&gt; an alias to one of those arguments.&lt;/p&gt;

&lt;p&gt;In other words, the &lt;code&gt;*@data&lt;/code&gt; parameter does just what &lt;code&gt;@_&lt;/code&gt; does in Perl 5: it grabs all the available arguments and makes its elements aliases for those arguments. The only differences are that in Perl 6 we&amp;rsquo;re allowed to give that slurpy array a sensible name, and we&amp;rsquo;re allowed to specify other individual parameters before it — to give separate sensible names to one or more of the preliminary arguments to the call.&lt;/p&gt;

&lt;p&gt;But why (you&amp;rsquo;re probably wondering) do we need an asterisk for that? Surely if we had defined &lt;code&gt;&amp;amp;part&lt;/code&gt; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub part (Code $is_sheep, @data) {...}   # note: no asterisk on @data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the array in the second parameter slot would have slurped up all the remaining arguments anyway.&lt;/p&gt;

&lt;p&gt;Well, no. Declaring a parameter to be a regular (non-slurpy) array tells the subroutine to expect the corresponding argument to be a actual array (or an array reference). So if &lt;code&gt;&amp;amp;part&lt;/code&gt; had been defined with its second parameter just &lt;code&gt;@data&lt;/code&gt; (rather than &lt;code&gt;*@data&lt;/code&gt;), then we could call it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;part \&amp;amp;selector, @animal_sounds;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;part \&amp;amp;selector, [&amp;quot;woof&amp;quot;,&amp;quot;meow&amp;quot;,&amp;quot;ook!&amp;quot;];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but not like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;part \&amp;amp;selector, &amp;quot;woof&amp;quot;, &amp;quot;meow&amp;quot;, &amp;quot;ook!&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In each case, the compiler would compare the type of the second argument with the type required by the second parameter (i.e. an &lt;code&gt;Array&lt;/code&gt;). In the first two cases, the types match and everything is copacetic. In the third case, the second argument is a string, not an array or array reference, so we get a compile-time error message:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Type mismatch in call to &amp;amp;part: @data expects Array but got Str instead
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another way of thinking about the difference between slurpy and regular parameters is to realize that a slurpy parameter imposes a list (i.e. flattening) context on the corresponding arguments, whereas a regular, non-slurpy parameter doesn&amp;rsquo;t flatten or listify. Instead, it insists on a single argument of the correct type.&lt;/p&gt;

&lt;p&gt;So, if we want &lt;code&gt;&amp;amp;part&lt;/code&gt; to handle raw lists as data, we need to tell the &lt;code&gt;@data&lt;/code&gt; parameter to take whatever it finds — array or list — and flatten everything down to a list. That&amp;rsquo;s what the asterisk on &lt;code&gt;*@data&lt;/code&gt; does.&lt;/p&gt;

&lt;p&gt;Because of that all-you-can-eat behaviour, slurpy arrays like this are generally placed at the very end of the parameter list and used to collect data for the subroutine. The preceding non-slurpy arguments generally tell the subroutine &lt;em&gt;what to do&lt;/em&gt;; the slurpy array generally tells it &lt;em&gt;what to do it to&lt;/em&gt;.&lt;/p&gt;

&lt;h4 id=&#34;splats-and-slurps&#34;&gt;Splats and Slurps&lt;/h4&gt;

&lt;p&gt;Another aspect of Perl 6&amp;rsquo;s distinction between slurpy and non-slurpy parameters can be seen when we write a subroutine that takes multiple scalar parameters, then try to pass an array to that subroutine.&lt;/p&gt;

&lt;p&gt;For example, suppose we wrote:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub log($message, $date, $time) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we happen to have the date and time in a handy array, we might expect that we could just call &lt;code&gt;log&lt;/code&gt; like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;log(&amp;quot;Starting up...&amp;quot;, @date_and_time);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We might then be surprised when this fails even to compile.&lt;/p&gt;

&lt;p&gt;The problem is that each of &lt;code&gt;&amp;amp;log&lt;/code&gt;&amp;rsquo;s three scalar parameters imposes a scalar context on the corresponding argument in any call to &lt;code&gt;log&lt;/code&gt;. So &lt;code&gt;&amp;quot;Starting up...&amp;quot;&lt;/code&gt; is first evaluated in the scalar context imposed by the &lt;code&gt;$message&lt;/code&gt; parameter and the resulting string is bound to &lt;code&gt;$message&lt;/code&gt;. Then &lt;code&gt;@date_and_time&lt;/code&gt; is evaluated in the scalar context imposed by &lt;code&gt;$date&lt;/code&gt;, and the resulting array reference is bound to &lt;code&gt;$date&lt;/code&gt;. Then the compiler discovers that there is no third argument to bind to the &lt;code&gt;$time&lt;/code&gt; parameter and kills your program.&lt;/p&gt;

&lt;p&gt;Of course, it &lt;strong&gt;has&lt;/strong&gt; to work that way, or we don&amp;rsquo;t get the ever-so-useful &amp;ldquo;array parameter takes an unflattened array argument&amp;rdquo; behaviour described earlier. Unfortunately, that otherwise admirable behaviour is actually getting in the way here and preventing &lt;code&gt;@date_and_time&lt;/code&gt; from flattening as we want.&lt;/p&gt;

&lt;p&gt;So Perl 6 also provides a simple way of explicitly flattening an array (or a hash for that matter): the unary prefix &lt;code&gt;*&lt;/code&gt; operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;log(&amp;quot;Starting up...&amp;quot;, *@date_and_time);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This operator (known as &amp;ldquo;splat&amp;rdquo;) simply flattens its argument into a list. Since it&amp;rsquo;s a unary operator, it does that flattening &lt;strong&gt;before&lt;/strong&gt; the arguments are bound to their respective parameters.&lt;/p&gt;

&lt;p&gt;The syntactic similarity of a &amp;ldquo;slurpy&amp;rdquo; &lt;code&gt;*&lt;/code&gt; in a parameter list, and a &amp;ldquo;splatty&amp;rdquo; &lt;code&gt;*&lt;/code&gt; in an argument list is quite deliberate. It reflects a behavioral similarity: just as a slurpy asterisk implicitly flattens any argument to which its parameter is bound, so too a splatty asterisk explicitly flattens any argument to which it is applied.&lt;/p&gt;

&lt;h4 id=&#34;i-do-declare&#34;&gt;I Do Declare&lt;/h4&gt;

&lt;p&gt;By the way, take another look at those examples above — the ones with the &lt;code&gt;{...}&lt;/code&gt; where their subroutine bodies should be. Those dots aren&amp;rsquo;t just metasyntactic; they&amp;rsquo;re real executable Perl 6 code. A subroutine definition with a &lt;code&gt;{...}&lt;/code&gt; for its body isn&amp;rsquo;t actually a &lt;em&gt;definition&lt;/em&gt; at all. It&amp;rsquo;s a &lt;em&gt;declaration&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In the same way that the Perl 5 declaration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Perl 5 code...
sub part;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;states that there exists a subroutine &lt;code&gt;&amp;amp;part&lt;/code&gt;, without actually saying how it&amp;rsquo;s implemented, so too:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Perl 6 code...
sub part (Code $is_sheep, *@data) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;states that there exists a subroutine &lt;code&gt;&amp;amp;part&lt;/code&gt; that takes a &lt;code&gt;Code&lt;/code&gt; object and a list of data, without saying how it&amp;rsquo;s implemented. In fact, the old &lt;code&gt;sub part;&lt;/code&gt; syntax is no longer allowed; in Perl 6 you have to yada-yada-yada when you&amp;rsquo;re making a declaration.&lt;/p&gt;

&lt;h4 id=&#34;body-parts&#34;&gt;Body Parts&lt;/h4&gt;

&lt;p&gt;With the parameter list taking care of getting the right arguments into the right parameters in the right way, the body of the &lt;code&gt;&amp;amp;part&lt;/code&gt; subroutine is then quite straightforward:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    my (@sheep, @goats);
    for @data {
        if $is_sheep($_) { push @sheep, $_ }
        else             { push @goats, $_ }
    }
    return (\@sheep, \@goats);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;According to the original specification, we need to return references to two arrays. So we first create those arrays. Then we iterate through each element of the data (which the &lt;code&gt;for&lt;/code&gt; aliases to &lt;code&gt;$_&lt;/code&gt;, just as in Perl 5). For each element, we take the &lt;code&gt;Code&lt;/code&gt; object that was passed as &lt;code&gt;$is_sheep&lt;/code&gt; (let&amp;rsquo;s just call it the &lt;em&gt;selector&lt;/em&gt; from now on) and we call it, passing the current data element. If the selector returns true, we push the data element onto the array of &amp;ldquo;sheep&amp;rdquo;, otherwise it is appended to the list of &amp;ldquo;goats&amp;rdquo;. Once all the data has been divvied up, we return references to the two arrays.&lt;/p&gt;

&lt;p&gt;Note that, if this were Perl 5, we&amp;rsquo;d have to unpack the &lt;code&gt;@_&lt;/code&gt; array into a list of lexical variables and then explicitly check that &lt;code&gt;$is_sheep&lt;/code&gt; is a valid &lt;code&gt;Code&lt;/code&gt; object. In the Perl 6 version there&amp;rsquo;s no &lt;code&gt;@_&lt;/code&gt;, the parameters are already lexicals, and the type-checking is handled automatically.&lt;/p&gt;

&lt;h4 id=&#34;call-of-the-wild&#34;&gt;Call of the Wild&lt;/h4&gt;

&lt;p&gt;With the explicit parameter list in place, we can use &lt;code&gt;&amp;amp;part&lt;/code&gt; in a variety of ways. If we already have a subroutine that is a suitable test:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub is_feline ($animal) {
    return $animal.isa(Cat);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then we can just pass that to &lt;code&gt;&amp;amp;part&lt;/code&gt;, along with the data to be partitioned, then grab the two array references that come back:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;($cats, $chattels) = part &amp;amp;is_feline, @animals;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works fine, because the first parameter of &lt;code&gt;&amp;amp;part&lt;/code&gt; expects a &lt;code&gt;Code&lt;/code&gt; object, and that&amp;rsquo;s exactly what &lt;code&gt;&amp;amp;is_feline&lt;/code&gt; is. Note that we couldn&amp;rsquo;t just put &lt;code&gt;is_feline&lt;/code&gt; there (i.e. without the ampersand), since that would indicate a &lt;em&gt;call&lt;/em&gt; to &lt;code&gt;&amp;amp;is_feline&lt;/code&gt;, rather than a reference to it.&lt;/p&gt;

&lt;p&gt;In Perl 5 we&amp;rsquo;d have had to write &lt;code&gt;\&amp;amp;is_feline&lt;/code&gt; to get a reference to the subroutine. However, since the &lt;code&gt;$is_sheep&lt;/code&gt; parameter specifies that the first argument must be a scalar (i.e. it imposes a scalar context on the first argument slot), in Perl 6 we don&amp;rsquo;t have to create a subroutine reference explicitly. Putting a code object in the scalar context auto-magically enreferences it (just as an array or hash is automatically converted to a reference in scalar context). Of course, an explicit &lt;code&gt;Code&lt;/code&gt; reference is perfectly acceptable there too:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;($cats, $chattels) = part \&amp;amp;is_feline, @animals;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternatively, rather than going to the trouble of declaring a separate subroutine to sort our sheep from our goats, we might prefer to conjure up a suitable (anonymous) subroutine on the spot:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;($cats, $chattels) = part sub ($animal) { $animal.isa(Animal::Cat) }, @animals;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;in-a-bind&#34;&gt;In a Bind&lt;/h4&gt;

&lt;p&gt;So far we&amp;rsquo;ve always captured the two array references returned from the &lt;code&gt;part&lt;/code&gt; call by assigning the result of the call to a list of scalars. But we might instead prefer to bind them to actual arrays:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(@cats, @chattels) := part sub($animal) { $animal.isa(Animal::Cat) }, @animals;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using binding (&lt;code&gt;:=&lt;/code&gt;) instead of assignment (&lt;code&gt;=&lt;/code&gt;) causes &lt;code&gt;@cats&lt;/code&gt; and &lt;code&gt;@chattels&lt;/code&gt; to become aliases for the two anonymous arrays returned by &lt;code&gt;&amp;amp;part&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In fact, this aliasing of the two return values to &lt;code&gt;@cats&lt;/code&gt; and &lt;code&gt;@chattels&lt;/code&gt; uses &lt;em&gt;exactly&lt;/em&gt; the same mechanism that is used to alias subroutine parameters to their corresponding arguments. We could almost think of the lefthand side of the &lt;code&gt;:=&lt;/code&gt; as a parameter list (in this case, consisting of two non-slurpy array parameters), and the righthand side of the &lt;code&gt;:=&lt;/code&gt; as being the corresponding argument list. The only difference is that the variables on the lefthand side of a &lt;code&gt;:=&lt;/code&gt; are not implicitly treated as constant.&lt;/p&gt;

&lt;p&gt;One consequence of the similarities between binding and parameter passing is that we can put a slurpy array on the left of a binding:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(@Good, $Bad, *@Ugly) := (@Adams, @Vin, @Chico, @OReilly, @Lee, @Luck, @Britt);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first pseudo-parameter (&lt;code&gt;@Good&lt;/code&gt;) on the left expects an array, so it binds to &lt;code&gt;@Adams&lt;/code&gt; from the list on the right.&lt;/p&gt;

&lt;p&gt;The second pseudo-parameter (&lt;code&gt;$Bad&lt;/code&gt;) expects a scalar. That means it imposes a scalar context on the second element of the righthand list. So &lt;code&gt;@Vin&lt;/code&gt; evaluates to a reference to the original array and &lt;code&gt;$Bad&lt;/code&gt; becomes an alias for &lt;code&gt;\@Vin&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The final pseudo-parameter (&lt;code&gt;*@Ugly&lt;/code&gt;) is slurpy, so it expects the rest of the lefthand side to be a list it can slurp up. In order to ensure that, the slurpy asterisk causes the remaining pseudo-arguments on the right to be flattened into a list, whose elements are then aliased to successive elements of &lt;code&gt;@Ugly&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 6&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;who-shall-sit-in-judgment&#34;&gt;Who Shall Sit in Judgment?&lt;/h4&gt;

&lt;p&gt;Conjuring up an anonymous subroutine in each call to &lt;code&gt;part&lt;/code&gt; is intrinsically neither good nor bad, but it sure is ugly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;($cats, $chattels) = part sub($animal) { $animal.isa(Animal::Cat) }, @animals;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fortunately, there&amp;rsquo;s a cleaner way to specify the selector within the call to &lt;code&gt;part&lt;/code&gt;. We can use a &lt;em&gt;parameterized block&lt;/em&gt; instead:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;($cats, $chattels) = part -&amp;gt; $animal { $animal.isa(Animal::Cat) } @animals;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A parameterized block is just a normal brace-delimited block, except that you&amp;rsquo;re allowed to put a list of parameters out in front of it, preceded by an arrow (&lt;code&gt;-&amp;gt;&lt;/code&gt;). So the actual parameterized block in the above example is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-&amp;gt; $animal { $animal.isa(Animal::Cat) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Perl 6, a block is a subspecies of &lt;code&gt;Code&lt;/code&gt; object, so it&amp;rsquo;s perfectly okay to pass a parameterized block as the first argument to &lt;code&gt;&amp;amp;part&lt;/code&gt;. Like a real subroutine, a parameterized block can be subsequently invoked and passed an argument list. The body of the &lt;code&gt;&amp;amp;part&lt;/code&gt; subroutine will continue to work just fine.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s important to realize that parameterized blocks &lt;em&gt;aren&amp;rsquo;t&lt;/em&gt; subroutines though. They&amp;rsquo;re blocks, and so there are important differences in their behaviour. The most important difference is that you can&amp;rsquo;t &lt;code&gt;return&lt;/code&gt; from a parameterized block, the way you can from a subroutine. For example, this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;part sub($animal) { return $animal.size &amp;lt; $breadbox }, @creatures
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;works fine, returning the result of each size comparison every time the anonymous subroutine is called within &lt;code&gt;&amp;amp;part&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But in this &amp;ldquo;pointier&amp;rdquo; version:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;part -&amp;gt; $animal { return $animal.size &amp;lt; $breadbox } @creatures
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the &lt;code&gt;return&lt;/code&gt; isn&amp;rsquo;t inside a nested subroutine; it&amp;rsquo;s inside a block. The first time the parameterized block is executed within &lt;code&gt;&amp;amp;part&lt;/code&gt; it causes the subroutine in which the block was defined (i.e. the subroutine that&amp;rsquo;s &lt;em&gt;calling&lt;/em&gt; &lt;code&gt;part&lt;/code&gt;) to return!&lt;/p&gt;

&lt;p&gt;Oops.&lt;/p&gt;

&lt;p&gt;The problem with that second example, of course, is not that we were too Lazy to write the full anonymous subroutine. The problem is that we weren&amp;rsquo;t Lazy enough: we forgot to &lt;em&gt;leave out&lt;/em&gt; the &lt;code&gt;return&lt;/code&gt;. Just like a Perl 5 &lt;code&gt;do&lt;/code&gt; or &lt;code&gt;eval&lt;/code&gt; block, a Perl 6 parameterized block evaluates to the value of the last statement executed within it. We only needed to say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;part -&amp;gt; $animal { $animal.size &amp;lt; $breadbox } @creatures
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note too that, because the parameterized block is a block, we don&amp;rsquo;t need to put a comma after it to separate it from the second argument. In fact, &lt;em&gt;anywhere&lt;/em&gt; a block is used as an argument to a subroutine, any comma before or after the block is optional.&lt;/p&gt;

&lt;h4 id=&#34;cowabunga&#34;&gt;Cowabunga!&lt;/h4&gt;

&lt;p&gt;Even with the slight abbreviation provided by using a parameterized block instead of an anonymous subroutine, it&amp;rsquo;s all too easy to lose track of the the actual data (i.e. &lt;code&gt;@animals&lt;/code&gt;) when it&amp;rsquo;s buried at the end of that long selector definition.&lt;/p&gt;

&lt;p&gt;We can help it stand out a little better by using a new feature of Perl 6: the &amp;ldquo;pipeline&amp;rdquo; operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;($cats, $chattels) = part sub($animal) { $animal.isa(Animal::Cat) } &amp;lt;== @animals;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;&amp;lt;==&lt;/code&gt; operator takes a subroutine &lt;em&gt;call&lt;/em&gt; as its lefthand argument and a list of data as its righthand arguments. The subroutine being called on the left must have a slurpy array parameter (e.g. &lt;code&gt;*@data&lt;/code&gt;) and the list on the operator&amp;rsquo;s right is then bound to that parameter.&lt;/p&gt;

&lt;p&gt;In other words, a &lt;code&gt;&amp;lt;==&lt;/code&gt; in a subroutine call marks the end of the specific arguments and the start of the slurped data.&lt;/p&gt;

&lt;p&gt;Pipelines are more interesting when there are several stages to the process, as in this Perl 6 version of the Schwartzian transform:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@shortest_first = map  { .key }                     # 4
              &amp;lt;== sort { $^a.value &amp;lt;=&amp;gt; $^b.value }  # 3
              &amp;lt;== map  { $_ =&amp;gt; .height }            # 2
              &amp;lt;== @animals;                         # 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example takes the array &lt;code&gt;@animals&lt;/code&gt;, flattens it into a list (#1), pipes that list in as the data for a &lt;code&gt;map&lt;/code&gt; operation (#2), takes the resulting list of object/height pairs and pipes that in to the &lt;code&gt;sort&lt;/code&gt; (#3), then takes the resulting sorted list of pairs and &lt;code&gt;map&lt;/code&gt;s out just the sorted objects (#4).&lt;/p&gt;

&lt;p&gt;Of course, since the data lists for all of these functions always come at the end of the call anyway, we could have just written that as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@shortest_first = map  { .key }                     # 4
                  sort { $^a.value &amp;lt;=&amp;gt; $^b.value }  # 3
                  map  { $_ =&amp;gt; .height }            # 2
                  @animals;                         # 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But there&amp;rsquo;s no reason to stint ourselves: the pipelines cost nothing in performance, and often make the flow of data much clearer.&lt;/p&gt;

&lt;p&gt;One problem that many people have with pipelined list processing techniques like the Schwartzian Transform is that the pipeline flows the &amp;ldquo;wrong&amp;rdquo; way: the code reads left-to-right/top-to-bottom but the data (and execution) runs right-to-left/bottom-to-top. Happily, Perl 6 has a solution for that too. It provides a &amp;ldquo;reversed&amp;rdquo; version of the pipeline operator, to make it easy to create left-to-right pipelines:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@animals ==&amp;gt; map  { $_ =&amp;gt; .height }              # 1
         ==&amp;gt; sort { $^a.value &amp;lt;=&amp;gt; $^b.value }    # 2
         ==&amp;gt; map  { .key }                       # 3
         ==&amp;gt; @shortest_first;                    # 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This version works exactly the same as the previous right-to-left/bottom-to-top examples, except that now the various components of the pipeline are written and performed in the &amp;ldquo;natural&amp;rdquo; order.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;==&amp;gt;&lt;/code&gt; operator is the mirror-image of &lt;code&gt;&amp;lt;==&lt;/code&gt;, both visually and in its behaviour. That is, it takes a subroutine call as its righthand argument and a list of data on its left, and binds the lefthand list to the slurpy array parameter of the subroutine being called on the right.&lt;/p&gt;

&lt;p&gt;Note that this last example makes use of a special dispensation given to both pipeline operators. The argument on the &amp;ldquo;sharp&amp;rdquo; side is supposed to be a subroutine call. However, if it is a variable, or a list of variables, then the pipeline operator simply assigns the list from its &amp;ldquo;blunt&amp;rdquo; side to variable (or list) on its &amp;ldquo;sharp&amp;rdquo; side.&lt;/p&gt;

&lt;p&gt;Hence, if we preferred to partition our animals left-to-right, we could write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@animals ==&amp;gt; part sub ($animal) { $animal.isa(Animal::Cat) } ==&amp;gt; ($cats, $chattels);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;the-incredible-shrinking-selector&#34;&gt;The Incredible Shrinking Selector&lt;/h4&gt;

&lt;p&gt;Of course, even with a parameterized block instead of an anonymous subroutine, the definition of the selector argument is still klunky:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;($cats, $chattels) = part -&amp;gt; $animal { $animal.isa(Animal::Cat) } @animals;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But it doesn&amp;rsquo;t have to be so intrusive. There&amp;rsquo;s another way to create a parameterized block. Instead of explicitly enumerating the parameters after a &lt;code&gt;-&amp;gt;&lt;/code&gt;, we could use &lt;em&gt;placeholder variables&lt;/em&gt; instead.&lt;/p&gt;

&lt;p&gt;As explained in Apocalypse 4, a placeholder variable is one whose sigil is immediately followed by a caret (&lt;code&gt;^&lt;/code&gt;). Any block containing one or more placeholder variables is automatically a parameterized block, without the need for an explicit &lt;code&gt;-&amp;gt;&lt;/code&gt; or parameter list. Instead, the block&amp;rsquo;s parameter list is determined automatically from the set of placeholder variables enclosed by the block&amp;rsquo;s braces.&lt;/p&gt;

&lt;p&gt;We could simplify our partitioning to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;($cats, $chattels) = part { $^animal.isa(Animal::Cat) }
@animals;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here &lt;code&gt;$^animal&lt;/code&gt; is a placeholder, so the block immediately surrounding it becomes a parameterized block — in this case with exactly one parameter.&lt;/p&gt;

&lt;p&gt;Better still, any block containing a &lt;code&gt;$_&lt;/code&gt; is also a parameterized block — with a single parameter named &lt;code&gt;$_&lt;/code&gt;. We could dispense with the explicit placeholder and just write our partitioning statement:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;($cats, $chattels) = part { $_.isa(Animal::Cat) }
@animals;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which is really a shorthand for the parameterized block:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;($cats, $chattels) = part -&amp;gt; $_ { $_.isa(Animal::Cat) }
@animals;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Come to think of it, since we now have the unary dot operator (which calls a method using &lt;code&gt;$_&lt;/code&gt; as the invocant), we don&amp;rsquo;t even need the explicit &lt;code&gt;$_&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;($cats, $chattels) = part { .isa(Animal::Cat) }
@animals;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;part-the-second&#34;&gt;Part: The Second&lt;/h3&gt;

&lt;p&gt;But wait, there&amp;rsquo;s even&amp;hellip;err&amp;hellip;less!&lt;/p&gt;

&lt;p&gt;We could very easily extend &lt;code&gt;&amp;amp;part&lt;/code&gt; so that we don&amp;rsquo;t even need the block in that case; so that we could just pass the raw class in as the first parameter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;($cats, $chattels) = part Animal::Cat, @animals;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To do that, the type of the first parameter will have to become &lt;code&gt;Class&lt;/code&gt;, which is the (meta-)type of all classes. However, if we changed &lt;code&gt;&amp;amp;part&lt;/code&gt;&amp;rsquo;s parameter list in that way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub part (Class $is_sheep, *@data) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then all our existing code that currently passes &lt;code&gt;Code&lt;/code&gt; objects as &lt;code&gt;&amp;amp;part&lt;/code&gt;&amp;rsquo;s first argument will break.&lt;/p&gt;

&lt;p&gt;Somehow we need to be able to pass &lt;em&gt;either&lt;/em&gt; a &lt;code&gt;Code&lt;/code&gt; object &lt;em&gt;or&lt;/em&gt; a &lt;code&gt;Class&lt;/code&gt; as &lt;code&gt;&amp;amp;part&lt;/code&gt;&amp;rsquo;s first argument. To accomplish that, we need to take a short detour into&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 6&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;the-wonderful-world-of-junctions&#34;&gt;The Wonderful World of Junctions&lt;/h4&gt;

&lt;p&gt;Perl 6 introduces an entirely new scalar data-type: the &lt;em&gt;junction&lt;/em&gt;. A junction is a single scalar value that can act like two or more values at once. So, for example, we can create a value that behaves like any of the values &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;4&lt;/code&gt;, or &lt;code&gt;9&lt;/code&gt;, by writing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$monolith = any(1,4,9);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The scalar value returned by &lt;code&gt;any&lt;/code&gt; and subsequently stored in &lt;code&gt;$monolith&lt;/code&gt; is equal to &lt;code&gt;1&lt;/code&gt;. And at the same time it&amp;rsquo;s also equal to &lt;code&gt;4&lt;/code&gt;. And to &lt;code&gt;9&lt;/code&gt;. It&amp;rsquo;s equal to any of them. Hence the name of the &lt;code&gt;any&lt;/code&gt; function that we used to set it up.&lt;/p&gt;

&lt;p&gt;What good it that? Well, if it&amp;rsquo;s equal to &amp;ldquo;any of them&amp;rdquo; then, with a single comparison, we can test if some other value is also equal to &amp;ldquo;any of them&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if $dave == any(1,4,9) { print &amp;quot;I&#39;m sorry, Dave, you&#39;re just a
square.&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s considerably shorter (and more maintainable) than:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if $dave == 1 || $dave == 4 || $dave == 9 { print &amp;quot;I&#39;m sorry, Dave,
you&#39;re just a square.&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It even reads more naturally.&lt;/p&gt;

&lt;p&gt;Better still, Perl 6 provides an n-ary operator that builds the same kinds of junctions from its operands:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if $dave == 1|4|9 { print &amp;quot;I&#39;m sorry, Dave, you&#39;re just a square.&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once you get used to this notation, it too is very easy to follow: &lt;em&gt;if Dave equals 1 or 4 or 9&amp;hellip;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;(Yes, the Perl 5 bitwise OR is still available in Perl 6; it&amp;rsquo;s just spelled differently now).&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;any&lt;/code&gt; function is more useful when the values under consideration are stored in a single array. For example, we could check whether a new value is bigger than any we&amp;rsquo;ve already seen:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if $newval &amp;gt; any(@oldvals) { print &amp;quot;$newval isn&#39;t the smallest.&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Perl 5 we&amp;rsquo;d have to write that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (grep { $newval &amp;gt; $_ } @oldvals) { print &amp;quot;$newval isn&#39;t the
smallest.&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which isn&amp;rsquo;t as clear and isn&amp;rsquo;t as quick (since the &lt;code&gt;any&lt;/code&gt; version will short-circuit as soon as it knows the comparison is true, whereas the &lt;code&gt;grep&lt;/code&gt; version will churn through every element of &lt;code&gt;@oldvals&lt;/code&gt; no matter what).&lt;/p&gt;

&lt;p&gt;An &lt;code&gt;any&lt;/code&gt; is even more useful when we have a collection of new values to check against the old ones. We can say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if any(@newvals) &amp;gt; any(@oldvals) { print &amp;quot;Already seen at least
one smaller value.&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;instead of resorting to the horror of nested &lt;code&gt;grep&lt;/code&gt;s:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (grep { my $old = $_; grep { $_ &amp;gt; $old } @newvals } @oldvals)
{ print &amp;quot;Already seen at least one smaller value.&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What if we wanted to check whether &lt;em&gt;all&lt;/em&gt; of the new values were greater than any of the old ones? For that we use a different kind of junction — one that is equal to all our values at once (rather than just any one of them). We can create such a junction with the &lt;code&gt;all&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if all(@newvals) &amp;gt; any(@oldvals) {
    print &amp;quot;These are all bigger than something already seen.&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We could also test if all the new values are greater than &lt;em&gt;all&lt;/em&gt; the old ones (not merely greater than at least one of them), with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if all(@newvals) &amp;gt; all(@oldvals) {
    print &amp;quot;These are all bigger than everything already seen.&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s an operator for building &lt;code&gt;all&lt;/code&gt; junctions too. No prizes for guessing. It&amp;rsquo;s n-ary &lt;code&gt;&amp;amp;&lt;/code&gt;. So, if we needed to check that the maximal dimension of some object is within acceptable limits, we could say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if $max_dimension &amp;lt; $height &amp;amp; $width &amp;amp; $depth {
    print &amp;quot;A maximal dimension of $max_dimension is okay.&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That last example is the same as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if $max_dimension &amp;lt; $height
&amp;amp;&amp;amp; $max_dimension &amp;lt; $width
&amp;amp;&amp;amp; $max_dimension &amp;lt; $depth {
    print &amp;quot;A maximal dimension of $max_dimension is okay.&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;any&lt;/code&gt; junctions are known as &lt;em&gt;disjunctions&lt;/em&gt;, because they act like they&amp;rsquo;re in a boolean OR: &amp;ldquo;this OR that OR the other&amp;rdquo;. &lt;code&gt;all&lt;/code&gt; junctions are known as &lt;em&gt;conjunctions&lt;/em&gt;, because they have an implicit AND between their values — &amp;ldquo;this AND that AND the other&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;There are two other types of junction available in Perl 6: &lt;em&gt;abjunctions&lt;/em&gt; and &lt;em&gt;injunctions&lt;/em&gt;. An abjunction is created using the &lt;code&gt;one&lt;/code&gt; function and represents exactly one of its possible values at any given time:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if one(@roots) == 0 {
    print &amp;quot;Unique root to polynomial.&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In other words, it&amp;rsquo;s as though there were an implicit n-ary XOR between each pair of values.&lt;/p&gt;

&lt;p&gt;Injunctions represent none of their values and hence are constructed with a built-in named &lt;code&gt;none&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if $passwd eq none(@previous_passwds) {
    print &amp;quot;New password is acceptable.&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;They&amp;rsquo;re like a multi-part NEITHER&amp;hellip;NOR&amp;hellip;NOR&amp;hellip;&lt;/p&gt;

&lt;p&gt;We can build a junction out of any scalar type. For example, strings:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $known_title = &#39;Mr&#39; | &#39;Mrs&#39; | &#39;Ms&#39; | &#39;Dr&#39; | &#39;Rev&#39;;

if %person{title} ne $known_title {
    print &amp;quot;Unknown title: %person{title}.&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or even &lt;code&gt;Code&lt;/code&gt; references:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my &amp;amp;ideal := \&amp;amp;tall &amp;amp; \&amp;amp;dark &amp;amp; \&amp;amp;handsome;

if ideal($date) {   # Same as: if tall($date) &amp;amp;&amp;amp; dark($date) &amp;amp;&amp;amp; handsome($date)
    swoon();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;the-best-of-both-worlds&#34;&gt;The Best of Both Worlds&lt;/h4&gt;

&lt;p&gt;So a disjunction (&lt;code&gt;any&lt;/code&gt;) allows us to create a scalar value that is &lt;em&gt;either&lt;/em&gt; this &lt;em&gt;or&lt;/em&gt; that.&lt;/p&gt;

&lt;p&gt;In Perl 6, classes (or, more specifically, &lt;code&gt;Class&lt;/code&gt; objects) are scalar values. So it follows that we can create a disjunction of classes. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Floor::Wax | Dessert::Topping
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gives us a type that can be &lt;em&gt;either&lt;/em&gt; &lt;code&gt;Floor::Wax&lt;/code&gt; &lt;em&gt;or&lt;/em&gt; &lt;code&gt;Dessert::Topping&lt;/code&gt;. So a variable declared with that type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my Floor::Wax|Dessert::Topping $shimmer;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;can store &lt;em&gt;either&lt;/em&gt; a &lt;code&gt;Floor::Wax&lt;/code&gt; object &lt;em&gt;or&lt;/em&gt; a &lt;code&gt;Dessert::Topping&lt;/code&gt; object. A parameter declared with that type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub advertise(Floor::Wax|Dessert::Topping $shimmer) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;can be passed an argument that is of either type.&lt;/p&gt;

&lt;h4 id=&#34;matcher-smarter-not-harder&#34;&gt;Matcher Smarter, not Harder&lt;/h4&gt;

&lt;p&gt;So, in order to extend &lt;code&gt;&amp;amp;part&lt;/code&gt; to accept a &lt;code&gt;Class&lt;/code&gt; as its first argument, whilst allowing it to accept a &lt;code&gt;Code&lt;/code&gt; object in that position, we just use a type junction:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub part (Code|Class $is_sheep, *@data) {
    my (@sheep, @goats);
    for @data {
        when $is_sheep { push @sheep, $_ }
        default        { push @goats, $_ }
    }
    return (\@sheep, \@goats);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are only two differences between this version and the previous one. The first difference is, of course, that we have changed the type of the first parameter. Previously it was &lt;code&gt;Code&lt;/code&gt;; now it&amp;rsquo;s &lt;code&gt;Code|Class&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The second change is in the body of the subroutine itself. We replaced the partitioning &lt;code&gt;if&lt;/code&gt; statement:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for @data {
    if $is_sheep($_) { push @sheep, $_ }
    else             { push @goats, $_ }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With a switch:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for @data {
    when $is_sheep { push @sheep, $_ }
    default        { push @goats, $_ }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the actual work of categorizing each element as a &amp;ldquo;sheep&amp;rdquo; or a &amp;ldquo;goat&amp;rdquo; is done by the &lt;code&gt;when&lt;/code&gt; statement, because:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;when $is_sheep { push @sheep, $_ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if $_ ~~ $is_sheep { push @sheep, $_; next }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When &lt;code&gt;$is_sheep&lt;/code&gt; is a subroutine reference, that implicit smart-match will simply pass &lt;code&gt;$_&lt;/code&gt; (the current data element) to the subroutine and then evaluate the return value as a boolean. On the other hand, when &lt;code&gt;$is_sheep&lt;/code&gt; is a class, the smart-match will check to see if the object in &lt;code&gt;$_&lt;/code&gt; belongs to the same class or some derived class.&lt;/p&gt;

&lt;p&gt;The single &lt;code&gt;when&lt;/code&gt; statement handles either type of selector — &lt;code&gt;Code&lt;/code&gt; or &lt;code&gt;Class&lt;/code&gt; — auto-magically. That&amp;rsquo;s why it&amp;rsquo;s known as smart-matching.&lt;/p&gt;

&lt;p&gt;Having now allowed class names as selectors, we can take the final step and simplify:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;($cats, $chattels) = part { .isa(Animal::Cat) } @animals;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;($cats, $chattels) = part Animal::Cat, @animals;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note, however, that the comma is back. Only blocks can appear in argument lists without accompanying commas, and the raw class isn&amp;rsquo;t a block.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 6&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;partitioning-rules&#34;&gt;Partitioning Rules!&lt;/h3&gt;

&lt;p&gt;Now that the &lt;code&gt;when&lt;/code&gt;&amp;rsquo;s implicit smart-match is doing the hard work of deciding how to evaluate each data element against the selector, adding new kinds of selectors becomes trivial. For example, here&amp;rsquo;s a third version of &lt;code&gt;&amp;amp;part&lt;/code&gt; which also allows Perl 6 rules (i.e. patterns) to be used to partition a list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub part (Code|Class|Rule $is_sheep, *@data) {
    my (@sheep, @goats);
    for @data {
        when $is_sheep { push @sheep, $_ }
        default        { push @goats, $_ }
    }
    return (\@sheep, \@goats);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All we needed to do was to tell &lt;code&gt;&amp;amp;part&lt;/code&gt; that its first argument was also allowed to be of type &lt;code&gt;Rule&lt;/code&gt;. That allows us to call &lt;code&gt;&amp;amp;part&lt;/code&gt; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;($cats, $chattels) = part /meow/, @animal_sounds;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the scalar context imposed by the &lt;code&gt;$is_sheep&lt;/code&gt; parameter, the &lt;code&gt;/meow/&lt;/code&gt; pattern evaluates to a &lt;code&gt;Rule&lt;/code&gt; object (rather than immediately doing a match). That &lt;code&gt;Rule&lt;/code&gt; object is then bound to &lt;code&gt;$is_sheep&lt;/code&gt; and subsequently used as the selector in the &lt;code&gt;when&lt;/code&gt; statement.&lt;/p&gt;

&lt;p&gt;Note that the body of this third version is exactly the same as that of the previous version. No change is required because, when it detects that &lt;code&gt;$is_sheep&lt;/code&gt; is a &lt;code&gt;Rule&lt;/code&gt; object, the &lt;code&gt;when&lt;/code&gt;&amp;rsquo;s smart-matching will auto-magically do a pattern match.&lt;/p&gt;

&lt;p&gt;In the same way, we could further extend &lt;code&gt;&amp;amp;part&lt;/code&gt; to allow the user to pass a hash as the selector:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my %is_cat = (
    cat =&amp;gt; 1, tiger =&amp;gt; 1, lion =&amp;gt; 1, leopard =&amp;gt; 1, # etc.
);

($cats, $chattels) = part %is_cat, @animal_names;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;simply by changing the parameter list of &lt;code&gt;&amp;amp;part&lt;/code&gt; to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub part (Code|Class|Rule|Hash $is_sheep, *@data) {
    # body exactly as before
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once again, the smart-match hidden in the &lt;code&gt;when&lt;/code&gt; statement just Does The Right Thing. On detecting a hash being matched against each datum, it will use the datum as a key, do a hash look up, and evaluate the truth of the corresponding entry in the hash.&lt;/p&gt;

&lt;p&gt;Of course, the ever-increasing disjunction of allowable selector types is rapidly threatening to overwhelm the entire parameter list. At this point it would make sense to factor the type-junction out, give it a logical name, and use that name instead. To do that, we just write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Selector ::= Code | Class | Rule | Hash;

sub part (Selector $is_sheep, *@data) {
    # body exactly as before
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;::=&lt;/code&gt; binding operator is just like the &lt;code&gt;:=&lt;/code&gt; binding operator, except that it operates at compile-time. It&amp;rsquo;s the right choice here because types need to be fully defined at compile-time, so the compiler can do as much static type checking as possible.&lt;/p&gt;

&lt;p&gt;The effect of the binding is to make the name &lt;code&gt;Selector&lt;/code&gt; an alias for &lt;code&gt;Code&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;Class&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;Rule&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;Hash&lt;/code&gt;. Then we can just use &lt;code&gt;Selector&lt;/code&gt; wherever we want that particular disjunctive type.&lt;/p&gt;

&lt;h3 id=&#34;out-with-the-new-and-in-with-the-old&#34;&gt;Out with the New and in with the Old&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s take a step back for a moment.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ve already seen how powerful and clean these new-fangled explicit parameters can be, but maybe you still prefer the Perl 5 approach. After all, &lt;code&gt;@_&lt;/code&gt; was good enough fer Grandpappy when he lernt hisself Perl as a boy, dangnabit!&lt;/p&gt;

&lt;p&gt;In Perl 6 we can still pass our arguments the old-fashioned way and then process them manually:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Still valid Perl 6...
sub part {
    # Unpack and verify args...
    my ($is_sheep, @data) = @_;
    croak &amp;quot;First argument to &amp;amp;part is not Code, Hash, Rule, or Class&amp;quot;
        unless $is_sheep.isa(Selector);

    # Then proceed as before...
    my (@sheep, @goats);
    for @data {
        when $is_sheep { push @sheep, $_ }
        default        { push @goats, $_ }
    }
    return (\@sheep, \@goats);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we declare a subroutine without a parameter list, Perl 6 automatically supplies one for us, consisting of a single slurpy array named &lt;code&gt;@_&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub part {...}      # means: sub part (*@_) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is, any un-parametered Perl 6 subroutine expects to flatten and then slurp up an arbitrarily long list of arguments, binding them to the elements of a parameter called &lt;code&gt;@_&lt;/code&gt;. That&amp;rsquo;s pretty much what a Perl 5 subroutine does. The only important difference is that in Perl 6 that slurpy &lt;code&gt;@_&lt;/code&gt; is, like all Perl 6 parameters, constant by default. So, if we want the &lt;em&gt;exact&lt;/em&gt; behaviour of a Perl 5 subroutine — including being able to modify elements of &lt;code&gt;@_&lt;/code&gt; — we need to be explicit:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub part (*@_ is rw) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that &amp;ldquo;declare a subroutine without a parameter list&amp;rdquo; &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; mean &amp;ldquo;declare a subroutine with an empty parameter list&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub part    {...}   # without parameter list
sub part () {...}   # empty parameter list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An empty parameter list specifies that the subroutine takes exactly zero arguments, whereas a missing parameter list means it takes any number of arguments and binds them to the implicit parameter &lt;code&gt;@_&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Of course, by using the implicit &lt;code&gt;@_&lt;/code&gt; instead of named parameters, we&amp;rsquo;re merely doing extra work that Perl 6 could do for us, as well as making the subroutine body more complex, harder to maintain, and slower. We&amp;rsquo;re also eliminating any chance of Perl 6 identifying argument mismatches at compile-time. And, unless we&amp;rsquo;re prepared to complexify the code even further, we&amp;rsquo;re preventing client code from using named arguments (see &amp;ldquo;Name your poison&amp;rdquo; below).&lt;/p&gt;

&lt;p&gt;But this is Perl, not Fascism. We&amp;rsquo;re not in the business of imposing the One True Coding Style on Perl hackers. So if you want to pass your arguments the old-fashioned way, Perl 6 makes sure you still can.&lt;/p&gt;

&lt;h3 id=&#34;a-pair-of-lists-in-a-list-of-pairs&#34;&gt;A Pair of Lists in a List of Pairs&lt;/h3&gt;

&lt;p&gt;Suppose now that, instead of getting a list of array references back, we wanted to get back a list of &lt;code&gt;key=&amp;gt;value&lt;/code&gt; pairs, where each value was one of the array refs and each key some kind of identifying label (we&amp;rsquo;ll see why that might be particularly handy soon).&lt;/p&gt;

&lt;p&gt;The easiest solution is to use two fixed keys (for example, &amp;ldquo;&lt;code&gt;sheep&lt;/code&gt;&amp;rdquo; and &amp;ldquo;&lt;code&gt;goats&lt;/code&gt;&amp;rdquo;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub part (Selector $is_sheep, *@data) returns List of Pair {
    my %herd;
    for @data {
        when $is_sheep { push %herd{&amp;quot;sheep&amp;quot;}, $_ }
        default        { push %herd{&amp;quot;goats&amp;quot;}, $_ }
    }
    return *%herd;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The parameter list of the subroutine is unchanged, but now we&amp;rsquo;ve added a return type after it, using the &lt;code&gt;returns&lt;/code&gt; keyword. That return type is &lt;code&gt;List of Pair&lt;/code&gt;, which tells the compiler that any &lt;code&gt;return&lt;/code&gt; statements in the subroutine are expected to return a list of values, each of which is a Perl 6 &lt;code&gt;key=&amp;gt;value&lt;/code&gt; pair.&lt;/p&gt;

&lt;h4 id=&#34;parametric-types&#34;&gt;Parametric Types&lt;/h4&gt;

&lt;p&gt;Note that this type is different from those we&amp;rsquo;ve seen so far: it&amp;rsquo;s compound. The &lt;code&gt;of Pair&lt;/code&gt; suffix is actually an argument that modifies the principal type &lt;code&gt;List&lt;/code&gt;, telling the container type what kind of value it&amp;rsquo;s allowed to store. This is possible because &lt;code&gt;List&lt;/code&gt; is a &lt;em&gt;parametric type&lt;/em&gt;. That is, it&amp;rsquo;s a type that can be specified with arguments that modify how it works. The idea is a little like C++ templates, except not quite so brain-meltingly complicated.&lt;/p&gt;

&lt;p&gt;The specific parameters for a parametric type are normally specified in square brackets, immediately after the class name. The arguments that define a particular instance of the class are likewise passed in square brackets. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Table[Class $of] {...}
class Logfile[Str $filename] {...}
module SecureOps[AuthKey $key] {...}

# and later:

sub typeset(Table of Contents $toc) {...}
# Expects an object whose class is Table
# and which stores Contents objects

my Logfile[&amp;quot;./log&amp;quot;] $file;
# $file can only store logfiles that log to ./log

$plaintext = SecureOps[$KEY]::decode($cryptotext);
# Only use &amp;amp;decode if our $KEY entitles us to
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that type names like &lt;code&gt;Table of Contents&lt;/code&gt; and &lt;code&gt;List of Pair&lt;/code&gt; are really just tidier ways to say &lt;code&gt;Table[of=&amp;gt;Contents]&lt;/code&gt; and &lt;code&gt;List[of=&amp;gt;Pair]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;By convention, when we pass an argument to the &lt;code&gt;$of&lt;/code&gt; parameter of a parametric type, we&amp;rsquo;re telling that type what kind of value we&amp;rsquo;re expecting it to store. For example: whenever we access an element of &lt;code&gt;List of Pair&lt;/code&gt;, we expect to get back a &lt;code&gt;Pair&lt;/code&gt;. Similarly we could specify &lt;code&gt;List of Int&lt;/code&gt;, &lt;code&gt;Array of Str&lt;/code&gt;, or &lt;code&gt;Hash of Num&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Admittedly &lt;code&gt;List of Pair&lt;/code&gt; doesn&amp;rsquo;t seem &lt;em&gt;much&lt;/em&gt; tidier than &lt;code&gt;List(of=&amp;gt;Pair)&lt;/code&gt;, but as container types get more complex, the advantages start to become obvious. For example, consider a data structure consisting of an array of arrays of arrays of hashes of numbers (such as one might use to store, say, several years worth of daily climatic data). Using the &lt;code&gt;of&lt;/code&gt; notation that&amp;rsquo;s just:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Climate::Record ::= Array of Array of Array of Hash of Num;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Without the &lt;code&gt;of&lt;/code&gt; keyword, it&amp;rsquo;s:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Climate::Record ::= Array(of=&amp;gt;Array(of=&amp;gt;Array(of=&amp;gt;Hash(of=&amp;gt;Num))));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which is starting to look uncomfortably like Lisp.&lt;/p&gt;

&lt;p&gt;Parametric types may have any number of parameters with any names we like, but only type parameters named &lt;code&gt;$of&lt;/code&gt; have special syntactic support built into Perl.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 6&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;tmtowtdeclarei&#34;&gt;TMTOWTDeclareI&lt;/h4&gt;

&lt;p&gt;While we&amp;rsquo;re talking about type declarations, it&amp;rsquo;s worth noting that we could also have put &lt;code&gt;&amp;amp;part&lt;/code&gt;&amp;rsquo;s new return type out in front (just as we&amp;rsquo;ve been doing with variable and parameter types). However, this is only allowed for subroutines when the subroutine is explicitly scoped:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# lexical subroutine
my List of Pair sub part (Selector $is_sheep, *@data) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# package subroutine
our List of Pair sub part (Selector $is_sheep, *@data) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The return type goes between the scoping keyword (&lt;code&gt;my&lt;/code&gt; or &lt;code&gt;our&lt;/code&gt;) and the &lt;code&gt;sub&lt;/code&gt; keyword. And, of course, the &lt;code&gt;returns&lt;/code&gt; keyword is not used.&lt;/p&gt;

&lt;p&gt;Contrariwise, we can also put variable/parameter type information &lt;em&gt;after&lt;/em&gt; the variable name. To do that, we use the &lt;code&gt;of&lt;/code&gt; keyword:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my sub part ($is_sheep of Selector, *@data) returns List of Pair {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This makes sense, when you think about it. As we saw above, &lt;code&gt;of&lt;/code&gt; tells the preceding container what type of value it&amp;rsquo;s supposed to store, so &lt;code&gt;$is_sheep of Selector&lt;/code&gt; tells &lt;code&gt;$is_sheep&lt;/code&gt; it&amp;rsquo;s supposed to store a &lt;code&gt;Selector&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;you-are-what-you-eat-not&#34;&gt;You Are What You Eat &amp;ndash; Not!&lt;/h4&gt;

&lt;p&gt;Careful though: we have to remember to use &lt;code&gt;of&lt;/code&gt; there, not &lt;code&gt;is&lt;/code&gt;. It would be a mistake to write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my sub part ($is_sheep is Selector, *@data) returns List of Pair {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s because Perl 6 variables and parameters can be more precisely typed than variables in most other languages. Specifically, Perl 6 allows us to specify both the &lt;em&gt;storage type&lt;/em&gt; of a variable (i.e. what kinds of values it can contain) and the &lt;em&gt;implementation class&lt;/em&gt; of the variable (i.e. how the variable itself is actually implemented).&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;is&lt;/code&gt; keyword indicates what a particular container (variable, parameter, etc.) &lt;em&gt;is&lt;/em&gt; — namely, how it&amp;rsquo;s implemented and how it operates. Saying:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub bark(@dogs is Pack) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;specifies that, although the &lt;code&gt;@dogs&lt;/code&gt; parameter looks like an &lt;code&gt;Array&lt;/code&gt;, it&amp;rsquo;s actually implemented by the &lt;code&gt;Pack&lt;/code&gt; class instead.&lt;/p&gt;

&lt;p&gt;That declaration is &lt;strong&gt;not&lt;/strong&gt; specifying that the &lt;code&gt;@dogs&lt;/code&gt; variable &lt;em&gt;stores&lt;/em&gt; &lt;code&gt;Pack&lt;/code&gt; objects. In fact, it&amp;rsquo;s not saying anything at all about what &lt;code&gt;@dogs&lt;/code&gt; stores. Since its storage type has been left unspecified, &lt;code&gt;@dogs&lt;/code&gt; inherits the default storage type — &lt;code&gt;Any&lt;/code&gt; — which allows its elements to store any kind of scalar value.&lt;/p&gt;

&lt;p&gt;If we&amp;rsquo;d wanted to specify that &lt;code&gt;@dogs&lt;/code&gt; was a normal array, but that it can only store &lt;code&gt;Dog&lt;/code&gt; objects, we&amp;rsquo;d need to write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub bark(@dogs of Dog) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and if we&amp;rsquo;d wanted it to store &lt;code&gt;Dog&lt;/code&gt;s but be implemented by the &lt;code&gt;Pack&lt;/code&gt; class, we&amp;rsquo;d have to write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub bark(@dogs is Pack of Dog) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Appending &lt;code&gt;is SomeType&lt;/code&gt; to a variable or parameter is the Perl 6 equivalent of Perl 5&amp;rsquo;s &lt;code&gt;tie&lt;/code&gt; mechanism, except that the tying is part of the declaration. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $Elvis is King of Rock&amp;amp;Roll;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;rather than a run-time function call like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Perl 5 code...
my $Elvis;
tie $Elvis, &#39;King&#39;, stores=&amp;gt;all(&#39;Rock&#39;,&#39;Roll&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In any case, the simple rule for &lt;code&gt;of&lt;/code&gt; vs &lt;code&gt;is&lt;/code&gt; is: &lt;em&gt;to say what a variable stores, use &lt;code&gt;of&lt;/code&gt;; to say how the variable itself works, use &lt;code&gt;is&lt;/code&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h4 id=&#34;many-happy-returns&#34;&gt;Many Happy Returns&lt;/h4&gt;

&lt;p&gt;Meanwhile, we&amp;rsquo;re still attempting to create a version of &lt;code&gt;&amp;amp;part&lt;/code&gt; that returns a list of pairs. The easiest way to create and return a suitable list of pairs is to flatten a hash in a list context. This is precisely what the &lt;code&gt;return&lt;/code&gt; statement does:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return *%herd;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;using the splatty star. Although, in this case, we could have simply written:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return %herd;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;since the declared return type (&lt;code&gt;List of Pair&lt;/code&gt;) automatically imposes list context (and hence list flattening) on any &lt;code&gt;return&lt;/code&gt; statement within &lt;code&gt;&amp;amp;part&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Of course, it will only make sense to return a flattened hash if we&amp;rsquo;ve already partitioned the original data into that hash. So the bodies of the &lt;code&gt;when&lt;/code&gt; and &lt;code&gt;default&lt;/code&gt; statements inside &lt;code&gt;&amp;amp;part&lt;/code&gt; have to be changed accordingly. Now, instead of pushing each element onto one of two separate arrays, we push each element onto one of the two arrays stored inside &lt;code&gt;%herd&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for @data {
    when $is_sheep { push %herd{&amp;quot;sheep&amp;quot;}, $_ }
    default        { push %herd{&amp;quot;goats&amp;quot;}, $_ }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;it-lives&#34;&gt;It Lives!!!!!&lt;/h4&gt;

&lt;p&gt;Assuming that each of the hash entries (&lt;code&gt;%herd{&amp;quot;sheep&amp;quot;}&lt;/code&gt; and &lt;code&gt;%herd{&amp;quot;goats&amp;quot;}&lt;/code&gt;) will be storing a reference to one of the two arrays, we can simply push each data element onto the appropriate array.&lt;/p&gt;

&lt;p&gt;In Perl 5 we&amp;rsquo;d have to dereference each of the array references inside our hash before we could push a new element onto it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Perl 5 code...
push @{$herd{&amp;quot;sheep&amp;quot;}}, $_;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But in Perl 6, the first parameter of &lt;code&gt;push&lt;/code&gt; expects an array, so if we give it an array reference, the interpreter can work out that it needs to dereference that first argument. So we can just write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Perl 6 code...
push %herd{&amp;quot;sheep&amp;quot;}, $_;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Remember that, in Perl 6, hashes keep their &lt;code&gt;%&lt;/code&gt; sigil, even when being indexed).&lt;/p&gt;

&lt;p&gt;Initially, of course, the entries of &lt;code&gt;%herd&lt;/code&gt; don&amp;rsquo;t contain references to arrays at all; like all uninitialized hash entries, they contain &lt;code&gt;undef&lt;/code&gt;. But, because &lt;code&gt;push&lt;/code&gt; itself is defined like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub push (@array is rw, *@data) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;an actual read-writable array is expected as the first argument. If a scalar variable containing &lt;code&gt;undef&lt;/code&gt; is passed to such a parameter, Perl 6 detects the fact and autovivifies the necessary array, placing a reference to it into the previously undefined scalar argument. That behaviour makes it trivially easy to create subroutines that autovivify read/write arguments, in the same way that Perl 5&amp;rsquo;s &lt;code&gt;open&lt;/code&gt; does.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s also possible to declare a read/write parameter that &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; autovivify in this way: using the &lt;code&gt;is ref&lt;/code&gt; trait instead of &lt;code&gt;is rw&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub push_only_if_real_array (@array is ref, *@data) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;is ref&lt;/code&gt; still allows the parameter to be read from and written to, but throws an exception if the corresponding argument isn&amp;rsquo;t already a real referent of some kind.&lt;/p&gt;

&lt;h3 id=&#34;a-label-by-any-other-name&#34;&gt;A Label by Any Other Name&lt;/h3&gt;

&lt;p&gt;Mandating fixed labels for the two arrays being returned seems a little inflexible, so we could add another — optional — parameter via which user-selected key names could be passed&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub part (Selector $is_sheep,
          Str ?@labels is dim(2) = &amp;lt;&amp;lt;sheep goats&amp;gt;&amp;gt;,
          *@data
         ) returns List of Pair
{
    my ($sheep, $goats) is constant = @labels;
    my %herd = ($sheep=&amp;gt;[], $goats=&amp;gt;[]);
    for @data {
        when $is_sheep { push %herd{$sheep}, $_ }
        default        { push %herd{$goats}, $_ }
    }
    return *%herd;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Optional parameters in Perl 6 are prefixed with a &lt;code&gt;?&lt;/code&gt; marker (just as slurpy parameters are prefixed with &lt;code&gt;*&lt;/code&gt;). Like required parameters, optional parameters are passed positionally, so the above example means that the second argument is expected to be an array of strings. This has important consequences for backwards compatibility — as we&amp;rsquo;ll see shortly.&lt;/p&gt;

&lt;p&gt;As well as declaring it to be optional (using a leading &lt;code&gt;?&lt;/code&gt;), we also declare the &lt;code&gt;@labels&lt;/code&gt; parameter to have exactly two elements, by specifying the &lt;code&gt;is dim(2)&lt;/code&gt; trait. The &lt;code&gt;is dim&lt;/code&gt; trait takes one or more integer values. The number of values it&amp;rsquo;s given specifies the number of dimensions the array has; the values themselves specify how many elements long the array is in each dimension. For example, to create a four-dimensional array of 7x24x60x60 elements, we&amp;rsquo;d declare it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my @seconds is dim(7,24,60,60);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the latest version of &lt;code&gt;&amp;amp;part&lt;/code&gt;, the &lt;code&gt;@labels is dim(2)&lt;/code&gt; declaration means that &lt;code&gt;@labels&lt;/code&gt; is a normal one-dimensional array, but that it has only two elements in that one dimension.&lt;/p&gt;

&lt;p&gt;The final component of the declaration of &lt;code&gt;@labels&lt;/code&gt; is the specification of its default value. Any optional parameter may be given a default value, to which it will be bound if no corresponding argument is provided. The default value can be any expression that yields a value compatible with the type of the optional parameter.&lt;/p&gt;

&lt;p&gt;In the above version of &lt;code&gt;&amp;amp;part&lt;/code&gt;, for the sake of backwards compatibility we make the optional &lt;code&gt;@labels&lt;/code&gt; default to the list of two strings &lt;code&gt;&amp;lt;&amp;lt;sheep goats&amp;gt;&amp;gt;&lt;/code&gt;  (using the new Perl 6 list-of-strings syntax).&lt;/p&gt;

&lt;p&gt;Thus if we provide an array of two strings explicitly, the two strings we provide will be used as keys for the two pairs returned. If we don&amp;rsquo;t specify the labels ourselves, &lt;code&gt;&amp;quot;sheep&amp;quot;&lt;/code&gt; and &lt;code&gt;&amp;quot;goats&amp;quot;&lt;/code&gt; will be used.&lt;/p&gt;

&lt;h4 id=&#34;name-your-poison&#34;&gt;Name Your Poison&lt;/h4&gt;

&lt;p&gt;With the latest version of &lt;code&gt;&amp;amp;part&lt;/code&gt; defined to return named pairs, we can now write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@parts = part Animal::Cat, &amp;lt;&amp;lt;cat chattel&amp;gt;&amp;gt;, @animals;
#    returns: (cat=&amp;gt;[...], chattel=&amp;gt;[...])
# instead of: (sheep=&amp;gt;[...], goats=&amp;gt;[...])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first argument (&lt;code&gt;Animal::Cat&lt;/code&gt;) is bound to &lt;code&gt;&amp;amp;part&lt;/code&gt;&amp;rsquo;s &lt;code&gt;$is_sheep&lt;/code&gt; parameter (as before). The second argument (&lt;code&gt;&amp;lt;&amp;lt;cat chattel&amp;gt;&amp;gt;&lt;/code&gt;) is now bound to the optional &lt;code&gt;@labels&lt;/code&gt; parameter, leaving the &lt;code&gt;@animals&lt;/code&gt; argument to be flattened into a list and slurped up by the &lt;code&gt;@data&lt;/code&gt; parameter.&lt;/p&gt;

&lt;p&gt;We could also pass some or all of the arguments as &lt;em&gt;named arguments&lt;/em&gt;. A named argument is simply a Perl 6 pair, where the key is the name of the intended parameter, and the value is the actual argument to be bound to that parameter. That makes sense: every parameter we ever declare has to have a name, so there&amp;rsquo;s no good reason why we shouldn&amp;rsquo;t be allowed to pass it an argument using that name to single it out.&lt;/p&gt;

&lt;p&gt;An important restriction on named arguments is that they cannot come before positional arguments, or after any arguments that are bound to a slurpy array. Otherwise, there would be no efficient, single-pass way of working out which unnamed arguments belong to which parameters. Apart from that one overarching restriction (which Larry likes to think of as a zoning law), we&amp;rsquo;re free to pass named arguments in any order we like. That&amp;rsquo;s a huge advantage in any subroutine that takes a large number of parameters, because it means we no longer have to remember their order, just their names.&lt;/p&gt;

&lt;p&gt;For example, using named arguments we could rewrite the above &lt;code&gt;part&lt;/code&gt; call as any of the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Use named argument to pass optional @labels argument...
@parts = part Animal::Cat, labels =&amp;gt; &amp;lt;&amp;lt;cat chattel&amp;gt;&amp;gt;, @animals;

# Use named argument to pass both @labels and @data arguments...
@parts = part Animal::Cat, labels =&amp;gt; &amp;lt;&amp;lt;cat chattel&amp;gt;&amp;gt;, data =&amp;gt; @animals;

# The order in which named arguments are passed doesn&#39;t matter...
@parts = part Animal::Cat, data =&amp;gt; @animals, labels =&amp;gt; &amp;lt;&amp;lt;cat chattel&amp;gt;&amp;gt;;

# Can pass *all* arguments by name...
@parts = part is_sheep =&amp;gt; Animal::Cat,
                labels =&amp;gt; &amp;lt;&amp;lt;cat chattel&amp;gt;&amp;gt;,
                  data =&amp;gt; @animals;

# And the order still doesn&#39;t matter...
@parts = part data =&amp;gt; @animals,
              labels =&amp;gt; &amp;lt;&amp;lt;cat chattel&amp;gt;&amp;gt;,
              is_sheep =&amp;gt; Animal::Cat;

# etc.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As long as we never put a named argument before a positional argument, or after any unnamed data for the slurpy array, the named arguments can appear in any convenient order. They can even be pulled out of a flattened hash:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@parts = part *%args;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 6&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;who-gets-the-last-piece-of-cake&#34;&gt;Who Gets the Last Piece of Cake?&lt;/h4&gt;

&lt;p&gt;We&amp;rsquo;re making progress. Whether we pass its arguments by name or positionally, our call to &lt;code&gt;part&lt;/code&gt; produces two partitions of the original list. Those partitions now come back with convenient labels that we can specify via the optional &lt;code&gt;@labels&lt;/code&gt; parameter.&lt;/p&gt;

&lt;p&gt;But now there&amp;rsquo;s a problem. Even though we explicitly marked it as optional, it turns out that things can go horribly wrong if we don&amp;rsquo;t actually supply that optional argument. Which is not very &amp;ldquo;optional&amp;rdquo;. Worse, it means there&amp;rsquo;s potentially a problem with every single legacy call to &lt;code&gt;part&lt;/code&gt; that was coded before we added the optional parameter.&lt;/p&gt;

&lt;p&gt;For example, consider the call:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@pets = (&#39;Canis latrans&#39;, &#39;Felis sylvestris&#39;);

@parts = part /:i felis/, @pets;

# expected to return: (sheep=&amp;gt;[&#39;Felis sylvestris&#39;], goats=&amp;gt;[&#39;Canis latrans&#39;] )
# actually returns:   (&#39;Canis latrans&#39;=&amp;gt;[], &#39;Felis sylvestris&#39;=&amp;gt;[])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What went wrong?&lt;/p&gt;

&lt;p&gt;Well, when the call to &lt;code&gt;part&lt;/code&gt; is matching its argument list against &lt;code&gt;&amp;amp;call&lt;/code&gt;&amp;rsquo;s parameter list, it works left-to-right as follows:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The first parameter (&lt;code&gt;$is_sheep&lt;/code&gt;) is declared as a scalar of type &lt;code&gt;Selector&lt;/code&gt;, so the first argument must be a &lt;code&gt;Code&lt;/code&gt; or a &lt;code&gt;Class&lt;/code&gt; or a &lt;code&gt;Hash&lt;/code&gt; or a &lt;code&gt;Rule&lt;/code&gt;. It&amp;rsquo;s actually a &lt;code&gt;Rule&lt;/code&gt;, so the call mechanism binds that rule to &lt;code&gt;$is_sheep&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The second parameter (&lt;code&gt;?@labels&lt;/code&gt;) is declared as an array of two strings, so the second argument must be an array of two strings. &lt;code&gt;@pets&lt;/code&gt; is an array of two strings, so we bind that array to &lt;code&gt;@labels&lt;/code&gt;. (Oops!)&lt;/li&gt;
&lt;li&gt;The third parameter (&lt;code&gt;*@data&lt;/code&gt;) is declared as a slurpy array, so any remaining arguments should be flattened and bound to successive elements of &lt;code&gt;@data&lt;/code&gt;. There are no remaining arguments, so there&amp;rsquo;s nothing to flatten-and-bind, so &lt;code&gt;@data&lt;/code&gt; remains empty.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That&amp;rsquo;s the problem. If we pass the arguments positionally and there are not enough of them to bind to every parameter, the parameters at the start of the parameter list are bound before those towards the end. Even if those earlier parameters are marked optional. In other words, argument binding is &amp;ldquo;greedy&amp;rdquo; and (for obvious efficiency reasons) it never backtracks to see if there might be better ways to match arguments to parameters. Which means, in this case, that our data is being preemptively &amp;ldquo;stolen&amp;rdquo; by our labels.&lt;/p&gt;

&lt;h4 id=&#34;pipeline-to-the-rescue&#34;&gt;Pipeline to the Rescue!&lt;/h4&gt;

&lt;p&gt;So in general (and in the above example in particular) we need some way of indicating that a positional argument belongs to the slurpy data, not to some preceding optional parameter. One way to do that is to pass the ambiguous argument by name:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@parts = part /:i felis/, data=&amp;gt;@pets;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then there can be no mistake about which argument belongs to what parameter.&lt;/p&gt;

&lt;p&gt;But there&amp;rsquo;s also a purely positional way to tell the call to &lt;code&gt;part&lt;/code&gt; that &lt;code&gt;@pets&lt;/code&gt; belongs to the slurpy &lt;code&gt;@data&lt;/code&gt;, not to the optional &lt;code&gt;@labels&lt;/code&gt;. We can pipeline it directly there. After all, that&amp;rsquo;s precisely what the pipeline operator does: it binds the list on its blunt side to the slurpy array parameter of the call on its sharp side. So we could just write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@parts = part /:i felis/ &amp;lt;== @pets;

# returns: (sheep=&amp;gt;[&#39;Felis sylvestris&#39;], goats=&amp;gt;[&#39;Canis latrans&#39;])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because &lt;code&gt;@pets&lt;/code&gt; now appears on the blunt end of a pipeline, there&amp;rsquo;s no way it can be interpreted as anything other than the slurped data for the call to &lt;code&gt;part&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;a-natural-assumption&#34;&gt;A Natural Assumption&lt;/h4&gt;

&lt;p&gt;Of course, as a solution to the problem of legacy code, this is highly sub-optimal. It requires that every single pre-existing call to &lt;code&gt;part&lt;/code&gt; be modified (by having a pipeline inserted). That will almost certainly be too painful.&lt;/p&gt;

&lt;p&gt;Our new optional labels would be much more useful if their existence itself were also optional — if we could somehow add a single statement to the start of any legacy code file and thereby cause &lt;code&gt;&amp;amp;part&lt;/code&gt; to work like it used to in the good old days before labels. In other words, what we really want is an impostor &lt;code&gt;&amp;amp;part&lt;/code&gt; subroutine that pretends that it only has the original two parameters (&lt;code&gt;$is_sheep&lt;/code&gt; and &lt;code&gt;@data&lt;/code&gt;), but then when it&amp;rsquo;s called surreptitiously supplies an appropriate value for the new &lt;code&gt;@label&lt;/code&gt; parameter and quietly calls the real &lt;code&gt;&amp;amp;part&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In Perl 6, that&amp;rsquo;s easy. All we need is a good curry.&lt;/p&gt;

&lt;p&gt;We write the following at the start of the file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use List::Part;   # Supposing &amp;amp;part is defined in this module

my &amp;amp;part ::= &amp;amp;List::Part::part.assuming(labels =&amp;gt; &amp;lt;&amp;lt;sheep goats&amp;gt;&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That second line is a little imposing so let&amp;rsquo;s break it down. First of all:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List::Part::part
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is just the fully qualified name of the &lt;code&gt;&amp;amp;part&lt;/code&gt; subroutine that&amp;rsquo;s defined in the &lt;code&gt;List::Part&lt;/code&gt; module (which, for the purposes of this example, is where we&amp;rsquo;re saying &lt;code&gt;&amp;amp;part&lt;/code&gt; lives). So:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;amp;List::Part::part
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is the actual &lt;code&gt;Code&lt;/code&gt; object corresponding to the &lt;code&gt;&amp;amp;part&lt;/code&gt; subroutine. So:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;amp;List::Part::part.assuming(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is a method call on that &lt;code&gt;Code&lt;/code&gt; object. This is the tricky bit, but it&amp;rsquo;s no big deal really. If a &lt;code&gt;Code&lt;/code&gt; object really is an object, we certainly ought to be able to call methods on it. So:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;amp;List::Part::part.assuming(labels =&amp;gt; &amp;lt;&amp;lt;sheep goats&amp;gt;&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;calls the &lt;code&gt;assuming&lt;/code&gt; method of the &lt;code&gt;Code&lt;/code&gt; object &lt;code&gt;&amp;amp;part&lt;/code&gt; and passes the &lt;code&gt;assuming&lt;/code&gt; method a named argument whose name is &lt;code&gt;labels&lt;/code&gt; and whose value is the list of strings &lt;code&gt;&amp;lt;&amp;lt;sheep goats&amp;gt;&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now, if we only knew what the &lt;code&gt;.assuming&lt;/code&gt; method did&amp;hellip;&lt;/p&gt;

&lt;h4 id=&#34;that-about-wraps-it-up&#34;&gt;That About Wraps it Up&lt;/h4&gt;

&lt;p&gt;What the &lt;code&gt;.assuming(...)&lt;/code&gt; method does is place an anonymous wrapper around an existing &lt;code&gt;Code&lt;/code&gt; object and then return a reference to (what appears to be) an entirely separate &lt;code&gt;Code&lt;/code&gt; object. That new &lt;code&gt;Code&lt;/code&gt; object works exactly like the original — except that the new one is missing one or more of the original&amp;rsquo;s parameters.&lt;/p&gt;

&lt;p&gt;Specifically, the parameter list of the wrapper subroutine doesn&amp;rsquo;t have any of the parameters that were named in in the call to &lt;code&gt;.assuming&lt;/code&gt;. Instead those missing parameters are automatically filled in whenever the new subroutine is called, using the values of those named arguments to &lt;code&gt;.assuming&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;All of which simply means that the method call:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;amp;List::Part::part.assuming(labels =&amp;gt; &amp;lt;&amp;lt;sheep goats&amp;gt;&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;returns a reference to a new subroutine that acts like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub ($is_sheep, *@data) {
    return part($is_sheep, labels=&amp;gt;&amp;lt;&amp;lt;sheep goats&amp;gt;&amp;gt;, *@data)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is, because we passed a &lt;code&gt;labels =&amp;gt; &amp;lt;&amp;lt;sheep goats&amp;gt;&amp;gt;&lt;/code&gt;  argument to &lt;code&gt;.assuming&lt;/code&gt;, we get back a subroutine &lt;em&gt;without&lt;/em&gt; a &lt;code&gt;labels&lt;/code&gt; parameter, but which then just calls &lt;code&gt;part&lt;/code&gt; and inserts the value &lt;code&gt;&amp;lt;&amp;lt;sheep goats&amp;gt;&amp;gt;&lt;/code&gt;  for the missing parameter.&lt;/p&gt;

&lt;p&gt;Or, as the code itself suggests:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;amp;List::Part::part.assuming(labels =&amp;gt; &amp;lt;&amp;lt;sheep goats&amp;gt;&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gives us what &lt;code&gt;&amp;amp;List::Part::part&lt;/code&gt; would become under the assumption that the value of &lt;code&gt;@labels&lt;/code&gt; is always &lt;code&gt;&amp;lt;&amp;lt;sheep goats&amp;gt;&amp;gt;&lt;/code&gt; .&lt;/p&gt;

&lt;p&gt;How does that help with our source code backwards compatibility problem? It completely solves it. All we have to do is to make Perl 6 use that carefully wrapped, two-parameter version of &lt;code&gt;&amp;amp;part&lt;/code&gt; in all our legacy code, instead of the full three-parameter one. To do that, we merely create a lexical subroutine of the same name and bind the wrapped version to that lexical:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my &amp;amp;part ::= &amp;amp;List::Part::part.assuming(labels =&amp;gt; &amp;lt;&amp;lt;sheep goats&amp;gt;&amp;gt;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;my &amp;amp;part&lt;/code&gt; declares a lexical subroutine named &lt;code&gt;&amp;amp;part&lt;/code&gt; (in exactly the same way that a &lt;code&gt;my $part&lt;/code&gt; would declare a lexical variable named &lt;code&gt;$part&lt;/code&gt;). The &lt;code&gt;my&lt;/code&gt; keyword says that it&amp;rsquo;s lexical and the sigil says what kind of thing it is (&lt;code&gt;&amp;amp;&lt;/code&gt; for subroutine, in this case). Then we simply install the wrapped version of &lt;code&gt;&amp;amp;List::Part::part&lt;/code&gt; as the implementation of the new lexical &lt;code&gt;&amp;amp;part&lt;/code&gt; and we&amp;rsquo;re done.&lt;/p&gt;

&lt;p&gt;Just as lexical variables hide package or global variables of the same name, so too a lexical subroutine hides any package or global subroutine of the same name. So &lt;code&gt;my &amp;amp;part&lt;/code&gt; hides the imported &lt;code&gt;&amp;amp;List::Part::part&lt;/code&gt;, and every subsequent call to &lt;code&gt;part(...)&lt;/code&gt; in the rest of the current scope calls the lexical &lt;code&gt;&amp;amp;part&lt;/code&gt; instead.&lt;/p&gt;

&lt;p&gt;Because that lexical version is bound to a label-assuming wrapper, it doesn&amp;rsquo;t have a &lt;code&gt;labels&lt;/code&gt; parameter, so none of the legacy calls to &lt;code&gt;&amp;amp;part&lt;/code&gt; are broken. Instead, the lexical &lt;code&gt;&amp;amp;part&lt;/code&gt; just silently &amp;ldquo;fills in&amp;rdquo; the &lt;code&gt;labels&lt;/code&gt; parameter with the value we originally gave to &lt;code&gt;.assuming&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If we needed to add another partitioning call within the scope of that lexical &lt;code&gt;&amp;amp;part&lt;/code&gt;, but we wanted to use those sexy new non-default labels, we could do so by calling the actual three-parameter &lt;code&gt;&amp;amp;part&lt;/code&gt; via its fully qualified name, like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@parts = List::Part::part(Animal::Cat, &amp;lt;&amp;lt;cat chattel&amp;gt;&amp;gt;, @animals);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;pair-bonding&#34;&gt;Pair Bonding&lt;/h4&gt;

&lt;p&gt;One major advantage of having &lt;code&gt;&amp;amp;part&lt;/code&gt; return a list of pairs rather than a simple list of arrays is that now, instead of positional binding:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# with original (list-of-arrays) version of &amp;amp;part...
(@cats, @chattels) := part Animal::Cat &amp;lt;== @animals;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we can do &amp;ldquo;named binding&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# with latest (list-of-pairs) version of &amp;amp;part...
(goats=&amp;gt;@chattels, sheep=&amp;gt;@cats) := part Animal::Cat &amp;lt;== @animals;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Named binding???&lt;/p&gt;

&lt;p&gt;Well, we just learned that we can bind arguments to parameters by name, but earlier we saw that parameter binding is merely an implicit form of explicit &lt;code&gt;:=&lt;/code&gt; binding. So the inevitable conclusion is that the only reason we can bind parameters by name is because &lt;code&gt;:=&lt;/code&gt; supports named binding.&lt;/p&gt;

&lt;p&gt;And indeed it does. If a &lt;code&gt;:=&lt;/code&gt; finds a list of pairs on its righthand side, and a list of simple variables on its lefthand side, it uses named binding instead of positional binding. That is, instead of binding first to first, second to second, etc., the &lt;code&gt;:=&lt;/code&gt; uses the key of each righthand pair to determine the name of the variable on its left to which the value of the pair should be bound.&lt;/p&gt;

&lt;p&gt;That sounds complicated, but the effect is very easy to understand:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Positional binding...
($who, $why) := ($because, &amp;quot;me&amp;quot;);
# same as: $who := $because; $why := &amp;quot;me&amp;quot;;

# Named binding...
($who, $why) := (why =&amp;gt; $because, who =&amp;gt; &amp;quot;me&amp;quot;);
# same as: $who := &amp;quot;me&amp;quot;; $why := $because;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Even more usefully, if the binding operator detects a list of pairs on its left and another list of pairs on its right, it binds the value of the first pair on the right to the value of the identically named pair on the left (again, regardless of where the two pairs appear in their respective lists). Then it binds the value of the second pair on the right to the value of the identically named pair on the left, and so on.&lt;/p&gt;

&lt;p&gt;That means we can set up a named &lt;code&gt;:=&lt;/code&gt; binding in which the names of the bound variables don&amp;rsquo;t even have to match the keys of the values being bound to them:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Explicitly named binding...
(who=&amp;gt;$name, why=&amp;gt;$reason) := (why =&amp;gt; $because, who =&amp;gt; &amp;quot;me&amp;quot;);
# same as: $name := &amp;quot;me&amp;quot;; $reason := $because;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The most common use for that feature will probably be to create &amp;ldquo;free-standing&amp;rdquo; aliases for particular entries in a hash:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(who=&amp;gt;$name, why=&amp;gt;$reason) := *%explanation;
# same as: $name := %explanation{who}; $reason := %explanation{why};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or to convert particular hash entries into aliases for other variables:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*%details := (who=&amp;gt;&amp;quot;me&amp;quot;, why=&amp;gt;$because);
# same as: %details{who} := &amp;quot;me&amp;quot;, %details{why} := $because;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 6&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;an-argument-in-name-only&#34;&gt;An Argument in Name Only&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s pretty cool that Perl 6 automatically lets us specify positional arguments — and even return values — by name rather than position.&lt;/p&gt;

&lt;p&gt;But what if we&amp;rsquo;d prefer that some of our arguments could &lt;em&gt;only&lt;/em&gt; be specified by name. After all, the &lt;code&gt;@labels&lt;/code&gt; parameter isn&amp;rsquo;t really in the same league as the &lt;code&gt;$is_sheep&lt;/code&gt; parameter: it&amp;rsquo;s only an option after all, and one that most people probably won&amp;rsquo;t use. It shouldn&amp;rsquo;t really be a positional parameter at all.&lt;/p&gt;

&lt;p&gt;We &lt;strong&gt;can&lt;/strong&gt; specify that the &lt;code&gt;labels&lt;/code&gt; argument is only to be passed by name&amp;hellip;by changing the previous declaration of the &lt;code&gt;@labels&lt;/code&gt; parameter very slightly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub part (Selector $is_sheep,
          Str +@labels is dim(2) = &amp;lt;&amp;lt;sheep goats&amp;gt;&amp;gt;,
          *@data
         ) returns List of Pair
{
    my ($sheep, $goats) is constant = @labels;
    my %herd = ($sheep=&amp;gt;[], $goats=&amp;gt;[]);
    for @data {
        when $is_sheep { push %herd{$sheep}, $_ }
        default        { push %herd{$goats}, $_ }
    }
    return *%herd;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, there&amp;rsquo;s only a single character&amp;rsquo;s worth of difference in the whole definition. Whereas before we declared the &lt;code&gt;@labels&lt;/code&gt; parameter like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Str ?@labels is dim(2) = &amp;lt;&amp;lt;sheep goats&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;now we declare it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Str +@labels is dim(2) = &amp;lt;&amp;lt;sheep goats&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Changing that &lt;code&gt;?&lt;/code&gt; prefix to a &lt;code&gt;+&lt;/code&gt; changes &lt;code&gt;@labels&lt;/code&gt; from an optional positional-or-named parameter to an optional named-only parameter. Now if we want to pass in a &lt;code&gt;labels&lt;/code&gt; argument, we can only pass it by name. Attempting to pass it positionally will result in some extreme prejudice from the compiler.&lt;/p&gt;

&lt;p&gt;Named-only parameters are still optional parameters however, so legacy code that omits the labels:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%parts = part Animal::Cat &amp;lt;== @animals;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;still works fine (and still causes the &lt;code&gt;@labels&lt;/code&gt; parameter to default to &lt;code&gt;&amp;lt;&amp;lt;sheep goats&amp;gt;&amp;gt;&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Better yet, converting &lt;code&gt;@labels&lt;/code&gt; from a positional to a named-only parameter also solves the problem of legacy code of the form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%parts = part Animals::Cat, @animals;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;@animals&lt;/code&gt; can&amp;rsquo;t possibly be intended for the &lt;code&gt;@labels&lt;/code&gt; parameter now. We explicitly specified that labels can only be passed by name, and the &lt;code&gt;@animals&lt;/code&gt; argument isn&amp;rsquo;t named.&lt;/p&gt;

&lt;p&gt;So named-only parameters give us a clean way of upgrading a subroutine and still supporting legacy code. Indeed, in many cases the &lt;strong&gt;only&lt;/strong&gt; reasonable way to add a new parameter to an existing, widely used, Perl 6 subroutine will be to add it as a named-only parameter.&lt;/p&gt;

&lt;h3 id=&#34;careful-with-that-arg-eugene&#34;&gt;Careful with that Arg, Eugene!&lt;/h3&gt;

&lt;p&gt;Of course, there&amp;rsquo;s no free lunch here. The cost of solving the legacy code problem is that we changed the meaning of any more recent code like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%parts = part Animal::Cat, &amp;lt;&amp;lt;cat chattel&amp;gt;&amp;gt;, @animals;     # Oops!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When &lt;code&gt;@labels&lt;/code&gt; was positional-or-named, the &lt;code&gt;&amp;lt;&amp;lt;cat chattel&amp;gt;&amp;gt;&lt;/code&gt;  argument could only be interpreted as being intended for &lt;code&gt;@labels&lt;/code&gt;. But now, there&amp;rsquo;s no way it can be for &lt;code&gt;@labels&lt;/code&gt; (because it isn&amp;rsquo;t named), so Perl 6 assumes that the list is just part of the slurped data. The two-element list will now be flattened (along with &lt;code&gt;@animals&lt;/code&gt;), resulting in a single list that is then bound to the &lt;code&gt;@data&lt;/code&gt; parameter, as if we&amp;rsquo;d written:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%parts = part Animal::Cat &amp;lt;== &#39;cat&#39;, &#39;chattel&#39;, @animals;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is yet another reason why named-only should probably be the first choice for optional parameters.&lt;/p&gt;

&lt;h4 id=&#34;temporal-life-insurance&#34;&gt;Temporal Life Insurance&lt;/h4&gt;

&lt;p&gt;Being able to add name-only parameters to existing subroutines is an important way of future-proofing any calls to the subroutine. So long as we continue to add only named-only parameters to &lt;code&gt;&amp;amp;part&lt;/code&gt;, the order in which the subroutine expects its positional and slurpy arguments will be unchanged, so every existing call to &lt;code&gt;part&lt;/code&gt; will continue to work correctly.&lt;/p&gt;

&lt;p&gt;Curiously, the reverse is also true. Named-only parameters also provide us with a way to &amp;ldquo;history-proof&amp;rdquo; subroutine &lt;em&gt;calls&lt;/em&gt;. That is, we can allow a subroutine to accept named arguments that it doesn&amp;rsquo;t (yet) know how to handle! Like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub part (Selector $is_sheep,
          Str +@labels is dim(2) = &amp;lt;&amp;lt;sheep goats&amp;gt;&amp;gt;
          *%extras,         # &amp;lt;-- NEW PARAMETER ADDED HERE
          *@data,
         ) returns List of Pair
{
    # Handle extras...
    carp &amp;quot;Ignoring unknown named parameter &#39;$_&#39;&amp;quot; for keys %extras;

    # Remainder of subroutine as before...
    my ($sheep, $goats) is constant = @labels;
    my %herd = ($sheep=&amp;gt;[], $goats=&amp;gt;[]);
    for @data {
        when $is_sheep { push %herd{$sheep}, $_ }
        default        { push %herd{$goats}, $_ }
    }
    return *%herd;
}

# and later...

%parts = part Animal::Cat, label=&amp;gt;&amp;lt;&amp;lt;Good Bad&amp;gt;&amp;gt;, max=&amp;gt;3, @data;

# warns: &amp;quot;Ignoring unknown parameter &#39;max&#39; at future.pl, line 19&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;*%extras&lt;/code&gt; parameter is a &amp;ldquo;slurpy hash&amp;rdquo;. Just as the slurpy array parameter (&lt;code&gt;*@data&lt;/code&gt;) sucks up any additional positional arguments for which there&amp;rsquo;s no explicit parameter, a slurpy hash sucks up any named arguments that are unaccounted for. In the above example, for instance, &lt;code&gt;&amp;amp;part&lt;/code&gt; has no &lt;code&gt;$max&lt;/code&gt; parameter, so passing the named argument &lt;code&gt;max=&amp;gt;3&lt;/code&gt; would normally produce a (compile-time) exception:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Invalid named parameter (&#39;max&#39;) in call to &amp;amp;part
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, because &lt;code&gt;&amp;amp;part&lt;/code&gt; now has a slurpy hash, that extraneous named argument is simply bound to the appropriate entry of &lt;code&gt;%extras&lt;/code&gt; and (in this example) used to generate a warning.&lt;/p&gt;

&lt;p&gt;The more common use of such slurpy hashes is to capture the named arguments that are passed to an object constructor and have them automatically forwarded to the constructors of the appropriate ancestral classes. We&amp;rsquo;ll explore that technique in Exegesis 12.&lt;/p&gt;

&lt;h3 id=&#34;the-greatest-thing-since-sliced-arrays&#34;&gt;The Greatest Thing Since Sliced Arrays&lt;/h3&gt;

&lt;p&gt;So far we&amp;rsquo;ve progressively extended &lt;code&gt;&amp;amp;part&lt;/code&gt; from the first simple version that only accepted subroutines as selectors, to the most recent versions that can now also use classes, rules, or hashes to partition their data.&lt;/p&gt;

&lt;p&gt;Suppose we also wanted to allow the user to specify a list of integer indices as the selector, and thereby allow &lt;code&gt;&amp;amp;part&lt;/code&gt; to separate a slice of data from its &amp;ldquo;anti-slice&amp;rdquo;. In other words, instead of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%data{2357}  = [ @data[2,3,5,7]            ];
%data{other} = [ @data[0,1,4,6,8..@data-1] ];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we could write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%data = part [2,3,5,7], labels=&amp;gt;[&amp;quot;2357&amp;quot;,&amp;quot;other&amp;quot;], @data;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We could certainly extend &lt;code&gt;&amp;amp;part&lt;/code&gt; to do that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Selector ::= Code | Class | Rule | Hash | (Array of Int);

sub part (Selector $is_sheep,
          Str +@labels is dim(2) = &amp;lt;&amp;lt;sheep goats&amp;gt;&amp;gt;,
          *@data
         ) returns List of Pair
{
    my ($sheep, $goats) is constant = @labels;
    my %herd = ($sheep=&amp;gt;[], $goats=&amp;gt;[]);
    if $is_sheep.isa(Array of Int) {
        for @data.kv -&amp;gt; $index, $value {
            if $index == any($is_sheep) { push %herd{$sheep}, $value }
            else                        { push %herd{$goats}, $value }
        }
    }
    else {
        for @data {
            when $is_sheep { push %herd{$sheep}, $_ }
            default        { push %herd{$goats}, $_ }
        }
    }
    return *%herd;
}

# and later, if there&#39;s a prize for finishing 1st, 2nd, 3rd, or last...

%prize = part [0, 1, 2, @horses-1],
              labels =&amp;gt; &amp;lt;&amp;lt; placed  also_ran &amp;gt;&amp;gt;,
              @horses;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that this is the first time we couldn&amp;rsquo;t just add another class to the &lt;code&gt;Selector&lt;/code&gt; type and rely on the smart-match inside the &lt;code&gt;when&lt;/code&gt; to work out how to tell &amp;ldquo;sheep&amp;rdquo; from &amp;ldquo;goats&amp;rdquo;. The problem here is that when the selector is an array of integers, the &lt;em&gt;value&lt;/em&gt; of each data element no longer determines its sheepishness/goatility. It&amp;rsquo;s now the element&amp;rsquo;s &lt;em&gt;position&lt;/em&gt; (i.e. its index) that decides its fate. Since our existing smart-match compares values, not positions, the &lt;code&gt;when&lt;/code&gt; can&amp;rsquo;t pick out the right elements for us. Instead, we have to consider both the index &lt;em&gt;and&lt;/em&gt; the value of each data element.&lt;/p&gt;

&lt;p&gt;To do that we use the &lt;code&gt;@data&lt;/code&gt; array&amp;rsquo;s &lt;code&gt;.kv&lt;/code&gt; method. Just as calling the &lt;code&gt;.kv&lt;/code&gt; method on a hash returns &lt;em&gt;key&lt;/em&gt;, &lt;em&gt;value&lt;/em&gt;, &lt;em&gt;key&lt;/em&gt;, &lt;em&gt;value&lt;/em&gt;, &lt;em&gt;key&lt;/em&gt;, &lt;em&gt;value&lt;/em&gt;, etc., so too calling the &lt;code&gt;.kv&lt;/code&gt; method on an array returns &lt;em&gt;index&lt;/em&gt;, &lt;em&gt;value&lt;/em&gt;, &lt;em&gt;index&lt;/em&gt;, &lt;em&gt;value&lt;/em&gt;, &lt;em&gt;index&lt;/em&gt;, &lt;em&gt;value&lt;/em&gt;, etc. Then we just use a parameterized block as our &lt;code&gt;for&lt;/code&gt; block, specifying that it has two arguments. That causes the &lt;code&gt;for&lt;/code&gt; to grab two elements of the list its iterating (i.e. one index and one value) on each iteration.&lt;/p&gt;

&lt;p&gt;Then we simply test to see if the current index is any of those specified in &lt;code&gt;$is_sheep&lt;/code&gt;&amp;rsquo;s array and, if so, we push the corresponding value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for @data.kv -&amp;gt; $index, $value {
    if $index == any(@$is_sheep) { push %herd{$sheep}, $value }
    else                         { push %herd{$goats}, $value }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 6&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-parting-of-the-err-parts&#34;&gt;A Parting of the &amp;hellip; err &amp;hellip; Parts&lt;/h3&gt;

&lt;p&gt;That works okay, but it&amp;rsquo;s not perfect. In fact, as it&amp;rsquo;s presented above the &lt;code&gt;&amp;amp;part&lt;/code&gt; subroutine is now both an ugly solution and an inefficient one.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s ugly because &lt;code&gt;&amp;amp;part&lt;/code&gt; is now twice as long as it was before. The two branches of control-flow within it are similar in form but quite different in function. One partitions the data according to the &lt;em&gt;contents&lt;/em&gt; of a datum; the other, according to a datum&amp;rsquo;s &lt;em&gt;position&lt;/em&gt; in &lt;code&gt;@data&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s inefficient because it effectively tests the type of the selector argument twice: once (implicitly) when it&amp;rsquo;s first bound to the &lt;code&gt;$is_sheep&lt;/code&gt; parameter, and then again (explicitly) in the call to &lt;code&gt;.isa&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It would be cleaner and more maintainable to break these two nearly unrelated behaviours out into separate subroutines. And it would be more efficient if we could select between those two subroutines by testing the type of the selector only once.&lt;/p&gt;

&lt;p&gt;Of course, in Perl 6 we can do just that — with a &lt;em&gt;multisub&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;What&amp;rsquo;s a multisub? It&amp;rsquo;s a collection of related subroutines (known as &amp;ldquo;variants&amp;rdquo;), all of which have the same name but different parameter lists. When the multisub is called and passed a list of arguments, Perl 6 examines the types of the arguments, finds the variant with the same name and the most compatible parameter list, and calls that variant.&lt;/p&gt;

&lt;p&gt;By the way, you might be more familiar with the term &lt;em&gt;multimethod&lt;/em&gt;. A multisub is a multiply dispatched subroutine, in the same way that a multimethod is a multiply dispatched method. There&amp;rsquo;ll be much more about those in Exegesis 12.&lt;/p&gt;

&lt;p&gt;Multisubs provide facilities something akin to function overloading in C++. We set up several subroutines with the same logical name (because they implement the same logical action). But each takes a distinct set of argument types and does the appropriate things with those particular arguments.&lt;/p&gt;

&lt;p&gt;However, multisubs are more &amp;ldquo;intelligent&amp;rdquo; that mere overloaded subroutines. With overloaded subroutines, the compiler examines the compile-time types of the subroutine&amp;rsquo;s arguments and hard codes a call to the appropriate variant based on that information. With multisubs, the compiler takes no part in the variant selection process. Instead, the interpreter decides which variant to invoke at the time the call is actually made. It does that by examining the &lt;em&gt;run-time&lt;/em&gt; type of each argument, making use of its inheritance relationships to resolve any ambiguities.&lt;/p&gt;

&lt;p&gt;To see why a run-time decision is better, consider the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Lion is Cat {...}    # Lion inherits from Cat

multi sub feed(Cat  $c) { pat $c; my $glop = open &#39;Can&#39;; spoon_out($glop); }
multi sub feed(Lion $l) { $l.stalk($prey) and kill; }

my Cat $fluffy = Lion.new;

feed($fluffy);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Perl 6, the call to &lt;code&gt;feed&lt;/code&gt; will correctly invoke the second variant because the interpreter knows that &lt;code&gt;$fluffy&lt;/code&gt; actually contains a reference to a &lt;code&gt;Lion&lt;/code&gt; object at the time the call is made (even though the nominal type of the variable is &lt;code&gt;Cat&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;If Perl 6 multisubs worked like C++&amp;rsquo;s function overloading, the call to &lt;code&gt;feed($fluffy)&lt;/code&gt; would invoke the &lt;em&gt;first&lt;/em&gt; version of &lt;code&gt;feed&lt;/code&gt;, because all that the compiler knows for sure at compile-time is that &lt;code&gt;$fluffy&lt;/code&gt; is declared to store &lt;code&gt;Cat&lt;/code&gt; objects. That&amp;rsquo;s precisely why Perl 6 doesn&amp;rsquo;t do it that way. We prefer leave the hand-feeding of lions to other languages.&lt;/p&gt;

&lt;h4 id=&#34;many-parts&#34;&gt;Many Parts&lt;/h4&gt;

&lt;p&gt;As the above example shows, in Perl 6, multisub variants are defined by prepending the &lt;code&gt;sub&lt;/code&gt; keyword with another keyword: &lt;code&gt;multi&lt;/code&gt;. The parameters that the interpreter is going to consider when deciding which variant to call are specified to the left of a colon (&lt;code&gt;:&lt;/code&gt;), with any other parameters specified to the right. If there is no colon in the parameter list (as above), &lt;em&gt;all&lt;/em&gt; the parameters are considered when deciding which variant to invoke.&lt;/p&gt;

&lt;p&gt;We could re-factor the most recent version of &lt;code&gt;&amp;amp;part&lt;/code&gt; like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Selector ::= Code | Class | Rule | Hash;

multi sub part (Selector $is_sheep:
                Str +@labels is dim(2) = &amp;lt;&amp;lt;sheep goats&amp;gt;&amp;gt;,
                *@data
               ) returns List of Pair
{
    my ($sheep, $goats) is constant = @labels;
    my %herd = ($sheep=&amp;gt;[], $goats=&amp;gt;[]);
    for @data {
        when $is_sheep { push %herd{$sheep}, $_ }
        default        { push %herd{$goats}, $_ }
    }
    return *%herd;
}

multi sub part (Int @sheep_indices:
                Str +@labels is dim(2) = &amp;lt;&amp;lt;sheep goats&amp;gt;&amp;gt;,
                *@data
               ) returns List of Pair
{
    my ($sheep, $goats) is constant = @labels;
    my %herd = ($sheep=&amp;gt;[], $goats=&amp;gt;[]);
    for @data -&amp;gt; $index, $value {
        if $index == any(@sheep_indices) { push %herd{$sheep}, $value }
        else                             { push %herd{$goats}, $value }
    }
    return *%herd;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we create two variants of a single multisub named &lt;code&gt;&amp;amp;part&lt;/code&gt;. The first variant will be invoked whenever &lt;code&gt;&amp;amp;part&lt;/code&gt; is called with a &lt;code&gt;Selector&lt;/code&gt; object as its first argument (that is, when it is passed a &lt;code&gt;Code&lt;/code&gt; or &lt;code&gt;Class&lt;/code&gt; or &lt;code&gt;Rule&lt;/code&gt; or &lt;code&gt;Hash&lt;/code&gt; object as its selector).&lt;/p&gt;

&lt;p&gt;The second variant will be invoked only if the first argument is an &lt;code&gt;Array of Int&lt;/code&gt;. If the first argument is anything else, an exception will be thrown.&lt;/p&gt;

&lt;p&gt;Notice how similar the body of the first variant is to the earlier subroutine versions. Likewise, the body of the second variant is almost identical to the &lt;code&gt;if&lt;/code&gt; branch of the previous (subroutine) version.&lt;/p&gt;

&lt;p&gt;Notice too how the body of each variant only has to deal with the particular type of selector that its first parameter specifies. That&amp;rsquo;s because the interpreter has already determined what type of thing the first argument was when deciding which variant to call. A particular variant will only ever be called if the first argument is compatible with that variant&amp;rsquo;s first parameter.&lt;/p&gt;

&lt;h3 id=&#34;call-me-early&#34;&gt;Call Me Early&lt;/h3&gt;

&lt;p&gt;Suppose we wanted more control over the default labels that &lt;code&gt;&amp;amp;part&lt;/code&gt; uses for its return values. For example, suppose we wanted to be able to prompt the user for the appropriate defaults — before the program runs.&lt;/p&gt;

&lt;p&gt;The default value for an optional parameter can be any valid Perl expression whose result is compatible with the type of the parameter. We could simply write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my Str @def_labels;

BEGIN {
    print &amp;quot;Enter 2 default labels: &amp;quot;;
    @def_labels = split(/\s+/, &amp;lt;&amp;gt;, 3).[0..1];
}

sub part (Selector $is_sheep,
          Str +@labels is dim(2) = @def_labels,
          *@data
         ) returns List of Pair
{
    # body as before
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We first define an array variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my Str @def_labels;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will ultimately serve as the expression that the &lt;code&gt;@labels&lt;/code&gt; parameter uses as its default:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Str +@labels is dim(2) = @def_labels
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we merely need a &lt;code&gt;BEGIN&lt;/code&gt; block (so that it runs before the program starts) in which we prompt for the required information:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print &amp;quot;Enter 2 default labels: &amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;read it in:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;split the input line into three pieces using whitespace as a separator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;split(/\s+/, &amp;lt;&amp;gt;, 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;grab the first two of those pieces:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;split(/\s+/, &amp;lt;&amp;gt;, 3).[0..1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and assign them to &lt;code&gt;@def_labels&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@def_labels = split(/\s+/, &amp;lt;&amp;gt;, 3).[0..1];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;re now guaranteed that &lt;code&gt;@def_labels&lt;/code&gt; has the necessary default labels before &lt;code&gt;&amp;amp;part&lt;/code&gt; is ever called.&lt;/p&gt;

&lt;h4 id=&#34;core-breach&#34;&gt;Core Breach&lt;/h4&gt;

&lt;p&gt;Built-ins like &lt;code&gt;&amp;amp;split&lt;/code&gt; can also be given named arguments in Perl 6, so, alternatively, we could write the &lt;code&gt;BEGIN&lt;/code&gt; block like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BEGIN {
    print &amp;quot;Enter 2 default labels: &amp;quot;;
    @def_labels = split(str=&amp;gt;&amp;lt;&amp;gt;, max=&amp;gt;3).[0..1];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we&amp;rsquo;re leaving out the split pattern entirely and making use of &lt;code&gt;&amp;amp;split&lt;/code&gt;&amp;rsquo;s default split-on-whitespace behaviour.&lt;/p&gt;

&lt;p&gt;Incidentally, an important goal of Perl 6 is to make the language powerful enough to natively implement all its own built-ins. We won&amp;rsquo;t actually implement it that way, since screamingly fast performance is another goal, but we do want to make it easy for anyone to create their own versions of any Perl built-in or control structure.&lt;/p&gt;

&lt;p&gt;So, for example, &lt;code&gt;&amp;amp;split&lt;/code&gt; would be declared like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub split( Rule|Str ?$sep = /\s+/,
           Str ?$str = $CALLER::_,
           Int ?$max = Inf
          )
{
    # implementation here
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note first that every one of &lt;code&gt;&amp;amp;split&lt;/code&gt;&amp;rsquo;s parameters is optional, and that the defaults are the same as in Perl 5. If we omit the separator pattern, the default separator is whitespace; if we omit the string to be split, &lt;code&gt;&amp;amp;split&lt;/code&gt; splits the caller&amp;rsquo;s &lt;code&gt;$_&lt;/code&gt; variable; if we omit the &amp;ldquo;maximum number of pieces to return&amp;rdquo; argument, there is no upper limit on the number of splits that may be made.&lt;/p&gt;

&lt;p&gt;Note that we can&amp;rsquo;t just declare the second parameter like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Str ?$str = $_,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s because, in Perl 6, the &lt;code&gt;$_&lt;/code&gt; variable is lexical (not global), so a subroutine doesn&amp;rsquo;t have direct access to the &lt;code&gt;$_&lt;/code&gt; of its caller. That means that Perl 6 needs a special way to access a caller&amp;rsquo;s &lt;code&gt;$_&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;That special way is via the &lt;code&gt;CALLER::&lt;/code&gt; namespace. Writing &lt;code&gt;$CALLER::_&lt;/code&gt; gives us access to the &lt;code&gt;$_&lt;/code&gt; of whatever scope called the current subroutine. This works for other variables too (&lt;code&gt;$CALLER::foo&lt;/code&gt;, &lt;code&gt;@CALLER::bar&lt;/code&gt;, etc.) but is rarely useful, since we&amp;rsquo;re only allowed to use &lt;code&gt;CALLER::&lt;/code&gt; to access variables that already exist, and &lt;code&gt;$_&lt;/code&gt; is about the only variable that a subroutine can rely upon to be present in any scope it might be called from.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 6&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;a-constant-source-of-joy&#34;&gt;A Constant Source of Joy&lt;/h4&gt;

&lt;p&gt;Setting up the &lt;code&gt;@def_labels&lt;/code&gt; array at compile-time and then using it as the default for the &lt;code&gt;@labels&lt;/code&gt; parameter works fine, but there&amp;rsquo;s always the chance that the array might somehow be accidentally reassigned later. If that&amp;rsquo;s not desirable, then we need to make the array a constant. In Perl 6 that looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my @def_labels is constant = BEGIN {
    print &amp;quot;Enter 2 default labels: &amp;quot;;
    split(/\s+/, &amp;lt;&amp;gt;, 3).[0..1];
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;is constant&lt;/code&gt; trait is the way we prevent any Perl 6 variable from being reassigned after it&amp;rsquo;s been declared. It effectively replaces the &lt;code&gt;STORE&lt;/code&gt; method of the variable&amp;rsquo;s implementation with one that throws an exception whenever it&amp;rsquo;s called. It also instructs the compiler to keep an eye out for compile-time-detectable modifications to the variable and die violently if it finds any.&lt;/p&gt;

&lt;p&gt;Whenever a variable is declared &lt;code&gt;is constant&lt;/code&gt; it must be initialized as part of its declaration. In this case we use the return value of a &lt;code&gt;BEGIN&lt;/code&gt; block as the initializer value.&lt;/p&gt;

&lt;p&gt;Oh, by the way, &lt;code&gt;BEGIN&lt;/code&gt; blocks have return values in Perl 6. Specifically, they return the value of the last statement executed inside them (just like a Perl 5 &lt;code&gt;do&lt;/code&gt; or &lt;code&gt;eval&lt;/code&gt; block does, except that &lt;code&gt;BEGIN&lt;/code&gt;s do it at compile-time).&lt;/p&gt;

&lt;p&gt;In the above example the result of the &lt;code&gt;BEGIN&lt;/code&gt; is the return value of the call to &lt;code&gt;split&lt;/code&gt;. So &lt;code&gt;@def_labels&lt;/code&gt; is initialized to the two default labels, which cannot thereafter be changed.&lt;/p&gt;

&lt;h4 id=&#34;begin-at-the-scene-of-the-crime&#34;&gt;&lt;code&gt;BEGIN&lt;/code&gt; at the Scene of the Crime&lt;/h4&gt;

&lt;p&gt;Of course, the &lt;code&gt;@def_labels&lt;/code&gt; array is really just a temporary storage facility for transferring the results of the &lt;code&gt;BEGIN&lt;/code&gt; block to the default value of the &lt;code&gt;@labels&lt;/code&gt; parameter.&lt;/p&gt;

&lt;p&gt;We could easily do away with it entirely, by simply putting the &lt;code&gt;BEGIN&lt;/code&gt; block right there &lt;em&gt;in&lt;/em&gt; the parameter list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub part (Selector $is_sheep,
          Str +@labels is dim(2) = BEGIN {
                      print &amp;quot;Enter 2 default labels: &amp;quot;; 
                      split(/\s+/, &amp;lt;&amp;gt;, 3).[0..1];
                    },
          *@data
         ) returns List of Pair
{
    # body as before
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that works fine.&lt;/p&gt;

&lt;h3 id=&#34;macro-biology&#34;&gt;Macro Biology&lt;/h3&gt;

&lt;p&gt;The only problem is that it&amp;rsquo;s ugly, brutish, and not at all short. If only there were some way of calling the &lt;code&gt;BEGIN&lt;/code&gt; block at that point without having to put the actual &lt;code&gt;BEGIN&lt;/code&gt; block at that point&amp;hellip;.&lt;/p&gt;

&lt;p&gt;Well, of course there is such a way. In Perl 6 a block is just a special kind of nameless subroutine&amp;hellip; and a subroutine is just a special name-ful kind of block. So it shouldn&amp;rsquo;t really come as a surprise that &lt;code&gt;BEGIN&lt;/code&gt; blocks have a name-ful, subroutine-ish counterpart. They&amp;rsquo;re called &lt;em&gt;macros&lt;/em&gt; and they look and act very much like ordinary subroutine, except that they run at compile-time.&lt;/p&gt;

&lt;p&gt;So, for example, we could create a compile-time subroutine that requests and returns our user-specified labels:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;macro request(int $n, Str $what) returns List of Str {
    print &amp;quot;Enter $n $what: &amp;quot;;
    my @def_labels = split(/\s+/, &amp;lt;&amp;gt;, $n+1);
    return { @def_labels[0..$n-1] };
}

# and later...

sub part (Selector $is_sheep,
          Str +@labels is dim(2) = request(2,&amp;quot;default labels&amp;quot;),
          *@data
         ) returns List of Pair
{
    # body as before
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Calls to a macro are invoked during compilation (not at run-time). In fact, like a &lt;code&gt;BEGIN&lt;/code&gt; block, a macro call is executed as soon as the parser has finished parsing it. So, in the above example, when the parser has parsed the declaration of the &lt;code&gt;@labels&lt;/code&gt; parameter and then the &lt;code&gt;=&lt;/code&gt; sign indicating a default value, it comes across what looks like a subroutine call. As soon as it has parsed that subroutine call (including its argument list) it will detect that the subroutine &lt;code&gt;&amp;amp;request&lt;/code&gt; is actually a macro, so it will immediately call &lt;code&gt;&amp;amp;request&lt;/code&gt; with the specified arguments (&lt;code&gt;2&lt;/code&gt; and &lt;code&gt;&amp;quot;default labels&amp;quot;&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Whenever a macro like &lt;code&gt;&amp;amp;request&lt;/code&gt; is invoked, the parser itself intercepts the macro&amp;rsquo;s return value and integrates it somehow back into the parse tree it is in the middle of building. If the macro returns a block — as &lt;code&gt;&amp;amp;request&lt;/code&gt; does in the above example — the parser extracts the the contents of that block and inserts the parse tree of those contents into the program&amp;rsquo;s parse tree. In other words, if a macro returns a block, a precompiled version of whatever is inside the block replaces the original macro call.&lt;/p&gt;

&lt;p&gt;Alternatively, a macro can return a string. In that case, the parser inserts that string back into the source code in place of the macro call and then reparses it. This means we could also write &lt;code&gt;&amp;amp;request&lt;/code&gt; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;macro request(int $n, Str $what) returns List of Str {
    print &amp;quot;Enter $n $what: &amp;quot;;
    return &amp;quot;&amp;lt;&amp;lt; ( @(split(/\s+/, &amp;lt;&amp;gt;, $n+1).[0..$n-1]) &amp;gt;&amp;gt;&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in which case it would return a string containing the characters &lt;code&gt;&amp;quot;&amp;lt;&amp;lt;&amp;quot;&lt;/code&gt;, followed by the two labels that the &lt;code&gt;request&lt;/code&gt; call reads in, followed by a closing double angles. The parser would then substitute that string in place of the macro call, discover it was a &lt;code&gt;&amp;lt;&amp;lt;...&amp;gt;&amp;gt;&lt;/code&gt; word list, and use that list as the default labels.&lt;/p&gt;

&lt;h4 id=&#34;macros-for-begin-ners&#34;&gt;Macros for &lt;code&gt;BEGIN&lt;/code&gt;-ners&lt;/h4&gt;

&lt;p&gt;Macros are enormously powerful. In fact, in Perl 6, we could implement the functionality of &lt;code&gt;BEGIN&lt;/code&gt; itself using a macro:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;macro MY_BEGIN (&amp;amp;block) {
    my $context = want;
    if $context ~~ List {
        my @values = block();
        return { *@values };
    }
    elsif $context ~~ Scalar {
        my $value = block();
        return { $value };
    }
    else {
        block();
        return;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;MY_BEGIN&lt;/code&gt; macro declares a single parameter (&lt;code&gt;&amp;amp;block&lt;/code&gt;). Because that parameter is specified with the &lt;code&gt;Code&lt;/code&gt; sigil (&lt;code&gt;&amp;amp;&lt;/code&gt;), the macro requires that the corresponding argument must be a block or subroutine of some type. Within the body of &lt;code&gt;&amp;amp;MY_BEGIN&lt;/code&gt; that argument is bound to the &lt;em&gt;lexical&lt;/em&gt; subroutine &lt;code&gt;&amp;amp;block&lt;/code&gt; (just as a &lt;code&gt;$foo&lt;/code&gt; parameter would bind its corresponding argument to a lexical scalar variable, or a &lt;code&gt;@foo&lt;/code&gt; parameter would bind its argument to a lexical array).&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;amp;MY_BEGIN&lt;/code&gt; then calls the &lt;code&gt;want&lt;/code&gt; function, which is Perl 6&amp;rsquo;s replacement for &lt;code&gt;wantarray&lt;/code&gt;. &lt;code&gt;want&lt;/code&gt; returns a scalar value that simultaneously represents any the contexts in which the current subroutine was called. In other words, it returns a disjunction of various classes. We then compare that context information against the three possibilities — &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Scalar&lt;/code&gt;, and (by elimination) &lt;code&gt;Void&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If &lt;code&gt;MY_BEGIN&lt;/code&gt; was called in a list context, we evaluate its block/closure argument in a list context, capture the results in an array (&lt;code&gt;@values&lt;/code&gt;), and then return a block containing the contents of that array flattened back to a list. In a scalar context we do much the same thing, except that &lt;code&gt;MY_BEGIN&lt;/code&gt;&amp;rsquo;s argument is evaluated in scalar context and a block containing that scalar result is returned. In a void context (the only remaining possibility), the argument is simply evaluated and nothing is returned.&lt;/p&gt;

&lt;p&gt;In the first two cases, returning a block causes the original macro call to be replaced by a parse tree, specifically, the parse tree representing the values that resulted from executing the original block passed to &lt;code&gt;MY_BEGIN&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In the final case — a void context — the compiler isn&amp;rsquo;t expecting to replace the macro call with anything, so it doesn&amp;rsquo;t matter what we return, just as long as we evaluate the block. The macro call itself is simply eliminated from the final parse-tree.&lt;/p&gt;

&lt;p&gt;Note that &lt;code&gt;MY_BEGIN&lt;/code&gt; could be written more concisely than it was above, by taking advantage of the smart-matching behaviour of a switch statement:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;macro MY_BEGIN (&amp;amp;block) {
    given want {
        when List   { my @values = block(); return { *@values }; }
        when Scalar { my $value  = block(); return {  $value  }; }
        when Void   {              block(); return               }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;a-macro-by-any-other-syntax&#34;&gt;A Macro by Any Other Syntax &amp;hellip;&lt;/h4&gt;

&lt;p&gt;Because macros are called by the parser, it&amp;rsquo;s possible to have them interact with the parser itself. In particular, it&amp;rsquo;s possible for a macro to tell the parser how the macro&amp;rsquo;s own argument list should be parsed.&lt;/p&gt;

&lt;p&gt;For example, we could give the &lt;code&gt;&amp;amp;request&lt;/code&gt; macro its own non-standard argument syntax, so that instead of calling it as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;request(2,&amp;quot;default labels&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we could just write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;request(2 default labels)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To do that we&amp;rsquo;d define &lt;code&gt;&amp;amp;request&lt;/code&gt; like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;macro request(int $n, Str $what) 
    is parsed( /:w \( (\d+) (.*?) \) / )
    returns List of Str
{
    print &amp;quot;Enter $n $what: &amp;quot;;
    my @def_labels = split(/\s+/, &amp;lt;&amp;gt;, $n+1);
    return { @def_labels[0..$n-1] };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;is parsed&lt;/code&gt; trait tells the parser what to look for immediately after it encounters the macro&amp;rsquo;s name. In the above example, the parser is told that, after encountering the sequence &lt;code&gt;&amp;quot;request&amp;quot;&lt;/code&gt; it should expect to match the pattern:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/ :w        # Allow whitespace between the tokens
  \(        # Match an opening paren
  (\d+)     # Capture one-or-more digits
  (.*?)     # Capture everything else up to...
  \)        # ...a closing paren
/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the one-or-more-digits and the anything-up-to-paren bits of the pattern are in capturing parentheses. This is important because the list of substrings that an &lt;code&gt;is parsed&lt;/code&gt; pattern captures is then used as the argument list to the macro call. The captured digits become the first argument (which is then bound to the &lt;code&gt;$n&lt;/code&gt; parameter) and the captured &amp;ldquo;everything else&amp;rdquo; becomes the second argument (and is bound to &lt;code&gt;$what&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Normally, of course, we don&amp;rsquo;t need to specify the &lt;code&gt;is parsed&lt;/code&gt; trait when setting up a macro. Since a macro is a kind of subroutine, by default its argument list is parsed the same as any other subroutine&amp;rsquo;s — as a comma-separated list of Perl 6 expressions.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 6&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;refactoring-parameter-lists&#34;&gt;Refactoring Parameter Lists&lt;/h3&gt;

&lt;p&gt;By this stage, you might be justified in feeling that &lt;code&gt;&amp;amp;part&lt;/code&gt;&amp;rsquo;s parameter list is getting just a leeeeettle too sophisticated for its own good. Moreover, if we were using the multisub version, that complexity would have to be repeated in every variant.&lt;/p&gt;

&lt;p&gt;Philosophically though, that&amp;rsquo;s okay. The later versions of &lt;code&gt;&amp;amp;part&lt;/code&gt; are doing some fairly sophisticated things, and the complexity required to achieve that has to go somewhere. Putting that extra complexity in the parameter list means that the body of &lt;code&gt;&amp;amp;part&lt;/code&gt; stays much simpler, as do any calls to &lt;code&gt;&amp;amp;part&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s the whole point: &lt;em&gt;Complexify locally to simplify globally.&lt;/em&gt; Or maybe: &lt;em&gt;Complexify declaratively to simplify procedurally.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;But there&amp;rsquo;s precious little room for the consolations of philosophy when you&amp;rsquo;re swamped in code and up to your assembler in allomorphism. So, rather than having to maintain those complex and repetitive parameter lists, we might prefer to factor out the common infrastructure. With, of course, yet another macro:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;macro PART_PARAMS {
    my ($sheep,$goats) = request(2 default labels);
    return &amp;quot;Str +\@labels is dim(2) = &amp;lt;&amp;lt;$sheep $goats&amp;gt;&amp;gt;, *\@data&amp;quot;;
}

multi sub part (Selector $is_sheep, PART_PARAMS) {
    # body as before
}

multi sub part (Int @is_sheep, PART_PARAMS) {
    # body as before
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we create a macro named &lt;code&gt;&amp;amp;PART_PARAMS&lt;/code&gt; that requests and extracts the default labels and then interpolates them into a string, which it returns. That string then replaces the original macro call.&lt;/p&gt;

&lt;p&gt;Note that we reused the &lt;code&gt;&amp;amp;request&lt;/code&gt; macro within the &lt;code&gt;&amp;amp;PART_PARAMS&lt;/code&gt; macro. That&amp;rsquo;s important, because it means that, as the body of &lt;code&gt;&amp;amp;PART_PARAMS&lt;/code&gt; is itself being parsed, the default names are requested and interpolated into &lt;code&gt;&amp;amp;PART_PARAMS&lt;/code&gt;&amp;rsquo;s code. That ensures that the user-supplied default labels are hardwired into &lt;code&gt;&amp;amp;PART_PARAMS&lt;/code&gt; even before it&amp;rsquo;s compiled. So every subsequent call to &lt;code&gt;PART_PARAMS&lt;/code&gt; will return the same default labels.&lt;/p&gt;

&lt;p&gt;On the other hand, if we&amp;rsquo;d written &lt;code&gt;&amp;amp;PART_PARAMS&lt;/code&gt; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;macro PART_PARAMS {
    print &amp;quot;Enter 2 default labels: &amp;quot;;
    my ($sheep,$goats) = split(/\s+/, &amp;lt;&amp;gt;, 3);
    return &amp;quot;*\@data, Str +\@labels is dim(2) = &amp;lt;&amp;lt;$sheep $goats&amp;gt;&amp;gt;&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then each time we used the &lt;code&gt;&amp;amp;PART_PARAMS&lt;/code&gt; macro in our code, it would re-prompt for the labels. So we could give each variant of &lt;code&gt;&amp;amp;part&lt;/code&gt; its own default labels. Either approach is fine, depending on the effect we want to achieve. It&amp;rsquo;s really just a question how much work we&amp;rsquo;re willing to put in in order to be Lazy.&lt;/p&gt;

&lt;h3 id=&#34;smooth-operators&#34;&gt;Smooth Operators&lt;/h3&gt;

&lt;p&gt;By now it&amp;rsquo;s entirely possible that your head is spinning with the sheer number of ways Perl 6 lets us implement the &lt;code&gt;&amp;amp;part&lt;/code&gt; subroutine. Each of those ways represents a different tradeoff in power, flexibility, and maintainability of the resulting code. It&amp;rsquo;s important to remember that, however we choose to implement &lt;code&gt;&amp;amp;part&lt;/code&gt;, it&amp;rsquo;s always invoked in basically the same way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%parts = part $selector, @data;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sure, some of the above techniques let us modify the return labels, or control the use of named vs positional arguments. But with all of them, the call itself starts with the name of the subroutine, after which we specify the arguments.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s change that too!&lt;/p&gt;

&lt;p&gt;Suppose we preferred to have a partitioning &lt;em&gt;operator&lt;/em&gt;, rather than a subroutine. If we ignore those optional labels, and restrict our list to be an actual array, we can see that the core partitioning operation is binary (&amp;ldquo;apply this selector to that array&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;If &lt;code&gt;&amp;amp;part&lt;/code&gt; is to become an operator, we need it to be a binary operator. In Perl 6 we can make up completely new operators, so let&amp;rsquo;s take our partitioning inspiration from Moses and call our new operator: &lt;code&gt;~|_|~&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll assume that this &amp;ldquo;Red Sea&amp;rdquo; operator is to be used like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%parts = @animals ~|_|~ Animal::Cat;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The left operand is the array to be partitioned and the right operand is the selector. To implement it, we&amp;rsquo;d write;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;multi sub infix:~|_|~ (@data, Selector $is_sheep)
    is looser(&amp;amp;infix:+)
    is assoc(&#39;non&#39;)
{
    return part $is_sheep, @data;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Operators are often overloaded with multiple variants (as we&amp;rsquo;ll soon see), so we typically implement them as multisubs. However, it&amp;rsquo;s also perfectly possible to implement them as regular subroutines, or even as macros.&lt;/p&gt;

&lt;p&gt;To distinguish a binary operator from a regular multisub, we give it a special compound name, composed of the keyword &lt;code&gt;infix:&lt;/code&gt; followed by the characters that make up the operator&amp;rsquo;s symbol. These characters can be any sequence of non-whitespace Unicode characters (except left parenthesis, which can only appear if it&amp;rsquo;s the first character of the symbol). So instead of &lt;code&gt;~|_|~&lt;/code&gt; we could equally well have named our partitioning operator any of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;infix:¥
infix:¦
infix:^%#$!
infix:&amp;lt;-&amp;gt;
infix:∇
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;infix:&lt;/code&gt; keyword tells the compiler that the operator is placed between its operands (as binary operators always are). If we&amp;rsquo;re declaring a unary operator, there are three other keywords that can be used instead: &lt;code&gt;prefix:&lt;/code&gt;, &lt;code&gt;postfix:&lt;/code&gt;, or &lt;code&gt;circumfix:&lt;/code&gt;. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub prefix:±       (Num $n) is equiv(&amp;amp;infix:+)    { return +$n|-$n }

sub postfix:²      (Num $n) is tighter(&amp;amp;infix:**) { return $n**2 }

sub circumfix:⌊...⌋ (Num $n) { return POSIX::floor($n) }

# and later...

$error = ±⌊$x²⌋;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;is tighter&lt;/code&gt;, &lt;code&gt;is looser&lt;/code&gt;, and &lt;code&gt;is equiv&lt;/code&gt; traits tell the parser what the precedence of the new operator will be, relative to existing operators: namely, whether the operator binds more tightly than, less tightly than, or with the same precedence as the operator named in the trait. Every operator has to have a precedence and associativity, so every operator definition has to include one of these three traits.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;is assoc&lt;/code&gt; trait is only required on infix operators and specifies whether they chain to the left (like &lt;code&gt;+&lt;/code&gt;), to the right (like &lt;code&gt;=&lt;/code&gt;), or not at all (like &lt;code&gt;..&lt;/code&gt;). If the trait is not specified, the operator takes its associativity from the operator that&amp;rsquo;s specified in the &lt;code&gt;is tighter&lt;/code&gt;, &lt;code&gt;is looser&lt;/code&gt;, or &lt;code&gt;is equiv&lt;/code&gt; trait.&lt;/p&gt;

&lt;h4 id=&#34;arguments-both-ways&#34;&gt;Arguments Both Ways&lt;/h4&gt;

&lt;p&gt;On the other hand, we might prefer that the selector come first (as it does in &lt;code&gt;&amp;amp;part&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%parts = Animal::Cat ~|_|~ @animals;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in which case we could just add:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;multi sub infix:~|_|~ (Selector $is_sheep, @data)
    is equiv( &amp;amp;infix:~|_|~(Array,Selector) )
{
    return part $is_sheep, @data;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;so now we can specify the selector and the data in &lt;em&gt;either&lt;/em&gt; order.&lt;/p&gt;

&lt;p&gt;Because the two variants of the &lt;code&gt;&amp;amp;infix:~|_|~&lt;/code&gt; multisubs have different parameter lists (one is &lt;code&gt;(Array,Selector)&lt;/code&gt;, the other is &lt;code&gt;(Selector, Array)&lt;/code&gt;, Perl 6 always knows which one to call. If the left operand is a &lt;code&gt;Selector&lt;/code&gt;, the &lt;code&gt;&amp;amp;infix:~|_|~(Selector,Array)&lt;/code&gt; variant is called. If the left operand is an array, the &lt;code&gt;&amp;amp;infix:~|_|~(Array,Selector)&lt;/code&gt; variant is invoked.&lt;/p&gt;

&lt;p&gt;Note that, for this second variant, we specified &lt;code&gt;is equiv&lt;/code&gt; instead of &lt;code&gt;is tighter&lt;/code&gt; or &lt;code&gt;is looser&lt;/code&gt;. This ensures that the precedence and associativity of the second variant are the same as those of the first. That&amp;rsquo;s also why we didn&amp;rsquo;t need to specify an &lt;code&gt;is assoc&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;parting-is-such-sweet-sorrow&#34;&gt;Parting Is Such Sweet Sorrow&lt;/h3&gt;

&lt;p&gt;Phew. Talk about &amp;ldquo;more than one way to do it&amp;rdquo;!&lt;/p&gt;

&lt;p&gt;But don&amp;rsquo;t be put off by these myriad new features and alternatives. The vast majority of them are special-purpose, power-user techniques that you may well never need to use or even know about.&lt;/p&gt;

&lt;p&gt;For most of us it will be enough to know that we can now add a proper parameter list, with sensibly named parameters, to any subroutine. What we used to write as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub feed {
    my ($who, $how_much, @what) = @_;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we now write as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub feed ($who, $how_much, *@what) {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or, when we&amp;rsquo;re feeling particularly cautious:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub feed (Str $who, Num $how_much, Food *@what) {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just being able to do that is a huge win for Perl 6.&lt;/p&gt;

&lt;h3 id=&#34;parting-shot&#34;&gt;Parting Shot&lt;/h3&gt;

&lt;p&gt;By the way, here&amp;rsquo;s (most of) that same partitioning functionality implemented in Perl 5:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Perl 5 code...
sub part {
    my ($is_sheep, $maybe_flag_or_labels, $maybe_labels, @data) = @_;
    my ($sheep, $goats);
    if ($maybe_flag_or_labels eq &amp;quot;labels&amp;quot; &amp;amp;&amp;amp; ref $maybe_labels eq &#39;ARRAY&#39;) { 
        ($sheep, $goats) = @$maybe_labels;
    }
    elsif (ref $maybe_flag_or_labels eq &#39;ARRAY&#39;) {
        unshift @data, $maybe_labels;
        ($sheep, $goats) = @$maybe_flag_or_labels;
    }
    else {
        unshift @data, $maybe_flag_or_labels, $maybe_labels;
        ($sheep, $goats) = qw(sheep goats);
    }
    my $arg1_type = ref($is_sheep) || &#39;CLASS&#39;;
    my %herd;
    if ($arg1_type eq &#39;ARRAY&#39;) {
        for my $index (0..$#data) {
            my $datum = $data[$index];
            my $label = grep({$index==$_} @$is_sheep) ? $sheep : $goats;
            push @{$herd{$label}}, $datum;
        }
    }
    else {
        croak &amp;quot;Invalid first argument to &amp;amp;part&amp;quot;
            unless $arg1_type =~ /^(Regexp|CODE|HASH|CLASS)$/;
        for (@data) {
            if (  $arg1_type eq &#39;Regexp&#39; &amp;amp;&amp;amp; /$is_sheep/
               || $arg1_type eq &#39;CODE&#39;   &amp;amp;&amp;amp; $is_sheep-&amp;gt;($_)
               || $arg1_type eq &#39;HASH&#39;   &amp;amp;&amp;amp; $is_sheep-&amp;gt;{$_}
               || UNIVERSAL::isa($_,$is_sheep)
               ) {
                push @{$herd{$sheep}}, $_;
            }
            else {
                push @{$herd{$goats}}, $_;
            }
        }
    }
    return map {bless {key=&amp;gt;$_,value=&amp;gt;$herd{$_}},&#39;Pair&#39;} keys %herd;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; which is &lt;em&gt;precisely&lt;/em&gt; why we&amp;rsquo;re developing Perl 6.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Synopsis 6</title>
      <link>http://localhost:1313/pub/2003/04/09/synopsis.html/</link>
      <pubDate>Wed, 09 Apr 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/04/09/synopsis.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 6&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This document summarizes Apocalypse 6, which covers subroutines and the new type system.&lt;/p&gt;

&lt;h3 id=&#34;span-id-subroutines-and-other-code-objects-subroutines-and-other-code-objects-span&#34;&gt;&lt;span id=&#34;subroutines_and_other_code_objects&#34;&gt;Subroutines and Other Code Objects&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Subroutines&lt;/strong&gt; (keyword: &lt;code&gt;sub&lt;/code&gt;) are noninheritable routines with parameter lists.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Methods&lt;/strong&gt; (keyword: &lt;code&gt;method&lt;/code&gt;) are inheritable routines that always have an associated object (known as their invocant) and belong to a particular class.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Submethods&lt;/strong&gt; (keyword: &lt;code&gt;submethod&lt;/code&gt;) are noninheritable methods, or subroutines masquerading as methods. They have an invocant and belong to a particular class.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Multimethods&lt;/strong&gt; (keyword: &lt;code&gt;multi&lt;/code&gt;) are routines that do not belong to a particular class, but which have one or more invocants.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rules&lt;/strong&gt; (keyword: &lt;code&gt;rule&lt;/code&gt;) are methods (of a grammar) that perform pattern matching. Their associated block has a special syntax (see Synopsis 5).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Macros&lt;/strong&gt; (keyword: &lt;code&gt;macro&lt;/code&gt;) are routines whose calls execute as soon as they are parsed (i.e. at compile-time). Macros may return another source code string or a parse-tree.&lt;/p&gt;

&lt;h4 id=&#34;span-id-standard-subroutines-standard-subroutines-span&#34;&gt;&lt;span id=&#34;standard_subroutines&#34;&gt;Standard Subroutines&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The general syntax for named subroutines is any of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     my RETTYPE sub NAME ( PARAMS ) TRAITS {...}
    our RETTYPE sub NAME ( PARAMS ) TRAITS {...}
                sub NAME ( PARAMS ) TRAITS {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The general syntax for anonymous subroutines is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub ( PARAMS ) TRAITS {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;ldquo;Trait&amp;rdquo; is the new name for a compile-time (&lt;code&gt;is&lt;/code&gt;) property. See &lt;a href=&#34;#traits_and_properties&#34;&gt;Traits and Properties&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-perl5ish-subroutine-declarations-perl5ish-subroutine-declarations-span&#34;&gt;&lt;span id=&#34;perl5ish_subroutine_declarations&#34;&gt;Perl5ish Subroutine Declarations&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;You can still declare a sub without parameter list, as in Perl 5:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Arguments still come in via the &lt;code&gt;@_&lt;/code&gt; array, but they are &lt;strong&gt;constant&lt;/strong&gt; aliases to actual arguments:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub say { print qq{&amp;quot;@_&amp;quot;\n}; }   # args appear in @_

    sub cap { $_ = uc $_ for @_ }   # Error: elements of @_ are constant
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you need to modify the elements of &lt;code&gt;@_&lt;/code&gt;, then declare it with the &lt;a href=&#34;#item_is_rw&#34;&gt;&lt;code&gt;is rw&lt;/code&gt;&lt;/a&gt; trait:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub swap (*@_ is rw) { @_[0,1] = @_[1,0] }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-blocks-blocks-span&#34;&gt;&lt;span id=&#34;blocks&#34;&gt;Blocks&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Raw blocks are also executable code structures in Perl 6.&lt;/p&gt;

&lt;p&gt;Every block defines a subroutine, which may either be executed immediately or passed in as a &lt;code&gt;Code&lt;/code&gt; reference argument to some other subroutine.&lt;/p&gt;

&lt;h4 id=&#34;span-id-pointy-subs-pointy-subs-span&#34;&gt;&lt;span id=&#34;pointy_subs&#34;&gt;&amp;ldquo;Pointy subs&amp;rdquo;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The arrow operator &lt;code&gt;-&amp;gt;&lt;/code&gt; is almost a synonym for the anonymous &lt;code&gt;sub&lt;/code&gt; keyword. The parameter list of a pointy sub does not require parentheses and a pointy sub may not be given traits.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $sq = -&amp;gt; $val { $val**2 };  # Same as: $sq = sub ($val) { $val**2 };

    for @list -&amp;gt; $elem {        # Same as: for @list, sub ($elem) {
        print &amp;quot;$elem\n&amp;quot;;        #              print &amp;quot;$elem\n&amp;quot;;
    }                           #          }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-stub-declarations-stub-declarations-span&#34;&gt;&lt;span id=&#34;stub_declarations&#34;&gt;Stub Declarations&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;To predeclare a subroutine without actually defining it, use a &amp;ldquo;stub block&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo {...};     # Yes, those three dots are part of the actual syntax
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The old Perl 5 form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is a compile-time error in Perl 6 (for reasons explained in Apocalypse 6).&lt;/p&gt;

&lt;h4 id=&#34;span-id-globally-scoped-subroutines-globally-scoped-subroutines-span&#34;&gt;&lt;span id=&#34;globally_scoped_subroutines&#34;&gt;Globally Scoped Subroutines&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Subroutines and variables can be declared in the global namespace, and are thereafter visible everywhere in a program.&lt;/p&gt;

&lt;p&gt;Global subroutines and variables are normally referred to by prefixing their identifier with &lt;code&gt;*&lt;/code&gt;, but it may be omitted if the reference is unambiguous:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $*next_id = 0;
    sub *saith($text)  { print &amp;quot;Yea verily, $text&amp;quot; }

    module A {
        my $next_id = 2;    # hides any global or package $next_id
        saith($next_id);    # print the lexical $next_id;
        saith($*next_id);   # print the global $next_id;
    }

    module B {
        saith($next_id);    # Unambiguously the global $next_id
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-lvalue-subroutines-lvalue-subroutines-span&#34;&gt;&lt;span id=&#34;lvalue_subroutines&#34;&gt;Lvalue Subroutines&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Lvalue subroutines return a &amp;ldquo;proxy&amp;rdquo; object that can be assigned to. It&amp;rsquo;s known as a proxy because the object usually represents the purpose or outcome of the subroutine call.&lt;/p&gt;

&lt;p&gt;Subroutines are specified as being lvalue using the &lt;a href=&#34;#item_is_rw&#34;&gt;&lt;code&gt;is rw&lt;/code&gt;&lt;/a&gt; trait.&lt;/p&gt;

&lt;p&gt;An lvalue subroutine may return a variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $lastval;
    sub lastval () is rw { return $lastval }

or the result of some nested call to an lvalue subroutine:

    sub prevval () is rw { return lastval() }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or a specially tied proxy object, with suitably programmed &lt;code&gt;FETCH&lt;/code&gt; and &lt;code&gt;STORE&lt;/code&gt; methods:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub checklastval ($passwd) is rw {
        my $proxy is Proxy(
                FETCH =&amp;gt; sub ($self) {
                            return lastval();
                         },
                STORE =&amp;gt; sub ($self, $val) {
                            die unless check($passwd);
                            lastval() = $val;
                         },
        );
        return $proxy;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-operator-overloading-operator-overloading-span&#34;&gt;&lt;span id=&#34;operator_overloading&#34;&gt;Operator Overloading&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Operators are just subroutines with special names.&lt;/p&gt;

&lt;p&gt;Unary operators are defined as prefix or postfix:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub prefix:OPNAME  ($operand) {...}
    sub postfix:OPNAME ($operand) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Binary operators are defined as infix:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub infix:OPNAME ($leftop, $rightop) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bracketing operators are defined as circumfix. The leading and trailing delimiters together are the name of the operator.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub circumfix:LEFTDELIM...RIGHTDELIM ($contents) {...}
    sub circumfix:DELIMITERS ($contents) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the left and right delimiters aren&amp;rsquo;t separated by &amp;ldquo;&lt;code&gt;...&lt;/code&gt;&amp;rdquo;, then the &lt;code&gt;DELIMITERS&lt;/code&gt; string must have an even number of characters. The first half is treated as the opening delimiter and the second half as the closing.&lt;/p&gt;

&lt;p&gt;Operator names can be any sequence of Unicode characters. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub infix:(c)        ($text, $owner) { return $text but Copyright($owner) }
    method prefix:± (Num $x) returns Num { return +$x | -$x }
    multi postfix:!             (Int $n) { $n&amp;lt;2 ?? 1 :: $n*($n-1)! }
    macro circumfix:&amp;lt;!--...--&amp;gt;   ($text) { &amp;quot;&amp;quot; }

    my $document = $text (c) $me;

    my $tolerance = ±7!;

    &amp;lt;!-- This is now a comment --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-parameters-and-arguments-parameters-and-arguments-span&#34;&gt;&lt;span id=&#34;parameters_and_arguments&#34;&gt;Parameters and Arguments&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Perl 6 subroutines may be declared with parameter lists.&lt;/p&gt;

&lt;p&gt;By default, all parameters are constant aliases to their corresponding arguments &amp;ndash; the parameter is just another name for the original argument, but the argument can&amp;rsquo;t be modified through it. To allow modification, use the &lt;a href=&#34;#item_is_rw&#34;&gt;&lt;code&gt;is rw&lt;/code&gt;&lt;/a&gt; trait. To pass-by-copy, use the &lt;a href=&#34;#item_is_copy&#34;&gt;&lt;code&gt;is copy&lt;/code&gt;&lt;/a&gt; trait.&lt;/p&gt;

&lt;p&gt;Parameters may be required or optional. They may be passed by position, or by name. Individual parameters may confer a scalar or list context on their corresponding arguments.&lt;/p&gt;

&lt;p&gt;Arguments destined for required parameters must come before those bound to optional parameters. Arguments destined for positional parameters must come before those bound to named parameters.&lt;/p&gt;

&lt;h4 id=&#34;span-id-invocant-parameters-invocant-parameters-span&#34;&gt;&lt;span id=&#34;invocant_parameters&#34;&gt;Invocant Parameters&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;A method invocant is specified as the first parameter in the parameter list, with a colon (rather than a comma) immediately after it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method get_name ($self:) {...}
    method set_name ($me: $newname) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The corresponding argument (the invocant) is evaluated in scalar context and is passed as the left operand of the method call operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print $obj.get_name();
    $obj.set_name(&amp;quot;Sam&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Multimethod invocants are specified at the start of the parameter list, with a colon terminating the list of invocants:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi handle_event ($window, $event: $mode) {...}    # two invocants
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Multimethod invocant arguments are passed positionally, though the first invocant can be passed via the method call syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Multimethod calls...
    handle_event($w, $e, $m);
    $w.handle_event($e, $m);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Invocants may also be passed using the indirect object syntax, with a colon after them. The colon is just a special form of the comma, and has the same precedence:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Indirect method call...
    set_name $obj: &amp;quot;Sam&amp;quot;;

    # Indirect multimethod call...
    handle_event $w, $e: $m;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Passing too many or too few invocants is a fatal error.&lt;/p&gt;

&lt;p&gt;The first invocant is always the topic of the corresponding method or multimethod.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 6&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-required-parameters-required-parameters-span&#34;&gt;&lt;span id=&#34;required_parameters&#34;&gt;Required Parameters&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Required parameters are specified at the start of a subroutine&amp;rsquo;s parameter list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub numcmp ($x, $y) { return $x &amp;lt;=&amp;gt; $y }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The corresponding arguments are evaluated in scalar context and may be passed positionally or by name. To pass an argument by name, specify it as a pair: &lt;code&gt;parameter_name =&amp;gt; argument_value&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $comparison = numcmp(2,7);
    $comparison = numcmp(x=&amp;gt;2, y=&amp;gt;7);
    $comparison = numcmp(y=&amp;gt;7, x=&amp;gt;2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Passing the wrong number of required arguments is a fatal error.&lt;/p&gt;

&lt;p&gt;The number of required parameters a subroutine has can be determined by calling its &lt;code&gt;.arity&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $args_required = &amp;amp;foo.arity;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-optional-parameters-optional-parameters-span&#34;&gt;&lt;span id=&#34;optional_parameters&#34;&gt;Optional Parameters&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Optional positional parameters are specified after all the required parameters and each is marked with a &lt;code&gt;?&lt;/code&gt; before the parameter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub my_substr ($str, ?$from, ?$len) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;=&lt;/code&gt; sign introduces a default value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub my_substr ($str, ?$from = 0, ?$len = Inf) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Default values can be calculated at run-time. They can even use the values of preceding parameters:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub xml_tag ($tag, ?$endtag = matching_tag($tag) ) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Arguments that correspond to optional parameters are evaluated in scalar context. They can be omitted, passed positionally, or passed by name:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my_substr(&amp;quot;foobar&amp;quot;);            # $from is 0, $len is infinite
    my_substr(&amp;quot;foobar&amp;quot;,1);          # $from is 1, $len is infinite
    my_substr(&amp;quot;foobar&amp;quot;,1,3);        # $from is 1, $len is 3
    my_substr(&amp;quot;foobar&amp;quot;,len=&amp;gt;3);     # $from is 0, $len is 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Missing optional arguments default to their default value, or to &lt;code&gt;undef&lt;/code&gt; if they have no default.&lt;/p&gt;

&lt;h4 id=&#34;span-id-named-parameters-named-parameters-span&#34;&gt;&lt;span id=&#34;named_parameters&#34;&gt;Named Parameters&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Named parameters follow any required or optional parameters in the signature. They are marked by a &lt;code&gt;+&lt;/code&gt; before the parameter.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub formalize($text, +$case, +$justify) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Arguments that correspond to named parameters are evaluated in scalar context. They can only be passed by name, so it doesn&amp;rsquo;t matter what order you pass them in, so long as they follow any positional arguments:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $formal = formalize($title, case=&amp;gt;&#39;upper&#39;);
    $formal = formalize($title, justify=&amp;gt;&#39;left&#39;);
    $formal = formalize($title, justify=&amp;gt;&#39;right&#39;, case=&amp;gt;&#39;title&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Named parameters are always optional. Default values for named parameters are defined in the same way as for optional parameters. Named parameters default to &lt;code&gt;undef&lt;/code&gt; if they have no default.&lt;/p&gt;

&lt;h4 id=&#34;span-id-list-parameters-list-parameters-span&#34;&gt;&lt;span id=&#34;list_parameters&#34;&gt;List Parameters&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;List parameters capture a variable length list of data. They&amp;rsquo;re used in subroutines like &lt;code&gt;print&lt;/code&gt;, where the number of arguments needs to be flexible. They&amp;rsquo;re also called &amp;ldquo;variadic parameters,&amp;rdquo; because they take a &lt;em&gt;variable&lt;/em&gt; number of arguments.&lt;/p&gt;

&lt;p&gt;Variadic parameters follow any required or optional parameters. They are marked by a &lt;code&gt;*&lt;/code&gt; before the parameter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub duplicate($n, *@data, *%flag) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Named variadic arguments are bound to the variadic hash (&lt;code&gt;*%flag&lt;/code&gt; in the above example). Such arguments are evaluated in scalar context. Any remaining variadic arguments at the end of the argument list are bound to the variadic array (&lt;code&gt;*@data&lt;/code&gt; above) and are evaluated in list context.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    duplicate(3, reverse=&amp;gt;1, collate=&amp;gt;0, 2, 3, 5, 7, 11, 14);

    # The @data parameter receives [2, 3, 5, 7, 11, 14]
    # The %flag parameter receives { reverse=&amp;gt;1, collate=&amp;gt;0 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Variadic scalar parameters capture what would otherwise be the first elements of the variadic array:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub head(*$head, *@tail)         { return $head }
    sub neck(*$head, *$neck, *@tail) { return $neck }
    sub tail(*$head, *@tail)         { return @tail }

    head(1, 2, 3, 4, 5);        # $head parameter receives 1
                                # @tail parameter receives [2, 3, 4, 5]

    neck(1, 2, 3, 4, 5);        # $head parameter receives 1
                                # $neck parameter receives 2
                                # @tail parameter receives [3, 4, 5]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Variadic scalars still impose list context on their arguments.&lt;/p&gt;

&lt;p&gt;Variadic parameters are treated lazily &amp;ndash; the list is only flattened into an array when individual elements are actually accessed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        @fromtwo = tail(1..Inf);        # @fromtwo contains a lazy [2..Inf]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-flattening-argument-lists-flattening-argument-lists-span&#34;&gt;&lt;span id=&#34;flattening_argument_lists&#34;&gt;Flattening Argument Lists&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The unary prefix operator &lt;code&gt;*&lt;/code&gt; flattens its operand (which allows the elements of an array to be used as an argument list). The &lt;code&gt;*&lt;/code&gt; operator also causes its operand &amp;ndash; and any subsequent arguments in the argument list &amp;ndash; to be evaluated in list context.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo($x, $y, $z) {...}    # expects three scalars
    @onetothree = 1..3;          # array stores three scalars

    foo(1,2,3);                  # okay:  three args found
    foo(@onetothree);            # error: only one arg
    foo(*@onetothree);           # okay:  @onetothree flattened to three args
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;*&lt;/code&gt; operator flattens lazily &amp;ndash; the array is only flattened if flattening is actually required within the subroutine. To flatten before the list is even passed into the subroutine, use the unary prefix &lt;code&gt;**&lt;/code&gt; operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    foo(**@onetothree);          # array flattened before &amp;amp;foo called
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-pipe-operators-pipe-operators-span&#34;&gt;&lt;span id=&#34;pipe_operators&#34;&gt;Pipe Operators&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The variadic array of a subroutine call can be passed in separately from the normal argument list, by using either of the &amp;ldquo;pipe&amp;rdquo; operators: &lt;code&gt;&amp;lt;==&lt;/code&gt; or &lt;code&gt;==&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Each operator expects to find a call to a variadic subroutine on its &amp;ldquo;sharp&amp;rdquo; end, and a list of values on its &amp;ldquo;blunt&amp;rdquo; end:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    grep { $_ % 2 } &amp;lt;== @data;

    @data ==&amp;gt; grep { $_ % 2 };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, it flattens the list of values on the blunt side. Then, it binds that flattened list to the variadic &lt;code&gt;parameter(s)&lt;/code&gt; of the subroutine on the sharp side. So both of the calls above are equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    grep { $_ % 2 } *@data;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Leftward pipes are a convenient way of explicitly indicating the typical right-to-left flow of data through a chain of operations:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @oddsquares = map { $_**2 } sort grep { $_ % 2 } @nums;

    # more clearly written as...

    @oddsquares = map { $_**2 } &amp;lt;== sort &amp;lt;== grep { $_ % 2 } &amp;lt;== @nums;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rightward pipes are a convenient way of reversing the normal data flow in a chain of operations, to make it read left-to-right:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @oddsquares =
            @nums ==&amp;gt; grep { $_ % 2 } ==&amp;gt; sort ==&amp;gt; map { $_**2 };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the operand on the sharp end of a pipe is not a call to a variadic operation, then it must be a variable, in which case the list operand is assigned to the variable. This special case allows for &amp;ldquo;pure&amp;rdquo; processing chains:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @oddsquares &amp;lt;== map { $_**2 } &amp;lt;== sort &amp;lt;== grep { $_ % 2 } &amp;lt;== @nums;

    @nums ==&amp;gt; grep { $_ % 2 } ==&amp;gt; sort ==&amp;gt; map { $_**2 } ==&amp;gt; @oddsquares;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-closure-parameters-closure-parameters-span&#34;&gt;&lt;span id=&#34;closure_parameters&#34;&gt;Closure Parameters&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Parameters declared with the &lt;code&gt;&amp;amp;&lt;/code&gt; sigil take blocks, closures, or subroutines as their arguments. Closure parameters can be required, optional, or named.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub limited_grep (Int $count, &amp;amp;block, *@list) {...}

    # and later...

    @first_three = limited_grep 3 {$_&amp;lt;10} @data;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Within the subroutine, the closure parameter can be used like any other lexically scoped subroutine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub limited_grep (Int $count, &amp;amp;block, *@list) {
        ...
        if block($nextelem) {...}
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The closure parameter can have its own signature (from which the parameter names may be omitted):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub limited_Dog_grep ($count, &amp;amp;block(Dog), Dog *@list) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and even a return type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub limited_Dog_grep ($count, &amp;amp;block(Dog) returns Bool, Dog *@list) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When an argument is passed to a closure parameter that has this kind of signature, the argument must be a &lt;code&gt;Code&lt;/code&gt; object with a compatible parameter list and return type.&lt;/p&gt;

&lt;h4 id=&#34;span-id-unpacking-array-parameters-unpacking-array-parameters-span&#34;&gt;&lt;span id=&#34;unpacking_array_parameters&#34;&gt;Unpacking Array Parameters&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Instead of specifying an array parameter as an array:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub quicksort (@data, ?$reverse, ?$inplace) {
        my $pivot := shift @data;
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it may be broken up into components in the signature, by specifying the parameter as if it were an anonymous array of parameters:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub quicksort ([$pivot, *@data], ?$reverse, ?$inplace) {
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This subroutine still expects an array as its first argument, just like the first version.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 6&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-attributive-parameters-attributive-parameters-span&#34;&gt;&lt;span id=&#34;attributive_parameters&#34;&gt;Attributive parameters&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;If a method&amp;rsquo;s parameter is declared with a &lt;code&gt;.&lt;/code&gt; after the sigil (like an attribute):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method initialize($.name, $.age) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then the argument is assigned directly to the object&amp;rsquo;s attribute of the same name. This avoids the frequent need to write code like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method initialize($name, $age) {
        $.name = $name;
        $.age  = $age;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-placeholder-variables-placeholder-variables-span&#34;&gt;&lt;span id=&#34;placeholder_variables&#34;&gt;Placeholder Variables&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Even though every bare block is a closure, bare blocks can&amp;rsquo;t have explicit parameter lists. Instead, they use &amp;ldquo;placeholder&amp;rdquo; variables, marked by a caret (&lt;code&gt;^&lt;/code&gt;) after their sigils.&lt;/p&gt;

&lt;p&gt;Using placeholders in a block defines an implicit parameter list. The signature is the list of distinct placeholder names, sorted in Unicode order. So:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    { $^y &amp;lt; $^z &amp;amp;&amp;amp; $^x != 2 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is a shorthand for:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub ($x,$y,$z) { $y &amp;lt; $z &amp;amp;&amp;amp; $x != 2 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-types-types-span&#34;&gt;&lt;span id=&#34;types&#34;&gt;Types&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;These are the standard type names in Perl 6 (at least this week):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    bit         single native bit
    int         native integer
    str         native string
    num         native floating point
    ref         native pointer 
    bool        native boolean
    Bit         Perl single bit (allows traits, aliasing, etc.)
    Int         Perl integer (allows traits, aliasing, etc.)
    Str         Perl string
    Num         Perl number
    Ref         Perl reference
    Bool        Perl boolean
    Array       Perl array
    Hash        Perl hash
    IO          Perl filehandle
    Code        Base class for all executable objects
    Routine     Base class for all nameable executable objects
    Sub         Perl subroutine
    Method      Perl method
    Submethod   Perl subroutine acting like a method
    Macro       Perl compile-time subroutine
    Rule        Perl pattern
    Block       Base class for all unnameable executable objects
    Bare        Basic Perl block
    Parametric  Basic Perl block with placeholder parameters
    Package     Perl 5 compatible namespace
    Module      Perl 6 standard namespace
    Class       Perl 6 standard class namespace
    Object      Perl 6 object
    Grammar     Perl 6 pattern matching namespace
    List        Perl list
    Lazy        Lazily evaluated Perl list
    Eager       Non-lazily evaluated Perl list
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-value-types-value-types-span&#34;&gt;&lt;span id=&#34;value_types&#34;&gt;Value Types&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Explicit types are optional. Perl variables have two associated types: their &amp;ldquo;value type&amp;rdquo; and their &amp;ldquo;variable type&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;The value type specifies what kinds of values may be stored in the variable. A value type is given as a prefix or with the &lt;code&gt;returns&lt;/code&gt; or &lt;code&gt;of&lt;/code&gt; keywords:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Dog $spot;
    my $spot returns $dog;
    my $spot of Dog;

    our Animal sub get_pet() {...}
    sub get_pet() returns Animal {...}
    sub get_pet() of Animal {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A value type on an array or hash specifies the type stored by each element:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Dog @pound;  # each element of the array stores a Dog

    my Rat %ship;   # the value of each entry stores a Rat
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-variable-types-variable-types-span&#34;&gt;&lt;span id=&#34;variable_types&#34;&gt;Variable Types&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The variable type specifies how the variable itself is implemented. It is given as a trait of the variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $spot is Scalar;             # this is the default
    my $spot is PersistentScalar;
    my $spot is DataBase;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Defining a variable type is the Perl 6 equivalent to tying a variable in Perl 5.&lt;/p&gt;

&lt;h4 id=&#34;span-id-hierarchical-types-hierarchical-types-span&#34;&gt;&lt;span id=&#34;hierarchical_types&#34;&gt;Hierarchical Types&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;A nonscalar type may be qualified, in order to specify what type of value each of its elements stores:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Egg $cup;                       # the value is an Egg
    my Egg @carton;                    # each elem is an Egg
    my Array of Egg @box;              # each elem is an array of Eggs
    my Array of Array of Egg @crate;   # each elem is an array of arrays of Eggs
    my Hash of Array of Recipe %book;  # each value is a hash of arrays of Recipes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each successive &lt;code&gt;of&lt;/code&gt; makes the type on its right a parameter of the type on its left. So:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Hash of Array of Recipe %book;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;means:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Hash(returns=&amp;gt;Array(returns=&amp;gt;Recipe)) %book;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because the actual variable can be hard to find when complex types are specified, there is a postfix form as well:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Hash of Array of Recipe %book;           # HoHoAoRecipe
    my %book of Hash of Array of Recipe;        # same thing
    my %book returns Hash of Array of Recipe;   # same thing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;returns&lt;/code&gt; form is more commonly seen in subroutines:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Hash of Array of Recipe sub get_book () {...}
    my sub get_book () of Hash of Array of Recipe {...}
    my sub get_book returns Hash of Array of Recipe {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-junctive-types-junctive-types-span&#34;&gt;&lt;span id=&#34;junctive_types&#34;&gt;Junctive Types&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Anywhere you can use a single type you can use a junction of types:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Int|Str $error = $val;              # can assign if $val~~Int or $val~~Str

    if $shimmer.isa(Wax &amp;amp; Topping) {...}   # $shimmer must inherit from both
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-parameter-types-parameter-types-span&#34;&gt;&lt;span id=&#34;parameter_types&#34;&gt;Parameter Types&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Parameters may be given types, just like any other variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub max (int @array is rw) {...}
    sub max (@array of int is rw) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-return-types-return-types-span&#34;&gt;&lt;span id=&#34;return_types&#34;&gt;Return Types&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;On a scoped subroutine, a return type can be specified before or after the name:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    our Egg sub lay {...}
    our sub lay returns Egg {...}

    my Rabbit sub hat {...}
    my sub hat returns Rabbit {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If a subroutine is not explicitly scoped, then it belongs to the current namespace (module, class, grammar, or package). Any return type must go after the name:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub lay returns Egg {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On an anonymous subroutine, any return type can only go after the name:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $lay = sub returns Egg {...};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;unless you use the &amp;ldquo;anonymous declarator&amp;rdquo; (&lt;code&gt;a&lt;/code&gt;/&lt;code&gt;an&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $lay = an Egg sub {...};
    $hat = a Rabbit sub {...};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-properties-and-traits-properties-and-traits-span&#34;&gt;&lt;span id=&#34;properties_and_traits&#34;&gt;Properties and Traits&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Compile-time properties are now called &amp;ldquo;traits.&amp;rdquo; The &lt;code&gt;is NAME (DATA)&lt;/code&gt; syntax defines traits on containers and subroutines, as part of their declaration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $pi is constant = 3;

    my $key is Persistent(file=&amp;gt;&amp;quot;.key&amp;quot;);

    sub fib is cached {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;will NAME BLOCK&lt;/code&gt; syntax is a synonym for &lt;code&gt;is NAME (BLOCK)&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $fh will undo { close $fh };    # Same as: my $fh is undo({ close $fh });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;but NAME (DATA)&lt;/code&gt; syntax specifies run-time properties on values:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $pi = 3 but Approximate(&amp;quot;legislated&amp;quot;);

    sub system {
        ...
        return $error but false if $error;
        return 0 but true;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-subroutine-traits-subroutine-traits-span&#34;&gt;&lt;span id=&#34;subroutine_traits&#34;&gt;Subroutine Traits&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;These traits may be declared on the subroutine as a whole (not on individual parameters).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_is_signature&#34;&gt;&lt;code&gt;is signature&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The signature of a subroutine &amp;ndash; normally declared implicitly, by providing a parameter list and/or return type.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_returns%2fis_returns&#34;&gt;&lt;code&gt;returns&lt;/code&gt;/&lt;code&gt;is returns&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The type returned by a subroutine.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_will_do&#34;&gt;&lt;code&gt;will do&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The block of code executed when the subroutine is called &amp;ndash; normally declared implicitly, by providing a block after the subroutine&amp;rsquo;s signature definition.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_is_rw&#34;&gt;&lt;code&gt;is rw&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Marks a subroutine as returning an lvalue.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_is_parsed&#34;&gt;&lt;code&gt;is parsed&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Specifies the rule by which a macro call is parsed.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_is_cached&#34;&gt;&lt;code&gt;is cached&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Marks a subroutine as being memoized&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_is_inline&#34;&gt;&lt;code&gt;is inline&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Suggests&lt;/em&gt; to the compiler that the subroutine is a candidate for optimization via inlining.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_is_tighter%2fis_looser%2fis_equiv&#34;&gt;&lt;code&gt;is tighter&lt;/code&gt;/&lt;code&gt;is looser&lt;/code&gt;/&lt;code&gt;is equiv&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Specifies the precedence of an operator relative to an existing operator.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_is_assoc&#34;&gt;&lt;code&gt;is assoc&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Specifies the associativity of an operator.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_pre%2fpost&#34;&gt;&lt;code&gt;PRE&lt;/code&gt;/&lt;code&gt;POST&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Mark blocks that are to be unconditionally executed before/after the subroutine&amp;rsquo;s &lt;code&gt;do&lt;/code&gt; block. These blocks must return a true value, otherwise an exception is thrown.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_first%2flast%2fnext%2fkeep%2fundo%2fetc%2e&#34;&gt;&lt;code&gt;FIRST&lt;/code&gt;/&lt;code&gt;LAST&lt;/code&gt;/&lt;code&gt;NEXT&lt;/code&gt;/&lt;code&gt;KEEP&lt;/code&gt;/&lt;code&gt;UNDO&lt;/code&gt;/etc.&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Mark blocks that are to be conditionally executed before or after the subroutine&amp;rsquo;s &lt;code&gt;do&lt;/code&gt; block. The return values of these blocks are ignored.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 6&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-parameter-traits-parameter-traits-span&#34;&gt;&lt;span id=&#34;parameter_traits&#34;&gt;Parameter Traits&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The following traits can be applied to many types of parameters.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_is_constant&#34;&gt;&lt;code&gt;is constant&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Specifies that the parameter cannot be modified (e.g. assigned to, incremented). It is the default for parameters.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;is rw&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Specifies that the parameter can be modified (assigned to, incremented, etc). Requires that the corresponding argument is an lvalue or can be converted to one.&lt;/p&gt;

&lt;p&gt;When applied to a variadic parameter, the &lt;code&gt;rw&lt;/code&gt; trait applies to each element of the list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub incr (*@vars is rw) { $_++ for @vars }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_is_ref&#34;&gt;&lt;code&gt;is ref&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Specifies that the parameter is passed by reference. Unlike &lt;a href=&#34;#item_is_rw&#34;&gt;&lt;code&gt;is rw&lt;/code&gt;&lt;/a&gt;, the corresponding argument must already be a suitable lvalue. No attempt at coercion or autovivification is made.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_is_copy&#34;&gt;&lt;code&gt;is copy&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Specifies that the parameter receives a distinct, read-writeable copy of the original argument. This is commonly known as &amp;ldquo;pass-by-value.&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub reprint ($text, $count is copy) {
        print $text while $count--&amp;gt;0;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_context&#34;&gt;&lt;code&gt;is context(TYPE)&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Specifies the context that a parameter applies to its argument. Typically used to cause a final list parameter to apply a series of scalar contexts:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # &amp;amp;format may have as many arguments as it likes,
    # each of which is evaluated in scalar context

    sub format(*@data is context(Scalar)) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-advanced-subroutine-features-advanced-subroutine-features-span&#34;&gt;&lt;span id=&#34;advanced_subroutine_features&#34;&gt;Advanced Subroutine Features&lt;/span&gt;&lt;/h3&gt;

&lt;h4 id=&#34;span-id-the-routine-the-routine-span&#34;&gt;&lt;span id=&#34;the_&amp;__routine&#34;&gt;The &lt;code&gt;&amp;amp;_&lt;/code&gt; routine&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;&amp;amp;_&lt;/code&gt; is always an alias for the current subroutine, much like the &lt;code&gt;$_&lt;/code&gt; alias for the current topic:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $anonfactorial = sub (Int $n) {
                            return 1 if $n&amp;lt;2;
                            return $n * &amp;amp;_($n-1)
                        };
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-the-caller-function-the-caller-function-span&#34;&gt;&lt;span id=&#34;the_caller_function&#34;&gt;The &lt;code&gt;caller&lt;/code&gt; Function&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;caller&lt;/code&gt; function returns an object that describes a particular &amp;ldquo;higher&amp;rdquo; dynamic scope, from which the current scope was called.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print &amp;quot;In &amp;quot;,           caller.sub,
          &amp;quot; called from &amp;quot;, caller.file,
          &amp;quot; line &amp;quot;,        caller.line,
          &amp;quot;\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;caller&lt;/code&gt; may be given arguments telling it what kind of higher scope to look for, and how many such scopes to skip over when looking:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $caller = caller;                      # immediate caller
    $caller = caller Method;               # nearest caller that is method
    $caller = caller Bare;                 # nearest caller that is bare block
    $caller = caller Sub, skip=&amp;gt;2;         # caller three levels up
    $caller = caller Block, label=&amp;gt;&#39;Foo&#39;;  # caller whose label is &#39;Foo&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-the-want-function-the-want-function-span&#34;&gt;&lt;span id=&#34;the_want_function&#34;&gt;The &lt;code&gt;want&lt;/code&gt; Function&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;want&lt;/code&gt; function returns an object that contains information about the context in which the current block, closure, or subroutine was called.&lt;/p&gt;

&lt;p&gt;The returned context object is typically tested with a smart match (&lt;code&gt;~~&lt;/code&gt;) or a &lt;code&gt;when&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   given want {
        when Scalar {...}           # called in scalar context
        when List   {...}           # called in list context
        when Lvalue {...}           # expected to return an lvalue
        when 2      {...}           # expected to return two values
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or has the corresponding methods called on it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       if (want.Scalar)    {...}    # called in scalar context
    elsif (want.List)      {...}    # called in list context
    elsif (want.rw)        {...}    # expected to return an lvalue
    elsif (want.count &amp;gt; 2) {...}    # expected to return more than two values
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-the-leave-function-the-leave-function-span&#34;&gt;&lt;span id=&#34;the_leave_function&#34;&gt;The &lt;code&gt;leave&lt;/code&gt; Function&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;A &lt;code&gt;return&lt;/code&gt; statement causes the innermost surrounding subroutine, method, rule, macro or multimethod to return.&lt;/p&gt;

&lt;p&gt;To return from other types of code structures, the &lt;code&gt;leave&lt;/code&gt; funtion is used:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    leave;                      # return from innermost block of any kind
    leave Method;               # return from innermost calling method
    leave &amp;amp;_ &amp;lt;== 1,2,3;         # Return from current sub. Same as: return 1,2,3
    leave &amp;amp;foo &amp;lt;== 1,2,3;       # Return from innermost surrounding call to &amp;amp;foo
    leave Loop, label=&amp;gt;&#39;COUNT&#39;; # Same as: last COUNT;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-temporization-temporization-span&#34;&gt;&lt;span id=&#34;temporization&#34;&gt;Temporization&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;temp&lt;/code&gt; function temporarily replaces a variable, subroutine or other object in a given scope:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    {
       temp $*foo = &#39;foo&#39;;      # Temporarily replace global $foo
       temp &amp;amp;bar = sub {...};   # Temporarily replace sub &amp;amp;bar
       ...
    } # Old values of $*foo and &amp;amp;bar reinstated at this point
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;temp&lt;/code&gt; invokes its argument&amp;rsquo;s &lt;code&gt;.TEMP&lt;/code&gt; method. The method is expected to return a reference to a subroutine that can later restore the current value of the object. At the end of the lexical scope in which the &lt;code&gt;temp&lt;/code&gt; was applied, the subroutine returned by the &lt;code&gt;.TEMP&lt;/code&gt; method is executed.&lt;/p&gt;

&lt;p&gt;The default &lt;code&gt;.TEMP&lt;/code&gt; method for variables simply creates a closure that assigns the variable&amp;rsquo;s pre-&lt;code&gt;temp&lt;/code&gt; value back to the variable.&lt;/p&gt;

&lt;p&gt;New kinds of temporization can be created by writing storage classes with their own &lt;code&gt;.TEMP&lt;/code&gt; methods:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class LoudArray is Array {
        method TEMP {
            print &amp;quot;Replacing $_.id() at $(caller.location)\n&amp;quot;;
            my $restorer = .SUPER::TEMP();
            return { 
                print &amp;quot;Restoring $_.id() at $(caller.location)\n&amp;quot;;
                $restorer();
            };
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also modify the behaviour of temporized code structures, by giving them a &lt;code&gt;TEMP&lt;/code&gt; block. As with &lt;code&gt;.TEMP&lt;/code&gt; methods, this block is expected to return a closure, which will be executed at the end of the temporizing scope to restore the subroutine to its pre-&lt;code&gt;temp&lt;/code&gt; state:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $next = 0;
    sub next {
        my $curr = $next++;
        TEMP {{ $next = $curr }}  # TEMP block returns the closure { $next = $curr }
        return $curr;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-wrapping-wrapping-span&#34;&gt;&lt;span id=&#34;wrapping&#34;&gt;Wrapping&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Every subroutine has a &lt;code&gt;.wrap&lt;/code&gt; method. This method expects a single argument consisting of a block, closure or subroutine. That argument must contain a call to the special &lt;code&gt;call&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub thermo ($t) {...}   # set temperature in Celsius, returns old temp

    # Add a wrapper to convert from Fahrenheit...

    $id = &amp;amp;thermo.wrap( { call( ($^t-32)/1.8 ) } );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The call to &lt;code&gt;.wrap&lt;/code&gt; replaces the original subroutine with the closure argument, and arranges that the closure&amp;rsquo;s call to &lt;code&gt;call&lt;/code&gt; invokes the original (unwrapped) version of the subroutine. In other words, the call to &lt;code&gt;.wrap&lt;/code&gt; has more or less the same effect as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;amp;old_thermo := &amp;amp;thermo;
    &amp;amp;thermo := sub ($t) { old_thermo( ($t-32)/1.8 ) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The call to &lt;code&gt;.wrap&lt;/code&gt; returns a unique identifier that can later be passed to the &lt;code&gt;.unwrap&lt;/code&gt; method, to undo the wrapping:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;amp;thermo.unwrap($id);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A wrapping can also be restricted to a particular dynamic scope with temporization:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Add a wrapper to convert from Kelvin
    # wrapper self-unwraps at end of current scope

    temp &amp;amp;thermo.wrap( { call($^t + 273.16) } );
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-currying-currying-span&#34;&gt;&lt;span id=&#34;currying&#34;&gt;Currying&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Every subroutine has an &lt;code&gt;.assuming&lt;/code&gt; method. This method takes a series of named arguments, whose names must match parameters of the subroutine itself:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;amp;textfrom := &amp;amp;substr.assuming(str=&amp;gt;$text, len=&amp;gt;Inf);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It returns a reference to a subroutine that implements the same behavior as the original subroutine, but has the values passed to &lt;code&gt;.assuming&lt;/code&gt; already bound to the corresponding parameters:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $all  = $textfrom(0);   # same as: $all  = substr($text,0,Inf);
    $some = $textfrom(50);  # same as: $some = substr($text,50,Inf);
    $last = $textfrom(-1);  # same as: $last = substr($text,-1,Inf);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The result of a &lt;code&gt;use&lt;/code&gt; statement is a (compile-time) object that also has an &lt;code&gt;.assuming&lt;/code&gt; method, allowing the user to bind parameters in all the module&amp;rsquo;s subroutines/methods/etc. simultaneously:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (use IO::Logging).assuming(logfile =&amp;gt; &amp;quot;.log&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-other-matters-other-matters-span&#34;&gt;&lt;span id=&#34;other_matters&#34;&gt;Other Matters&lt;/span&gt;&lt;/h3&gt;

&lt;h4 id=&#34;span-id-anonymous-hashes-vs-blocks-anonymous-hashes-vs-blocks-span&#34;&gt;&lt;span id=&#34;anonymous_hashes_vs_blocks&#34;&gt;Anonymous Hashes vs. Blocks&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;{...}&lt;/code&gt; is always a block/closure unless it consists of a single list, the first element of which is either a hash or a pair.&lt;/p&gt;

&lt;p&gt;The standard &lt;code&gt;pair LIST&lt;/code&gt; function is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub pair (*@LIST) {
        my @pairs;
        for @LIST -&amp;gt; $key, $val {
            push @pairs, $key=&amp;gt;$val;
        }
        return @pairs;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The standard &lt;code&gt;hash&lt;/code&gt; function takes a block, evaluates it in list context, and constructs an anonymous hash from the resulting key/value list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $ref = hash { 1, 2, 3, 4, 5, 6 };   # Anonymous hash
    $ref = sub  { 1, 2, 3, 4, 5, 6 };   # Anonymous sub returning list
    $ref =      { 1, 2, 3, 4, 5, 6 };   # Anonymous sub returning list
    $ref =      { 1=&amp;gt;2, 3=&amp;gt;4, 5=&amp;gt;6 };   # Anonymous hash
    $ref =      { 1=&amp;gt;2, 3, 4, 5, 6 };   # Anonymous hash
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-pairs-as-lvalues-pairs-as-lvalues-span&#34;&gt;&lt;span id=&#34;pairs_as_lvalues&#34;&gt;Pairs as lvalues&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Pairs can be used as lvalues. The value of the pair is the recipient of the assignment:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (key =&amp;gt; $var) = &amp;quot;value&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When binding pairs, names can be used to &amp;ldquo;match up&amp;rdquo; lvalues and rvalues:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (who =&amp;gt; $name, why =&amp;gt; $reason) := (why =&amp;gt; $because, who =&amp;gt; &amp;quot;me&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-outofscope-names-out-of-scope-names-span&#34;&gt;&lt;span id=&#34;outofscope_names&#34;&gt;Out-of-Scope Names&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;$CALLER::varname&lt;/code&gt; specifies the &lt;code&gt;$varname&lt;/code&gt; visible in the dynamic scope from which the current block/closure/subroutine was called.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$MY::varname&lt;/code&gt; specifies the lexical &lt;code&gt;$varname&lt;/code&gt; declared in the current lexical scope.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$OUTER::varname&lt;/code&gt; specifies the &lt;code&gt;$varname&lt;/code&gt; declared in the lexical scope surrounding the current lexical scope (i.e. the scope in which the current block was defined).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exegesis 5</title>
      <link>http://localhost:1313/pub/2002/08/22/exegesis5.html/</link>
      <pubDate>Thu, 22 Aug 2002 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2002/08/22/exegesis5.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 5&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#exegesis_5&#34;&gt;Exegesis 5&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#whats_the_diff&#34;&gt;What&amp;rsquo;s the diff?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#starting_gently&#34;&gt;Starting gently&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#lay_it_out_for_me&#34;&gt;Lay it out for me&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#interpolate_ye_not&#34;&gt;Interpolate ye not &amp;hellip;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#the_incredible_hunk&#34;&gt;The incredible &lt;code&gt;$hunk&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#modified_modifiers&#34;&gt;Modified modifiers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#take_no_prisoners&#34;&gt;Take no prisoners&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#meanwhile_back_at_the_hunk&#34;&gt;Meanwhile, back at the &lt;code&gt;$hunk&lt;/code&gt; &amp;hellip;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#this_or_nothing&#34;&gt;This or nothing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#failing_with_style&#34;&gt;Failing with style&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#home_home_on_the_line_range&#34;&gt;Home, home on the (line) range&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#whats_my_line&#34;&gt;What&amp;rsquo;s my line?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#the_final_frontier&#34;&gt;The final frontier&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#matchmaker_matchmaker&#34;&gt;Match-maker, match-maker &amp;hellip;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#a_cleaner_approach&#34;&gt;A cleaner approach&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#whats_in_a-name&#34;&gt;What&amp;rsquo;s in a name?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bad_line_no_match&#34;&gt;Bad line! No match!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#thinking_ahead&#34;&gt;Thinking ahead&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#what_you_match_is_what_you_get&#34;&gt;What you match is what you get&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#a_hypothetical_solution_to_a_very_real_problem&#34;&gt;A hypothetical solution to a very real problem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#the_nesting_instinct&#34;&gt;The nesting instinct&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#extracting_the_insertions&#34;&gt;Extracting the insertions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dont_just_match_there_do_something!&#34;&gt;Don&amp;rsquo;t just match there; do something!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#smarter_alternatives&#34;&gt;Smarter alternatives&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rearranging_the_deckchairs&#34;&gt;Rearranging the deck chairs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#deriving_a_benefit&#34;&gt;Deriving a benefit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#different_diffs&#34;&gt;Different diffs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#lets_get_cooking&#34;&gt;Let&amp;rsquo;s get cooking&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-exegesis-5-exegesis-5-span&#34;&gt;&lt;span id=&#34;exegesis_5&#34;&gt;Exegesis 5&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_Come_gather_round_Mongers%2C_whatever_you_code&#34;&gt;&lt;em&gt;Come gather round Mongers, whatever you code&lt;/em&gt;&lt;/span&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;span id=&#34;item_And_admit_that_your_forehead%27s_about_to_explode&#34;&gt;&lt;em&gt;And admit that your forehead&amp;rsquo;s about to explode&lt;/em&gt;&lt;/span&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;span id=&#34;item_%27Cos_Perl_patterns_induce_complete_brain_overloa&#34;&gt;&lt;em&gt;&amp;lsquo;Cos Perl patterns induce complete brain overload&lt;/em&gt;&lt;/span&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;span id=&#34;item_If_there%27s_source_code_you_should_be_maintainin%&#34;&gt;&lt;em&gt;If there&amp;rsquo;s source code, you should be maintainin&amp;rsquo;&lt;/em&gt;&lt;/span&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;span id=&#34;item_Then_you_better_start_learnin%27_Perl_6_patterns_s&#34;&gt;&lt;em&gt;Then you better start learnin&amp;rsquo; Perl 6 patterns soon&lt;/em&gt;&lt;/span&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;span id=&#34;item_For_the_regexes%2C_they_are_a%2Dchangin%27&#34;&gt;&lt;em&gt;For the regexes, they are a-changin&amp;rsquo;&lt;/em&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Apocalypse 5 marks a significant departure in the ongoing design of Perl 6.&lt;/p&gt;

&lt;p&gt;Previous Apocalypses took an evolutionary approach to changing Perl&amp;rsquo;s general syntax, data structures, control mechanisms and operators. New features were added, old features removed, and existing features were enhanced, extended and simplified. But the changes described were remedial, not radical.&lt;/p&gt;

&lt;p&gt;Larry could have taken the same approach with regular expressions. He could have tweaked some of the syntax, added new &lt;code&gt;(?...)&lt;/code&gt; constructs, cleaned up the rougher edges, and moved on.&lt;/p&gt;

&lt;p&gt;Fortunately, however, he&amp;rsquo;s taking a much broader view of Perl&amp;rsquo;s future than that. And he saw that the problem with regular expressions was &lt;em&gt;not&lt;/em&gt; that they lacked a &lt;code&gt;(?$var:...)&lt;/code&gt; extension to do named captures, or that they needed a &lt;code&gt;\R&lt;/code&gt; metatoken to denote a recursive subpattern, or that there was a &lt;code&gt;[:YourNamedCharClassHere:]&lt;/code&gt; mechanism missing.&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;p&gt;Related articles:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;He saw that those features, laudable as they were individually, would just compound the real problem, which was that Perl 5 regular expressions were already groaning under the accumulated weight of their own metasyntax. And that a decade of accretion had left the once-clean notation arcane, baroque, inconsistent and obscure.&lt;/p&gt;

&lt;p&gt;It was time to throw away the prototype.&lt;/p&gt;

&lt;p&gt;Even more importantly, as powerful as Perl 5 regexes are, they are not nearly powerful enough. Modern text manipulation is predominantly about processing structured, hierarchical text. And that&amp;rsquo;s just plain painful with regular expressions. The advent of modules like Parse::Yapp and Parse::RecDescent reflects the community&amp;rsquo;s widespread need for more sophisticated parsing mechanisms. Mechanisms that should be native to Perl.&lt;/p&gt;

&lt;p&gt;As Piers Cawley has so eloquently misquoted: &lt;em&gt;“It is a truth universally acknowledged that any language in possession of a rich syntax must be in want of a rewrite.”&lt;/em&gt; Perl regexes are such a language. And Apocalypse 5 is precisely that rewrite.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-whats-the-diff-what-s-the-diff-span&#34;&gt;&lt;span id=&#34;#whats_the_diff&#34;&gt;What&amp;rsquo;s the diff?&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;So let&amp;rsquo;s take a look at some of those new features. To do that, we&amp;rsquo;ll consider a series of examples structured around a common theme: recognizing and manipulating data in the Unix &lt;em&gt;&lt;a href=&#34;http://www.gnu.org/manual/diffutils-2.8.1/html_node/Detailed-Normal.html&#34;&gt;diff&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A classic diff consists of zero-or-more text transformations, each of which is known as a “hunk”. A hunk consists of a modification specifier, followed by one or more lines of context. Each hunk is either an append, a delete, or a change, and the type of hunk is specified by a single letter (&lt;code&gt;&#39;a&#39;&lt;/code&gt;, &lt;code&gt;&#39;d&#39;&lt;/code&gt;, or &lt;code&gt;&#39;c&#39;&lt;/code&gt;). Each of these single-letter specifiers is prefixed by the line numbers of the lines in the original document it affects, and followed by the equivalent line numbers in the transformed file. The context information consists of the lines of the original file (each preceded by a &lt;code&gt;&#39;&amp;lt;&#39;&lt;/code&gt; character), then the lines of the transformed file (each preceded by a &lt;code&gt;&#39;&amp;gt;&#39;&lt;/code&gt;). Deletes omit the transformed context, appends omit the original context. If both contexts appear, then they are separated by a line consisting of three hyphens.&lt;/p&gt;

&lt;p&gt;Phew! You can see why natural language isn&amp;rsquo;t the preferred way of specifying data formats.&lt;/p&gt;

&lt;p&gt;The preferred way is, of course, to specify such formats as patterns. And, indeed, we could easily throw together a few Perl 6 patterns that collectively would match any data conforming to that format:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $file = rx/ ^  &amp;lt;$hunk&amp;gt;*  $ /;

    $hunk = rx :i { 
        [ &amp;lt;$linenum&amp;gt; a :: &amp;lt;$linerange&amp;gt; \n
          &amp;lt;$appendline&amp;gt;+ 
        |
          &amp;lt;$linerange&amp;gt; d :: &amp;lt;$linenum&amp;gt; \n
          &amp;lt;$deleteline&amp;gt;+
        |
          &amp;lt;$linerange&amp;gt; c :: &amp;lt;$linerange&amp;gt; \n
          &amp;lt;$deleteline&amp;gt;+
          --- \n
          &amp;lt;$appendline&amp;gt;+
        ]
      |
        (\N*) ::: { fail &amp;quot;Invalid diff hunk: $1&amp;quot; }
    };

    $linerange = rx/ &amp;lt;$linenum&amp;gt; , &amp;lt;$linenum&amp;gt;
                   | &amp;lt;$linenum&amp;gt;
                   /;

    $linenum = rx/ \d+ /;

    $deleteline = rx/^^ \&amp;lt; &amp;lt;sp&amp;gt; (\N* \n) /;
    $appendline = rx/^^ \&amp;gt; &amp;lt;sp&amp;gt; (\N* \n) /;

    # and later...

    my $text is from($*ARGS);

    print &amp;quot;Valid diff&amp;quot; 
        if $text =~ /&amp;lt;$file&amp;gt;/;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-starting-gently-starting-gently-span&#34;&gt;&lt;span id=&#34;starting_gently&#34;&gt;Starting gently&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;There&amp;rsquo;s a lot of new syntax there, so let&amp;rsquo;s step through it slowly, starting with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $file = rx/ ^  &amp;lt;$hunk&amp;gt;*  $ /;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This statement creates a pattern object. Or, as it&amp;rsquo;s known in Perl 6, a “rule”. People will probably still call them “regular expressions” or “regexes” too (and the keyword &lt;code&gt;rx&lt;/code&gt; reflects that), but Perl patterns long ago ceased being anything like “regular”, so we&amp;rsquo;ll try and avoid those terms.&lt;/p&gt;

&lt;p&gt;In any case, the &lt;code&gt;rx&lt;/code&gt; constructor builds a new rule, which is then stored in the &lt;code&gt;$file&lt;/code&gt; variable. The Perl 5 equivalent would be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Perl 5
    my $file = qr/ ^  (??{$hunk})*  $ /x;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This illustrates quite nicely why the entire syntax needed to change.&lt;/p&gt;

&lt;p&gt;The name of the rule constructor has changed from &lt;code&gt;qr&lt;/code&gt; to &lt;code&gt;rx&lt;/code&gt;, because in Perl 6 rule constructors &lt;em&gt;aren&amp;rsquo;t&lt;/em&gt; quotelike contexts. In particular, variables don&amp;rsquo;t interpolate into &lt;code&gt;rx&lt;/code&gt; constructors in the way they do for a &lt;code&gt;qq&lt;/code&gt; or a &lt;code&gt;qx&lt;/code&gt;. That&amp;rsquo;s why we can embed the &lt;code&gt;$hunk&lt;/code&gt; variable before it&amp;rsquo;s actually initialized.&lt;/p&gt;

&lt;p&gt;In Perl 6, an embedded variable becomes part of the rule&amp;rsquo;s implementation rather than part of its “source code”. As we&amp;rsquo;ll see shortly, the pattern itself can determine how the variable is treated (i.e., whether to interpolate it literally, treat it as a subpattern or use it as a container).&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 5&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-lay-it-out-for-me-lay-it-out-for-me-span&#34;&gt;&lt;span id=&#34;lay_it_out_for_me&#34;&gt;Lay it out for me&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In Perl 6, each rule implicitly has the equivalent of the Perl 5 &lt;code&gt;/x&lt;/code&gt; modifier turned on, so we could lay out (and annotate) that first pattern like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $file = rx/ ^               # Must be at start of string
                &amp;lt;$hunk&amp;gt;         # Match what the rule in $hunk would match...
                        *       #          ...zero-or-more times
                $               # Must be at end of string (no newline allowed)
              /;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because &lt;code&gt;/x&lt;/code&gt; is the default, the whitespace in the pattern is ignored, which allows us to lay out the rule more readably. Comments are also honored, which enables us to document the rule sensibly. You can even use the closing delimiter in a comment safely:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $caveat = rx/ Make \s+ sure \s+ to \s+ ask
                  \s+ (mum|mom)                 # handle UK/US spelling
                  \s+ (and|or)                  # handle and/or
                  \s+ dad \s+ first
                /;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, the examples in this Exegesis &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; represent good comments in general, since they document what is happening, rather than why.&lt;/p&gt;

&lt;p&gt;The meanings of the &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; metacharacters are unchanged from Perl 5. However, the meaning of the &lt;code&gt;$&lt;/code&gt; metacharacter &lt;em&gt;has&lt;/em&gt; changed slightly: it no longer allows an optional newline before the end of the string. If you want that behavior, then you need to specify it explicitly. For example, to match a line ending in digits: &lt;code&gt;/ \d+ \n? $/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The compensation is that, in Perl 6, a &lt;code&gt;\n&lt;/code&gt; in a pattern matches a &lt;em&gt;logical&lt;/em&gt; newline (that is any of: &lt;code&gt;&amp;quot;\015\012&amp;quot;&lt;/code&gt; or &lt;code&gt;&amp;quot;\012&amp;quot;&lt;/code&gt; or &lt;code&gt;&amp;quot;\015&amp;quot;&lt;/code&gt; or &lt;code&gt;&amp;quot;\x85&amp;quot;&lt;/code&gt; or &lt;code&gt;&amp;quot;\x2028&amp;quot;&lt;/code&gt;), rather than just a &lt;em&gt;physical&lt;/em&gt; ASCII newline (i.e. just &lt;code&gt;&amp;quot;\012&amp;quot;&lt;/code&gt;). And a &lt;code&gt;\n&lt;/code&gt; will always try to match any kind of physical newline marker (not just the current system&amp;rsquo;s favorite), so it correctly matches against strings that have been aggregated from multiple systems.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-interpolate-ye-not-interpolate-ye-not-span&#34;&gt;&lt;span id=&#34;interpolate_ye_not&#34;&gt;Interpolate ye not &amp;hellip;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The really new bit in the &lt;code&gt;$file&lt;/code&gt; rule is the &lt;code&gt;&amp;lt;$hunk&amp;gt;&lt;/code&gt; element. It&amp;rsquo;s a directive to grab whatever&amp;rsquo;s in the &lt;code&gt;$hunk&lt;/code&gt; variable (presumably another pattern) and attempt to match it at that point in the rule. The important point is that the contents of &lt;code&gt;$hunk&lt;/code&gt; are only grabbed when the pattern matching mechanism actually needs to match against them, &lt;em&gt;not&lt;/em&gt; when the rule is being constructed. So it&amp;rsquo;s like the mysterious &lt;code&gt;(??{...})&lt;/code&gt; construct in Perl 5 regexes.&lt;/p&gt;

&lt;p&gt;The angle brackets themselves are a much more general mechanism in Perl 6 rules. They are the “metasyntactic markers” and replace the Perl 5 &lt;code&gt;(?...)&lt;/code&gt; syntax. They are used to specify numerous other features of Perl 6 rules, many of which we will explore below.&lt;/p&gt;

&lt;p&gt;Note that if we &lt;em&gt;hadn&amp;rsquo;t&lt;/em&gt; put the variable in angle-brackets, and had just written:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rx/ ^  $hunk*  $ /;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then the contents of &lt;code&gt;$hunk&lt;/code&gt; would &lt;em&gt;still&lt;/em&gt; not be interpolated when the pattern was parsed. Once again, the pattern would grab the contents of the variable when it reached that point in its match. But, this time, without the angle brackets around &lt;code&gt;$hunk&lt;/code&gt;, the pattern would try to match the contents of the variable as an atomic literal string (rather than as a subpattern). “Atomic” means that the &lt;code&gt;*&lt;/code&gt; repetition quantifier applies to everything that&amp;rsquo;s in &lt;code&gt;$hunk&lt;/code&gt;, &lt;em&gt;not&lt;/em&gt; just to the last character (as it does in Perl 5).&lt;/p&gt;

&lt;p&gt;In other words, a raw variable in a Perl 6 pattern is matched as if it was a Perl 5 regex in which the interpolation had been &lt;code&gt;quotemeta&lt;/code&gt;&amp;rsquo;d and then placed in a pair of noncapturing parentheses. That&amp;rsquo;s really handy in something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Perl 6
    my $target = &amp;lt;&amp;gt;;                  # Get literal string to search for
    $text =~ m/ $target* /;           # Search for them as literals
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which in Perl 5 we&amp;rsquo;d have to write as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Perl 5
    my $target = &amp;lt;&amp;gt;;                  # Get literal string to search for
    chomp $target;                    # No autochomping in Perl 5 
    $text =~ m/ (?:\Q$target\E)* /x;  # Search for it, quoting metas
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Raw arrays and hashes interpolate as literals, too. For example, if we use an array in a Perl 6 pattern, then the matcher will attempt to match any of its elements (each as a literal). So:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Perl 6
    @cmd = (&#39;get&#39;,&#39;put&#39;,&#39;try&#39;,&#39;find&#39;,&#39;copy&#39;,&#39;fold&#39;,&#39;spindle&#39;,&#39;mutilate&#39;);

    $str =~ / @cmd \( .*? \) /;     # Match a cmd, followed by stuff in parens
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is the same as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Perl 5 
    @cmd = (&#39;get&#39;,&#39;put&#39;,&#39;try&#39;,&#39;find&#39;,&#39;copy&#39;,&#39;fold&#39;,&#39;spindle&#39;,&#39;mutilate&#39;);
    $cmd = join &#39;|&#39;, map { quotemeta $_ } @cmd;

    $str =~ / (?:$cmd) \( .*? \) /;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By the way, putting the array into angle brackets would cause the matcher to try and match each of the array elements as a pattern, rather than as a literal.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-the-incredible-hunk-the-incredible-hunk-span&#34;&gt;&lt;span id=&#34;the_incredible_hunk&#34;&gt;The incredible &lt;code&gt;$hunk&lt;/code&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The rule that &lt;code&gt;&amp;lt;$hunk&amp;gt;&lt;/code&gt; tries to match against is the next one defined in the program. Here&amp;rsquo;s the annotated version of it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $hunk = rx :i {                             # Case-insensitively...
        [                                       #   Start a non-capturing group
            &amp;lt;$linenum&amp;gt;                          #     Match the subrule in $linenum
            a                                   #     Match a literal &#39;a&#39;
            ::                                  #     Commit to this alternative
            &amp;lt;$linerange&amp;gt;                        #     Match the subrule in $linerange
            \n                                  #     Match a newline
            &amp;lt;$appendline&amp;gt;                       #     Match the subrule in $appendline...
                          +                     #         ...one-or-more times
        |                                       #   Or...
          &amp;lt;$linerange&amp;gt; d :: &amp;lt;$linenum&amp;gt; \n       #     Match $linerange, &#39;d&#39;, $linenum, newline
          &amp;lt;$deleteline&amp;gt;+                        #     Then match $deleteline once-or-more
        |                                       #   Or...
          &amp;lt;$linerange&amp;gt; c :: &amp;lt;$linerange&amp;gt; \n     #     Match $linerange, &#39;c&#39;, $linerange, newline
          &amp;lt;$deleteline&amp;gt;+                        #     Then match $deleteline once-or-more
          --- \n                                #     Then match three &#39;-&#39; and a newline
          &amp;lt;$appendline&amp;gt;+                        #     Then match $appendline once-or-more
        ]                                       #   End of non-capturing group
      |                                         # Or...
        (                                       #   Start a capturing group
            \N*                                 #     Match zero-or-more non-newlines
        )                                       #     End of capturing group
        :::                                     #     Emphatically commit to this alternative
        { fail &amp;quot;Invalid diff hunk: $1&amp;quot; }        #     Then fail with an error msg
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first thing to note is that, like a Perl 5 &lt;code&gt;qr&lt;/code&gt;, a Perl 6 &lt;code&gt;rx&lt;/code&gt; can take (almost) any delimiters we choose. The &lt;code&gt;$hunk&lt;/code&gt; pattern uses &lt;code&gt;{...}&lt;/code&gt;, but we could have used:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rx/pattern/     # Standard
    rx[pattern]     # Alternative bracket-delimiter style
    rx&amp;lt;pattern&amp;gt;     # Alternative bracket-delimiter style
    rx«forme»       # Délimiteurs très chic
    rx&amp;gt;pattern&amp;lt;     # Inverted bracketing is allowed too (!)
    rx»Muster«      # Begrenzungen im korrekten Auftrag
    rx!pattern!     # Excited
    rx=pattern=     # Unusual
    rx?pattern?     # No special meaning in Perl 6
    rx#pattern#     # Careful with these: they disable internal comments
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-modified-modifiers-modified-modifiers-span&#34;&gt;&lt;span id=&#34;modified_modifiers&#34;&gt;Modified modifiers&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In fact, the only characters not permitted as &lt;code&gt;rx&lt;/code&gt; delimiters are &lt;code&gt;&#39;:&#39;&lt;/code&gt; and &lt;code&gt;&#39;(&#39;&lt;/code&gt;. That&amp;rsquo;s because &lt;code&gt;&#39;:&#39;&lt;/code&gt; is the character used to introduce pattern modifiers in Perl 6, and &lt;code&gt;&#39;(&#39;&lt;/code&gt; is the character used to delimit any arguments that might be passed to those pattern modifiers.&lt;/p&gt;

&lt;p&gt;In Perl 6, pattern modifiers are placed &lt;em&gt;before&lt;/em&gt; the pattern, rather than after it. That makes life easier for the parser, since it doesn&amp;rsquo;t have to go back and reinterpret the contents of a rule when it reaches the end and discovers a &lt;code&gt;/s&lt;/code&gt; or &lt;code&gt;/m&lt;/code&gt; or &lt;code&gt;/i&lt;/code&gt; or &lt;code&gt;/x&lt;/code&gt;. And it makes life easier for anyone reading the code &amp;ndash; for precisely the same reason.&lt;/p&gt;

&lt;p&gt;The only modifier used in the &lt;code&gt;$hunk&lt;/code&gt; rule is the &lt;code&gt;:i&lt;/code&gt; (case-insensitivity) modifier, which works exactly as it does in Perl 5.&lt;/p&gt;

&lt;p&gt;The other rule modifiers available in Perl 6 are:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_%3Ae_or_%3Aeach&#34;&gt;&lt;code&gt;:e&lt;/code&gt; or &lt;code&gt;:each&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This is the replacement for Perl 5&amp;rsquo;s &lt;code&gt;/g&lt;/code&gt; modifier. It causes a match (or substitution) to be attempted as many times as possible. The name was changed because “each” is shorter and clearer in intent than “globally”. And because the &lt;code&gt;:each&lt;/code&gt; modifier can be combined with other modifiers (see below) in such a way that it&amp;rsquo;s no longer “global” in its effect.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_x&#34;&gt;&lt;code&gt;:x($count)&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This modifier is like &lt;code&gt;:e&lt;/code&gt;, in that it causes the match or substitution to be attempted repeatedly. However, unlike &lt;code&gt;:e&lt;/code&gt;, it specifies exactly how many times the match must succeed. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;quot;fee fi &amp;quot;       =~ m:x(3)/ (f\w+) /;  # fails
    &amp;quot;fee fi fo&amp;quot;     =~ m:x(3)/ (f\w+) /;  # succeeds (matches &amp;quot;fee&amp;quot;,&amp;quot;fi&amp;quot;,&amp;quot;fo&amp;quot;)
    &amp;quot;fee fi fo fum&amp;quot; =~ m:x(3)/ (f\w+) /;  # succeeds (matches &amp;quot;fee&amp;quot;,&amp;quot;fi&amp;quot;,&amp;quot;fo&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the repetition count doesn&amp;rsquo;t have to be a constant:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    m:x($repetitions)/ pattern /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is also a series of tidy abbreviations for all the constant cases:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    m:1x/ pattern /         # same as: m:x(1)/ pattern /
    m:2x/ pattern /         # same as: m:x(2)/ pattern /
    m:3x/ pattern /         # same as: m:x(3)/ pattern /
    # etc.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_nth&#34;&gt;&lt;code&gt;:nth($count)&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This modifier causes a match or substitution to be attempted repeatedly, but to ignore the first &lt;code&gt;$count-1&lt;/code&gt; successful matches. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $foo = &amp;quot;fee fi fo fum&amp;quot;;

    $foo =~ m:nth(1)/ (f\w+) /;        # succeeds (matches &amp;quot;fee&amp;quot;)
    $foo =~ m:nth(2)/ (f\w+) /;        # succeeds (matches &amp;quot;fi&amp;quot;)
    $foo =~ m:nth(3)/ (f\w+) /;        # succeeds (matches &amp;quot;fo&amp;quot;)
    $foo =~ m:nth(4)/ (f\w+) /;        # succeeds (matches &amp;quot;fum&amp;quot;)
    $foo =~ m:nth(5)/ (f\w+) /;        # fails
    $foo =~ m:nth($n)/ (f\w+) /;       # depends on the numeric value of $n

    $foo =~ s:nth(3)/ (f\w+) /bar/;    # $foo now contains: &amp;quot;fee fi bar fum&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, there is also a series of abbreviations:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $foo =~ m:1st/ (f\w+) /;           # succeeds (matches &amp;quot;fee&amp;quot;)
    $foo =~ m:2nd/ (f\w+) /;           # succeeds (matches &amp;quot;fi&amp;quot;)
    $foo =~ m:3rd/ (f\w+) /;           # succeeds (matches &amp;quot;fo&amp;quot;)
    $foo =~ m:4th/ (f\w+) /;           # succeeds (matches &amp;quot;fum&amp;quot;)
    $foo =~ m:5th/ (f\w+) /;           # fails

    $foo =~ s:3rd/ (f\w+) /bar/;       # $foo now contains: &amp;quot;fee fi bar fum&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By the way, Perl isn&amp;rsquo;t going to be pedantic about these “ordinal” versions of repetition specifiers. If you&amp;rsquo;re not a native English speaker, and you find &lt;code&gt;:1th&lt;/code&gt;, &lt;code&gt;:2th&lt;/code&gt;, &lt;code&gt;:3th&lt;/code&gt;, &lt;code&gt;:4th&lt;/code&gt;, etc., easier to remember, then that&amp;rsquo;s perfectly OK.&lt;/p&gt;

&lt;p&gt;The various types of repetition modifiers can also be combined by separating them with additional colons:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $foo = &amp;quot;fee fi fo feh far foo fum &amp;quot;;

    $foo =~ m:2nd:2x/ (f\w+) /;        # succeeds (matches &amp;quot;fi&amp;quot;, &amp;quot;feh&amp;quot;)
    $foo =~ m:each:2nd/ (f\w+) /;      # succeeds (matches &amp;quot;fi&amp;quot;, &amp;quot;feh&amp;quot;, &amp;quot;foo&amp;quot;)
    $foo =~ m:x(2):nth(3)/ (f\w+) /;   # succeeds (matches &amp;quot;fo&amp;quot;, &amp;quot;foo&amp;quot;)
    $foo =~ m:each:3rd/ (f\w+) /;      # succeeds (matches &amp;quot;fo&amp;quot;, &amp;quot;foo&amp;quot;)
    $foo =~ m:2x:4th/ (f\w+) /;        # fails (not enough matches to satisfy :2x)
    $foo =~ m:4th:each/ (f\w+) /;      # succeeds (matches &amp;quot;feh&amp;quot;)

    $foo =~ s:each:2nd/ (f\w+) /bar/;  # $foo now &amp;quot;fee bar fo bar far bar fum &amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the order in which the two modifiers are specified doesn&amp;rsquo;t matter.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_%3Ap5_or_%3Aperl5&#34;&gt;&lt;code&gt;:p5&lt;/code&gt; or &lt;code&gt;:perl5&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This modifier causes Perl 6 to interpret the contents of a rule as a regular expression in Perl 5 syntax. This is mainly provided as a transitional aid for porting Perl 5 code. And to mollify the curmudgeonly.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_%3Aw_or_%3Aword&#34;&gt;&lt;code&gt;:w&lt;/code&gt; or &lt;code&gt;:word&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This modifier causes whitespace appearing in the pattern to match optional whitespace in the string being matched. For example, instead of having to cope with optional whitespace explicitly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $cmd =~ m/ \s* &amp;lt;keyword&amp;gt; \s* \( [\s* &amp;lt;arg&amp;gt; \s* ,?]* \s* \)/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we can just write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $cmd =~ m:w/ &amp;lt;keyword&amp;gt; \( [ &amp;lt;arg&amp;gt; ,?]* \)/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;:w&lt;/code&gt; modifier is also smart enough to detect those cases where the whitespace should actually be mandatory. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $str =~ m:w/a symmetric ally/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is the same as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $str =~ m/a \s+ symmetric \s+ ally/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;rather than:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $str =~ m/a \s* symmetric \s* ally/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So it won&amp;rsquo;t accidentally match strings like &lt;code&gt;&amp;quot;asymmetric ally&amp;quot;&lt;/code&gt; or &lt;code&gt;&amp;quot;asymmetrically&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_%3Aany&#34;&gt;&lt;code&gt;:any&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This modifier causes the rule to match a given string in every possible way, simultaneously, and then return all the possible matches. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $str = &amp;quot;ahhh&amp;quot;;

    @matches =  $str =~ m/ah*/;         # returns &amp;quot;ahhh&amp;quot;
    @matches =  $str =~ m:any/ah*/;     # returns &amp;quot;ahhh&amp;quot;, &amp;quot;ahh&amp;quot;, &amp;quot;ah&amp;quot;, &amp;quot;a&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_%3Au0%2C_%3Au1%2C_%3Au2%2C_%3Au3&#34;&gt;&lt;code&gt;:u0&lt;/code&gt;, &lt;code&gt;:u1&lt;/code&gt;, &lt;code&gt;:u2&lt;/code&gt;, &lt;code&gt;:u3&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;These modifiers specify how the rule matches the dot (&lt;code&gt;.&lt;/code&gt;) metacharacter against Unicode data. If &lt;code&gt;:u0&lt;/code&gt; is specified, then dot matches a single byte; if &lt;code&gt;:u1&lt;/code&gt; is specified, then dot matches a single codepoint (i.e. one or more bytes representing a single Unicode “character”). If &lt;code&gt;:u2&lt;/code&gt; is specified, then dot matches a single grapheme (i.e. a base codepoint followed by zero or more modifier codepoints, such as accents). If &lt;code&gt;:u3&lt;/code&gt; is specified, then dot matches an appropriate “something” in a language-dependent manner.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s OK to ignore this modifier if you&amp;rsquo;re not using Unicode (and maybe even if you are). As usual, Perl will try to do the right thing. To that end, the default behavior of rules is &lt;code&gt;:u2&lt;/code&gt;, unless an overriding pragma (e.g. &lt;code&gt;use bytes&lt;/code&gt;) is in effect.&lt;/p&gt;

&lt;p&gt;Note that the &lt;code&gt;/s&lt;/code&gt;, &lt;code&gt;/m&lt;/code&gt;, and &lt;code&gt;/e&lt;/code&gt; modifiers are no longer available. This is because they&amp;rsquo;re no longer needed. The &lt;code&gt;/s&lt;/code&gt; isn&amp;rsquo;t needed because the &lt;code&gt;.&lt;/code&gt; (dot) metacharacter now matches newlines as well. When we want to match “anything except a newline”, we now use the new &lt;code&gt;\N&lt;/code&gt; metatoken (i.e. “opposite of &lt;code&gt;\n&lt;/code&gt;”).&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;/m&lt;/code&gt; modifier isn&amp;rsquo;t required, because &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; always mean start and end of string, respectively. To match the start and end of a line, we use the new &lt;code&gt;^^&lt;/code&gt; and &lt;code&gt;$$&lt;/code&gt; metatokens instead.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;/e&lt;/code&gt; modifier is no longer needed, because Perl 6 provides the &lt;code&gt;$(...)&lt;/code&gt; string interpolator (as described in Apocalypse 2). So a substitution such as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Perl 5
    s/(\w+)/ get_val_for($1) /e;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;becomes just:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Perl 6
    s/(\w+)/$( get_val_for($1) )/;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 5&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-take-no-prisoners-take-no-prisoners-span&#34;&gt;&lt;span id=&#34;take_no_prisoners&#34;&gt;Take no prisoners&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The first character of the &lt;code&gt;$hunk&lt;/code&gt; rule is an opening square bracket. In Perl 5, that denoted the start of a character class, but not in Perl 6. In Perl 6, square brackets mark the boundaries of a noncapturing group. That is, a pair of square brackets in Perl 6 are the same as a &lt;code&gt;(?:...)&lt;/code&gt; in Perl 5, but less line-noisy.&lt;/p&gt;

&lt;p&gt;By the way, to get a character class in Perl 6, we need to put the square brackets inside a pair of metasyntactic angle brackets. So the Perl 5:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Perl 5
    / [A-Za-z] [0-9]+ /x          # An A-Z or a-z, followed by digits
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;would become in Perl 6:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Perl 6
    / &amp;lt;[A-Za-z]&amp;gt; &amp;lt;[0-9]&amp;gt;+ /       # An A-Z or a-z, followed by digits
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Perl 5 complemented character class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Perl 5
    / [^A-Za-z]+ /x               # One-or-more chars-that-aren&#39;t-A-Z-or-a-z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;becomes in Perl 6:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Perl 6
    / &amp;lt;-[A-Za-z]&amp;gt;+ /              #  One-or-more chars-that-aren&#39;t-A-Z-or-a-z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The external minus sign is used (instead of an internal caret), because Perl 6 allows proper set operations on character classes, and the minus sign is the “difference” operator. So we could also create:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Perl 6
    / &amp;lt; &amp;lt;alpha&amp;gt; - [A-Za-z] &amp;gt;+ /   # All alphabetics except A-Z or a-z
                                  # (i.e. the accented alphabetics)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Explicit character classes were deliberately made a little less convenient in Perl 6, because they&amp;rsquo;re generally a bad idea in a Unicode world. For example, the &lt;code&gt;[A-Za-z]&lt;/code&gt; character class in the above examples won&amp;rsquo;t even match standard alphabetic Latin-1 characters like &lt;code&gt;&#39;Ã&#39;&lt;/code&gt;, &lt;code&gt;&#39;é&#39;&lt;/code&gt;, &lt;code&gt;&#39;ø&#39;&lt;/code&gt;, let alone alphabetic characters from code-sets such as Cyrillic, Hiragana, Ogham, Cherokee, or Klingon.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-meanwhile-back-at-the-hunk-meanwhile-back-at-the-hunk-span&#34;&gt;&lt;span id=&#34;meanwhile_back_at_the_hunk&#34;&gt;Meanwhile, back at the &lt;code&gt;$hunk&lt;/code&gt; &amp;hellip;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The noncapturing group of the &lt;code&gt;$hunk&lt;/code&gt; pattern groups together three alternatives, separated by &lt;code&gt;|&lt;/code&gt; metacharacters (as in Perl 5). The first alternative:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;$linenum&amp;gt; a :: &amp;lt;$linerange&amp;gt;
    \n                         
    &amp;lt;$appendline&amp;gt;+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;grabs whatever is in the &lt;code&gt;$linenum&lt;/code&gt; variable, treats it as a subpattern, and attempts to match against it. It then matches a literal letter &lt;code&gt;&#39;a&#39;&lt;/code&gt; (or an &lt;code&gt;&#39;A&#39;&lt;/code&gt;, because of the &lt;code&gt;:i&lt;/code&gt; modifier on the rule). Then whatever the contents of the &lt;code&gt;$linerange&lt;/code&gt; variable match. Then a newline. Then it tries to match whatever the pattern in &lt;code&gt;$appendline&lt;/code&gt; would match, one or more times.&lt;/p&gt;

&lt;p&gt;But what about that double-colon after the &lt;code&gt;a&lt;/code&gt;? Shouldn&amp;rsquo;t the pattern have tried to match two colons at that point?&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-this-or-nothing-this-or-nothing-span&#34;&gt;&lt;span id=&#34;this_or_nothing&#34;&gt;This or nothing&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Actually, no. The double-colon is a new Perl 6 pattern-control structure. It has no effect (and is ignored) when the pattern is successfully matching, but if the pattern match should fail, and consequently back-track over the double-colon &amp;ndash; for example, to try and rematch an earlier repetition one fewer times &amp;ndash; the double-colon causes the entire surrounding group (i.e. the surrounding &lt;code&gt;[...]&lt;/code&gt; in this case) to fail as well.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s a useful optimization in this case because, if we match a line number followed by an &lt;code&gt;&#39;a&#39;&lt;/code&gt; but subsequently fail, then there&amp;rsquo;s no point even trying either of the other two alternatives in the same group. Because we found an &lt;code&gt;&#39;a&#39;&lt;/code&gt;, there&amp;rsquo;s no chance we could match a &lt;code&gt;&#39;d&#39;&lt;/code&gt; or a &lt;code&gt;&#39;c&#39;&lt;/code&gt; instead.&lt;/p&gt;

&lt;p&gt;So, in general, a double-colon means: “At this point I&amp;rsquo;m committed to this alternative within the current group &amp;ndash; don&amp;rsquo;t bother with the others if this one fails after this point”.&lt;/p&gt;

&lt;p&gt;There are other control directives like this, too. A single colon means: “Don&amp;rsquo;t bother backtracking into the previous element”. That&amp;rsquo;s useful in a pattern like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rx:w/ $keyword [-full|-quick|-keep]+ : end /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Suppose we successfully match the keyword (as a literal, by the way) and one or more of the three options, but then fail to match &lt;code&gt;&#39;end&#39;&lt;/code&gt;. In that case, there&amp;rsquo;s no point backtracking and trying to match one fewer option, and &lt;em&gt;still&lt;/em&gt; failing to find an &lt;code&gt;&#39;end&#39;&lt;/code&gt;. And then backtracking &lt;em&gt;another&lt;/em&gt; option, and failing again, etc. By using the colon after the repetition, we tell the matcher to give up after the first attempt.&lt;/p&gt;

&lt;p&gt;However, the single colon isn&amp;rsquo;t just a “Greed is Good” operator. It&amp;rsquo;s much more like a “Resistance is Futile” operator. That is, if the preceding repetition had been non-greedy instead:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rx:w/ $keyword [-full|-quick|-keep]+? : end /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then backtracking over the colon would prevent the &lt;code&gt;+?&lt;/code&gt; from attempting to match &lt;em&gt;more&lt;/em&gt; options. Note that this means that &lt;code&gt;x+?:&lt;/code&gt; is just a baroque way of matching exactly one repetition of &lt;code&gt;x&lt;/code&gt;, since the non-greedy repetition initially tries to match the minimal number of times (i.e. once) and the trailing colon then prevents it from backtracking and trying longer matches. Likewise, &lt;code&gt;x*?:&lt;/code&gt; and &lt;code&gt;x??:&lt;/code&gt; are arcane ways of matching exactly zero repetitions of &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Generally, though, a single colon tells the pattern matcher that there&amp;rsquo;s no point trying any other match on the preceding repetition, because retrying (whether more or fewer repetitions) would just waste time and would still fail.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s also a three-colon directive. Three colons means: “If we have to backtrack past here, cause the entire rule to fail” (i.e. not just this group). If the double-colon in &lt;code&gt;$hunk&lt;/code&gt; had been triple:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;$linenum&amp;gt; a ::: &amp;lt;$linerange&amp;gt;
    \n                         
    &amp;lt;$appendline&amp;gt;+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then matching a line number and an &lt;code&gt;&#39;a&#39;&lt;/code&gt; and subsequently failing would cause the entire &lt;code&gt;$hunk&lt;/code&gt; rule to fail immediately (though the &lt;code&gt;$file&lt;/code&gt; rule that invoked it might still match successfully in some other way).&lt;/p&gt;

&lt;p&gt;So, in general, a triple-colon specifies: “At this point I&amp;rsquo;m committed to this way of matching the current rule &amp;ndash; give up on the rule completely if the matching process fails at this point”.&lt;/p&gt;

&lt;p&gt;Four colons &amp;hellip; would just be silly. So, instead, there&amp;rsquo;s a special named directive: &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;. Backtracking through a &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; causes the entire match to immediately fail. And if the current rule is being matched as part of a larger rule, that larger rule will fail as well. In other words, it&amp;rsquo;s the “Blow up this Entire Planet and Possibly One or Two Others We Noticed on our Way Out Here” operator.&lt;/p&gt;

&lt;p&gt;If the double-colon in &lt;code&gt;$hunk&lt;/code&gt; had been a &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; instead:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;$linenum&amp;gt; a &amp;lt;commit&amp;gt; &amp;lt;$linerange&amp;gt;
    \n                         
    &amp;lt;$appendline&amp;gt;+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then matching a line number and an &lt;code&gt;&#39;a&#39;&lt;/code&gt; and subsequently failing would cause the entire &lt;code&gt;$hunk&lt;/code&gt; rule to fail immediately, &lt;em&gt;and&lt;/em&gt; would also cause the &lt;code&gt;$file&lt;/code&gt; rule that invoked it to fail immediately.&lt;/p&gt;

&lt;p&gt;So, in general, a &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; means: “At this point I&amp;rsquo;m committed to this way of completing the current match &amp;ndash; give up all attempts at matching anything if the matching process fails at this point”.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-failing-with-style-failing-with-style-span&#34;&gt;&lt;span id=&#34;failing_with_style&#34;&gt;Failing with style&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The other two alternatives:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    | &amp;lt;$linerange&amp;gt; d :: &amp;lt;$linenum&amp;gt; \n
      &amp;lt;$deleteline&amp;gt;+                 
    | &amp;lt;$linerange&amp;gt; c :: &amp;lt;$linerange&amp;gt; \n
      &amp;lt;$deleteline&amp;gt;+  --- \n  &amp;lt;$appendline&amp;gt;+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;are just variants on the first.&lt;/p&gt;

&lt;p&gt;If none of the three alternatives in the square brackets matches, then the alternative outside the brackets is tried:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    |  (\N*) ::: { fail &amp;quot;Invalid diff hunk: $1&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This captures a sequence of non-newline characters (&lt;code&gt;\N&lt;/code&gt; means “not &lt;code&gt;\n&lt;/code&gt;”, in the same way &lt;code&gt;\S&lt;/code&gt; means “not &lt;code&gt;\s&lt;/code&gt;” or &lt;code&gt;\W&lt;/code&gt; means “not &lt;code&gt;\w&lt;/code&gt;”). Then it invokes a block of Perl code inside the pattern. The call to &lt;code&gt;fail&lt;/code&gt; causes the match to fail at that point, and sets an associated error message that would subsequently appear in the &lt;code&gt;$!&lt;/code&gt; error variable (and which would also be accessible as part of &lt;code&gt;$0&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Note the use of the triple colon after the repetition. It&amp;rsquo;s needed because the &lt;code&gt;fail&lt;/code&gt; in the block will cause the pattern match to backtrack, but there&amp;rsquo;s no point backing up one character and trying again, since the original failure was precisely what we wanted. The presence of the triple-colon causes the entire rule to fail as soon as the backtracking reaches that point the first time.&lt;/p&gt;

&lt;p&gt;The overall effect of the &lt;code&gt;$hunk&lt;/code&gt; rule is therefore either to match one hunk of the diff, or else fail with a relevant error message.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-home-home-on-the-line-range-home-home-on-the-line-range-span&#34;&gt;&lt;span id=&#34;home_home_on_the_line_range&#34;&gt;Home, home on the (line)range&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The third and fourth rules:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $linerange = rx/ &amp;lt;$linenum&amp;gt; , &amp;lt;$linenum&amp;gt;
                   | &amp;lt;$linenum&amp;gt; 
                   /;

    $linenum = rx/ \d+ /;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;specify that a line number consists of a series of digits, and that a line range consists of either two line numbers with a comma between them or a single line number. The &lt;code&gt;$linerange&lt;/code&gt; rule could also have been written:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $linerange = rx/ &amp;lt;$linenum&amp;gt; [ , &amp;lt;$linenum&amp;gt; ]? /;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which might be marginally more efficient, since it doesn&amp;rsquo;t have to backtrack and rematch the first &lt;code&gt;$linenum&lt;/code&gt; in the second alternative. It&amp;rsquo;s likely, however, that the rule optimizer will detect such cases and automatically hoist the common prefix out anyway, so it&amp;rsquo;s probably not worth the decrease in readability to do that manually.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-whats-my-line-what-s-my-line-span&#34;&gt;&lt;span id=&#34;whats_my_line&#34;&gt;What&amp;rsquo;s my line?&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The final two rules specify the structure of individual context lines in the diff (i.e. the lines that say what text is being added or removed by the hunk):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $deleteline = rx/^^ \&amp;lt; &amp;lt;sp&amp;gt; (\N* \n) /
    $appendline = rx/^^ \&amp;gt; &amp;lt;sp&amp;gt; (\N* \n) /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;^^&lt;/code&gt; markers ensure that each rule starts at the beginning of an entire line.&lt;/p&gt;

&lt;p&gt;The first character on that line must be either a &lt;code&gt;&#39;&amp;lt;&#39;&lt;/code&gt; or a &lt;code&gt;&#39;&amp;gt;&#39;&lt;/code&gt;. Note that we have to escape these characters since angle brackets are metacharacters in Perl 6. An alternative would be to use the “literal string” metasyntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $deleteline = rx/^^ &amp;lt;&#39;&amp;lt;&#39;&amp;gt; &amp;lt;sp&amp;gt; (\N* \n) /
    $appendline = rx/^^ &amp;lt;&#39;&amp;gt;&#39;&amp;gt; &amp;lt;sp&amp;gt; (\N* \n) /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is, angle brackets with a single-quoted string inside them match the string&amp;rsquo;s sequence of characters as literals (including whitespace and other metatokens).&lt;/p&gt;

&lt;p&gt;Or we could have used the quotemeta metasyntax (&lt;code&gt;\Q[...]&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $deleteline = rx/^^ \Q[&amp;lt;] &amp;lt;sp&amp;gt; (\N* \n) /
    $appendline = rx/^^ \Q[&amp;gt;] &amp;lt;sp&amp;gt; (\N* \n) /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that Perl 5&amp;rsquo;s &lt;code&gt;\Q...\E&lt;/code&gt; construct is replaced in Perl 6 by just the &lt;code&gt;\Q&lt;/code&gt; marker, which now takes a group after it.&lt;/p&gt;

&lt;p&gt;We could also have used a single-letter character class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $deleteline = rx/^^ &amp;lt;[&amp;lt;]&amp;gt; &amp;lt;sp&amp;gt; (\N* \n) /
    $appendline = rx/^^ &amp;lt;[&amp;gt;]&amp;gt; &amp;lt;sp&amp;gt; (\N* \n) /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or even a named character (&lt;code&gt;\c[CHAR NAME HERE]&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $deleteline = rx/^^ \c[LEFT ANGLE BRACKET] &amp;lt;sp&amp;gt; (\N* \n) /
    $appendline = rx/^^ \c[RIGHT ANGLE BRACKET] &amp;lt;sp&amp;gt; (\N* \n) /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whether any of those MTOWTDI is better than just escaping the angle bracket is, of course, a matter of personal taste.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-the-final-frontier-the-final-frontier-span&#34;&gt;&lt;span id=&#34;the_final_frontier&#34;&gt;The final frontier&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;After the leading angle, a single literal space is expected. Again, we could have specified that by escapology (&lt;code&gt;\ &lt;/code&gt;) or literalness (&lt;code&gt;&amp;lt;&#39; &#39;&amp;gt;&lt;/code&gt;) or quotemetaphysics (&lt;code&gt;\Q[ ]&lt;/code&gt;) or character classification (&lt;code&gt;&amp;lt;[ ]&amp;gt;&lt;/code&gt;), or deterministic nomimalism (&lt;code&gt;\c[SPACE]&lt;/code&gt;), but Perl 6 also gives us a simple &lt;em&gt;name&lt;/em&gt; for the space character: &lt;code&gt;&amp;lt;sp&amp;gt;&lt;/code&gt;. This is the preferred option, since it reduces line-noise and makes the significant space much harder to miss.&lt;/p&gt;

&lt;p&gt;Perl 6 provides predefined names for other useful subpatterns as well, including:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_%3Cdot%3E&#34;&gt;&lt;code&gt;&amp;lt;dot&amp;gt;&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;which matches a literal dot (&lt;code&gt;&#39;.&#39;&lt;/code&gt;) character (i.e. it&amp;rsquo;s a more elegant synonym for &lt;code&gt;\.&lt;/code&gt;);&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_%3Clt%3E_and_%3Cgt%3E&#34;&gt;&lt;code&gt;&amp;lt;lt&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;gt&amp;gt;&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;which match a literal &lt;code&gt;&#39;&amp;lt;&#39;&lt;/code&gt; and &lt;code&gt;&#39;&amp;gt;&#39;&lt;/code&gt; respectively. These give us yet another way of writing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $deleteline = rx/^^ &amp;lt;lt&amp;gt; &amp;lt;sp&amp;gt; (\N* \n) /
    $appendline = rx/^^ &amp;lt;gt&amp;gt; &amp;lt;sp&amp;gt; (\N* \n) /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_%3Cws%3E&#34;&gt;&lt;code&gt;&amp;lt;ws&amp;gt;&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;which matches any sequence of whitespace (i.e. it&amp;rsquo;s a more elegant synonym for &lt;code&gt;\s+&lt;/code&gt;). Optional whitespace is, therefore, specified as &lt;code&gt;&amp;lt;ws&amp;gt;?&lt;/code&gt; or &lt;code&gt;&amp;lt;ws&amp;gt;*&lt;/code&gt; (Perl 6 will accept either);&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_%3Calpha%3E&#34;&gt;&lt;code&gt;&amp;lt;alpha&amp;gt;&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;which matches a single alphabetic character (i.e. it&amp;rsquo;s like the character class &lt;code&gt;&amp;lt;[A-Za-z]&amp;gt;&lt;/code&gt; but it handles accented characters and alphabetic characters from non-Roman scripts as well);&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_%3Cident%3E&#34;&gt;&lt;code&gt;&amp;lt;ident&amp;gt;&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;which is a short-hand for &lt;code&gt;[ [&amp;lt;alpha&amp;gt;|_] \w* ]&lt;/code&gt; (i.e. a standard identifier in many languages, including Perl)&lt;/p&gt;

&lt;p&gt;Using named subpatterns like these makes rules clearer in intent, easier to read, and more self-documenting. And, as we&amp;rsquo;ll see &lt;a href=&#34;#what&#39;s%20in%20a%20name&#34;&gt;shortly&lt;/a&gt;, they&amp;rsquo;re fully generalizable&amp;hellip;we can create our own.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-matchmaker-matchmaker-match-maker-match-maker-span&#34;&gt;&lt;span id=&#34;matchmaker_matchmaker&#34;&gt;Match-maker, match-maker&amp;hellip;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Finally, we&amp;rsquo;re ready to actually read in and match a diff file. In Perl 5, we&amp;rsquo;d do that like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Perl 5

    local $/;          # Disable input record separator (enable slurp mode)
    my $text = &amp;lt;&amp;gt;;     # Slurp up input stream into $text

    print &amp;quot;Valid diff&amp;quot; 
        if $text =~ /$file/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We could do the same thing in Perl 6 (though the syntax would differ slightly) and in this case that would be fine. But, in general, it&amp;rsquo;s clunky to have to slurp up the entire input before we start matching. The input might be huge, and we might fail early. Or we might want to match input interactively (and issue an error message as soon as the input fails to match). Or we might be matching a series of different formats. Or we might want to be able to leave the input stream in its original state if the match fails.&lt;/p&gt;

&lt;p&gt;The inability to do pattern matches immediately on an input stream is one of Perl 5&amp;rsquo;s few weaknesses when it comes to text processing. Sure, we can read line-by-line and apply pattern matching to each line, but trying to match a construct that may be laid out across an unknown number of lines is just painful.&lt;/p&gt;

&lt;p&gt;Not in Perl 6 though. In Perl 6, we can bind an input stream to a scalar variable (i.e. like a Perl 5 tied variable) and then just match on the characters in that stream as if they were already in memory:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $text is from($*ARGS);       # Bind scalar to input stream

    print &amp;quot;Valid diff&amp;quot; 
        if $text =~ /&amp;lt;$file&amp;gt;/;      # Match against input stream
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The important point is that, after the match, only those characters that the pattern actually matched will have been removed from the input stream.&lt;/p&gt;

&lt;p&gt;It may also be possible to skip the variable entirely and just write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print &amp;quot;Valid diff&amp;quot; 
        if $*ARGS =~ /&amp;lt;$file&amp;gt;/;     # Match against input stream
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print &amp;quot;Valid diff&amp;quot; 
        if &amp;lt;&amp;gt; =~ /&amp;lt;$file&amp;gt;/;         # Match against input stream
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but that&amp;rsquo;s yet to be decided.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-a-cleaner-approach-a-cleaner-approach-span&#34;&gt;&lt;span id=&#34;a_cleaner_approach&#34;&gt;A cleaner approach&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The previous example solves the problem of recognizing a valid diff file quite nicely (and with only six rules!), but it does so by cluttering up the program with a series of variables storing those precompiled patterns.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s as if we were to write a collection of subroutines like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $print_name = sub ($data) { print $data{name}, &amp;quot;\n&amp;quot;; };
    my $print_age  = sub ($data) { print $data{age}, &amp;quot;\n&amp;quot;; };
    my $print_addr = sub ($data) { print $data{addr}, &amp;quot;\n&amp;quot;; };

    my $print_info = sub ($data) {
        $print_name($data);
        $print_age($data);
        $print_addr($data);
    };

    # and later...

    $print_info($info);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You &lt;em&gt;could&lt;/em&gt; do it that way, but it&amp;rsquo;s not the right way to do it. The right way to do it is as a collection of named subroutines or methods, often collected together in the namespace of a class or module:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    module Info {

        sub print_name ($data) { print $data{name}, &amp;quot;\n&amp;quot;; }
        sub print_age ($data)  { print $data{age}, &amp;quot;\n&amp;quot;; }
        sub print_addr ($data) { print $data{addr}, &amp;quot;\n&amp;quot;; }

        sub print_info ($data) {
            print_name($data);
            print_age($data);
            print_addr($data);
        }
    }

    Info::print_info($info);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So it is with Perl 6 patterns. You &lt;em&gt;can&lt;/em&gt; write them as a series of pattern objects created at run-time, but they&amp;rsquo;re much better specified as a collection of named patterns, collected together at compile-time in the namespace of a grammar.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the previous diff-parsing example rewritten that way (and with a few extra bells-and-whistles added in):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    grammar Diff {
        rule file { ^  &amp;lt;hunk&amp;gt;*  $ }

        rule hunk :i { 
            [ &amp;lt;linenum&amp;gt; a :: &amp;lt;linerange&amp;gt; \n
              &amp;lt;appendline&amp;gt;+ 
            |
              &amp;lt;linerange&amp;gt; d :: &amp;lt;linenum&amp;gt; \n
              &amp;lt;deleteline&amp;gt;+
            |
              &amp;lt;linerange&amp;gt; c :: &amp;lt;linerange&amp;gt; \n
              &amp;lt;deleteline&amp;gt;+
              --- \n
              &amp;lt;appendline&amp;gt;+
            ]
          |
            &amp;lt;badline(&amp;quot;Invalid diff hunk&amp;quot;)&amp;gt;
        }

        rule badline ($errmsg) { (\N*) ::: { fail &amp;quot;$errmsg: $1&amp;quot; }

        rule linerange { &amp;lt;linenum&amp;gt; , &amp;lt;linenum&amp;gt;
                       | &amp;lt;linenum&amp;gt;
                       }

        rule linenum { \d+ }

        rule deleteline { ^^ &amp;lt;out_marker&amp;gt; (\N* \n) }
        rule appendline { ^^ &amp;lt;in_marker&amp;gt;  (\N* \n) }

        rule out_marker { \&amp;lt;  &amp;lt;sp&amp;gt; }
        rule in_marker  { \&amp;gt;  &amp;lt;sp&amp;gt; }
    }

    # and later...

    my $text is from($*ARGS);

    print &amp;quot;Valid diff&amp;quot; 
        if $text =~ /&amp;lt;Diff.file&amp;gt;/;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-whats-in-a-name-what-s-in-a-name-span&#34;&gt;&lt;span id=&#34;whats_in_a_name&#34;&gt;What&amp;rsquo;s in a name?&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;grammar&lt;/code&gt; declaration creates a new namespace for rules (in the same way a &lt;code&gt;class&lt;/code&gt; or &lt;code&gt;module&lt;/code&gt; declaration creates a new namespace for methods or subroutines). If a block is specified after the grammar&amp;rsquo;s name:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    grammar HTML {

        rule file :iw { \Q[&amp;lt;HTML&amp;gt;]  &amp;lt;head&amp;gt;  &amp;lt;body&amp;gt;  \Q[&amp;lt;/HTML&amp;gt;] }

        rule head :iw { \Q[&amp;lt;HEAD&amp;gt;]  &amp;lt;head_tag&amp;gt;+  \Q[&amp;lt;HEAD&amp;gt;] }

        # etc.

    } # Explicit end of HTML grammar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then that new namespace is confined to that block. Otherwise the namespace continues until the end of the source section of the current file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    grammar HTML;

    rule file :iw { \Q[&amp;lt;HTML&amp;gt;]  &amp;lt;head&amp;gt;  &amp;lt;body&amp;gt;  \Q[&amp;lt;/HTML&amp;gt;] }

    rule head :iw { \Q[&amp;lt;HEAD&amp;gt;]  &amp;lt;head_tag&amp;gt;+  \Q[&amp;lt;HEAD&amp;gt;] }

    # etc.

    # Implicit end of HTML grammar
    __END__
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that, as with the blockless variants on &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;module&lt;/code&gt;, this form of the syntax is designed to simplify one-namespace-per-file situations. It&amp;rsquo;s a compile-time error to put two or more blockless grammars, classes or modules in a single file.&lt;/p&gt;

&lt;p&gt;Within the namespace, named rules are defined using the &lt;code&gt;rule&lt;/code&gt; declarator. It&amp;rsquo;s analogous to the &lt;code&gt;sub&lt;/code&gt; declarator within a module, or the &lt;code&gt;method&lt;/code&gt; declarator within a class. Just like a class method, a named rule has to be invoked through its grammar if we refer to it outside its own namespace. That&amp;rsquo;s why the actual match became:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $text =~ /&amp;lt;Diff.file&amp;gt;/;         # Invoke through grammar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to match a named rule, we put the name in angle brackets. Indeed, many of the constructs we&amp;rsquo;ve already seen &amp;ndash; &lt;code&gt;&amp;lt;sp&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;ws&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;ident&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;alpha&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; &amp;ndash; are really just predefined named rules that come standard with Perl 6.&lt;/p&gt;

&lt;p&gt;Like subroutines and methods, within their own namespace, rules don&amp;rsquo;t have to be qualified. Which is why we can write things like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule linerange { &amp;lt;linenum&amp;gt; , &amp;lt;linenum&amp;gt;
                   | &amp;lt;linenum&amp;gt;
                   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;instead of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule linerange { &amp;lt;Diff.linenum&amp;gt; , &amp;lt;Diff.linenum&amp;gt;
                   | &amp;lt;Diff.linenum&amp;gt;
                   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using named rules has several significant advantages, apart from making the patterns look cleaner. For one thing, the compiler may be able to optimize the embedded named rules better. For example, it could inline the attempts to match &lt;code&gt;&amp;lt;linenum&amp;gt;&lt;/code&gt; within the &lt;code&gt;linerange&lt;/code&gt; rule. In the &lt;code&gt;rx&lt;/code&gt; version:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $linerange = rx{ &amp;lt;$linenum&amp;gt; , &amp;lt;$linenum&amp;gt;
                   | &amp;lt;$linenum&amp;gt;
                   };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;that&amp;rsquo;s not possible, since the pattern matching mechanism won&amp;rsquo;t know what&amp;rsquo;s in &lt;code&gt;$linenum&lt;/code&gt; until it actually tries to perform the match.&lt;/p&gt;

&lt;p&gt;By the way, we &lt;em&gt;can&lt;/em&gt; still use interpolated &lt;code&gt;&amp;lt;$subrule&amp;gt;&lt;/code&gt;-ish subpatterns in a named rule, and we can use named subpatterns in an &lt;code&gt;rx&lt;/code&gt;-ish rule. The difference between &lt;code&gt;rule&lt;/code&gt; and &lt;code&gt;rx&lt;/code&gt; is just that a &lt;code&gt;rule&lt;/code&gt; can have a name and must use &lt;code&gt;{...}&lt;/code&gt; as its delimiters, whereas an &lt;code&gt;rx&lt;/code&gt; doesn&amp;rsquo;t have a name and can use any allowed delimiters.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-bad-line-no-match-bad-line-no-match-span&#34;&gt;&lt;span id=&#34;bad_line_no_match&#34;&gt;Bad line! No match!&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;This version of the diff parser has an additional rule, named &lt;code&gt;badline&lt;/code&gt;. This rule illustrates another similarity between rules and subroutines/methods: rules can take arguments. The &lt;code&gt;badline&lt;/code&gt; rule factors out the error message creation at the end of the &lt;code&gt;hunk&lt;/code&gt; rule. Previously that rule ended with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    |  (\N*) ::: { fail &amp;quot;Invalid diff hunk: $1&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but in this version it ends with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    |  &amp;lt;badline(&amp;quot;Invalid diff hunk&amp;quot;)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s a much better abstraction of the error condition. It&amp;rsquo;s easier to understand and easier to maintain, but it does require us to be able to pass an argument (the error message) to the new &lt;code&gt;badline&lt;/code&gt; subrule. To do that, we simply declare it to have a parameter list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule badline($errmsg) { (\N*) ::: { fail &amp;quot;$errmsg: $1&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note the strong syntactic parallel with a subroutine definition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub  subname($param)  { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The argument is passed to a subrule by placing it in parentheses after the rule name within the angle brackets:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    |  &amp;lt;badline(&amp;quot;Invalid diff hunk&amp;quot;)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The argument can also be passed without the parentheses, but then it is interpreted as if it were the body of a separate rule:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule list_of ($pattern) { 
            &amp;lt;$pattern&amp;gt; [ , &amp;lt;$pattern&amp;gt; ]*
    }

    # and later...

    $str =~ m:w/  \[                  # Literal opening square bracket
                  &amp;lt;list_of \w\d+&amp;gt;     # Call list_of subrule passing rule rx/\w\d+/
                  \]                  # Literal closing square bracket
               /;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A rule can take as many arguments as it needs to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule seplist($elem, $sep) {
            &amp;lt;$elem&amp;gt;  [ &amp;lt;$sep&amp;gt; &amp;lt;$elem&amp;gt; ]*
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and those arguments can also be passed by name, using the standard Perl 6 pair-based mechanism (as described in Apocalypse 3).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $str =~ m:w/
                \[                                      # literal left square bracket
                &amp;lt;seplist(sep=&amp;gt;&amp;quot;:&amp;quot;, elem=&amp;gt;rx/&amp;lt;ident&amp;gt;/)&amp;gt;  # colon-separated list of identifiers
                \]                                      # literal right square bracket
               /;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the list&amp;rsquo;s element specifier is itself an anonymous rule, which the &lt;code&gt;seplist&lt;/code&gt; rule will subsequently interpolate as a pattern (because the &lt;code&gt;$elem&lt;/code&gt; parameter appears in angle brackets within &lt;code&gt;seplist&lt;/code&gt;).&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 5&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-thinking-ahead-thinking-ahead-span&#34;&gt;&lt;span id=&#34;thinking_ahead&#34;&gt;Thinking ahead&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The only other change in the grammar version of the diff parser is that the matching of the &lt;code&gt;&#39;&amp;lt;&#39;&lt;/code&gt; and &lt;code&gt;&#39;&amp;gt;&#39;&lt;/code&gt; at the start of the context lines has been factored out. Whereas before we had:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $deleteline = rx/^^ \&amp;lt; &amp;lt;sp&amp;gt; (\N* \n) /
    $appendline = rx/^^ \&amp;gt; &amp;lt;sp&amp;gt; (\N* \n) /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;now we have:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule deleteline { ^^ &amp;lt;out_marker&amp;gt; (\N* \n) }
    rule appendline { ^^ &amp;lt;in_marker&amp;gt;  (\N* \n) }

    rule out_marker { \&amp;lt;  &amp;lt;sp&amp;gt; }
    rule in_marker  { \&amp;gt;  &amp;lt;sp&amp;gt; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That seems like a step backwards, since it complicated the grammar for no obvious benefit, but the benefit will be reaped &lt;a href=&#34;#different%20diffs&#34;&gt;later&lt;/a&gt; when we discover another type of diff file that uses different markers for incoming and outgoing lines.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-what-you-match-is-what-you-get-what-you-match-is-what-you-get-span&#34;&gt;&lt;span id=&#34;what_you_match_is_what_you_get&#34;&gt;What you match is what you get&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Both the variable-based and grammatical versions of the code above do a great job of &lt;em&gt;recognizing&lt;/em&gt; a diff, but that&amp;rsquo;s all they do. If we only want syntax checking, that&amp;rsquo;s fine. But, generally, if we&amp;rsquo;re parsing data what we really want is to do something useful with it: transform it into some other syntax, make changes to its contents, or perhaps convert it to a Perl internal data structure for our program to manipulate.&lt;/p&gt;

&lt;p&gt;Suppose we did want to build a hierarchical Perl data structure representing the diff that the above examples match. What extra code would we need?&lt;/p&gt;

&lt;p&gt;None.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s right. Whenever Perl 6 matches a pattern, it &lt;em&gt;automatically&lt;/em&gt; builds a “result object” representing the various components of the match.&lt;/p&gt;

&lt;p&gt;That result object is named &lt;code&gt;$0&lt;/code&gt; (the program&amp;rsquo;s name is now &lt;code&gt;$*PROG&lt;/code&gt;) and it&amp;rsquo;s lexical to the scope in which the match occurs. The result object stores (amongst other things) the complete string matched by the pattern, and it evaluates to that string when used in a string context. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if ($text =~ /&amp;lt;Diff.file&amp;gt;/) {
        $difftext = $0;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s handy, but not really useful for extracting data structures. However, in addition, any components within a match that were captured using parentheses become elements of the object&amp;rsquo;s array attribute, and are accessible through its array index operator. So, for example, when a pattern such as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule linenum_plus_comma { (\d+) (,?) };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;matches successfully, the array element 1 of the result object (i.e. &lt;code&gt;$0[1]&lt;/code&gt;) is assigned the result of the first parenthesized capture (i.e. the digits), whilst the array element 2 (&lt;code&gt;$0[2]&lt;/code&gt;) receives the comma. Note that array element zero of any result object is assigned the complete string that the pattern matched.&lt;/p&gt;

&lt;p&gt;There are also abbreviations for each of the array elements of &lt;code&gt;$0&lt;/code&gt;. &lt;code&gt;$0[1]&lt;/code&gt; can also be referred to as&amp;hellip;surprise, surprise&amp;hellip;&lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$0[2]&lt;/code&gt; can also be referred to as &lt;code&gt;$2&lt;/code&gt;, &lt;code&gt;$0[3]&lt;/code&gt; as &lt;code&gt;$3&lt;/code&gt;, etc. Like &lt;code&gt;$0&lt;/code&gt;, each of these numeric variables is also lexical to the scope in which the pattern match occurred.&lt;/p&gt;

&lt;p&gt;The parts of a matched string that were matched by a named subrule become entries in the result object&amp;rsquo;s hash attribute, and are subsequently accessible through its hash lookup operator. So, for example, when the pattern:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule deleteline { ^^ &amp;lt;out_marker&amp;gt; (\N* \n) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;matches, the result object&amp;rsquo;s hash entry for the key &lt;code&gt;&#39;out_marker&#39;&lt;/code&gt; (i.e. &lt;code&gt;$0{out_marker}&lt;/code&gt;) will contain the result object returned by the successful nested match of the &lt;code&gt;out_marker&lt;/code&gt; subrule.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-a-hypothetical-solution-to-a-very-real-problem-a-hypothetical-solution-to-a-very-real-problem-span&#34;&gt;&lt;span id=&#34;a_hypothetical_solution_to_a_very_real_problem&#34;&gt;A hypothetical solution to a very real problem&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Named capturing into a hash is very convenient, but it doesn&amp;rsquo;t work so well for a rule like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule linerange {
          &amp;lt;linenum&amp;gt; , &amp;lt;linenum&amp;gt;
        | &amp;lt;linenum&amp;gt;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem is that the hash attribute of the rule&amp;rsquo;s &lt;code&gt;$0&lt;/code&gt; can only store one entry with the key &lt;code&gt;&#39;linenum&#39;&lt;/code&gt;. So if the &lt;code&gt;&amp;lt;linenum&amp;gt; , &amp;lt;linenum&amp;gt;&lt;/code&gt; alternative matches, then the result object from the second match of &lt;code&gt;&amp;lt;linenum&amp;gt;&lt;/code&gt; will overwrite the entry for the first &lt;code&gt;&amp;lt;linenum&amp;gt;&lt;/code&gt; match.&lt;/p&gt;

&lt;p&gt;The solution to this is a new Perl 6 pattern matching feature known as “hypothetical variables”. A hypothetical variable is a variable that is declared and bound within a pattern match (i.e. inside a closure within a rule). The variable is declared, not with a &lt;code&gt;my&lt;/code&gt;, &lt;code&gt;our&lt;/code&gt;, or &lt;code&gt;temp&lt;/code&gt;, but with the new keyword &lt;code&gt;let&lt;/code&gt;, which was chosen because it&amp;rsquo;s what mathematicians and other philosophers use to indicate a hypothetical assumption.&lt;/p&gt;

&lt;p&gt;Once declared, a hypothetical variable is then bound using the normal binding operator. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule checked_integer {
            (\d+)                   # Match and capture one-or-more digits
            { let $digits := $1 }   # Bind to hypothetical var $digits
            -                       # Match a hyphen
            (\d)                    # Match and capture one digit
            { let $check := $2 }    # Bind to hypothetical var $check
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example, if a sequence of digits is found, then the &lt;code&gt;$digits&lt;/code&gt; variable is bound to that substring. Then, if the dash and check-digit are matched, the digit is bound to &lt;code&gt;$check&lt;/code&gt;. However, if the dash or digit is not matched, the match will fail and backtrack through the closure. This backtracking causes the &lt;code&gt;$digits&lt;/code&gt; hypothetical variable to be automatically &lt;em&gt;un-bound&lt;/em&gt;. Thus, if a rule fails to match, the hypothetical variables within it are not associated with any value.&lt;/p&gt;

&lt;p&gt;Each hypothetical variable is really just another name for the corresponding entry in the result object&amp;rsquo;s hash attribute. So binding a hypothetical variable like &lt;code&gt;$digits&lt;/code&gt; within a rule actually sets the &lt;code&gt;$0{digits}&lt;/code&gt; element of the rule&amp;rsquo;s result object.&lt;/p&gt;

&lt;p&gt;So, for example, to distinguish the two line numbers within a line range:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule linerange {
          &amp;lt;linenum&amp;gt; , &amp;lt;linenum&amp;gt;
        | &amp;lt;linenum&amp;gt;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we could bind them to two separate hypothetical variables &amp;ndash; say, &lt;code&gt;$from&lt;/code&gt; and &lt;code&gt;$to&lt;/code&gt; &amp;ndash; like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule linerange {
          (&amp;lt;linenum&amp;gt;)               # Match linenum and capture result as $1
          { let $from := $1 }       # Save result as hypothetical variable
          ,                         # Match comma
          (&amp;lt;linenum&amp;gt;)               # Match linenum and capture result as $2
          { let $to := $2 }         # Save result as hypothetical variable
        |
          (&amp;lt;linenum&amp;gt;)               # Match linenum and capture result as $3
          { let $from := $3 }       # Save result as hypothetical variable
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now our result object has a hash entry &lt;code&gt;$0{from}&lt;/code&gt; and (maybe) one for &lt;code&gt;$0{to}&lt;/code&gt; (if the first alternative was the one that matched). In fact, we could &lt;em&gt;ensure&lt;/em&gt; that the result always has a &lt;code&gt;$0{to}&lt;/code&gt;, by setting the corresponding hypothetical variable in the second alternative as well:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule linerange {
          (&amp;lt;linenum&amp;gt;)
          { let $from := $1 }
          ,         
          (&amp;lt;linenum&amp;gt;)
          { let $to := $2 }
        |
          (&amp;lt;linenum&amp;gt;)
          { let $from := $3; let $to := $from }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Problem solved.&lt;/p&gt;

&lt;p&gt;But only by introducing a new problem. All that hypothesizing made our rule ugly and complex. So Perl 6 provides a much prettier short-hand:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule linerange {
          $from := &amp;lt;linenum&amp;gt;          # Match linenum rule, bind result to $from
          ,                           # Match comma
          $to := &amp;lt;linenum&amp;gt;            # Match linenum rule, bind result to $to
        |                             # Or...
          $from := $to := &amp;lt;linenum&amp;gt;   # Match linenum rule,
    }                                 #   bind result to both $from and $to
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or, more compactly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule linerange {
          $from:=&amp;lt;linenum&amp;gt; , $to:=&amp;lt;linenum&amp;gt;
        | $from:=$to:=&amp;lt;linenum&amp;gt;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If a Perl 6 rule contains a variable that is immediately followed by the binding operator (&lt;code&gt;:=&lt;/code&gt;), that variable is never interpolated. Instead, it is treated as a hypothetical variable, and bound to the result of the next component of the rule (in the above examples, to the result of the &lt;code&gt;&amp;lt;linenum&amp;gt;&lt;/code&gt; subrule match).&lt;/p&gt;

&lt;p&gt;You can also use hypothetical arrays and hashes, binding them to a component that captures repeatedly. For example, we might choose to name our set of hunks:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule file { ^  @adonises := &amp;lt;hunk&amp;gt;*  $ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;collecting all the &lt;code&gt;&amp;lt;hunk&amp;gt;&lt;/code&gt; matches into a single array (which would then be available after the match as &lt;code&gt;$0{&#39;@adonises&#39;}&lt;/code&gt;. Note that the sigil is included in the key in this case).&lt;/p&gt;

&lt;p&gt;Or we might choose to bind a hypothetical hash:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule config {
        %init :=            # Hypothetically, bind %init to...
            [               # Start of group
                (&amp;lt;ident&amp;gt;)   # Match and capture an identifier
                \h*=\h*     # Match an equals sign with optional horizontal whitespace
                (\N*)       # Match and capture the rest of the line
                \n          # Match the newline
            ]*
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where each repetition of the &lt;code&gt;[...]*&lt;/code&gt; grouping captures two substrings on each repetition and converts them to a key/value pair, which is then added to the hash. The first captured substring in each repetition becomes the key, and the second captured substring becomes its associated value. The hypothetical &lt;code&gt;%init&lt;/code&gt; hash is also available through the rule&amp;rsquo;s result object, as &lt;code&gt;$0{&#39;%init&#39;}&lt;/code&gt; (again, with the sigil as part of the key).&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-the-nesting-instinct-the-nesting-instinct-span&#34;&gt;&lt;span id=&#34;the_nesting_instinct&#34;&gt;The nesting instinct&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Of course, those line number submatches in:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule linerange {
          $from:=&amp;lt;linenum&amp;gt; , $to:=&amp;lt;linenum&amp;gt;
        | $from:=$to:=&amp;lt;linenum&amp;gt;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will have returned their own result objects. And it&amp;rsquo;s a reference to those nested result objects that actually gets stored in &lt;code&gt;linerange&lt;/code&gt;&amp;rsquo;s &lt;code&gt;$0{from}&lt;/code&gt; and &lt;code&gt;$0{to}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Likewise, in the next higher rule:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule hunk :i { 
        [ &amp;lt;linenum&amp;gt; a :: &amp;lt;linerange&amp;gt; \n
          &amp;lt;appendline&amp;gt;+ 
        |
          &amp;lt;linerange&amp;gt; d :: &amp;lt;linenum&amp;gt; \n
          &amp;lt;deleteline&amp;gt;+
        |
          &amp;lt;linerange&amp;gt; c :: &amp;lt;linerange&amp;gt; \n
          &amp;lt;deleteline&amp;gt;+
          --- \n
          &amp;lt;appendline&amp;gt;+
        ]
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the match on &lt;code&gt;&amp;lt;linerange&amp;gt;&lt;/code&gt; will return &lt;em&gt;its&lt;/em&gt; &lt;code&gt;$0&lt;/code&gt; object. So, within the &lt;code&gt;hunk&lt;/code&gt; rule, we could access the “from” digits of the line range of the hunk as: &lt;code&gt;$0{linerange}{from}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Likewise, at the highest level:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule file { ^  &amp;lt;hunk&amp;gt;*  $ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we are matching a series of hunks, so the hypothetical &lt;code&gt;$hunk&lt;/code&gt; variable (and hence &lt;code&gt;$0{hunk}&lt;/code&gt;) will contain a result object whose array attribute contains the series of result objects returned by each individual &lt;code&gt;&amp;lt;hunk&amp;gt;&lt;/code&gt; match.&lt;/p&gt;

&lt;p&gt;So, for example, we could access the “from” digits of the line range of the third hunk as: &lt;code&gt;$0{hunk}[2]{linerange}{from}&lt;/code&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-extracting-the-insertions-extracting-the-insertions-span&#34;&gt;&lt;span id=&#34;extracting_the_insertions&#34;&gt;Extracting the insertions&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;More usefully, we could locate and print every line in the diff that was being inserted, regardless of whether it was inserted by an “append” or a “change” hunk. Like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $text is from($*ARGS);

    if $text =~ /&amp;lt;Diff.file&amp;gt;/ {
        for @{ $0{file}{hunk} } -&amp;gt; $hunk
             print @{$hunk{appendline}}
                 if $hunk{appendline};
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, the &lt;code&gt;if&lt;/code&gt; statement attempts to match the text against the pattern for a diff file. If it succeeds, the &lt;code&gt;for&lt;/code&gt; loop grabs the &lt;code&gt;&amp;lt;hunk&amp;gt;*&lt;/code&gt; result object, treats it as an array, and then iterates each hunk match object in turn into &lt;code&gt;$hunk&lt;/code&gt;. The array of append lines for each hunk match is then printed (if there is in fact a reference to that array in the hunk).&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-dont-just-match-there-do-something-don-t-just-match-there-do-something-span&#34;&gt;&lt;span id=&#34;dont_just_match_there_do_something&#34;&gt;Don&amp;rsquo;t just match there; do something!&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Because Perl 6 patterns can have arbitrary code blocks inside them, it&amp;rsquo;s easy to have a pattern actually perform syntax transformations whilst it&amp;rsquo;s parsing. That&amp;rsquo;s often a useful technique because it allows us to manipulate the various parts of a hierarchical representation locally (within the rules that recognize them).&lt;/p&gt;

&lt;p&gt;For example, suppose we wanted to “reverse” the diff file. That is, suppose we had a diff that specified the changes required to transform file A to file B, but we needed the back-transformation instead: from file B to file A. That&amp;rsquo;s relatively easy to create. We just turn every “append” into a “delete”, every “delete” into an “append”, and reverse every “change”.&lt;/p&gt;

&lt;p&gt;The following code does exactly that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    grammar ReverseDiff {
        rule file { ^  &amp;lt;hunk&amp;gt;*  $ }

        rule hunk :i { 
            [ &amp;lt;linenum&amp;gt; a :: &amp;lt;linerange&amp;gt; \n
              &amp;lt;appendline&amp;gt;+ 
              { @$appendline =~ s/&amp;lt;in_marker&amp;gt;/&amp;lt; /;
                let $0 := &amp;quot;${linerange}d${linenum}\n&amp;quot;
                        _ join &amp;quot;&amp;quot;, @$appendline;
              }
            |
              &amp;lt;linerange&amp;gt; d :: &amp;lt;linenum&amp;gt; \n
              &amp;lt;deleteline&amp;gt;+
              { @$deleteline =~ s/&amp;lt;out_marker&amp;gt;/&amp;gt; /;
                let $0 := &amp;quot;${linenum}a${linerange}\n&amp;quot;
                        _ join &amp;quot;&amp;quot;, @$deleteline;
              }
            |
              $from:=&amp;lt;linerange&amp;gt; c :: $to:=&amp;lt;linerange&amp;gt; \n
              &amp;lt;deleteline&amp;gt;+
              --- \n
              &amp;lt;appendline&amp;gt;+
              { @$appendline =~ s/&amp;lt;in_marker&amp;gt;/&amp;lt;/;
                @$deleteline =~ s/&amp;lt;out_marker&amp;gt;/&amp;gt;/;
                let $0 := &amp;quot;${to}c${from}\n&amp;quot;
                        _ join(&amp;quot;&amp;quot;, @$appendline)
                        _ &amp;quot;---\n&amp;quot;
                        _ join(&amp;quot;&amp;quot;, @$deleteline);
              }
            ]
          |
            &amp;lt;badline(&amp;quot;Invalid diff hunk&amp;quot;)&amp;gt;
        }

    rule badline ($errmsg) { (\N*) ::: { fail &amp;quot;$errmsg: $1&amp;quot; } }

    rule linerange { $from:=&amp;lt;linenum&amp;gt; , $to:=&amp;lt;linenum&amp;gt;
                       | $from:=$to:=&amp;lt;linenum&amp;gt;
                       }

    rule linenum { (\d+) }

    rule deleteline { ^^ &amp;lt;out_marker&amp;gt; (\N* \n) }
        rule appendline { ^^ &amp;lt;in_marker&amp;gt;  (\N* \n) }

    rule out_marker { \&amp;lt;  &amp;lt;sp&amp;gt; }
        rule in_marker  { \&amp;gt;  &amp;lt;sp&amp;gt; }
    }

    # and later...

    my $text is from($*ARGS);

    print @{ $0{file}{hunk} }
        if $text =~ /&amp;lt;Diff.file&amp;gt;/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The rule definitions for &lt;code&gt;file&lt;/code&gt;, &lt;code&gt;badline&lt;/code&gt;, &lt;code&gt;linerange&lt;/code&gt;, &lt;code&gt;linenum&lt;/code&gt;, &lt;code&gt;appendline&lt;/code&gt;, &lt;code&gt;deleteline&lt;/code&gt;, &lt;code&gt;in_marker&lt;/code&gt; and &lt;code&gt;out_marker&lt;/code&gt; are exactly the same as before.&lt;/p&gt;

&lt;p&gt;All the work of reversing the diff is performed in the &lt;code&gt;hunk&lt;/code&gt; rule. To do that work, we have to extend each of the three main alternatives of that rule, adding to each a closure that changes the result object it returns.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-smarter-alternatives-smarter-alternatives-span&#34;&gt;&lt;span id=&#34;smarter_alternatives&#34;&gt;Smarter alternatives&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In the first alternative (which matches “append” hunks), we match as before:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;linenum&amp;gt; a :: &amp;lt;linerange&amp;gt; \n
    &amp;lt;appendline&amp;gt;+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But then we execute an embedded closure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    { @$appendline =~ s/&amp;lt;in_marker&amp;gt;/&amp;lt;/;
      let $0 := &amp;quot;${linerange}d${linenum}\n&amp;quot;
              _ join &amp;quot;&amp;quot;, @$appendline;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first line reverses the “marker” arrows on each line of data that was previously being appended, using the smart-match operator to apply the transformation to each line. Note too, that we reuse the &lt;code&gt;in_marker&lt;/code&gt; rule within the substitution.&lt;/p&gt;

&lt;p&gt;Then we bind the result object (i.e. the hypothetical variable &lt;code&gt;$0&lt;/code&gt;) to a string representing the “reversed” append hunk. That is, we reverse the order of the line range and line number components, put a &lt;code&gt;&#39;d&#39;&lt;/code&gt; (for “delete”) between them, and then follow that with all the reversed data:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    let $0 := &amp;quot;${linerange}d${linenum}\n&amp;quot;
            _ join &amp;quot;&amp;quot;, @$appendline;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The changes to the “delete” alternative are exactly symmetrical. Capture the components as before, reverse the marker arrows, reverse the &lt;code&gt;$linerange&lt;/code&gt; and &lt;code&gt;$linenum&lt;/code&gt;, change the &lt;code&gt;&#39;d&#39;&lt;/code&gt; to an &lt;code&gt;&#39;a&#39;&lt;/code&gt;, and append the reversed data lines.&lt;/p&gt;

&lt;p&gt;In the third alternative:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $from:=&amp;lt;linerange&amp;gt; c :: $to:=&amp;lt;linerange&amp;gt; \n
    &amp;lt;deleteline&amp;gt;+   
    --- \n
    &amp;lt;appendline&amp;gt;+
    { @$appendline =~ s/&amp;lt;in_marker&amp;gt;/&amp;lt;/;
      @$deleteline =~ s/&amp;lt;out_marker&amp;gt;/&amp;gt;/;
      let $0 := &amp;quot;${to}c${from}\n&amp;quot;
              _ join(&amp;quot;&amp;quot;, @$appendline)
              _ &amp;quot;---\n&amp;quot;
              _ join(&amp;quot;&amp;quot;, @$deleteline);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;there are line ranges on both sides of the &lt;code&gt;&#39;c&#39;&lt;/code&gt;. So we need to give them distinct names, by binding them to extra hypothetical variables: &lt;code&gt;$from&lt;/code&gt; and &lt;code&gt;$to&lt;/code&gt;. We then reverse the order of two line ranges, but leave the &lt;code&gt;&#39;c&#39;&lt;/code&gt; as it was (because we&amp;rsquo;re simply changing something back to how it was previously). The markers on both the append and delete lines are reversed, and then the order of the two sets of lines is also reversed.&lt;/p&gt;

&lt;p&gt;Once those transformations has been performed on each hunk (i.e. as it&amp;rsquo;s being matched!), the result of successfully matching any &lt;code&gt;&amp;lt;hunk&amp;gt;&lt;/code&gt; subrule will be a string in which the matched hunk has already been reversed.&lt;/p&gt;

&lt;p&gt;All that remains is to match the text against the grammar, and print out the (modified) hunks:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print @{ $0{file}{hunk} }
        if $text =~ /&amp;lt;ReverseDiff.file&amp;gt;/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And, since the &lt;code&gt;file&lt;/code&gt; rule is now in the ReverseDiff grammar&amp;rsquo;s namespace, we need to call the rule through that grammar. Note the way the syntax for doing that continues the parallel with methods and classes.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 5&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-rearranging-the-deckchairs-rearranging-the-deck-chairs-span&#34;&gt;&lt;span id=&#34;rearranging_the_deckchairs&#34;&gt;Rearranging the deck-chairs&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;It might have come as a surprise that we were allowed to bind the pattern&amp;rsquo;s &lt;code&gt;$0&lt;/code&gt; result object directly, but there&amp;rsquo;s nothing magical about it. &lt;code&gt;$0&lt;/code&gt; turns out to be just another hypothetical variable&amp;hellip;the one that happens to be returned when the match is complete.&lt;/p&gt;

&lt;p&gt;Likewise, &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, &lt;code&gt;$3&lt;/code&gt;, etc. are all hypotheticals, and can also be explicitly bound in a rule. That&amp;rsquo;s very handy for ensuring that the right substring always turns up in the right numbered variable. For example, consider a Perl 6 rule to match simple Perl 5 method calls (matching &lt;em&gt;all&lt;/em&gt; Perl 5 method calls would, of course, require a much more sophisticated rule):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule method_call :w {
        # Match direct syntax:   $var-&amp;gt;meth(...)
        \$  (&amp;lt;ident&amp;gt;)  -\&amp;gt;  (&amp;lt;ident&amp;gt;)  \(  (&amp;lt;arglist&amp;gt;)  \)

      | # Match indirect syntax: meth $var (...)
        (&amp;lt;ident&amp;gt;)  \$  (&amp;lt;ident&amp;gt;)  [ \( (&amp;lt;arglist&amp;gt;) \) | (&amp;lt;arglist&amp;gt;) ]
    }

    my ($varname, methodname, $arglist);

    if ($source_code =~ / $0 := &amp;lt;method_call&amp;gt; /) {
        $varname    = $1 // $5;
        $methodname = $2 // $4;
        $arglist    = $3 // $6 // $7;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By binding the match&amp;rsquo;s &lt;code&gt;$0&lt;/code&gt; to the result of the &lt;code&gt;&amp;lt;method_call&amp;gt;&lt;/code&gt; subrule, we bind its &lt;code&gt;$0[1]&lt;/code&gt;, &lt;code&gt;$0[2]&lt;/code&gt;, &lt;code&gt;$0[3]&lt;/code&gt;, etc. to those array elements in &lt;code&gt;&amp;lt;method_call&amp;gt;&lt;/code&gt;&amp;rsquo;s result object. And thereby bind &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, &lt;code&gt;$3&lt;/code&gt;, etc. as well. Then it&amp;rsquo;s just a matter of sorting out which numeric variable ended up with which bit of the method call.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s okay, but it would be much better if we could guarantee that the variable name was always in &lt;code&gt;$1&lt;/code&gt;, the method name in &lt;code&gt;$2&lt;/code&gt;, and the argument list in &lt;code&gt;$3&lt;/code&gt;. Then we could replace the last six lines above with just:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my ($varname, methodname, $arglist) =
            $source_code =~ / $0 := &amp;lt;method_call&amp;gt; /;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Perl 5 there was no way to do that, but in Perl 6 it&amp;rsquo;s relatively easy. We just modify the &lt;code&gt;method_call&lt;/code&gt; rule like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule method_call :w {
        \$  $1:=&amp;lt;ident&amp;gt;  -\&amp;gt;  $2:=&amp;lt;ident&amp;gt;  \( $3:=&amp;lt;arglist&amp;gt; \)
      | $2:=&amp;lt;ident&amp;gt;  \$  $1:=&amp;lt;ident&amp;gt;  [ \( $3:=&amp;lt;arglist&amp;gt; \) | $3:=&amp;lt;arglist&amp;gt; ]
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or, annotated:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule method_call :w {
        \$                          #   Match a literal $
        $1:=&amp;lt;ident&amp;gt;                 #   Match the varname, bind it to $1
        -\&amp;gt;                         #   Match a literal -&amp;gt;
        $2:=&amp;lt;ident&amp;gt;                 #   Match the method name, bind it to $2
        \(                          #   Match an opening paren
        $3:=&amp;lt;arglist&amp;gt;               #   Match the arg list, bind it to $3
        \)                          #   Match a closing paren
      |                             # Or
        $2:=&amp;lt;ident&amp;gt;                 #   Match the method name, bind it to $2
        \$                          #   Match a literal $
        $1:=&amp;lt;ident&amp;gt;                 #   Match the varname, bind it to $1
        [                           #   Either...
          \( $3:=&amp;lt;arglist&amp;gt; \)       #     Match arg list in parens, bind it to $3
        |                           #   Or...
             $3:=&amp;lt;arglist&amp;gt;          #     Just match arg list, bind it to $3
        ]
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the rule&amp;rsquo;s &lt;code&gt;$1&lt;/code&gt; is bound to the variable name, regardless of which alternative matches. Likewise &lt;code&gt;$2&lt;/code&gt; is bound to the method name in either branch of the &lt;code&gt;|&lt;/code&gt;, and &lt;code&gt;$3&lt;/code&gt; is associated with the argument list, no matter which of the &lt;em&gt;three&lt;/em&gt; possible ways it was matched.&lt;/p&gt;

&lt;p&gt;Of course, that&amp;rsquo;s still rather ugly (especially if we have to write all those comments just so others can understand how clever we were).&lt;/p&gt;

&lt;p&gt;So an even better solution is just to use proper named rules (with their handy auto-capturing behaviour) for everything. And then slice the required information out of the result object&amp;rsquo;s hash attribute:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule varname    { &amp;lt;ident&amp;gt; }
    rule methodname { &amp;lt;ident&amp;gt; }

    rule method_call :w {
        \$  &amp;lt;varname&amp;gt;  -\&amp;gt;  &amp;lt;methodname&amp;gt;  \( &amp;lt;arglist&amp;gt; \)
      | &amp;lt;methodname&amp;gt;  \$  &amp;lt;varname&amp;gt;  [ \( &amp;lt;arglist&amp;gt; \) | &amp;lt;arglist&amp;gt; ]
    }

    $source_code =~ / &amp;lt;method_call&amp;gt; /;

    my ($varname, $methodname, $arglist) =
            $0{method_call}{&amp;quot;varname&amp;quot;,&amp;quot;methodname&amp;quot;,&amp;quot;arglist&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-deriving-a-benefit-deriving-a-benefit-span&#34;&gt;&lt;span id=&#34;deriving_a_benefit&#34;&gt;Deriving a benefit&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;As the above examples illustrate, using named rules in grammars provides a cleaner syntax and a reduction in the number of variables required in a parsing program. But, beyond those advantages, and the obvious benefits of moving rule construction from run-time to compile-time, there&amp;rsquo;s yet another significant way to gain from placing named rules inside a grammar: we can &lt;em&gt;inherit&lt;/em&gt; from them.&lt;/p&gt;

&lt;p&gt;For example, the ReverseDiff grammar is almost the same as the normal Diff grammar. The only difference is in the &lt;code&gt;hunk&lt;/code&gt; rule. So there&amp;rsquo;s no reason why we shouldn&amp;rsquo;t just have ReverseDiff inherit all that sameness, and simply redefine its notion of &lt;code&gt;hunk&lt;/code&gt;-iness. That would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    grammar ReverseDiff is Diff {

        rule hunk :i { 
            [ &amp;lt;linenum&amp;gt; a :: &amp;lt;linerange&amp;gt; \n
              &amp;lt;appendline&amp;gt;+ 
              { $appendline =~ s/ &amp;lt;in_marker&amp;gt; /&amp;lt;/;
                let $0 := &amp;quot;${linerange}d${linenum}\n&amp;quot;
                        _ join &amp;quot;&amp;quot;, @$appendline;
              }
            |
              &amp;lt;linerange&amp;gt; d :: &amp;lt;linenum&amp;gt; \n
              &amp;lt;deleteline&amp;gt;+
              { $deleteline =~ s/ &amp;lt;out_marker&amp;gt; /&amp;gt;/;
                let $0 := &amp;quot;${linenum}a${linerange}\n&amp;quot;
                        _ join &amp;quot;&amp;quot;, @$deleteline;
              }
            |
              $from:=&amp;lt;linerange&amp;gt; c :: $to:=&amp;lt;linerange&amp;gt; \n
              &amp;lt;deleteline&amp;gt;+
              --- \n
              &amp;lt;appendline&amp;gt;+
              { $appendline =~ s/ &amp;lt;in_marker&amp;gt; /&amp;lt;/;
                $deleteline =~ s/ &amp;lt;out_marker&amp;gt; /&amp;gt;/;
                let $0 := &amp;quot;${to}c${from}\n&amp;quot;
                        _ join(&amp;quot;&amp;quot;, @$appendline)
                        _ &amp;quot;---\n&amp;quot;
                        _ join(&amp;quot;&amp;quot;, @$deleteline);
              }
            ]
          |
            &amp;lt;badline(&amp;quot;Invalid diff hunk&amp;quot;)&amp;gt;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;ReverseDiff is Diff&lt;/code&gt; syntax is the standard Perl 6 way of inheriting behaviour. Classes will use the same notation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Hacker is Programmer {...}
    class JAPH is Hacker {...}
    # etc.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Likewise, in the above example Diff is specified as the base grammar from which the new ReverseDiff grammar is derived. As a result of that inheritance relationship, ReverseDiff immediately inherits all of the Diff grammar&amp;rsquo;s rules. We then simple redefine ReverseDiff&amp;rsquo;s version of the &lt;code&gt;hunk&lt;/code&gt; rule, and the job&amp;rsquo;s done.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-different-diffs-different-diffs-span&#34;&gt;&lt;span id=&#34;different_diffs&#34;&gt;Different diffs&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Grammatical inheritance isn&amp;rsquo;t only useful for tweaking the behaviour of a grammar&amp;rsquo;s rules. It&amp;rsquo;s also handy when two or more related grammars share some characteristics, but differ in some particulars. For example, suppose we wanted to support the “unified” diff format, as well as the “classic”.&lt;/p&gt;

&lt;p&gt;A unified diff consists of two lines of header information, followed by a series of hunks. The header information indicates the name and modification date of the old file (prefixing the line with three minus signs), and then the name and modification date of the new file (prefixing that line with three plus signs). Each hunk consists of an offset line, followed by one or more lines representing either shared context, or a line to be inserted, or a line to be deleted. Offset lines start with two “at” signs, then consist of a minus sign followed by the old line offset and line-count, and then a plus sign followed by the nes line offset and line-count, and then two more “at” signs. Context lines are prefixed with two spaces. Insertion lines are prefixed with a plus sign and a space. Deletion lines are prefixed with a minus sign and a space.&lt;/p&gt;

&lt;p&gt;But that&amp;rsquo;s not important right now.&lt;/p&gt;

&lt;p&gt;What &lt;em&gt;is&lt;/em&gt; important is that we could write another complete grammar for that, like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    grammar Diff::Unified {

        rule file { ^  &amp;lt;fileinfo&amp;gt;  &amp;lt;hunk&amp;gt;*  $ }

        rule fileinfo {
            &amp;lt;out_marker&amp;gt;&amp;lt;3&amp;gt; $oldfile:=(\S+) $olddate:=[\h* (\N+?) \h*?] \n
            &amp;lt;in_marker&amp;gt;&amp;lt;3&amp;gt;  $newfile:=(\S+) $newdate:=[\h* (\N+?) \h*?] \n
        }

        rule hunk { 
            &amp;lt;header&amp;gt;
            @spec := ( &amp;lt;contextline&amp;gt;
                     | &amp;lt;appendline&amp;gt;
                     | &amp;lt;deleteline&amp;gt;
                     | &amp;lt;badline(&amp;quot;Invalid line for unified diff&amp;quot;)&amp;gt;
                     )*
        }

        rule header {
            \@\@ &amp;lt;out_marker&amp;gt; &amp;lt;linenum&amp;gt; , &amp;lt;linecount&amp;gt; \h+
                 &amp;lt;in_marker&amp;gt;  &amp;lt;linenum&amp;gt; , &amp;lt;linecount&amp;gt; \h+
            \@\@ \h* \n
        }

        rule badline ($errmsg) { (\N*) ::: { fail &amp;quot;$errmsg: $1&amp;quot; } }

        rule linenum   { (\d+) }
        rule linecount { (\d+) }

        rule deleteline  { ^^ &amp;lt;out_marker&amp;gt; (\N* \n) }
        rule appendline  { ^^ &amp;lt;in_marker&amp;gt;  (\N* \n) }
        rule contextline { ^^ &amp;lt;sp&amp;gt; &amp;lt;sp&amp;gt;    (\N* \n) }

        rule out_marker { \+ &amp;lt;sp&amp;gt; }
        rule in_marker  {  - &amp;lt;sp&amp;gt; }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That represents (and can parse) the new diff format correctly, but it&amp;rsquo;s a needless duplication of effort and code. Many the rules of this grammar are identical to those of the original diff parser. Which suggests we could just grab them straight from the original &amp;ndash; by inheriting them:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    grammar Diff::Unified is Diff  {

        rule file { ^  &amp;lt;fileinfo&amp;gt;  &amp;lt;hunk&amp;gt;*  $ }

        rule fileinfo {
            &amp;lt;out_marker&amp;gt;&amp;lt;3&amp;gt; $newfile:=(\S+) $olddate:=[\h* (\N+?) \h*?] \n
            &amp;lt;in_marker&amp;gt;&amp;lt;3&amp;gt;  $newfile:=(\S+) $newdate:=[\h* (\N+?) \h*?] \n
        }

        rule hunk { 
            &amp;lt;header&amp;gt;
            @spec := ( &amp;lt;contextline&amp;gt;
                     | &amp;lt;appendline&amp;gt;
                     | &amp;lt;deleteline&amp;gt;
                     | &amp;lt;badline(&amp;quot;Invalid line for unified diff&amp;quot;)&amp;gt;
                     )*
        }

        rule header {
            \@\@ &amp;lt;out_marker&amp;gt; &amp;lt;linenum&amp;gt; , &amp;lt;linecount&amp;gt; \h+
                 &amp;lt;in_marker&amp;gt;  &amp;lt;linenum&amp;gt; , &amp;lt;linecount&amp;gt; \h+
            \@\@ \h* \n
        }

        rule linecount { (\d+) }

        rule contextline { ^^ &amp;lt;sp&amp;gt; &amp;lt;sp&amp;gt;  (\N* \n) }

        rule out_marker { \+ &amp;lt;sp&amp;gt; }
        rule in_marker  {  - &amp;lt;sp&amp;gt; }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that in this version we don&amp;rsquo;t need to specify the rules for &lt;code&gt;appendline&lt;/code&gt;, &lt;code&gt;deleteline&lt;/code&gt;, &lt;code&gt;linenum&lt;/code&gt;, etc. They&amp;rsquo;re provided automagically by inheriting from the &lt;code&gt;Diff&lt;/code&gt; grammar. So we only have to specify the parts of the new grammar that differ from the original.&lt;/p&gt;

&lt;p&gt;In particular, this is where we finally reap the reward for factoring out the &lt;code&gt;in_marker&lt;/code&gt; and &lt;code&gt;out_marker&lt;/code&gt; rules. Because we did that earlier, we can now just change the rules for matching those two markers directly in the new grammar. As a result, the inherited &lt;code&gt;appendline&lt;/code&gt; and &lt;code&gt;deleteline&lt;/code&gt; rules (which use &lt;code&gt;in_marker&lt;/code&gt; and &lt;code&gt;out_marker&lt;/code&gt; as subrules) will now attempt to match the new versions of &lt;code&gt;in_marker&lt;/code&gt; and &lt;code&gt;out_marker&lt;/code&gt; rules instead.&lt;/p&gt;

&lt;p&gt;And if you&amp;rsquo;re thinking that looks suspiciously like polymorphism, you&amp;rsquo;re absolutely right. The parallels between pattern matching and OO run &lt;em&gt;very&lt;/em&gt; deep in Perl 6.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-lets-get-cooking-let-s-get-cooking-span&#34;&gt;&lt;span id=&#34;lets_get_cooking&#34;&gt;Let&amp;rsquo;s get cooking&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;To sum up: Perl 6 patterns and grammars extend Perl&amp;rsquo;s text matching capacities enormously. But you don&amp;rsquo;t have to start using all that extra power right away. You can ignore grammars and embedded closures and assertions and the other sophisticated bits until you actually need them.&lt;/p&gt;

&lt;p&gt;The new rule syntax also cleans up much of the “line-noise” of Perl 5 regexes. But the fundamentals don&amp;rsquo;t change that much. Many Perl 5 patterns will translate very simply and naturally to Perl 6.&lt;/p&gt;

&lt;p&gt;To demonstrate that, and to round out this exploration of Perl 6 patterns, here are a few common Perl 5 regexes &amp;ndash; some borrowed from the &lt;em&gt;Perl Cookbook&lt;/em&gt;, and others from the Regexp::Common module &amp;ndash; all ported to equivalent Perl 6 rules:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_Match_a_C_comment%3A&#34;&gt;Match a C comment:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Perl 5
$str =~ m{ /\* .*? \*/ }xs;

# Perl 6
$str =~ m{ /\* .*? \*/ };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_Remove_leading_qualifiers_from_a_Perl_identifier&#34;&gt;Remove leading qualifiers from a Perl identifier&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Perl 5
$ident =~ s/^(?:\w*::)*//;

# Perl 6
$ident =~ s/^[\w*\:\:]*//;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_Warn_of_text_with_lines_greater_than_80_characters&#34;&gt;Warn of text with lines greater than 80 characters&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Perl 5
warn &amp;quot;Thar she blows!: $&amp;amp;&amp;quot;
        if $str =~ m/.{81,}/;

# Perl 6
warn &amp;quot;Thar she blows!: $0&amp;quot;
        if $str =~ m/\N&amp;lt;81,&amp;gt;/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_Match_a_Roman_numeral&#34;&gt;Match a Roman numeral&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Perl 5
$str =~ m/ ^ m* (?:d?c{0,3}|c[dm]) (?:l?x{0,3}|x[lc]) (?:v?i{0,3}|i[vx]) $ /ix;

# Perl 6
$str =~ m:i/ ^ m* [d?c&amp;lt;0,3&amp;gt;|c&amp;lt;[dm]&amp;gt;] [l?x&amp;lt;0,3&amp;gt;|x&amp;lt;[lc]&amp;gt;] [v?i&amp;lt;0,3&amp;gt;|i&amp;lt;[vx]&amp;gt;] $ /;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_Extract_lines_regardless_of_line_terminator&#34;&gt;Extract lines regardless of line terminator&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Perl 5
push @lines, $1
        while $str =~ m/\G([^\012\015]*)(?:\012\015?|\015\012?)/gc;

# Perl 6
push @lines, $1
        while $str =~ m:c/ (\N*) \n /;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_string&#34;&gt;Match a quote-delimited string (Friedl-style), capturing contents:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Perl 5
$str =~ m/ &amp;quot; ( [^\\&amp;quot;]* (?: \\. [^\\&amp;quot;]* )* ) &amp;quot; /x;

# Perl 6
$str =~ m/ &amp;quot; ( &amp;lt;-[\\&amp;quot;]&amp;gt;* [ \\. &amp;lt;-[\\&amp;quot;]&amp;gt;* ]* ) &amp;quot; /;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_Match_a_decimal_IPv4_address%3A&#34;&gt;Match a decimal IPv4 address:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Perl 5
my $quad = qr/(?: 25[0-5] | 2[0-4]\d | [0-1]??\d{1,2} )/x;

$str =~ m/ $quad \. $quad \. $quad \. $quad /x;

# Perl 6
rule quad {  (\d&amp;lt;1,3&amp;gt;) :: { fail unless $1 &amp;lt; 256 }  }

$str =~ m/ &amp;lt;quad&amp;gt; &amp;lt;dot&amp;gt; &amp;lt;quad&amp;gt; &amp;lt;dot&amp;gt; &amp;lt;quad&amp;gt; &amp;lt;dot&amp;gt; &amp;lt;quad&amp;gt; /x;

# Perl 6 (same great approach, now less syntax)
rule quad {  (\d&amp;lt;1,3&amp;gt;) :: &amp;lt;($1 &amp;lt; 256)&amp;gt;  }

$str =~ m/ &amp;lt;quad&amp;gt; &amp;lt;dot&amp;gt; &amp;lt;quad&amp;gt; &amp;lt;dot&amp;gt; &amp;lt;quad&amp;gt; &amp;lt;dot&amp;gt; &amp;lt;quad&amp;gt; /x;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_Match_a_floating%2Dpoint_number%2C_returning_compo&#34;&gt;Match a floating-point number, returning components:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Perl 5
($sign, $mantissa, $exponent) =
        $str =~ m/([+-]?)([0-9]+\.?[0-9]*|\.[0-9]+)(?:e([+-]?[0-9]+))?/;

# Perl 6
($sign, $mantissa, $exponent) =
        $str =~ m/(&amp;lt;[+-]&amp;gt;?)(&amp;lt;[0-9]&amp;gt;+\.?&amp;lt;[0-9]&amp;gt;*|\.&amp;lt;[0-9]&amp;gt;+)[e(&amp;lt;[+-]&amp;gt;?&amp;lt;[0-9]&amp;gt;+)]?/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_Match_a_floating%2Dpoint_number_maintainably%2C_re&#34;&gt;Match a floating-point number &lt;em&gt;maintainably&lt;/em&gt;, returning components:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Perl 5
my $digit    = qr/[0-9]/;
my $sign_pat = qr/(?: [+-]? )/x;
my $mant_pat = qr/(?: $digit+ \.? $digit* | \. digit+ )/x;
my $expo_pat = qr/(?: $signpat $digit+ )? /x;

($sign, $mantissa, $exponent) =
        $str =~ m/ ($sign_pat) ($mant_pat) (?: e ($expo_pat) )? /x;

# Perl 6
rule sign     { &amp;lt;[+-]&amp;gt;? }
rule mantissa { &amp;lt;digit&amp;gt;+ [\. &amp;lt;digit&amp;gt;*] | \. &amp;lt;digit&amp;gt;+ }
rule exponent { [ &amp;lt;sign&amp;gt; &amp;lt;digit&amp;gt;+ ]? }

($sign, $mantissa, $exponent) = 
        $str =~ m/ (&amp;lt;sign&amp;gt;) (&amp;lt;mantissa&amp;gt;) [e (&amp;lt;exponent&amp;gt;)]? /;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_Match_nested_parentheses%3A&#34;&gt;Match nested parentheses:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Perl 5
our $parens = qr/ \(  (?: (?&amp;gt;[^()]+) | (??{$parens}) )*  \) /x;
$str =~ m/$parens/;

# Perl 6
$str =~ m/ \(  [ &amp;lt;-[()]&amp;gt; + : | &amp;lt;self&amp;gt; ]*  \) /;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_Match_nested_parentheses_maintainably%3A&#34;&gt;Match nested parentheses &lt;em&gt;maintainably&lt;/em&gt;:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Perl 5
our $parens = qr/
           \(                   # Match a literal &#39;(&#39;
           (?:                  # Start a non-capturing group
               (?&amp;gt;              #     Never backtrack through...
                   [^()] +      #         Match a non-paren (repeatedly)
               )                #     End of non-backtracking region
           |                    # Or
               (??{$parens})    #    Recursively match entire pattern
           )*                   # Close group and match repeatedly
           \)                   # Match a literal &#39;)&#39;
         /x;

$str =~ m/$parens/;

# Perl 6
$str =~ m/ &amp;lt;&#39;(&#39;&amp;gt;                # Match a literal &#39;(&#39;
           [                    # Start a non-capturing group
                &amp;lt;-[()]&amp;gt; +       #    Match a non-paren (repeatedly)
                :               #    ...and never backtrack that match
           |                    # Or
                &amp;lt;self&amp;gt;          #    Recursively match entire pattern
           ]*                   # Close group and match repeatedly
           &amp;lt;&#39;)&#39;&amp;gt;                # Match a literal &#39;)&#39;
         /;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;Return to the &lt;a href=&#34;http://localhost:1313/&#34;&gt;Perl.com&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Synopsis 5</title>
      <link>http://localhost:1313/pub/2002/06/26/synopsis5.html/</link>
      <pubDate>Wed, 26 Jun 2002 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2002/06/26/synopsis5.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 5&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-summary-of-the-changes-in-apocalypse-5&#34;&gt;A summary of the changes in Apocalypse 5:&lt;/h3&gt;

&lt;h3 id=&#34;span-id-unchanged-features-unchanged-features-span&#34;&gt;&lt;span id=&#34;unchanged_features&#34;&gt;Unchanged features&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Capturing: (&amp;hellip;)&lt;/li&gt;
&lt;li&gt;Repetition quantifiers: *, +, and ?&lt;/li&gt;
&lt;li&gt;Alternatives: |&lt;/li&gt;
&lt;li&gt;Backslash escape: &lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Minimal matching suffix: ??, *?, +?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;span-id-modifiers-modifiers-span&#34;&gt;&lt;span id=&#34;modifiers&#34;&gt;Modifiers&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The extended syntax (&lt;code&gt;/x&lt;/code&gt;) is no longer required&amp;hellip;it&amp;rsquo;s the default.&lt;/li&gt;
&lt;li&gt;There are no &lt;code&gt;/s&lt;/code&gt; or &lt;code&gt;/m&lt;/code&gt; modifiers (changes to the meta-characters replace them - see below).&lt;/li&gt;
&lt;li&gt;There is no &lt;code&gt;/e&lt;/code&gt; evaluation modifier on substitutions; use &lt;code&gt;s/pattern/$( code() )/&lt;/code&gt; instead.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;/g&lt;/code&gt; modifier has been renamed to &lt;code&gt;e&lt;/code&gt; (for &lt;code&gt;each&lt;/code&gt;).&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Modifiers are now placed as adverbs at the &lt;em&gt;start&lt;/em&gt; of a match/substitution:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @matches = m:ei/\s* (\w*) \s* ,?/;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The single-character modifiers also have longer versions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        :i        :ignorecase
        :e        :each
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;code&gt;:c&lt;/code&gt; (or &lt;code&gt;:cont&lt;/code&gt;) modifier causes the match to continue from the string&amp;rsquo;s current &lt;code&gt;.pos&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    m:c/ pattern /        # start at end of
                          # previous match on $_
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The new &lt;code&gt;:o&lt;/code&gt; (&lt;code&gt;:once&lt;/code&gt;) modifier replaces the Perl 5 &lt;code&gt;?...?&lt;/code&gt; syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    m:once/ pattern /    # only matches first time
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The new &lt;code&gt;:w&lt;/code&gt; (&lt;code&gt;:word&lt;/code&gt;) modifier causes whitespace sequences to be replaced by &lt;code&gt;\s*&lt;/code&gt; or &lt;code&gt;\s+&lt;/code&gt; subpattern:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    m:w/ next cmd =   &amp;lt;condition&amp;gt;/
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Same as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    m/ \s* next \s+ cmd \s* = \s* &amp;lt;condition&amp;gt;/
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The new &lt;code&gt;:uN&lt;/code&gt; modifier specifies Unicode level:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    m:u0/ .&amp;lt;2&amp;gt; /        # match two bytes
    m:u1/ .&amp;lt;2&amp;gt; /        # match two codepoints
    m:u2/ .&amp;lt;2&amp;gt; /        # match two graphemes
    m:u3/ .&amp;lt;2&amp;gt; /        # match language dependently
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The new &lt;code&gt;:p5&lt;/code&gt; modifier allows Perl 5 regex syntax to be used instead:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    m:p5/(?mi)^[a-z]{1,2}(?=\s)/
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Any integer modifier specifies a count. What kind of count is determined by the character that follows.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If followed by an &lt;code&gt;x&lt;/code&gt;, it means repetition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s:4x{ (&amp;lt;ident&amp;gt;) = (\N+) $$}{$1 =&amp;gt; $2};

    # same as:

    s{ (&amp;lt;ident&amp;gt;) = (\N+) $$}{$1 =&amp;gt; $2} for 1..4;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If followed by an &lt;code&gt;st&lt;/code&gt;, &lt;code&gt;nd&lt;/code&gt;, &lt;code&gt;rd&lt;/code&gt;, or &lt;code&gt;th&lt;/code&gt;, it means find the *N*th occurance:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s:3rd/(\d+)/@data[$1]/;

    # same as:

    m/(\d+)/ &amp;amp;&amp;amp; m:c/(\d+)/ &amp;amp;&amp;amp; s:c/(\d+)/@data[$1]/;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;With the new &lt;code&gt;:any&lt;/code&gt; modifier, the regex will match every possible way (including overlapping) and return all matches.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $str = &amp;quot;abracadabra&amp;quot;;

    @substrings = $str =~ m:any/ a (.*) a /;

    # br brac bracad bracadabr c cad cadabr d dabr br
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;code&gt;:i&lt;/code&gt;, &lt;code&gt;:w&lt;/code&gt;, &lt;code&gt;:c&lt;/code&gt;, &lt;code&gt;:uN&lt;/code&gt;, and &lt;code&gt;:p5&lt;/code&gt; modifiers can be placed inside the regex (and are lexically scoped):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    m/:c alignment = [:i left|right|cent[er|re]] /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;User-defined modifiers will be possible&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        m:fuzzy/pattern/;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Single letter flags can be ``chained&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        s:ewi/cat/feline/
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;User-defined modifiers can also take arguments:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        m:fuzzy(&#39;bare&#39;)/pattern/;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Hence parentheses are no longer valid regex delimiters&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 5&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-changed-metacharacters-changed-metacharacters-span&#34;&gt;&lt;span id=&#34;changed_metacharacters&#34;&gt;Changed metacharacters&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;A dot &lt;code&gt;.&lt;/code&gt; now matches &lt;em&gt;any&lt;/em&gt; character including newline. (The &lt;code&gt;/s&lt;/code&gt; modifier is gone.)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; now always match the start/end of a string, like the old &lt;code&gt;\A&lt;/code&gt; and &lt;code&gt;\z&lt;/code&gt;. (The &lt;code&gt;/m&lt;/code&gt; modifier is gone.)&lt;/li&gt;
&lt;li&gt;A &lt;code&gt;$&lt;/code&gt; no longer matches an optional preceding &lt;code&gt;\n&lt;/code&gt; so it&amp;rsquo;s necessary to say &lt;code&gt;\n?$&lt;/code&gt; if that&amp;rsquo;s what you mean.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\n&lt;/code&gt; now matches a logical (platform independent) newline not just &lt;code&gt;\012&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;\A&lt;/code&gt;, &lt;code&gt;\Z&lt;/code&gt;, and &lt;code&gt;\z&lt;/code&gt; metacharacters are gone.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-new-metacharacters-new-metacharacters-span&#34;&gt;&lt;span id=&#34;new_metacharacters&#34;&gt;New metacharacters&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Because &lt;code&gt;/x&lt;/code&gt; is default:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#&lt;/code&gt; now always introduces a comment.&lt;/li&gt;
&lt;li&gt;Whitespace is now always metasyntactic, i.e. used only for layout and not matched literally (but see the :w modifier described above).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^^&lt;/code&gt; and &lt;code&gt;$$&lt;/code&gt; match line beginnings and endings. (The &lt;code&gt;/m&lt;/code&gt; modifier is gone.)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt; matches an ``anything&amp;rdquo;, while &lt;code&gt;\N&lt;/code&gt; matches an ``anything except newline&amp;rdquo;. (The &lt;code&gt;/s&lt;/code&gt; modifier is gone.)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-bracket-rationalization-bracket-rationalization-span&#34;&gt;&lt;span id=&#34;bracket_rationalization&#34;&gt;Bracket rationalization&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(...)&lt;/code&gt; still delimits a capturing group.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[...]&lt;/code&gt; is no longer a character class.&lt;/li&gt;
&lt;li&gt;It now delimits a non-capturing group.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{...}&lt;/code&gt; is no longer a repetition quantifier.&lt;/li&gt;
&lt;li&gt;It now delimits an embedded closure.&lt;/li&gt;
&lt;li&gt;You can call Perl code as part of a regex match.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Embedded code does not usually affect the match - it is only used for side-effects:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / (\S+) { print &amp;quot;string not blank\n&amp;quot;; $text = $1; }
       \s+  { print &amp;quot;but does contain whitespace\n&amp;quot; }
    /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It can affect the match if it calls &lt;code&gt;fail&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / (\d+) {$1&amp;lt;256 or fail} /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; are now extensible metasyntax delimiters or ``assertions&amp;rdquo; (i.e. they replace &lt;code&gt;(?...)&lt;/code&gt;).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-variable-non-interpolation-variable-non-interpolation-span&#34;&gt;&lt;span id=&#34;variable_(non)interpolation&#34;&gt;Variable (non-)interpolation&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;In Perl 6 regexes, variables don&amp;rsquo;t interpolate.&lt;/li&gt;
&lt;li&gt;Instead they&amp;rsquo;re passed ``raw&amp;rdquo; to the regex engine, which can then decide how to handle them (more on that below).&lt;/li&gt;
&lt;li&gt;The default way in which the engine handles a scalar is to match it as a \Q[&amp;hellip;] literal (i.e.it does not treat the interpolated string as a subpattern).&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In other words, a Perl 6: / $var /&lt;/p&gt;

&lt;p&gt;is like a Perl 5: / \Q$var\E /&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;(To get regex interpolation use an assertion - see below)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;An interpolated array:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / @cmds /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is matched as if it were an alternation of its elements:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / [ @cmds[0] | @cmds[1] | @cmds[2] | ... ] /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;And, of course, each one is matched as a literal.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;An interpolated hash matches a &lt;code&gt;/\w+/&lt;/code&gt; and then requires that sequence to be a valid key of the hash.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;So:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / %cmds /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;is like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / (\w+) { fail unless exists %cmds{$1} } /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-extensible-metasyntax-extensible-metasyntax-span&#34;&gt;&lt;span id=&#34;extensible_metasyntax_(&lt;...&gt;)&amp;ldquo;&amp;gt;Extensible metasyntax (&lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt;)&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The first character after &lt;code&gt;&amp;lt;&lt;/code&gt; determines the behaviour of the assertion.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A leading alphabetic character means it&amp;rsquo;s a grammatical assertion (i.e. a subpattern or a named character class - see below):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / &amp;lt;sign&amp;gt;? &amp;lt;mantissa&amp;gt; &amp;lt;exponent&amp;gt;? /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The special named assertions include:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / &amp;lt;before pattern&amp;gt; /    # was /(?=pattern)/
    / &amp;lt;after pattern&amp;gt; /     # was /(?&amp;lt;pattern)/ 
                            # but now a real pattern!

    / &amp;lt;ws&amp;gt; /                # match any whitespace

    / &amp;lt;sp&amp;gt; /                # match a space char
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A leading number, pair of numbers, or pair of scalars means it&amp;rsquo;s a repetition specifier:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / value was (\d&amp;lt;1,6&amp;gt;) with (\w&amp;lt;$m,$n&amp;gt;) /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A leading &lt;code&gt;$&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, or &lt;code&gt;&amp;amp;&lt;/code&gt; interpolates a variable or subroutine return value as a regex rather than as a literal:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / &amp;lt;$key_pat&amp;gt; = &amp;lt;@value_alternatives&amp;gt; /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A leading &lt;code&gt;(&lt;/code&gt; indicates a code assertion:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / (\d&amp;lt;1,3&amp;gt;) &amp;lt;( $1 &amp;lt; 256 )&amp;gt; /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Same as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / (\d&amp;lt;1,3&amp;gt;) {$1&amp;lt;256 or fail} /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A leading &lt;code&gt;{&lt;/code&gt; indicates code that produces a regex to be interpolated into the pattern at that point:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / (&amp;lt;ident&amp;gt;)  &amp;lt;{ cache{$1} //= get_body($1) }&amp;gt; /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A leading &lt;code&gt;[&lt;/code&gt; indicates an enumerated character class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / &amp;lt;[a-z_]&amp;gt;* /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A leading &lt;code&gt;-&lt;/code&gt; indicates a complemented character class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / &amp;lt;-[a-z_]&amp;gt; &amp;lt;-&amp;lt;alpha&amp;gt;&amp;gt; /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A leading &lt;code&gt;&#39;&lt;/code&gt; indicates an interpolated literal match (including whitespace):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / &amp;lt;&#39;match this exactly (whitespace matters)&#39;&amp;gt; /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The special assertion &lt;code&gt;&amp;lt;.&amp;gt;&lt;/code&gt; matches any logical grapheme (including a Unicode combining character sequences):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / seekto = &amp;lt;.&amp;gt; /  # Maybe a combined char
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A leading &lt;code&gt;!&lt;/code&gt; indicates a negated meaning (a zero-width assertion except for repetition specifiers):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / &amp;lt;!before _&amp;gt;    # We aren&#39;t before an _
      \w&amp;lt;!1,3&amp;gt;       # We match 0 or &amp;gt;3 word chars
    /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 5&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-backslash-reform-backslash-reform-span&#34;&gt;&lt;span id=&#34;backslash_reform&#34;&gt;Backslash reform&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;\p&lt;/code&gt; and &lt;code&gt;\P&lt;/code&gt; properties become intrinsic grammar rules (&lt;code&gt;&amp;lt;prop ...&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;!prop ...&amp;gt;&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;\L...\E&lt;/code&gt;, &lt;code&gt;\U...\E&lt;/code&gt;, and &lt;code&gt;\Q...\E&lt;/code&gt; sequences become &lt;code&gt;\L[...]&lt;/code&gt;, &lt;code&gt;\U[...]&lt;/code&gt;, and &lt;code&gt;\Q[...]&lt;/code&gt; (&lt;code&gt;\E&lt;/code&gt; is gone).&lt;/li&gt;
&lt;li&gt;Note that &lt;code&gt;\Q[...]&lt;/code&gt; will rarely be needed since raw variables interpolate as &lt;code&gt;eq&lt;/code&gt; matches, rather than regexes.&lt;/li&gt;
&lt;li&gt;Backreferences (e.g. &lt;code&gt;\1&lt;/code&gt;) are gone; &lt;code&gt;$1&lt;/code&gt; can be used instead, because it&amp;rsquo;s no longer interpolated.&lt;/li&gt;
&lt;li&gt;New backslash sequences, &lt;code&gt;\h&lt;/code&gt; and &lt;code&gt;\v&lt;/code&gt;, match horizontal and vertical whitespace respectively, including Unicode.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\s&lt;/code&gt; now matches any Unicode whitespace character.&lt;/li&gt;
&lt;li&gt;The new backslash sequence &lt;code&gt;\N&lt;/code&gt; matches anything except a logical newline; it is the negation of &lt;code&gt;\n&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;A series of other new capital backslash sequences are also the negation of their lower-case counterparts:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;\H&lt;/code&gt; matches anything but horizontal whitespace.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\V&lt;/code&gt; matches anything but vertical whitespace.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\T&lt;/code&gt; matches anything but a tab.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\R&lt;/code&gt; matches anything but a return.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\F&lt;/code&gt; matches anything but a formfeed.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\E&lt;/code&gt; matches anything but an escape.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\X...&lt;/code&gt; matches anything but the specified hex character.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-regexes-are-rules-regexes-are-rules-span&#34;&gt;&lt;span id=&#34;regexes_are_rules&#34;&gt;Regexes are rules&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The Perl 5 &lt;code&gt;qr/pattern/&lt;/code&gt; regex constructor is gone.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The Perl 6 equivalents are:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule { pattern }    # always takes {...} as delimiters
    rx/ pattern /       # can take (almost any) chars as delimiters
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If either needs modifiers, they go before the opening delimiter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $regex = rule :ewi { my name is (.*) };
    $regex = rx:ewi/ my name is (.*) /;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The name of the constructor was changed from &lt;code&gt;qr&lt;/code&gt; because it&amp;rsquo;s no longer an interpolating quote-like operator.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;As the syntax indicates, it is now more closely analogous to a &lt;code&gt;sub {...}&lt;/code&gt; constructor.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In fact, that analogy will run &lt;em&gt;very&lt;/em&gt; deep in Perl 6.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Just as a raw &lt;code&gt;{...}&lt;/code&gt; is now always a closure (which may still execute immediately in certain contexts and be passed as a reference in others)&amp;hellip;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;hellip;so too a raw &lt;code&gt;/.../&lt;/code&gt; is now always a regex (which may still match immediately in certain contexts and be passed as a reference in others).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Specifically, a &lt;code&gt;/.../&lt;/code&gt; matches immediately in a void or Boolean context, or when it is an explicit argument of a &lt;code&gt;=~&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Otherwise it&amp;rsquo;s a regex constructor.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;So this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $var = /pattern/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;no longer does the match and sets &lt;code&gt;$var&lt;/code&gt; to the result.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Instead it assigns a regex reference to &lt;code&gt;$var&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The two cases can always be distinguished using &lt;code&gt;m{...}&lt;/code&gt; or &lt;code&gt;rx{...}&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $var = m{pattern};    # Match regex, assign result
    $var = rx{pattern};   # Assign regex itself
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Note that this means that former magically lazy usages like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @list = split /pattern/, $str;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;are now just consequences of the normal semantics.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It&amp;rsquo;s now also possible to set up a user-defined subroutine that acts like grep:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub my_grep($selector, *@list) {
        given $selector {
            when RULE  { ... }
            when CODE  { ... }
            when HASH  { ... }
            # etc.
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Using &lt;code&gt;{...}&lt;/code&gt; or &lt;code&gt;/.../&lt;/code&gt; in the scalar context of the first argument causes it to produce a &lt;code&gt;CODE&lt;/code&gt; or &lt;code&gt;RULE&lt;/code&gt; reference, which the switch statement then selects upon.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-backtracking-control-backtracking-control-span&#34;&gt;&lt;span id=&#34;backtracking_control&#34;&gt;Backtracking control&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Backtracking over a single colon causes the regex engine not to retry the preceding atom:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    m:w/ \( &amp;lt;expr&amp;gt; [ , &amp;lt;expr&amp;gt; ]* : \) /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(i.e. there&amp;rsquo;s no point trying fewer &lt;code&gt;&amp;lt;expr&amp;gt;&lt;/code&gt; matches, if there&amp;rsquo;s no closing parenthesis on the horizon)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Backtracking over a double colon causes the surrounding group to immediately fail:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    m:w/ [ if :: &amp;lt;expr&amp;gt; &amp;lt;block&amp;gt;
         | for :: &amp;lt;list&amp;gt; &amp;lt;block&amp;gt;
         | loop :: &amp;lt;loop_controls&amp;gt;? &amp;lt;block&amp;gt;
         ]
    /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(i.e. there&amp;rsquo;s no point trying to match a different keyword if one was already found but failed)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Backtracking over a triple colon causes the current rule to fail outright (no matter where in the rule it occurs):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule ident {
          ( [&amp;lt;alpha&amp;gt;|_] \w* ) ::: { fail if %reserved{$1} }
        | &amp;quot; [&amp;lt;alpha&amp;gt;|_] \w* &amp;quot;
    }

    m:w/ get &amp;lt;ident&amp;gt;? /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(i.e. using an unquoted reserved word as an identifier is not permitted)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Backtracking over a &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; assertion causes the entire match to fail outright, no matter how many subrules down it happens:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule subname {
        ([&amp;lt;alpha&amp;gt;|_] \w*) &amp;lt;commit&amp;gt; { fail if %reserved{$1} }
    }
    m:w/ sub &amp;lt;subname&amp;gt;? &amp;lt;block&amp;gt; /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(i.e. using a reserved word as a subroutine name is instantly fatal to the ``surrounding&amp;rdquo; match as well)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A &amp;lt;cut&amp;gt; assertion always matches successfully, and has the side effect of deleting the parts of the string already matched.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Attempting to backtrack past a &amp;lt;cut&amp;gt; causes the complete match to fail (like backtracking past a &amp;lt;commit&amp;gt;. This is because there&amp;rsquo;s now no preceding text to backtrack into.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This is useful for throwing away successfully processed input when matching from an input stream or an iterator of arbitrary length.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 5&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-named-regexes-named-regexes-span&#34;&gt;&lt;span id=&#34;named_regexes&#34;&gt;Named Regexes&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The analogy between &lt;code&gt;sub&lt;/code&gt; and &lt;code&gt;rule&lt;/code&gt; extends much further.&lt;/li&gt;
&lt;li&gt;Just as you can have anonymous subs and named subs&amp;hellip;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;hellip;so too you can have anonymous regexes and &lt;em&gt;named&lt;/em&gt; regexes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule ident { [&amp;lt;alpha&amp;gt;|_] \w* }

    # and later...

    @ids = grep /&amp;lt;ident&amp;gt;/, @strings;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;As the above example indicates, it&amp;rsquo;s possible to refer to named regexes, such as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule serial_number { &amp;lt;[A-Z]&amp;gt; \d&amp;lt;8&amp;gt; })
    rule type { alpha | beta | production | deprecated | legacy }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in other regexes as named assertions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule identification { [soft|hard]ware &amp;lt;type&amp;gt; &amp;lt;serial_number&amp;gt; }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-nothing-is-illegal-nothing-is-illegal-span&#34;&gt;&lt;span id=&#34;nothing_is_illegal&#34;&gt;Nothing is illegal&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The null pattern is now illegal.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To match whatever the prior successful regex matched, use:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /&amp;lt;prior&amp;gt;/
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To match the zero-width string, use:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /&amp;lt;null&amp;gt;/
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-hypothetical-variables-hypothetical-variables-span&#34;&gt;&lt;span id=&#34;hypothetical_variables&#34;&gt;Hypothetical variables&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;In embedded closures it&amp;rsquo;s possible to bind a variable to a value that only ``sticks&amp;rdquo; if the surrounding pattern successfully matches.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A variable is declared with the keyword &lt;code&gt;let&lt;/code&gt; and then bound to the desired value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / (\d+) {let $num := $1} (&amp;lt;alpha&amp;gt;+)/
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Now &lt;code&gt;$num&lt;/code&gt; will only be bound if the digits are actually found.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If the match ever backtracks past the closure (i.e. if there are no alphabetics following), the binding is ``undone&amp;rdquo;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This is even more interesting in alternations:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / [ (\d+)      { let $num   := $1 }
      | (&amp;lt;alpha&amp;gt;+) { let $alpha := $2 }
      | (.)        { let $other := $3 }
      ]
    /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;There is also a shorthand for assignment to hypothetical variables:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / [ $num  := (\d+)
      | $alpha:= (&amp;lt;alpha&amp;gt;+)
      | $other:=(.)
      ]
    /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The numeric variables (&lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, etc.) are also ``hypothetical&amp;rdquo;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Numeric variables can be assigned to, and even re-ordered:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my ($key, $val) = m:w{ $1:=(\w+) =\&amp;gt; $2:=(.*?)
                         | $2:=(.*?) \&amp;lt;= $1:=(\w+)
                         };
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Repeated captures can be bound to arrays:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / @values:=[ (.*?) , ]* /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Pairs of repeated captures can be bound to hashes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / %options:=[ (&amp;lt;ident&amp;gt;) = (\N+) ]* /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Or just capture the keys (and leave the values undef):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / %options:=[ (&amp;lt;ident&amp;gt;) = \N+ ]* /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Subrules (e.g. &lt;code&gt;&amp;lt;rule&amp;gt;&lt;/code&gt;) also capture their result in a hypothetical variable of the same name as the rule:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / &amp;lt;key&amp;gt; =\&amp;gt; &amp;lt;value&amp;gt; { %hash{$key} = $value } /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-return-values-from-matches-return-values-from-matches-span&#34;&gt;&lt;span id=&#34;return_values_from_matches&#34;&gt;Return values from matches&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;A match always returns a ``match object&amp;rdquo;, which is also available as (lexical) &lt;code&gt;$0&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The match object evaluates differently in different contexts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;in boolean context it evaluates as true or false (i.e. did the match succeed?):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if /pattern/ {...}
    # or:
    /pattern/; if $0 {...}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;in numeric context it evaluates to the number of matches:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $match_count += m:e/pattern/;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;in string context it evaluates to the captured substring (if there was exactly one capture in the pattern) or to the entire text that was matched (if the pattern does not capture, or captures multiple elements):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print %hash{$text =~ /,? (&amp;lt;ident&amp;gt;)/};
    # or: 
    $text =~ /,? (&amp;lt;ident&amp;gt;)/  &amp;amp;&amp;amp;  print %hash{$0};
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;Within&lt;/em&gt; a regex, &lt;code&gt;$0&lt;/code&gt; acts like a hypothetical variable.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It controls what a regex match returns (like &lt;code&gt;$$&lt;/code&gt; does in yacc)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use &lt;code&gt;$0:=&lt;/code&gt; to override the default return behaviour described above:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule string1 { (&amp;lt;[&amp;quot;&#39;`]&amp;gt;) ([ \\. | &amp;lt;-[\\]&amp;gt; ]*?) $1 }

    $match = m/&amp;lt;string1&amp;gt;/;  # default: $match includes 
                            # opening and closing quotes

    rule string2 { (&amp;lt;[&amp;quot;&#39;`]&amp;gt;) $0:=([ \\. | &amp;lt;-[\\]&amp;gt; ]*?) $1 }

    $match = m/&amp;lt;string2&amp;gt;/;  # $match now excludes quotes
                            # because $0 explicitly bound 
                            # to second capture only
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 5&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-matching-against-nonstrings-matching-against-non-strings-span&#34;&gt;&lt;span id=&#34;matching_against_nonstrings&#34;&gt;Matching against non-strings&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Anything that can be tied to a string can be matched against a regex. This feature is particularly useful with input streams:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @array := &amp;lt;$fh&amp;gt;;           # lazy when aliased
    my $array is from(\@array);   # tie scalar

    # and later...

    $array =~ m/pattern/;         # match from stream
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-grammars-grammars-span&#34;&gt;&lt;span id=&#34;grammars&#34;&gt;Grammars&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Potential ``collision&amp;rdquo; problem with named regexes&lt;/li&gt;
&lt;li&gt;Of course, a named &lt;code&gt;ident&lt;/code&gt; regex shouldn&amp;rsquo;t clobber someone else&amp;rsquo;s &lt;code&gt;ident&lt;/code&gt; regex.&lt;/li&gt;
&lt;li&gt;So some mechanism is needed to confine regexes to a namespace.&lt;/li&gt;
&lt;li&gt;If subs are the model for rules, then modules/classes are the obvious model for aggregating them.&lt;/li&gt;
&lt;li&gt;Such collections of rules are generally known as ``grammars&amp;rdquo;.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Just as a class can collect named actions together:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Identity {
        method name { &amp;quot;Name = $.name&amp;quot; }
        method age  { &amp;quot;Age  = $.age&amp;quot;  }
        method addr { &amp;quot;Addr = $.addr&amp;quot; }

        method desc {
            print .name(), &amp;quot;\n&amp;quot;,
                  .age(),  &amp;quot;\n&amp;quot;,
                  .addr(), &amp;quot;\n&amp;quot;;
        }

        # etc.
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;So too a grammar can collect a set of named rules together:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    grammar Identity {
        rule name :w { Name = (\N+) }
        rule age  :w { Age  = (\d+) }
        rule addr :w { Addr = (\N+) }
        rule desc {
            &amp;lt;name&amp;gt; \n
            &amp;lt;age&amp;gt;  \n
            &amp;lt;addr&amp;gt; \n
        }

        # etc.
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Like classes, grammars can inherit:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    grammar Letter {
        rule text     { &amp;lt;greet&amp;gt; &amp;lt;body&amp;gt; &amp;lt;close&amp;gt; }

        rule greet :w { [Hi|Hey|Yo] $to:=(\S+?) , $$}

        rule body     { &amp;lt;line&amp;gt;+ }

        rule close :w { Later dude, $from:=(.+) }

        # etc.
    }

    grammar FormalLetter is Letter {

        rule greet :w { Dear $to:=(\S+?) , $$}

        rule close :w { Yours sincerely, $from:=(.+) }

    }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Inherit rule definitions (polymorphically!)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;So there&amp;rsquo;s no need to respecify body, line, etc.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Perl 6 will come with at least one grammar predefined:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    grammar Perl {    # Perl&#39;s own grammar

        rule prog { &amp;lt;line&amp;gt;* }

        rule line { &amp;lt;decl&amp;gt;
                  | &amp;lt;loop&amp;gt;
                  | &amp;lt;label&amp;gt; [&amp;lt;cond&amp;gt;|&amp;lt;sideff&amp;gt;|;]
        }

        rule decl { &amp;lt;sub&amp;gt; | &amp;lt;class&amp;gt; | &amp;lt;use&amp;gt; }

        # etc. etc.
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Hence:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    given $source_code {
        $parsetree = m/&amp;lt;Perl::prog&amp;gt;/;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-transliteration-transliteration-span&#34;&gt;&lt;span id=&#34;transliteration&#34;&gt;Transliteration&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The tr/// quote-like operator now also has a subroutine form.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It can be given either a single &lt;code&gt;PAIR&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $str =~ tr( &#39;A-C&#39; =&amp;gt; &#39;a-c&#39; );
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Or a hash (or hash ref):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $str =~ tr( {&#39;A&#39;=&amp;gt;&#39;a&#39;, &#39;B&#39;=&amp;gt;&#39;b&#39;, &#39;C&#39;=&amp;gt;&#39;c&#39;} );
    $str =~ tr( {&#39;A-Z&#39;=&amp;gt;&#39;a-z&#39;, &#39;0-9&#39;=&amp;gt;&#39;A-F&#39;} );
    $str =~ tr( %mapping );
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Or two arrays (or array refs):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $str =~ tr( [&#39;A&#39;..&#39;C&#39;], [&#39;a&#39;..&#39;c&#39;] );
    $str =~ tr( @UPPER, @lower );
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Note that the array version can map one-or-more characters to one-or-more characters:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $str =~ tr( [&#39; &#39;,      &#39;&amp;lt;&#39;,    &#39;&amp;gt;&#39;,    &#39;&amp;amp;&#39;    ],
                [&#39;&amp;amp;nbsp;&#39;, &#39;&amp;amp;lt;&#39;, &#39;&amp;amp;gt;&#39;, &#39;&amp;amp;amp;&#39; ]);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;**&lt;/p&gt;

&lt;p&gt;**&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Return to &lt;a href=&#34;http://localhost:1313/&#34;&gt;Perl.com&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Exegesis 4</title>
      <link>http://localhost:1313/pub/2002/04/01/exegesis4.html/</link>
      <pubDate>Tue, 02 Apr 2002 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2002/04/01/exegesis4.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S04.html&#34;&gt;Synopsis 4&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_And_I%27d_se%2Dell_my%2Dy_so%2Doul_for_flow_of_con&#34;&gt;&lt;em&gt;And I&amp;rsquo;d se-ell my-y so-oul for flow of con-tro-ol &amp;hellip; over Perl&lt;/em&gt;&lt;/span&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;span id=&#34;item_%2D%2D_The_Motels%2C_%22Total_Control%22_%28Perl_6&#34;&gt;&amp;ndash; The Motels, &amp;ldquo;Total Control&amp;rdquo; (Perl 6 remix)&lt;/span&gt;&lt;/strong&gt;
In &lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html&#34;&gt;Apocalypse 4&lt;/a&gt;, Larry explains the fundamental changes to flow and block control in Perl 6. The changes bring fully integrated exceptions; a powerful new switch statement; a coherent mechanism for polymorphic matching; a greatly enhanced &lt;code&gt;for&lt;/code&gt; loop; and unification of blocks, subroutines and closures.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s dive right in.&lt;/p&gt;

&lt;h3 id=&#34;span-id-now-witness-the-power-of-this-fully-operational-control-structure-now-witness-the-power-of-this-fully-operational-control-structure-span&#34;&gt;&lt;span id=&#34;now, witness the power of this fully operational control structure&#34;&gt;&amp;ldquo;Now, Witness the Power of This Fully &lt;em&gt;Operational&lt;/em&gt; Control Structure&amp;rdquo;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ll consider a simple interactive &lt;a href=&#34;http://www.calculator.org/rpn.html&#34;&gt;RPN calculator&lt;/a&gt;. The real thing would have many more operators and values, but that&amp;rsquo;s not important right now.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Err::BadData is Exception {...}

    module Calc;

    my class NoData is Exception {
        method warn(*@args) { die @args }
    }

    my %var;

    my sub get_data ($data) {
        given $data {
            when /^\d+$/    { return %var{&amp;quot;&amp;quot;} = $_ }
            when &#39;previous&#39; { return %var{&amp;quot;&amp;quot;} // fail NoData }
            when %var       { return %var{&amp;quot;&amp;quot;} = %var{$_} }
            default         { die Err::BadData : msg=&amp;gt;&amp;quot;Don&#39;t understand $_&amp;quot; }
        }  
    }

    sub calc (str $expr, int $i) {
        our %operator is private //= (
            &#39;*&#39;  =&amp;gt; { $^a * $^b },
            &#39;/&#39;  =&amp;gt; { $^a / $^b },
            &#39;~&#39;  =&amp;gt; { ($^a + $^b) / 2 },
        );

        my @stack;
        my $toknum = 1;
        for split /\s+/, $expr -&amp;gt; $token {
            try {
                when %operator {
                    my @args = splice @stack, -2;
                    push @stack, %operator{$token}(*@args)
                }
                when &#39;.&#39;, &#39;;&#39;, &#39;=&#39; {
                    last
                }

                use fatal;
                push @stack, get_data($token);

                CATCH {
                    when Err::Reportable     { warn $!; continue }
                    when Err::BadData        { $!.fail(at=&amp;gt;$toknum) }
                    when NoData              { push @stack, 0 }
                    when /division by zero/  { push @stack, Inf }
                }
            }

            NEXT { $toknum++ }
        }
        fail Err::BadData: msg=&amp;gt;&amp;quot;Too many operands&amp;quot; if @stack &amp;gt; 1;
        return %var{&#39;$&#39; _ $i} = pop(@stack) but true;
    }

    module main;

    for 1..Inf -&amp;gt; $i {
        print &amp;quot;$i&amp;gt; &amp;quot;;
        my $expr = &amp;lt;&amp;gt; err last;  
        print &amp;quot;$i&amp;gt; $( Calc::calc(i=&amp;gt;$i, expr=&amp;gt;$expr) )\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-an-exceptionally-promising-beginning-an-exceptionally-promising-beginning-span&#34;&gt;&lt;span id=&#34;an exceptionally promising beginning&#34;&gt;An Exceptionally Promising Beginning&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The calculator is going to handle internal and external errors using Perl 6&amp;rsquo;s OO exception mechanism. This means that we&amp;rsquo;re going to need some classes for those OO exceptions to belong to.&lt;/p&gt;

&lt;p&gt;To create those classes, the &lt;code&gt;class&lt;/code&gt; keyword is used. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Err::BadData is Exception {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After this declaration, &lt;code&gt;Err::BadData&lt;/code&gt; is a class name (or rather, by analogy to &amp;ldquo;filehandle,&amp;rdquo; it&amp;rsquo;s a &amp;ldquo;classname&amp;rdquo;). Either way, it can then be used as a type specifier wherever Perl 6 expects one. Unlike Perl 5, that classname is not a bareword string: It&amp;rsquo;s a genuine first-class symbol in the program. In object-oriented terms, we could think of a classname as a meta-object &amp;ndash; an object that describes the attributes and behavior of other objects.&lt;/p&gt;

&lt;p&gt;Modules and packages are also first class in Perl 6, so we can also refer to their names directly, or take references to them, or look them up in the appropriate symbol table.&lt;/p&gt;

&lt;p&gt;Classes can take properties, just like variables and values. Generally, those properties will specify variations in the behavior of the class. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class B::Like::Me is interface;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;specifies that the B::Like::Me class defines a (Java-like) interface that any subclass must implement.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;is Exception&lt;/code&gt; is not, however, a standard property. Indeed, &lt;code&gt;Exception&lt;/code&gt; is the name of another (standard, built-in) class. When a classname like this is used as if it were a property, the property it confers is inheritance. Specifically, &lt;code&gt;Err::BadData&lt;/code&gt; is defined as inheriting from the &lt;code&gt;Exception&lt;/code&gt; base class. In Perl 5, that would have been:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Perl 5 code
    package Err::BadData;
    use base &#39;Exception&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So now class &lt;code&gt;Err::BadData&lt;/code&gt; will have all the exceptionally useful properties of the &lt;code&gt;Exception&lt;/code&gt; class.&lt;/p&gt;

&lt;p&gt;Having classnames as &amp;ldquo;first class&amp;rdquo; symbols of the program means that it&amp;rsquo;s also important to be able to pre-declare them (to avoid compile-time &amp;ldquo;no such class or module&amp;rdquo; errors). So we need a new syntax for declaring the existence of classes/modules/packages, without actually defining their behavior.&lt;/p&gt;

&lt;p&gt;To do that we write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class MyClass {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That right. That&amp;rsquo;s real, executable, Perl 6 code.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re defining the class, but using the new Perl 6 &amp;ldquo;yada-yada-yada&amp;rdquo; operator in a block immediately after the classname. By using the &amp;ldquo;I&amp;rsquo;m-eventually-going-to-put-something-here-but-not-just-yet&amp;rdquo; marker, we indicate that this definition is only a stub or placeholder. In this way, we introduce the classname into the current scope without needing to provide the complete description of the class.&lt;/p&gt;

&lt;p&gt;By the way, this is also the way we can declare other types of symbols in Perl 6 without actually defining them:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    module Alpha {...}
    package Beta {...}
    method Gamma::delta(Gamma $self: $d1, $d2) {...}
    sub epsilon() {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In our example, the &lt;code&gt;Err::BadData&lt;/code&gt; classname is introduced in precisely that way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Err::BadData is Exception {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which means that we can refer to the class by name, even though it has not yet been completely defined.&lt;/p&gt;

&lt;p&gt;In fact, in this example, &lt;code&gt;Err::BadData&lt;/code&gt; is &lt;em&gt;never&lt;/em&gt; completely defined. So we&amp;rsquo;d get a fatal compile-time error: &amp;ldquo;Missing definition for class Err::BadData.&amp;rdquo; Then we&amp;rsquo;d realize we either forgot to eventually define the class, or that we had really meant to write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Err::BadData is Exception {}   # Define new exception class with
                                         # no methods or attributes
                                         # except those it inherits
                                         # See below.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S04.html&#34;&gt;Synopsis 4&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-lexical-exceptions-lexical-exceptions-span&#34;&gt;&lt;span id=&#34;lexical exceptions&#34;&gt;Lexical Exceptions&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Most of the implementation of the calculator is contained in the &lt;code&gt;Calc&lt;/code&gt; module. In Perl 6, modules are specified using the &lt;code&gt;module&lt;/code&gt; keyword:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    module Calc;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which is similar in effect to a Perl 5:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Perl 5 code
    package Calc;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Modules are not quite the same as packages in Perl 6. Most significantly, they have a different export mechanism: They export via a new, built-in, declarative mechanism (which will be described in a future Apocalypse) and the symbols they export are exported lexically by default.&lt;/p&gt;

&lt;p&gt;The first thing to appear in the module is a class declaration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my class NoData is Exception {
        method warn(*@args) { die @args }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is another class derived from &lt;code&gt;Exception&lt;/code&gt;, but one that has two significant differences from the declaration of &lt;code&gt;class Err::BadData&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The leading &lt;code&gt;my&lt;/code&gt; makes it lexical in scope, and&lt;/li&gt;
&lt;li&gt;the trailing braces give it an associated block in which its attributes and methods can be specified.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let&amp;rsquo;s look at each of those.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;NoData&lt;/code&gt; exceptions are only going to be used within the &lt;code&gt;Calc&lt;/code&gt; module itself. So it&amp;rsquo;s good software engineering to make them visible only within the module itself.&lt;/p&gt;

&lt;p&gt;Why? Because if we ever attempt to refer to the exception class outside &lt;code&gt;Calc&lt;/code&gt; (e.g. if we tried to catch such an exception in &lt;code&gt;main&lt;/code&gt;), then we&amp;rsquo;ll get a compile-time &amp;ldquo;No such class: NoData&amp;rdquo; error. Any such errors would indicate a flaw in our class design or implementation.&lt;/p&gt;

&lt;p&gt;In Perl 6, classes are first-class constructs. That is, like variables and subroutines, they are &amp;ldquo;tangible&amp;rdquo; components of a program, denizens of a symbol table, able to be referred to both symbolically and by explicit reference:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $class = \Some::Previously::Defined::Class;

    # and later

    $obj = $class.new();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the back slash is actually optional in that first line, just as it would be for an array or hash in the same position.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;First class&amp;rdquo; also means that classnames live in a symbol table. So it follows that they can be defined to live in the current &lt;em&gt;lexical&lt;/em&gt; symbol table (i.e. &lt;code&gt;%MY::&lt;/code&gt;), by placing a &lt;code&gt;my&lt;/code&gt; before them.&lt;/p&gt;

&lt;p&gt;A lexical class or module is only accessible in the lexical scope in which it&amp;rsquo;s declared. Of course, like Perl 5 packages, Perl 6 classes and modules don&amp;rsquo;t usually &lt;em&gt;have&lt;/em&gt; an explicit lexical scope associated with their declaration. They are implicitly associated with the surrounding lexical scope (which is normally a file scope).&lt;/p&gt;

&lt;p&gt;But we can give them their own lexical scope to preside over by adding a block at the end of their declaration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Whatever {
        # definition here
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This turns out to be important. Without the ability to specify a lexical scope over which the class has effect, we would be stuck with no way to embed a &amp;ldquo;nested&amp;rdquo; lexical class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Outer;
    # class Outer&#39;s namespace

    my class Inner;

    # From this line to the end of the file 
    # is now in class Inner&#39;s namespace
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Perl 6, we avoid this problem by writing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Outer;
    # class Outer&#39;s namespace

    my class Inner {
        # class Inner&#39;s namespace
    }

    # class Outer&#39;s namespace again
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In our example, we use this new feature to redefine &lt;code&gt;NoData&lt;/code&gt;&amp;rsquo;s &lt;code&gt;warn&lt;/code&gt; method (upgrading it to a call to &lt;code&gt;die&lt;/code&gt;). Of course, we could also have done that with just:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my class NoData is Exception;       # Open NoData&#39;s namespace
    method warn(*@args) { die @args }   # Defined in NoData&#39;s namespace
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but then we would have needed to &amp;ldquo;reopen&amp;rdquo; the &lt;code&gt;Calc&lt;/code&gt; module&amp;rsquo;s namespace afterward:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    module Calc;                        # Open Calc&#39;s namespace

    my class NoData is Exception;       # Open NoData&#39;s (nested) namespace
    method warn(*@args) { die @args }   # Defined in NoData&#39;s namespace

    module Calc;                        # Back to Calc&#39;s namespace
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Being able to &amp;ldquo;nest&amp;rdquo; the &lt;code&gt;NoData&lt;/code&gt; namespace:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    module Calc;                            # Open Calc&#39;s namespace

    my class NoData is Exception {          # Open NoData&#39;s (nested) namespace
        method warn(*@args) { die @args }   # Defined in NoData&#39;s namespace
    }

    # The rest of module Calc defined here.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is much cleaner.&lt;/p&gt;

&lt;p&gt;By the way, because classes can now have an associated block, they can even be anonymous:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $anon_class = class { 
        # definition here
    };

    # and later

    $obj = $anon_class.new();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which is a handy way of implementing &amp;ldquo;singleton&amp;rdquo; objects:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $allocator = class { 
                        my $.count = &amp;quot;ID_000001&amp;quot;;
                        method next_ID { $.count++ }
                    }.new;

    # and later...

    for @objects {
        $_.set_id( $allocator.next_ID );
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-maintaining-your-state-maintaining-your-state-span&#34;&gt;&lt;span id=&#34;maintaining your state&#34;&gt;Maintaining Your State&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;To store the values of any variables used by the calculator, we&amp;rsquo;ll use a single hash, with each key being a variable name:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my %var;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nothing more to see here. Let&amp;rsquo;s move along.&lt;/p&gt;

&lt;h3 id=&#34;span-id-it-s-a-given-it-s-a-given-span&#34;&gt;&lt;span id=&#34;it&#39;s a given&#34;&gt;It&amp;rsquo;s a Given&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;get_data&lt;/code&gt; subroutine may be given a number (i.e. a literal value), a numerical variable name (i.e. &lt;code&gt;&#39;$1&#39;&lt;/code&gt;, &lt;code&gt;&#39;$2&#39;&lt;/code&gt;, etc.) , or the keyword &lt;code&gt;&#39;previous&#39;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It then looks up the information in the &lt;code&gt;%var&lt;/code&gt; hash, using a switch statement to determine the appropriate look-up:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my sub get_data ($data) {
        given $data {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;given $data&lt;/code&gt; evaluates its first argument (in this case, &lt;code&gt;$data&lt;/code&gt;) in a scalar context, and makes the result the &amp;ldquo;topic&amp;rdquo; of each subsequent &lt;code&gt;when&lt;/code&gt; inside the block associated with the &lt;code&gt;given&lt;/code&gt;. (Though, just between us, that block is merely an anonymous closure acting as the &lt;code&gt;given&lt;/code&gt;&amp;rsquo;s second argument &amp;ndash; in Perl 6 &lt;em&gt;all&lt;/em&gt; blocks are merely closures that are slumming it.)&lt;/p&gt;

&lt;p&gt;Note that the &lt;code&gt;given $data&lt;/code&gt; statement also makes &lt;code&gt;$_&lt;/code&gt; an alias for &lt;code&gt;$data&lt;/code&gt;. So, for example, if the &lt;code&gt;when&lt;/code&gt; specifies a pattern:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    when /^\d+$/  { return %var{&amp;quot;&amp;quot;} = $_ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then that pattern is matched against the contents of &lt;code&gt;$data&lt;/code&gt; (i.e. against the current topic). Likewise, caching and returning &lt;code&gt;$_&lt;/code&gt; when the pattern matches is the same as caching and returning &lt;code&gt;$data&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;After a &lt;code&gt;when&lt;/code&gt;&amp;rsquo;s block has been selected and executed, control automatically passes to the end of the surrounding &lt;code&gt;given&lt;/code&gt; (or, more generally, to the end of whatever block provided the &lt;code&gt;when&lt;/code&gt;&amp;rsquo;s topic). That means that &lt;code&gt;when&lt;/code&gt; blocks don&amp;rsquo;t &amp;ldquo;fall through&amp;rdquo; in the way that &lt;code&gt;case&lt;/code&gt; statements do in C.&lt;/p&gt;

&lt;p&gt;You can also explicitly send control to the end of a &lt;code&gt;when&lt;/code&gt;&amp;rsquo;s surrounding &lt;code&gt;given&lt;/code&gt;, using a &lt;code&gt;break&lt;/code&gt; statement. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    given $number {
        when /[02468]$/ {
            if ($_ == 2) {
                warn &amp;quot;$_ is even and prime\n&amp;quot;;
                break;
            }           
            warn &amp;quot;$_ is even and composite\n&amp;quot;;
        }
        when &amp;amp;is_prime {
            warn &amp;quot;$_ is odd and prime\n&amp;quot;;
        }
        warn &amp;quot;$_ is odd and composite\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternatively, you can explicitly tell Perl not to automatically &lt;code&gt;break&lt;/code&gt; at the end of the &lt;code&gt;when&lt;/code&gt; block. That is, tell it to &amp;ldquo;fall through&amp;rdquo; to the statement immediately after the &lt;code&gt;when&lt;/code&gt;. That&amp;rsquo;s done with a &lt;code&gt;continue&lt;/code&gt; statement (which is the new name for The Statement &lt;a href=&#34;http://dev.perl.org/perl6/apocalypse/4&#34;&gt;Formerly&lt;/a&gt; Known As &lt;code&gt;skip&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    given $number {
        when &amp;amp;is_prime   { warn &amp;quot;$_ is prime\n&amp;quot;; continue; }
        when /[13579]$/  { warn &amp;quot;$_ is odd&amp;quot;; }
        when /[02468]$/  { warn &amp;quot;$_ is even&amp;quot;; }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Perl 6, a &lt;code&gt;continue&lt;/code&gt; means: &amp;ldquo;continue executing from the next statement after the current &lt;code&gt;when&lt;/code&gt;, rather than jumping out of the surrounding &lt;code&gt;given&lt;/code&gt;.&amp;rdquo; It has nothing to do with the old Perl 5 &lt;code&gt;continue&lt;/code&gt; block, which in Perl 6 becomes &lt;a href=&#34;#onwards%20and%20backwards&#34;&gt;&lt;code&gt;NEXT&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &amp;ldquo;topic&amp;rdquo; that &lt;code&gt;given&lt;/code&gt; creates can also be aliased to a name of our own choosing (though it&amp;rsquo;s &lt;em&gt;always&lt;/em&gt; aliased to &lt;code&gt;$_&lt;/code&gt; no matter what else we may do). To give the topic a more meaningful name, we just need to use the &amp;ldquo;topical arrow:&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    given check_online().{active}{names}[0] -&amp;gt; $name {
        when /^\w+$/  { print &amp;quot;$name&#39;s on first\n&amp;quot; }
        when /\?\?\?/    { print &amp;quot;Who&#39;s on first\n&amp;quot; }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Having been replaced by the dot, the old Perl 5 arrow operator is given a new role in Perl 6. When placed after the topic specifier of a control structure (i.e. the scalar argument of a &lt;code&gt;given&lt;/code&gt;, or the list of a &lt;code&gt;for&lt;/code&gt;), it allows us to give an extra name (apart from &lt;code&gt;$_&lt;/code&gt;) to the topic associated with that control structure.&lt;/p&gt;

&lt;p&gt;In the above version, the &lt;code&gt;given&lt;/code&gt; statement declares a lexical variable &lt;code&gt;$name&lt;/code&gt; and makes it yet another way of referring to the current topic. That is, it aliases both &lt;code&gt;$name&lt;/code&gt; and &lt;code&gt;$_&lt;/code&gt; to the value specified by &lt;code&gt;check_online().{active}{names}[0]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This is a fundamental change from Perl 5, where &lt;code&gt;$_&lt;/code&gt; was only aliased to the current topic in a &lt;code&gt;for&lt;/code&gt; loop. In Perl 6, the current topic &amp;ndash; whatever its name and however you make it the topic &amp;ndash; is &lt;em&gt;always&lt;/em&gt; aliased to &lt;code&gt;$_&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;That implies that everywhere that Perl 5 used &lt;code&gt;$_&lt;/code&gt; as a default (i.e. &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;chomp&lt;/code&gt;, &lt;code&gt;split&lt;/code&gt;, &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;eval&lt;/code&gt;, etc.), Perl 6 uses the current topic:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @list -&amp;gt; $next {        # iterate @list, aliasing each element to 
                                # $next (and to $_)
        print if length &amp;gt; 10;   # same as: print $next if length $next &amp;gt; 10
        %count{$next}++;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is subtly different from the &amp;ldquo;equivalent&amp;rdquo; Perl 5 code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Perl 5 code
    for my $next (@list) {      # iterate @list, aliasing each element to 
                                # $next (but not to $_)
        print if length &amp;gt; 10;   # same as: print $_ if length $_ &amp;gt; 10
                                # using the $_ value from *outside* the loop
        %count{$next}++;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you had wanted this Perl 5 behavior in Perl 6, then you&amp;rsquo;d have to say explicitly what you meant:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $outer_underscore := $_;
    for @list -&amp;gt; $next {
        print $outer_underscore
            if length $outer_underscore &amp;gt; 10;
        %count{$next}++;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which is probably a good thing in code that subtle.&lt;/p&gt;

&lt;p&gt;Oh, and yes: the &lt;code&gt;p52p6&lt;/code&gt; translator program &lt;em&gt;will&lt;/em&gt; take that new behavior into account and correctly convert something pathological like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Perl 5 code
    while (&amp;lt;&amp;gt;) {
        for my $elem (@list) {
            print if $elem % 2;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Perl 6 code
    for &amp;lt;&amp;gt; {
        my $some_magic_temporary_variable := $_;
        for @list -&amp;gt; $elem {
            print $some_magic_temporary_variable if $elem % 2;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that this works because, in Perl 6, a call to &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is lazily evaluated in list contexts, including the list of a &lt;code&gt;for&lt;/code&gt; loop.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S04.html&#34;&gt;Synopsis 4&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-other-whens-other-whens-span&#34;&gt;&lt;span id=&#34;other whens&#34;&gt;Other whens&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The remaining cases of the data look-up are handled by subsequent &lt;code&gt;when&lt;/code&gt; statements. The first:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    when &#39;previous&#39; { return %var{&amp;quot;&amp;quot;} // fail NoData }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;handles the special keyword &lt;code&gt;&amp;quot;previous&amp;quot;&lt;/code&gt;. The previous value is always stored in the element of &lt;code&gt;%var&lt;/code&gt; whose key is the empty string.&lt;/p&gt;

&lt;p&gt;If, however, that previous value is undefined, then the defaulting operator &amp;ndash; &lt;code&gt;//&lt;/code&gt; &amp;ndash; causes the right-hand side of the expression to be evaluated instead. That right-hand side is a call to the &lt;code&gt;fail&lt;/code&gt; method of class &lt;code&gt;NoData&lt;/code&gt; (and could equally have been written &lt;code&gt;NoData.fail()&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;The standard &lt;code&gt;fail&lt;/code&gt; method inherited from the &lt;code&gt;Exception&lt;/code&gt; class constructs an instance of the appropriate class (i.e. an exception object) and then either throws that exception (if the &lt;code&gt;use fatal&lt;/code&gt; pragma is in effect) or else returns an &lt;code&gt;undef&lt;/code&gt; value from the scope in which the &lt;code&gt;fail&lt;/code&gt; was invoked. That is, the &lt;code&gt;fail&lt;/code&gt; acts like a &lt;code&gt;die SomeExceptionClass&lt;/code&gt; or a &lt;code&gt;return undef&lt;/code&gt;, depending on the state of the &lt;code&gt;use fatal&lt;/code&gt; pragma.&lt;/p&gt;

&lt;p&gt;This is possible because, in Perl 6, &lt;em&gt;all&lt;/em&gt; flow-of-control &amp;ndash; including the normal subroutine &lt;code&gt;return&lt;/code&gt; &amp;ndash; is exception-based. So, when it is supposed to act like a &lt;code&gt;return&lt;/code&gt;, the &lt;code&gt;Exception::fail&lt;/code&gt; method simply throws the special &lt;code&gt;Ctl::Return&lt;/code&gt; exception, which &lt;code&gt;get_data&lt;/code&gt;&amp;rsquo;s caller will (automagically) catch and treat as a normal return.&lt;/p&gt;

&lt;p&gt;So then why not just write the usual:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    return undef;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;instead?&lt;/p&gt;

&lt;p&gt;The advantage of using &lt;code&gt;fail&lt;/code&gt; is that it allows the &lt;em&gt;callers&lt;/em&gt; of &lt;code&gt;get_data&lt;/code&gt; to decide how that subroutine should signal failure. As explained above, normally &lt;code&gt;fail&lt;/code&gt; fails by returning &lt;code&gt;undef&lt;/code&gt;. But if a &lt;code&gt;use fatal&lt;/code&gt; pragma is in effect, any invocation of &lt;code&gt;fail&lt;/code&gt; instead throws the corresponding exception.&lt;/p&gt;

&lt;p&gt;What&amp;rsquo;s the advantage in that? Well, some people feel that certain types of failures ought to be taken deadly seriously (i.e. they should kill you unless you explicitly catch and handle them). Others feel that the same errors really aren&amp;rsquo;t all that serious and you should be allowed to, like, chill man and just groove with the heavy consequences, dude.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;fail&lt;/code&gt; method allows you, the coder, to stay well out of that kind of fruitless religious debate.&lt;/p&gt;

&lt;p&gt;When you use &lt;code&gt;fail&lt;/code&gt; to signal failure, not only is the code nicely documented at that point, but the mode of failure becomes caller-selectable. Fanatics can &lt;code&gt;use fatal&lt;/code&gt; and make each failure punishable by death; hippies can say &lt;code&gt;no fatal&lt;/code&gt; and make each failure just return &lt;code&gt;undef&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You no longer have to get caught up in endless debate as to whether the exception-catching:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try { $data = get_data($str) }
        // warn &amp;quot;Couldn&#39;t get data&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is inherently better or worse than the &lt;code&gt;undef&lt;/code&gt;-sensing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    do { $data = get_data($str) }
        // warn &amp;quot;Couldn&#39;t get data&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead, you can just write &lt;code&gt;get_data&lt;/code&gt; such that There&amp;rsquo;s More Than One Way To Fail It.&lt;/p&gt;

&lt;p&gt;By the way, &lt;code&gt;fail&lt;/code&gt; can fail in other ways, too: in different contexts or under different pragmas. The most obvious example would be inside a regex, where it would initiate back-tracking. More on that in Apocalypse 5.&lt;/p&gt;

&lt;h3 id=&#34;span-id-still-other-whens-still-other-whens-span&#34;&gt;&lt;span id=&#34;still other whens&#34;&gt;Still Other Whens&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Meanwhile, if &lt;code&gt;$data&lt;/code&gt; isn&amp;rsquo;t a number or the &lt;code&gt;&amp;quot;previous&amp;quot;&lt;/code&gt; keyword, then maybe it&amp;rsquo;s the name of one of the calculator&amp;rsquo;s variables. The third &lt;code&gt;when&lt;/code&gt; statement of the switch tests for that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    when %var   { return %var{&amp;quot;&amp;quot;} = %var{$_} }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If a &lt;code&gt;when&lt;/code&gt; is given a hash, then it uses the current topic as a key in the hash and looks up the corresponding entry. If that value is true, then it executes its block. In this case, that block caches the value that was looked up (i.e. &lt;code&gt;%var{$_}&lt;/code&gt;) in the &amp;ldquo;previous&amp;rdquo; slot and returns it.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Aha!&amp;rdquo; you say, &amp;ldquo;that&amp;rsquo;s a bug! What if the value of &lt;code&gt;%var{$_}&lt;/code&gt; is false?!&amp;rdquo; Well, if it were possible for that to ever happen, then it certainly &lt;em&gt;would&lt;/em&gt; be a bug, and we&amp;rsquo;d have to write something ugly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    when defined %var{$_}   { return %var{&amp;quot;&amp;quot;} = %var{$_} }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But, of course, it&amp;rsquo;s much easier just to redefine Truth, so that any literal zero value stored in &lt;code&gt;%var&lt;/code&gt; is no longer false. See &lt;a href=&#34;#cache%20and%20return&#34;&gt;below&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Finally, if the &lt;code&gt;$data&lt;/code&gt; isn&amp;rsquo;t a literal, then a &lt;code&gt;&amp;quot;previous&amp;quot;&lt;/code&gt;, or a variable name, it must be an invalid token, so the default alternative in the switch statement throws an &lt;code&gt;Err::BadData&lt;/code&gt; exception:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    default     { die Err::BadData : msg=&amp;gt;&amp;quot;Don&#39;t understand $_&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that, here again, we are actually executing a method call to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Err::BadData.die(msg=&amp;gt;&amp;quot;Don&#39;t understand $_&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;as indicated by the use of the colon after the classname.&lt;/p&gt;

&lt;p&gt;Of course, by using &lt;code&gt;die&lt;/code&gt; instead of &lt;code&gt;fail&lt;/code&gt; here, we&amp;rsquo;re giving clients of the &lt;code&gt;get_data&lt;/code&gt; subroutine no choice but to deal with &lt;code&gt;Err::BadData&lt;/code&gt; exceptions.&lt;/p&gt;

&lt;h3 id=&#34;span-id-an-aside-the-smart-match-operator-an-aside-the-smart-match-operator-span&#34;&gt;&lt;span id=&#34;an aside: the smart match operator&#34;&gt;An Aside: the &amp;ldquo;Smart Match&amp;rdquo; Operator&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The rules governing how the argument of a &lt;code&gt;when&lt;/code&gt; is matched against the current topic are designed to be as DWIMish as possible. Which means that they are actually quite complex. They&amp;rsquo;re listed in Apocalypse 4, so we won&amp;rsquo;t review them here.&lt;/p&gt;

&lt;p&gt;Collectively, the rules are designed to provide a generic &amp;ldquo;best attempt at matching&amp;rdquo; behavior. That is, given two values (the current topic and the &lt;code&gt;when&lt;/code&gt;&amp;rsquo;s first argument), they try to determine whether those values can be combined to produce a &amp;ldquo;smart match&amp;rdquo; &amp;ndash; for some reasonable definitions of &amp;ldquo;smart&amp;rdquo; and &amp;ldquo;match.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;That means that one possible use of a Perl 6 switch statement is simply to test &lt;em&gt;whether&lt;/em&gt; two values match without worrying about &lt;em&gt;how&lt;/em&gt; those two values match:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub hey_just_see_if_dey_match_willya ($val1, $val2) {
        given $val1 {
            when $val2 { return 1 }
            default    { return 0 }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That behavior is sufficiently useful that Larry wanted to make it much easier to use. Specifically, he wanted to provide a generic &amp;ldquo;smart match&amp;rdquo; operator.&lt;/p&gt;

&lt;p&gt;So he did. It&amp;rsquo;s called &lt;code&gt;=~&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Yes, the humble Perl 5 &amp;ldquo;match a string against a regex&amp;rdquo; operator is promoted in Perl 6 to a &amp;ldquo;smart-match an &lt;em&gt;anything&lt;/em&gt; against an &lt;em&gt;anything&lt;/em&gt;&amp;rdquo; operator. So now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if ($val1 =~ $val2) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;works out the most appropriate way to compare its two scalar operands. The result might be a numeric comparison (&lt;code&gt;$val1 == $val2&lt;/code&gt;) or a string comparison (&lt;code&gt;$val1 eq $val2&lt;/code&gt;) or a subroutine call (&lt;code&gt;$val1.($val2)&lt;/code&gt;) or a pattern match (&lt;code&gt;$val1 =~ /$val2/&lt;/code&gt;) or whatever else makes the most sense for the actual run-time types of the two operands.&lt;/p&gt;

&lt;p&gt;This new turbo-charged &amp;ldquo;smart match&amp;rdquo; operator will also work on arrays, hashes and lists:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if @array =~ $elem {...}        # true if @array contains $elem

    if $key =~ %hash {...}          # true if %hash{$key}

    if $value =~ (1..10) {...}      # true if $value is in the list

    if $value =~ (&#39;a&#39;,/\s/,7) {...} # true if $value is eq to &#39;a&#39;
                                    #   or if $value contains whitespace
                                    #   or if $value is == to 7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That final example illustrates some of the extra intelligence that Perl 6&amp;rsquo;s &lt;code&gt;=~&lt;/code&gt; has: When one of its arguments is a list (&lt;em&gt;not&lt;/em&gt; an array), the &amp;ldquo;smart match&amp;rdquo; operator recursively &amp;ldquo;smart matches&amp;rdquo; each element and ORs the results together, short-circuiting if possible.&lt;/p&gt;

&lt;h3 id=&#34;span-id-being-calculating-being-calculating-span&#34;&gt;&lt;span id=&#34;being calculating&#34;&gt;Being Calculating&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The next component of the program is the subroutine that computes the actual results of each expression that the user enters. It takes a string to be evaluated and an integer indicating the current iteration number of the main input loop (for debugging purposes):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub calc (str $expr, int $count) {
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-give-us-a-little-privacy-please-give-us-a-little-privacy-please-span&#34;&gt;&lt;span id=&#34;give us a little privacy, please&#34;&gt;Give us a little privacy, please&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Perl 5 has a really ugly idiom for creating &amp;ldquo;durable&amp;rdquo; lexical variables: variables that are lexically scoped but stick around from call to call.&lt;/p&gt;

&lt;p&gt;If you write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub whatever {
        my $count if 0;
        $count++;
        print &amp;quot;whatever called $count times\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then the compile-time aspect of a &lt;code&gt;my $count&lt;/code&gt; declaration causes &lt;code&gt;$count&lt;/code&gt; to be declared as a lexical in the subroutine block. However, at run-time &amp;ndash; when the variable would normally be (re-)allocated &amp;ndash; the &lt;code&gt;if 0&lt;/code&gt; prevents that process. So the original lexical variable is not replaced on each invocation, and is instead shared by them all.&lt;/p&gt;

&lt;p&gt;This awful &lt;code&gt;if 0&lt;/code&gt; idiom works under most versions of Perl 5, but it&amp;rsquo;s really just a freakish accident of Perl&amp;rsquo;s evolution, not a carefully designed and lovingly crafted feature. So &lt;a href=&#34;http://perl.plover.com/docs/perlsub.html#warning&#34;&gt;just say &amp;ldquo;No!&amp;rdquo;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Perl 6 allows us to do the same thing, but without feeling the need to wash afterward.&lt;/p&gt;

&lt;p&gt;To understand how Perl 6 cleans up this idiom, notice that the durable variable is really much more; like a package variable that just happens to be accessible only in a particular lexical scope. That kind of restricted-access package variable is going to be quite common in Perl 6 &amp;ndash; as an attribute of a class.&lt;/p&gt;

&lt;p&gt;So the way we create such a variable is to declare it as a package variable, but with the &lt;code&gt;is private&lt;/code&gt; property:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    module Wherever;

    sub whatever {
        our $count is private;
        $count++;
        print &amp;quot;whatever called $count times\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Adding &lt;code&gt;is private&lt;/code&gt; causes Perl to recognize the existence of the variable &lt;code&gt;$count&lt;/code&gt; within the &lt;code&gt;Wherever&lt;/code&gt; module, but then to restrict its accessibility to the lexical scope in which it is first declared. In the above example, any attempt to refer to &lt;code&gt;$Wherever::count&lt;/code&gt; outside the &lt;code&gt;&amp;amp;Wherever::whatever&lt;/code&gt; subroutine produces a compile-time error. It&amp;rsquo;s still a package variable, but now you can&amp;rsquo;t use it anywhere but in the nominated lexical scope.&lt;/p&gt;

&lt;p&gt;Apart from the benefit of replacing an ugly hack with a clean explicit marker on the variable, the real advantage is that Perl 6 private variables can be also be initialized:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub whatever {
        our $count is private //= 1;
        print &amp;quot;whatever called $count times\n&amp;quot;;
        $count++;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That initialization is performed the first time the variable declaration is encountered during execution (because that&amp;rsquo;s the only time its value is &lt;code&gt;undef&lt;/code&gt;, so that&amp;rsquo;s the only time the &lt;code&gt;//=&lt;/code&gt; operator has any effect).&lt;/p&gt;

&lt;p&gt;In our example program we use that facility to do a one-time-only initialization of a private package hash. That hash will then be used as a (lexically restricted) look-up table to provide the implementations for a set of operator symbols:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        our %operator is private //= (
            &#39;*&#39;  =&amp;gt; { $^a * $^b },
            &#39;/&#39;  =&amp;gt; { $^a / $^b },
            &#39;~&#39;  =&amp;gt; { ($^a + $^b) / 2 },
        );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each key of the hash is an operator symbol and the corresponding value is an anonymous subroutine that implements the appropriate operation. Note the use of the &amp;ldquo;place-holder&amp;rdquo; variables (&lt;code&gt;$^a&lt;/code&gt; and &lt;code&gt;$^b&lt;/code&gt;) to implicitly specify the parameters of the closures.&lt;/p&gt;

&lt;p&gt;Since all the data for the &lt;code&gt;%operator&lt;/code&gt; hash is constant, we could have achieved a similar effect with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        my %operator is constant = (
            &#39;*&#39;  =&amp;gt; { $^a * $^b },
            &#39;/&#39;  =&amp;gt; { $^a / $^b },
            &#39;~&#39;  =&amp;gt; { ($^a + $^b) / 2 },
        );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notionally this is quite different from the &lt;code&gt;is private&lt;/code&gt; version, in that &amp;ndash; theoretically &amp;ndash; the lexical constant would be reconstructed and reinitialized on each invocation of the &lt;code&gt;calc&lt;/code&gt; subroutine. Although, in practice, we would expect the compiler to notice the constant initializer and optimize the initialization out to compile-time.&lt;/p&gt;

&lt;p&gt;If the initializer had been a run-time expression, then the &lt;code&gt;is private&lt;/code&gt; and &lt;code&gt;is constant&lt;/code&gt; versions would behave very differently:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    our %operator is private //= todays_ops();   # Initialize once, the first
                                                 # time statement is reached.
                                                 # Thereafter may be changed
                                                 # at will within subroutine.

    my %operator is constant = todays_ops();     # Re-initialize every time
                                                 # statement is reached.
                                                 # Thereafter constant
                                                 # within subroutine
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-let-s-split-let-s-split-span&#34;&gt;&lt;span id=&#34;let&#39;s split!&#34;&gt;Let&amp;rsquo;s Split!&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;We then have to split the input expression into (whitespace-delimited) tokens, in order to parse and execute it. Since the calculator language we&amp;rsquo;re implementing is RPN, we need a stack to store data and interim calculations:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @stack;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also need a counter to track the current token number (for error messages):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $toknum = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we just use the standard &lt;code&gt;split&lt;/code&gt; built-in to break up the expression string, and iterate through each of the resulting tokens using a &lt;code&gt;for&lt;/code&gt; loop:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for split /\s+/, $expr -&amp;gt; $token {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are several important features to note in this &lt;code&gt;for&lt;/code&gt; loop. To begin with, there are no parentheses around the list. In Perl 6, they are not required (they&amp;rsquo;re not needed for &lt;em&gt;any&lt;/em&gt; control structure), though they are certainly still permissible:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for (split /\s+/, $expr) -&amp;gt; $token {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More importantly, the declaration of the iterator variable (&lt;code&gt;$token&lt;/code&gt;) is no longer to the left of the list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Perl 5 code
    for my $token (split /\s+/, $expr) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead, it is specified via a topical arrow to the right of the list.&lt;/p&gt;

&lt;p&gt;By the way, somewhat surprisingly, the Perl 6 arrow operator &lt;em&gt;isn&amp;rsquo;t&lt;/em&gt; a binary operator. (Actually, neither is the Perl 5 arrow operator, but that&amp;rsquo;s not important right now.)&lt;/p&gt;

&lt;p&gt;Even more surprisingly, what the Perl 6 arrow operator is, is a synonym for the declarator &lt;code&gt;sub&lt;/code&gt;. That&amp;rsquo;s right, in Perl 6 you can declare an anonymous subroutine like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $product_plus_one = -&amp;gt; $x, $y { $x*$y + 1 };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The arrow behaves like an anonymous &lt;code&gt;sub&lt;/code&gt; declarator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $product_plus_one = sub($x, $y) { $x*$y + 1 };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;except that its parameter list doesn&amp;rsquo;t require parentheses. That implies:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The Perl 6 &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, and &lt;code&gt;given&lt;/code&gt; statements each take two arguments: an expression that controls them and a subroutine/closure that they execute. Normally, that closure is just a block (in Perl6 &lt;em&gt;all&lt;/em&gt; blocks are really closures):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for 1..10 {         # no comma needed before opening brace
        print
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but you can also be explicit:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for 1..10, sub {    # needs comma if a regular anonymous sub
        print
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or you can be pointed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for 1..10 -&amp;gt; {      # no comma needed with arrow notation
        print
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or referential:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for 1..10,          # needs comma if a regular sub reference
        &amp;amp;some_sub;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;The variable after the arrow is effectively a lexical variable confined to the scope of the following block (just as a subroutine parameter is a lexical variable confined to the scope of the subroutine block). Within the block, that lexical becomes an alias for the topic (just as a subroutine parameter becomes an alias for the corresponding argument).&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Topic variables created with the arrow notation are, by default, read-only aliases (because Perl 6 subroutine parameters are, by default, read-only aliases):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @list -&amp;gt; $i {
        if ($cmd =~ &#39;incr&#39;) {
            $i++;   # Error: $i is read-only
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the rule doesn&amp;rsquo;t apply to the default topic (&lt;code&gt;$_&lt;/code&gt;), which is given special dispensation to be a modifiable alias (as in Perl 5).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you want a named topic to be modifiable through its alias, then you have to say so explicitly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @list -&amp;gt; $i is rw {
        if ($cmd =~ &#39;incr&#39;) {
            $i++;   # Okay: $i is read-write
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Just as a subroutine can have more than one parameter, so too we can specify more than one named iterator variable at a time:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for %phonebook.kv -&amp;gt; $name, $number {
        print &amp;quot;$name: $number\n&amp;quot;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that in Perl 6, a hash in a list context returns a list of pairs, not the Perl 5-ish &amp;ldquo;key, value, key, value, &amp;hellip;&amp;rdquo; sequence. To get the hash contents in that format, we have to call the hash&amp;rsquo;s &lt;code&gt;kv&lt;/code&gt; method explicitly.&lt;/p&gt;

&lt;p&gt;What actually happens in this iteration (and, in fact, in all such instances) is that the &lt;code&gt;for&lt;/code&gt; loop looks at the number of arguments its closure takes and iterates that many elements at a time.&lt;/p&gt;

&lt;p&gt;Note that &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;reduce&lt;/code&gt; can do that too in Perl 6:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # process @xs_and_ys two-at-a-time...
    @list_of_powers = map { $^x ** $^y } @xs_and_ys;

    # reduce list three-at-a-time   
    $sum_of_powers  = reduce { $^partial_sum + $^x ** $^y } 0, @xs_and_ys;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And, of course, since &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;reduce&lt;/code&gt; take a subroutine reference as their first argument &amp;ndash; instead of using the higher-order placeholder notation &amp;ndash; we could use the arrow notation here too:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @list_of_powers = map -&amp;gt; $x, $y { $x ** $y } @xs_and_ys;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or even an old-fashioned anonymous subroutine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @list_of_powers = map sub($x,$y){ $x ** $y }, @xs_and_ys;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Phew. If that all makes your head hurt, then don&amp;rsquo;t worry. All you really need to remember is this: If you don&amp;rsquo;t want to use &lt;code&gt;$_&lt;/code&gt; as the name of the current topic, then you can change it by putting an arrow and a variable name before the block of most control statements.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S04.html&#34;&gt;Synopsis 4&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-a-trying-situation-a-trying-situation-span&#34;&gt;&lt;span id=&#34;a trying situation&#34;&gt;A Trying Situation&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Once the calculator&amp;rsquo;s input has been split into tokens, the &lt;code&gt;for&lt;/code&gt; loop processes each one in turn, by applying them (if they represent an operator), or jumping out of the loop (if they represent an end-of-expression marker: &lt;code&gt;&#39;.&#39;&lt;/code&gt;, &lt;code&gt;&#39;;&#39;&lt;/code&gt;, or &lt;code&gt;&#39;=&#39;&lt;/code&gt;), or pushing them onto the stack (since anything else must be an operand):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try {
        when %operator {                # apply operator
            my @args = splice @stack, -2;
            push @stack, %operator{$token}(*@args);
        }

        when &#39;.&#39;, &#39;;&#39;, &#39;=&#39; {           # or jump out of loop
            last;
        }

        use fatal;
        push @stack, get_data($token);  # or push operand
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first two possibilities are tested for using &lt;code&gt;when&lt;/code&gt; statements. Recall that a &lt;code&gt;when&lt;/code&gt; tests its first argument against the current topic. In this case, however, the token was made the topic by the surrounding &lt;code&gt;for&lt;/code&gt;. This is a significant feature of Perl 6: &lt;code&gt;when&lt;/code&gt; blocks can implement a switch statement &lt;em&gt;anywhere&lt;/em&gt; there is a valid topic, not just inside a &lt;code&gt;given&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The block associated with &lt;code&gt;when %operator&lt;/code&gt; will be selected if &lt;code&gt;%operator{$token}&lt;/code&gt; is true (i.e. if there is an operator implementation in &lt;code&gt;%operator&lt;/code&gt; corresponding to the current topic). In that case, the top two arguments are spliced from the stack and passed to the closure implementing that operation (&lt;code&gt;%operator{$token}(*@args)&lt;/code&gt;). Note that there would normally be a dot (&lt;code&gt;.&lt;/code&gt;) operator between the hash entry (i.e. a subroutine reference) and the subroutine call, like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %operator{$token}.(*@args)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but in Perl 6 it may be omitted since it can be inferred (just as an inferrable &lt;code&gt;-&amp;gt;&lt;/code&gt; can be omitted in Perl 5).&lt;/p&gt;

&lt;p&gt;Note too that we used the flattening operator &lt;code&gt;(C&amp;lt;*&amp;gt;)&lt;/code&gt;on &lt;code&gt;C&amp;lt;@args&amp;gt;&lt;/code&gt;, because the closure returned by &lt;code&gt;C&amp;lt;%operator{$token}&amp;gt;&lt;/code&gt; expects two scalar arguments, not one array.&lt;/p&gt;

&lt;p&gt;The second &lt;code&gt;when&lt;/code&gt; simply exits the loop if it finds an &amp;ldquo;end-of-expression&amp;rdquo; token. In this example, the argument of the &lt;code&gt;when&lt;/code&gt; is a list of strings, so the &lt;code&gt;when&lt;/code&gt; succeeds if any of them matches the token.&lt;/p&gt;

&lt;p&gt;Of course, since the entire body of the &lt;code&gt;when&lt;/code&gt; block is a single statement, we could also have written the &lt;code&gt;when&lt;/code&gt; as a statement modifier:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        last when &#39;.&#39;, &#39;;&#39;, &#39;=&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The fact that &lt;code&gt;when&lt;/code&gt; has a postfix version like this should come as no surprise, since &lt;code&gt;when&lt;/code&gt; is simply another control structure like &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, etc.&lt;/p&gt;

&lt;p&gt;The postfix version of &lt;code&gt;when&lt;/code&gt; does have one interesting feature. Since it governs a statement, rather than a block, it does not provide the block-&lt;code&gt;when&lt;/code&gt;&amp;rsquo;s automatic &amp;ldquo;&lt;code&gt;break&lt;/code&gt; to the end of my topicalizing block&amp;rdquo; behavior. In this instance, it makes no difference since the &lt;code&gt;last&lt;/code&gt; would do that anyway.&lt;/p&gt;

&lt;p&gt;The final alternative &amp;ndash; pushing the token onto the stack &amp;ndash; is simply a regular Perl &lt;code&gt;push&lt;/code&gt; command. The only interesting feature is that it calls the &lt;a href=&#34;#it&#39;s%20a%20given&#34;&gt;&lt;code&gt;get_data&lt;/code&gt;&lt;/a&gt; subroutine to pre-translate the token if necessary. It also specifies a &lt;code&gt;use fatal&lt;/code&gt; so that &lt;code&gt;get_data&lt;/code&gt; will fail by an throwing exception, rather than returning &lt;code&gt;undef&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The loop tries each of these possibilities in turn. And &amp;ldquo;tries&amp;rdquo; is the operative word here, because either the application of operations or the pushing of data onto the stack may fail, resulting in an exception. To prevent that exception from propagating all the way back to the main program and terminating it, the various alternatives are placed in a &lt;code&gt;try&lt;/code&gt; block.&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;try&lt;/code&gt; block is the Perl 6 successor to Perl 5&amp;rsquo;s &lt;code&gt;eval&lt;/code&gt; block. Unless it includes some explicit error handling code (see &lt;a href=&#34;#where&#39;s%20the%20catch&#34;&gt;Where&amp;rsquo;s the catch???&lt;/a&gt;), it acts exactly like a Perl 5 &lt;code&gt;eval {...}&lt;/code&gt;, intercepting a propagating exception and converting it to an &lt;code&gt;undef&lt;/code&gt; return value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try { $quotient = $numerator / $denominator } // warn &amp;quot;couldn&#39;t divide&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-where-s-the-catch-where-s-the-catch-span&#34;&gt;&lt;span id=&#34;where&#39;s the catch&#34;&gt;Where&amp;rsquo;s the Catch???&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In Perl 6, we aren&amp;rsquo;t limited to just blindly catching a propagating exception and then coping with an &lt;code&gt;undef&lt;/code&gt;. It is also possible to set up an explicit handler to catch, identify and deal with various types of exceptions. That&amp;rsquo;s done in a &lt;code&gt;CATCH&lt;/code&gt; block:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    CATCH {
        when Err::Reportable     { warn $!; continue }
        when Err::BadData        { $!.fail(at=&amp;gt;$toknum) }
        when NoData              { push @stack, 0 }
        when /division by zero/  { push @stack, Inf }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;CATCH&lt;/code&gt; block is like a &lt;code&gt;BEGIN&lt;/code&gt; block (hence the capitalization). Its one argument is a closure that is executed if an exception ever propagates as far as the block in which the &lt;code&gt;CATCH&lt;/code&gt; was declared. If the block eventually executes, then the current topic is aliased to the error variable &lt;code&gt;$!&lt;/code&gt;. So the typical thing to do is to populate the exception handler&amp;rsquo;s closure with a series of &lt;code&gt;when&lt;/code&gt; statements that identify the exception contained in &lt;code&gt;$!&lt;/code&gt; and handle the error appropriately. More on that &lt;a href=&#34;#catch%20as%20catch%20can&#34;&gt;in a moment&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;CATCH&lt;/code&gt; block has one additional property. When its closure has executed, it transfers control to the end of the block in which it was defined. This means that exception handling in Perl 6 is non-resumptive: once an exception is handled, control passes outward, and the code that threw the exception is not automatically re-executed.&lt;/p&gt;

&lt;p&gt;If we did want &amp;ldquo;try, try, try again&amp;rdquo; exception handling instead, then we&amp;rsquo;d need to explicitly code a loop around the code we&amp;rsquo;re trying:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # generate exceptions (sometimes)
    sub getnum_or_die {
        given &amp;lt;&amp;gt; {                      # readline and make it the topic
            die &amp;quot;$_ is not a number&amp;quot;
                unless defined &amp;amp;&amp;amp; /^\d+$/;
            return $_;
        }
    }

    # non-resumptive exception handling
    sub readnum_or_cry {
        return getnum_or_die;       # maybe generate an exception
        CATCH { warn $! }           # if so, warn and fall out of sub
    }

    # pseudo-resumptive
    sub readnum_or_retry {
        loop {                      # loop endlessly...
            return getnum_or_die;   #   maybe generate an exception
            CATCH { warn $! }       #   if so, warn and fall out of loop
        }                           #   (i.e. loop back and try again)
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that this isn&amp;rsquo;t true resumptive exception handling. Control still passes outward &amp;ndash; to the end of the &lt;code&gt;loop&lt;/code&gt; block. But then the &lt;code&gt;loop&lt;/code&gt; reiterates, sending control back into &lt;code&gt;getnum_or_die&lt;/code&gt; for another attempt.&lt;/p&gt;

&lt;h3 id=&#34;span-id-catch-as-catch-can-catch-as-catch-can-span&#34;&gt;&lt;span id=&#34;catch as catch can&#34;&gt;Catch as Catch Can&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Within the &lt;code&gt;CATCH&lt;/code&gt; block, the example uses the standard Perl 6 exception handling technique: a series of &lt;code&gt;when&lt;/code&gt; statements. Those &lt;code&gt;when&lt;/code&gt; statements compare their arguments against the current topic. In a &lt;code&gt;CATCH&lt;/code&gt; block, that topic is always aliased to the error variable &lt;code&gt;$!&lt;/code&gt;, which contains a reference to the propagating exception object.&lt;/p&gt;

&lt;p&gt;The first three &lt;code&gt;when&lt;/code&gt; statements use a classname as their argument. When matching a classname against an object, the &lt;code&gt;=~&lt;/code&gt; operator (and therefore any &lt;code&gt;when&lt;/code&gt; statement) will call the object&amp;rsquo;s &lt;code&gt;isa&lt;/code&gt; method, passing it the classname. So the first three cases of the handler:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    when Err::Reportable   { warn $!; continue }
    when Err::BadData      { $!.fail(at=&amp;gt;$toknum) }
    when NoData            { push @stack, 0 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;are (almost) equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if $!.isa(Err::Reportable)  { warn $! }
    elsif $!.isa(Err::BadData)  { $!.fail(at=&amp;gt;$toknum) }
    elsif $!.isa(NoData)        { push @stack, 0 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;except far more readable.&lt;/p&gt;

&lt;p&gt;The first &lt;code&gt;when&lt;/code&gt; statement simply passes the exception object to &lt;code&gt;warn&lt;/code&gt;. Since &lt;code&gt;warn&lt;/code&gt; takes a string as its argument, the exception object&amp;rsquo;s stringification operator (inherited from the standard &lt;code&gt;Exception&lt;/code&gt; class) is invoked and returns an appropriate diagnostic string, which is printed. The &lt;code&gt;when&lt;/code&gt; block then executes a &lt;code&gt;continue&lt;/code&gt; statement, which circumvents the default &amp;ldquo;&lt;code&gt;break&lt;/code&gt; out of the surrounding topicalizer block&amp;rdquo; semantics of the &lt;code&gt;when&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The second &lt;code&gt;when&lt;/code&gt; statement calls the propagating exception&amp;rsquo;s &lt;code&gt;fail&lt;/code&gt; method to cause &lt;code&gt;calc&lt;/code&gt; either to return or rethrow the exception, depending on whether &lt;code&gt;use fatal&lt;/code&gt; was set. In addition, it passes some extra information to the exception, namely the number of the token that caused the problem.&lt;/p&gt;

&lt;p&gt;The third &lt;code&gt;when&lt;/code&gt; statement handles the case where there is no cached data corresponding to the calculator&amp;rsquo;s &lt;code&gt;&amp;quot;previous&amp;quot;&lt;/code&gt; keyword, by simply pushing a zero onto the stack.&lt;/p&gt;

&lt;p&gt;The final case that the handler tests for:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    when /division by zero/  { push @stack, Inf }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;uses a regex, rather than a classname. This causes the topic (i.e. the exception) to be stringified and pattern-matched against the regex. As mentioned above, by default, all exceptions stringify to their own diagnostic string. So this part of the handler simply tests whether that string includes the words &amp;ldquo;division by zero,&amp;rdquo; in which case it pushes the Perl 6 infinity value onto the stack.&lt;/p&gt;

&lt;h3 id=&#34;span-id-one-dot-only-one-dot-only-span&#34;&gt;&lt;span id=&#34;one dot only&#34;&gt;One Dot Only&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;CATCH&lt;/code&gt; block handled bad data by calling the &lt;code&gt;fail&lt;/code&gt; method of the current exception:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    when Err::BadData  { $!.fail(at=&amp;gt;$toknum) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s a particular instance of a far more general activity: calling a method on the current topic. Perl 6 provides a shortcut for that &amp;ndash; the prefix unary dot operator. Unary dot calls the method that is its single operand, using the current topic as the implicit invocant. So the &lt;code&gt;Err::BadData&lt;/code&gt; handler could have been written:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    when Err::BadData  { .fail(at=&amp;gt;$toknum) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One of the main uses of unary dot is to allow &lt;code&gt;when&lt;/code&gt; statements to select behavior on the basis of method calls. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    given $some_object {
        when .has_data(&#39;new&#39;) { print &amp;quot;New data available\n&amp;quot; }
        when .has_data(&#39;old&#39;) { print &amp;quot;Old data still available\n&amp;quot; }
        when .is_updating     { sleep 1 }
        when .can(&#39;die&#39;)      { .die(&amp;quot;bad state&amp;quot;) }    # $some_object.die(...)
        default               { die &amp;quot;internal error&amp;quot; } # global die
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unary dot is also useful within the definition of methods themselves. In a Perl 6 method, the invocant (i.e. the first argument of the method, which is a reference to the object on which the method was invoked) is always the topic, so instead of writing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method dogtag (Soldier $self) {
        print $self.rank, &amp;quot; &amp;quot;, $self.name, &amp;quot;\n&amp;quot;
            unless $self.status(&#39;covert&#39;);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we can just write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method dogtag (Soldier $self) {     # $self is automagically the topic
        print .rank, &amp;quot; &amp;quot;, .name, &amp;quot;\n&amp;quot;
            unless .status(&#39;covert&#39;);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or even just:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method dogtag {                     # @_[0] is automagically the topic
        print .rank, &amp;quot; &amp;quot;, .name, &amp;quot;\n&amp;quot;
            unless .status(&#39;covert&#39;);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yet another use of unary dot is as a way of abbreviating multiple accesses to hash or array elements. That is, &lt;code&gt;given&lt;/code&gt; also implements the oft-coveted &lt;code&gt;with&lt;/code&gt; statement. If many elements of a hash or array are to be accessed in a set of statements, then we can avoid the tedious repetition of the container name:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # initialize from %options...

    $name  = %options{name} // %options{default_name};
    $age   = %options{age};
    $limit = max(%options{limit}, %options{rate} * %options{count});
    $count = $limit / %options{max_per_count};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;by making it the topic and using unary dot:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # initialize from %options...

    given %options {
        $name  = .{name} // .{default_name};
        $age   = .{age};
        $limit = max(.{limit}, .{rate} * .{count});
        $count = $limit / .{max_per_count};
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S04.html&#34;&gt;Synopsis 4&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-onwards-and-backwards-onward-and-backward-span&#34;&gt;&lt;span id=&#34;onwards and backwards&#34;&gt;Onward and Backward&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Back in our example, after each token has been dealt with in its loop iteration, the iteration is finished. All that remains to do is increment the token number.&lt;/p&gt;

&lt;p&gt;In Perl 5, that would be done in a &lt;code&gt;continue&lt;/code&gt; block at the end of the loop block. In Perl 6, it&amp;rsquo;s done in a &lt;code&gt;NEXT&lt;/code&gt; statement &lt;em&gt;within&lt;/em&gt; the loop block:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    NEXT { $toknum++ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Like a &lt;code&gt;CATCH&lt;/code&gt;, a &lt;code&gt;NEXT&lt;/code&gt; is a special-purpose &lt;code&gt;BEGIN&lt;/code&gt; block that takes a closure as its single argument. The &lt;code&gt;NEXT&lt;/code&gt; pushes that closure onto the end of a queue of &amp;ldquo;next-iteration&amp;rdquo; handlers, all of which are executed each time a loop reaches the end of an iteration. That is, when the loop reaches the end of its block or when it executes an explicit &lt;code&gt;next&lt;/code&gt; or &lt;code&gt;last&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The advantage of moving from Perl 5&amp;rsquo;s external &lt;code&gt;continue&lt;/code&gt; to Perl 6&amp;rsquo;s internal &lt;code&gt;NEXT&lt;/code&gt; is that it gives the &amp;ldquo;next-iteration&amp;rdquo; handler access to any lexical variables declared within the loop block. In addition, it allows the &amp;ldquo;next-iteration&amp;rdquo; handler to be placed anywhere in the loop that&amp;rsquo;s convenient (e.g. close to the initialization it&amp;rsquo;s later supposed to clean up).&lt;/p&gt;

&lt;p&gt;For example, instead of having to write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Perl 5 code
    my $in_file, $out_file;
    while (&amp;lt;&amp;gt;) {
        open $in_file, $_ or die;
        open $out_file, &amp;quot;&amp;gt; $_.out&amp;quot; or die;

        # process files here (maybe next&#39;ing out early)
    }
    continue {
        close $in_file  or die;
        close $out_file or die;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we can just write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    while (&amp;lt;&amp;gt;) {
        my $in_file  = open $_ or die;
        my $out_file = open &amp;quot;&amp;gt; $_.out&amp;quot; or die;
        NEXT {
            close $in_file  or die;
            close $out_file or die;
        }

        # process files here (maybe next&#39;ing out early)
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s no need to declare &lt;code&gt;$in_file&lt;/code&gt; and &lt;code&gt;$out_file&lt;/code&gt; outside the loop, because they don&amp;rsquo;t have to be accessible outside the loop (i.e. in an external &lt;code&gt;continue&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;This ability to declare, access and clean up lexicals within a given scope is especially important because, in Perl 6, there is no reference counting to ensure that the filehandles close themselves automatically immediately at the end of the block. Perl 6&amp;rsquo;s full incremental garbage collector &lt;em&gt;does&lt;/em&gt; guarantee to eventually call the filehandle&amp;rsquo;s destructors, but makes no promises about when that will happen.&lt;/p&gt;

&lt;p&gt;Note that there is also a &lt;code&gt;LAST&lt;/code&gt; statement, which sets up a handler that is called automatically when a block is left for the last time. For example, this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for reverse 1..10 {
        print &amp;quot;$_...&amp;quot; and flush;
        NEXT { sleep 1 }
        LAST { ignition() &amp;amp;&amp;amp; print &amp;quot;lift-off!\n&amp;quot; }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;prints:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    10...9...8...7...6...5...4...3...2...1...lift-off!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sleeping one second after each iteration (including the last one), and then calling &lt;code&gt;&amp;amp;ignition&lt;/code&gt; at the end of the countdown.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LAST&lt;/code&gt; statements are also extremely useful in nonlooping blocks, as a way of giving the block a &amp;ldquo;destructor&amp;rdquo; with which it can clean up its state regardless of how it is exited:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub handler ($value, $was_handled is rw) {
        given $value {
            LAST { $was_handled = 1 }
            when &amp;amp;odd { return &amp;quot;$value is odd&amp;quot; }
            when /0$/ { print &amp;quot;decimal compatible&amp;quot; }
            when /2$/ { print &amp;quot;binary compatible&amp;quot;; break }
            $value %= 7;
            when 1,3,5 { die &amp;quot;odd residual&amp;quot; }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above example, no matter how the &lt;code&gt;given&lt;/code&gt; block exits &amp;ndash; i.e. via the &lt;code&gt;return&lt;/code&gt; of the first &lt;code&gt;when&lt;/code&gt; block, or via the (implicit) &lt;code&gt;break&lt;/code&gt; of the second &lt;code&gt;when&lt;/code&gt;, or via the (explicit and redundant) &lt;code&gt;break&lt;/code&gt; of the third &lt;code&gt;when&lt;/code&gt;, or via the &lt;code&gt;&amp;quot;odd residual&amp;quot;&lt;/code&gt; exception, or by falling off the end of the &lt;code&gt;given&lt;/code&gt; block &amp;ndash; the &lt;code&gt;$was_handled&lt;/code&gt; parameter is always correctly set.&lt;/p&gt;

&lt;p&gt;Note that the &lt;code&gt;LAST&lt;/code&gt; is essential here. It wouldn&amp;rsquo;t suffice to write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub handler ($value, $was_handled is rw) {
        given $value {
            when &amp;amp;odd { return &#39;$value is odd&amp;quot; }
            when /3$/ { print &amp;quot;ternary compatible&amp;quot; }
            when /2$/ { print &amp;quot;binary compatible&amp;quot;; break }
            $value %= 7;
            when 1,3,5 { die &amp;quot;odd residual&amp;quot; }
        }
        $was_handled = 1;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;because then &lt;code&gt;$handled&lt;/code&gt; wouldn&amp;rsquo;t be set if an exception was thrown. Of course, if that&amp;rsquo;s actually the semantics you &lt;em&gt;wanted&lt;/em&gt;, then you don&amp;rsquo;t want &lt;code&gt;LAST&lt;/code&gt; in that case.&lt;/p&gt;

&lt;h3 id=&#34;span-id-why-are-you-shouting-why-are-you-shouting-span&#34;&gt;&lt;span id=&#34;why are you shouting&#34;&gt;WHY ARE YOU SHOUTING???&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;You may be wondering why &lt;code&gt;try&lt;/code&gt; is in lower case but &lt;code&gt;CATCH&lt;/code&gt; is in upper. Or why &lt;code&gt;NEXT&lt;/code&gt; and &lt;code&gt;LAST&lt;/code&gt; blocks have those &amp;ldquo;loud&amp;rdquo; keywords.&lt;/p&gt;

&lt;p&gt;The reason is simple: &lt;code&gt;CATCH&lt;/code&gt;, &lt;code&gt;NEXT&lt;/code&gt; and &lt;code&gt;LAST&lt;/code&gt; blocks are just specialized &lt;code&gt;BEGIN&lt;/code&gt; blocks that install particular types of handlers into the block in which they appear.&lt;/p&gt;

&lt;p&gt;They install those handlers at compile-time so, unlike a &lt;code&gt;try&lt;/code&gt; or a &lt;code&gt;next&lt;/code&gt; or a &lt;code&gt;last&lt;/code&gt;, they don&amp;rsquo;t actually &lt;em&gt;do&lt;/em&gt; anything when the run-time flow of execution reaches them. The blocks associated with them are only executed if the appropriate condition or exception is encountered within their scope. And, if that happens, then they are executed automatically, just like &lt;code&gt;AUTOLOAD&lt;/code&gt;, or &lt;code&gt;DESTROY&lt;/code&gt;, or &lt;code&gt;TIEHASH&lt;/code&gt;, or &lt;code&gt;FETCH&lt;/code&gt;, etc.&lt;/p&gt;

&lt;p&gt;So Perl 6 is merely continuing the long Perl tradition of using a capitalized keyword to highlight code that is executed automatically.&lt;/p&gt;

&lt;p&gt;In other words: I&amp;rsquo;M SHOUTING BECAUSE I WANT YOU TO BE AWARE THAT SOMETHING SUBTLE IS HAPPENING AT THIS POINT.&lt;/p&gt;

&lt;h3 id=&#34;span-id-cache-and-return-cache-and-return-span&#34;&gt;&lt;span id=&#34;cache and return&#34;&gt;Cache and Return&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Meanwhile, back in &lt;code&gt;calc&lt;/code&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;Once the loop is complete and all the tokens have been processed, the result of the calculation should be the top item on the stack. If the stack of items has more than one element left, then it&amp;rsquo;s likely that the expression was wrong somehow (most probably, because there were too many original operands). So we report that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    fail Err::BadData : msg=&amp;gt;&amp;quot;Too many operands&amp;quot;
        if @stack &amp;gt; 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If everything is OK, then we simply pop the one remaining value off the stack and make sure it will evaluate true (even if its value is zero or &lt;code&gt;undef&lt;/code&gt;) by setting its &lt;code&gt;true&lt;/code&gt; property. This avoids the potential bug &lt;a href=&#34;#still%20other%20whens&#34;&gt;discussed earlier&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Finally, we record it in &lt;code&gt;%var&lt;/code&gt; under the key &lt;code&gt;&#39;$n&#39;&lt;/code&gt; (i.e. as the &lt;em&gt;n&lt;/em&gt;-th result), and return it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    return %var{&#39;$&#39; _ $i} = pop(@stack) but true;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;ldquo;But, but, but&amp;hellip;&amp;rdquo;, I hear you expostulate, &amp;ldquo;&amp;hellip;shouldn&amp;rsquo;t that be &lt;code&gt;pop(@stack) is true&lt;/code&gt;???&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Once upon a time, yes. But Larry has recently decided that compile-time and run-time properties should have different keywords. Compile-time properties (i.e. those ascribed to declarations) will still be specified with the &lt;code&gt;is&lt;/code&gt; keyword:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Child is interface;
    my $heart is constant = &amp;quot;true&amp;quot;;
    our $meeting is private;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;whereas run-time properties (i.e. those ascribed to values) will now be specified with the &lt;code&gt;but&lt;/code&gt; keyword:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $str = &amp;lt;$trusted_fh&amp;gt; but tainted(0);
    $fh = open($filename) but chomped;
    return 0 but true;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The choice of &lt;code&gt;but&lt;/code&gt; is meant to convey the fact that run-time properties will generally contradict some standard property of a value, such as its normal truth, chompedness or tainting.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s also meant to keep people from writing the very natural, but very misguided:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if ($x is true) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which now generates a (compile-time) error:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Can&#39;t ascribe a compile-time property to the run-time value of $x.
    (Did you mean &amp;quot;$x but true&amp;quot; or &amp;quot;$x =~ true&amp;quot;?)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-the-forever-loop-the-forever-loop-span&#34;&gt;&lt;span id=&#34;the forever loop&#34;&gt;The Forever Loop&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Once the &lt;code&gt;Calc&lt;/code&gt; module has all its functionality defined, all that&amp;rsquo;s required is to write the main input-process-output loop. We&amp;rsquo;ll cheat a little and write it as an infinite loop, and then (in solemn Unix tradition) we&amp;rsquo;ll require an EOF signal to exit.&lt;/p&gt;

&lt;p&gt;The infinite loop needs to keep track of its iteration count. In Perl 5 that would be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Perl 5 code
    for (my $i=0; 1; $i++) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which would translate into Perl 6 as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    loop (my $i=0; 1; $i++) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;since Perl 5&amp;rsquo;s C-like &lt;code&gt;for&lt;/code&gt; loop has been renamed &lt;code&gt;loop&lt;/code&gt; in Perl 6 &amp;ndash; to distinguish it from the Perl-like &lt;code&gt;for&lt;/code&gt; loop.&lt;/p&gt;

&lt;p&gt;However, Perl 6 also allows us to create semi-infinite, lazily evaluated lists, so we can write the same loop much more cleanly as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for 0..Inf -&amp;gt; $i {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When &lt;code&gt;Inf&lt;/code&gt; is used as the right-hand operand to &lt;code&gt;..&lt;/code&gt;, it signifies that the resulting list must be lazily built, and endlessly iterable. This type of loop will probably be common in Perl 6 as an easy way of providing a loop counter.&lt;/p&gt;

&lt;p&gt;If we need to iterate some list of values, as well as tracking a loop counter, then we can take advantage of another new feature of Perl 6: iteration streams.&lt;/p&gt;

&lt;p&gt;A regular Perl 6 &lt;code&gt;for&lt;/code&gt; loop iterates a single stream of values, aliasing the current topic to each in turn:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @stream -&amp;gt; $topic_from_stream {
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But it&amp;rsquo;s also possible to specify two (or more) streams of values that the one &lt;code&gt;for&lt;/code&gt; loop will step through &lt;em&gt;in parallel&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @stream1 ; @stream2 -&amp;gt; $topic_from_stream1 ; $topic_from_stream2 {
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each stream of values is separated by a semicolon, and each topic variable is similarly separated. The &lt;code&gt;for&lt;/code&gt; loop iterates both streams in parallel, aliasing the next element of the first stream (&lt;code&gt;@stream1&lt;/code&gt;) to the first topic (&lt;code&gt;$topic_from_stream1&lt;/code&gt;) and the next element of the second stream (&lt;code&gt;@stream2&lt;/code&gt;) to the second topic (&lt;code&gt;$topic_from_stream2&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;The commonest application of this will probably be to iterate a list and simultaneously provide an iteration counter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @list; 0..@list.last -&amp;gt; $next; $index {
        print &amp;quot;Element $index is $next\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It may be useful to set that out slightly differently, to show the parallel nature of the iteration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for  @list ; 0..@list.last
     -&amp;gt;  $next ; $index   {
        print &amp;quot;Element $index is $next\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s important to note that writing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @a; @b -&amp;gt; $x; $y {...}
    # in parallel, iterate @a one-at-a-time as $x, and @b one-at-a-time as $y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is &lt;em&gt;not&lt;/em&gt; the same as writing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @a, @b -&amp;gt; $x, $y {...}
    # sequentially iterate @a then @b, two-at-a-time as $x and $y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The difference is that semicolons separate streams, while commas separate elements within a single stream.&lt;/p&gt;

&lt;p&gt;If we were brave enough, then we could even combine the two:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @a1, @a2; @b -&amp;gt; $x; $y1, $y2 {...}
    # sequentially iterate @a1 then @a2, one-at-a-time as $x
    # and, in parallel, iterate @b two-at-a-time as $y1 and $y2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is definitely a case where a different layout would help make the various iterations and topic bindings clearer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @a1, @a2 ;  @b
     -&amp;gt; $x       ;  $y1, $y2   {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note, however, that the normal way in Perl 6 to step through an array&amp;rsquo;s values while tracking its indices will almost certainly be to use the array&amp;rsquo;s &lt;code&gt;kv&lt;/code&gt; method. That method returns a list of interleaved indices and values (much like the hash&amp;rsquo;s &lt;code&gt;kv&lt;/code&gt; method returns alternating keys and values):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @list.kv -&amp;gt; $index, $next {
        print &amp;quot;Element $index is $next\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S04.html&#34;&gt;Synopsis 4&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-read-or-die-read-or-die-span&#34;&gt;&lt;span id=&#34;read or die&#34;&gt;Read or Die&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Having prompted for the next expression that the calculator will evaluate:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print &amp;quot;$i&amp;gt; &amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we read in the expression and check for an EOF (which will cause the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator to return &lt;code&gt;undef&lt;/code&gt;, in which case we escape the infinite loop):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $expr = &amp;lt;&amp;gt; err last;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Err&amp;hellip;&lt;code&gt;err&lt;/code&gt;???&lt;/p&gt;

&lt;p&gt;In &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html&#34;&gt;Apocalypse 3&lt;/a&gt;, Larry introduced the &lt;code&gt;//&lt;/code&gt; operator, which is like a &lt;code&gt;||&lt;/code&gt; that tests its left operand for definedness rather than truth.&lt;/p&gt;

&lt;p&gt;What he didn&amp;rsquo;t mention (but which you probably guessed) was that there is also the low-precedence version of &lt;code&gt;//&lt;/code&gt;. Its name is &lt;code&gt;err&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          Operation         High Precedence       Low Precedence

         INCLUSIVE OR             ||                     or
         EXCLUSIVE OR             ~~                    xor
          DEFINED OR              //                    err
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But why call it &lt;code&gt;err&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Well, the &lt;code&gt;//&lt;/code&gt; operator looks like a skewed version of &lt;code&gt;||&lt;/code&gt;, so the low-precedence version should probably be a skewed version of &lt;code&gt;or&lt;/code&gt;. We can&amp;rsquo;t skew it visually (even Larry thought that using italics would be going a bit far), so we skew it phonetically instead: &lt;code&gt;or&lt;/code&gt; -&amp;gt; &lt;code&gt;err&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;err&lt;/code&gt; also has the two handy mnemonic connotations:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;That we&amp;rsquo;re handling an &lt;strong&gt;err&lt;/strong&gt;or marker (which a returned &lt;code&gt;undef&lt;/code&gt; usually is)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;That we&amp;rsquo;re voicing a surprised double-take after something unexpected (which a returned &lt;code&gt;undef&lt;/code&gt; often is).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Besides all that, it just seems to work well. That is, something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $value = compute_value(@args)
        err die &amp;quot;Was expecting a defined value&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;reads quite naturally in English (whether you think of &lt;code&gt;err&lt;/code&gt; as an abbreviation of &amp;ldquo;on error&amp;hellip;&amp;rdquo;, or as a synonym for &amp;ldquo;oops&amp;hellip;&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;Note that &lt;code&gt;err&lt;/code&gt; is a binary operator, just like &lt;code&gt;or&lt;/code&gt;, and &lt;code&gt;xor&lt;/code&gt;, so there&amp;rsquo;s no particular need to start it on a new line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $value = compute_value(@args) err die &amp;quot;Was expecting a defined value&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In our example program, the &lt;code&gt;undef&lt;/code&gt; returned by the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator at end-of-file is our signal to jump out of the main loop. To accomplish that we simply append &lt;code&gt;err last&lt;/code&gt; to the input statement:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $expr = &amp;lt;&amp;gt; err last;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that an &lt;code&gt;or last&lt;/code&gt; wouldn&amp;rsquo;t work here, as both the empty string and the string &amp;ldquo;0&amp;rdquo; are valid (i.e. non-terminating) inputs to the calculator.&lt;/p&gt;

&lt;h3 id=&#34;span-id-just-do-it-just-do-it-span&#34;&gt;&lt;span id=&#34;just do it&#34;&gt;Just Do It&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Then it&amp;rsquo;s just a matter of calling &lt;code&gt;Calc::calc&lt;/code&gt;, passing it the iteration number and the expression:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Calc::calc(i=&amp;gt;$i, expr=&amp;gt;$expr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that we used named arguments, so passing them in the wrong order didn&amp;rsquo;t matter.&lt;/p&gt;

&lt;p&gt;We then interpolate the result back into the output string using the &lt;code&gt;$(...)&lt;/code&gt; scalar interpolator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print &amp;quot;$i&amp;gt; $( Calc::calc(i=&amp;gt;$i, expr=&amp;gt;$expr) )\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We could even simplify that a little further, by taking advatage of the fact that subroutine calls interpolate directly into strings in Perl 6, provided we use the &lt;code&gt;&amp;amp;&lt;/code&gt; prefix:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print &amp;quot;$i&amp;gt; &amp;amp;Calc::calc(i=&amp;gt;$i, expr=&amp;gt;$expr)\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Either way, that&amp;rsquo;s it: we&amp;rsquo;re done.&lt;/p&gt;

&lt;h3 id=&#34;span-id-summing-up-summing-up-span&#34;&gt;&lt;span id=&#34;summing up&#34;&gt;Summing Up&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In terms of control structures, Perl 6:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;provides far more support for exceptions and exception handling,&lt;/li&gt;
&lt;li&gt;cleans up and extends the &lt;code&gt;for&lt;/code&gt; loop syntax in several ways,&lt;/li&gt;
&lt;li&gt;unifies the notions of blocks and closures and makes them interchangeable,&lt;/li&gt;
&lt;li&gt;provides hooks for attaching various kinds of automatic handlers to a block/closure,&lt;/li&gt;
&lt;li&gt;re-factors the concept of a switch statement into two far more general ideas: marking a value/variable as the current topic, and then doing &amp;ldquo;smart matching&amp;rdquo; against that topic.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These extensions and cleanups offer us far more power and control, and &amp;ndash; amazingly &amp;ndash; in most cases require far less syntax. For example, here&amp;rsquo;s (almost) the same program, written in Perl 5:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package Err::BadData; 
    use base &#39;Exception&#39;;   # which you&#39;d have to write yourself

    package NoData;         # not lexical
    use base &#39;Exception&#39;;
    sub warn { die @_ }

    package Calc;

    my %var;

    sub get_data  {
        my $data = shift;
        if ($data =~ /^\d+$/)       { return $var{&amp;quot;&amp;quot;} = $data }
        elsif ($data eq &#39;previous&#39;) { return defined $var{&amp;quot;&amp;quot;}
                                                 ? $var{&amp;quot;&amp;quot;}
                                                 : die NoData-&amp;gt;new() 
                                    }
        elsif ($var{$data})         { return $var{&amp;quot;&amp;quot;} = $var{$data} }
        else                        { die Err::BadData-&amp;gt;new(
                                             {msg=&amp;gt;&amp;quot;Don&#39;t understand $data&amp;quot;}
                                          )
                                     }
    }

    sub calc {
        my %data = @_;
        my ($i, $expr) = @data{&#39;i&#39;, &#39;expr&#39;};
        my %operator = (
            &#39;*&#39;  =&amp;gt; sub { $_[0] * $_[1] },
            &#39;/&#39;  =&amp;gt; sub { $_[0] / $_[1] },
            &#39;~&#39;  =&amp;gt; sub { ($_[0] + $_[1]) / 2 },
        );

        my @stack;
        my $toknum = 1;
        LOOP: for my $token (split /\s+/, $expr) {
            defined eval {
                TRY: if ($operator{$token}) {
                    my @args = splice @stack, -2;
                    push @stack, $operator{$token}-&amp;gt;(@args);
                    last TRY;
                }
                last LOOP if $token eq &#39;.&#39; || $token eq &#39;;&#39; || $token eq &#39;=&#39;;

                push @stack, get_data($token);
            } || do {
                if ($@-&amp;gt;isa(Err::Reportable))     { warn $@; }
                if ($@-&amp;gt;isa(Err::BadData))        { $@-&amp;gt;{at} = $i; die $@ }
                elsif ($@-&amp;gt;isa(NoData))           { push @stack, 0     }
                elsif ($@ =~ /division by zero/)  { push @stack, ~0 }
            }
        }
        continue { $toknum++ }
        die Err::BadData-&amp;gt;new(msg=&amp;gt;&amp;quot;Too many operands&amp;quot;) if @stack &amp;gt; 1;
        $var{&#39;$&#39;.$i} = $stack[-1] . &#39; but true&#39;;
        return 0+pop(@stack);
    }

    package main;

    for (my $i=1; 1; $i++) {
        print &amp;quot;$i&amp;gt; &amp;quot;;
        defined( my $expr = &amp;lt;&amp;gt; ) or last;
        print &amp;quot;$i&amp;gt; ${\Calc::calc(i=&amp;gt;$i, expr=&amp;gt;$expr)}\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hmmmmmmm. I know which version &lt;em&gt;I&amp;rsquo;d&lt;/em&gt; rather maintain.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Exegesis 3</title>
      <link>http://localhost:1313/pub/2001/10/03/exegesis3.html/</link>
      <pubDate>Wed, 03 Oct 2001 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2001/10/03/exegesis3.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S03.html&#34;&gt;Synopsis 3&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Diamond lives (context-aware);&lt;/em&gt;
&lt;em&gt;Underscore space means concatenate; fat comma means pair;&lt;/em&gt;
&lt;em&gt;A pre-star will flatten; colon-equals will bind;&lt;/em&gt;
&lt;em&gt;And binary slash-slash yields left-most defined.&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ndash; Sade, &amp;ldquo;Smooth operator&amp;rdquo; (Perl 6 remix)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;In &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html&#34;&gt;Apocalypse 3&lt;/a&gt;, Larry describes the changes that Perl 6 will make to operators and their operations. As with all the Apocalypses, only the new and different are presented &amp;ndash; just remember that the vast majority of operator-related syntax and semantics will stay precisely as they are in Perl 5.&lt;/p&gt;

&lt;h3 id=&#34;span-id-for-example-span-for-example&#34;&gt;&lt;span id=&#34;for example...&#34;&gt;&lt;/span&gt;For example&amp;hellip;&lt;/h3&gt;

&lt;p&gt;To better understand those new and different aspects of Perl 6 operators, let&amp;rsquo;s consider the following program. Suppose we wanted to locate a particular data file in one or more directories, read the first four lines of each such file, report and update their information, and write them back to disk.&lt;/p&gt;

&lt;p&gt;We could do that with this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub load_data ($filename ; $version, *@dirpath) {
        $version //= 1;
        @dirpath //= @last_dirpath // @std_dirpath // &#39;.&#39;;
        @dirpath ^=~ s{([^/])$}{$1/};

        my %data;
        foreach my $prefix (@dirpath) {
            my $filepath = $prefix _ $filename;
            if (-w -r -e $filepath  and  100 &amp;lt; -s $filepath &amp;lt;= 1e6) {
                my $fh = open $filepath : mode=&amp;gt;&#39;rw&#39;
                    or die &amp;quot;Something screwy with $filepath: $!&amp;quot;;
                my ($name, $vers, $status, $costs) = &amp;lt;$fh&amp;gt;;
                next if $vers &amp;lt; $version;
                $costs = [split /\s+/, $costs];
                %data{$filepath}{qw(fh name vers stat costs)} =
                                ($fh, $name, $vers, $status, $costs);
            }
        }
        return %data;
    }

    my @StartOfFile is const = (0,0);

    sub save_data ( %data) {
        foreach my $data (values %data) {
            my $rest = &amp;lt;$data.{fh}.irs(undef)&amp;gt;
            seek $data.{fh}: *@StartOfFile;
            truncate $data.{fh}: 0;
            $data.{fh}.ofs(&amp;quot;\n&amp;quot;);
            print $data.{fh}: $data.{qw(name vers stat)}, _@{$data.{costs}}, $rest;
         }
    }

    my %data = load_data(filename=&amp;gt;&#39;weblog&#39;, version=&amp;gt;1);

    my $is_active_bit is const = 0x0080;

    foreach my $file (keys %data) {
        print &amp;quot;$file contains data on %data{$file}{name}\n&amp;quot;;

        %data{$file}{stat} = %data{$file}{stat} ~ $is_active_bit;

        my @costs := @%data{$file}{costs};

        my $inflation;
        print &amp;quot;Inflation rate: &amp;quot; and $inflation = +&amp;lt;&amp;gt;
            until $inflation != NaN;

        @costs = map  { $_.value }
                 sort { $a.key &amp;lt;=&amp;gt; $b.key }
                 map  { amortize($_) =&amp;gt; $_ }
                        @costs ^* $inflation;

        my sub operator:∑ is prec(\&amp;amp;operator:+($)) (*@list : $filter //= undef) {
               reduce {$^a+$^b}  ($filter ?? grep &amp;amp;$filter, @list :: @list);
        }

        print &amp;quot;Total expenditure: $( ∑ @costs )\n&amp;quot;;
        print &amp;quot;Major expenditure: $( ∑ @costs : {$^_ &amp;gt;= 1000} )\n&amp;quot;;
        print &amp;quot;Minor expenditure: $( ∑ @costs : {$^_ &amp;lt; 1000} )\n&amp;quot;;

        print &amp;quot;Odd expenditures: @costs[1..Inf:2]\n&amp;quot;;
    }

    save_data(%data, log =&amp;gt; {name=&amp;gt;&#39;metalog&#39;, vers=&amp;gt;1, costs=&amp;gt;[], stat=&amp;gt;0});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-i-was-bound-under-a-flattening-star-span-i-was-bound-under-a-flattening-star&#34;&gt;&lt;span id=&#34;i was bound under a flattening star&#34;&gt;&lt;/span&gt;I was bound under a flattening star&lt;/h3&gt;

&lt;p&gt;The first subroutine takes a filename and (optionally) a version number and a list of directories to search:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub load_data ($filename ; $version, *@dirpath) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the directory path parameter is declared as &lt;code&gt;*@dirpath&lt;/code&gt;, not &lt;code&gt;@dirpath&lt;/code&gt;. In Perl 6, declaring a parameter as an array (i.e &lt;code&gt;@dirpath&lt;/code&gt;) causes Perl to expect the corresponding argument will be an actual array (or an array reference), not just any old list of values. In other words, a &lt;code&gt;@&lt;/code&gt; parameter in Perl 6 is like a &lt;code&gt;\@&lt;/code&gt; context specifier in Perl 5.
To allow &lt;code&gt;@dirpath&lt;/code&gt; to accept a list of arguments, we have to use the &lt;em&gt;list context specifier&lt;/em&gt; &amp;ndash; unary &lt;code&gt;*&lt;/code&gt; &amp;ndash; to tell Perl to &amp;ldquo;slurp up&amp;rdquo; any remaining arguments into the &lt;code&gt;@dirpath&lt;/code&gt; parameter.&lt;/p&gt;

&lt;p&gt;This slurping-up process consists of flattening any arguments that are arrays or hashes, and then assigning the resulting list of values, together with any other scalar arguments, to the array (i.e. to &lt;code&gt;@dirpath&lt;/code&gt; in this example). In other words, a &lt;code&gt;*@&lt;/code&gt; parameter in Perl 6 is like a &lt;code&gt;@&lt;/code&gt; context specifier in Perl 5.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S03.html&#34;&gt;Synopsis 3&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-it-s-a-setup-span-it-s-a-setup&#34;&gt;&lt;span id=&#34;it&#39;s a setup&#34;&gt;&lt;/span&gt;It&amp;rsquo;s a setup&lt;/h3&gt;

&lt;p&gt;In Perl 5, it&amp;rsquo;s not uncommon to see people using the &lt;code&gt;||=&lt;/code&gt; operator to set up default values for subroutine parameters or input data:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $offset ||= 1;
    $suffix ||= $last_suffix || $default_suffix || &#39;.txt&#39;;
    # etc.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, unless you&amp;rsquo;re sure of your range of values, this can go horribly wrong &amp;ndash; specifically, if the variable being initialized already has a valid value that Perl happens to consider false (i.e if &lt;code&gt;$suffix&lt;/code&gt; or &lt;code&gt;$last_suffix&lt;/code&gt; or &lt;code&gt;$default_suffix&lt;/code&gt; contained an empty string, or the offset really &lt;em&gt;was&lt;/em&gt; meant to be zero).&lt;/p&gt;

&lt;p&gt;So people have been forced to write default initializers like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $offset = 1 unless defined $offset;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which is OK for a single alternative, but quickly becomes unwieldy when there are several alternatives:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $suffix = $last_suffix    unless defined $suffix;
    $suffix = $default_suffix unless defined $suffix;
    $suffix = &#39;.txt&#39;          unless defined $suffix;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perl 6 introduces a binary &amp;lsquo;default&amp;rsquo; operator &amp;ndash; &lt;code&gt;//&lt;/code&gt; &amp;ndash; that solves this problem. The default operator evaluates to its left operand if that operand is defined, otherwise it evaluates to its right operand. When chained together, a sequence of &lt;code&gt;//&lt;/code&gt; operators evaluates to the first operand in the sequence that is defined. And, of course, the assignment variant &amp;ndash; &lt;code&gt;//=&lt;/code&gt; &amp;ndash; only assigns to its lvalue if that lvalue is currently undefined.&lt;/p&gt;

&lt;p&gt;The symbol for the operator was chosen to be reminiscent of a &lt;code&gt;||&lt;/code&gt;, but one that&amp;rsquo;s taking a slightly different angle on things.&lt;/p&gt;

&lt;p&gt;So &lt;code&gt;&amp;amp;load_data&lt;/code&gt; ensures that its parameters have sensible defaults like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $version //= 1;
    @dirpath //= @last_dirpath // @std_dirpath // &#39;.&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that it will also be possible to provide default values directly in the specification of optional parameters, probably like this:
        sub load_data ($filename ; $version //= 1, *@dirpath //= @std_dirpath) {&amp;hellip;}&lt;/p&gt;

&lt;h3 id=&#34;span-id-and-context-for-all-span-and-context-for-all&#34;&gt;&lt;span id=&#34;...and context for all&#34;&gt;&lt;/span&gt;&amp;hellip;and context for all&lt;/h3&gt;

&lt;p&gt;As if it weren&amp;rsquo;t broken enough already, there&amp;rsquo;s another nasty problem with using &lt;code&gt;||&lt;/code&gt; to build default initializers in Perl 5. Namely, that it doesn&amp;rsquo;t work quite as one might expect for arrays or hashes either.
If you write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @last_mailing_list = (&#39;me&#39;, &#39;my@shadow&#39;);

    # and later...

    @mailing_list = @last_mailing_list || @std_mailing_list;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then you get a nasty surprise: In Perl 5, &lt;code&gt;||&lt;/code&gt; (and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, for that matter) always evaluates its left argument in &lt;em&gt;scalar&lt;/em&gt; context. And in a scalar context an array evaluates to the number of elements it contains, so &lt;code&gt;@last_mailing_list&lt;/code&gt; evaluates to &lt;code&gt;2&lt;/code&gt;. And that&amp;rsquo;s what&amp;rsquo;s assigned to &lt;code&gt;@mailing_list&lt;/code&gt; instead of the actual two elements.
Perl 6 fixes that problem, too. In Perl 6, both sides of an &lt;code&gt;||&lt;/code&gt; (or a &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; or a &lt;code&gt;//&lt;/code&gt;) are evaluated in the same context as the complete expression. That means, in the example above, &lt;code&gt;@last_mailing_list&lt;/code&gt; is evaluated in list context, so its two elements are assigned to &lt;code&gt;@mailing_list&lt;/code&gt;, as expected.&lt;/p&gt;

&lt;h3 id=&#34;span-id-substitute-our-vector-victor-span-substitute-our-vector-victor&#34;&gt;&lt;span id=&#34;substitute our vector, victor!&#34;&gt;&lt;/span&gt;Substitute our vector, Victor!&lt;/h3&gt;

&lt;p&gt;The next step in &lt;code&gt;&amp;amp;load_data&lt;/code&gt; is to ensure that each path in &lt;code&gt;@dirpath&lt;/code&gt; ends in a directory separator. In Perl 5, we might do that with:
        s{([^/])$}{$1/} foreach @dirpath;&lt;/p&gt;

&lt;p&gt;but Perl 6 gives us another alternative: hyper-operators.
Normally, when an array is an operand of a unary or binary operator, it is evaluated in the scalar context imposed by the operator and yields a single result. For example, if we execute:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $account_balance   = @credits + @debits;
    $biblical_metaphor = @sheep - @goats;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then &lt;code&gt;$account_balance&lt;/code&gt; gets the total number of credits plus the number of debits, and &lt;code&gt;$biblical_metaphor&lt;/code&gt; gets the numerical difference between the number of &lt;code&gt;@sheep&lt;/code&gt; and &lt;code&gt;@goats&lt;/code&gt;.
That&amp;rsquo;s fine, but this scalar coercion also happens when the operation is in a list context:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @account_balances   = @credits + @debits;
    @biblical_metaphors = @sheep - @goats;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Many people find it counter-intuitive that these statements each produce the same scalar result as before and then assign it as the single element of the respective lvalue arrays.
It would be more reasonable to expect these to act like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Perl 5 code...
    @account_balances   =
            map { $credits[$_] + $debits[$_] } 0..max($#credits,$#debits);
    @biblical_metaphors =
            map { $sheep[$_] - $goats[$_] } 0..max($#sheep,$#goats);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is, to apply the operation element-by-element, pairwise along the two arrays.
Perl 6 makes that possible, though &lt;em&gt;not&lt;/em&gt; by changing the list context behavior of the existing operators. Instead, Perl 6 provides a &amp;ldquo;vector&amp;rdquo; version of each binary operator. Each uses the same symbol as the corresponding scalar operator, but with a caret (&lt;code&gt;^&lt;/code&gt;) dangled in front of it. Hence to get the one-to-one addition of corresponding credits and debits, and the list of differences between pairs of sheep and goats, we can write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @account_balances   = @credits ^+ @debits;
    @biblical_metaphors = @sheep ^- @goats;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works for &lt;em&gt;all&lt;/em&gt; unary and binary operators, including those that are user-defined. If the two arguments are of different lengths, the operator Does What You Mean (which, depending on the operator, might involve padding with ones, zeroes or &lt;code&gt;undef&lt;/code&gt;&amp;rsquo;s, or throwing an exception).&lt;/p&gt;

&lt;p&gt;If one of the arguments is a scalar, that operand is replicated as many times as is necessary. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @interest = @account_balances ^* $interest_rate;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which brings us back to the problem of appending those directory separators. The &amp;ldquo;pattern association&amp;rdquo; operator (&lt;code&gt;=~&lt;/code&gt;) can also be vectorized by prepending a caret, so we can apply the necessary substitution to each element in the &lt;code&gt;@dirpath&lt;/code&gt; array like this:
        @dirpath ^=~ s{([^/])$}{$1/};&lt;/p&gt;

&lt;h3 id=&#34;span-id-pre-fixing-those-filenames-span-pre-fixing-those-filenames&#34;&gt;&lt;span id=&#34;(pre)fixing those filenames&#34;&gt;&lt;/span&gt;(Pre)fixing those filenames&lt;/h3&gt;

&lt;p&gt;Having ensured everything is set up correctly, &lt;code&gt;&amp;amp;load_data&lt;/code&gt; then processes each candidate file in turn, accumulating data as it goes:
        my %data;
        foreach my $prefix (@dirpath) {&lt;/p&gt;

&lt;p&gt;The first step is to create the full file path, by prefixing the current directory path to the basic filename:
            my $filepath = $prefix _ $filename;&lt;/p&gt;

&lt;p&gt;And here we see the new Perl 6 string concatenation operator: underscore. And yes, we realize it&amp;rsquo;s going to take time to get used to. It may help to think of it as the old dot operator under extreme acceleration.
Underscore is still a valid identifier character, so you need to be careful about spacing it from a preceding or following identifier (just as you&amp;rsquo;ve always have with the &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;eq&lt;/code&gt; operators):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Perl 6 code                   # Meaning

    $name = getTitle _ getName;     # getTitle() . getName()
    $name = getTitle_ getName;      # getTitle_(getName())
    $name = getTitle _getName;      # getTitle(_getName())
    $name = getTitle_getName;       # getTitle_getName()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Perl 6, there&amp;rsquo;s also a unary form of &lt;code&gt;_&lt;/code&gt;. We&amp;rsquo;ll get to that &lt;a href=&#34;http://localhost:1313/pub/2001/10/03/exegesis3.html?page=4#string%20&#39;em%20up%20together&#34;&gt;a little later&lt;/a&gt;.
&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S03.html&#34;&gt;Synopsis 3&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-don-t-break-the-chain-span-don-t-break-the-chain&#34;&gt;&lt;span id=&#34;don&#39;t break the chain&#34;&gt;&lt;/span&gt;Don&amp;rsquo;t break the chain&lt;/h3&gt;

&lt;p&gt;Of course, we only want to load the file&amp;rsquo;s data if the file exists, is readable and writable, and isn&amp;rsquo;t too big or too small (say, no less than 100 bytes and no more than a million). In Perl 5 that would be:
        if (-e $filepath  &amp;amp;&amp;amp;  -r $filepath  &amp;amp;&amp;amp;  -w $filepath  and
            100 &amp;lt; -s $filepath  &amp;amp;&amp;amp;  -s $filepath &amp;lt;= 1e6) {&amp;hellip;&lt;/p&gt;

&lt;p&gt;which has far too many &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&amp;rsquo;s and &lt;code&gt;$filepath&lt;/code&gt;&amp;rsquo;s for its own good.
In Perl 6, the same set of tests can be considerably abbreviated by taking advantage of two new types of operator chaining:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if (-w -r -e $filepath  and  100 &amp;lt; -s $filepath &amp;lt;= 1e6) {...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, the &lt;code&gt;-X&lt;/code&gt; file test operators now all return a special object that evaluates true or false in a boolean context but is really an encapsulated &lt;code&gt;stat&lt;/code&gt; buffer, to which subsequent file tests can be applied. So now you can put as many file tests as you like in front of a single filename or filehandle and they must all be true for the whole expression to be true. Note that because these are really nested calls to the various file tests (i.e. &lt;code&gt;-w(-r(-e($filepath)))&lt;/code&gt;), the series of tests are effectively evaluated in right-to-left order.
The test of the file size uses another new form of chaining that Perl 6 supports: multiway comparisons. An expression like &lt;code&gt;100 &amp;lt; -s $filepath &amp;lt;= 1e6&lt;/code&gt; isn&amp;rsquo;t even legal Perl 5, but it Does The Right Thing in Perl 6. More importantly, it short-circuits if the first comparison fails and will evaluate each operand only once.&lt;/p&gt;

&lt;h3 id=&#34;span-id-open-for-business-span-open-for-business&#34;&gt;&lt;span id=&#34;open for business&#34;&gt;&lt;/span&gt;Open for business&lt;/h3&gt;

&lt;p&gt;Having verified the file&amp;rsquo;s suitability, we open it for reading and writing:
        my $fh = open $filepath : mode=&amp;gt;&amp;lsquo;rw&amp;rsquo;
            or die &amp;ldquo;Something screwy with $filepath: $!&amp;ldquo;;&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;: mode=&amp;gt;&#39;rw&#39;&lt;/code&gt; is an &lt;em&gt;adverbial modifier&lt;/em&gt; on the &lt;code&gt;open&lt;/code&gt;. We&amp;rsquo;ll see more adverbs &lt;a href=&#34;http://localhost:1313/pub/2001/10/03/exegesis3.html?page=7#would%20you%20like%20an%20adverb%20with%20that&#34;&gt;shortly&lt;/a&gt;.
The &lt;code&gt;$!&lt;/code&gt; variable is exactly what you think it is: a container for the last system error message. It&amp;rsquo;s also considerably &lt;em&gt;more&lt;/em&gt; than you think it is, since it&amp;rsquo;s also taken over the roles of &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;$@&lt;/code&gt;, to become the One True Error Variable.&lt;/p&gt;

&lt;h3 id=&#34;span-id-applied-laziness-101-span-applied-laziness-101&#34;&gt;&lt;span id=&#34;applied laziness 101&#34;&gt;&lt;/span&gt;Applied laziness 101&lt;/h3&gt;

&lt;p&gt;Contrary to earlier rumors, the &amp;ldquo;diamond&amp;rdquo; input operator is alive and well and living in Perl 6 (yes, the Perl Ministry of Truth is even now rewriting &lt;a href=&#34;http://localhost:1313/pub/2001/05/03/wall.html&#34;&gt;Apocalypse 2&lt;/a&gt; to correct the &amp;hellip; err &amp;hellip; &amp;ldquo;printing error&amp;rdquo; &amp;hellip; that announced &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; would be purged from the language).
So we can happily proceed to read in four lines of data:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my ($name, $vers, $status, $costs) = &amp;lt;$fh&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, writing something like this is a common Perl 5 mistake &amp;ndash; the list context imposed by the list of lvalues induces &lt;code&gt;&amp;lt;$fh&amp;gt;&lt;/code&gt; to read the entire file, create a list of (possibly hundreds of thousands of) lines, assign the first four to the specified variables, and throw the rest away. That&amp;rsquo;s rarely the desired effect.
In Perl 6, this statement works as it should. That is, it works out how many values the lvalue list is actually expecting and then reads only that many lines from the file.&lt;/p&gt;

&lt;p&gt;Of course, if we&amp;rsquo;d written:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my ($name, $vers, $status, $costs, @and_the_rest) = &amp;lt;$fh&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then the entire file &lt;em&gt;would&lt;/em&gt; have been read.&lt;/p&gt;

&lt;h3 id=&#34;span-id-and-now-for-something-completely-the-same-well-almost-span-and-now-for-something-completely-the-same-well-almost&#34;&gt;&lt;span id=&#34;and now for something completely the same (well, almost)&#34;&gt;&lt;/span&gt;And now for something completely the same (well, almost)&lt;/h3&gt;

&lt;p&gt;Apart from the new sigil syntax (i.e. hashes now keep their &lt;code&gt;%&lt;/code&gt; signs no matter what they&amp;rsquo;re doing), the remainder of &lt;code&gt;&amp;amp;load_data&lt;/code&gt; is exactly as it would have been if we&amp;rsquo;d written it in Perl 5.
We skip to the next file if the current file&amp;rsquo;s version is wrong. Otherwise, we split the costs line into an array of whitespace-delimited values, and then save everything (including the still-open filehandle) in a nested hash within &lt;code&gt;%data&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            next if $vers &amp;lt; $version;
            $costs = [split /\s+/, $costs];
            %data{$filepath}{qw(fh name vers stat costs)} =
                          ($fh, $name, $vers, $status, $costs);
            }
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, once we&amp;rsquo;ve iterated over all the directories in &lt;code&gt;@dirpath&lt;/code&gt;, we return the accumulated data:
            return %data;
        }&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-virtue-of-constancy-span-the-virtue-of-constancy&#34;&gt;&lt;span id=&#34;the virtue of constancy&#34;&gt;&lt;/span&gt;The virtue of constancy&lt;/h3&gt;

&lt;p&gt;Perl 6 variables can be used as constants:
        my @StartOfFile is const = (0,0);&lt;/p&gt;

&lt;p&gt;which is a great way to give logical names to literal values, but ensure that those named values aren&amp;rsquo;t accidentally changed in some other part of the code.&lt;/p&gt;

&lt;h3 id=&#34;span-id-writing-it-back-span-writing-it-back&#34;&gt;&lt;span id=&#34;writing it back&#34;&gt;&lt;/span&gt;Writing it back&lt;/h3&gt;

&lt;p&gt;When the data is eventually saved, we&amp;rsquo;ll be passing it to the &lt;code&gt;&amp;amp;save_data&lt;/code&gt; subroutine in a hash. If we expected the hash to be a real hash variable (or a reference to one), we&amp;rsquo;d write:
        sub save_data (%data) {&amp;hellip;&lt;/p&gt;

&lt;p&gt;But since we want to allow for the possibility that the hash is created on the fly (e.g. from a hash-like list of values), we need to use the slurp-it-all-up list context asterisk again:
        sub save_data (*%data) {&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;span-id-from-each-according-to-its-ability-span-from-each-according-to-its-ability&#34;&gt;&lt;span id=&#34;from each according to its ability ... &#34;&gt;&lt;/span&gt;From each according to its ability &amp;hellip;&lt;/h3&gt;

&lt;p&gt;We then grab each datum for each file with the usual &lt;code&gt;foreach ... values ...&lt;/code&gt; construct:
            foreach my $data (values %data) {&lt;/p&gt;

&lt;p&gt;and go about saving the data to file.&lt;/p&gt;

&lt;h3 id=&#34;span-id-your-allinone-input-supplier-span-your-all-in-one-input-supplier&#34;&gt;&lt;span id=&#34;your allinone input supplier&#34;&gt;&lt;/span&gt;Your all-in-one input supplier&lt;/h3&gt;

&lt;p&gt;Because the Perl 6 &amp;ldquo;diamond&amp;rdquo; operator can take an arbitrary expression as its argument, it&amp;rsquo;s possible to set a filehandle to read an entire file &lt;em&gt;and&lt;/em&gt; do the actual reading, all in a single statement:
        my $rest = &amp;lt;$data.{fh}.irs(undef)&amp;gt;&lt;/p&gt;

&lt;p&gt;The variable &lt;code&gt;$data&lt;/code&gt; stores a reference to a hash, so to dereference it and access the &lt;code&gt;&#39;fh&#39;&lt;/code&gt; entry, we use the Perl 6 dereferencing operator (dot) and write: &lt;code&gt;$data.{fh}&lt;/code&gt;. In practice, we could leave out the operator and just write &lt;code&gt;$data{fh}&lt;/code&gt;, since Perl can infer from the &lt;code&gt;$&lt;/code&gt; sigil that we&amp;rsquo;re accessing the hash through a reference held in a scalar. In fact, in Perl 6 the only place you &lt;em&gt;must&lt;/em&gt; use an explicit &lt;code&gt;.&lt;/code&gt; dereferencer is in a method call. But it never hurts to say exactly what you mean, and there&amp;rsquo;s certainly no difference in performance if you do choose to use the dot.
The &lt;code&gt;.irs(undef)&lt;/code&gt; method call then sets the input record separator of the filehandle (i.e. the Perl 6 equivalent of &lt;code&gt;$/&lt;/code&gt;) to &lt;code&gt;undef&lt;/code&gt;, causing the next read operation to return the remaining contents of the file. And because the filehandle&amp;rsquo;s &lt;code&gt;irs&lt;/code&gt; method returns its own invocant &amp;ndash; i.e. the filehandle reference &amp;ndash; the entire expression can be used within the angle brackets of the read.&lt;/p&gt;

&lt;p&gt;A variation on this technique allows a Perl program to do a shell-like read-from-filename just as easily:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $next_line = &amp;lt;open $filename or die&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or, indeed, to read the whole file:
        my $all_lines = &amp;lt; open $filename : irs=&amp;gt;undef &amp;gt;;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S03.html&#34;&gt;Synopsis 3&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-seek-and-ye-shall-flatten-span-seek-and-ye-shall-flatten&#34;&gt;&lt;span id=&#34;seek and ye shall flatten&#34;&gt;&lt;/span&gt;Seek and ye shall flatten&lt;/h3&gt;

&lt;p&gt;Having grabbed the entire file, we now rewind and truncate it, in preparation for writing it back:
        seek $data.{fh}: *@StartOfFile;
        truncate $data.{fh}: 0;&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;re probably wondering what&amp;rsquo;s with the asterisk &amp;hellip; unless you&amp;rsquo;ve ever tried to write:
        seek $filehandle, @where_and_whence;&lt;/p&gt;

&lt;p&gt;in Perl 5 and gotten back the annoying &lt;code&gt;&amp;quot;Not enough arguments for seek&amp;quot;&lt;/code&gt; exception. The problem is that &lt;code&gt;seek&lt;/code&gt; expects three distinct scalars as arguments (as if it had a Perl 5 prototype of &lt;code&gt;seek($$$)&lt;/code&gt;), and it&amp;rsquo;s too fastidious to flatten the proffered array in order to get them.
It&amp;rsquo;s handy to wrap the magical &lt;code&gt;0,0&lt;/code&gt; arguments of the &lt;code&gt;seek&lt;/code&gt; in a single array (so we no longer have to remember this particular incantation), but to use such an array in Perl 5 we would then have to write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    seek $data-&amp;gt;{fh}, $StartOfFile[0], $StartOfFile[1];    # Perl 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Perl 6 that&amp;rsquo;s not a problem, because we have &lt;code&gt;*&lt;/code&gt; &amp;ndash; the list context specifier. When used in an argument list, it takes whatever you give it (typically an array or hash) and flattens it. So:
        seek $data.{fh}: *@StartOfFile;                        # Perl 6&lt;/p&gt;

&lt;p&gt;massages the single array into a list of two scalars, as &lt;code&gt;seek&lt;/code&gt; requires.
Oh, and yes, that &lt;em&gt;is&lt;/em&gt; the adverbial colon again. In Perl 6, &lt;code&gt;seek&lt;/code&gt; and &lt;code&gt;truncate&lt;/code&gt; are both methods of filehandle objects. So we can either call them as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $data.{fh}.seek(*@StartOfFile);
    $data.{fh}.truncate(0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or use the &amp;ldquo;indirect object&amp;rdquo; syntax:
        seek $data.{fh}: *@StartOfFile;
        truncate $data.{fh}: 0;&lt;/p&gt;

&lt;p&gt;And that&amp;rsquo;s where the colon comes in. Another of its many uses in Perl 6 is to separate &amp;ldquo;indirect object&amp;rdquo; arguments (e.g. filehandles) from the rest of the argument list. The main place you&amp;rsquo;ll see colons guarding indirect objects is in &lt;code&gt;print&lt;/code&gt; statements (as described in the next section).&lt;/p&gt;

&lt;h3 id=&#34;span-id-it-is-written-span-it-is-written&#34;&gt;&lt;span id=&#34;it is written...&#34;&gt;&lt;/span&gt;It is written&amp;hellip;&lt;/h3&gt;

&lt;p&gt;Finally, &lt;code&gt;&amp;amp;save_data&lt;/code&gt; has everything ready and can write the four fields and the rest of the file back to disk. First, it sets the output field separator for the filehandle (i.e. the equivalent of Perl 5&amp;rsquo;s &lt;code&gt;$,&lt;/code&gt; variable) to inject newlines between elements:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $data.{fh}.ofs(&amp;quot;\n&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then it prints the fields to the filehandle:
        print $data.{fh}: $data.{qw(name vers stat)}, _@{$data.{costs}}, $rest;&lt;/p&gt;

&lt;p&gt;Note the use of the adverbial colon after &lt;code&gt;$data.{fh}&lt;/code&gt; to separate the filehandle argument from the items to be printed. The colon is required because it&amp;rsquo;s how Perl 6 eliminates the nasty ambiguity inherent in the &amp;ldquo;indirect object&amp;rdquo; syntax. In Perl 5, something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print foo bar;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;could conceivably mean:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print {foo} (bar);    # Perl 5: print result of bar() to filehandle foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print ( foo(bar) );   # Perl 5: print foo() of bar() to default filehandle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or even:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print ( bar-&amp;gt;foo );   # Perl 5: call method foo() on object returned by
                          #         bar() and print result to default filehandle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Perl 6, there is no confusion, because each indirect object must followed by a colon. So in Perl 6:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print foo bar;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;can only mean:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print ( foo(bar) );   # Perl 6: print foo() of bar() to default filehandle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and to get the other two meanings we&amp;rsquo;d have to write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print foo: bar;       # Perl 6: print result of bar() to filehandle foo()
                          #         (foo() not foo, since there are no
                          #          bareword filehandles in Perl 6)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print foo bar: ;      # Perl 6: call method foo() on object returned by
                          #         bar() and print result to default filehandle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, the colon has an even wider range of use, as a general-purpose &amp;ldquo;adverb marker&amp;rdquo;; a notion we will explore more fully &lt;a href=&#34;#would%20you%20like%20an%20adverb%20with%20that&#34;&gt;below&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-string-em-up-together-span-string-em-up-together&#34;&gt;&lt;span id=&#34;string &#39;em up together&#34;&gt;&lt;/span&gt;String &amp;lsquo;em up together&lt;/h3&gt;

&lt;p&gt;The printed arguments are: a hash slice:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $data.{qw(name vers stat)},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;a stringified dereferenced nested array:
         _@{$data.{costs}},&lt;/p&gt;

&lt;p&gt;and a scalar:
        $rest;&lt;/p&gt;

&lt;p&gt;The new hash slice syntax was explained in the previous Apocalypse/Exegesis, and the scalar is just a scalar, but what was the middle thing again?
Well, &lt;code&gt;$data.{costs}&lt;/code&gt; is just a regular Perl 6 access to the &lt;code&gt;&#39;costs&#39;&lt;/code&gt; entry of the hash referred to by &lt;code&gt;$data&lt;/code&gt;. That entry contains the array reference that was the result of splitting &lt;code&gt;$cost&lt;/code&gt; &lt;a href=&#34;http://localhost:1313/pub/2001/10/03/exegesis3.html?page=3#and%20now%20for%20something%20completely%20the%20same%20(well,%20almost)&#34;&gt;in &lt;code&gt;&amp;amp;load_data&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So to get the actual array itself, we can prefix the array reference with a &lt;code&gt;@&lt;/code&gt; sigil (though, technically, we don&amp;rsquo;t &lt;em&gt;have&lt;/em&gt; to: in Perl 6 arrays and array references are interchangeable in scalar context).&lt;/p&gt;

&lt;p&gt;That gives us &lt;code&gt;@{$data.{costs}}&lt;/code&gt;. The only remaining difficulty is that when we print the list of items produced by &lt;code&gt;@{$data.{costs}}&lt;/code&gt;, they are subject to the output field separator. Which we just set to newline.&lt;/p&gt;

&lt;p&gt;But what we want is for them to appear on the &lt;em&gt;same&lt;/em&gt; line, with a space between each.&lt;/p&gt;

&lt;p&gt;Well &amp;hellip; evaluating a list in a string context does precisely that, so we could just write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;quot;@{$data.{costs}}&amp;quot;    # evaluate array in string context
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But Perl 6 has another alternative to offer us &amp;ndash; the unary underscore operator. Binary underscore is &lt;a href=&#34;http://localhost:1313/pub/2001/10/03/exegesis3.html?page=2#(pre)fixing%20those%20filenames&#34;&gt;string concatenation&lt;/a&gt;, so it shouldn&amp;rsquo;t be too surprising that unary underscore is the stringification operator (think: concatenation with a null string). Prefixing any expression with an underscore forces it to be evaluated in string context:
        _@{$data{costs}}     # evaluate array in string context&lt;/p&gt;

&lt;p&gt;Which, in this case, conveniently inserts the required spaces between the elements of the costs array.
&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S03.html&#34;&gt;Synopsis 3&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-a-parameter-by-any-other-name-span-a-parameter-by-any-other-name&#34;&gt;&lt;span id=&#34;a parameter by any other name&#34;&gt;&lt;/span&gt;A parameter by any other name&lt;/h3&gt;

&lt;p&gt;Now that the I/O is organized, we can get down to the actual processing. First, we load the data:
        my %data = load_data(filename=&amp;gt;&amp;lsquo;weblog&amp;rsquo;, version=&amp;gt;1);&lt;/p&gt;

&lt;p&gt;Note that we&amp;rsquo;re using named arguments here. This attempt would blow up badly in Perl 5, because we didn&amp;rsquo;t set &lt;code&gt;&amp;amp;load_data&lt;/code&gt; up to expect a hash-like list of arguments. But it works fine in Perl 6 for two reasons:
1.  Because we &lt;em&gt;did&lt;/em&gt; set up &lt;code&gt;&amp;amp;load_data&lt;/code&gt; with named parameters; and
2.  Because the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator isn&amp;rsquo;t in Kansas anymore.&lt;/p&gt;

&lt;p&gt;In Perl 5, &lt;code&gt;=&amp;gt;&lt;/code&gt; is just an up-market comma with a single minor talent: It stringifies its left operand if that operand is a bareword.
In Perl 6, &lt;code&gt;=&amp;gt;&lt;/code&gt; is a fully-fledged anonymous object constructor &amp;ndash; like &lt;code&gt;[...]&lt;/code&gt; and &lt;code&gt;{...}&lt;/code&gt;. The objects it constructs are called &amp;ldquo;pairs&amp;rdquo; and they consist of a key (the left operand of the &lt;code&gt;=&amp;gt;&lt;/code&gt;), and a value (the right operand). The key is still stringified if it&amp;rsquo;s a valid identifier, but both the key and the value can be &lt;em&gt;any&lt;/em&gt; kind of Perl data structure. They are accessed via the pair object&amp;rsquo;s &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; methods:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $pair_ref = [1..9] =&amp;gt; &amp;quot;digit&amp;quot;;

    print $pair_ref.value;      # prints &amp;quot;digit&amp;quot;
    print $pair_ref.key.[3];    # prints 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, rather than getting four arguments:
        load_data(&amp;lsquo;filename&amp;rsquo;, &amp;lsquo;weblog&amp;rsquo;, &amp;lsquo;version&amp;rsquo;, 1);    # Perl 5 semantics&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;amp;load_data&lt;/code&gt; gets just two arguments, each of which is a reference to a pair:
        load_data( $pair_ref1, $pair_ref2);               # Perl 6 semantics&lt;/p&gt;

&lt;p&gt;When the subroutine dispatch mechanism detects one or more pairs as arguments to a subroutine with named parameters, it examines the keys of the pairs and binds their values to the correspondingly named parameters &amp;ndash; no matter what order the paired arguments originally appeared in. Any remaining non-pair arguments are then bound to the remaining parameters in left-to-right order.
So we could call &lt;code&gt;&amp;amp;load_data&lt;/code&gt; in any of the following ways:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    load_data(filename=&amp;gt;&#39;weblog&#39;, version=&amp;gt;1);  # named

    load_data(version=&amp;gt;1, filename=&amp;gt;&#39;weblog&#39;);  # named (order doesn&#39;t matter)

    load_data(&#39;weblog&#39;, 1);                     # positional (order matters)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are numerous other uses for pairs, one of which we&amp;rsquo;ll see &lt;a href=&#34;http://localhost:1313/pub/2001/10/03/exegesis3.html?page=6#schwartzian%20pairs&#34;&gt;shortly&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-please-queue-for-processing-span-please-queue-for-processing&#34;&gt;&lt;span id=&#34;please queue for processing&#34;&gt;&lt;/span&gt;Please queue for processing&lt;/h3&gt;

&lt;p&gt;Having loaded the data, we go into a loop and iterate over each file&amp;rsquo;s information. First, we announce the file and its internal name:
        foreach my $file (keys %data) {
            print &amp;ldquo;$file contains data on %data{$file}{name}\n&amp;rdquo;;&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-xortwist-span-the-xor-twist&#34;&gt;&lt;span id=&#34;the xortwist&#34;&gt;&lt;/span&gt;The Xor-twist&lt;/h3&gt;

&lt;p&gt;Then we toggle the &amp;ldquo;is active&amp;rdquo; status bit (the eighth bit) for each file. To flip that single bit without changing any of the other status bits, we bitwise-xor the status bitset against the bitstring &lt;code&gt;0000000010000000&lt;/code&gt;. Each bit xor&amp;rsquo;d against a zero stays as it is (0 xor 0 &amp;ndash;&amp;gt; 0; 1 xor 0 &amp;ndash;&amp;gt; 1), while xor&amp;rsquo;ing the eighth bit against 1 complements it (0 xor 1 &amp;ndash;&amp;gt; 1; 1 xor 1 &amp;ndash;&amp;gt; 0).
But because the caret has been appropriated as the Perl 6 &lt;a href=&#34;http://localhost:1313/pub/2001/10/03/exegesis3.html?page=2#substitute%20our%20vector,%20victor!&#34;&gt;hyper-operator prefix&lt;/a&gt;, it will no longer be used as bitwise xor. Instead, binary tilde will be used:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %data{$file}{stat} = %data{$file}{stat} ~ $is_active_bit;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is actually an improvement in syntactic consistency since bitwise xor (now binary &lt;code&gt;~&lt;/code&gt;) and bitwise complement (still unary &lt;code&gt;~&lt;/code&gt;) are mathematically related: &lt;code&gt;~x&lt;/code&gt; is &lt;code&gt;(-1~x)&lt;/code&gt;.
Note that we &lt;em&gt;could&lt;/em&gt; have used the assignment variant of binary &lt;code&gt;~&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %data{$file}{stat} ~= $is_active_bit;     # flip only bit 8 of status bitset
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but that&amp;rsquo;s probably best avoided due to its confusability with the much commoner &amp;ldquo;pattern association&amp;rdquo; operator:
        %data{$file}{stat} =~ $is_active_bit;     # match if status bitset is &amp;ldquo;128&amp;rdquo;&lt;/p&gt;

&lt;p&gt;By the way, there is also a high precedence logical xor operator in Perl 6. You guessed it: &lt;code&gt;~~&lt;/code&gt;. This finally fills the strange gap in Perl&amp;rsquo;s logical operator set:
            Binary (low) | Binary (high) |    Bitwise
           ___________&lt;strong&gt;&lt;em&gt;|&lt;/em&gt;&lt;/strong&gt;_________&lt;strong&gt;&lt;em&gt;|&lt;/em&gt;&lt;/strong&gt;__________
                         |               |
                or       |      ||       |      |
                         |               |
                and      |      &amp;amp;&amp;amp;       |      &amp;amp;
                         |               |
                xor      |      ~~       |      ~
                         |               |&lt;/p&gt;

&lt;p&gt;And it will also help to reduce programmer stress by allowing us to write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $make = $money ~~ $fast;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;instead of (the clearly over-excited):
        $make = !$money != !$fast;&lt;/p&gt;

&lt;h3 id=&#34;span-id-bound-for-glory-span-bound-for-glory&#34;&gt;&lt;span id=&#34;bound for glory&#34;&gt;&lt;/span&gt;Bound for glory&lt;/h3&gt;

&lt;p&gt;In both Perl 5 and 6, it&amp;rsquo;s possible to create an &lt;em&gt;alias&lt;/em&gt; for a variable. For example, the subroutine:
        sub increment { $&lt;em&gt;[0]++ }           # Perl 5
        sub increment { @&lt;/em&gt;[0]++ }           # Perl 6&lt;/p&gt;

&lt;p&gt;works because the elements of &lt;code&gt;@_&lt;/code&gt; become aliases for whatever variable is passed as their corresponding argument. Similarly, one can use a &lt;code&gt;for&lt;/code&gt; to implement a Pascal-ish &lt;code&gt;with&lt;/code&gt;:
        for my $age ( $person[$n]{data}{personal}{time_dependent}{age} ) {
            if    ($age &amp;lt; 12) { print &amp;ldquo;Child&amp;rdquo; }
            elsif ($age &amp;lt; 18) { print &amp;ldquo;Adolescent&amp;rdquo; }
            elsif ($age &amp;lt; 25) { print &amp;ldquo;Junior citizen&amp;rdquo; }
            elsif ($age &amp;lt; 65) { print &amp;ldquo;Citizen&amp;rdquo; }
            else              { print &amp;ldquo;Senior citizen&amp;rdquo; }
        }&lt;/p&gt;

&lt;p&gt;Perl 6 provides a more direct mechanism for aliasing one variable to another in this way: the &lt;code&gt;:=&lt;/code&gt; (or &amp;ldquo;binding&amp;rdquo;) operator. For example, we could rewrite the previous example like so in Perl 6:
        my $age := $person[$n]{data}{personal}{time_dependent}{age};&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if    ($age &amp;lt; 12) { print &amp;quot;Child&amp;quot; }
    elsif ($age &amp;lt; 18) { print &amp;quot;Adolescent&amp;quot; }
    elsif ($age &amp;lt; 25) { print &amp;quot;Junior citizen&amp;quot; }
    elsif ($age &amp;lt; 65) { print &amp;quot;Citizen&amp;quot; }
    else              { print &amp;quot;Senior citizen&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bound aliases are particularly useful for temporarily giving a conveniently short identifier to a variable with a long or complex name. Scalars, arrays, hashes and even subroutines may all be given less sequipedalian names in this way:
            my   @list := @They::never::would::be::missed::No_never_would_be_missed;
            our  %plan := %{$planning.[$planner].{planned}.[$planet]};
            temp &amp;amp;rule := &amp;FulfilMyGrandMegalomanicalDestinyBwahHaHaHaaaa;&lt;/p&gt;

&lt;p&gt;In our example program, we use aliasing to avoid having to write &lt;code&gt;@%data{$file}{costs}&lt;/code&gt; everywhere:
        my @costs := @%data{$file}{costs};&lt;/p&gt;

&lt;p&gt;An important feature of the binding operator is that the lvalue (or lvalues) on the left side form a context specification for the rvalue (or rvalues) on the right side. It&amp;rsquo;s as if the lvalues were the parameters of an invisible subroutine, and the rvalues were the corresponding arguments being passed to it. So, for example, we could also have written:
        my @costs := %data{$file}{costs};&lt;/p&gt;

&lt;p&gt;(i.e. without the &lt;code&gt;@&lt;/code&gt; dereferencer) because the lvalue &lt;em&gt;expects&lt;/em&gt; an array as the corresponding rvalue, so Perl 6 automatically dereferences the array reference in &lt;code&gt;%data{$file}{costs}&lt;/code&gt; to provide that.
More interestingly, if we have both lvalue and rvalue lists, then each of the rvalues is evaluated in the context specified by its corresponding lvalue. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (@x, @y) := (@a, @b);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;aliases &lt;code&gt;@x&lt;/code&gt; to &lt;code&gt;@a&lt;/code&gt;, and &lt;code&gt;@y&lt;/code&gt; to &lt;code&gt;@b&lt;/code&gt;, because &lt;code&gt;@&lt;/code&gt;&amp;rsquo;s on the left act like &lt;code&gt;@&lt;/code&gt; parameters, which require &amp;ndash; and bind to &amp;ndash; an unflattened array as their corresponding argument. Likewise:
        ($x, %y, @z) := (1, {b=&amp;gt;2}, %c{list});&lt;/p&gt;

&lt;p&gt;binds &lt;code&gt;$x&lt;/code&gt; to the value &lt;code&gt;1&lt;/code&gt; (i.e. &lt;code&gt;$x&lt;/code&gt; becomes a constant), &lt;code&gt;%y&lt;/code&gt; to the anonymous hash constructed by &lt;code&gt;{b=&amp;gt;2}&lt;/code&gt;, and &lt;code&gt;@z&lt;/code&gt; to the array referred to by &lt;code&gt;%c{list}&lt;/code&gt;. In other words, it&amp;rsquo;s the same set of bindings we&amp;rsquo;d see if we wrote:
        sub foo($x, %y, @z) {&amp;hellip;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    foo(1, {b=&amp;gt;2}, %c{list});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;except that the &lt;code&gt;:=&lt;/code&gt; binding takes effect in the current scope.
And because &lt;code&gt;:=&lt;/code&gt; works that way, we can also use the flattening operator (unary &lt;code&gt;*&lt;/code&gt;) on either side of such bindings. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (@x, *@y) := (@a, $b, @c, %d);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;aliases &lt;code&gt;@x&lt;/code&gt; to &lt;code&gt;@a&lt;/code&gt;, and causes &lt;code&gt;@y&lt;/code&gt; to bind to the remainder of the lvalues &amp;ndash; by flattening out &lt;code&gt;$b&lt;/code&gt;, &lt;code&gt;@c&lt;/code&gt;, and &lt;code&gt;%d&lt;/code&gt; into a list and then slurping up all their components together.
Note that &lt;code&gt;@y&lt;/code&gt; is still an &lt;em&gt;alias&lt;/em&gt; for those various slurped components. So &lt;code&gt;@y[0]&lt;/code&gt; is an alias for &lt;code&gt;$b&lt;/code&gt;, &lt;code&gt;@y[1..@c.length]&lt;/code&gt; are aliases for the elements of &lt;code&gt;@c&lt;/code&gt;, and the remaining elements of &lt;code&gt;@y&lt;/code&gt; are aliases for the interlaced keys and values of &lt;code&gt;%d&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;When the star is on the other side of the binding, as in:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ($x, $y) := (*@a);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then &lt;code&gt;@a&lt;/code&gt; is flattened before it is bound, so &lt;code&gt;$x&lt;/code&gt; becomes an alias for &lt;code&gt;@a[0]&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; becomes an alias for &lt;code&gt;@a[1]&lt;/code&gt;.
The binding operator will have many uses in Perl 6 (most of which we probably haven&amp;rsquo;t even thought of yet), but one of the commonest will almost certainly be as an easy way to swap two arrays efficiently:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (@x, @y) := (@y, @x);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yet another way to think about the binding operator is to consider it as a sanitized version of those dreaded Perl 5 typeglob assignments. That is:
        $age := $person[$n]{data}{personal}{time_dependent}{age};&lt;/p&gt;

&lt;p&gt;is the same as Perl 5&amp;rsquo;s:
        *age = \$person-&amp;gt;[$n]{data}{personal}{time_dependent}{age};&lt;/p&gt;

&lt;p&gt;except that it also works if &lt;code&gt;$age&lt;/code&gt; is declared as a lexical.
Oh, and binding is much safer than typeglobbing was, because it explicitly requires that &lt;code&gt;$person[$n]{data}{personal}{time_dependent}{age}&lt;/code&gt; evaluate to a scalar, whereas the Perl 5 typeglob version would happily (and silently!) replace &lt;code&gt;@age&lt;/code&gt;, &lt;code&gt;%age&lt;/code&gt;, or even &lt;code&gt;&amp;amp;age&lt;/code&gt; if the rvalue happened to produce a reference to an array, hash, or subroutine instead of a scalar.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S03.html&#34;&gt;Synopsis 3&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-better-living-through-sigils-span-better-living-through-sigils&#34;&gt;&lt;span id=&#34;better living through sigils&#34;&gt;&lt;/span&gt;Better living through sigils&lt;/h3&gt;

&lt;p&gt;We should also note that the binding of the &lt;code&gt;@costs&lt;/code&gt; array:
        my @costs := @%data{$file}{costs};&lt;/p&gt;

&lt;p&gt;shows yet another case where Perl 6&amp;rsquo;s sigil semantics are much DWIM-mier than those of Perl 5.
In Perl 5 we would probably have written that as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        local *costs = \ @$data{$file}{costs};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then spent some considerable time puzzling out why it wasn&amp;rsquo;t working, before realising that we&amp;rsquo;d actually meant:
            local *costs = \ @{$data{$file}{costs}};&lt;/p&gt;

&lt;p&gt;instead.
That&amp;rsquo;s because, in Perl 5, the precedence of a hash key is relatively low, so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @$data{$file}{costs}    # means: @{$data}{$file}{costs}
                            # i.e. (invalid attempt to) access the &#39;costs&#39;
                            # key of a one-element slice of the hash
                            # referred to by $data
                            # problem is: slices don&#39;t have hash keys
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;whereas:
        @{$data{$file}{costs}}  # means: @{ $data{$file}{costs} }
                                # i.e. dereference of array referred to by
                                # $data{$file}{costs}&lt;/p&gt;

&lt;p&gt;The problem simply doesn&amp;rsquo;t arise in Perl 6, where the two would be written quite distinctly, as:
        %data{@($file)}{costs}  # means: (%data{@($file)}).{costs}
                                # (still an error in Perl 6)&lt;/p&gt;

&lt;p&gt;and:
        @%data{$file}{costs}    # means: @{ %data{$file}{costs} }
                                # i.e. dereference of array referred to by
                                # %data{$file}{costs}&lt;/p&gt;

&lt;p&gt;respectively.&lt;/p&gt;

&lt;h3 id=&#34;span-id-that-s-not-a-number-now-that-s-a-number-span-that-s-not-a-number-now-that-s-a-number&#34;&gt;&lt;span id=&#34;that&#39;s not a number...now that&#39;s a number!&#34;&gt;&lt;/span&gt;That&amp;rsquo;s not a number&amp;hellip;now &lt;em&gt;that&amp;rsquo;s&lt;/em&gt; a number!&lt;/h3&gt;

&lt;p&gt;One of the perennial problems with Perl 5 is how to read in a number. Or rather, how to read in a string&amp;hellip;and then be sure that it contains a valid number. Currently, most people read in the string and then either just assume it&amp;rsquo;s a number (optimism) or use the regexes found in &lt;a href=&#34;https://perldoc.perl.org/perlfaq4.html#How_do_I_determine_whether_a_scalar_is_a_number_whole_integer_float_&#34;&gt;perlfaq4&lt;/a&gt; or &lt;a href=&#34;https://metacpan.org/pod/Regexp::Common&#34;&gt;Regexp::Common&lt;/a&gt; to make sure (cynicism).&lt;/p&gt;

&lt;p&gt;Perl 6 offers a simpler, built-in mechanism.&lt;/p&gt;

&lt;p&gt;Just as the unary version of binary underscore (&lt;code&gt;_&lt;/code&gt;) is Perl 6&amp;rsquo;s explicit stringification specifier, so to the unary version of binary plus is Perl 6&amp;rsquo;s explicit numerifier. That is, prefixing an expression with unary &lt;code&gt;+&lt;/code&gt; evaluates that expression in a numeric context. Furthermore, if the expression has to be coerced from a string and the string does not begin with a valid number, the stringification operator returns &lt;code&gt;NaN&lt;/code&gt;, the not-a-number value.&lt;/p&gt;

&lt;p&gt;That makes it particularly easy to read in numeric data reliably:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $inflation;
    print &amp;quot;Inflation rate: &amp;quot; and $inflation = +&amp;lt;&amp;gt;
        until $inflation != NaN;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The unary &lt;code&gt;+&lt;/code&gt; takes the string returned by &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; and converts it to a number. Or, if the string can&amp;rsquo;t be interpreted as a number, &lt;code&gt;+&lt;/code&gt; returns &lt;code&gt;NaN&lt;/code&gt;. Then we just go back and try again until we do get a valid number.
Note that these new semantics for unary &lt;code&gt;+&lt;/code&gt; are a little different from its role in Perl 5, where it is just the identity operator. In Perl 5 it&amp;rsquo;s occasionally used to disambiguate constructs like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print  ($x + $y) * $z;        # in Perl 5 means: ( print($x+$y) ) * $z;
    print +($x + $y) * $z;        # in Perl 5 means: print( ($x+$y) * $z );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To get the same effect in Perl 6, we&amp;rsquo;d use the &lt;a href=&#34;http://localhost:1313/pub/2001/10/03/exegesis3.html?page=4#it%20is%20written...&#34;&gt;adverbial colon&lt;/a&gt; instead:
        print   ($x + $y) * $z;        # in Perl 6 means: ( print($x+$y) ) * $z;
        print : ($x + $y) * $z;        # in Perl 6 means: print( ($x+$y) * $z );&lt;/p&gt;

&lt;h3 id=&#34;span-id-schwartzian-pairs-span-schwartzian-pairs&#34;&gt;&lt;span id=&#34;schwartzian pairs&#34;&gt;&lt;/span&gt;Schwartzian pairs&lt;/h3&gt;

&lt;p&gt;Another handy use for &lt;a href=&#34;http://localhost:1313/pub/2001/10/03/exegesis3.html?page=5#a%20parameter%20by%20any%20other%20name&#34;&gt;pairs&lt;/a&gt; is as a natural data structure for implementing the Schwartzian Transform. This caching technique is used when sorting a large list of values according to some expensive function on those values. Rather than writing:
        my @sorted = sort { expensive($a) &amp;lt;=&amp;gt; expensive($b) } @unsorted;&lt;/p&gt;

&lt;p&gt;and recomputing the same expensive function every time each value is compared during the sort, we can precompute the function on each value once. We then pass both the original value and its computed value to &lt;code&gt;sort&lt;/code&gt;, use the computed value as the key on which to sort the list, but then return the original value as the result. Like this:
        my @sorted =                        # step 4: store sorted originals
            map  { $&lt;em&gt;.[0] }                 # step 3: extract original
            sort { $a.[1] &amp;lt;=&amp;gt; $b.[1] }      # step 2: sort on computed
            map  { [$&lt;/em&gt;, expensive($_) ] }   # step 1: cache original and computed
                @unsorted;                  # step 0: take originals&lt;/p&gt;

&lt;p&gt;The use of arrays can make such transforms hard to read (and to maintain), so people sometimes use hashes instead:
        my @sorted =
            map  { $&lt;em&gt;.{original} }
            sort { $a.{computed} &amp;lt;=&amp;gt; $b.{computed} }
            map  { {original=&amp;gt;$&lt;/em&gt;, computed=&amp;gt;expensive($_)} }
                @unsorted;&lt;/p&gt;

&lt;p&gt;That improves the readability, but at the expense of performance. Pairs are an ideal way to get the readability of hashes but with (probably) even better performance than arrays:
        my @sorted =
            map  { $&lt;em&gt;.value }
            sort { $a.key &amp;lt;=&amp;gt; $b.key }
            map  { expensive($&lt;/em&gt;) =&amp;gt; $_ }
                @unsorted;&lt;/p&gt;

&lt;p&gt;Or in the case of our example program:
        @costs = map  { $&lt;em&gt;.value }
                 sort { $a.key &amp;lt;=&amp;gt; $b.key }
                 map  { amortize($&lt;/em&gt;) =&amp;gt; $_ }
                     @costs ^* $inflation;&lt;/p&gt;

&lt;p&gt;Note that we also used a hyper-multiplication (&lt;code&gt;^*&lt;/code&gt;) to multiply each cost individually by the rate of inflation before sorting them. That&amp;rsquo;s equivalent to writing:
        @costs = map  { $&lt;em&gt;.value }
                 sort { $a.key &amp;lt;=&amp;gt; $b.key }
                 map  { amortize($&lt;/em&gt;) =&amp;gt; $_ }
                 map  { $_ * $inflation }
                     @costs;&lt;/p&gt;

&lt;p&gt;but spares us from the burden of yet another &lt;code&gt;map&lt;/code&gt;.
More importantly, because &lt;code&gt;@costs&lt;/code&gt; is an &lt;a href=&#34;http://localhost:1313/pub/2001/10/03/exegesis3.html?page=5#bound%20for%20glory&#34;&gt;alias&lt;/a&gt; for &lt;code&gt;@%data{$file}{costs}&lt;/code&gt;, when we assign the sorted list back to &lt;code&gt;@costs&lt;/code&gt;, we&amp;rsquo;re actually assigning it back into the appropriate sub-entry of &lt;code&gt;%data&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-sum-of-all-our-fears-span-the-of-all-our-fears&#34;&gt;&lt;span id=&#34;the sum of all our fears&#34;&gt;&lt;/span&gt;The ∑ of all our fears&lt;/h3&gt;

&lt;p&gt;Perl 6 will probably have a built-in &lt;code&gt;sum&lt;/code&gt; operator, but we might still prefer to build our own for a couple of reasons. Firstly &lt;code&gt;sum&lt;/code&gt; is obviously far too long a name for so fundamental an operation; it really should be &lt;code&gt;∑&lt;/code&gt;. Secondly, we may want to extend the basic summation functionality somehow. For instance, by allowing the user to specify a filter and only summing those arguments that the filter lets through.
Perl 6 allows us to create our own operators. Their names can be any combination of characters from the Unicode set. So it&amp;rsquo;s relatively easy to build ourselves a &lt;code&gt;∑&lt;/code&gt; operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my sub operator:∑ is prec(\&amp;amp;operator:+($)) (*@list) {
        reduce {$^a+$^b} @list;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We declare the &lt;code&gt;∑&lt;/code&gt; operator as a lexically scoped subroutine. The lexical scoping eases the syntactic burden on the parser, the semantic burden on other unrelated parts of the code, and the cognitive burden on the programmer.
The operator subroutine&amp;rsquo;s name is always &lt;code&gt;operator:whatever_symbols_we_want&lt;/code&gt;. In this case, that&amp;rsquo;s &lt;code&gt;operator:∑&lt;/code&gt;, but it can be any sequence of Unicode characters, including alphanumerics:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        my sub operator:*#@&amp;amp; is prec(\&amp;amp;operator:\)  (STR $x) {
                return &amp;quot;darn $x&amp;quot;;
        }

        my sub operator:† is prec(\&amp;amp;CORE::kill)  (*@tIHoH) {
                kill(9, @tIHoH) == @tIHoH or die &amp;quot;batlhHa&#39;&amp;quot;;
                return &amp;quot;Qapla!&amp;quot;;
        }

        my sub operator:EQ is prec(\&amp;amp;operator:eq)  ($a, $b) {
                return $a eq $b                 # stringishly equal strings
                    || $a == $b != NaN;         # numerically equal numbers
        }

        # and then:

        warn *#@&amp;amp; &amp;quot;QeH!&amp;quot; unless E&amp;lt;dagger&amp;gt; $puq EQ &amp;quot;Qapla!&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Did you notice that cunning &lt;code&gt;$a == $b != NaN&lt;/code&gt; test in &lt;code&gt;operator:EQ&lt;/code&gt;? This lovely Perl 6 idiom solves the problem of numerical comparisons between non-numeric strings.&lt;/p&gt;

&lt;p&gt;In Perl 5, a comparison like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        $a = &amp;quot;a string&amp;quot;;
        $b = &amp;quot;another string&amp;quot;;
        print &amp;quot;huh?&amp;quot; if $a == $b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will unexpectedly succeed (and silently too, if you run without warnings), because the non-numeric values of both the scalars are converted to zero in the numeric context of the &lt;code&gt;==&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But in Perl 6, non-numeric strings numerify to &lt;code&gt;NaN&lt;/code&gt;. So, using Perl 6&amp;rsquo;s multiway comparison feature, we can add an extra &lt;code&gt;!= NaN&lt;/code&gt; to the equality test to ensure that we compared genuine numbers.&lt;/p&gt;

&lt;p&gt;Meanwhile, we also have to specify a precedence for each new operator we define. We do that with the &lt;code&gt;is prec&lt;/code&gt; trait of the subroutine. The precedence is specified in terms of the precedence of some existing operator; in this case, in terms of Perl&amp;rsquo;s built-in unary &lt;code&gt;+&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my sub operator:∑ is prec( \&amp;amp;operator:+($) )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To do this, we give the &lt;code&gt;is prec&lt;/code&gt; trait a reference to teh existing operator. Note that, because there are two overloaded forms of &lt;code&gt;operator:+&lt;/code&gt; (unary and binary) of different precedences, to get the reference to the correct one we need to specify its complete &lt;em&gt;signature&lt;/em&gt; (its name and parameter types) as part of the enreferencing operation. The ability to take references to signatures is a standard feature in Perl 6, since ordinary subroutines can also be overloaded, and may need the same kind of disambiguation when enreferenced.
If the operator had been binary, we might also have had to specify its associativity (&lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, or &lt;code&gt;non&lt;/code&gt;), using the &lt;code&gt;is assoc&lt;/code&gt; trait.&lt;/p&gt;

&lt;p&gt;Note too that we specified the parameter of &lt;code&gt;operator:∑&lt;/code&gt; with a flattening asterisk, since we want &lt;code&gt;@list&lt;/code&gt; to slurp up any series of values passed to it, rather than being restricted to accepting only actual array variables as arguments.&lt;/p&gt;

&lt;p&gt;The implementation of &lt;code&gt;operator:∑&lt;/code&gt; is very simple: we just apply the built-in &lt;code&gt;reduce&lt;/code&gt; function to the list, reducing each successive pair of elements by adding them.&lt;/p&gt;

&lt;p&gt;Note that we used a higher-order function to specify the addition operation. Larry has decided that the syntax for higher-order functions requires that implicit parameters be specified with a &lt;code&gt;$^&lt;/code&gt; sigil (or &lt;code&gt;@^&lt;/code&gt; or &lt;code&gt;%^&lt;/code&gt;, as appropriate) and that the whole expression be enclosed in braces.&lt;/p&gt;

&lt;p&gt;So now we have a &lt;code&gt;∑&lt;/code&gt; operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $result = ∑ $wins, $losses, $ties;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but it doesn&amp;rsquo;t yet provide a way to filter its values. Normally, that would present a difficulty with an operator like &lt;code&gt;∑&lt;/code&gt;, whose &lt;code&gt;*@list&lt;/code&gt; argument will gobble up every argument we give it, leaving no way &amp;ndash; except convention &amp;ndash; to distinguish the filter from the data.
But Perl 6 allows any subroutine &amp;ndash; not just built-ins like &lt;code&gt;print&lt;/code&gt; &amp;ndash; to take one or more &amp;ldquo;adverbs&amp;rdquo; in addition to its normal arguments. This provides a second channel by which to transmit information to a subroutine. Typically that information will be used to modify the behaviour of the subroutine (hence the name &amp;ldquo;adverb&amp;rdquo;). And that&amp;rsquo;s exactly what we need in order to pass a filter to &lt;code&gt;∑&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A subroutine&amp;rsquo;s adverbs are specified as part of its normal parameter list, but separated from its regular parameters by a colon:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my sub operator:∑ is prec(\&amp;amp;operator:+($)) ( *@list : $filter //= undef) {...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This specifies that &lt;code&gt;operator:∑&lt;/code&gt; can take a single scalar adverb, which is bound to the parameter &lt;code&gt;$filter&lt;/code&gt;. When there is no adverb specified in the call, &lt;code&gt;$filter&lt;/code&gt; is default-assigned the value &lt;code&gt;undef&lt;/code&gt;.
We then modify the body of the subroutine to pre-filter the list through a &lt;code&gt;grep&lt;/code&gt;, but only if a filter is provided:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        reduce {$^a+$^b}  ($filter ?? grep &amp;amp;$filter, @list :: @list);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;??&lt;/code&gt; and &lt;code&gt;::&lt;/code&gt; are the new way we write the old &lt;code&gt;?:&lt;/code&gt; ternary operator in Perl 6. Larry had to change the spelling because he needed the single colon for marking adverbs. But it&amp;rsquo;s a change for the better anyway &amp;ndash;it was rather odd that all the other short-circuiting logical operators (&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;//&lt;/code&gt;) used doubled symbols, but the conditional operator didn&amp;rsquo;t. Well, now it does. The doubling also helps it stand out better in code, in part because it forces you to put space around the &lt;code&gt;::&lt;/code&gt; so that it&amp;rsquo;s not confused with a package name separator.
You might also be wondering about the ambiguity of &lt;code&gt;??&lt;/code&gt;, which in Perl 5 already represents an empty regular expression with question-mark delimiters. Fortunately, Perl 6 won&amp;rsquo;t be riddled with the nasty &lt;code&gt;?...?&lt;/code&gt; regex construct, so there&amp;rsquo;s no ambiguity at all.&lt;/p&gt;

&lt;p&gt;Adverbial semantics can be defined for &lt;em&gt;any&lt;/em&gt; Perl 6 subroutine. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub mean (*@values : $type //= &#39;arithmetic&#39;) {
        given ($type) {
            when &#39;arithmetic&#39;: { return sum(@values) / @values; }
            when &#39;geometric&#39;:  { return product(@values) ** (1/@values) }
            when &#39;harmonic&#39;:   { return @values / sum( @values ^** -1 ) }
            when &#39;quadratic&#39;:  { return (sum(@values ^** 2) / @values) ** 0.5 }
        }
        croak &amp;quot;Unknown type of mean: &#39;$type&#39;&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Adverbs will probably become widely used for passing this type of &amp;ldquo;out-of-band&amp;rdquo; behavioural modifier to subroutines that take an unspecified number of data arguments.
&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S03.html&#34;&gt;Synopsis 3&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-would-you-like-an-adverb-with-that-span-would-you-like-an-adverb-with-that&#34;&gt;&lt;span id=&#34;would you like an adverb with that&#34;&gt;&lt;/span&gt;Would you like an adverb with that?&lt;/h3&gt;

&lt;p&gt;OK, so now our &lt;code&gt;∑&lt;/code&gt; operator can take a modifying filter. How exactly do we pass that filter to it?
As described &lt;a href=&#34;http://localhost:1313/pub/2001/10/03/exegesis3.html?page=4#it%20is%20written...&#34;&gt;earlier&lt;/a&gt;, the colon is used to introduce adverbial arguments into the argument list of a subroutine or operator. So to do a normal summation we write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $sum = ∑ @costs;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;whilst to do a filtered summation we place the filter after a colon at the end of the regular argument list:
        $sum = ∑ @costs : sub {$_ &amp;gt;= 1000};&lt;/p&gt;

&lt;p&gt;or, more elegantly, using a higher-order function:
        $sum = ∑ @costs : {$^_ &amp;gt;= 1000};&lt;/p&gt;

&lt;p&gt;Any arguments after the colon are bound to the parameters specified by the subroutine&amp;rsquo;s adverbial parameter list.
Note that the example also demonstrates that we can interpolate the results of the various summations directly into output strings. We do this using Perl 6&amp;rsquo;s scalar interpolation mechanism (&lt;code&gt;$(...)&lt;/code&gt;), like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print &amp;quot;Total expenditure: $( ∑ @costs )\n&amp;quot;;
    print &amp;quot;Major expenditure: $( ∑ @costs : {$^_ &amp;gt;= 1000} )\n&amp;quot;;
    print &amp;quot;Minor expenditure: $( ∑ @costs : {$^_ &amp;lt; 1000} )\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-the-odd-lazy-step-span-the-odd-lazy-step&#34;&gt;&lt;span id=&#34;the odd lazy step&#34;&gt;&lt;/span&gt;The odd lazy step&lt;/h3&gt;

&lt;p&gt;Finally (and only because we &lt;em&gt;can&lt;/em&gt;), we print out a list of every second element of &lt;code&gt;@costs&lt;/code&gt;. There are numerous ways to do that in Perl 6, but the cutest is to use a lazy, infinite, stepped list of indices in a regular slicing operation.&lt;/p&gt;

&lt;p&gt;In Perl 6, any list of values created with the &lt;code&gt;..&lt;/code&gt; operator is created lazily. That is, the &lt;code&gt;..&lt;/code&gt; operator doesn&amp;rsquo;t actually build a list of all the values in the specified range, it creates an array object that knows the boundaries of the range and can interpolate (and then cache) any given value when it&amp;rsquo;s actually needed. That&amp;rsquo;s useful, because it greatly speeds up the creation of a list like &lt;code&gt;(1..Inf)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Inf&lt;/code&gt; is Perl 6&amp;rsquo;s standard numerical infinity value, so a list that runs to &lt;code&gt;Inf&lt;/code&gt; takes &amp;hellip; well &amp;hellip; forever to actually build. But writing &lt;code&gt;1..Inf&lt;/code&gt; is OK in Perl 6, since the elements of the resulting list are only ever computed on demand. Of course, if you were to &lt;code&gt;print(1..Inf)&lt;/code&gt;, you&amp;rsquo;d have plenty of time to go and get a cup of coffee. And even then (given the comparatively imminent heat death of the universe) that coffee would be &lt;em&gt;really&lt;/em&gt; cold before the output was complete. So there will probably be a warning when you try to do that.&lt;/p&gt;

&lt;p&gt;But to get an infinite list of odd indices, we don&amp;rsquo;t want every number between 1 and infinity; we want every &lt;em&gt;second&lt;/em&gt; number. Fortunately, Perl 6&amp;rsquo;s &lt;code&gt;..&lt;/code&gt; operator can take an adverb that specifies a &amp;ldquo;step-size&amp;rdquo; between the elements in the resulting list. So if we write &lt;code&gt;(1..Inf : 2)&lt;/code&gt;, we get &lt;code&gt;(1,3,5,7,...)&lt;/code&gt;. Using that list, we can extract the oddly indexed elements of an array of any size (e.g. &lt;code&gt;@costs&lt;/code&gt;) with an ordinary array slice:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print @costs[1..Inf:2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You might have expected another one of those &amp;ldquo;maximal-entropy coffee&amp;rdquo; delays whilst &lt;code&gt;print&lt;/code&gt; patiently outputs the infinite number of &lt;code&gt;undef&lt;/code&gt;&amp;rsquo;s that theoretically exist after &lt;code&gt;@costs&lt;/code&gt;&amp;rsquo; last element, but slices involving infinite lists avoid that problem by returning only those elements that actually exist in the list being sliced. That is, instead of iterating the requested indices in a manner analogous to:
        sub slice is lvalue (@array, *@wanted_indices) {
            my @slice;
            foreach $wanted_index ( @wanted_indices ) {
                @slice[+@slice] := @array[$wanted_index];
            }
            return @slice;
        }&lt;/p&gt;

&lt;p&gt;infinite slices iterate the available indices:
        sub slice is lvalue (@array, *@wanted_indices) {
            my @slice;
            foreach $actual_index ( 0..@array.last ) {
                @slice[+@slice] := @array[$actual_index]
                    if any(@wanted_indices) == $actual_index;
            }
            return @slice;
        }&lt;/p&gt;

&lt;p&gt;(Obviously, it&amp;rsquo;s actually far more complicated &amp;ndash; and lazy &amp;ndash; than that. It has to preserve the original ordering of the wanted indexes, as well as cope with complex cases like infinite slices of infinite lists. But from the programmer&amp;rsquo;s point of view, it all just DWYMs).
By the way, binding selected array elements to the elements of another array (as in: &lt;code&gt;@slice[+@slice] := @array[$actual_index]&lt;/code&gt;), and then returning the bound array as an lvalue, is a neat Perl 6 idiom for recreating any kind of slice-like semantics with user-defined subroutines.&lt;/p&gt;

&lt;h3 id=&#34;span-id-take-that-and-that-span-take-that-and-that&#34;&gt;&lt;span id=&#34;take that! and that!&#34;&gt;&lt;/span&gt;Take that! And that!&lt;/h3&gt;

&lt;p&gt;And so, lastly, we save the data back to disk:
        save_data(%data, log =&amp;gt; {name=&amp;gt;&amp;lsquo;metalog&amp;rsquo;, vers=&amp;gt;1, costs=&amp;gt;[], stat=&amp;gt;0});&lt;/p&gt;

&lt;p&gt;Note that we&amp;rsquo;re passing in both a hash and a pair, but that these still get correctly folded into &lt;code&gt;&amp;amp;save_data&lt;/code&gt;&amp;rsquo;s single hash parameter, courtesy of the flattening asterisk on the parameter definition:
        sub save_data (*%data) {&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;span-id-in-a-nutshell-span-in-a-nutshell&#34;&gt;&lt;span id=&#34;in a nutshell...&#34;&gt;&lt;/span&gt;In a nutshell&amp;hellip;&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s okay if your head is spinning at this point.
We just crammed a huge number of syntactic and semantic changes into a comparatively small piece of example code. The changes may seem overwhelming, but that&amp;rsquo;s because we&amp;rsquo;ve been concentrating on &lt;em&gt;only&lt;/em&gt; the changes. Most of the syntax and semantics of Perl&amp;rsquo;s operators don&amp;rsquo;t change at all in Perl 6.&lt;/p&gt;

&lt;p&gt;So, to conclude, here&amp;rsquo;s a summary of what&amp;rsquo;s new, what&amp;rsquo;s different, and (most of all) what stays the same.&lt;/p&gt;

&lt;h4 id=&#34;span-id-unchanged-operators-span-unchanged-operators&#34;&gt;&lt;span id=&#34;unchanged operators&#34;&gt;&lt;/span&gt;Unchanged operators&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;prefix and postfix &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;unary &lt;code&gt;!&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;\&lt;/code&gt;, and &lt;code&gt;-&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;binary &lt;code&gt;**&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;binary &lt;code&gt;=~&lt;/code&gt; and &lt;code&gt;!~&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;binary &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, and &lt;code&gt;%&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;binary &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;binary &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;binary &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;binary &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, etc.&lt;/li&gt;
&lt;li&gt;binary &lt;code&gt;,&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;unary &lt;code&gt;not&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;binary &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, and &lt;code&gt;xor&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;span-id-changes-to-existing-operators-span-changes-to-existing-operators&#34;&gt;&lt;span id=&#34;changes to existing operators&#34;&gt;&lt;/span&gt;Changes to existing operators&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;binary &lt;code&gt;-&amp;gt;&lt;/code&gt; (dereference) becomes &lt;code&gt;.&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;binary &lt;code&gt;.&lt;/code&gt; (concatenate) becomes &lt;code&gt;_&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;unary &lt;code&gt;+&lt;/code&gt; (identity) now enforces numeric context on its argument&lt;/li&gt;
&lt;li&gt;binary &lt;code&gt;^&lt;/code&gt; (bitwise xor) becomes &lt;code&gt;~&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;binary &lt;code&gt;=&amp;gt;&lt;/code&gt; becomes the &amp;ldquo;pair&amp;rdquo; constructor&lt;/li&gt;
&lt;li&gt;ternary &lt;code&gt;? :&lt;/code&gt; bbeeccoommeess &lt;code&gt;?? ::&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;span-id-enhancements-to-existing-operators-span-enhancements-to-existing-operators&#34;&gt;&lt;span id=&#34;enhancements to existing operators&#34;&gt;&lt;/span&gt;Enhancements to existing operators&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;binary &lt;code&gt;..&lt;/code&gt; becomes even lazier&lt;/li&gt;
&lt;li&gt;binary &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;lt&lt;/code&gt;, &lt;code&gt;gt&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, etc. become chainable&lt;/li&gt;
&lt;li&gt;Unary &lt;code&gt;-r&lt;/code&gt;, &lt;code&gt;-w&lt;/code&gt;, &lt;code&gt;-x&lt;/code&gt;, etc. are nestable&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; input operator are more context-aware&lt;/li&gt;
&lt;li&gt;The logical &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; operators propagate their context to &lt;em&gt;both&lt;/em&gt; their operands&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;x&lt;/code&gt; repetition operator no longer requires listifying parentheses on its left argument in a list context.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;span-id-new-operators-span-new-operators&#34;&gt;&lt;span id=&#34;new operators:&#34;&gt;&lt;/span&gt;New operators:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;unary &lt;code&gt;_&lt;/code&gt; is the explicit string context enforcer&lt;/li&gt;
&lt;li&gt;binary &lt;code&gt;~~&lt;/code&gt; is high-precedence logical xor&lt;/li&gt;
&lt;li&gt;unary &lt;code&gt;*&lt;/code&gt; is a list context specifier for parameters and a array flattening operator for arguments&lt;/li&gt;
&lt;li&gt;unary &lt;code&gt;^&lt;/code&gt; is a meta-operator for specifying vector operations&lt;/li&gt;
&lt;li&gt;unary &lt;code&gt;:=&lt;/code&gt; is used to create aliased variables (a.k.a. binding)&lt;/li&gt;
&lt;li&gt;unary &lt;code&gt;//&lt;/code&gt; is the logical &amp;lsquo;default&amp;rsquo; operator&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Exegesis 2</title>
      <link>http://localhost:1313/pub/2001/05/08/exegesis2.html/</link>
      <pubDate>Tue, 15 May 2001 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2001/05/08/exegesis2.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S02.html&#34;&gt;Synopsis 2&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;exegesis: n. an interpretation and explanation of a text, esp. Holy Writ&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This is the first of a series of articles paralleling Larry&amp;rsquo;s ``Apocalypse&amp;rdquo; encyclicals (it&amp;rsquo;s numbered 2 to keep it in sync with those Revelations). These articles will take each unveiled piece of the design for Perl 6 and demonstrate the new syntax and semantics in an annotated program.&lt;/p&gt;

&lt;p&gt;So, without further ado, let&amp;rsquo;s write some Perl 6:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        # bintree - binary tree demo program 
        # adapted from &amp;quot;Perl Cookbook&amp;quot;, Recipe 11.15

        use strict;
        use warnings;
        my ($root, $n);

        while ($n++ &amp;lt; 20) { insert($root, int rand 1000) }

        my int ($pre, $in, $post) is constant = (0..2);

        print &amp;quot;Pre order:  &amp;quot;; show($root,$pre);  print &amp;quot;\n&amp;quot;;
        print &amp;quot;In order:   &amp;quot;; show($root,$in);   print &amp;quot;\n&amp;quot;;
        print &amp;quot;Post order: &amp;quot;; show($root,$post); print &amp;quot;\n&amp;quot;;

        $*ARGS is chomped;
        $ARGS prompts(&amp;quot;Search? &amp;quot;);
        while (&amp;lt;$ARGS&amp;gt;) {
            if (my $node = search($root, $_)) {
                print &amp;quot;Found $_ at $node: $node{VALUE}\n&amp;quot;;
                print &amp;quot;(again!)\n&amp;quot; if $node{VALUE}.Found &amp;gt; 1;
            }
            else {
                print &amp;quot;No $_ in tree\n&amp;quot;;
            }
        }

        exit;

        #########################################

        sub insert (HASH $tree is rw, int $val) {
            unless ($tree) {
                my %node;
                %node{LEFT}   = undef;
                %node{RIGHT}  = undef;
                %node{VALUE}  = $val is Found(0);
                $tree = %node;
                return;
            }
            if    ($tree{VALUE} &amp;gt; $val) { insert($tree{LEFT},  $val) }
            elsif ($tree{VALUE} &amp;lt; $val) { insert($tree{RIGHT}, $val) }
            else                        { warn &amp;quot;dup insert of $val\n&amp;quot; }
        }

        sub show {
            return unless @_[0];
            show(@_[0]{LEFT}, @_[1]) unless @_[1] == $post;
            show(@_[0]{RIGHT},@_[1])     if @_[1] == $pre;
            print @_[0]{VALUE};
            show(@_[0]{LEFT}, @_[1])     if @_[1] == $post;
            show(@_[0]{RIGHT},@_[1]) unless @_[1] == $pre;
        }

        sub search (HASH $tree is rw, *@_) {
            return unless $tree;
            return search($tree{@_[0]&amp;lt;$tree{VALUE} &amp;amp;&amp;amp; &amp;quot;LEFT&amp;quot; || &amp;quot;RIGHT&amp;quot;}, @_[0])
                unless $tree{VALUE} == @_[0];
            $tree{VALUE} is Found($tree{VALUE}.Found+1);
            return $tree;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-it-s-perl-jim-and-quite-like-we-know-it-it-s-perl-jim-and-quite-like-we-know-it-span&#34;&gt;&lt;span id=&#34;it&#39;s perl, jim, and quite like we know it&#34;&gt;It&amp;rsquo;s Perl, Jim, and quite like we know it&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The program gets off to a familiar start:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        use strict;
        use warnings;
        my ($root, $n);

        while ($n++ &amp;lt; 20) { insert($root, int rand 1000) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nothing new here. And, in fact, despite the many new features it illustrates, overall this program looks and feels a great deal like Perl 5 code.&lt;/p&gt;

&lt;p&gt;That shouldn&amp;rsquo;t really be surprising, given that Perl 6 is growing out the of suggestions of hundreds of devoted Perl 5 programmers, filtered through the mind that invented Perl 5.&lt;/p&gt;

&lt;p&gt;As &lt;a href=&#34;#http://dev.perl.org/rfc/28.html&#34;&gt;RFC 28&lt;/a&gt; suggested, Perl is definitely going to stay Perl.&lt;/p&gt;

&lt;h3 id=&#34;span-id-any-variables-to-declare-any-variables-to-declare-span&#34;&gt;&lt;span id=&#34;any variables to declare&#34;&gt;Any variables to declare?&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Variable declarations in Perl 6 can be as simple as those for &lt;code&gt;$root&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; above, but they can also be much more sophisticated:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        my int ($pre, $in, $post) is constant = (0..2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we declare three variables that share a common type (&lt;code&gt;int&lt;/code&gt;) and a common property (&lt;code&gt;constant&lt;/code&gt;). Typed lexicals are a feature of Perl 5 too, but having names for Perl&amp;rsquo;s built-in types is new.&lt;/p&gt;

&lt;p&gt;The type specification tells the compiler that &lt;code&gt;$pre&lt;/code&gt;, &lt;code&gt;$in&lt;/code&gt;, and &lt;code&gt;$post&lt;/code&gt; will only ever be used to store integer values. And because &lt;code&gt;int&lt;/code&gt; is in lower-case, the specification also tells the compiler that it&amp;rsquo;s okay to optimize the implementation of the variables, because we promise not to &lt;code&gt;bless&lt;/code&gt; them or ascribe any run-time properties to them. Making this promise and then breaking the rules later in the program will get you a compile-time or run-time error (depending on whether the compiler can detect the malfeasance statically).&lt;/p&gt;

&lt;p&gt;If we had not been willing to live without the blessing of &lt;code&gt;bless&lt;/code&gt;-ing or the useful run-time properties of run-time properties, we would have written:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        my INT ($pre, $in, $post) is constant = (0..2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in which case we&amp;rsquo;d get three less-optimized, but fully-functional, Perl scalars.&lt;/p&gt;

&lt;p&gt;In this particular case, the &lt;code&gt;int&lt;/code&gt;/&lt;code&gt;INT&lt;/code&gt; distinction makes very little practical difference. However, there&amp;rsquo;s a significant advantage to writing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        my int @hit_count is dim(100,366,24);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;compared to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        my INT @hit_count is dim(100,366,24);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and thereby replacing nearly a million chunky scalars with svelte raw integers.&lt;/p&gt;

&lt;h3 id=&#34;span-id-la-proprit-c-est-le-vol-la-propriété-c-est-le-vol-span&#34;&gt;&lt;span id=&#34;la proprit c&#39;est le vol&#34;&gt;La propriété c&amp;rsquo;est le vol&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;is constant&lt;/code&gt; and &lt;code&gt;is dim&lt;/code&gt; bits of the above declarations are compile-time property specifications. These particular properties are standard to Perl 6, but you can also &lt;a href=&#34;#haven&#39;t%20we%20met%20before%20(part%201&#34;&gt;roll-your-own&lt;/a&gt;). The &lt;code&gt;is dim&lt;/code&gt; property tells Perl the (fixed!) dimensions of the array in question. The &lt;code&gt;is constant&lt;/code&gt; property specifies that the preceding variables cannot be assigned to, nor have their values otherwise modified, once they&amp;rsquo;re initialized.&lt;/p&gt;

&lt;p&gt;Moreover, the &lt;code&gt;constant&lt;/code&gt; property is a hint to the compiler that it may be able to optimize the variables right out of existence, by inlining their values directly. Of course, that&amp;rsquo;s only feasible if we don&amp;rsquo;t ever treat them like a real variable (e.g. take a reference to them, or bless them).&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;is&lt;/code&gt; keyword is optional where its absence is unambiguous, so we could have written:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        my int ($pre, $in, $post) constant = (0..2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Larry&amp;rsquo;s also still mulling over a suggestion that &lt;code&gt;are&lt;/code&gt; be provided as a synonym for &lt;code&gt;is&lt;/code&gt;, so you might even be able to write the declaration as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        my int ($pre, $in, $post) are constant = (0..2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An important feature of the &lt;code&gt;is&lt;/code&gt; operator that we&amp;rsquo;ll make use of shortly, is that it returns its &lt;em&gt;left&lt;/em&gt; operand. So:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        $submarine is Colour(&#39;yellow&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;evaluates to &lt;code&gt;$submarine&lt;/code&gt;, not &lt;code&gt;&#39;yellow&#39;&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-more-of-the-same-more-of-the-same-span&#34;&gt;&lt;span id=&#34;more of the same&#34;&gt;More of the same&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The three calls to &lt;code&gt;show&lt;/code&gt; are also exactly as they were in Perl 5:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        print &amp;quot;Pre order:  &amp;quot;; show($root,$pre);  print &amp;quot;\n&amp;quot;;
        print &amp;quot;In order:   &amp;quot;; show($root,$in);   print &amp;quot;\n&amp;quot;;
        print &amp;quot;Post order: &amp;quot;; show($root,$post); print &amp;quot;\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Happily, we&amp;rsquo;re going to see that a lot throughout this series of articles.&lt;/p&gt;

&lt;h3 id=&#34;span-id-biting-off-less-so-you-can-chew-biting-off-less-so-you-can-chew-span&#34;&gt;&lt;span id=&#34;biting off less so you can chew&#34;&gt;Biting off less so you can chew&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Do you ever get tired of writing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        while (&amp;lt;&amp;gt;) {            # Common Perl 5 idiom
                chomp;
                ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wouldn&amp;rsquo;t it be nice if input lines were automatically chomped? In Perl 6, they can be. We just set the &lt;code&gt;chomped&lt;/code&gt; property on the input handle referred to by the global variable &lt;code&gt;$*ARGS&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        $*ARGS is chomped;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This causes any normal read on the handle (see &lt;a href=&#34;#inputs%20that%20output&#34;&gt;Inputs that output&lt;/a&gt;) to automatically pre-&lt;code&gt;chomp&lt;/code&gt; the string it returns. Of course, like most other global punctuation variables, &lt;code&gt;$/&lt;/code&gt; has been banished from Perl 6, so the trailing character sequence to be chomped is specified by the handle&amp;rsquo;s own &lt;code&gt;insep&lt;/code&gt; (&lt;strong&gt;in&lt;/strong&gt;put &lt;strong&gt;sep&lt;/strong&gt;arator) property instead.&lt;/p&gt;

&lt;p&gt;The asterisk in &lt;code&gt;$*ARGS&lt;/code&gt; indicates that the variable is the one from the special global namespace. If the asterisk is omitted, it&amp;rsquo;s probably &lt;em&gt;still&lt;/em&gt; the one from the special global namespace &amp;ndash; unless you declared a lexical or package variable of the same name. You can pronounce &lt;code&gt;*&lt;/code&gt; as ``standard&amp;rdquo;, if that helps.&lt;/p&gt;

&lt;p&gt;By the way, it&amp;rsquo;s called &lt;code&gt;$*ARGS&lt;/code&gt; because it lets us access the files passed as a Perl 6 program&amp;rsquo;s &lt;em&gt;arguments&lt;/em&gt; (just as the Perl 5 &lt;code&gt;ARGV&lt;/code&gt; filehandle provides access to the program&amp;rsquo;s&amp;hellip;err&amp;hellip;&lt;em&gt;argumentv&lt;/em&gt;).&lt;/p&gt;

&lt;h3 id=&#34;span-id-inputs-that-output-inputs-that-output-span&#34;&gt;&lt;span id=&#34;inputs that output&#34;&gt;Inputs that output&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In the original &lt;a href=&#34;http://www.oreilly.com/catalog/cookbook/&#34;&gt;&lt;em&gt;Cookbook&lt;/em&gt;&lt;/a&gt; version of this program, the next line was:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        for (print &amp;quot;Search? &amp;quot;; &amp;lt;&amp;gt;; print &amp;quot;Search? &amp;quot;) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This highlights a common situation for which there is no satisfactory solution in Perl 5. Namely: repeatedly prompting for input and reading it into &lt;code&gt;$_&lt;/code&gt;, until EOF. In Perl 6, there&amp;rsquo;s finally a clean way to do this &amp;ndash; with another property:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        $ARGS prompts(&amp;quot;Search? &amp;quot;);
        while (&amp;lt;$ARGS&amp;gt;) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first thing you&amp;rsquo;ll notice is that reports of the diamond operator&amp;rsquo;s death have been greatly exaggerated. Yes, even though the Second Apocalypse foretold its demise, Rule #2 has since been applied and the angle brackets live!&lt;/p&gt;

&lt;p&gt;Of course, they&amp;rsquo;re slightly different in Perl 6, in that they &lt;em&gt;require&lt;/em&gt; a handle object inside them (normally stored in a variable), but that&amp;rsquo;s already possible in Perl 5 too.&lt;/p&gt;

&lt;p&gt;Meanwhile, what about that prompt? Well, the Perl 6 solution is to allow input handles to have an associated character string that they print out just before they attempt to read in data.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Wait a minute!&lt;/em&gt;, I hear you object, &lt;em&gt;Input handles that do output???&lt;/em&gt; Actually, you&amp;rsquo;ve been using handles like that for decades. In most languages, every time you do a read from standard input, the first thing the input operation does is flush the standard output buffer. That&amp;rsquo;s why something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        print &amp;quot;nuqneH? &amp;quot;;
        $request = &amp;lt;&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pre-prints the prompt correctly, even though it doesn&amp;rsquo;t end in a newline.&lt;/p&gt;

&lt;p&gt;So input and output mechanisms are already carrying on a secret relationship. The only change here is that now you&amp;rsquo;re allowed to have the input handle add a little something to the output before it flushes the buffer. That&amp;rsquo;s done with the &lt;code&gt;prompts&lt;/code&gt; property. If an input handle has that property, its value is written to &lt;code&gt;$*OUT&lt;/code&gt; just before the input handle reads. So we can replace:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        for (print &amp;quot;Search? &amp;quot;; &amp;lt;&amp;gt;; print &amp;quot;Search? &amp;quot;;) {         # Perl 5 (or 6)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        $ARGS prompts(&amp;quot;Search? &amp;quot;);                              # Perl 6
        while (&amp;lt;$ARGS&amp;gt;) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Technically, that should of course be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        $ARGS is prompts(&amp;quot;Search? &amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but that grates unbearably. Fortunately the &lt;code&gt;is&lt;/code&gt; is optional in contexts &amp;ndash; such as this one &amp;ndash; where it can be inferred.&lt;/p&gt;

&lt;p&gt;Note that, because the &lt;code&gt;is&lt;/code&gt; operation returns its &lt;code&gt;left&lt;/code&gt; operand (even when the &lt;code&gt;is&lt;/code&gt; is invisible!), we could also use the rather elegant:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        while (&amp;lt;$ARGS prompts(&amp;quot;Search? &amp;quot;)&amp;gt;) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, this one-line version may often be preferable, since the value of the &lt;code&gt;prompts&lt;/code&gt; property might be changed somewhere inside the loop and this resets it on each iteration.&lt;/p&gt;

&lt;p&gt;The exact semantics of the prompting mechanism aren&amp;rsquo;t nailed down yet, so it may also be possible to use a subroutine reference as a dynamic prompt (the handle would call the subroutine before each read and pre-print the return value).&lt;/p&gt;

&lt;h3 id=&#34;span-id-haven-t-we-met-before-part-1-haven-t-we-met-before-part-1-span&#34;&gt;&lt;span id=&#34;haven&#39;t we met before (part 1)&#34;&gt;Haven&amp;rsquo;t we met before? (part 1)&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Having requested and read in a value, the search-and-report code is almost entirely familiar:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            if (my $node = search($root, $_)) {
                print &amp;quot;Found $_ at $node: $node{VALUE}\n&amp;quot;
                print &amp;quot;(again!)\n&amp;quot; if $node{VALUE}.Found &amp;gt; 1;
            }
            else {
                print &amp;quot;No $_ in tree\n&amp;quot;
            }
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only lurking Perl6ism is the use of the user-defined &lt;code&gt;Found&lt;/code&gt; property to report repeated searches.&lt;/p&gt;

&lt;p&gt;The call to &lt;code&gt;$node{VALUE}.Found&lt;/code&gt; would normally be a method call (in Perl 6 &lt;code&gt;-&amp;gt;&lt;/code&gt; is spelled &lt;code&gt;.&lt;/code&gt;). But since &lt;code&gt;$node{VALUE}&lt;/code&gt; is just a regular unblessed int, there is no &lt;code&gt;Found&lt;/code&gt; method to call. So Perl treats the request as a property query instead and returns (an alias to) the corresponding property.&lt;/p&gt;

&lt;h3 id=&#34;span-id-take-that-and-that-take-that-and-that-span&#34;&gt;&lt;span id=&#34;take that! and that!&#34;&gt;Take that! And that!&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In Perl 6, subroutines can &amp;ndash; optionally &amp;ndash; specify proper parameter lists (as opposed to the not-evil-just-misunderstood argument context prototypes that Perl 5 allows).&lt;/p&gt;

&lt;p&gt;For instance the &lt;code&gt;insert&lt;/code&gt; subroutine, declares itself to take two parameters:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        sub insert (HASH $tree is rw, int $val) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first parameter specifies that the first argument must be a reference to a hash and is to be assigned to the lexical variable &lt;code&gt;$tree&lt;/code&gt;. Defining the first parameter to be a hash reference means that any attempt to use it in some other way (e.g. trying to do an subroutine call through it, trying to pass it an explicit array reference, etc.) can be caught and punished &amp;ndash; at compile-time.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s important to understand that, by default, named parameters are &lt;em&gt;not&lt;/em&gt; like the elements of &lt;code&gt;@_&lt;/code&gt;. Specifically, even though each argument is passed to its corresponding parameter by reference (for efficiency), the parameter variable itself is automatically declared &lt;code&gt;constant&lt;/code&gt;, so any attempt to assign to it results in a compile-time error. This is intended to reduce the incidence of people accidentally people shooting themselves in the foot.&lt;/p&gt;

&lt;p&gt;Of course, this being Perl, when we really do need to draw a bead on those metatarsals, we can. To allow assignments to a named parameter &amp;ndash; assignments that &lt;em&gt;will&lt;/em&gt; propagate back to the original argument &amp;ndash; we need to to declare the parameter with the standard &lt;code&gt;rw&lt;/code&gt; (&lt;strong&gt;r&lt;/strong&gt;ead-&lt;strong&gt;w&lt;/strong&gt;rite) property. It then becomes an fully assignable alias for the original argument, which in this example allows us to autovivify it (see &lt;a href=&#34;#we%20don&#39;t%20need%20no%20stinking%20backslashes&#34;&gt;We don&amp;rsquo;t need no stinking backslashes&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;@_&lt;/code&gt; argument array &lt;em&gt;is&lt;/em&gt; still available in Perl 6, but only when we declare subroutines in the Perl 5 manner &amp;ndash; without a parameter list. See &lt;a href=&#34;#a%20good,%20oldfashioned%20show&#34;&gt;A good, old-fashioned show&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;The second parameter of &lt;code&gt;insert&lt;/code&gt; is defined to take an integer value. By using the type &lt;code&gt;int&lt;/code&gt; instead of &lt;code&gt;INT&lt;/code&gt;, we&amp;rsquo;re once again explicitly promising not to do bizarre things with the referent (at least, not within the body of &lt;code&gt;insert&lt;/code&gt;). The compiler might be able to use this information to optimize the subroutine&amp;rsquo;s code in some way.&lt;/p&gt;

&lt;h3 id=&#34;span-id-a-sigil-is-for-life-not-just-for-value-type-a-sigil-is-for-life-not-just-for-value-type-span&#34;&gt;&lt;span id=&#34;a sigil is for life, not just for value type&#34;&gt;A sigil is for life, not just for value type&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Long ago, when the Earth was new and Perl was young and clean, the type of sigil (&lt;code&gt;$&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, or &lt;code&gt;%&lt;/code&gt;) that was associated with a variable described what it evaluated to. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        print $x;                       # $x evaluates to scalar
        print $y[1];                    # $y[1] evaluates to scalar
        print $z{a};                    # $z{a} evaluates to scalar
        print $yref-&amp;gt;[1];               # $yref-&amp;gt;[1] evaluates to scalar
        print $zref-&amp;gt;{a};               # $zref-&amp;gt;{a} evaluates to scalar
        print @y;                       # @y evaluates to list
        print @y[2,3];                  # @y[2,3] evaluates to list
        print @z{&#39;b&#39;,&#39;c&#39;};              # @z{&#39;b&#39;,&#39;c&#39;} evaluates to list
        print @{$yref}[2,3];            # @{$yref}[2,3] evaluates to list
        print @{$zref}{&#39;b&#39;,&#39;c&#39;};        # @{zyref}{&#39;b&#39;,&#39;c&#39;} evaluates to list
        print %z;                       # %z evaluates to hash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Regardless of the actual type of the variable being referred to, a leading &lt;code&gt;$&lt;/code&gt; on the access meant the result would be a scalar; a leading &lt;code&gt;@&lt;/code&gt; meant a list; a leading &lt;code&gt;%&lt;/code&gt;, a hash.&lt;/p&gt;

&lt;p&gt;But then the serpent of OO entered the garden, and offered Perlkind the bitter fruit of subroutine and method calls:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        print $subref-&amp;gt;();
        print $objref-&amp;gt;method();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the leading &lt;code&gt;$&lt;/code&gt; no longer indicated the type of value returned. And in beginners&amp;rsquo; Perl classes across the land there arose a great wailing and a gnashing of teeth.&lt;/p&gt;

&lt;p&gt;Perl 6 returns us to a state of grace &amp;ndash; albeit a state of &lt;em&gt;different&lt;/em&gt; grace &amp;ndash;in which each variable type has One True Sigil, from which it never strays.&lt;/p&gt;

&lt;p&gt;In Perl 6, a scalar &lt;em&gt;always&lt;/em&gt; has a leading &lt;code&gt;$&lt;/code&gt;, an array &lt;em&gt;always&lt;/em&gt; has a leading &lt;code&gt;@&lt;/code&gt; (even when accessing its elements or slicing it), and a hash &lt;em&gt;always&lt;/em&gt; has a leading &lt;code&gt;%&lt;/code&gt; (even when accessing its entries or slicing it).&lt;/p&gt;

&lt;p&gt;In other words, the sigil no longer (sometimes) indicates the type of the resulting value. Instead, it (always) tells you exactly what kind of variable you&amp;rsquo;re messing about with, regardless of what kind of messing about you&amp;rsquo;re doing.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;insert&lt;/code&gt; subroutine has several examples of this new syntax. The most obvious are in the autovivification of an empty subtree at the start of the subroutine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            unless ($tree) {
                my %node;
                %node{LEFT}   = undef;
                %node{RIGHT}  = undef;
                %node{VALUE}  = $val
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Even though we&amp;rsquo;re accessing the &lt;code&gt;%node&lt;/code&gt; hash&amp;rsquo;s entries, the variable retains its &lt;code&gt;%&lt;/code&gt; sigil and the hash access braces are simply appended to the complete variable name.&lt;/p&gt;

&lt;p&gt;Likewise, to access the element of an array, we simply append the array-access square brackets to the variable name: &lt;code&gt;@array[1]&lt;/code&gt;. This is a significant departure from Perl 5 syntax. In Perl 5, &lt;code&gt;@array[1]&lt;/code&gt; is a one-element slice of the &lt;code&gt;@array&lt;/code&gt; array; in Perl 6, it&amp;rsquo;s a direct single element access (no slicing involved).&lt;/p&gt;

&lt;p&gt;This means, of course, that Perl 6 will require some revised array-slicing semantics. Larry&amp;rsquo;s planning to take that opportunity to beef up Perl&amp;rsquo;s slicing facilities and provide for arbitrary slicing and dicing of multidimensional arrays. But that&amp;rsquo;s for a future Apocalypse.&lt;/p&gt;

&lt;p&gt;For the time being, it&amp;rsquo;s enough to know that, if you put a single scalar in the square brackets, you get a single element look-up; if you put a list in the brackets, you get a slice.&lt;/p&gt;

&lt;h3 id=&#34;span-id-haven-t-we-met-before-part-2-haven-t-we-met-before-part-2-span&#34;&gt;&lt;span id=&#34;haven&#39;t we met before (part 2)&#34;&gt;Haven&amp;rsquo;t we met before? (part 2)&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The last assignment to a &lt;code&gt;%node&lt;/code&gt; entry has one other little twist. The (copy of the) value being assigned is also ascribed a &lt;code&gt;Found&lt;/code&gt; property, initialized to the value zero:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                %node{VALUE}  = $val is Found(0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once again, that works because, when a property is set using &lt;code&gt;is&lt;/code&gt;, the result of the operation is the left operand (in this case &lt;code&gt;$val&lt;/code&gt;), &lt;em&gt;not&lt;/em&gt; the new value of the property.&lt;/p&gt;

&lt;p&gt;Indeed, although we glossed over it at the time, that&amp;rsquo;s the only reason the:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        while (&amp;lt;$ARGS prompts(&amp;quot;Search? &amp;quot;)&amp;gt;) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;syntax actually worked. The expression &lt;code&gt;$ARGS prompts(&amp;quot;Search? &amp;quot;)&lt;/code&gt; set the handle&amp;rsquo;s prompt, and then returned &lt;code&gt;$ARGS&lt;/code&gt;, which became the operand of the diamond operator, resulting in a prompt-and-read operation through that handle.&lt;/p&gt;

&lt;h3 id=&#34;span-id-we-don-t-need-no-stinking-backslashes-we-don-t-need-no-stinking-backslashes-span&#34;&gt;&lt;span id=&#34;we don&#39;t need no stinking backslashes&#34;&gt;We don&amp;rsquo;t need no stinking backslashes&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Once the new &lt;code&gt;%node&lt;/code&gt; is initialized, a reference to it needs to be assigned to the variable that was passed as the first argument (if it&amp;rsquo;s not clear why, see section 12.3.2 of &lt;a href=&#34;http://www.manning.com/conway/&#34;&gt;&lt;em&gt;Object Oriented Perl&lt;/em&gt;&lt;/a&gt; for a detailed explanation of this tree-manipulation technique).&lt;/p&gt;

&lt;p&gt;In Perl 5, modifying an original argument would require an assignment to &lt;code&gt;$_[0]&lt;/code&gt; (i.e. &lt;code&gt;@_[0]&lt;/code&gt; in Perl 6), but because we declared &lt;code&gt;$tree&lt;/code&gt; to be &lt;code&gt;rw&lt;/code&gt;, we can assign directly to it and have the original argument change appropriately:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                $tree = %node;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Oops,&lt;/em&gt; (you&amp;rsquo;re probably thinking), &lt;em&gt;he just fell victim to one of the Classic Blunders: In a scalar context, a hash evaluates to the ratio of used buckets to allocated buckets!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;In Perl 5 maybe, but in Perl 6 that near-useless behaviour has gone the way of the powdered wigs, buggy whips, and DSL providers. Instead, when evaluated in a scalar context, a hash (or an array) returns a reference to itself. So the above line of code works correctly.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Okay,&lt;/em&gt; (you&amp;rsquo;re now wondering), &lt;em&gt;if arrays do that too, how do I get the length of an array???&lt;/em&gt; The answer is that in a numeric context an array reference now evaluates to the length of the array. So the translation of the Perl 5 code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        while (@queue &amp;gt; 0) {    # scalar eval of @queue yields length
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        while (@queue &amp;gt; 0) {    # scalar eval of @queue yields ref to array
                                # ref to array in numeric context yields length
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Similarly, in a boolean context, an array evaluates true if it contains any elements, so the translation of the Perl 5 code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        while (@queue) {    # scalar eval of @queue yields length
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        while (@queue) {    # boolean eval of @queue yields true if not empty
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cunning, huh?&lt;/p&gt;

&lt;h3 id=&#34;span-id-you-say-node-value-but-i-say-tree-value-you-say-node-value-but-i-say-tree-value-span&#34;&gt;&lt;span id=&#34;you say %node{value}, but i say $tree{value}&#34;&gt;You say &lt;code&gt;%node{VALUE}&lt;/code&gt;, but I say &lt;code&gt;$tree{VALUE}&lt;/code&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;When we were loading up the new node, we wrote &lt;code&gt;%node{VALUE}&lt;/code&gt; to access its &lt;code&gt;&#39;VALUE&#39;&lt;/code&gt; entry. Now that &lt;code&gt;$tree&lt;/code&gt; holds a reference to &lt;code&gt;%node&lt;/code&gt;, we need some way of accessing the same entry.&lt;/p&gt;

&lt;p&gt;In Perl 5 that would be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        $tree-&amp;gt;{VALUE}        # Perl 5 entry access through hash ref in $tree
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And since &lt;code&gt;-&amp;gt;&lt;/code&gt; is spelled &lt;code&gt;.&lt;/code&gt; in Perl 6, that becomes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        $tree.{VALUE}         # Perl 6 entry access through hash ref in $tree
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, since the direct hash access syntax now uses a completely different sigil &amp;ndash; &lt;code&gt;%node{VALUE}&lt;/code&gt; &amp;ndash; the &lt;code&gt;.&lt;/code&gt; isn&amp;rsquo;t needed for disambiguation there and hence can be made optional:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        $tree{VALUE}          # Perl 6 entry access through hash ref in $tree
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that&amp;rsquo;s the usual way accesses to hash references will be written:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            if    ($tree{VALUE} &amp;gt; $val) { insert($tree{LEFT},  $val) }
            elsif ($tree{VALUE} &amp;lt; $val) { insert($tree{RIGHT}, $val) }
            else                        { warn &amp;quot;dup insert of $val\n&amp;quot; }
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is actually far &lt;em&gt;less&lt;/em&gt; confusing than it might at first seem. For example, back in &lt;a href=&#34;#haven&#39;t%20we%20met%20before%20(part%201&#34;&gt;Haven&amp;rsquo;t we met before? (part 1)&lt;/a&gt;), did you notice that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        if (my $node = search($root, $_)) {
            print &amp;quot;Found $_ at $node: $node{VALUE}\n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;already used this new syntax?&lt;/p&gt;

&lt;p&gt;In Perl 5 that would have been a (very common) error &amp;ndash; the second line would print an entry of &lt;code&gt;%node&lt;/code&gt;, when we actually wanted an entry of &lt;code&gt;%{$node}&lt;/code&gt;. But in Perl 6, it just Does What We Mean.&lt;/p&gt;

&lt;p&gt;And, of course, access through other kinds of references will also allow the &lt;code&gt;.&lt;/code&gt; to be omitted: &lt;code&gt;$arr_ref[$index]&lt;/code&gt; and &lt;code&gt;$sub_ref(@args)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a handy conversion table:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        Access through...       Perl 5          Perl 6
        =================       ======          ======
        Scalar variable         $foo            $foo
        Array variable          $foo[$n]        @foo[$n]
        Hash variable           $foo{$k}        %foo{$k}
        Array reference         $foo-&amp;gt;[$n]      $foo[$n] (or $foo.[$n])
        Hash reference          $foo-&amp;gt;{$k}      $foo{$k} (or $foo.{$k})
        Code reference          $foo-&amp;gt;(@a)      $foo(@a) (or $foo.(@a))
        Array slice             @foo[@ns]       @foo[@ns]
        Hash slice              @foo{@ks}       %foo{@ks}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-a-good-oldfashioned-show-a-good-old-fashioned-show-span&#34;&gt;&lt;span id=&#34;a good, oldfashioned show&#34;&gt;A good, old-fashioned show&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;show&lt;/code&gt; subroutine illustrates the optional nature of parameter lists. Here we omit the parameter specifications entirely, and get the good old familiar ``take-any-number-of-arguments-and-stick-them-all-in-&lt;code&gt;@_&lt;/code&gt;&amp;rdquo; semantics.&lt;/p&gt;

&lt;p&gt;Indeed, apart from its DWIM-ier array access syntax, the &lt;code&gt;show&lt;/code&gt; subroutine is vanilla Perl 5:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        sub show {
            return unless @_[0];
            show(@_[0]{LEFT}, @_[1]) unless @_[1] == $post;
            show(@_[0]{RIGHT},@_[1])     if @_[1] == $pre;
            print @_[0]{VALUE};
            show(@_[0]{LEFT}, @_[1])     if @_[1] == $post;
            show(@_[0]{RIGHT},@_[1]) unless @_[1] == $pre;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that, we believe, will be the normal experience when moving from 5 to 6: Perl will still be Perl&amp;hellip;only slightly more so.&lt;/p&gt;

&lt;p&gt;Of course, the &lt;code&gt;show&lt;/code&gt; subroutine is moderately funky Perl anyway, so if symmetrically guarded repetitions of the left- and right- subtree traversals aren&amp;rsquo;t your maintenance dream, this would also be the ideal place to use Perl&amp;rsquo;s new &lt;em&gt;case&lt;/em&gt; statement.&lt;/p&gt;

&lt;p&gt;But that won&amp;rsquo;t be unveiled until Apocalypse 4, so if you could just look at this &lt;a href=&#34;#http://www.meninblack.com/media/kay08.html&#34;&gt;little red light&lt;/a&gt;&amp;hellip;.&amp;lt;FLASH&amp;gt;&amp;hellip;Thank-you.&lt;/p&gt;

&lt;h3 id=&#34;span-id-search-me-search-me-span&#34;&gt;&lt;span id=&#34;search me&#34;&gt;Search me&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The parameter list of the &lt;code&gt;search&lt;/code&gt; subroutine is interesting because it&amp;rsquo;s a hybrid of the old and new Perl semantics:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        sub search (HASH $tree is rw, *@_) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Both parameter&amp;rsquo;s are explicitly declared, but the second declaration (&lt;code&gt;*@_&lt;/code&gt;) causes the remaining parameters to be collected in &lt;code&gt;@_&lt;/code&gt;. There&amp;rsquo;s nothing &lt;em&gt;magical&lt;/em&gt; about &lt;code&gt;@_&lt;/code&gt; there: if the second declaration had been &lt;code&gt;*@others&lt;/code&gt;, the rest of the arguments would have turned up in &lt;code&gt;@others&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The asterisk in the second parameter tells Perl 6 that the corresponding argument position is a plain ol&amp;rsquo; list context, so that any arguments there (or thereafter) should be treated as a single list and assigned to the corresponding parameter variable. It&amp;rsquo;s the equivalent of the Perl 5 &lt;code&gt;@&lt;/code&gt; prototype.&lt;/p&gt;

&lt;p&gt;In contrast, a parameter declaration of &lt;code&gt;@param&lt;/code&gt;, is the equivalent of Perl 5&amp;rsquo;s &lt;code&gt;\@&lt;/code&gt; prototype &amp;ndash; and explicitly requires an array variable as the corresponding argument.&lt;/p&gt;

&lt;p&gt;Notice that, because we started collecting arguments in &lt;code&gt;@_&lt;/code&gt; from the &lt;em&gt;second&lt;/em&gt; parameter, the value we&amp;rsquo;re looking for (i.e. the second argument) is referred to as &lt;code&gt;@_[0]&lt;/code&gt;, not &lt;code&gt;@_[1]&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            return search($tree{@_[0]&amp;lt;$tree{VALUE} &amp;amp;&amp;amp; &amp;quot;LEFT&amp;quot; || &amp;quot;RIGHT&amp;quot;}, @_[0])
                unless $tree{VALUE} == @_[0];
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-haven-t-we-met-before-part-3-haven-t-we-met-before-part-3-span&#34;&gt;&lt;span id=&#34;haven&#39;t we met before (part 3)&#34;&gt;Haven&amp;rsquo;t we met before? (part 3)&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The second last line of &lt;code&gt;search&lt;/code&gt; is where all the Perl 6 action is. Having worked out that we&amp;rsquo;re already at the desired node, we&amp;rsquo;re going to return it. But we also need to increment its &lt;code&gt;Found&lt;/code&gt; property, which we do like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            $tree{VALUE} is Found($tree{VALUE}.Found+1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This highlights two of the three ways of accessing a property: the read-write &lt;code&gt;.&lt;/code&gt; syntax, and the write-only &lt;code&gt;is&lt;/code&gt; operator.&lt;/p&gt;

&lt;p&gt;If a property is accessed as if it were a method, its value can be set by passing the new value as an argument. Whether such a value is passed or not, the result of the operation is an alias (i.e. an lvalue) for the property itself. So we could also increment the values&amp;rsquo;s &lt;code&gt;Found&lt;/code&gt; property like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        $tree{VALUE}.Found($tree{VALUE}.Found+1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        $tree{VALUE}.Found++;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;is&lt;/code&gt; syntax, on the other hand, can only set a property, because the &lt;code&gt;is&lt;/code&gt; operation returns its left operand (the referent that owns the property), not the value of property itself. This is often highly useful, however, for last-minute property setting in a &lt;code&gt;return&lt;/code&gt; statement:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        return $result is Verified;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another very common usage is expected to be in returning zero-but-true and non-zero-but-false values:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        sub my_system ($shell_command) {
                ...
                return $error is false if $error;
                return 0 is true;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;em&gt;third&lt;/em&gt; way of accessing a property is via the &lt;code&gt;prop&lt;/code&gt; meta-property, which returns a reference to a hash containing all the properties of a referent:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        $tree{VALUE}.prop{Found}++;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also use this feature to list &lt;em&gt;all&lt;/em&gt; the properties that a referent has been ascribed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        for (keys %{$tree.prop}) {
            print &amp;quot;$_: $tree{VALUE}.prop{$key}\n&amp;quot;;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By the way, in Apocalypse 2, Larry waggishly referred to the &lt;code&gt;prop&lt;/code&gt; meta-property as &lt;code&gt;btw&lt;/code&gt;, but with the help of &lt;a href=&#34;#http://www.meninblack.com/media/kay08.html&#34;&gt;modern therapeutic techniques&lt;/a&gt;, he&amp;rsquo;s now gotten over the idea.&lt;/p&gt;

&lt;h3 id=&#34;span-id-coda-on-an-earlier-theme-coda-on-an-earlier-theme-span&#34;&gt;&lt;span id=&#34;coda on an earlier theme&#34;&gt;Coda on an earlier theme&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;This article has illustrated several important new features that Perl 6 will provide. But don&amp;rsquo;t let all that newness scare you. Perl has always offered the ability to code at your own level and in the style that suits you best. That&amp;rsquo;s not going to change, even if the style that suits you best is Perl 5.&lt;/p&gt;

&lt;p&gt;Almost every new feature covered here will be &lt;em&gt;optional&lt;/em&gt;, and if you choose not to use them, you can still write the same program in a manner that is &lt;em&gt;very&lt;/em&gt; close to Perl 5. Like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        use strict;
        use warnings;
        my ($root, $n);

        while ($n++ &amp;lt; 20) { insert($root, int rand 1000) }

        my ($pre, $in, $post) = (0..2);

        print &amp;quot;Pre order:  &amp;quot;; show($root,$pre);  print &amp;quot; \n&amp;quot;;
        print &amp;quot;In order:   &amp;quot;; show($root,$in);   print &amp;quot; \n&amp;quot;;
        print &amp;quot;Post order: &amp;quot;; show($root,$post); print &amp;quot; \n&amp;quot;;

        for (print &amp;quot;Search? &amp;quot;; &amp;lt;$ARGS&amp;gt;; print &amp;quot;Search? &amp;quot;) {
            chomp;
            if (my $node = search($root, $_)) {
                print &amp;quot;Found $_ at $node: $node{VALUE}\n&amp;quot;;
                print &amp;quot;(again!)\n&amp;quot; if $node{FOUND} &amp;gt; 1;
            }
            else {
                print &amp;quot;No $_ in tree\n&amp;quot;;
            }
        }

        exit;

        #########################################

        sub insert {
            unless (@_[0]) {
                @_[0] = { LEFT  =&amp;gt; undef, RIGHT =&amp;gt; undef,
                          VALUE =&amp;gt; @_[1], FOUND =&amp;gt; 0,
                        };
                return;
            }
            if    (@_[0]{VALUE} &amp;gt; @_[1]) { insert(@_[0]{LEFT},  @_[1]) }
            elsif (@_[0]{VALUE} &amp;lt; @_[1]) { insert(@_[0]{RIGHT}, @_[1]) }
            else                         { warn &amp;quot;dup insert of @_[1]\n&amp;quot;  }
        }

        sub show  {
            return unless @_[0];
            show(@_[0]{LEFT}, @_[1]) unless @_[1] == $post;
            show(@_[0]{RIGHT},@_[1])     if @_[1] == $pre;
            print @_[0]{VALUE};
            show(@_[0]{LEFT}, @_[1])     if @_[1] == $post;
            show(@_[0]{RIGHT},@_[1]) unless @_[1] == $pre;
        }

        sub search {
            return unless @_[0];
            return search(@_[0]{@_[1]&amp;lt;@_[0]{VALUE} &amp;amp;&amp;amp; &amp;quot;LEFT&amp;quot; || &amp;quot;RIGHT&amp;quot;}, @_[1])
                unless @_[0]{VALUE} == @_[1];
            @_[0]{FOUND}++;
            return @_[0];
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, that&amp;rsquo;s only 40 characters (out of 1779) from being pure Perl 5. And almost all of those differences are &lt;code&gt;@&lt;/code&gt;&amp;rsquo;s instead of &lt;code&gt;$&lt;/code&gt;&amp;rsquo;s at the start of array element look-ups.&lt;/p&gt;

&lt;p&gt;98% backwards compatibility even without an automatic p52p6 translator&amp;hellip;pretty slick!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bless My Referents</title>
      <link>http://localhost:1313/pub/1999/09/refererents.html/</link>
      <pubDate>Thu, 16 Sep 1999 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/1999/09/refererents.html/</guid>
      <description>

&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Damian Conway is the author of the newly released &lt;a href=&#34;https://www.manning.com/books/object-oriented-perl&#34;&gt;Object Oriented Perl&lt;/a&gt;, the first of a new series of Perl books from Manning.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Object-oriented programming in Perl is easy. Forget the heavy theory and the sesquipedalian jargon: classes in Perl are just regular packages, objects are just variables, methods are just subroutines. The syntax and semantics are a little different from regular Perl, but the basic building blocks are completely familiar.&lt;/p&gt;

&lt;p&gt;The one problem most newcomers to object-oriented Perl seem to stumble over is the notion of references and referents, and how the two combine to create objects in Perl. So let&amp;rsquo;s look at how references and referents relate to Perl objects, and see who gets to be blessed and who just gets to point the finger.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start with a short detour down a dark alley&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;references-and-referents&#34;&gt;References and referents&lt;/h3&gt;

&lt;p&gt;Sometimes it&amp;rsquo;s important to be able to access a variable indirectly— to be able to use it without specifying its name. There are two obvious motivations: the variable you want may not &lt;em&gt;have&lt;/em&gt; a name (it may be an anonymous array or hash), or you may only know which variable you want at run-time (so you don&amp;rsquo;t have a name to offer the compiler).&lt;/p&gt;

&lt;p&gt;To handle such cases, Perl provides a special scalar datatype called a &lt;em&gt;reference&lt;/em&gt;. A reference is like the traditional Zen idea of the &amp;ldquo;finger pointing at the moon&amp;rdquo;. It&amp;rsquo;s something that identifies a variable, and allows us to locate it. And that&amp;rsquo;s the stumbling block most people need to get over: the finger (reference) isn&amp;rsquo;t the moon (variable); it&amp;rsquo;s merely a means of working out where the moon is.&lt;/p&gt;

&lt;h3 id=&#34;making-a-reference&#34;&gt;Making a reference&lt;/h3&gt;

&lt;p&gt;When you prefix an existing variable or value with the unary \ operator you get a reference to the original variable or value. That original is then known as the &lt;em&gt;referent&lt;/em&gt; to which the reference refers.&lt;/p&gt;

&lt;p&gt;For example, if $s is a scalar variable, then \$s is a reference to that scalar variable (i.e. a finger pointing at it) and $s is that finger&amp;rsquo;s referent. Likewise, if @a in an array, then \@a is a reference to it.&lt;/p&gt;

&lt;p&gt;In Perl, a reference to any kind of variable can be stored in another scalar variable. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$slr_ref = \$s;     # scalar $slr_ref stores a reference to scalar $s
$arr_ref = \@a;     # scalar $arr_ref stores a reference to array @a
$hsh_ref = \%h;     # scalar $hsh_ref stores a reference to hash %h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Figure 1 shows the relationships produced by those assignments.
Note that the references are separate entities from the referents at which they point. The only time that isn&amp;rsquo;t the case is when a variable happens to contain a reference to itself:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$self_ref = \$self_ref;     # $self_ref stores a reference to itself!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That (highly unusual) situation produces an arrangement shown in Figure 2.
Once you have a reference, you can get back to the original thing it refers to—it&amp;rsquo;s referent—simply by prefixing the variable containing the reference (optionally in curly braces) with the appropriate variable symbol. Hence to access $s, you could write $$slr_ref or ${$slr_ref}. At first glance, that might look like one too many dollar signs, but it isn&amp;rsquo;t. The $slr_ref tells Perl which variable has the reference; the extra $ tells Perl to follow that reference and treat the referent as a scalar.&lt;/p&gt;

&lt;p&gt;Similarly, you could access the array @a as @{$arr_ref}, or the hash %h as %{$hsh_ref}. In each case, the $whatever_ref is the name of the scalar containing the reference, and the leading @ or % indicates what type of variable the referent is. That type is important: if you attempt to prefix a reference with the wrong symbol (for example, @{$slr_ref} or ${$hsh_ref}), Perl produces a fatal run-time error.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_09_refererents/refs.gif&#34; alt=&#34;[A series of scalar variables with arrows pointing to other variables]&#34; width=&#34;450&#34; height=&#34;267&#34; /&gt;
&lt;strong&gt;Figure 1: References and their referents&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_09_refererents/selfref.gif&#34; alt=&#34;[A scalar variable with an arrow pointing back to itself]&#34; width=&#34;250&#34; height=&#34;147&#34; /&gt;
&lt;strong&gt;Figure 2: A reference that is its own referent&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;the-arrow-operator&#34;&gt;The &amp;ldquo;arrow&amp;rdquo; operator&lt;/h3&gt;

&lt;p&gt;Accessing the elements of an array or a hash through a reference can be awkward using the syntax shown above. You end up with a confusing tangle of dollar signs and brackets:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;${$arr_ref}[0] = ${$hsh_ref}{&amp;quot;first&amp;quot;};  # i.e. $a[0] = $h{&amp;quot;first&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So Perl provides a little extra syntax to make life just a little less cluttered:
    $arr_ref-&amp;gt;[0] = $hsh_ref-&amp;gt;{&amp;ldquo;first&amp;rdquo;};    # i.e. $a[0] = $h{&amp;ldquo;first&amp;rdquo;}&lt;/p&gt;

&lt;p&gt;The &amp;ldquo;arrow&amp;rdquo; operator (-&amp;gt;) takes a reference on its left and either an array index (in square brackets) or a hash key (in curly braces) on its right. It locates the array or hash that the reference refers to, and then accesses the appropriate element of it.&lt;/p&gt;

&lt;h3 id=&#34;identifying-a-referent&#34;&gt;Identifying a referent&lt;/h3&gt;

&lt;p&gt;Because a scalar variable can store a reference to any kind of data, and because dereferencing a reference with the wrong prefix leads to fatal errors, it&amp;rsquo;s sometimes important to be able to determine what type of referent a specific reference refers to. Perl provides a built-in function called ref that takes a scalar and returns a description of the kind of reference it contains. Table 1 summarizes the string that is returned for each type of reference.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;If $slr_ref contains&amp;hellip;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;then ref($slr_ref) returns&amp;hellip;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;a scalar value&lt;/td&gt;
&lt;td&gt;undef&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;a reference to a scalar&lt;/td&gt;
&lt;td&gt;&amp;ldquo;SCALAR&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;a reference to an array&lt;/td&gt;
&lt;td&gt;&amp;ldquo;ARRAY&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;a reference to a hash&lt;/td&gt;
&lt;td&gt;&amp;ldquo;HASH&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;a reference to a subroutine&lt;/td&gt;
&lt;td&gt;&amp;ldquo;CODE&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;a reference to a filehandle&lt;/td&gt;
&lt;td&gt;&amp;ldquo;IO&amp;rdquo; or &amp;ldquo;IO::Handle&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;a reference to a typeglob&lt;/td&gt;
&lt;td&gt;&amp;ldquo;GLOB&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;a reference to a precompiled pattern&lt;/td&gt;
&lt;td&gt;&amp;ldquo;Regexp&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;a reference to another reference&lt;/td&gt;
&lt;td&gt;&amp;ldquo;REF&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Table 1: What ref returns&lt;/strong&gt;
As Table 1 indicates, you can create references to many kinds of Perl constructs, apart from variables.&lt;/p&gt;

&lt;p&gt;If a reference is used in a context where a string is expected, then the ref function is called automatically to produce the expected string, and a unique hexadecimal value (the internal memory address of the thing being referred to) is appended. That means that printing out a reference:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print $hsh_ref, &amp;quot;\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;produces something like:
    HASH(0x10027588)&lt;/p&gt;

&lt;p&gt;since each element of print&amp;rsquo;s argument list is stringified before printing.
The ref function has a vital additional role in object-oriented Perl, where it can be used to identify the class to which a particular object belongs. More on that in a moment.&lt;/p&gt;

&lt;h3 id=&#34;references-referents-and-objects&#34;&gt;References, referents, and objects&lt;/h3&gt;

&lt;p&gt;References and referents matter because they&amp;rsquo;re both required when you come to build objects in Perl. In fact, Perl objects are just referents (i.e. variables or values) that have a special relationship with a particular package. References come into the picture because Perl objects are always accessed via a reference, using an extension of the &amp;ldquo;arrow&amp;rdquo; notation.&lt;/p&gt;

&lt;p&gt;But that doesn&amp;rsquo;t mean that Perl&amp;rsquo;s object-oriented features are difficult to use (even if you&amp;rsquo;re still unsure of references and referents). To do real, useful, production-strength, object-oriented programming in Perl you only need to learn about one extra function, one straightforward piece of additional syntax, and three very simple rules. Let&amp;rsquo;s start with the rules&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;rule-1-to-create-a-class-build-a-package&#34;&gt;Rule 1: To create a class, build a package&lt;/h3&gt;

&lt;p&gt;Perl packages already have a number of class-like features:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;They collect related code together;&lt;/li&gt;
&lt;li&gt;They distinguish that code from unrelated code;&lt;/li&gt;
&lt;li&gt;They provide a separate namespace within the program, which keeps subroutine names from clashing with those in other packages;&lt;/li&gt;
&lt;li&gt;They have a name, which can be used to identify data and subroutines defined in the package.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In Perl, those features are sufficient to allow a package to act like a class.
Suppose you wanted to build an application to track faults in a system. Here&amp;rsquo;s how to declare a class named &amp;ldquo;Bug&amp;rdquo; in Perl:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package Bug;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it! In Perl, classes are packages. No magic, no extra syntax, just plain, ordinary packages. Of course, a class like the one declared above isn&amp;rsquo;t very interesting or useful, since its objects will have no attributes or behaviour.
That brings us to the second rule&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;rule-2-to-create-a-method-write-a-subroutine&#34;&gt;Rule 2: To create a method, write a subroutine&lt;/h3&gt;

&lt;p&gt;In object-oriented theory, methods are just subroutines that are associated with a particular class and exist specifically to operate on objects that are instances of that class. In Perl, a subroutine that is declared in a particular package &lt;em&gt;is already&lt;/em&gt; associated with that package. So to write a Perl method, you just write a subroutine within the package that is acting as your class.&lt;/p&gt;

&lt;p&gt;For example, here&amp;rsquo;s how to provide an object method to print Bug objects:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package Bug;

sub print_me
{
       # The code needed to print the Bug goes here
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, that&amp;rsquo;s it. The subroutine print_me is now associated with the package Bug, so whenever Bug is used as a class, Perl automatically treats Bug::print_me as a method.
Invoking the Bug::print_me method involves that one extra piece of syntax mentioned above—an extension to the existing Perl &amp;ldquo;arrow&amp;rdquo; notation. If you have a reference to an object of class Bug, you can access any method of that object by using a -&amp;gt; symbol, followed by the name of the method.&lt;/p&gt;

&lt;p&gt;For example, if the variable $nextbug holds a reference to a Bug object, you could call Bug::print_me on that object by writing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$nextbug-&amp;gt;print_me();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Calling a method through an arrow should be very familiar to any C++ programmers; for the rest of us, it&amp;rsquo;s at least consistent with other Perl usages:
    $hsh_ref-&amp;gt;{&amp;ldquo;key&amp;rdquo;};           # Access the hash referred to by $hashref
    $arr_ref-&amp;gt;[$index];          # Access the array referred to by $arrayref
    $sub_ref-&amp;gt;(@args);           # Access the sub referred to by $subref
    $obj_ref-&amp;gt;method(@args);     # Access the object referred to by $objref&lt;/p&gt;

&lt;p&gt;The only difference with the last case is that the referent (i.e. the object) pointed to by $objref has many ways of being accessed (namely, its various methods). So, when you want to access that object, you have to specify which particular way—which method—should be used. Hence, the method name after the arrow.
When a method like Bug::print_me is called, the argument list that it receives begins with the reference through which it was called, followed by any arguments that were explicitly given to the method. That means that calling Bug::print_me(&amp;ldquo;logfile&amp;rdquo;) is &lt;em&gt;not&lt;/em&gt; the same as calling $nextbug-&amp;gt;print_me(&amp;ldquo;logfile&amp;rdquo;). In the first case, print_me is treated as a regular subroutine so the argument list passed to Bug::print_me is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;( &amp;quot;logfile&amp;quot; )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the second case, print_me is treated as a method so the argument list is equivalent to:
    ( $objref, &amp;ldquo;logfile&amp;rdquo; )&lt;/p&gt;

&lt;p&gt;Having a reference to the object passed as the first parameter is vital, because it means that the method then has access to the object on which it&amp;rsquo;s supposed to operate. Hence you&amp;rsquo;ll find that most methods in Perl start with something equivalent to this:
    package Bug;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub print_me
{
    my ($self) = shift;
    # The @_ array now stores the arguments passed to &amp;amp;Bug::print_me
    # The rest of &amp;amp;print_me uses the data referred to by $self 
    # and the explicit arguments (still in @_)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or, better still:
    package Bug;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub print_me
{
    my ($self, @args) = @_;
    # The @args array now stores the arguments passed to &amp;amp;Bug::print_me
    # The rest of &amp;amp;print_me uses the data referred to by $self
    # and the explicit arguments (now in @args)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This second version is better because it provides a lexically scoped copy of the argument list (@args). Remember that the @_ array is &amp;ldquo;magical&amp;rdquo;—changing any element of it actually changes the &lt;em&gt;caller&amp;rsquo;s&lt;/em&gt; version of the corresponding argument. Copying argument values to a lexical array like @args prevents nasty surprises of this kind, as well as improving the internal documentation of the subroutine (especially if a more meaningful name than @args is chosen).
The only remaining question is: &lt;em&gt;how do you create the invoking object in the first place?&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;rule-3-to-create-an-object-bless-a-referent&#34;&gt;Rule 3: To create an object, bless a referent&lt;/h3&gt;

&lt;p&gt;Unlike other object-oriented languages, Perl doesn&amp;rsquo;t require that an object be a special kind of record-like data structure. In fact, you can use &lt;em&gt;any&lt;/em&gt; existing type of Perl variable—a scalar, an array, a hash, etc.—as an object in Perl.&lt;/p&gt;

&lt;p&gt;Hence, the issue isn&amp;rsquo;t how to &lt;em&gt;create&lt;/em&gt; the object, because you create them exactly like any other Perl variable: declare them with a my, or generate them anonymously with a [&amp;hellip;] or {&amp;hellip;}. The real problem is how to tell Perl that such an object &lt;em&gt;belongs&lt;/em&gt; to a particular class. That brings us to the one extra built-in Perl function you need to know about. It&amp;rsquo;s called bless, and its only job is to mark a variable as belonging to a particular class.&lt;/p&gt;

&lt;p&gt;The bless function takes two arguments: a reference to the variable to be marked, and a string containing the name of the class. It then sets an internal flag on the variable, indicating that it now belongs to the class.&lt;/p&gt;

&lt;p&gt;For example, suppose that $nextbug actually stores a reference to an anonymous hash:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$nextbug = {
                id    =&amp;gt; &amp;quot;00001&amp;quot;,
                type  =&amp;gt; &amp;quot;fatal&amp;quot;,
                descr =&amp;gt; &amp;quot;application does not compile&amp;quot;,
           };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To turn that anonymous hash into an object of class Bug you write:
    bless $nextbug, &amp;ldquo;Bug&amp;rdquo;;&lt;/p&gt;

&lt;p&gt;And, once again, that&amp;rsquo;s it! The anonymous array referred to by $nextbug is now marked as being an object of class Bug. Note that the variable $nextbug itself hasn&amp;rsquo;t been altered in any way; only the nameless hash it refers to has been marked. In other words, bless sanctified the referent, &lt;em&gt;not&lt;/em&gt; the reference. Figure 3 illustrates where the new class membership flag is set.
You can check that the blessing succeeded by applying the built-in ref function to $nextbug. As explained above, when ref is applied to a reference, it normally returns the type of that reference. Hence, before $nextbug was blessed, ref($nextbug) would have returned the string &amp;lsquo;HASH&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;Once an object is blessed, ref returns the name of its class instead. So after the blessing, ref($nextbug) will return &amp;lsquo;Bug&amp;rsquo;. Of course the object itself still &lt;em&gt;is&lt;/em&gt; a hash, but now it&amp;rsquo;s a hash that &lt;em&gt;belongs&lt;/em&gt; to the Bug class. The various entries of the hash become the attributes of the newly created Bug object.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_09_refererents/blessing.gif&#34; alt=&#34;[A picture of an anonymous hash having a flag set within it]&#34; width=&#34;450&#34; height=&#34;412&#34; /&gt;
&lt;strong&gt;Figure 3: What changes when an object is blessed&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;creating-a-constructor&#34;&gt;Creating a constructor&lt;/h3&gt;

&lt;p&gt;Given that you&amp;rsquo;re likely to want to create many such Bug objects, it would be convenient to have a subroutine that took care of all the messy, blessy details. You could pass it the necessary information, and it would then wrap it in an anonymous hash, bless the hash, and give you back a reference to the resulting object.&lt;/p&gt;

&lt;p&gt;And, of course, you might as well put such a subroutine in the Bug package itself, and call it something that indicates its role. Such a subroutine is known as a &lt;em&gt;constructor,&lt;/em&gt; and it generally looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package Bug;
sub new
{
    my $class = $_[0];
    my $objref = {
                     id    =&amp;gt; $_[1],
                     type  =&amp;gt; $_[2],
                     descr =&amp;gt; $_[3],
                 };
    bless $objref, $class;
    return $objref;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the middle bits of the subroutine (in bold) look just like the raw blessing that was handed out to $nextbug in the previous example.
The bless function is set up to make writing constructors like this a little easier. Specifically, it returns the reference that&amp;rsquo;s passed as its first argument (i.e. the reference to whatever referent it just blessed into object-hood). And since Perl subroutines automatically return the value of their last evaluated statement, that means that you could condense the definition of Bug::new to this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub Bug::new
{
        bless { id =&amp;gt; $_[1], type =&amp;gt; $_[2], descr =&amp;gt; $_[3] }, $_[0];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This version has exactly the same effects: slot the data into an anonymous hash, bless the hash into the class specified first argument, and return a reference to the hash.
Regardless of which version you use, now whenever you want to create a new Bug object, you can just call:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$nextbug = Bug::new(&amp;quot;Bug&amp;quot;, $id, $type, $description);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s a little redundant, since you have to type &amp;ldquo;Bug&amp;rdquo; twice. Fortunately, there&amp;rsquo;s another feature of the &amp;ldquo;arrow&amp;rdquo; method-call syntax that solves this problem. If the operand to the left of the arrow is the name of a class —rather than an object reference—then the appropriate method of that class is called. More importantly, if the arrow notation is used, the first argument passed to the method is a string containing the class name. That means that you could rewrite the previous call to Bug::new like this:
    $nextbug = Bug-&amp;gt;new($id, $type, $description);&lt;/p&gt;

&lt;p&gt;There are other benefits to this notation when your class uses inheritance, so you should always call constructors and other class methods this way.&lt;/p&gt;

&lt;h3 id=&#34;method-enacting&#34;&gt;Method enacting&lt;/h3&gt;

&lt;p&gt;Apart from encapsulating the gory details of object creation within the class itself, using a class method like this to create objects has another big advantage. If you abide by the convention of only ever creating new Bug objects by calling Bug::new, you&amp;rsquo;re guaranteed that all such objects will always be hashes. Of course, there&amp;rsquo;s nothing to prevent us from &amp;ldquo;manually&amp;rdquo; blessing arrays, or scalars as Bug objects, but it turns out to make life &lt;em&gt;much&lt;/em&gt; easier if you stick to blessing one type of object into each class.&lt;/p&gt;

&lt;p&gt;For example, if you can be confident that any Bug object is going to be a blessed hash, you can (finally!) fill in the missing code in the Bug::print_me method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package Bug;
sub print_me
{
    my ($self) = @_;
    print &amp;quot;ID: $self-&amp;gt;{id}\n&amp;quot;;
    print &amp;quot;$self-&amp;gt;{descr}\n&amp;quot;;
    print &amp;quot;(Note: problem is fatal)\n&amp;quot; if $self-&amp;gt;{type} eq &amp;quot;fatal&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, whenever the print_me method is called via a reference to any hash that&amp;rsquo;s been blessed into the Bug class, the $self variable extracts the reference that was passed as the first argument and then the print statements access the various entries of the blessed hash.&lt;/p&gt;

&lt;h3 id=&#34;till-death-us-do-part&#34;&gt;Till death us do part&amp;hellip;&lt;/h3&gt;

&lt;p&gt;Objects sometimes require special attention at the other end of their lifespan too. Most object-oriented languages provide the ability to specify a subroutine that is called automatically when an object ceases to exist. Such subroutines are usually called &lt;em&gt;destructors&lt;/em&gt;, and are used to undo any side-effects caused by the previous existence of an object. That may include:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;deallocating related memory (although in Perl that&amp;rsquo;s almost never necessary since reference counting usually takes care of it for you);&lt;/li&gt;
&lt;li&gt;closing file or directory handles stored in the object;&lt;/li&gt;
&lt;li&gt;closing pipes to other processes;&lt;/li&gt;
&lt;li&gt;closing databases used by the object;&lt;/li&gt;
&lt;li&gt;updating class-wide information;&lt;/li&gt;
&lt;li&gt;anything else that the object should do before it ceases to exist (such as logging the fact of its own demise, or storing its data away to provide persistence, etc.)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;In Perl, you can set up a destructor for a class by defining a subroutine named DESTROY in the class&amp;rsquo;s package. Any such subroutine is automatically called on an object of that class, just before that object&amp;rsquo;s memory is reclaimed. Typically, this happens when the last variable holding a reference to the object goes out of scope, or has another value assigned to it.
For example, you could provide a destructor for the Bug class like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package Bug;

# other stuff as before

sub DESTROY
{
        my ($self) = @_;
        print &amp;quot;&amp;lt;&amp;lt; Squashed the bug: $self-&amp;gt;{id} &amp;gt;&amp;gt;\n\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, every time an object of class Bug is about to cease to exist, that object will automatically have its DESTROY method called, which will print an epitaph for the object. For example, the following code:
    package main;
    use Bug;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open BUGDATA, &amp;quot;Bug.dat&amp;quot; or die &amp;quot;Couldn&#39;t find Bug data&amp;quot;;

while (&amp;lt;BUGDATA&amp;gt;)
{
    my @data = split &#39;,&#39;, $_;       # extract comma-separated Bug data
    my $bug = Bug-&amp;gt;new(@data);      # create a new Bug object
    $bug-&amp;gt;print_me();               # print it out
} 

print &amp;quot;(end of list)\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;prints out something like this:
    ID: HW000761
    &amp;ldquo;Cup holder&amp;rdquo; broken
    Note: problem is fatal
    &amp;lt;&amp;lt; Squashed the bug HW000761 &amp;gt;&amp;gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ID: SW000214
Word processor trashing disk after 20 saves.
&amp;lt;&amp;lt; Squashed the bug SW000214 &amp;gt;&amp;gt; 

ID: OS000633
Can&#39;t change background colour (blue) on blue screen of death.
&amp;lt;&amp;lt; Squashed the bug OS000633 &amp;gt;&amp;gt; 

(end of list)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s because, at the end of each iteration of the while loop, the lexical variable $bug goes out of scope, taking with it the only reference to the Bug object created earlier in the same loop. That object&amp;rsquo;s reference count immediately becomes zero and, because it was blessed, the corresponding DESTROY method (i.e. Bug::DESTROY) is automatically called on the object.&lt;/p&gt;

&lt;h3 id=&#34;where-to-from-here&#34;&gt;Where to from here?&lt;/h3&gt;

&lt;p&gt;Of course, these fundamental techniques only scratch the surface of object-oriented programming in Perl. Simple hash-based classes with methods, constructors, and destructors may be enough to let you solve real problems in Perl, but there&amp;rsquo;s a vast array of powerful and labor-saving techniques you can add to those basic components: autoloaded methods, class methods and class attributes, inheritance and multiple inheritance, polymorphism, multiple dispatch, enforced encapsulation, operator overloading, tied objects, genericity, and persistence.&lt;/p&gt;

&lt;p&gt;Perl&amp;rsquo;s standard documentation includes plenty of good material—&lt;em&gt;perlref&lt;/em&gt;, &lt;em&gt;perlreftut&lt;/em&gt;, &lt;em&gt;perlobj&lt;/em&gt;, &lt;em&gt;perltoot&lt;/em&gt;, &lt;em&gt;perltootc&lt;/em&gt;, and &lt;em&gt;perlbot&lt;/em&gt; to get you started. But if you&amp;rsquo;re looking for a comprehensive tutorial on everything you need to know, you may also like to consider my new book, &lt;em&gt;&lt;a href=&#34;http://www.manning.com/conway/&#34;&gt;Object Oriented Perl&lt;/a&gt;&lt;/em&gt;, from which this article has been adapted.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

