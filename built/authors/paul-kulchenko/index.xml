<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Paul Kulchenko on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/authors/paul-kulchenko/</link>
    <description>Recent content in Paul Kulchenko on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 23 Apr 2001 00:00:00 -0800</lastBuildDate>
    <atom:link href="/authors/paul-kulchenko/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Quick Start Guide with SOAP Part Two</title>
      <link>http://localhost:1313/pub/2001/04/24/soap.html/</link>
      <pubDate>Mon, 23 Apr 2001 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2001/04/24/soap.html/</guid>
      <description>

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Table of Contents&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;•&lt;a href=&#34;http://localhost:1313/pub/2001/01/soap.html&#34;&gt;Quick Start with SOAP Part I&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
•&lt;a href=&#34;#more%20complex%20server%20(daemon,%20mod_perl%20and%20mod_soap)&#34;&gt;More Complex Server (daemon, mod_perl and mod_soap)&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
•&lt;a href=&#34;#access%20to%20remote%20services&#34;&gt;Access to Remote Services&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
•&lt;a href=&#34;#access%20with%20service%20description%20(wsdl)&#34;&gt;Access With Service Description (WSDL)&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
•&lt;a href=&#34;#security%20(ssl,%20basic/digest%20authentication,%20cookiebased%20authentication,%20ticketbased%20authentication,%20access%20control)&#34;&gt;Security (SSL, basic/digest authentication, cookie-based authentication, ticket-based authentication, access control)&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
•&lt;a href=&#34;#handling%20lols%20(list%20of%20lists,%20structs,%20objects,%20or%20something%20else)&#34;&gt;Handling LoLs (List of Lists, Structs, Objects, or something else)&lt;/a&gt;&lt;br /&gt;
&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;span-id-more-complex-server-daemon-mod-perl-and-mod-soap-more-complex-server-daemon-mod-perl-and-mod-soap-span&#34;&gt;&lt;span id=&#34;more complex server (daemon, mod_perl and mod_soap)&#34;&gt;More Complex Server (daemon, mod_perl and mod_soap)&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;You shouldn&amp;rsquo;t have many problems with the CGI-based SOAP server you created in the &lt;a href=&#34;http://localhost:1313/pub/2001/01/soap.html&#34;&gt;first part of this article&lt;/a&gt;; however, performance could be significantly better. The next logical step might be to implement SOAP services using accelerators (like PerlEx or VelociGen) or persistent technologies (like mod_perl). Another lightweight solution might be to implement the SOAP service as an HTTP daemon; in that case, you don&amp;rsquo;t need to use a separate Web server. This might be useful in a situation where a client application accepts SOAP calls, or for internal usage.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_HTTP_daemon&#34;&gt;HTTP daemon&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The following code shows an example implementation for a HTTP daemon:&lt;/p&gt;

&lt;p&gt;4.a. server (HTTP daemon)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; #!perl -w

  use SOAP::Transport::HTTP;

  use Demo;

  # don&#39;t want to die on &#39;Broken pipe&#39; or Ctrl-C
  $SIG{PIPE} = $SIG{INT} = &#39;IGNORE&#39;;

  $daemon = SOAP::Transport::HTTP::Daemon
    -&amp;gt; new (LocalPort =&amp;gt; 80)
    -&amp;gt; dispatch_to(&#39;/home/soaplite/modules&#39;)
  ;

  print &amp;quot;Contact to SOAP server at &amp;quot;, $daemon-&amp;gt;url, &amp;quot;\n&amp;quot;;
  $daemon-&amp;gt;handle;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Quick Start with SOAP</title>
      <link>http://localhost:1313/pub/2001/01/soap.html/</link>
      <pubDate>Mon, 29 Jan 2001 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2001/01/soap.html/</guid>
      <description>

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Table of Contents&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;•&lt;a href=&#34;#quick%20start%20with%20soap&#34;&gt;Quick Start with SOAP&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#writing%20a%20cgibased%20server&#34;&gt;Writing a CGI-based Server&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#client&#34;&gt;Client&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#passing%20values&#34;&gt;Passing Values&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#autodispatching&#34;&gt;Autodispatching&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#objects%20access&#34;&gt;Objects access&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#error%20handling&#34;&gt;Error handling&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#service%20dispatch%20(different%20services%20on%20one%20server)&#34;&gt;Service dispatch (different services on one server)&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#types%20and%20names&#34;&gt;Types and Names&lt;/a&gt;&lt;br /&gt;
•&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2001/04/24/soap.html&#34;&gt;Part 2 of this series&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;SOAP (Simple Object Access Protocol) is a way for you to remotely make method calls upon classes and objects that exist on a remote server. It&amp;rsquo;s the latest in a long series of similar projects like CORBA, DCOM, and XML-RPC.&lt;/p&gt;

&lt;p&gt;SOAP specifies a standard way to encode parameters and return values in XML, and standard ways to pass them over some common network protocols like HTTP (web) and SMTP (email). This article, however, is merely intended as a quick guide to writing SOAP servers and clients. We will hardly scratch the surface of what&amp;rsquo;s possible.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll be using the &lt;strong&gt;SOAP::Lite&lt;/strong&gt; module from CPAN. Don&amp;rsquo;t be mislead by the &amp;ldquo;Lite&amp;rdquo; suffix&amp;ndash;this refers to the effort it takes to use the module, not its capabilities.&lt;/p&gt;

&lt;h3 id=&#34;span-id-writing-a-cgibased-server-writing-a-cgi-based-server-span&#34;&gt;&lt;span id=&#34;writing a cgibased server&#34;&gt;Writing a CGI-based Server&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2001_01_soap/SOAP-Lite-guide.tar.gz&#34;&gt;Download source files mentioned in this article here.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a simple CGI-based SOAP server (hibye.cgi):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; #!perl -w

  use SOAP::Transport::HTTP;

  SOAP::Transport::HTTP::CGI   
    -&amp;gt; dispatch_to(&#39;Demo&#39;)     
    -&amp;gt; handle;

  package Demo;

  sub hi {                     
    return &amp;quot;hello, world&amp;quot;;     
  }

  sub bye {                    
    return &amp;quot;goodbye, cruel world&amp;quot;;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;hr /&gt;
&lt;br /&gt;
&lt;strong&gt;&lt;/strong&gt;
&lt;p&gt;Paul Kulchenko is a featured speaker at the upcoming O&#39;Reilly Open Source Convention in San Diego, CA, July 23 - 27, 2001. Take this opportunity to rub elbows with open source leaders while relaxing in the beautiful setting of the beach-front Sheraton San Diego Hotel and Marina. For more information, visit our &lt;a href=&#34;http://conferences.oreilly.com/oscon/&#34;&gt;conference home page&lt;/a&gt;. You can register online.&lt;/p&gt;
&lt;hr /&gt;
&lt;br /&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;There are basically two parts to this: the first four lines set up a SOAP wrapper around a class. Everything from &amp;lsquo;package Demo&amp;rsquo; onward is the class being wrapped.&lt;/p&gt;

&lt;p&gt;In the previous version of specification (1.0), SOAP over HTTP was supposed to use a new HTTP method, M-POST. Now it&amp;rsquo;s common to try a normal POST first, and then use M-POST if the server needs it. If you don&amp;rsquo;t understand the difference between POST and M-POST, don&amp;rsquo;t worry, you don&amp;rsquo;t need to know all the specific details to be able to use the module.&lt;/p&gt;

&lt;h3 id=&#34;span-id-client-client-span&#34;&gt;&lt;span id=&#34;client&#34;&gt;Client&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;This client prints the results of the &lt;code&gt;hi()&lt;/code&gt; method call (hibye.pl):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; #!perl -w

  use SOAP::Lite;

  print SOAP::Lite                                             
    -&amp;gt; uri(&#39;http://www.soaplite.com/Demo&#39;)                                             
    -&amp;gt; proxy(&#39;http://services.soaplite.com/hibye.cgi&#39;)
    -&amp;gt; hi()                                                    
    -&amp;gt; result;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;a href=&#34;#item_uri&#34;&gt;&lt;code&gt;uri()&lt;/code&gt;&lt;/a&gt; identifies the class to the server, and the &lt;a href=&#34;#item_proxy&#34;&gt;&lt;code&gt;proxy()&lt;/code&gt;&lt;/a&gt; identifies the location of the server itself. Since both look like URLs, I&amp;rsquo;ll take a minute to explain the difference, as it&amp;rsquo;s &lt;strong&gt;quite important&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_proxy&#34;&gt;&lt;code&gt;proxy()&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;#item_proxy&#34;&gt;&lt;code&gt;proxy()&lt;/code&gt;&lt;/a&gt; is simply the address of the server to contact that provides the methods. You can use http:, mailto:, even ftp: URLs here.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_uri&#34;&gt;&lt;code&gt;uri()&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Each server can offer many different services through the one proxy() URL. Each service has a unique URI-like identifier, which you specify to SOAP::Lite through the uri() method. If you get caught up in the gripping saga of the SOAP documentation, the &amp;ldquo;namespace&amp;rdquo; corresponds to the uri() method.&lt;/p&gt;

&lt;!-- --&gt;

&lt;p&gt;If you&amp;rsquo;re connected to the Internet, you can run your client, and you should see:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; hello, world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it!&lt;/p&gt;

&lt;p&gt;If your method returns multiple values (hibye.cgi):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; #!perl -w

  use SOAP::Transport::HTTP;

  SOAP::Transport::HTTP::CGI      
    -&amp;gt; dispatch_to(&#39;Demo&#39;)        
    -&amp;gt; handle;

  package Demo;

  sub hi {                        
    return &amp;quot;hello, world&amp;quot;;        
  }

  sub bye {                       
    return &amp;quot;goodbye, cruel world&amp;quot;;
  }

  sub languages {                 
    return (&amp;quot;Perl&amp;quot;, &amp;quot;C&amp;quot;, &amp;quot;sh&amp;quot;);   
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then the &lt;code&gt;result()&lt;/code&gt; method will only return the first. To access the rest, use the &lt;code&gt;paramsout()&lt;/code&gt; method (hibyeout.pl):&amp;gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; #!perl -w

  use SOAP::Lite;

  $soap_response = SOAP::Lite                                  
    -&amp;gt; uri(&#39;http://www.soaplite.com/Demo&#39;)                                             
    -&amp;gt; proxy(&#39;http://services.soaplite.com/hibye.cgi&#39;)
    -&amp;gt; languages();

  @res = $soap_response-&amp;gt;paramsout;

  $res = $soap_response-&amp;gt;result;                               
  print &amp;quot;Result is $res, outparams are @res\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code will produce:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; Result is Perl, outparams are Perl C sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-passing-values-passing-values-span&#34;&gt;&lt;span id=&#34;passing values&#34;&gt;Passing Values&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Methods can take arguments. Here&amp;rsquo;s a SOAP server that translates between Fahrenheit and Celsius (temper.cgi):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; #!perl -w

  use SOAP::Transport::HTTP;

  SOAP::Transport::HTTP::CGI
    -&amp;gt; dispatch_to(&#39;Temperatures&#39;)
    -&amp;gt; handle;

  package Temperatures;

  sub f2c {
      my ($class, $f) = @_;
      return 5 / 9 * ($f - 32);
  }

  sub c2f {
      my ($class, $c) = @_;
      return 32 + $c * 9 / 5;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here&amp;rsquo;s a sample query (temp.pl):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; #!perl -w

  use SOAP::Lite;

  print SOAP::Lite                                            
    -&amp;gt; uri(&#39;http://www.soaplite.com/Temperatures&#39;)                                    
    -&amp;gt; proxy(&#39;http://services.soaplite.com/temper.cgi&#39;)
    -&amp;gt; c2f(37.5)                                              
    -&amp;gt; result;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also create an object representing the remote class, and then make method calls on it (tempmod.pl):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; #!perl -w

  use SOAP::Lite;

  my $soap = SOAP::Lite                                        
    -&amp;gt; uri(&#39;http://www.soaplite.com/Temperatures&#39;)                                     
    -&amp;gt; proxy(&#39;http://services.soaplite.com/temper.cgi&#39;);

  print $soap                                                  
    -&amp;gt; c2f(37.5)                                               
    -&amp;gt; result;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-autodispatching-autodispatching-span&#34;&gt;&lt;span id=&#34;autodispatching&#34;&gt;Autodispatching&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;This being Perl, there&amp;rsquo;s more than one way to do it: SOAP::Lite provides an alternative client syntax (tempauto.pl).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; #!perl -w

  use SOAP::Lite +autodispatch =&amp;gt;

    uri =&amp;gt; &#39;http://www.soaplite.com/Temperatures&#39;,
    proxy =&amp;gt; &#39;http://services.soaplite.com/temper.cgi&#39;;

  print c2f(37.5);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After you specify the uri and proxy parameters, you are able to call remote functions with the same syntax as local ones (e.g., c2f). This is done with UNIVERSAL::AUTOLOAD, which catches all unknown method calls. Be warned that &lt;strong&gt;all&lt;/strong&gt; calls to undefined methods will result in an attempt to use SOAP.&lt;/p&gt;

&lt;h3 id=&#34;span-id-objects-access-objects-access-it-s-simple-object-access-protocol-isn-t-it-span&#34;&gt;&lt;span id=&#34;objects access&#34;&gt;Objects access (it&amp;rsquo;s &amp;lsquo;Simple &lt;strong&gt;Object&lt;/strong&gt; access protocol&amp;rsquo;, isn&amp;rsquo;t it?)&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Methods can also return real objects. Let&amp;rsquo;s extend our &lt;code&gt;Temperatures&lt;/code&gt; class with an object-oriented interface (temper.cgi):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; #!perl -w

  use SOAP::Transport::HTTP;

  SOAP::Transport::HTTP::CGI
    -&amp;gt; dispatch_to(&#39;Temperatures&#39;)
    -&amp;gt; handle;

  package Temperatures;

  sub f2c {
      my ($class, $f) = @_;
      return 5/9*($f-32);
  }

  sub c2f {
      my ($class, $c) = @_;
      return 32+$c*9/5;
  }

  sub new {
      my $self = shift;
      my $class = ref($self) || $self;
      bless {_temperature =&amp;gt; shift} =&amp;gt; $class;
  }

  sub as_fahrenheit {
      return shift-&amp;gt;{_temperature};
  }

  sub as_celsius {
      my $self = shift;
      return $self-&amp;gt;f2c( $self-&amp;gt;{_temperature} );
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is a client that accesses this class (tempobj.pl):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; #!perl -w

  use SOAP::Lite;

  my $soap = SOAP::Lite
    -&amp;gt; uri(&#39;http://www.soaplite.com/Temperatures&#39;)
    -&amp;gt; proxy(&#39;http://services.soaplite.com/temper.cgi&#39;);

  my $temperatures = $soap
    -&amp;gt; call(new =&amp;gt; 100) # accept Fahrenheit  
    -&amp;gt; result;

  print $soap
    -&amp;gt; as_celsius($temperatures)
    -&amp;gt; result;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Similar code with autodispatch is shorter and easier to read (tempobja.pl):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; #!perl -w

  use SOAP::Lite +autodispatch =&amp;gt;
    uri =&amp;gt; &#39;http://www.soaplite.com/Temperatures&#39;,
    proxy =&amp;gt; &#39;http://services.soaplite.com/temper.cgi&#39;;

  my $temperatures = Temperatures-&amp;gt;new(100);
  print $temperatures-&amp;gt;as_fahrenheit();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-error-handling-error-handling-span&#34;&gt;&lt;span id=&#34;error handling&#34;&gt;Error handling&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;A SOAP call may fail for numerous reasons, such as transport error, incorrect parameters, or an error on the server. Transport errors (which may occur if, for example, there is a network break between the client and the server) are dealt with below. All other errors are indicated by the &lt;code&gt;fault()&lt;/code&gt; method (temperr.pl):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; #!perl -w

  use SOAP::Lite;

  my $soap = SOAP::Lite
    -&amp;gt; uri(&#39;http://www.soaplite.com/Temperatures&#39;)
    -&amp;gt; proxy(&#39;http://services.soaplite.com/temper.cgi&#39;);

 my $result = $soap-&amp;gt;c2f(37.5);

  unless ($result-&amp;gt;fault) {
    print $result-&amp;gt;result();
  } else {
    print join &#39;, &#39;, 
      $result-&amp;gt;faultcode, 
      $result-&amp;gt;faultstring, 
      $result-&amp;gt;faultdetail;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;faultcode()&lt;/code&gt; gives you information about the main reason for the error. Possible values may be:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_client%3a_you_provided_incorrect_information_in_th&#34;&gt;Client: you provided incorrect information in the request.&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This error may occur when parameters for the remote call are incorrect. Parameters may be out-of-bounds, such as negative numbers, when positive integers are expected; or of an incorrect type, for example, a string is provided where a number was expected.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_server%3a_something_is_wrong_on_the_server_side%2e&#34;&gt;Server: something is wrong on the server side.&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This means that provided information is correct, but the server couldn&amp;rsquo;t handle the request because of temporary difficulties, for example, an unavailable database.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_mustunderstand%3a_header_elements_has_mustundersta&#34;&gt;MustUnderstand: Header elements has mustUnderstand attribute, but wasn&amp;rsquo;t understood by server.&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The server was able to parse the request, but the client is requesting functionality that can&amp;rsquo;t be provided. For example, suppose that a request requires execution of SQL statement, and the client wants to be sure that several requests will be executed in one database transaction. This could be implemented as three different calls with one common TransactionID.&lt;/p&gt;

&lt;p&gt;In this case, the SOAP header may be extended with a new header element called, say, &amp;lsquo;TransactionID&amp;rsquo;, which carries a common identifier across the 3 separate invocations. However, if server does not understand the provided TransactionID header, it probably won&amp;rsquo;t be able to maintain transactional integrity across invocations. To guard against this, the client may indicate that the server &amp;lsquo;mustUnderstand&amp;rsquo; the element &amp;lsquo;TransactionID&amp;rsquo;. If the server sees this and does NOT understand the meaning of the element, it will not try and process the requests in the first place.&lt;/p&gt;

&lt;p&gt;This functionality makes services more reliable and distributed systems more robust.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_versionmismatch%3a_the_server_can%27t_understand_t&#34;&gt;VersionMismatch: the server can&amp;rsquo;t understand the version of SOAP used by the client.&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This is provided for (possible) future extensions, when new versions of SOAP may have different functionality, and only clients that are knowledgeable about it will be able to properly use it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_other_errors&#34;&gt;Other errors&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The server is allowed to create its own errors, like &lt;strong&gt;Client.Authentication&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;faultstring()&lt;/code&gt; provides a readable explanation, whereas &lt;code&gt;faultdetail()&lt;/code&gt; gives access to more detailed information, which may be a string, object, or more complex structure.&lt;/p&gt;

&lt;p&gt;For example, if you change &lt;strong&gt;uri&lt;/strong&gt; to something else (let&amp;rsquo;s try with &lt;code&gt;&#39;Test&#39;&lt;/code&gt; instead of &lt;code&gt;&#39;Temperatures&#39;&lt;/code&gt;), this code will generate:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; Client, Bad Class Name, Failed to access class (Test)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By default client will &lt;strong&gt;die with diagnostic&lt;/strong&gt; on &lt;em&gt;transport errors&lt;/em&gt; and &lt;strong&gt;do nothing&lt;/strong&gt; for &lt;em&gt;faulted calls&lt;/em&gt;, so, you&amp;rsquo;ll be able to get fault info from result. You can alter this behavior with &lt;code&gt;on_fault()&lt;/code&gt; handler either per object, so it will die on both transport errors and SOAP faults (temperrh.pl):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; #!perl -w

  use SOAP::Lite;

  my $soap = SOAP::Lite
    -&amp;gt; uri(&#39;http://www.soaplite.com/Temperatures&#39;)
    -&amp;gt; proxy(&#39;http://services.soaplite.com/temper.cgi&#39;)

    -&amp;gt; on_fault(sub { my($soap, $res) = @_; 
         die ref $res ? $res-&amp;gt;faultdetail : $soap-&amp;gt;transport-&amp;gt;status, &amp;quot;\n&amp;quot;;
       });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or you can set it globally (temperrg.pl):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; #!perl -w

  use SOAP::Lite

    on_fault =&amp;gt; sub { my($soap, $res) = @_; 
      die ref $res ? $res-&amp;gt;faultdetail : $soap-&amp;gt;transport-&amp;gt;status, &amp;quot;\n&amp;quot;;
    };

  my $soap = SOAP::Lite
    -&amp;gt; uri(&#39;http://www.soaplite.com/Temperatures&#39;)
    -&amp;gt; proxy(&#39;http://services.soaplite.com/temper.cgi&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, wrap your SOAP call into an &lt;code&gt;eval {}&lt;/code&gt; block, and catch both transport errors and SOAP faults (temperrg.pl):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; #!perl -w

  use SOAP::Lite

    on_fault =&amp;gt; sub { my($soap, $res) = @_; 
      die ref $res ? $res-&amp;gt;faultdetail : $soap-&amp;gt;transport-&amp;gt;status, &amp;quot;\n&amp;quot;;
    };

  my $soap = SOAP::Lite
    -&amp;gt; uri(&#39;http://www.soaplite.com/Temperatures&#39;)
    -&amp;gt; proxy(&#39;http://services.soaplite.com/temper.cgi&#39;);

  eval { 
    print $soap-&amp;gt;c2f(37.5)-&amp;gt;result; 
  1 } or die;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may also consider this variant that will return &lt;code&gt;undef&lt;/code&gt; and setup &lt;code&gt;$!&lt;/code&gt; on failure, just like many Perl functions do (temperrv.pl):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; #!perl -w

  use SOAP::Lite
    on_fault =&amp;gt; sub { my($soap, $res) = @_; 
      eval { die ref $res ? $res-&amp;gt;faultdetail : $soap-&amp;gt;transport-&amp;gt;status };
      return ref $res ? $res : new SOAP::SOM;
    };

  my $soap = SOAP::Lite
    -&amp;gt; uri(&#39;http://www.soaplite.com/Temperatures&#39;)
    -&amp;gt; proxy(&#39;http://services.soaplite.com/temper.cgi&#39;);

  defined (my $temp = $soap-&amp;gt;c2f(37.5)-&amp;gt;result) or die;

  print $temp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally, if you want to ignore errors (however, you can still check for them with the &lt;code&gt;fault()&lt;/code&gt; method call):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; use SOAP::Lite
    on_fault =&amp;gt; sub {};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; my $soap = SOAP::Lite
    -&amp;gt; on_fault(sub{})
    ..... other parameters
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-service-dispatch-different-services-on-one-server-service-dispatch-different-services-on-one-server-span&#34;&gt;&lt;span id=&#34;service dispatch (different services on one server)&#34;&gt;Service dispatch (different services on one server)&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;So far our CGI programs have had a single class to handle incoming SOAP calls. But we might have one CGI program that dispatches SOAP calls to many classes.&lt;/p&gt;

&lt;p&gt;What exactly is &lt;strong&gt;SOAP dispatch&lt;/strong&gt;? When a SOAP request is recieved by a server, it gets bound to the class specified in the request. The class could be already loaded on server side (on server startup, or as a result of previous calls), or might be loaded on demand, according to server configuration. &lt;strong&gt;Dispatching&lt;/strong&gt; is the process of determining of which class should handle a given request, and loading that class, if necessary. &lt;strong&gt;Static&lt;/strong&gt; dispatch means that name of the class is specified in configuration, whereas &lt;strong&gt;dynamic&lt;/strong&gt; means that only a pool of classes is specified, in, say, a particular directory, and that any class from this directory can be accessed.&lt;/p&gt;

&lt;p&gt;Imagine that you want to give access to two different classes on the server side, and want to provide the same &amp;lsquo;proxy&amp;rsquo; address for both. What should you do? Several options are available:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_static_internal&#34;&gt;Static internal&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&amp;hellip; Which you are already familiar with (hibye.cgi):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use SOAP::Transport::HTTP;

  SOAP::Transport::HTTP::CGI   
    -&amp;gt; dispatch_to(&#39;Demo&#39;)     
    -&amp;gt; handle;

  package Demo;

  sub hi {                     
    return &amp;quot;hello, world&amp;quot;;     
  }

  sub bye {                    
    return &amp;quot;goodbye, cruel world&amp;quot;;
  }

  1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_static_external&#34;&gt;Static external&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Similar to &lt;a href=&#34;#item_Static_internal&#34;&gt;&lt;code&gt;Static    internal&lt;/code&gt;&lt;/a&gt;, but the module is somewhere outside of server code (hibyeout.cgi):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use SOAP::Transport::HTTP;

  use Demo;

  SOAP::Transport::HTTP::CGI   
    -&amp;gt; dispatch_to(&#39;Demo&#39;)     
    -&amp;gt; handle;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following module should, of course, be somewhere in a directory listed in @INC (Demo.pm):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; package Demo;

  sub hi {                     
    return &amp;quot;hello, world&amp;quot;;     
  }

  sub bye {                    
    return &amp;quot;goodbye, cruel world&amp;quot;;
  }

  1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_dynamic&#34;&gt;Dynamic&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;As you can see in both &lt;a href=&#34;#item_Static_internal&#34;&gt;&lt;code&gt;Static    internal&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;#item_Static_external&#34;&gt;&lt;code&gt;Static    external&lt;/code&gt;&lt;/a&gt; modes, the module name is hardcoded in the server code. But what if you want to be able to add new modules dynamically without altering the server? Dynamic dispatch allows you to do it. Specify a directory, and any module in this directory becomes available for dispatching (hibyedyn.cgi):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; #!perl -w

  use SOAP::Transport::HTTP;

  SOAP::Transport::HTTP::CGI

    -&amp;gt; dispatch_to(&#39;/home/soaplite/modules&#39;)

    -&amp;gt; handle;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then put &lt;code&gt;Demo.pm&lt;/code&gt; in &lt;code&gt;/home/soaplite/modules&lt;/code&gt; directory (Demo.pm):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; package Demo;

  sub hi {                     
    return &amp;quot;hello, world&amp;quot;;     
  }

  sub bye {                    
    return &amp;quot;goodbye, cruel world&amp;quot;;
  }

  1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it. &lt;strong&gt;Any&lt;/strong&gt; module you put in &lt;code&gt;/home/soaplite/modules&lt;/code&gt; is available now, but don&amp;rsquo;t forget that the URI specified on the client side should match module/class name you want to dispatch your call to.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_mixed&#34;&gt;Mixed&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;What do we need this for? Unfortunately, dynamic dispatch also has a significant disadvantage: Access to @INC is disabled for the purposes of dynamic dispatch, for security reasons. To work around this, you can combine dynamic and static approaches. All you need to do is this (hibyemix.cgi):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; #!perl -w

  use SOAP::Transport::HTTP;

  SOAP::Transport::HTTP::CGI

    -&amp;gt; dispatch_to(&#39;/home/soaplite/modules&#39;, &#39;Demo&#39;, &#39;Demo1&#39;, &#39;Demo2&#39;)

    -&amp;gt; handle;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now Demo, Demo1, and Demo2 are pre-loaded from anywhere in @INC, but dynamic access is enabled for any modules in &lt;code&gt;/home/soaplite/modules&lt;/code&gt;, and they&amp;rsquo;ll be loaded on demand.&lt;/p&gt;

&lt;h3 id=&#34;span-id-types-and-names-types-and-names-span&#34;&gt;&lt;span id=&#34;types and names&#34;&gt;Types and Names&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;So far as Perl is typeless language (in a sense that there is no difference between integer &lt;code&gt;123&lt;/code&gt; and string &lt;code&gt;&#39;123&#39;&lt;/code&gt;), it greatly simplifies the transformation process from SOAP message to Perl data. For most simple data, we can just ignore typing at this stage. However, this approach has drawbacks also: we need to provide additional information during generation of our SOAP message, because the other server or client may expect type information. SOAP::Lite doesn&amp;rsquo;t force you to type every parameter explicitly, but instead tries to guess each data type based on actual values in question (according to another of Perl&amp;rsquo;s mottos, DWIM, or &amp;lsquo;Do What I Mean&amp;rsquo;).&lt;/p&gt;

&lt;p&gt;For example, a variable that has the value &lt;code&gt;123&lt;/code&gt; becomes an element of type &lt;code&gt;int&lt;/code&gt; in a SOAP message, and a variable that has the value &lt;code&gt;&#39;abc&#39;&lt;/code&gt; becomes type &lt;code&gt;string&lt;/code&gt;. However, there are more complex cases, such as variables that contain binary data, which must be Base64-encoded, or objects (blessed references), as another example, which are given type and name (unless specified) according to their Perl package.&lt;/p&gt;

&lt;p&gt;The autotyping may not work in all cases, though. There is no default way to make an element with type &lt;code&gt;string&lt;/code&gt; or type &lt;code&gt;long&lt;/code&gt; from a value of &lt;code&gt;123&lt;/code&gt;, for example. You may alter this behavior in several ways. First, you may disable autotyping completely (by calling the &lt;code&gt;autotype()&lt;/code&gt; with a value of 0), or change autotyping for different types.&lt;/p&gt;

&lt;p&gt;Alternately, you may use objects from the SOAP::Data class to explicitly specify a type for a particular variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; my $var = SOAP::Data-&amp;gt;type( string =&amp;gt; 123 );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$var&lt;/code&gt; becomes an element with type &lt;code&gt;string&lt;/code&gt; and value &lt;code&gt;123&lt;/code&gt;. You may use this variable in ANY place where you use ordinary Perl variables in SOAP calls. This also allows you to provide not only specific &lt;strong&gt;data types&lt;/strong&gt;, but also specific &lt;strong&gt;name&lt;/strong&gt; and &lt;strong&gt;attributes&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Since many services count on &lt;strong&gt;names&lt;/strong&gt; of parameters (instead of &lt;strong&gt;positions&lt;/strong&gt;) you may specify names for request parameters using the same syntax. To add a name to &lt;code&gt;$var&lt;/code&gt; variable, call &lt;code&gt;$var-&amp;gt;name(&#39;myvar&#39;)&lt;/code&gt;, or even chain calls with the &lt;code&gt;type()&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; my $var = SOAP::Data-&amp;gt;type(string =&amp;gt; 123)-&amp;gt;name(&#39;myvar&#39;);

  # -- OR --
  my $var = SOAP::Data-&amp;gt;type(&#39;string&#39;)-&amp;gt;name(myvar =&amp;gt; 123);

  # -- OR --
  my $var = SOAP::Data-&amp;gt;type(&#39;string&#39;)-&amp;gt;name(&#39;myvar&#39;)-&amp;gt;value(123);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may always get or set the value of a variable with &lt;code&gt;value()&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $var-&amp;gt;value(321);            # set new value

  my $realvalue = $var-&amp;gt;value; # store it in variable
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-conclusion-conclusion-span&#34;&gt;&lt;span id=&#34;conclusion&#34;&gt;Conclusion&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;This should be enough to get you started building SOAP applications. You can read the manpages (or even the source, if you&amp;rsquo;re brave!) to learn more, and don&amp;rsquo;t forget to keep checking &lt;a href=&#34;http://www.soaplite.com/&#34;&gt;www.soaplite.com&lt;/a&gt; for more documentation, examples, and SOAP-y fun.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Part 2 of this article can be found &lt;a href=&#34;http://localhost:1313/pub/2001/04/24/soap.html&#34;&gt;here&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Major contributors:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_nathan_torkington&#34;&gt;Nathan Torkington&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Basically started this work and pushed the whole process.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_tony_hong&#34;&gt;Tony Hong&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Invaluable comments and input help me keep this material fresh and simple.&lt;/p&gt;

&lt;p&gt;This piece continues &lt;a href=&#34;http://localhost:1313/pub/2001/04/24/soap.html&#34;&gt;here&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

