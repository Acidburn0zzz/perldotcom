<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Felipe Gasper on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/authors/felipe-gasper/</link>
    <description>Recent content in Felipe Gasper on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 29 Jan 2020 20:11:44 +0000</lastBuildDate>
    <atom:link href="/authors/felipe-gasper/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>JSON, Unicode, and Perl … Oh My!</title>
      <link>http://localhost:1313/article/json-unicode-and-perl-oh-my-/</link>
      <pubDate>Wed, 29 Jan 2020 20:11:44 +0000</pubDate>
      
      <guid>http://localhost:1313/article/json-unicode-and-perl-oh-my-/</guid>
      <description>

&lt;p&gt;Consider the following code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Mojo::JSON;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Cpanel::JSON::XS;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Data::Dumper;
$Data::Dumper::Useqq &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $e_acute &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\xc3\xa9&amp;#34;&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $json &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Mojo::JSON::encode_json([$e_acute]);
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $decoded &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Cpanel::JSON::XS&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;()&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;decode($json)&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;];
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; Dumper( $json, $decoded );&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You might think this a reasonable enough round-trip, just using two
different JSON libraries, &lt;a href=&#34;https://metacpan.org/pod/Mojo::JSON&#34;&gt;Mojo::JSON&lt;/a&gt;
and &lt;a href=&#34;https://metacpan.org/pod/Cpanel::JSON::XS&#34;&gt;Cpanel::JSON::XS&lt;/a&gt;.
In fact, though, when you run
this you’ll see that $decode in the above is &lt;code&gt;&amp;quot;\x{c3}\x{83}\x{c2}\x{a9}&amp;quot;&lt;/code&gt;,
not just the &lt;code&gt;&amp;quot;\xc3\xa9&amp;quot;&lt;/code&gt; that we started with.&lt;/p&gt;

&lt;p&gt;Now invert the encoder/decoder modules:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Mojo::JSON;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Cpanel::JSON::XS;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Data::Dumper;
$Data::Dumper::Useqq &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $e_acute &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\xc3\xa9&amp;#34;&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $json &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Cpanel::JSON::XS&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;()&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;encode([$e_acute]);
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $decoded &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Mojo::JSON::decode_json($json)&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;];
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; Dumper( $json, $decoded );&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now $decode is just &lt;code&gt;&amp;quot;\x{e9}&amp;quot;&lt;/code&gt;. What’s going on here?&lt;/p&gt;

&lt;h2 id=&#34;what-s-in-a-string&#34;&gt;What’s in a string?&lt;/h2&gt;

&lt;p&gt;To appreciate the above, we first have to grapple with what Perl strings
&lt;em&gt;are&lt;/em&gt;, fundamentally. Unlike C strings, Perl strings aren’t mere arrays
of bytes … but unlike, say, Python 3 strings, Perl strings aren’t arrays of
Unicode characters, either. Perl strings, rather, are arrays of “code
points” in an undefined character set.&lt;/p&gt;

&lt;p&gt;In particular, unlike Python, JavaScript, and many other popular high-level
programming languages, Perl strings do not differentiate between “binary”
and “text”. For example, if Perl reads
bytes 0xff, 0xfe, 0xfd, and 0xfc off of a binary filehandle, the string
that Perl creates from those 4 bytes is understood to contain not 4 &lt;em&gt;bytes&lt;/em&gt;,
but 4 &lt;em&gt;code points&lt;/em&gt;, without reference to any particular character set,
stored in an abstract, internal-use encoding.
(The Perl interpreter may, in fact, use 4 bytes to store the string, but that
would be an implementation detail, of no concern to interpreted Perl code.)&lt;/p&gt;

&lt;p&gt;This point must be stressed: Perl _does not care_—and does not &lt;em&gt;want&lt;/em&gt; to
care—whether a given string’s code points represent bytes or characters.
(More will be said on this later.)&lt;/p&gt;

&lt;h2 id=&#34;back-to-json&#34;&gt;Back to JSON&lt;/h2&gt;

&lt;p&gt;In our examples above we compared round-tripping using different libraries
for the encode and decode. Let’s dig further by comparing just the
encoded JSON:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Mojo::JSON;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Cpanel::JSON::XS;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Data::Dumper;
$Data::Dumper::Useqq &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $e_acute &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\xc3\xa9&amp;#34;&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $mojo_json &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Mojo::JSON::encode_json([$e_acute]);
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $cp_json &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Cpanel::JSON::XS&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;()&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;encode([$e_acute]);
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; Dumper( $mojo_json, $cp_json );&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This will print:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$VAR1 = &amp;quot;[\&amp;quot;\303\203\302\251\&amp;quot;]&amp;quot;;
$VAR2 = &amp;quot;[\&amp;quot;\x{c3}\x{a9}\&amp;quot;]&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Note that &lt;a href=&#34;https://metacpan.org/pod/Data::Dumper&#34;&gt;Data::Dumper&lt;/a&gt;
outputs one string using octal escapes
and the other using hex. This reflects another Perl interpreter
implementation detail which, for now, is of no concern.)&lt;/p&gt;

&lt;p&gt;Our input string contains two code points, 0xc3 and 0xa9. Recall that
there is no specific character set associated with those code points; they’re
just numbers. JSON, though, is purely Unicode—and the
latest standard mandates UTF-8 encoding specifically. So we need to translate
our “no-character-set” code points to UTF-8 in order to encode to JSON. But
how to do this?&lt;/p&gt;

&lt;p&gt;We can’t, strictly speaking. It would be like trying
to convert 5 “currency units” to U.S. dollars: we need to know the actual
source currency (Bitcoin? Euros?) to get an answer. Likewise, in Perl, to
express our stored “code points” in UTF-8 we need to know what &lt;em&gt;characters&lt;/em&gt;
those code points represent. For example, your Perl string might store code
point 142 … but which character is that? Perl doesn’t know, and Perl doesn’t
care. Without a defined character set, a code point is just a number.&lt;/p&gt;

&lt;p&gt;To work around this problem, our JSON libraries make reasonable—though
not necessarily correct—assumptions about what the string’s code points
represent.&lt;/p&gt;

&lt;p&gt;Mojo::JSON assumes that our 2 original code points are Unicode. That means
Mojo::JSON thinks we gave it the characters U+00C3 (Ã) and
U+00A9 (©). The reason for the “expansion” from 2 code points to 4 in the
encoded JSON is that
Mojo::JSON encodes our code points as UTF-8: U+00C3 becomes Perl
code points 0303 (0xc3) and 0203 (0x83), and U+00A9 becomes 0302 (0xc2) and
0251 (0xa9).&lt;/p&gt;

&lt;p&gt;Cpanel::JSON::XS makes a different assumption that suits a different
interpretation: This encoder assumes that our 2 original code points
represent whatever bytes of the characters that should go into the eventual
JSON. Unlike with Mojo::JSON, there is no assumption about a desired encoding,
which allows the caller full control over the encoding.&lt;/p&gt;

&lt;p&gt;(This flexibility allows the encoder’s caller to choose, e.g., UTF-16 rather
than UTF-8 for the encoded JSON. That made more sense prior to the latest
JSON specification, which mandates UTF-8 outside closed systems.)&lt;/p&gt;

&lt;p&gt;The same difference in behavior applies to our two decoder functions. They,
too, face an “unsolvable” problem, the reverse of that for encoding. And
their solutions mirror the encoders’.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Mojo::JSON;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Data::Dumper;
$Data::Dumper::Useqq &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $from_mojo &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[\&amp;#34;\303\203\302\251\&amp;#34;]&amp;#34;&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $from_cp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[\&amp;#34;\x{c3}\x{a9}\&amp;#34;]&amp;#34;&lt;/span&gt;;

$from_mojo &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Mojo::JSON::decode_json($from_mojo)&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;];
$from_cp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Mojo::JSON::decode_json($from_cp)&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;];
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; Dumper( $from_mojo, $from_cp );&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This will print:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$VAR1 = &amp;quot;\x{c3}\x{a9}&amp;quot;;
$VAR2 = &amp;quot;\x{e9}&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Recall that Mojo::JSON’s encoder interprets its input as Unicode and that
its output code points represent bytes of UTF-8.
Above you’ll see that its decoder does the inverse: it interprets its
input as bytes of UTF-8 and outputs code points understood to be Unicode.
This means the number of code points output will be smaller than the number
input if the input contains any code points above 127 (0x7f), which UTF-8
represents as multiple bytes.&lt;/p&gt;

&lt;p&gt;As for Cpanel::JSON::XS:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Mojo::JSON;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Data::Dumper;
$Data::Dumper::Useqq &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $from_mojo &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[\&amp;#34;\303\203\302\251\&amp;#34;]&amp;#34;&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $from_cp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[\&amp;#34;\x{c3}\x{a9}\&amp;#34;]&amp;#34;&lt;/span&gt;;

$from_mojo &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Cpanel::JSON::XS&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;()&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;decode($from_mojo)&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;];
$from_cp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Cpanel::JSON::XS&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;()&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;decode($from_cp)&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;];
&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt; Dumper( $from_mojo, $from_cp );&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This gives:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$VAR1 = &amp;quot;\x{c3}\x{83}\x{c2}\x{a9}&amp;quot;;
$VAR2 = &amp;quot;\x{c3}\x{a9}&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;decode()&lt;/code&gt; method, like &lt;code&gt;encode()&lt;/code&gt;, assumes that the caller will
handle encoding manually and so simply copies code points.&lt;/p&gt;

&lt;h2 id=&#34;aside-assumptions-of-utf-8&#34;&gt;Aside: Assumptions of UTF-8&lt;/h2&gt;

&lt;p&gt;Mojo::JSON’s behavior of encoding to UTF-8 has precedent: Perl itself!&lt;/p&gt;

&lt;p&gt;You may have run into something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; perl -e&#39;print &amp;quot;\x{100}&amp;quot;&#39;
Wide character in print at -e line 1.
Ā
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For code points 0-255 Perl just outputs the code point as an octet, but
when asked to output a code point that exceeds 255, obviously that doesn’t
work. In this case, Perl assumes you want UTF-8 but throws the “wide
character” warning to tip you off to the fact that you missed something—in
this case, you neglected to encode code point 256 to bytes.&lt;/p&gt;

&lt;h2 id=&#34;abusing-the-system&#34;&gt;Abusing the System&lt;/h2&gt;

&lt;p&gt;Cpanel::JSON::XS’s &lt;code&gt;encode()&lt;/code&gt; allows for a nonstandard use of JSON:
literal binary data. Consider the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;perl -MCpanel::JSON::XS -e&#39;print Cpanel::JSON::XS-&amp;gt;new()-&amp;gt;encode([&amp;quot;\xff&amp;quot;])&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;… will output 5 bytes: &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;&amp;quot;&lt;/code&gt;, 0xff, &lt;code&gt;&amp;quot;&lt;/code&gt;, and &lt;code&gt;]&lt;/code&gt;. This is invalid JSON
because no Unicode encoding (let alone UTF-8) ever encodes a character to
a single 0xff byte. Only special decoders that understand this “literal
binary” JSON variant will parse this as intended. That reliance on a custom
mode of operation undercuts JSON’s usefulness as a widely-supported
standard—which may seem fine at first but
can easily bite if your application grows in scope.&lt;/p&gt;

&lt;p&gt;Applications that need to serialize strings with arbitrary octets (i.e.,
binary) should apply a secondary encoding (e.g., Base64) to strings prior
to JSON encoding. Or, better yet, prefer a binary-friendly encoding like
&lt;a href=&#34;https://cbor.io&#34;&gt;CBOR&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;about-that-flag-behind-the-curtain&#34;&gt;About That Flag Behind the Curtain …&lt;/h2&gt;

&lt;p&gt;If you run the output from our two encoder methods through
&lt;a href=&#34;https://metacpan.org/pod/Devel::Peek&#34;&gt;Devel::Peek&lt;/a&gt;, you’ll
see something like this for Mojo::JSON’s output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SV = PV(0x7fdc27802f30) at 0x7fdc27e59c58
  REFCNT = 1
  FLAGS = (POK,pPOK)
  PV = 0x7fdc28826350 &amp;quot;[\&amp;quot;\303\203\302\251\&amp;quot;]&amp;quot;\0
  CUR = 8
  LEN = 34
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;… and this for Cpanel::JSON::XS:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SV = PV(0x7fc0cd004d30) at 0x7fc0cd016228
  REFCNT = 1
  FLAGS = (POK,pPOK,UTF8)
  PV = 0x7fc0cce2ef60 &amp;quot;[\&amp;quot;\303\203\302\251\&amp;quot;]&amp;quot;\0 [UTF8 &amp;quot;[&amp;quot;\x{c3}\x{a9}&amp;quot;]&amp;quot;]
  CUR = 8
  LEN = 34
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note the &lt;code&gt;UTF8&lt;/code&gt; flag in the latter. This tells us that Perl’s
internal storage of the string’s code points uses UTF-8 encoding. This
difference is why, as we saw earlier, Data::Dumper encodes Mojo::JSON’s output
using
octal escapes but Cpanel::JSON::XS’s using hex: Data::Dumper recognizes the
UTF8 flag and renders its output based on it.&lt;/p&gt;

&lt;p&gt;As &lt;a href=&#34;https://perldoc.perl.org/perlunifaq.html#What-is-%22the-UTF8-flag%22%3f&#34;&gt;perldoc perlunifaq&lt;/a&gt; makes clear, though, the UTF8 flag is &lt;strong&gt;not&lt;/strong&gt; meant for
consumption by Perl code. Perl applications should regard strings as
simple sequences of code points, without regard for how the
Perl interpreter may store those strings in memory.&lt;/p&gt;

&lt;p&gt;That being said,
in limited contexts it &lt;em&gt;may&lt;/em&gt; work to imitate the distinction between string
types in languages like Python and JavaScript by regarding
UTF8-flagged strings as “character strings” and non-UTF8-flagged strings as
“byte strings”—indeed, &lt;a href=&#34;https://metacpan.org/pod/Sereal::Encoder&#34;&gt;multiple&lt;/a&gt;
&lt;a href=&#34;https://metacpan.org/pod/CBOR::XS&#34;&gt;serializers&lt;/a&gt;
&lt;a href=&#34;https://metacpan.org/pod/CBOR::Free&#34;&gt;on&lt;/a&gt;
&lt;a href=&#34;https://metacpan.org/pod/CBOR::PP&#34;&gt;CPAN&lt;/a&gt;, including two of my own,
do exactly this. This isn’t
a supported model, though, for using Perl strings, and any code that
depends on it may behave differently in different Perl versions. Caveat
emptor!&lt;/p&gt;

&lt;h2 id=&#34;making-peace&#34;&gt;Making Peace&lt;/h2&gt;

&lt;p&gt;JSON and Perl are odd bedfellows. Perl’s lack of distinct number and string
types, for example, can yield JSON that uses the wrong type for one
value or the other. Perl’s lack of native booleans produces a similar effect.&lt;/p&gt;

&lt;p&gt;The encoding problems discussed above, though, are especially nefarious
because accommodating them requires a good understanding of all of the above.
Most developers can accommodate something like &lt;code&gt;{&amp;quot;age&amp;quot;: &amp;quot;9&amp;quot;}&lt;/code&gt; easily enough
because typecasting from &lt;code&gt;&amp;quot;9&amp;quot;&lt;/code&gt; (string) to &lt;code&gt;9&lt;/code&gt; (number) is commonplace. But
how many would see &lt;code&gt;&amp;quot;Ã©&amp;quot;&lt;/code&gt; and think, “ah! I simply have to treat those
characters’ code points as bytes then decode those bytes as UTF-8!” Some
would, to be sure—perhaps even many—but likely fewer than can easily coerce
&lt;code&gt;&amp;quot;9&amp;quot;&lt;/code&gt; to &lt;code&gt;9&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Binary-friendly encodings like &lt;a href=&#34;http://cbor.io&#34;&gt;CBOR&lt;/a&gt;
mitigate against this problem because whatever decodes the Perl-sourced
data can more easily recognize the need to decode from binary. Anyone
who doesn’t know about bytes and encodings will quickly learn! Fundamentally,
though, even CBOR doesn’t really fit Perl’s “pure code points” string model
very well because CBOR distinguishes strongly between binary and text strings,
which Perl does not.&lt;/p&gt;

&lt;p&gt;At the end of the day, Perl’s data model, for all of the conveniences that it
affords us, makes communication with many other languages a challenge. The
best we can do is to anticipate these problems and deal with them as they arise.&lt;/p&gt;

&lt;h2 id=&#34;epilogue-json-alternatives&#34;&gt;Epilogue: JSON Alternatives&lt;/h2&gt;

&lt;p&gt;JSON’s inability to store arbitrary octet strings is, in my experience,
its biggest liability,
but there are other reasons why I often prefer to avoid JSON:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Its inability to store comments and proscription against trailing commas
make it an awkward choice for human-maintained data structures.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Its &lt;code&gt;\uXXXX&lt;/code&gt; escapes support only characters within Unicode’s
&lt;abbr title=&#34;Basic Multilingual Plane&#34;&gt;BMP&lt;/abbr&gt;; to store emoji or other
non-BMP characters you either have to encode to UTF-8 directly or indicate
a UTF-16 surrogate pair (&lt;a href=&#34;https://en.wikipedia.org/wiki/UTF-16#U+010000_to_U+10FFFF&#34;&gt;What does that mean?&lt;/a&gt;) in &lt;code&gt;\uXXXX&lt;/code&gt; escapes.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It’s inefficient compared with binary formats.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/toml-lang/toml&#34;&gt;TOML&lt;/a&gt; is a nice serialization format
for human-maintained data structures. It’s line-delimited and—of course!—allows
comments, and any Unicode code point can be expressed in simple hexadecimal.
TOML is fairly new, and its specification is still in flux; nevertheless,
it already undergirds a number of high-profile
software projects like Rust’s &lt;a href=&#34;https://doc.rust-lang.org/cargo/&#34;&gt;Cargo&lt;/a&gt;
package manager and &lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;—which powers this site! CPAN
&lt;a href=&#34;https://metacpan.org/pod/TOML::Tiny&#34;&gt;hosts&lt;/a&gt;
&lt;a href=&#34;https://metacpan.org/pod/TOML::Parser&#34;&gt;several&lt;/a&gt;
&lt;a href=&#34;https://metacpan.org/pod/TOML&#34;&gt;implementations&lt;/a&gt; of this serialization.&lt;/p&gt;

&lt;p&gt;The aforementioned &lt;a href=&#34;https://cbor.io&#34;&gt;CBOR&lt;/a&gt; improves upon JSON’s efficiency and
also allows for storage of binary strings. Whereas JSON encoders must
stringify numbers and escape all strings, CBOR stores numbers “literally”
and prefixes strings with their length, which obviates the need to escape those
strings. These dramatically simplify both encoding and decoding. As with
TOML and YAML, CPAN hosts &lt;a href=&#34;https://metacpan.org/pod/CBOR::XS&#34;&gt;multiple&lt;/a&gt;
&lt;a href=&#34;https://metacpan.org/pod/CBOR::Free&#34;&gt;CBOR&lt;/a&gt;
&lt;a href=&#34;https://metacpan.org/pod/CBOR::PP&#34;&gt;implementations&lt;/a&gt;.
(Full disclosure: Two of these are of my own authorship.)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Sereal/Sereal&#34;&gt;Sereal&lt;/a&gt; is another great JSON substitute
that confers most of CBOR’s benefits and can even serialize more
“Perl-specific” items like regular expressions. This makes it ideal
for Perl-to-Perl IPC. The reference implementation is CPAN’s
&lt;a href=&#34;https://metacpan.org/pod/Sereal&#34;&gt;Sereal&lt;/a&gt; distribution.
Sereal isn’t as well-supported as CBOR outside Perl,
though, so if you need to communicate with non-Perl code, Sereal may
not work as well for you.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://yaml.org/&#34;&gt;YAML&lt;/a&gt; is another format that humans can maintain easily.
Unlike TOML, YAML supports binary strings; in fact, it’s flexible enough
to replace Data::Dumper in many cases. CPAN includes
a &lt;a href=&#34;https://metacpan.org/pod/YAML::XS&#34;&gt;number&lt;/a&gt;
&lt;a href=&#34;https://metacpan.org/pod/YAML::PP&#34;&gt;of&lt;/a&gt;
&lt;a href=&#34;https://metacpan.org/pod/YAML::Old&#34;&gt;libraries&lt;/a&gt; that implement YAML.&lt;/p&gt;

&lt;p&gt;Thank you for reading!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Free Wildcard TLS with Net::ACME2 and Let’s Encrypt</title>
      <link>http://localhost:1313/article/free-wildcard-tls-with-net-acme2-and-let-s-encrypt/</link>
      <pubDate>Tue, 23 Jan 2018 08:00:24 +0000</pubDate>
      
      <guid>http://localhost:1313/article/free-wildcard-tls-with-net-acme2-and-let-s-encrypt/</guid>
      <description>&lt;p&gt;Much of the credit for the recent improvement in TLS deployment across
the Internet must go to &lt;a href=&#34;http://letsencrypt.org&#34;&gt;Let’s Encrypt&lt;/a&gt; (LE),
who provide free TLS certificates via an open-access RESTful API. That
API has a large number of clients in many languages, including Perl.
(The list includes the &lt;a href=&#34;http://cpanel.com&#34;&gt;cPanel&lt;/a&gt;-derived
&lt;a href=&#34;https://metacpan.org/pod/Net::ACME&#34;&gt;Net::ACME&lt;/a&gt;
as well as &lt;a href=&#34;https://metacpan.org/pod/Crypt::LE&#34;&gt;Crypt::LE&lt;/a&gt;,
&lt;a href=&#34;https://metacpan.org/pod/Protocol::ACME&#34;&gt;Protocol::ACME&lt;/a&gt;,
&lt;a href=&#34;https://metacpan.org/pod/WWW::LetsEncrypt&#34;&gt;WWW::LetsEncrypt&lt;/a&gt;, and
&lt;a href=&#34;https://metacpan.org/pod/Mojo::ACME&#34;&gt;Mojo::ACME&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;LE has worked with the &lt;a href=&#34;http://ietf.org&#34;&gt;IETF&lt;/a&gt; to standardize their
“ACME” (Automated Certificate Management Environment) protocol as an
Internet standard. The forthcoming standard breaks compatibility with the
previous version of the protocol, which necessitates updates to the client
logic.&lt;/p&gt;

&lt;p&gt;As an incentive for clients to adopt the new protocol, though, LE will
offer free wildcard TLS via their new API.&lt;/p&gt;

&lt;p&gt;I thought I would take the opportunity to rework Net::ACME for support of
the new protocol and quickly decided that a new distribution would suit
the need best. Besides the significant protocol changes that have taken
place, I wanted to make some “deeper” changes like:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;I wanted to incorporate &lt;a href=&#34;https://metacpan.org/pod/X::Tiny&#34;&gt;X::Tiny&lt;/a&gt;
to reduce some logic duplication and gain the benefits of that library.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The new protocol suggests some changes to the class structure that
would have been unwieldy to incorporate in the prior version.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And so, &lt;a href=&#34;https://metacpan.org/pod/Net::ACME2&#34;&gt;Net::ACME2&lt;/a&gt; is now available.
This is a generic client library for any standard ACME implementation,
though the only known public ACME implementation right now is
Let’s Encrypt’s. Their API only provides testing certificates for now,
but once there’s a production endpoint I will update Net::ACME2 to use it.&lt;/p&gt;

&lt;p&gt;Like its predecessor, Net::ACME2:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;… supports both RSA and ECDSA&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;… runs anywhere that Perl runs—no XS required except for core
modules. (cf. &lt;a href=&#34;https://metacpan.org/pod/Crypt::Perl&#34;&gt;Crypt::Perl&lt;/a&gt;)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;… reports detailed errors via typed exceptions&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;… has minimal dependencies (no Moose, &amp;amp;c.)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I&amp;rsquo;ve created some example &lt;a href=&#34;https://github.com/FGasper/p5-Net-ACME2/tree/master/examples&#34;&gt;scripts&lt;/a&gt; to get you started. After you&amp;rsquo;ve installed the module, clone the &lt;a href=&#34;https://github.com/FGasper/p5-Net-ACME2&#34;&gt;repo&lt;/a&gt;, change into the root project directory and run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./examples/http-01.pl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;… or:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./examples/dns-01.pl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These walk you through the following steps (with Let’s Encrypt):&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Read the terms of service and, if you accept them, proceed.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Create an RSA or ECC private key. Net::ACME2 will extract the public
key from it and send it to the ACME server as your account identifier.
(The example scripts create a new key for each invocation, but for a
production deployment you should reuse a key.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Create a certificate order by telling Net::ACME2 which domains the
certificate will include. The ACME server will respond with options for
“challenges”—i.e., how to prove that you control those domains. Currently
there are two available methods: HTTP and DNS. (NOTE: Wildcard domains
require the DNS method.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Set up the verification. For HTTP that means making a specific
URL on the domain respond with specific content; for DNS it means creating
a TXT record with a specific name and content. (The example scripts use
the same challenge method for all domains, but your application can be
more flexible.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Indicate to the ACME server which challenge you’re accepting for each
domain.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Finalize the certificate order. This will tell you if any challenges
failed or are still pending.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If all domains’ challenges succeeded, you’ll get a URL whose content
will be the newly-issued certificate.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Net::ACME2 is, like the ACME standard itself, still subject to
change, but it’ll get the job done for now. Give it a try!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

