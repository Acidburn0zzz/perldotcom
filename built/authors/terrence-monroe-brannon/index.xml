<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Terrence Monroe Brannon on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/authors/terrence-monroe-brannon/</link>
    <description>Recent content in Terrence Monroe Brannon on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 27 Feb 2001 00:00:00 -0800</lastBuildDate>
    <atom:link href="/authors/terrence-monroe-brannon/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>DBIx::Recordset VS DBI</title>
      <link>http://localhost:1313/pub/2001/02/dbix.html/</link>
      <pubDate>Tue, 27 Feb 2001 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2001/02/dbix.html/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;#problems%20using%20dbi%20at%20applicationlevel&#34;&gt;Problems Using DBI at Application-Level&lt;/a&gt;
-   &lt;a href=&#34;#intolerance%20to%20table%20and%20data%20mutation&#34;&gt;Intolerance to Table and Data Mutation&lt;/a&gt;
-   &lt;a href=&#34;#errorprone%20and%20tedious%20query%20construction&#34;&gt;Error-Prone and Tedious Query Construction&lt;/a&gt;
-   &lt;a href=&#34;#manual%20and%20complex%20mapping%20of%20database%20data%20to%20perl%20data%20structures&#34;&gt;Manual and Complex Mapping of Database Data to Perl Data Structures&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;#succint%20cgisql%20interaction%20(database%20control%20via%20cgi%20oneliners)&#34;&gt;Succint CGI-SQL Interaction (Database Control via ``CGI One-Liners&amp;rdquo;)&lt;/a&gt;
-   &lt;a href=&#34;#control%20and%20monitoring%20of%20table%20access&#34;&gt;Control and Monitoring of Table Access&lt;/a&gt;
-   &lt;a href=&#34;#scalability&#34;&gt;Scalability&lt;/a&gt;
-   &lt;a href=&#34;#form%20data%20variations&#34;&gt;Form Data Variations&lt;/a&gt;
-   &lt;a href=&#34;#table%20splits&#34;&gt;Table Splits&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;#sample%20code&#34;&gt;Sample Code&lt;/a&gt;
-   &lt;a href=&#34;#dbix::recordset%20version%20of%20code&#34;&gt;DBIx::Recordset Version of Code&lt;/a&gt;
-   &lt;a href=&#34;#dbi%20version%20of%20code&#34;&gt;DBI Version of Code&lt;/a&gt;
-   &lt;a href=&#34;#empirical%20results&#34;&gt;Empirical Results&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;
&lt;a href=&#34;#acknowledgements&#34;&gt;Acknowledgements&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;Writing this article was pure hell. No, actually, writing most of it was quite fun - it was just when I had to write the functional equivalent of my DBIx::Recordset code in DBI that I began to sweat profusely. It was only when I had finished writing the mountain of DBI code to do the same thing as my molehill of DBIx::Recordset that I could heave a sigh of relief. Since starting to use DBIx::Recordset, I have been loath to work on projects where the required database API was DBI. While it may seem like a play on words, it is crucial to understand that DBI is the standard database interface for Perl but it should not be the interface for most Perl applications requiring database functionality.&lt;/p&gt;

&lt;p&gt;The key way to determine whether a particular module/library is matched to the level of a task is to count the number of lines of ``prep code&amp;rdquo; you must write before you can do what you want. In other words, can the complex operations and data of your domain be dealt with in a unitary fashion by this module? In the case of DBI, we can say that it has made the tasks of connection, statement preparation, and data fetching tractable by reducing them to single calls to the DBI API. However, real-life applications have much larger and more practical complex units and it is in these respects that the DBI API falls short. To me, it comes as no surprise that DBI, a module whose only design intent was to present a uniform API to the wide variety of available databases, would lack such high-level functionality. But it does surprise me to no end that hoards of Perl programmers, some of whom may have had a software engineering course at some point in their careers, would make such errant judgment. Thus the fault lies with the judgment of the programmers, not DBI.&lt;/p&gt;

&lt;p&gt;In most cases the gap between DBI&amp;rsquo;s API and Perl applications has been bridged by indiscriminately mixing generic application-level functionality with the specifics of the current application. This makes it difficult to reuse the generic routines in another part of the application or in an altogether different application. Another maladaptive way that the DBI API has been extended for application-level databasing is by developing a collection of generic application-level tools but not publishing them. Thus, as larger scale tools are built from two camps using differing generic application-level APIs, amends for discrepancies in calling conventions must be duct-taped between the code bodies. The final way to misuse DBI in an application is to use it directly.&lt;/p&gt;

&lt;p&gt;However, an unsung module, publicly available on CPAN that bridges the gap between DBI and application-level programming robustly and conveniently is DBIx::Recordset. It is built on top of DBI and is so well-matched to the level at which database-driven applications are conceived that in most cases one sentence in an application design specification equates to one line of DBIx::Recordset.&lt;/p&gt;

&lt;h3 id=&#34;span-id-problems-using-dbi-at-applicationlevel-problems-using-dbi-at-application-level-span&#34;&gt;&lt;span id=&#34;problems using dbi at applicationlevel&#34;&gt;Problems Using DBI at Application-Level&lt;/span&gt;&lt;/h3&gt;

&lt;h4 id=&#34;span-id-intolerance-to-table-and-data-mutation-intolerance-to-table-and-data-mutation-span&#34;&gt;&lt;span id=&#34;intolerance to table and data mutation&#34;&gt;Intolerance to Table and Data Mutation&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Table mutation - the addition, deletion or rearrangement of fields from a table or data mutation - the addition, removal or rearrangement of portions of the input sources intended for database commission, can break a large number of calls to the DBI API. This is due to the fact that most routines expect and return arrays or array references and thus fail when the expected arrays shrink or grow. For example, the following DBI code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $dbh-&amp;gt;do(&amp;quot;INSERT INTO students (id,name) VALUES (1,$name)&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;would break once fields were removed from the table students. However, the equivalent DBIx::Recordset code&lt;a href=&#34;#1&#34;&gt;(1)&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; DBIx::Recordset-&amp;gt;Insert({%dsn,&#39;!Table&#39;=&amp;gt;&#39;students&#39;,%dbdata});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;would work regardless of constructive or destructive mutations of the students table or %dbdata. If there are fewer field-value pairs in %dbdata than in the table, then the insert will be performed with the corresponding fields. If there are irrelevant fields in %dbdata, then the extra fields are by default silently ignored.&lt;/p&gt;

&lt;p&gt;Now, the import of this intolerance for DBI usage is that changes in either the tables or the input data require changes in the source. For some, such rigidity is of merit because it forces both the source and target of database commission to be made explicitly manifest within the source code. However, for other Perl programmers, such rigidity is nothing more than an imposition on their highly cultivated sense of Laziness.&lt;/p&gt;

&lt;h4 id=&#34;span-id-errorprone-and-tedious-query-construction-error-prone-and-tedious-query-construction-span&#34;&gt;&lt;span id=&#34;errorprone and tedious query construction&#34;&gt;Error-Prone and Tedious Query Construction&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;A query string is presented to the DBI API in placeholder or literal notation. An example of DBI placeholder usage is shown below:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $sql=&#39;insert into uregisternew
        (country, firstname, lastname, userid, password, address1, city,
        state, province, zippostal, email, phone, favorites, remaddr,
        gender, income, dob, occupation, age)
        values (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)&#39;;

 my @data=($formdata{country}, $formdata{firstname}, $formdata{lastname},
        $formdata{email}, $formdata{password}, $formdata{address},
        $formdata{city},  $formdata{state},  $formdata{province},
        $formdata{zippostal}, $formdata{email}, $formdata{phone},
        $formdata{favorites}, $formdata{remaddr}, $formdata{gender},
        $formdata{income}, $formdata{date}, $formdata{occupation},
 $formdata{age});

        $sth2 = $dbh-&amp;gt;prepare($sql);
        $sth2-&amp;gt;execute(@data);
        $sth2-&amp;gt;finish();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a slightly modified version of a minefield I had to tiptoe through during a recent contract I was on. This code has several accidents waiting to happen. For one you must pray that the number of question-mark placeholders is the same as the number of fields you are inserting. Secondly, you must manually insure that the field names in the insert statement correspond with the data array in both position and number.&lt;/p&gt;

&lt;p&gt;If one were developing the same query using DBI&amp;rsquo;s literal notation, one would have the same issues and would in addition devote more lines of code to manually quoting the data and embedding it in the query string.&lt;/p&gt;

&lt;p&gt;In contrast, DBIx::Recordset&amp;rsquo;s &lt;code&gt;Insert()&lt;/code&gt; function takes a hash in which the keys are database field names and the values are the values to be inserted. Using such a data structure eliminates the correspondence difficulties mentioned above. Also, DBIx::Recordset generates the placeholder notation when it calls the DBI API.&lt;/p&gt;

&lt;p&gt;Thus, with no loss of functionality&lt;a href=&#34;#2&#34;&gt;(2)&lt;/a&gt;, the entire body of code above could be written as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; DBIx::Recordset-&amp;gt;Insert({%dsn,%formdata});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, the DBI code is not equivalent to the DBIx::Recordset code because connection and database operations are always separate calls to the DBI API. The additional work required to use DBI has been omitted for brevity.&lt;/p&gt;

&lt;h4 id=&#34;span-id-manual-and-complex-mapping-of-database-data-to-perl-data-structures-manual-and-complex-mapping-of-database-data-to-perl-data-structures-span&#34;&gt;&lt;span id=&#34;manual and complex mapping of database data to perl data structures&#34;&gt;Manual and Complex Mapping of Database Data to Perl Data Structures&lt;/span&gt;&lt;/h4&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;25%&#34; /&gt;
&lt;col width=&#34;25%&#34; /&gt;
&lt;col width=&#34;25%&#34; /&gt;
&lt;col width=&#34;25%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;operation&lt;/td&gt;
&lt;td&gt;DBI&lt;/td&gt;
&lt;td&gt;DBIx::Recordset&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;Single row fetch&lt;/td&gt;
&lt;td&gt;&lt;pre&gt;&lt;code&gt;selectrow_array
selectrow_arrayref&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td&gt;&lt;pre&gt;&lt;code&gt;$set[0]&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Multiple row fetch&lt;/td&gt;
&lt;td&gt;&lt;pre&gt;&lt;code&gt;fetchall_arrayref  
selectall_arrayref 
fetchrow_array     
fetchrow_arrayref  
fetchrow_hashref&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td&gt;&lt;pre&gt;&lt;code&gt; for $row (@set) {...}
       OR    
while ($href=$set-&amp;gt;Next())&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;In DBI, database record retrieval is manual, complex and in most cases intolerant to table mutation. By manual, we mean that performing the query does not automatically map the query results onto any native Perl data structures. By complex, we mean that DBI can return the data in a multiplicity of ways: array, array reference and hash reference.&lt;/p&gt;

&lt;p&gt;In DBIx::Recordset, however, retrieval of selected recordsets can be &lt;a href=&#34;#3&#34;&gt;(3)&lt;/a&gt; automatic, simple and field-mutation tolerant. By automatic, we mean that requesting the records leads to an automatic tie of the result set to a hash.&lt;a href=&#34;#4&#34;&gt;(4)&lt;/a&gt; No functions need be called for this transfer to take place. The retrieval process is simple because the only way to receive results is via a hash reference. Because DBIx::Recordset returns a hash, fields are referred to by name as opposed to position. This strategy is robust to all table mutations.&lt;/p&gt;

&lt;p&gt;Having seen DBIx::Recordset&amp;rsquo;s solution to some of the more troublesome aspects of DBI use, we now move on to explore the wealth of application-level benefits that DBIx::Recordset offers in the following areas:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Succinct CGI to SQL transfer&lt;/li&gt;
&lt;li&gt;Control and monitoring of table access&lt;/li&gt;
&lt;li&gt;Scalability&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As impressive as these topics may sound, DBIx::Recordset is designed to achieve each of them in one line of Perl&lt;img src=&#34;#5&#34; alt=&#34;(5)&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-succint-cgisql-interaction-database-control-via-cgi-oneliners-succint-cgi-sql-interaction-database-control-via-cgi-one-liners-span&#34;&gt;&lt;span id=&#34;succint cgisql interaction (database control via cgi oneliners)&#34;&gt;Succint CGI-SQL Interaction (Database Control via ``CGI One-Liners&amp;rdquo;)&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Assuming that the keys in the query string match the field names in the target database table, DBIx::Recordset can shuttle form data from a query string into a database in one line of Perl code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; DBIx::Recordset-&amp;gt;Insert({%formdata,%dsn});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One line of DBIx::Recordset can also drive recordset retrieval via form data as well as iterate through the results:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; # here we: SELECT * FROM sales and automatically tie
 # the selected records to @result

 *result = DBIx::Recordset-&amp;gt;Search({
        %dsn,&#39;!Table&#39;=&amp;gt;&#39;sales&#39;,%formdata
        });

 # here we iterate across our results...
 map { 
  printf (&amp;quot;&amp;lt;TR&amp;gt;Sucker # %d purchased item # %s on %s&amp;lt;/TR&amp;gt;&amp;quot;, 
        $_-&amp;gt;{customer_id}, $_-&amp;gt;{item_id}, $_-&amp;gt;{purchase_date}) 
 } @result;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code is automatically quoted and requires no tiresome connect, prepare and execute ritual.&lt;/p&gt;

&lt;p&gt;DBIx::Recordset also has helper functions which create the HTML for ``previous-next-first-last&amp;rdquo; navigation of recordsets:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $nav_html = $::result -&amp;gt; PrevNextForm ({
        -first =&amp;gt; &#39;First&#39;,  -prev =&amp;gt; &#39;&amp;lt;&amp;lt;Back&#39;, 
        -next  =&amp;gt; &#39;Next&amp;gt;&amp;gt;&#39;, -last =&amp;gt; &#39;Last&#39;,
                -goto  =&amp;gt; &#39;Goto #&#39;}, 
        \%formdata);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, we use the scalar aspect of the typeglob, which provides object-oriented access to the methods of the created recordset.&lt;/p&gt;

&lt;p&gt;A final CGI nicety has to do with the fact that browsers send empty form fields as empty strings. While in some cases you may want this empty string to propagate into the database as a SQL null, it is also sometimes desirable to have empty form fields ignored. It is possible to specify which behavior you prefer through the DBIx::Recordset &amp;lsquo;!IgnoreEmpty&amp;rsquo; hash field of the &lt;code&gt;Insert()&lt;/code&gt; and &lt;code&gt;Update()&lt;/code&gt; function.&lt;/p&gt;

&lt;h4 id=&#34;span-id-control-and-monitoring-of-table-access-control-and-monitoring-of-table-access-span&#34;&gt;&lt;span id=&#34;control and monitoring of table access&#34;&gt;Control and Monitoring of Table Access&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;A database handle in DBI is a carte blanche to add, retrieve, or remove anything from a database that one can do with a console interface to the database with the same login. The problem with this is that the semantics and volatility of an application&amp;rsquo;s database code is not self-consistent but instead varies as a function of database permission alteration.&lt;a href=&#34;#6&#34;&gt;(6)&lt;/a&gt; Au contraire, a DBIx::Recordset handle is much more structured. A handle is created and configured with a number of attributes: table write modes, accessible tables, and the method of logging database usage to name a few.&lt;/p&gt;

&lt;p&gt;The first form of much-needed table access control that DBIx::Recordset offers is specification of the manners in which a particular database connection will be allowed to alter database tables. By the use of a binary-valued string, one specifies the subset of write operations (specifically none/insert/update/delete/clear) that are allowable. Such facilities are often needed when defining access levels to a database for various parties. For example, it is conceivable for a corporate intranet database to give insert access to sales employees, update access to customer service, delete access to processing and complete access to technical support. To implement such constraints in plain DBI would yield a confusing maelstrom of if-thens and 2-3 suicide attempts. With DBIx::Recordset, one simply creates a properly configured connection for each corporate intranet sector.&lt;/p&gt;

&lt;p&gt;Tangential to the issue of write permission is the issue of which tables can be accessed at all. Control of table access is simply one more key-value pair to the connection setup hash. Finally to monitor the use of database handles, one only need setup a debug file for each handle.&lt;/p&gt;

&lt;p&gt;Thus, assuming the package company::database has a hash %write_mode which contains the write modes for the intranet, a hash %log_file with the log files for each handle, and a hash %table_access which contains the tables for each member of the intranet, one would specify the tables and their mode of access and usage logs for the entire intranet as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ 
  package company::database; 

  for (keys %write_mode) {

  *{$handle{$_}} = 
        DBIx::Recordset-&amp;gt;Setup({%dsn, 
        &#39;!Writemode&#39; =&amp;gt; $write_mode{$_}, 
        &#39;!Tables&#39;    =&amp;gt; $table_access{$_}
        });

   DBIx::Recordset-&amp;gt;Debug({
                &#39;!Level&#39; =&amp;gt; 4,
                &#39;!File&#39;  =&amp;gt; $log_file{$_},
                &#39;!Mode&#39;  =&amp;gt; &#39;&amp;gt;&#39;
                });
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-scalability-scalability-span&#34;&gt;&lt;span id=&#34;scalability&#34;&gt;Scalability&lt;/span&gt;&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Operation&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Code changes needed (DBI)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Code changes (DBIx::Recordset)&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Adding or removing form elements from a webpage but still having the database code commit the generated query string properly.&lt;/td&gt;
&lt;td&gt;For each change of the form (and hence the query string), the database code would have to be modified.&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Taking an un-normalized main table and splitting it into a number of &amp;ldquo;satellite&amp;rdquo; tables with foreign keys in the main table to reference the satellite tables.&lt;/td&gt;
&lt;td&gt;For each table split, additional terms would have to added to the WHERE or JOIN clause.&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Regardless of how well one plans a project, prototyping and early development are often evolutionary processes. Significant development time can be saved if database-processing routines remain invariant in the face of HTML and database re-design. It is in this regard that DBIx::Recordset dwarfs DBI, making it far more viable during the prototyping phases of a project. Having already shown DBIx::Recordset&amp;rsquo;s scalability in the face of table mutations, this section will demonstrate DBIx::Recordset&amp;rsquo;s scalability in the face of form data variations as well as database table splits.&lt;/p&gt;

&lt;h4 id=&#34;span-id-form-data-variations-form-data-variations-span&#34;&gt;&lt;span id=&#34;form data variations&#34;&gt;Form Data Variations&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Let&amp;rsquo;s assume you were developing a user registration form that submitted it&amp;rsquo;s form data to db-commit.cgi for insertion into a database:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/perl
use CGI (:standard);
$formdata{$_} = param{$_} for param();
if ($#(DBIx::Recordset-&amp;gt;Search(
 { %dsn,
  &#39;!Table&#39;  =&amp;gt; user_registration,
  &#39;username&#39; =&amp;gt; $formdata{username}
 })) &amp;gt;= 0) {
 &amp;amp;username_taken_error;
} else {
 DBIx::Recordset-&amp;gt;Insert(
 { %dsn,
  &#39;!Table&#39;  =&amp;gt; user_registration,
  %formdata
 }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now assume that you decided to add a new field called AGE to a table and a corresponding form. Under DBI, the insert query would have to be modified to account for the change. Because DBIx::Recordset takes a hash reference for its inserts, no code modification is required. Now of course, I can hear the DBI users squawking: ``I can develop a library that converts form data to hashes and turns this into query strings.&amp;rdquo; And of course my hot retort is: ``But don&amp;rsquo;t you see this is a homegrown, non-standard &lt;a href=&#34;#7&#34;&gt;(7)&lt;/a&gt;API that will have to be duct-taped to other people&amp;rsquo;s homegrown, non-standard solutions?&amp;rdquo;&lt;/p&gt;

&lt;h4 id=&#34;span-id-table-splits-table-splits-span&#34;&gt;&lt;span id=&#34;table splits&#34;&gt;Table Splits&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;For another example of DBIx::Recordset&amp;rsquo;s flexibility to architecture changes, consider the case where a table is split, perhaps for reasons of normalization. Thus, in the core table where you once explicitly coded a user&amp;rsquo;s name into a field user_name you now have a foreign key titled user_name_id which points to a table called user_name which has a field titled id. Assume that you also later decided to do the same sort of normalization for other fields such as age-bracket or salary-bracket. With plain DBI, each time that a query was supposed to retrieve all fields from each of the associated tables, the query would have to be rewritten to accommodate the splitting of the main table. With DBIx::Recordset, no query would have to be rewritten because the tables were described in a format recognizable by DBIx::Recordset&amp;rsquo;s database meta-analysis.&lt;/p&gt;

&lt;h3 id=&#34;span-id-sample-code-sample-code-span&#34;&gt;&lt;span id=&#34;sample code&#34;&gt;Sample Code&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;On a recent contract I had to copy a user registration table (named uregister) to a new table (called uregisternew) which had all of the fields of the old table plus a few new fields designed to store profile information on the users.&lt;/p&gt;

&lt;p&gt;The key thing to note about the DBIx::Recordset version of this code is that it is highly definitional: very little database mechanics clutters the main logic of the code, allowing one to focus on recordset migration from one table to another.&lt;/p&gt;

&lt;h4 id=&#34;span-id-dbix-recordset-version-of-code-dbix-recordset-version-of-code-span&#34;&gt;&lt;span id=&#34;dbix::recordset version of code&#34;&gt;DBIx::Recordset Version of Code&lt;/span&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt; #!/usr/bin/perl

 =head1

 uregisternew is a table with all the fields of uregister plus a few
 profile fields (ie, salary bracket, occupation, age) which contain a
 positive integer which serves as index into the array for that
 particular profile field.

 The purpose of this script is to copy over the same fields and
 generate a valid array index for the new profile fields.

 =cut

 use Angryman::Database;
 use Angryman::User;
 use DBIx::Recordset;
 use Math::Random;
 use strict;

 $::table{in}  = &#39;uregister&#39;;
 $::table{out} = &#39;uregisternew&#39;;


 # connect to database and SELECT * FROM uregister
 *::uregister = DBIx::Recordset-&amp;gt;Search ({            
        %Angryman::Database::DBIx::Recordset::Connect, 
        &#39;!Table&#39; =&amp;gt; $::table{in}  
        });


 # because we will re-use the target table many times, we separate the 
 # connection and insert steps with this recordset
 *::uregisternew = DBIx::Recordset-&amp;gt;Setup({  
        %Angryman::Database::DBIx::Recordset::Connect, 
        &#39;!Table&#39; =&amp;gt; $::table{out} 
        });


 # iterate through the recordsets from the old table:
 for my $uregister (@::uregister) {
     &amp;amp;randomize_user_profile;
     # INSERT 
        # the old table data into the new table and
        # the computed hash of profile data
    $::uregisternew-&amp;gt;Insert({%{$uregister},%::profile});
 }

 # Angryman::User::Profile is a hash in which each key is a reference 
 # to an array of profile choices. For example:
 # $Angryman::User::Profile{gender} = [ &#39;male&#39;, &#39;female&#39; ];
 # $Angryman::User::Profile{age} = [&#39;under 14&#39;, &#39;14-19&#39;, &#39;20-25&#39;, ... ];
 # Because we don&#39;t have the actual data for the people in uregister,
 # we randomly assign user profile data over a normal distribution.
 # when copying it to uregisternew.
 sub randomize_user_profile {
    for (keys %Angryman::User::Profile) {
        my @tmp=@{$Angryman::User::Profile{$_}};
        $::profile{$_} = random_uniform_integer(1,0,$#tmp);
        $::profile{dob}=&#39;1969-05-11&#39;;
    }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-dbi-version-of-code-dbi-version-of-code-span&#34;&gt;&lt;span id=&#34;dbi version of code&#34;&gt;DBI Version of Code&lt;/span&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt; #!/usr/bin/perl


 =head1
 uregisternew is a table with all the fields of uregister plus a few
 profile fields (ie, salary bracket, occupation, age) which contain
 a positive integer which serves as index into the array for that
 particular profile field.


 The purpose of this script is to copy over the same fields and
 generate a valid array index for the new profile fields.


 This file is twice as long as the DBIx::Recordset version and it 
 easily took me 5 times longer to write.
 =cut 


 use Angryman::Database;
 use Angryman::User;
 use DBI;
 use Math::Random;
 use strict;


 $::table{in}  = &#39;uregister&#39;;
 $::table{out} = &#39;uregisternew&#39;;


 # connect to database and SELECT * FROM uregister
 my $dbh = DBI-&amp;gt;connect($Angryman::Database::DSN, 
                        $Angryman::Database::Username, 
                        $Angryman::Database::Password);
 my $sth = $dbh-&amp;gt;prepare(&#39;SELECT * FROM uregister&#39;);
 my $ret = $sth-&amp;gt;execute;


 &amp;amp;determine_target_database_field_order;


 # because we will re-use the target table many times, we separate the 
 # connection and insert steps with this recordset


 # iterate through the recordsets from the old table:
 while ($::uregister = $sth-&amp;gt;fetchrow_hashref) {


     &amp;amp;randomize_user_profile;
     &amp;amp;fiddle_with_my_data_to_get_it_to_work_with_the_DBI_API();


     # INSERT 
         # the old table data into the new table and
         # the computed hash of profile data
     my $sql = &amp;quot;INSERT into $::table{out}($::sql_field_term) values($::INSERT_TERM)&amp;quot;;
     $dbh-&amp;gt;do($sql);
 }


 # Angryman::User::Profile is a hash in which each key is a reference 
 # to an array of profile choices. For example:
 # $Angryman::User::Profile{gender} = [ &#39;male&#39;, &#39;female&#39; ];
 # $Angryman::User::Profile{age} = [&#39;under 14&#39;, &#39;14-19&#39;, &#39;20-25&#39;,  ];
 # Because we don&#39;t have the actual data for the people in uregister,
 # we randomly assign user profile data over a normal distribution.
 # when copying it to uregisternew.
 sub randomize_user_profile {
     for (keys %Angryman::User::Profile) {
         my @tmp=@{$Angryman::User::Profile{$_}};
         $::profile{$_} = random_uniform_integer(1,0,$#tmp);
     }


     $::profile{dob}=&#39;&#39;;
 }


 # Hmm, I cant just give DBI my data and have it figure out the order
 # of the database fields... So here he we go getting the field
 # order dynamically so this code doesnt break with the least little
 # switch of field position.
 sub determine_target_database_field_order {


     my $order_sth = $dbh-&amp;gt;prepare(&amp;quot;SELECT * FROM $::table{out} LIMIT 1&amp;quot;);
     $order_sth-&amp;gt;execute;


 # In DBIx::Recordset, I would just say $handle-&amp;gt;Names()... but here we 
 # must iterate through the fields manually and get their names.


     for (my $i = 0; $i &amp;lt; $order_sth-&amp;gt;{NUM_OF_FIELDS}; $i++) {
         push @::order_data, $order_sth-&amp;gt;{NAME}-&amp;gt;[$i];
     }


     $::sql_field_term = join &#39;,&#39;,  @::order_data;


 }


 # As ubiquitous as hashes are in Perl, the DBI API does not
 # offer a way to commit hashes to disk.
 sub fiddle_with_my_data_to_get_it_to_work_with_the_DBI_API {


     my @output_data;
     for (@::order_data) {
         push @output_data, $dbh-&amp;gt;quote
             (
              defined($::uregister-&amp;gt;{$_}) 
              ? $::uregister-&amp;gt;{$_} 
              : $::profile{$_}
              );
    }


    $::INSERT_TERM=join &#39;,&#39;, @output_data;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-empirical-results-empirical-results-span&#34;&gt;&lt;span id=&#34;empirical results&#34;&gt;Empirical Results&lt;/span&gt;&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;DBI&lt;/th&gt;
&lt;th&gt;DBIx::Recordset&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1.4 seconds (1,2)&lt;/td&gt;
&lt;td&gt;3.7 seconds (3,4)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The average, minimum, and maximum number of seconds required to execute the sample code under DBI and DBIx::Recordset. The code was run on a database of 250 users.&lt;/p&gt;

&lt;h3 id=&#34;span-id-conclusion-conclusion-span&#34;&gt;&lt;span id=&#34;conclusion&#34;&gt;Conclusion&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;DBI accelerated past the ODBC API for database interface because it was simpler and more portable. Because DBIx::Recordset is built on top of DBI, it maintains these advantages and improves upon DBI&amp;rsquo;s simplicity. Because it also adds much-needed application-level features to DBI, it is a clear choice for database driven Perl applications.&lt;/p&gt;

&lt;p&gt;A strong contender for an improvement of DBI is the recent effort by Simon Matthews to simplify DBI use via a Template Toolkit plugin. Many of the advantages of DBIx::Recordset are available to the DBI plugin either intrinsically or due to the context in which it was developed. For example, DBIx::Recordset allows filtering of recordsets through the !Filter key to its database processing functions. The plugin did not have to provide filtering because there are several generic, widely useful filters (e.g., HTML, date, etc.) already available for Template Toolkit. However, Matthew&amp;rsquo;s DBI plugin uses the same level of abstraction as DBI. This shortcoming, along with the plug-in&amp;rsquo;s lack of application-level databasing conveniences, lands the plugin in the same functional boat as DBI with only nicer syntax to pad the same troublesome ride.&lt;/p&gt;

&lt;p&gt;That being said, DBI is preferable to DBIx::Recordset when speed is of utmost importance. DBI&amp;rsquo;s speed advantage is due to several factors &lt;a href=&#34;#8&#34;&gt;(8)&lt;/a&gt;. First DBIx::Recordset is built on the DBI API and thus one has the overhead of at least one additional function call per application-level database command. Secondly, it takes time for DBIx::Recordset to decode its compact input algebra and produce well-formed SQL.&lt;/p&gt;

&lt;p&gt;All theory aside, my experience and the timing results show that you don&amp;rsquo;t lose more than a second or two when you reach for DBIx::Recordset instead of DBI. Such a slowdown is acceptable in light of what DBIx::Recordset offers over DBI: speed of development, power of expression and availability of standard and necessary application-level functionality.&lt;/p&gt;

&lt;p&gt;Even if time constraints do lead one to decide that DBIx::Recordset is inappropriate for a finished product because it is slightly slower than DBI, it can prove especially handy during early prototyping or when one is solving a complex problem and wants to focus on the flow of recordsets as opposed to the mechanics of managing this flow.&lt;/p&gt;

&lt;h4 id=&#34;span-id-acknowledgements-acknowledgements-span&#34;&gt;&lt;span id=&#34;acknowledgements&#34;&gt;Acknowledgements&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;I would like to thank Gerald Richter (&lt;a href=&#34;mailto:richter@ecos.de&#34;&gt;richter@ecos.de&lt;/a&gt;) for authoring DBIx::Recordset, commenting on an early version of this manuscript as well as providing me and others with free help on his great tool.&lt;/p&gt;

&lt;h4 id=&#34;footnotes&#34;&gt;Footnotes&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;span id=&#34;1&#34;&gt;Actually, the DBI code is not equivalent to the DBIx::Recordset code because connection and database operations are always separate calls to the DBI API. The additional work required to use DBI has been omitted for brevity.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&#34;2&#34;&gt;The DBIx::Recordset code is also more accurate because it uses database metadata to determine which data to quote, while DBI uses string-based heuristics.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&#34;3&#34;&gt;DBIx::Recordset can be automatic and simple, but, you can also operate in a more manual mode to afford yourself time/space efficiency on the same order as DBI.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&#34;4&#34;&gt;More precisely, each row in the recordset is an anonymous hash which is referred to by one element of an array whose name is determined by the typeglob bound during the call to the Search() function.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&#34;5&#34;&gt;I can&amp;rsquo;t wait to see the next generation of obfuscated Perl now that major database operations only take one line!&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&#34;6&#34;&gt;Be this alteration done by friend or foe.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&#34;7&#34;&gt;Now admittedly, the transfer of a CGI query string into a hash is non-standard as well, but, most high-end web application frameworks for Perl (e.g. HTML::Embperl and HTML::Mason) provide this transfer automatically as part of their application-level API to web site development.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&#34;8&#34;&gt;Maybe that&amp;rsquo;s why there&amp;rsquo;s a cheetah on the front of the DBI book&lt;/span&gt;.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>

