<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dave Cross on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/authors/dave-cross/</link>
    <description>Recent content in Dave Cross on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 10 Aug 2004 00:00:00 -0800</lastBuildDate>
    <atom:link href="/authors/dave-cross/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Perl Command-Line Options</title>
      <link>http://localhost:1313/pub/2004/08/09/commandline.html/</link>
      <pubDate>Tue, 10 Aug 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/08/09/commandline.html/</guid>
      <description>

&lt;p&gt;Perl has a large number of command-line options that can help to make your programs more concise and open up many new possibilities for one-off command-line scripts using Perl. In this article we&amp;rsquo;ll look at some of the most useful of these.&lt;/p&gt;

&lt;h3 id=&#34;span-id-safety-net-options-safety-net-options-span&#34;&gt;&lt;span id=&#34;Safety_Net_Options&#34;&gt;Safety Net Options&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;There are three options I like to think of as a &amp;ldquo;safety net,&amp;rdquo; as they can stop you from making a fool of yourself when you&amp;rsquo;re doing something particularly clever (or stupid!). And while they aren&amp;rsquo;t ever necessary, it&amp;rsquo;s rare that you&amp;rsquo;ll find an experienced Perl programmer working without them.&lt;/p&gt;

&lt;p&gt;The first of these is &lt;code&gt;-c&lt;/code&gt;. This option compiles your program without running it. This is a great way to ensure that you haven&amp;rsquo;t introduced any syntax errors while you&amp;rsquo;ve been editing a program. When I&amp;rsquo;m working on a program I never go more than a few minutes without saving the file and running:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ perl -c &amp;lt;program&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This makes sure that the program still compiles. It&amp;rsquo;s far easier to fix problems when you&amp;rsquo;ve only made a few changes than it is to type in a couple of hundred of lines of code and then try to debug that.&lt;/p&gt;

&lt;p&gt;The next safety net is the &lt;code&gt;-w&lt;/code&gt; option. This turns on warnings that Perl will then give you if it finds any of a number of problems in your code. Each of these warnings is a potential bug in your program and should be investigated. In modern versions of Perl (since 5.6.0) the &lt;code&gt;-w&lt;/code&gt; option has been replaced by the &lt;code&gt;use warnings&lt;/code&gt; pragma, which is more flexible than the command-line option so you shouldn&amp;rsquo;t use &lt;code&gt;-w&lt;/code&gt; in new code.&lt;/p&gt;

&lt;p&gt;The final safety net is the &lt;code&gt;-T&lt;/code&gt; option. This option puts Perl into &amp;ldquo;taint mode.&amp;rdquo; In this mode, Perl inherently distrusts any data that it receives from outside the program&amp;rsquo;s source &amp;ndash; for example, data passed in on the command line, read from a file, or taken from CGI parameters.&lt;/p&gt;

&lt;p&gt;Tainted data cannot be used in an expression that interacts with the outside world &amp;ndash; for example, you can&amp;rsquo;t use it in a call to &lt;code&gt;system&lt;/code&gt; or as the name of a file to open. The full list of restrictions is given in the &lt;code&gt;perlsec&lt;/code&gt; manual page.&lt;/p&gt;

&lt;p&gt;In order to use this data in any of these potentially dangerous operations you need to untaint it. You do this by checking it against a regular expression. A detailed discussion of taint mode would fill an article all by itself so I won&amp;rsquo;t go into any more details here, but using taint mode is a very good habit to get into &amp;ndash; particularly if you are writing programs (like CGI programs) that take unknown input from users.&lt;/p&gt;

&lt;p&gt;Actually there&amp;rsquo;s one other option that belongs in this set and that&amp;rsquo;s &lt;code&gt;-d&lt;/code&gt;. This option puts you into the Perl debugger. This is also a subject that&amp;rsquo;s too big for this article, but I recommend you look at &amp;ldquo;perldoc perldebug&amp;rdquo; or Richard Foley&amp;rsquo;s &lt;em&gt;Perl Debugger Pocket Reference&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-command-line-programs-command-line-programs-span&#34;&gt;&lt;span id=&#34;Command_Line_Programs&#34;&gt;Command-Line Programs&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The next few options I want to look at make it easy to run short Perl programs on the command line. The first one, &lt;code&gt;-e&lt;/code&gt;, allows you to define Perl code to be executed by the compiler. For example, it&amp;rsquo;s not necessary to write a &amp;ldquo;Hello World&amp;rdquo; program in Perl when you can just type this at the command line.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ perl -e &#39;print &amp;quot;Hello World\n&amp;quot;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can have as many &lt;code&gt;-e&lt;/code&gt; options as you like and they will be run in the order that they appear on the command line.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ perl -e &#39;print &amp;quot;Hello &amp;quot;;&#39; -e &#39;print &amp;quot;World\n&amp;quot;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that like a normal Perl program, all but the last line of code needs to end with a &lt;code&gt;;&lt;/code&gt; character.&lt;/p&gt;

&lt;p&gt;Although it is possible to use a &lt;code&gt;-e&lt;/code&gt; option to load a module, Perl gives you the &lt;code&gt;-M&lt;/code&gt; option to make that easier.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ perl -MLWP::Simple -e&#39;print head &amp;quot;http://www.example.com&amp;quot;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So &lt;code&gt;-Mmodule&lt;/code&gt; is the same as &lt;code&gt;use module&lt;/code&gt;. If the module has default imports you don&amp;rsquo;t want imported then you can use &lt;code&gt;-m&lt;/code&gt; instead. Using &lt;code&gt;-mmodule&lt;/code&gt; is the equivalent of &lt;code&gt;use module()&lt;/code&gt;, which turns off any default imports. For example, the following command displays nothing as the &lt;code&gt;head&lt;/code&gt; function won&amp;rsquo;t have been imported into your &lt;code&gt;main&lt;/code&gt; package:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ perl -mLWP::Simple -e&#39;print head &amp;quot;http://www.example.com&amp;quot;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;-M&lt;/code&gt; and &lt;code&gt;-m&lt;/code&gt; options implement various nice pieces of syntactic sugar to make using them as easy as possible. Any arguments you would normally pass to the &lt;code&gt;use&lt;/code&gt; statement can be listed following an &lt;code&gt;=&lt;/code&gt; sign.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ perl -MCGI=:standard -e&#39;print header&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command imports the &amp;ldquo;:standard&amp;rdquo; export set from CGI.pm and therefore the &lt;code&gt;header&lt;/code&gt; function becomes available to your program. Multiple arguments can be listed using quotes and commas as separators.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ perl -MCGI=&#39;header,start_html&#39; -e&#39;print header, start_html&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example we&amp;rsquo;ve just imported the two methods &lt;code&gt;header&lt;/code&gt; and &lt;code&gt;start_html&lt;/code&gt; as those are the only ones we are using.&lt;/p&gt;

&lt;h3 id=&#34;span-id-implicit-loops-implicit-loops-span&#34;&gt;&lt;span id=&#34;Implicit_Loops&#34;&gt;Implicit Loops&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Two other command-line options, &lt;code&gt;-n&lt;/code&gt; and &lt;code&gt;-p&lt;/code&gt;, add loops around your &lt;code&gt;-e&lt;/code&gt; code. They are both very useful for processing files a line at a time. If you type something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ perl -n -e &#39;some code&#39; file1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then Perl will interpret that as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  LINE:
    while (&amp;lt;&amp;gt;) {
      # your code goes here
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice the use of the empty file input operator, which will read all of the files given on the command line a line at a time. Each line of the input files will be put, in turn, into &lt;code&gt;$_&lt;/code&gt; so that you can process it. As a example, try:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ perl -n -e &#39;print &amp;quot;$. - $_&amp;quot;&#39; file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This gets converted to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  LINE:
    while (&amp;lt;&amp;gt;) {
      print &amp;quot;$. - $_&amp;quot;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code prints each line of the file together with the current line number.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;-p&lt;/code&gt; option makes that even easier. This option always prints the contents of &lt;code&gt;$_&lt;/code&gt; each time around the loop. It creates code like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  LINE:
    while (&amp;lt;&amp;gt;) {
      # your code goes here
    } continue {
      print or die &amp;quot;-p destination: $!\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This uses the little-used &lt;code&gt;continue&lt;/code&gt; block on a &lt;code&gt;while&lt;/code&gt; loop to ensure that the &lt;code&gt;print&lt;/code&gt; statement is always called.&lt;/p&gt;

&lt;p&gt;Using this option, our line number generator becomes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ perl -p -e &#39;$_ = &amp;quot;$. - $_&amp;quot;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case there is no need for the explicit call to print as &lt;code&gt;-p&lt;/code&gt; calls &lt;code&gt;print&lt;/code&gt; for us.&lt;/p&gt;

&lt;p&gt;Notice that the &lt;code&gt;LINE:&lt;/code&gt; label is there so that you can easily move to the next input record no matter how deep in embedded loops you are. You do this using &lt;code&gt;next LINE&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ perl -n -e &#39;next LINE unless /pattern/; print $_&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, that example would probably be written as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ perl -n -e &#39;print unless /pattern/&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But in a more complex example, the &lt;code&gt;next LINE&lt;/code&gt; construct could potentially make your code easier to understand.&lt;/p&gt;

&lt;p&gt;If you need to have processing carried out either before or after the main code loop, you can use a &lt;code&gt;BEGIN&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt; block. Here&amp;rsquo;s a pretty basic way to count the words in a text file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ perl -ne &#39;END { print $t } @w = /(\w+)/g; $t += @w&#39; file.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each time round the loop we extract all of the words (defined as contiguous runs of &lt;code&gt;\w&lt;/code&gt; characters into &lt;code&gt;@w&lt;/code&gt; and add the number of elements in &lt;code&gt;@w&lt;/code&gt; to our total variable &lt;code&gt;$t&lt;/code&gt;. The &lt;code&gt;END&lt;/code&gt; block runs after the loop has completed and prints out the final value in &lt;code&gt;$t&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Of course, people&amp;rsquo;s definition of what constitutes a valid word can vary. The definition used by the Unix &lt;code&gt;wc&lt;/code&gt; (word count) program is a string of characters delimited by whitespace. We can simulate that by changing our program slightly, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ perl -ne &#39;END { print $x } @w = split; $x += @w&#39; file.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But there are a couple of command-line options that will make that even simpler. Firstly the &lt;code&gt;-a&lt;/code&gt; option turns on &lt;em&gt;autosplit&lt;/em&gt; mode. In this mode, each input record is split and the resulting list of elements is stored in an array called &lt;code&gt;@F&lt;/code&gt;. This means that we can write our word-count program like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ perl -ane &#39;END {print $x} $x += @F&#39; file.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The default value used to split the record is one or more whitespace characters. It is, of course, possible that you might want to split the input record on another character and you can control this with the &lt;code&gt;-F&lt;/code&gt; option. So if we wanted to change our program to split on all non-word characters we could do something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ perl -F&#39;\W&#39; -ane &#39;END {print $x} $x += @F&#39; file.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For a more powerful example of what we can do with these options, let&amp;rsquo;s look at the Unix password file. This is a simple, colon-delimited text file with one record per user. The seventh column in this file is the path of the login shell for that user. We can therefore produce a report of the most-used shells on a given system with a command-line script like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ perl -F&#39;:&#39; -ane &#39;$s{$F[6]}++;&#39; \
  &amp;gt; -e &#39;END { print &amp;quot;$_ : $s{$_}&amp;quot; for keys %s }&#39; /etc/passwd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK, so it&amp;rsquo;s longer than one line and the output isn&amp;rsquo;t sorted (although it&amp;rsquo;s quite easy to add sorting), but perhaps you can get a sense of the kinds of things that you can do from the command line.&lt;/p&gt;

&lt;h3 id=&#34;span-id-record-separators-record-separators-span&#34;&gt;&lt;span id=&#34;Record_Separators&#34;&gt;Record Separators&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In my previous article I talked a lot about &lt;code&gt;$/&lt;/code&gt; and &lt;code&gt;$\&lt;/code&gt; &amp;ndash; the input and output record separators. &lt;code&gt;$/&lt;/code&gt; defines how much data Perl will read every time you ask it for the next record from a filehandle, and &lt;code&gt;$\&lt;/code&gt; contains a value that is appended to the end of any data that your program prints. The default value of &lt;code&gt;$/&lt;/code&gt; is a new line and the default value of &lt;code&gt;$\&lt;/code&gt; is an empty string (which is why you usually explicity add a new line to your calls to &lt;code&gt;print&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Now in the implicit loops set up by &lt;code&gt;-n&lt;/code&gt; and &lt;code&gt;-p&lt;/code&gt; it can be useful to define the values of &lt;code&gt;$/&lt;/code&gt; and &lt;code&gt;$\&lt;/code&gt;. You could, of course, do this in a &lt;code&gt;BEGIN&lt;/code&gt; block, but Perl gives you an easier option with the &lt;code&gt;-0&lt;/code&gt; (that&amp;rsquo;s a zero) and &lt;code&gt;-l&lt;/code&gt; (that&amp;rsquo;s an L) command-line options. This can get a little confusing (well, it confuses me) so I&amp;rsquo;ll go slowly.&lt;/p&gt;

&lt;p&gt;Using &lt;code&gt;-0&lt;/code&gt; and giving it a hexadecimal or octal number sets &lt;code&gt;$/&lt;/code&gt; to that value. The special value &lt;code&gt;00&lt;/code&gt; puts Perl in paragraph mode and the special value &lt;code&gt;0777&lt;/code&gt; puts Perl into file slurp mode. These are the same as setting &lt;code&gt;$/&lt;/code&gt; to an empty string and &lt;code&gt;undef&lt;/code&gt; respectively.&lt;/p&gt;

&lt;p&gt;Using &lt;code&gt;-l&lt;/code&gt; and giving it no value has two effects. Firstly, it automatically &lt;code&gt;chomp&lt;/code&gt;s the input record, and secondly, it sets &lt;code&gt;$\&lt;/code&gt; equal to &lt;code&gt;$/&lt;/code&gt;. If you give &lt;code&gt;-l&lt;/code&gt; an octal number (and unlike &lt;code&gt;-0&lt;/code&gt; it doesn&amp;rsquo;t accept hex numbers) it sets &lt;code&gt;$\&lt;/code&gt; to the character represented by that number and also turns on auto-&lt;code&gt;chomp&lt;/code&gt;ing.&lt;/p&gt;

&lt;p&gt;To be honest, I rarely use the &lt;code&gt;-0&lt;/code&gt; option and I usually use the &lt;code&gt;-l&lt;/code&gt; option without an argument just to add a new line to the end of each line of output. For example, I&amp;rsquo;d usually write my original &amp;ldquo;Hello World&amp;rdquo; example as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ perl -le &#39;print &amp;quot;Hello World&amp;quot;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If I&amp;rsquo;m doing something that requires changing the values of the input and output record separators then I&amp;rsquo;m probably out of the realm of command-line scripts.&lt;/p&gt;

&lt;h3 id=&#34;span-id-in-place-editing-in-place-editing-span&#34;&gt;&lt;span id=&#34;In-Place_Editing&#34;&gt;In-Place Editing&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;With the options that we have already seen, it&amp;rsquo;s very easy to build up some powerful command-line programs. It&amp;rsquo;s very common to see command line programs that use Unix I/O redirection like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ perl -pe &#39;some code&#39; &amp;lt; input.txt &amp;gt; output.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This takes records from &lt;code&gt;input.txt&lt;/code&gt;, carries out some kind of transformation, and writes the transformed record to &lt;code&gt;output.txt&lt;/code&gt;. In some cases you don&amp;rsquo;t want to write the changed data to a different file, it&amp;rsquo;s often more convenient if the altered data is written back to the same file.&lt;/p&gt;

&lt;p&gt;You can get the appearance of this using the &lt;code&gt;-i&lt;/code&gt; option. Actually, Perl renames the input file and reads from this renamed version while writing to a new file with the original name. If &lt;code&gt;-i&lt;/code&gt; is given a string argument, then that string is appended to the name of the original version of the file. For example, to change all occurrences of &amp;ldquo;PHP&amp;rdquo; to &amp;ldquo;Perl&amp;rdquo; in a data file you could write something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ perl -i -pe &#39;s/\bPHP\b/Perl/g&#39; file.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perl reads the input file a line at a time, making the substitution, and then writing the results back to a new file that has the same name as the original file &amp;ndash; effectively overwriting it. If you&amp;rsquo;re not so confident of your Perl abilities you might take a backup of the original file, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $perl -i.bak -pe &#39;s/\bPHP\b/Perl/g&#39; file.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;ll end up with the transformed data in &lt;code&gt;file.txt&lt;/code&gt; and the original file backed up in &lt;code&gt;file.txt.bak&lt;/code&gt;. If you&amp;rsquo;re a fan of vi then you might like to use &lt;code&gt;-i~&lt;/code&gt; instead.&lt;/p&gt;

&lt;h3 id=&#34;span-id-further-information-further-information-span&#34;&gt;&lt;span id=&#34;Further_Information&#34;&gt;Further Information&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Perl has a large number of command-line options. This article has simply listed a few of the most useful. For the full list (and for more information on the ones covered here) see the &amp;ldquo;perlrun&amp;rdquo; manual page.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Perl&#39;s Special Variables</title>
      <link>http://localhost:1313/pub/2004/06/18/variables.html/</link>
      <pubDate>Fri, 18 Jun 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/06/18/variables.html/</guid>
      <description>

&lt;p&gt;One of the best ways to make your Perl code look more like &amp;hellip; well, like Perl code &amp;ndash; and not like C or BASIC or whatever you used before you were introduced to Perl &amp;ndash; is to get to know the internal variables that Perl uses to control various aspects of your program&amp;rsquo;s execution.&lt;/p&gt;

&lt;p&gt;In this article we&amp;rsquo;ll take a look at a number of variables that give you finer control over your file input and output.&lt;/p&gt;

&lt;h3 id=&#34;span-id-counting-lines-counting-lines-span&#34;&gt;&lt;span id=&#34;Counting_Lines&#34;&gt;Counting Lines&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;I decided to write this article because I am constantly amazed by the number of people who don&amp;rsquo;t know about the existence of &lt;code&gt;$.&lt;/code&gt;. I still see people producing code that looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my $line_no = 0;

  while (&amp;lt;FILE&amp;gt;) {
    ++$line_no;
    unless (/some regex/) {
      warn &amp;quot;Error in line $line_no\n&amp;quot;;
      next;
    }

    # process the record in some way
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For some reason, many people seem to completely miss the existence of &lt;code&gt;$.&lt;/code&gt;, which is Perl&amp;rsquo;s internal variable that keeps track of your current record number. The code above can be rewritten as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  while (&amp;lt;FILE&amp;gt;) {
    unless (/some regex/) {
      warn &amp;quot;Error in line $.\n&amp;quot;;
      next;
    }

    # process the record in some way
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I know that it doesn&amp;rsquo;t actually save you very much typing, but why create a new variable if you don&amp;rsquo;t have to?&lt;/p&gt;

&lt;p&gt;One other nice way to use &lt;code&gt;$.&lt;/code&gt; is in conjunction with Perl&amp;rsquo;s &amp;ldquo;flip-flop&amp;rdquo; operator (&lt;code&gt;..&lt;/code&gt;). When used in list context, &lt;code&gt;..&lt;/code&gt; is the list construction operator. It builds a list of elements by calculating all of the items between given start and end values like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my @numbers = (1 .. 1000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But when you use this operator in a scalar context (like, for example, as the condition of an &lt;code&gt;if&lt;/code&gt; statement), its behavior changes completely. The first operand (the left-hand expression) is evaluated to see if it is true or false. If it is false then the operator returns false and nothing happens. If it is true, however, the operator returns true and &lt;em&gt;continues&lt;/em&gt; to return true on subsequent calls until the second operand (the right-hand expression) returns true.&lt;/p&gt;

&lt;p&gt;An example will hopefully make this clearer. Suppose you have a file and you only want to process certain sections of it. The sections that you want to print are clearly marked with the string &amp;ldquo;!! START !!&amp;rdquo; at the start and &amp;ldquo;!! END !!&amp;rdquo; at the end. Using the flip-flop operator you can write code like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  while (&amp;lt;FILE&amp;gt;) {
    if (/!! START !!/ .. /!! END !!/) {
      # process line
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each time around the loop, the current line is checked by the flip-flop operator. If the line doesn&amp;rsquo;t match &lt;code&gt;/!! START !!/&lt;/code&gt; then the operator returns false and the loop continues. When we reach the first line that matches &lt;code&gt;/!! START !!/&lt;/code&gt; then the flip-flop operator returns true and the code in the &lt;code&gt;if&lt;/code&gt; block is executed. On subsequent iterations of the &lt;code&gt;while&lt;/code&gt; loop, the flip-flop operator checks for matches again &lt;code&gt;/!! END !!/&lt;/code&gt;, but it continues to return true until it finds a match. This means that all of the lines between the &amp;ldquo;!! START !!&amp;rdquo; and &amp;ldquo;!! END !!&amp;rdquo; markers are processed. When a line matches &lt;code&gt;/!! END !!/&lt;/code&gt; then the flip-flop operator returns false and starts checking against the first regex again.&lt;/p&gt;

&lt;p&gt;So what does all this have to do with &lt;code&gt;$.&lt;/code&gt;? Well, there&amp;rsquo;s another piece of magic coded into the flip-flop operator. If either of its operands are constant values then they are converted to integers and matched against &lt;code&gt;$.&lt;/code&gt;. So to print out just the first 10 lines of a file you can write code like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  while (&amp;lt;FILE&amp;gt;) {
    print if 1 .. 10;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One final point on &lt;code&gt;$.&lt;/code&gt;, there is only one &lt;code&gt;$.&lt;/code&gt; variable. If you are reading from multiple filehandles then &lt;code&gt;$.&lt;/code&gt; contains the current record number from the most recently read filehandle. If you want anything more complex then you can use something like IO::File objects for your filehandle. These objects all have an &lt;code&gt;input_line_number&lt;/code&gt; method.&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-field-record-separators-the-field-record-separators-span&#34;&gt;&lt;span id=&#34;The_Field_Record_Separators&#34;&gt;The Field Record Separators&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Next, we&amp;rsquo;ll look at &lt;code&gt;$/&lt;/code&gt; and &lt;code&gt;$\&lt;/code&gt; which are the input and output record separators respectively. They control what defines a &amp;ldquo;record&amp;rdquo; when you are reading or writing data.&lt;/p&gt;

&lt;p&gt;Let me explain that in a bit more detail. Remember when you were first learning Perl and you were introduced to the file input operator. Almost certainly you were told that &lt;code&gt;&amp;lt;FILE&amp;gt;&lt;/code&gt; read data from the file up to and including the next newline character. Well that&amp;rsquo;s not true. Well, it is, but it&amp;rsquo;s only a specialized case. Actually it reads data up to and including the next occurrence of whatever is currently in &lt;code&gt;$/&lt;/code&gt; - the file input separator. Let&amp;rsquo;s look at an example.&lt;/p&gt;

&lt;p&gt;Imagine you have a text file which contains amusing quotes. Or lyrics from songs. Or whatever it is that you like to put in your randomly generated signature. The file might look something like this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    This is the definition of my life
  %%
    We are far too young and clever
  %%
    Stab a sorry heart
    With your favorite finger
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have three quotes separated by a line containing just the string &lt;code&gt;%%&lt;/code&gt;. How would you go about reading in that file a quote at a time?&lt;/p&gt;

&lt;p&gt;One solution would be to read the file a line at a time, checking to see if the new line is just the string &lt;code&gt;%%&lt;/code&gt;. You&amp;rsquo;d need to keep a variable that contains current quote that you are building up and process a completed quote when you find the termination string. Oh, and you&amp;rsquo;d need to remember to process the last quote in the file as that doesn&amp;rsquo;t have a termination string (although, it might!)&lt;/p&gt;

&lt;p&gt;A simpler solution would be to change Perl&amp;rsquo;s idea of what constitutes a record. We do that by changing the value of &lt;code&gt;$/&lt;/code&gt;. The default value is a newline character - which is why &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; usually reads in a line at a time. But we can set it to any value we like. We can do something like this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $/ = &amp;quot;%%\n&amp;quot;;

  while (&amp;lt;QUOTE&amp;gt;) {
    chomp;
    print;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now each time we call the file input operator, Perl reads data from the filehandle until it finds &lt;code&gt;%%\n&lt;/code&gt; (or the end of file marker). A newline is no longer seen as a special character. Notice, however, that the file input operator always returns the next record with the file input separator still attached. When &lt;code&gt;$/&lt;/code&gt; has its default value of a newline character, you know that you can remove the newline character by calling &lt;code&gt;chomp&lt;/code&gt;. Well it works exactly the same way when &lt;code&gt;$/&lt;/code&gt; has other values. It turns out that &lt;code&gt;chomp&lt;/code&gt; doesn&amp;rsquo;t just remove a newline character (that&amp;rsquo;s another &amp;ldquo;simplification&amp;rdquo; that you find in beginners books) it actually removes whatever is the current value of &lt;code&gt;$/&lt;/code&gt;. So in our sample code above, the call to &lt;code&gt;chomp&lt;/code&gt; is removing the whole string &lt;code&gt;%%\n&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-changing-perl-s-special-variables-changing-perl-s-special-variables-span&#34;&gt;&lt;span id=&#34;Changing_Perl&#39;s_Special_Variables&#34;&gt;Changing Perl&amp;rsquo;s Special Variables&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Before we go on I just need to alert you to one possible repercussion of changing these variables whenever you want. The problem is that most of these variables are forced into the &lt;code&gt;main&lt;/code&gt; package. This means that when you change one of these variables, you are altering the value everywhere in your program. This includes any modules that you use in your program. The reverse is also true. If you&amp;rsquo;re writing a module that other people will use in their programs and you change the value of &lt;code&gt;$/&lt;/code&gt; inside it, then you have changed the value for all of the remaining program execution. I hope you can seen why changing variables like &lt;code&gt;$/&lt;/code&gt; in one part of your program can potentially lead to hard to find bugs in another part.&lt;/p&gt;

&lt;p&gt;So we need to do what we can to avoid this. Your first approach might be to reset the value of &lt;code&gt;$/&lt;/code&gt; after you have finished with it. So you&amp;rsquo;d write code like this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $/ = &amp;quot;%%\n&amp;quot;;

  while (&amp;lt;QUOTE&amp;gt;) {
    chomp;
    print;
  }

  $/ = &amp;quot;\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem with this is you can&amp;rsquo;t be sure that &lt;code&gt;$/&lt;/code&gt; contained &lt;code&gt;\n&lt;/code&gt; before you started fiddling with it. Someone else might have changed it before your code was reached. So the next attempt might look like this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $old_input_rec_sep = $/;
  $/ = &amp;quot;%%\n&amp;quot;;

  while (&amp;lt;QUOTE&amp;gt;) {
    chomp;
    print;
  }

  $/ = $old_input_rec_sep;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code works and doesn&amp;rsquo;t have the bug that we&amp;rsquo;re trying to avoid but there&amp;rsquo;s another way that looks cleaner. Remember the &lt;code&gt;local&lt;/code&gt; function that you used to declare local variables until someone told you that you should use &lt;code&gt;my&lt;/code&gt; instead? Well this is one of the few places where you can use &lt;code&gt;local&lt;/code&gt; to great effect.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s generally acknowledged that &lt;code&gt;local&lt;/code&gt; is badly named. The name doesn&amp;rsquo;t describe what the function does. In Perl 6 the function is likely to be renamed to &lt;code&gt;temp&lt;/code&gt; as that&amp;rsquo;s a far better description of what it does - it creates a temporary variable with the same name as an existing variable and restores the original variable when the program leaves the innermost enclosing block. This means that we can write our code like this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  {
    local $/ = &amp;quot;%%\n&amp;quot;;

    while (&amp;lt;QUOTE&amp;gt;) {
      chomp;
      print;
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ve enclosed all of the code in another pair of braces to create a &lt;em&gt;naked block&lt;/em&gt;. Code blocks are usually associated with loops, conditionals or subroutines, but in Perl they don&amp;rsquo;t need to be. You can introduce a new block whenever you want. Here, we&amp;rsquo;ve introduced a block purely to delimit the area where we want &lt;code&gt;$/&lt;/code&gt; to have a new value. We then use &lt;code&gt;local&lt;/code&gt; to store the old &lt;code&gt;$/&lt;/code&gt; variable somewhere where it can&amp;rsquo;t be disturbed and set our new version of the variable to &lt;code&gt;%%\n&lt;/code&gt;. We can then do whatever we want in the code block and when we exit from the block, Perl automatically restores the original copy of &lt;code&gt;$/&lt;/code&gt; and we never needed to know what it was set to.&lt;/p&gt;

&lt;p&gt;For all this reason, it&amp;rsquo;s good practice to never change one of Perl&amp;rsquo;s internal variables unless it is localized in a block.&lt;/p&gt;

&lt;h4 id=&#34;span-id-other-values-for-other-values-for-span&#34;&gt;&lt;span id=&#34;Other_Values_For_$/&#34;&gt;Other Values For $/&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;There are a few special values that you can give &lt;code&gt;$/&lt;/code&gt; which turn on interesting behaviours. The first of these is setting it to &lt;code&gt;undef&lt;/code&gt;. This turns on &amp;ldquo;slurp mode&amp;rdquo; and the next time you read from a filehandle you will get all of the remaining data right up to the end of file marker. This means that you can read a whole file in using code like this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my $file = do { local $/; &amp;lt;FILE&amp;gt; };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;do&lt;/code&gt; block returns the value of the last expression evaluated within it, which in this case is the file input operator. And as &lt;code&gt;$/&lt;/code&gt; has been set to &lt;code&gt;undef&lt;/code&gt; it returns the whole file. Notice that we don&amp;rsquo;t even need to explicitly set &lt;code&gt;$/&lt;/code&gt; to &lt;code&gt;undef&lt;/code&gt; as all Perl variables are initialized to &lt;code&gt;undef&lt;/code&gt; when they are created.&lt;/p&gt;

&lt;p&gt;There is a big difference between setting &lt;code&gt;$/&lt;/code&gt; to &lt;code&gt;undef&lt;/code&gt; and setting it to an empty string. Setting it to an empty string turns on &amp;ldquo;paragraph&amp;rdquo; mode. In this mode each record is a paragraph of text terminated by one or more empty lines. You might think that this effect can be mimicked by setting &lt;code&gt;$/&lt;/code&gt; to &lt;code&gt;\n\n&lt;/code&gt;, but the subtle difference is that paragraph mode acts as thought &lt;code&gt;$/&lt;/code&gt; had been set to &lt;code&gt;\n\n+&lt;/code&gt; (although you can&amp;rsquo;t actually set &lt;code&gt;$/&lt;/code&gt; equal to a regular expression.)&lt;/p&gt;

&lt;p&gt;The final special value is to set &lt;code&gt;$/&lt;/code&gt; to either a reference to a scalar variable that holds an integer, or to a reference to an integer constant. In these cases the next read from a filehandle will read up to that number of bytes (I say &amp;ldquo;up to&amp;rdquo; because at the end of the file there might not be enough data left to give you). So you read a file 2Kb at a time and you can do this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  {
    local $/ = \2048;

    while (&amp;lt;FILE&amp;gt;) {
      # $_ contains the next 2048 bytes from FILE
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-and-and-span&#34;&gt;&lt;span id=&#34;$/_and_$.&#34;&gt;$/ and $.&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Note that changing &lt;code&gt;$/&lt;/code&gt; alters Perl&amp;rsquo;s definition of a record and therefore it alters the behavior of &lt;code&gt;$.&lt;/code&gt;. &lt;code&gt;$.&lt;/code&gt; doesn&amp;rsquo;t actually contain the current line number, it contains the current &lt;em&gt;record&lt;/em&gt; number. So in our quotes example above, &lt;code&gt;$.&lt;/code&gt; will be incremented for each quote that you read from the filehandle.&lt;/p&gt;

&lt;h4 id=&#34;span-id-what-about-what-about-span&#34;&gt;&lt;span id=&#34;What_About_$\?&#34;&gt;What About $\?&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Many paragraphs back I mentioned both &lt;code&gt;$/&lt;/code&gt; and &lt;code&gt;$\&lt;/code&gt; as being the input and output record separators. But since then I&amp;rsquo;ve just gone on about &lt;code&gt;$/&lt;/code&gt;. What happened to &lt;code&gt;$\&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Well, to be honest, &lt;code&gt;$\&lt;/code&gt; isn&amp;rsquo;t anywhere near as useful as &lt;code&gt;$/&lt;/code&gt;. It contains a string that is printed at the end of every call to &lt;code&gt;print&lt;/code&gt;. Its default value is the empty string, so nothing gets added to data that you display with &lt;code&gt;print&lt;/code&gt;. But if, for example, you longed for the days of Pascal you could write a &lt;code&gt;println&lt;/code&gt; function like this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  sub println {
    local $\ = &amp;quot;\n&amp;quot;;
    print @_;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then every time you called &lt;code&gt;println&lt;/code&gt;, all of the arguments would be printed followed by a newline.&lt;/p&gt;

&lt;h3 id=&#34;span-id-other-print-variables-other-print-variables-span&#34;&gt;&lt;span id=&#34;Other_Print_Variables&#34;&gt;Other Print Variables&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The next two variables that I want to discuss are very easily confused although they do completely different things. To illustrate them, consider the following code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my @arr = (1, 2, 3);

  print @arr;
  print &amp;quot;@arr&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, without looking it up do you know what the difference is between the output from the two calls to &lt;code&gt;print&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;The answer is that the first one prints the three elements of the array with nothing separating them (like this - &lt;code&gt;123&lt;/code&gt;) whereas the second one prints the elements separated by spaces (like this - &lt;code&gt;1 2 3&lt;/code&gt;). Why is there a difference?&lt;/p&gt;

&lt;p&gt;The key to understanding it is to look at exactly what is being passed to &lt;code&gt;print&lt;/code&gt; in each case. In the first case &lt;code&gt;print&lt;/code&gt; is passed an array. Perl unrolls that array into a list and &lt;code&gt;print&lt;/code&gt; actually sees the three elements of the array as separate arguments. In the second case, the array is interpolated into a double quoted string before &lt;code&gt;print&lt;/code&gt; sees it. That interpolation has nothing at all to do with the call to &lt;code&gt;print&lt;/code&gt;. Exactly the same process would take place if, for example, we did something like this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my $string = &amp;quot;@arr&amp;quot;;
  print $string;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So in the second case, the &lt;code&gt;print&lt;/code&gt; function only sees one argument. The fact that it is the results of interpolating an array in double quotes has no effect on how &lt;code&gt;print&lt;/code&gt; treats the string.&lt;/p&gt;

&lt;p&gt;We therefore have two cases. When &lt;code&gt;print&lt;/code&gt; receives a number of arguments it prints them out with no spaces between them. And when an array is interpolated in double quotes it is expanded with spaces between the individual elements. These two cases are completely unrelated, but from our first example above it&amp;rsquo;s easy to see how people can get them confused.&lt;/p&gt;

&lt;p&gt;Of course, Perl allows us to change these behaviors if we want to. The string that is printed between the arguments passed to &lt;code&gt;print&lt;/code&gt; is stored in a variable called &lt;code&gt;$,&lt;/code&gt; (because you use a comma to separate arguments). As we&amp;rsquo;ve seen, the default value for that is an empty string but it can, of course, be changed.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my @arr = (1, 2, 3);
  {
    local $, = &#39;,&#39;;

    print @arr;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code prints the string &lt;code&gt;1,2,3&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The string that separates the elements of an array when expanded in a double quoted string is stored in &lt;code&gt;$&amp;quot;&lt;/code&gt;. Once again, it&amp;rsquo;s simple to change it to a different value.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my @arr = (1, 2, 3);
  {
    local $&amp;quot; = &#39;+&#39;;

    print &amp;quot;@arr&amp;quot;;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code prints &lt;code&gt;1+2+3&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Of course, &lt;code&gt;$&amp;quot;&lt;/code&gt; doesn&amp;rsquo;t necessarily have to used in conjunction with a print statement. You can use it anywhere that you have an array in a doubled quoted string. And it doesn&amp;rsquo;t just work for arrays. Array and hash slices work just as well.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my %hash = (one =&amp;gt; 1, two =&amp;gt; 2, three =&amp;gt; 3);

  {
    local $&amp;quot; = &#39; &amp;lt; &#39;;

    print &amp;quot;@hash{qw(one two three)}&amp;quot;;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This displays &lt;code&gt;1 &amp;lt; 2 &amp;lt; 3&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-conclusion-conclusion-span&#34;&gt;&lt;span id=&#34;Conclusion&#34;&gt;Conclusion&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In this article we&amp;rsquo;ve just scratched the surface of what you can do by changing the values in Perl&amp;rsquo;s internal variables. If this makes you want to look at this subject in more detail, then you should read the &lt;code&gt;perlvar&lt;/code&gt; manual page.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How We Wrote the Template Toolkit Book ...</title>
      <link>http://localhost:1313/pub/2004/01/30/ttbook.html/</link>
      <pubDate>Fri, 30 Jan 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/01/30/ttbook.html/</guid>
      <description>

&lt;p&gt;There are a number of tools available for writing books. Many people would immediately reach for their favorite word processor, but having written one book using Microsoft Word I&amp;rsquo;m very unlikely to repeat the experience. Darren Chamberlain, Andy Wardley, and I are all Perl hackers, so when we got together to write &lt;a href=&#34;http://www.oreilly.com/catalog/perltt/index.html?CMP=IL7015&#34;&gt;Perl Template Toolkit&lt;/a&gt;, it didn&amp;rsquo;t take us long to agree that we wanted to write it using POD (Plain Old Documentation).&lt;/p&gt;

&lt;p&gt;Of course, any chosen format has its pros and cons. With POD we had all the advantages of working with plain text files and all of the existing POD tools were available to convert our text into various other formats, but there were also some disadvantages. These largely stem from the way that books (especially technical books) are written. Authors rarely write the chapters in the order in which they are published in the finished book. In fact, it&amp;rsquo;s very common for the chapters to rearranged a few times before the book is published.&lt;/p&gt;

&lt;p&gt;Now this poses a problem with internal references. It&amp;rsquo;s all very well saying &amp;ldquo;see chapter Six for further details&amp;rdquo;, but when the book is rearranged and Chapter Six becomes Chapter Four, all of these references are broken. Most word processors will allow you to insert these references as &amp;ldquo;tags&amp;rdquo; that get expanded (correctly) as the document is printed. POD and emacs doesn&amp;rsquo;t support this functionality.&lt;/p&gt;

&lt;p&gt;Another common problem with technical books is the discrepancy between the code listings in the book and the code that actually got run to produce the output shown. It&amp;rsquo;s easily done. You create an example program and cut-and-paste the code into the document. You then find a subtle bug in the code and fix it in the version that you&amp;rsquo;re running but forget to fix it in the book. What would be really useful would be if you could just use tags saying &amp;ldquo;insert this program file here&amp;rdquo; and even &amp;ldquo;insert the output of running the program here&amp;rdquo;. That&amp;rsquo;s functionality that no word processor offers.&lt;/p&gt;

&lt;p&gt;Of course, these shortcomings would be simple to solve if you had a powerful templating system at the ready. Luckily Andy, Darren, and I had the Template Toolkit (TT) handy.&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-book-templates-the-book-templates-span&#34;&gt;&lt;span id=&#34;The_Book_Templates&#34;&gt;The Book Templates&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;We produced a series of templates that controlled the book&amp;rsquo;s structure and a Perl program that pulled together each chapter into a single POD file. This program was very similar to the &lt;code&gt;tpage&lt;/code&gt; program that comes with TT, but was specialized for our requirements.&lt;/p&gt;

&lt;h4 id=&#34;span-id-separating-code-from-code-separating-code-from-code-span&#34;&gt;&lt;span id=&#34;Separating_code_from_code&#34;&gt;Separating Code from Code&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;There was one problem we had to address very early on with our book templates. This was the problem of listing TT code within a TT template. We needed a way to distinguish the template directives we were using to produce the book from the template directives we were demonstrating &lt;em&gt;in the book&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Of course TT provides a simple way to achieve this. You can define the characters that TT uses to recognize template directives. By default it looks for &lt;code&gt;[% ... %]&lt;/code&gt;, but there are a number of predefined groups of tags that you can turn on using the &lt;code&gt;TAGS&lt;/code&gt; directive. All of our book templates started with the line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  [% TAGS star %]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When it sees this directive, the TT parser starts to look for template directives that are delimited with &lt;code&gt;[* ... *]&lt;/code&gt;. The default delimiters (&lt;code&gt;[% ... %]&lt;/code&gt;) are treated as plain text and passed through unaltered. Therefore, by using this directive we can use &lt;code&gt;[% ... %]&lt;/code&gt; in our example code and &lt;code&gt;[* ... *]&lt;/code&gt; for the template directives that we wanted TT to process.&lt;/p&gt;

&lt;p&gt;Of course, the page where we introduced the &lt;code&gt;TAGS&lt;/code&gt; directive and gave examples of its usage was still a little complex.&lt;/p&gt;

&lt;p&gt;In the rest of this article, I&amp;rsquo;ll go back to using the &lt;code&gt;[% ... %]&lt;/code&gt; style of tags.&lt;/p&gt;

&lt;h4 id=&#34;span-id-useful-blocks-and-macros-useful-blocks-and-macros-span&#34;&gt;&lt;span id=&#34;Useful_blocks_and_macros&#34;&gt;Useful Blocks and Macros&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;We defined a number of useful blocks and macros that expanded to useful phrases that would be used throughout the book. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  [% TT = &#39;Template Toolkit&#39;;

     versions = {
       stable = &#39;2.10&#39;
       developer = &#39;2.10a&#39;
     } %]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first of these must have saved each of us many hours of typing time and the second gave us an easy way to keep the text up-to-date if Andy released a new version of TT while we were writing the book. A template using these variables might look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  The current stable version of the [% TT %] is [% stable %]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-keeping-track-of-chapters-keeping-track-of-chapters-span&#34;&gt;&lt;span id=&#34;Keeping_track_of_chapters&#34;&gt;Keeping Track of Chapters&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;We used a slightly more complex set of variables and macros to solve the problem of keeping chapter references consistent. First we defined an array that contained details of the chapters (in the current order):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Chapters = [
    {  name  = &#39;intro&#39;
       title = &amp;quot;Introduction to the Template Toolkit&amp;quot;
    }
    {  name  = &#39;web&#39;
       title = &amp;quot;A Simple Web Site&amp;quot;
    }
    {  name  = &#39;language&#39;
       title = &amp;quot;The Template Language&amp;quot;
    }
    {  name  = &#39;directives&#39;
       title = &amp;quot;Template Directives&amp;quot;
    }
    {  name  = &#39;filters&#39;
       title = &amp;quot;Filters&amp;quot;
    }
    {  name  = &#39;plugins&#39;
       title = &amp;quot;Plugins&amp;quot;
    }
    ... etc ...
   ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each entry in this array is a hash with two keys. The name is the name of the directory in our source tree that contains that chapter&amp;rsquo;s files and the title is the human-readable name of the chapter.&lt;/p&gt;

&lt;p&gt;The next step is to convert this into a hash so that we can look up the details of a chapter when given its symbolic name.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    FOREACH c = Chapters;
      c.number = loop.count;
      Chapter.${c.name} = c;
    END;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that we are adding a new key to the hash that describes a chapter. We use the &lt;code&gt;loop.count&lt;/code&gt; variable to set the chapter number. This means that we can reorder our original &lt;code&gt;Chapters&lt;/code&gt; array and the chapter numbers in the &lt;code&gt;Chapter&lt;/code&gt; hash will always remain accurate.&lt;/p&gt;

&lt;p&gt;Using this hash, it&amp;rsquo;s now simple to create a macro that lets us reference chapters. It looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  MACRO chref(id) BLOCK;
    THROW chapter &amp;quot;invalid chapter id: $id&amp;quot;
      UNLESS (c = Chapter.$id);
    seen = global.chapter.$id;
    global.chapter.$id = 1;
    seen ? &amp;quot;Chapter $c.number&amp;quot;
         : &amp;quot;Chapter $c.number, I&amp;lt;$c.title&amp;gt;&amp;quot;;
  END;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The macro takes one argument, which is the id of the chapter (this is the unique name from the original array). If this chapter doesn&amp;rsquo;t exist in the &lt;code&gt;Chapter&lt;/code&gt; hash then the macro throws an error. If the chapter exists in the hash then the macro displays a reference to the chapter. Notice that we remember when we have seen a particular chapter (using &lt;code&gt;global.chapter.$id&lt;/code&gt;) &amp;ndash; this is because O&amp;rsquo;Reilly&amp;rsquo;s style guide says that a chapter is referenced differently the first time it is mentioned in another chapter. The first time, it is referenced as &amp;ldquo;Chapter 2, &lt;em&gt;A Simple Web Site&lt;/em&gt;&amp;rdquo;, and on subsequent references it is simply called &amp;ldquo;Chapter 2. &amp;ldquo;&lt;/p&gt;

&lt;p&gt;So with this mechanism in place, we can have templates that say things like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Plugins are covered in more detail in [% chref(plugins) %].
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And TT will convert that to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Plugins are covered in more detail in Chapter 6, I&amp;lt;Plugins&amp;gt;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And if we subsequently reorder the book again, the chapter number will be replaced with the new correct number.&lt;/p&gt;

&lt;h4 id=&#34;span-id-running-example-code-running-example-code-span&#34;&gt;&lt;span id=&#34;Running_example_code&#34;&gt;Running Example Code&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The other problem I mentioned above is that of ensuring that sample code and its output remain in step. The solution to this problem is a great example of the power of TT.&lt;/p&gt;

&lt;p&gt;The macro that inserts an example piece of code looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  MACRO example(file, title) BLOCK;
    global.example = global.example + 1;
    INCLUDE example
      title = title or &amp;quot;F&amp;lt;$file&amp;gt;&amp;quot;
      id    = &amp;quot;$chapter.id/example/$file&amp;quot;
      file  = &amp;quot;example/$file&amp;quot;
      n     = global.example;
    global.exref.$file = global.example;
  END;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The macro takes two arguments, the name of the file containing the example code and (optionally) a title for the example. If the title is omitted then the filename is used in its place. All of the examples in a particular chapter are numbered sequentially and the &lt;code&gt;global.example&lt;/code&gt; variable holds the last used value, which we increment. The macro then works out the path of the example file (the structure of our directory tree is very strict) and &lt;code&gt;INCLUDE&lt;/code&gt;s a template called &lt;code&gt;example&lt;/code&gt;, passing it various information about the example file. After processing the example, we store the number that is associated with this example by storing it in the hash &lt;code&gt;global.exref.$file&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;example&lt;/code&gt; template looks like this:&lt;/p&gt;

&lt;p&gt;[% IF publishing -%] =begin example [% title %]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      Z&amp;lt;[% id %]&amp;gt;[% INSERT $file FILTER indent(4) +%]

  =end
  [% ELSE -%]
  B&amp;lt;Example [% n %]: [% title %]&amp;gt;

  [% INSERT $file FILTER indent(4) +%]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[% END -%]&lt;/p&gt;

&lt;p&gt;This template looks at a global flag called &lt;code&gt;publishing&lt;/code&gt;, which determines if we are processing this file for submission to O&amp;rsquo;Reilly or just for our own internal use. The &lt;code&gt;Z&amp;lt; ... &amp;gt;&lt;/code&gt; POD escape is an O&amp;rsquo;Reilly extension used to identify the destination of a link anchor (we&amp;rsquo;ll see the link itself later on). Having worked out how to label the example, the template simply inserts it and indents it by four spaces.&lt;/p&gt;

&lt;p&gt;This template is used within our chapter template by adding code like &lt;code&gt;[% example(&#39;xpath&#39;, &#39;Processing XML with XPath&#39;) %]&lt;/code&gt; to your document. That will be expanded to something like, &amp;ldquo;Example 2: Processing XML with Xpath,&amp;rdquo; followed by the source of the example file, &lt;code&gt;xpath&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;All of that gets the example code into that document. We now have to do two other things. We need to be able to reference the code from the text of the chapter (&amp;lsquo;As example 3 demonstrates&amp;hellip;&amp;rsquo;), and we also need to include the results of running the code.&lt;/p&gt;

&lt;p&gt;For the first of these there is a macro called &lt;code&gt;exref&lt;/code&gt;, which is shown below:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  MACRO exref(file) BLOCK;
    # may be a forward reference to next example
    SET n = global.example + 1
      UNLESS (n = global.exref.$file);
    INCLUDE exref
      id    = &amp;quot;$chapter.id/example/$file&amp;quot;;
  END;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works in conjunction with another template, also called &lt;code&gt;exref&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  [% IF publishing -%]
  A&amp;lt;[% id %]&amp;gt;
  [%- ELSE -%]
  example [% n %]
  [%- END -%]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The clever thing about this is that you can use it &lt;em&gt;before&lt;/em&gt; you have included the example code. So you can do things like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  This is demonstrated in [% exref(&#39;xpath&#39;) %].

  [% example(&#39;xpath&#39;, &#39;Processing XML with XPath&#39;) %]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As long as you only look at a maximum of one example ahead, it still works. Notice that the &lt;code&gt;A&amp;lt; ... &amp;gt;&lt;/code&gt; POD escape is another O&amp;rsquo;Reilly extension that marks a link anchor. So within the O&amp;rsquo;Reilly publishing system it&amp;rsquo;s the &lt;code&gt;A&amp;lt;foo&amp;gt;&lt;/code&gt; and the associated &lt;code&gt;Z&amp;lt;foo&amp;gt;&lt;/code&gt; that make the link between the reference and the actual example code.&lt;/p&gt;

&lt;p&gt;The final thing we need is to be able to run the example code and insert the output into the document. For this we defined a macro called &lt;code&gt;output&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  MACRO output(file) BLOCK;
    n = global.example;
    &amp;quot;B&amp;lt;Output of example $n:&amp;gt;\n\n&amp;quot;;
    INCLUDE &amp;quot;example/$file&amp;quot; FILTER indent(4);
  END;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is pretty simple. The macro is passed the name of the example file. It assumes that this is the most recent example included in the document so it gets the example number from &lt;code&gt;global.example&lt;/code&gt;. It then displays a header and &lt;code&gt;INCLUDE&lt;/code&gt;s the file. Notice that the major difference between &lt;code&gt;example&lt;/code&gt; and &lt;code&gt;output&lt;/code&gt; is that &lt;code&gt;example&lt;/code&gt; uses &lt;code&gt;INSERT&lt;/code&gt; to just insert the file&amp;rsquo;s contents, whereas &lt;code&gt;output&lt;/code&gt; uses &lt;code&gt;INCLUDE&lt;/code&gt;, which loads the file and processes it.&lt;/p&gt;

&lt;p&gt;With all of these macros and templates, we can now have example code in our document and be sure that the output we show really reflects the output that you would get by running that code. So we can put something like this in the document:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  The use of GET and SET is demonstrated in [% exref(&#39;get_set&#39;) %].

  [% example(&#39;get_set&#39;, &#39;GET and SET&#39;) %]

  [% output(&#39;get_set&#39;) %]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that will be expanded to the following.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  The use of GET and SET is demonstrated in example 1.

  B&amp;lt;Example 1: GET and SET&amp;gt;

      [% SET foo = &#39;bar -%]
      The variable foo is set to &amp;quot;[% GET foo %]&amp;quot;.

  B&amp;lt;Output of example 1:

      The variable foo is set to &amp;quot;bar&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As another bonus, all of the example code is neatly packaged away in individual files that can easily be made into a tarball for distribution from the book&amp;rsquo;s web site.&lt;/p&gt;

&lt;h4 id=&#34;span-id-other-templates-blocks-and-macros-other-templates-blocks-and-macros-span&#34;&gt;&lt;span id=&#34;Other_templates,_blocks_and_macros&#34;&gt;Other Templates, Blocks, and Macros&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Once we started creating these timesaving templates, we found a huge numbers of areas where we could make our lives easier. We had macros that inserted references to other books in a standard manner, macros for inserting figures and screenshots, as well as templates that ensured that all our chapters had the same standard structure and warned us if any of the necessary sections were missing. I&amp;rsquo;m convinced that the TT templates we wrote for the project saved us all a tremendous amount of time that would have otherwise been spent organizing and reorganizing the work of the three authors. I would really recommend a similar approach to other authors.&lt;/p&gt;

&lt;p&gt;The Template Toolkit is often seen as a tool for building web sites, but we have successfully demonstrated one more non-Web area where the Template Toolkit excels.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Overloading</title>
      <link>http://localhost:1313/pub/2003/07/22/overloading.html/</link>
      <pubDate>Tue, 22 Jul 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/07/22/overloading.html/</guid>
      <description>

&lt;h3 id=&#34;introduction-what-is-overloading&#34;&gt;Introduction: What is Overloading?&lt;/h3&gt;

&lt;p&gt;All object-oriented programming languages have a feature called overloading, but in most of them this term means something different from what it means in Perl. Take a look at this Java example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public Fraction(int num, int den);
public Fraction(Fraction F);
public Fraction();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example, we have three methods called &lt;code&gt;Fraction&lt;/code&gt;. Java, like many languages, is very strict about the number and type of arguments that you can pass to a function. We therefore need three different methods to cover the three possibilities. In the first example, the method takes two integers (a numerator and a denominator) and it returns a &lt;code&gt;Fraction&lt;/code&gt; object based on those numbers. In the second example, the method takes an existing &lt;code&gt;Fraction&lt;/code&gt; object as an argument and returns a copy (or clone) of that object. The final method takes no arguments and returns a default &lt;code&gt;Fraction&lt;/code&gt; object, maybe representing &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1&lt;/sub&gt; or 0/1. When you call one of these methods, the Java Virtual Machine determines which of the three methods you wanted by looking at the number and type of the arguments.&lt;/p&gt;

&lt;p&gt;In Perl, of course, we are far more flexible about what arguments we can pass to a method. Therefore the same method can be used to handle all of the three cases from the Java example. (We&amp;rsquo;ll see an example of this in a short while.) This means that in Perl we can save the term &amp;ldquo;overloading&amp;rdquo; for something far more interesting — &lt;em&gt;operator overloading&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;number-fraction-the-constructor&#34;&gt;&lt;code&gt;Number::Fraction&lt;/code&gt; — The Constructor&lt;/h3&gt;

&lt;p&gt;Imagine you have a Perl object that represents fractions (or, more accurately, rational numbers, but we&amp;rsquo;ll call them fractions as we&amp;rsquo;re not all math geeks). In order to handle the same situations as the Java class we mentioned above, we need to be able to run code like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Number::Fraction;

my $half       = Number::Fraction-&amp;gt;new(1, 2);
my $other_half = Number::Fraction-&amp;gt;new($half);
my $default    = Number::Fraction-&amp;gt;new;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To do this, we would write a constructor method like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub new {
    my $class = shift;
    my $self;
    if (@_ &amp;gt;= 2) {
        return if $_[0] =~ /\D/ or $_[1] =~ /\D/;
        $self-&amp;gt;{num} = $_[0];
        $self-&amp;gt;{den} = $_[1];
    } elsif (@_ == 1) {
        if (ref $_[0]) {
            if (UNIVERSAL::isa($_[0], $class) {
                return $class-&amp;gt;new($_[0]-&amp;gt;{num}, $_[0]-&amp;gt;{den});
            } else {
                croak &amp;quot;Can&#39;t make a $class from a &amp;quot;, ref $_[0];
            }
        } else {
            return unless $_[0] =~ m|^(\d+)/(\d+)|;

            $self-&amp;gt;{num} = $1;
            $self-&amp;gt;{den} = $2;
        }
    } elsif (!@_) {
        $self-&amp;gt;{num} = 0;
        $self-&amp;gt;{den} = 1;
    }

    bless $self, $class;
    $self-&amp;gt;normalise;
    return $self;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As promised, there&amp;rsquo;s just one method here and it does everything that the three Java methods did and more even, so it&amp;rsquo;s a good example of why we don&amp;rsquo;t need method overloading in Perl. Let&amp;rsquo;s look at the various parts in some detail.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub new {
    my $class = shift;
    my $self;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The method starts out just like most Perl object constructors. It grabs the class which is passed in as the first argument and then declares a variable called &lt;code&gt;$self&lt;/code&gt; which will contain the object.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if (@_ &amp;gt;= 2) {
        return if $_[0] =~ /\D/ or $_[1] =~ /\D/;
        $self-&amp;gt;{num} = $_[0];
        $self-&amp;gt;{den} = $_[1];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is where we start to work out just how the method was called. We look at &lt;code&gt;@_&lt;/code&gt; to see how many arguments we have been given. If we&amp;rsquo;ve got two arguments then we assume that they are the numerator and denominator of the fraction. Notice that there&amp;rsquo;s also another check to ensure that both arguments contain only digits. If this check fails, we return &lt;code&gt;undef&lt;/code&gt; from the constructor.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     } elsif (@_ == 1) {
        if (ref $_[0]) {
            if (UNIVERSAL::isa($_[0], $class) {
                return $class-&amp;gt;new($_[0]-&amp;gt;num, $_[0]-&amp;gt;den);
            } else {
                croak &amp;quot;Can&#39;t make a $class from a &amp;quot;, ref $_[0];
            }
        } else {
            return unless $_[0] =~ m|^(\d+)/(\d+)|;
            $self-&amp;gt;{num} = $1;
            $self-&amp;gt;{den} = $2;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we&amp;rsquo;ve been given just one argument, then there are a couple of things we can do. First we see if the argument is a reference, and if it is, we check that it&amp;rsquo;s a reference to another &lt;code&gt;Number::Fraction&lt;/code&gt; object (or a subclass). If it&amp;rsquo;s the right kind of object then we get the numerators and denominators (using the accessor functions) and use them to call the two argument forms of &lt;code&gt;new&lt;/code&gt;. It the argument is the wrong type of reference then we complain bitterly to the user.&lt;/p&gt;

&lt;p&gt;If the single argument isn&amp;rsquo;t a reference then we assume it&amp;rsquo;s a string of the form &lt;code&gt;num/den&lt;/code&gt;, which we can split apart to get the numerator and denominator of the fraction. Once more we check for the correct format using a regex and return &lt;code&gt;undef&lt;/code&gt; if the check fails.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     } elsif (!@_) {
        $self-&amp;gt;{num} = 0;
        $self-&amp;gt;{den} = 1;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we are given no arguments, then we just create a default fraction which is &lt;code&gt;0/1&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    bless $self, $class;
    $self-&amp;gt;normalise;
    return $self;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At the end of the constructor we do more of the normal OO Perl stuff. We &lt;code&gt;bless&lt;/code&gt; the object into the correct class and return the reference to our caller. Between these two actions we pause to call the &lt;code&gt;normalise&lt;/code&gt; method, which converts the fraction to its simplest form. For example, it will convert &lt;code&gt;12/16&lt;/code&gt; to &lt;code&gt;3/4&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;number-fraction-doing-calculations&#34;&gt;&lt;code&gt;Number::Fraction&lt;/code&gt; — Doing Calculations&lt;/h3&gt;

&lt;p&gt;Having now created fraction objects, we will want to start doing calculations with them. For that we&amp;rsquo;ll need methods that implement the various mathematical functions. Here&amp;rsquo;s the &lt;code&gt;add&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub add {
    my ($self, $delta) = @_;

    if (ref $delta) {
        if (UNIVERSAL::isa($delta, ref $self)) {
            $self-&amp;gt;{num} = $self-&amp;gt;num  * $delta-&amp;gt;den
                + $delta-&amp;gt;num * $self-&amp;gt;den;
            $self-&amp;gt;{den} = $self-&amp;gt;den  * $delta-&amp;gt;den;
        } else {
            croak &amp;quot;Can&#39;t add a &amp;quot;, ref $delta, &amp;quot; to a &amp;quot;, ref $self;
        }
    } else {
        if ($delta =~ m|(\d+)/(\d+)|) {
            $self-&amp;gt;add(Number::Fraction-&amp;gt;new($1, $2));
        } elsif ($delta !~ /\D/) {
            $self-&amp;gt;add(Number::Fraction-&amp;gt;new($delta, 1));
        } else {
            croak &amp;quot;Can&#39;t add $delta to a &amp;quot;, ref $self;
        }
    }
    $self-&amp;gt;normalise;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once more we try to handle a number of different types of arguments. We can add the following things to our fraction object:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Another object of the same class (or a subclass).&lt;/li&gt;
&lt;li&gt;A string in the format &lt;code&gt;num/den&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;An integer. This is converted to a fraction with a denominator of 1.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This then allows us to write code like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $half           = Number::Fraction-&amp;gt;new(1, 2);
my $quarter        = Number::Fraction-&amp;gt;new(1, 4);
my $three_quarters = $half;
$three_quarters-&amp;gt;add($quarter);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In my opinion, this code looks pretty horrible. It also has a nasty, subtle bug. Can you spot it? (Hint: What will be in &lt;code&gt;$half&lt;/code&gt; after running this code?) To tidy up this code we can turn to &lt;em&gt;operator overloading&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;number-fraction-operator-overloading&#34;&gt;&lt;code&gt;Number::Fraction&lt;/code&gt; — Operator Overloading&lt;/h3&gt;

&lt;p&gt;The module &lt;code&gt;overload.pm&lt;/code&gt; is a standard part of the Perl distribution. It allows your objects to define how they will react to a number of Perl&amp;rsquo;s operators. For example, we can add code like this to &lt;code&gt;Number::Fraction&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use overload &#39;+&#39; =&amp;gt; &#39;add&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whenever a Number::Fraction is used as one of the operands to the &lt;code&gt;+&lt;/code&gt; operator, the &lt;code&gt;add&lt;/code&gt; method will be called instead. Code like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$three_quarters = $half + &#39;3/4&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is converted to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$three_quarters = $half-&amp;gt;add(&#39;3/4&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is getting closer, but it still has a serious problem. The &lt;code&gt;add&lt;/code&gt; method works on the &lt;code&gt;$half&lt;/code&gt; object. In general, however, that&amp;rsquo;s not how an assignment should work. If you were working with ordinary scalars and had code like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$foo = $bar + 0.75;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You would be very surprised if this altered the value of &lt;code&gt;$bar&lt;/code&gt;. Our objects need to work in the same way. We need to change our add method so that it doesn&amp;rsquo;t alter &lt;code&gt;$self&lt;/code&gt; but instead returns the new fraction.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub add {
    my ($l, $r) = @_;
    if (ref $r) {
        if (UNIVERSAL::isa($r, ref $l) {
            return Number::Fraction-&amp;gt;new($l-&amp;gt;num * $r-&amp;gt;den + $r-&amp;gt;num * $l-&amp;gt;den,
                    $l-&amp;gt;den * $r-&amp;gt;den})
        } else {
            ...
        } else {
            ...
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example, I&amp;rsquo;ve only shown one of the sections, but I hope it&amp;rsquo;s clear how it would work. Notice that I&amp;rsquo;ve also renamed &lt;code&gt;$self&lt;/code&gt; and &lt;code&gt;$delta&lt;/code&gt; to &lt;code&gt;$l&lt;/code&gt; and &lt;code&gt;$r&lt;/code&gt;. I find this makes more sense as we are working with the left and right operands of the &lt;code&gt;+&lt;/code&gt; operator.&lt;/p&gt;

&lt;h3 id=&#34;span-id-overloading-noncommutative-operators-overloading-non-commutative-operators-span&#34;&gt;&lt;span id=&#34;overloading noncommutative operators&#34;&gt;Overloading Non-Commutative Operators&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;We can now happily handle code like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$three_quarters = $half + &#39;1/4&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our object will do the right thing — &lt;code&gt;$three_quarters&lt;/code&gt; will end up as a &lt;code&gt;Number::Fraction&lt;/code&gt; object that contains the value &lt;code&gt;3/4&lt;/code&gt;. What will happen if we write code like this?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$three_quarters = &#39;1/4&#39; + $half;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;overload&lt;/code&gt; modules handle this case as well. If your object is &lt;em&gt;either&lt;/em&gt; operand of one of the overloaded operators, then your method will be called. You get passed an extra argument which indicates whether your object was the left or right operand of the operator. This argument is false if your object is the left operand and true if it is the right operand.&lt;/p&gt;

&lt;p&gt;For commutative operators you probably don&amp;rsquo;t need to take any notice of this argument as, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$half + &#39;1/4&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is the same as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;1/4&#39; + $half
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, for non-commutative operators (like &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;) you will need to do something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub subtract {
    my ($l, $r, $swap) = @_;

    ($l, $r) = ($r, $l) if $swap;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;overloadable-operators&#34;&gt;Overloadable Operators&lt;/h3&gt;

&lt;p&gt;Just about any Perl operator can be overloaded in this way. This is a partial list:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Arithmetic: &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;**=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;x=&lt;/code&gt;, &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;.=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Comparison: &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;=&amp;gt;&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; &lt;code&gt;lt&lt;/code&gt;, &lt;code&gt;le&lt;/code&gt;, &lt;code&gt;gt&lt;/code&gt;, &lt;code&gt;ge&lt;/code&gt;, &lt;code&gt;eq&lt;/code&gt;, &lt;code&gt;ne&lt;/code&gt;, &lt;code&gt;cmp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Increment/Decrement: &lt;code&gt;++&lt;/code&gt;, &lt;code&gt;--&lt;/code&gt; (both pre- and post- versions)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A full list is given in &lt;code&gt;overload&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s a very long list, but thankfully you rarely have to supply an implementation for more than a few operators. Perl is quite happy to synthesize (or &lt;em&gt;autogenerate&lt;/em&gt;) many of the missing operators. For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;++ can be derived from +&lt;/li&gt;
&lt;li&gt;+= can be derived from +&lt;/li&gt;
&lt;li&gt;- (unary) can be derived from - (binary)&lt;/li&gt;
&lt;li&gt;All numeric comparisons can be derived from &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;All string comparisons can be derived from &lt;code&gt;cmp&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Two other special operators give finer control over this autogeneration of methods. &lt;code&gt;nomethod&lt;/code&gt; defines a subroutine that is called when no other function is found and &lt;code&gt;fallback&lt;/code&gt; controls how hard Perl tries to autogenerate a method. &lt;code&gt;fallback&lt;/code&gt; can have one of three values:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;undef&lt;/code&gt;&lt;br /&gt;
Attempt to autogenerate methods and &lt;code&gt;die&lt;/code&gt; if a method can&amp;rsquo;t be autogenerated. This is the default.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;0&lt;/code&gt;&lt;br /&gt;
Never try to autogenerate methods.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;1&lt;/code&gt;&lt;br /&gt;
Attempt to autogenerate methods but fall back on Perl&amp;rsquo;s default behavior for the the object if a method can&amp;rsquo;t be autogenerated.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an example of an object that will die gracefully when an unknown operator is called. Notice that the &lt;code&gt;nomethod&lt;/code&gt; subroutine is passed the usual three arguments (left operand, right operand, and the swap flag) together with an extra argument containing the operator that was used.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use overload
    &#39;-&#39; =&amp;gt; &#39;subtract&#39;,
    fallback =&amp;gt; 0,
    nomethod =&amp;gt; sub { 
        croak &amp;quot;illegal operator $_[3]&amp;quot; 
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Three special operators are provided to control type conversion. They define methods to be called if the object is used in string, numeric, and boolean contexts. These operators are denoted by &lt;code&gt;q{&amp;quot;&amp;quot;}&lt;/code&gt;, &lt;code&gt;0+&lt;/code&gt;, and &lt;code&gt;bool&lt;/code&gt;. Here&amp;rsquo;s how we can use these in &lt;code&gt;Number::Fraction&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use overload
    q{&amp;quot;&amp;quot;} =&amp;gt; &#39;to_string&#39;,
    &#39;0+&#39;  =&amp;gt; &#39;to_num&#39;;

sub to_string {
    my $self = shift;
    return &amp;quot;$_-&amp;gt;{num}/$_-&amp;gt;{den}&amp;quot;;
}

sub to_num {
    my $self = shift;
    return $_{num}/$_-&amp;gt;{den};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, when we print a &lt;code&gt;Number::Fraction&lt;/code&gt; object, it will be displayed in &lt;code&gt;num/den&lt;/code&gt; format. When we use the object in a numeric context, Perl will automatically convert it to its numeric equivalent.&lt;/p&gt;

&lt;p&gt;We can use these type-conversion and fallback operators to cut down the number of operators we need to define even further.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use overload
    &#39;0+&#39; =&amp;gt; &#39;to_num&#39;,
    fallback =&amp;gt; 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, whenever our object is used where Perl is expecting a number and we haven&amp;rsquo;t already defined an overloading method, Perl will try to use our object as a number, which will, in turn, trigger our &lt;code&gt;to_num&lt;/code&gt; method. This means that we only need to define operators where their behavior will differ from that of a normal number. In the case of &lt;code&gt;Number::Fraction&lt;/code&gt;, we don&amp;rsquo;t need to define any numeric comparison operators since the numeric value of the object will give the correct behavior. The same is true of the string comparison operators if we define &lt;code&gt;to_string&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;overloading-constants&#34;&gt;Overloading Constants&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ve come a long way with our overloaded objects. Instead of nasty code like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Number::Fraction;

$f = Number::Fraction-&amp;gt;new(1, 2);
$f-&amp;gt;add(&#39;1/4&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we can now write code like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Number::Fraction;

$f = Number::Fraction-&amp;gt;new(1, 2) + &#39;1/4&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are still, however, two places where we need to use the full name of the class — when we load the module and when we create a new fraction object. We can&amp;rsquo;t do much about the first of these, but we &lt;em&gt;can&lt;/em&gt; remove the need for that ugly &lt;code&gt;new&lt;/code&gt; call by &lt;em&gt;overloading constants&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;You can use &lt;code&gt;overload::constant&lt;/code&gt; to control how Perl interprets constants in your program. &lt;code&gt;overload::constant&lt;/code&gt; expects a hash where the keys identify various kinds of constants and the values are subroutines which handle the constants. The keys can be any of &lt;code&gt;integer&lt;/code&gt; (for integers), &lt;code&gt;float&lt;/code&gt; (for floating point numbers), &lt;code&gt;binary&lt;/code&gt; (for binary, octal, and hex numbers), &lt;code&gt;q&lt;/code&gt; (for strings), and &lt;code&gt;qr&lt;/code&gt; (for the constant parts of regular expressions).&lt;/p&gt;

&lt;p&gt;When a constant of the right type is found, Perl will call the associated subroutine, passing it the string representation of the constant and the way that Perl would interpret the constant by default. Subroutines associated with &lt;code&gt;q&lt;/code&gt; or &lt;code&gt;qr&lt;/code&gt; also get a third argument &amp;ndash; either &lt;code&gt;qq&lt;/code&gt;, &lt;code&gt;q&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, or &lt;code&gt;tr&lt;/code&gt; &amp;ndash;which indicates how the string is being used in the program.&lt;/p&gt;

&lt;p&gt;As an example, here is how we would set up constant handlers so that strings of the form &lt;code&gt;num/den&lt;/code&gt; are always converted to the equivalent &lt;code&gt;Number::Fraction&lt;/code&gt; object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my %_const_handlers = 
    (q =&amp;gt; sub { 
        return __PACKAGE__-&amp;gt;new($_[0]) || $_[1] 
});

sub import {
    overload::constant %_const_handlers if $_[1] eq &#39;:constants&#39;;
}

sub unimport {
    overload::remove_constant(q =&amp;gt; undef);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ve defined a hash, &lt;code&gt;%_const_handlers&lt;/code&gt;, which only contains one entry as we are only interested in strings. The associated subroutine calls the &lt;code&gt;new&lt;/code&gt; method in the current package (which will be &lt;code&gt;Number::Fraction&lt;/code&gt; or a subclass) passing it the string as found in the program source. If this string can be used to create a valid &lt;code&gt;Number::Fraction&lt;/code&gt; object, a reference to that object is returned.&lt;/p&gt;

&lt;p&gt;If a valid object isn&amp;rsquo;t returned then the subroutine returns its second argument, which is Perl&amp;rsquo;s default intepretation of the constant. As a result, any strings in the program that can be intepreted as a fraction are converted to the correct &lt;code&gt;Number::Fraction&lt;/code&gt; object and other strings are left unchanged.&lt;/p&gt;

&lt;p&gt;The constant handler is loaded as part of our package&amp;rsquo;s &lt;code&gt;import&lt;/code&gt; subroutine. Notice that it is only loaded if the &lt;code&gt;import&lt;/code&gt; subroutine is passed the optional argument &lt;code&gt;:constants&lt;/code&gt;. This is because this is a potentially big change to the way that a program&amp;rsquo;s source code is interpreted so we only want to turn it on if the user wants it. &lt;code&gt;Number::Fraction&lt;/code&gt; can be used in this way by putting the following line in your program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Number::Fraction &#39;:constants&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you don&amp;rsquo;t want the scary constant-refining stuff you can just use:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Number::Fraction;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also note that we&amp;rsquo;ve defined an &lt;code&gt;unimport&lt;/code&gt; subroutine which removes the constant handler. An &lt;code&gt;unimport&lt;/code&gt; subroutine is called when a program calls &lt;code&gt;no Number::Fraction&lt;/code&gt; — it&amp;rsquo;s the opposite of &lt;code&gt;use&lt;/code&gt;. If you&amp;rsquo;re going to make major changes to the way that Perl parses a program then it&amp;rsquo;s only polite to undo your changes if the programmer askes you to.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ve finally managed to get rid of most of the ugly class names from our code. We can now write code like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Number::Fraction &#39;:constants&#39;;

my $half = &#39;1/2&#39;;
my $three_quarters = $half + &#39;1/4&#39;;
print $three_quarters;  # prints 3/4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I hope you can agree that this has the potential to make code far easier to read and understand.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Number::Fraction&lt;/code&gt; is available on the CPAN. Please feel free to take a closer look at how it is implemented. If you come up with any more interesting overloaded modules, I&amp;rsquo;d love to hear about them.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Finding CGI Scripts</title>
      <link>http://localhost:1313/pub/2002/01/23/cgi.html/</link>
      <pubDate>Wed, 23 Jan 2002 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2002/01/23/cgi.html/</guid>
      <description>

&lt;h3 id=&#34;span-id-introduction-introduction-span&#34;&gt;&lt;span id=&#34;introduction&#34;&gt;Introduction&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;No matter how much we try to convince people that Perl is a multi-purpose programming language, we&amp;rsquo;d be deluding ourselves if we didn&amp;rsquo;t admit that the majority of programmers first come into contact with Perl through their experience with CGI programs. People have a small Web site and one day they decide that they need a guest book, a form mail script or a hit counter. Because these people aren&amp;rsquo;t programmers, they go out onto the Web to see what pre-written scripts they can find.&lt;/p&gt;

&lt;p&gt;And there are plenty to choose from. Try searching on ``CGI scripts&amp;rdquo; at Google. I received about 2 million hits. The first two were those well-known sites - Matt&amp;rsquo;s Script Archive and the CGI Resource Index. Our Web site owner will visit one of these sites, find the required scripts and install them on his site. What could be simpler? See, the Web &lt;em&gt;is&lt;/em&gt; as easy as people make it out to be.&lt;/p&gt;

&lt;p&gt;In this article, I&amp;rsquo;ll take a closer look at this scenario and show that all is not as rosy as I&amp;rsquo;ve portrayed it above.&lt;/p&gt;

&lt;h3 id=&#34;span-id-cgi-script-quality-cgi-script-quality-span&#34;&gt;&lt;span id=&#34;cgi script quality&#34;&gt;CGI Script Quality&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;An important factor that Google takes into account when displaying search results is the number of links to a given site. Google assumes that if there are a large number of links to a given Web page, then it must be a well-known page and that Google&amp;rsquo;s visitors will want to visit that site first.&lt;/p&gt;

&lt;p&gt;Notice that I said ``well-known&amp;rdquo; in that previous paragraph. Not ``useful&amp;rdquo; or ``valuable.&amp;rdquo; Think about this for a second. The types of people that I described in the introduction are not programmers. They certainly aren&amp;rsquo;t Perl programmers. Therefore, they are in no position to make value judgments on the Perl code that they download from the Internet.&lt;/p&gt;

&lt;p&gt;This means that the ``most popular&amp;rdquo; site becomes a self-fulfilling prophecy. The best known site is listed first on the search engines. More people download scripts from that site, assuming that the most popular site must have the highest quality scripts and that the popular sites end up becoming more popular.&lt;/p&gt;

&lt;p&gt;At no point does any kind of quality control enter into the process.&lt;/p&gt;

&lt;p&gt;OK, so that&amp;rsquo;s not strictly true. If the scripts from a particular site just didn&amp;rsquo;t work at all, then word would soon get out and that site&amp;rsquo;s scripts would become unpopular. But what if the problems were more subtle and didn&amp;rsquo;t manifest themselves on all sites. Here is a list of some potential problems:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Not checking the results of an &lt;code&gt;open&lt;/code&gt; call. This will work fine if the expected file exists and has the right permissions. But what happens when the file doesn&amp;rsquo;t exist? Or it exists but the CGI process doesn&amp;rsquo;t have permissions to read from it or write to it?&lt;/li&gt;
&lt;li&gt;Bad CGI parameter parsing code. CGI parameter parsing is one of those things that is easy to do badly and hard to do well. It&amp;rsquo;s simple enough to write a parser function that handles most cases, but does it handle both GET and POST requests? What about keys with multiple associated values? And does it process file uploads correctly?&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Lack of security. Installing a CGI program allows anyone with an Internet connection to run a program on your server. That&amp;rsquo;s quite a scary thing to allow. You&amp;rsquo;d better be well aware of the security implications. Of course, if people only ever run the script from your HTML form, then everything will probably be fine, but a cracker won&amp;rsquo;t do that. He&amp;rsquo;ll fire ``interesting&amp;rdquo; sets of parameters at your script in an attempt to find its weaknesses. Suddenly a form mail script is being used to send copies of vital system files to the cracker.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s also worth bearing in mind that because these scripts are available on the Web, crackers can easily get the source code. They can then work out any insecurities in the scripts and exploit them. Recently, a friend&amp;rsquo;s Web site came under attack from crackers and amongst the traces left in the access log were a large number of calls to well-known CGI scripts.&lt;/p&gt;

&lt;p&gt;For this reason, it is even more important that you are careful about security when writing CGI scripts that are intended to be used by novice Webmasters.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The fact is, unfortunately, that these kinds of problems are commonplace in the scripts that you can download from many popular CGI script archives. That&amp;rsquo;s not to say that the authors of these scripts are deliberately trying to give crackers access to your servers. It&amp;rsquo;s simply evidence that Perl has moved on a great deal since the introduction of Perl 5 in 1994 and many of the CGI script authors haven&amp;rsquo;t kept their scripts up to date with current practices. In other cases, the authors know only too well how out of date their scripts are and have produced newer, improved versions, but other people are still distributing the older versions.&lt;/p&gt;

&lt;h3 id=&#34;span-id-setting-a-good-example-setting-a-good-example-span&#34;&gt;&lt;span id=&#34;setting a good example&#34;&gt;Setting a Good Example&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Although the people who are downloading these scripts aren&amp;rsquo;t usually programmers, there often comes a time when they want to start changing the way a program works and perhaps even writing their own CGI programs. When this time comes, they will go to the scripts they already have for examples of how to write them. If the original script contained bad programming practices, then these will be copied in the new scripts. This is the way that many bad programming practices have become so common among Perl scripts. I, therefore, think that it&amp;rsquo;s a good idea for any publicly distributed programs to follow best programming practices as much as possible.&lt;/p&gt;

&lt;h3 id=&#34;span-id-script-quality-a-checklist-script-quality-a-checklist-span&#34;&gt;&lt;span id=&#34;script quality  a checklist&#34;&gt;Script Quality - A Checklist&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;So now we have an obvious problem. I said before that the people who are downloading and installing these scripts aren&amp;rsquo;t qualified to make judgments on the quality of the code. Given that there are some problematic scripts out there, how are they supposed to know whether they should be using a particular script that they find on the Web?&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s a difficult question to answer, but there are some clues that you can look for that give a idea of how well-written a script is. Here&amp;rsquo;s a brief checklist:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Does the script use &lt;code&gt;-w&lt;/code&gt; and &lt;code&gt;use strict&lt;/code&gt;?&lt;/strong&gt; The vast majority of Perl experts recommend using these tools when writing Perl programs of any level of complexity. They make any Perl program more robust. Anyone distributing Perl programs without them probably doesn&amp;rsquo;t know as much Perl as they think they do.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Does the script use Perl&amp;rsquo;s taint mode?&lt;/strong&gt; Accepting external data from a Web browser is a dangerous business. You can never be sure what you&amp;rsquo;ll get. If you add &lt;code&gt;-T&lt;/code&gt; to a program&amp;rsquo;s shebang line, then Perl goes into taint mode. In this mode Perl distrusts any data that it gets from external sources. You need to explicitly check this data before using it. Using &lt;code&gt;-T&lt;/code&gt; is a sign that the author is at least thinking about CGI security issues.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Does the script use CGI.pm?&lt;/strong&gt; Since Perl 5.004, CGI.pm has been a part of the standard Perl distribution. This module contains a number of functions for handling various parts of the CGI protocol. The most important one is probably &lt;code&gt;param&lt;/code&gt;, which deals with the parsing of the query string to extract the CGI parameters. Many CGI scripts write their own CGI parameter parsing routine that is missing features or has bugs. The one in CGI.pm has been well-tested over many years in thousands of scripts - why attempt to reinvent it?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;How often is the script updated?&lt;/strong&gt; One reason for a script not to use CGI.pm might be that it hasn&amp;rsquo;t been updated since the module was added to the Perl distribution. This is generally a bad sign. You should look for scripts that are kept up to date. If there hasn&amp;rsquo;t been been a new version of the script for several years, then you should probably avoid it.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;How good is the support?&lt;/strong&gt; Any program is of limited use if it&amp;rsquo;s unsupported. How do you get support for the program? Is there an e-mail address for the author? Or is there a support mailing list? Try dropping an e-mail to either the author or the mailing list and see how quickly you get a response.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Of course, these rules will have exceptions, but if a script scores badly on most of them, then you might have second thoughts on whether you should be using the script.&lt;/p&gt;

&lt;h3 id=&#34;span-id-nms-a-new-cgi-program-archive-nms-a-new-cgi-program-archive-span&#34;&gt;&lt;span id=&#34;nms  a new cgi program archive&#34;&gt;&lt;em&gt;nms&lt;/em&gt; - A New CGI Program Archive&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Having spent most of this article being quite negative about existing CGI program archives, let&amp;rsquo;s now get a bit more positive. In the summer of 2001, a group of London Perl Mongers started to wonder what would be involved in writing a set of new CGI programs that could act as replacements for the ones in common use. After some discussion, the &lt;em&gt;nms&lt;/em&gt; project was born. The name &lt;em&gt;nms&lt;/em&gt; originally stood for a disparaging remark about one of the existing archives, but we decided that we didn&amp;rsquo;t want the kind of negativity in the name. By that time, however, the abbreviated name was in common usage so we decided to keep it - but it no longer stands for anything.&lt;/p&gt;

&lt;p&gt;The objectives for &lt;em&gt;nms&lt;/em&gt; were quite simple. We wanted to provide a set of CGI programs which fulfilled the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;As easy (or easier) to use as existing CGI scripts.&lt;/li&gt;
&lt;li&gt;Use best programming practices&lt;/li&gt;
&lt;li&gt;Secure&lt;/li&gt;
&lt;li&gt;Bug-free (or, at least, well supported)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We decided that we would base our programs on the ones found in Matt&amp;rsquo;s Script Archive. This wasn&amp;rsquo;t because Matt Wright&amp;rsquo;s scripts were the worst out there, but simply that they were the most commonly used. We made a rule that our scripts would be drop-in replacements for Matt&amp;rsquo;s scripts. That meant that anyone who had existing data from using one of Matt&amp;rsquo;s scripts would be able to take our replacement and simply put it in place of the old script. This, of course, meant that we had to become familiar with the inner workings of Matt&amp;rsquo;s scripts. This actually turned out not to be a hard as I expected. The majority of Matt&amp;rsquo;s scripts are simple. It&amp;rsquo;s only really formmail, guestbook and wwwboard that are complex.&lt;/p&gt;

&lt;p&gt;Sometimes our objectives contradicted one anther. We decided early on, that part of making the scripts as easy to use as possible meant not relying on any CPAN modules. We forced ourselves to only use only modules that came as part of the standard Perl distribution. The reason for this is that our target audience probably doesn&amp;rsquo;t know anything about CPAN modules and wouldn&amp;rsquo;t find it easy to install them. A large part of our audience isprobably operating a Web site on a hosted server where they may not be able to install new modules and in many cases won&amp;rsquo;t have telnet access to their server. We felt that asking them to install extra modules would make them far less likely to use our programs. This, of course, goes against our objective of using best programming practices as in many cases there is a CPAN module that implements functionality that we use. The best example of this is in formmail where we resort to sending e-mails by talking directly to &lt;code&gt;sendmail&lt;/code&gt; rather than using one of the e-mail modules. In these cases, we decided that getting people to use the scripts (by not relying on CPAN) was more important to us than following best practices.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;nms&lt;/em&gt; is a SourceForge project. You can get the latest released versions of the scripts from &lt;a href=&#34;[http://nms-cgi.sourceforge.net&#34;&gt;http://nms-cgi.sourceforge.net&lt;/a&gt; or, if you&amp;rsquo;re feeling braver, then you can get the leading edge versions from CVS at the project page at &lt;a href=&#34;http://sourceforge.net/projects/nms-cgi/&#34;&gt;http://sourceforge.net/projects/nms-cgi/&lt;/a&gt;. Both of those pages also have links to the &lt;em&gt;nms&lt;/em&gt; mailing lists. We have two lists, one for developers and one for support questions. There is also a FAQ that will hopefully answer any further questions that you have about the project.&lt;/p&gt;

&lt;p&gt;Here is a list of the scripts available from &lt;em&gt;nms&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Countdown&lt;/strong&gt; Count down the time to a certain date&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Free For All Links&lt;/strong&gt; A simple Web link database&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Formmail&lt;/strong&gt; Send e-mails from Web forms&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Guestbook&lt;/strong&gt; A simple guest book script&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Random Image&lt;/strong&gt; Display a random image&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Random Links&lt;/strong&gt; Display a link chosen randomly from a list&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Random Text&lt;/strong&gt; Display a randomly chosen piece of text&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Simple Search&lt;/strong&gt; Simple Web site search engine&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SSI Random Image&lt;/strong&gt; Display a random image using SSI&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Text Clock&lt;/strong&gt; Display the time&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Text Counter&lt;/strong&gt; Text counter&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I should point out that this is very much a ``work in progress.&amp;rdquo; While we&amp;rsquo;re happy with the way that they work, we can always use more people looking at the code. The one advantage that Matt&amp;rsquo;s scripts have over ours is that they&amp;rsquo;ve had many years of testing on a large number of Web sites.&lt;/p&gt;

&lt;h3 id=&#34;span-id-a-plea-for-help-a-plea-for-help-span&#34;&gt;&lt;span id=&#34;a plea for help&#34;&gt;A Plea for Help&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;So now we have a source of well-written CGI programs that we can point users to. What more needs to be done? Well, the whole point of writing this article was to ask more people to help. There&amp;rsquo;s always more work to do :-)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Peer review&lt;/strong&gt;. We think we&amp;rsquo;ve done a pretty good job on the scripts, but we&amp;rsquo;re not interested in resting on our laurels. The more people that look at the scripts the more likely we&amp;rsquo;ll catch bugs and insecurities. Please download the scripts and take a look at them. Pass any bugs on to the developers mailing.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Testing&lt;/strong&gt;. We test the scripts on as many platforms with as many different configurations as we can, but we&amp;rsquo;ll always miss one or two. Please try to install the scripts on your systems and let us know about any problems you have.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Documentation&lt;/strong&gt;. Our documentation isn&amp;rsquo;t any worse than the documentation for the existing archives, but we think it could be much better. If you&amp;rsquo;d like to help out with this, then please get in touch with us.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Advocacy&lt;/strong&gt;. This is the most important one. Please tell everyone that you know about &lt;em&gt;nms&lt;/em&gt;. Everywhere that you see people using other CGI scripts, please explain to them the potential problems and show them where to get the &lt;em&gt;nms&lt;/em&gt; scripts. Having written these scripts, we feel it&amp;rsquo;s important that they get as wide exposure as possible. If you have any ideas for promoting &lt;em&gt;nms&lt;/em&gt;, then please let us know.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While I don&amp;rsquo;t pretend for a minute that these are the only well-written and secure CGI programs available, I do think that the Perl community needs a well-known and trusted set of CGI programs that we can point people to. With your help, that&amp;rsquo;s what I want &lt;em&gt;nms&lt;/em&gt; to become.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Changing Hash Behaviour with tie</title>
      <link>http://localhost:1313/pub/2001/09/04/tiedhash.html/</link>
      <pubDate>Tue, 04 Sep 2001 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2001/09/04/tiedhash.html/</guid>
      <description>

&lt;h3 id=&#34;span-id-introduction-introduction-span&#34;&gt;&lt;span id=&#34;introduction&#34;&gt;Introduction&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In my experience, hashes are just about the most useful built-in datatype that Perl has. They are useful for so many things - from simple lookup tables to complex data structures. And, of course, most Perl objects have a blessed hash as their underlying implementation.&lt;/p&gt;

&lt;p&gt;The fact that they have so many uses must mean the Larry and the Perl5 Porters must have got the functionality of hashes pretty much right when designing them - it&amp;rsquo;s simple, instinctive and effective. But have you ever come across a situation where you wanted to change the way that hashes worked? Perhaps you wanted hashes that only had a fixed set of keys. Faced with this requirement, it&amp;rsquo;s tempting to move away from the hash interface completely and use an object. The downside to this decision is that you lose the easy-to-understand hash interface. But using &lt;em&gt;tied variables&lt;/em&gt; it is possible to create an object and still use it like a hash.&lt;/p&gt;

&lt;h3 id=&#34;span-id-tied-objects-tied-objects-span&#34;&gt;&lt;span id=&#34;tied objects&#34;&gt;Tied Objects&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Tied objects are, in my opinion, an underused feature of Perl. The details (together with some very good examples) are in &lt;em&gt;perltie&lt;/em&gt; and there are some extended examples in the &amp;ldquo;Tied variables&amp;rdquo; chapter of &lt;em&gt;Programming Perl&lt;/em&gt;. Despite all of this great documentation, most people seem to believe that &lt;code&gt;tie&lt;/code&gt;ing is only used to &lt;code&gt;tie&lt;/code&gt; a hash to a DBM file. The truth is that any type of Perl data structure can be &lt;code&gt;tie&lt;/code&gt;d to just about anything. It&amp;rsquo;s simply a case of writing an object that includes certain pre-defined methods. If you want to create a &lt;code&gt;tie&lt;/code&gt;d object that emulates a standard Perl object most of the time, then it&amp;rsquo;s even easier, as the Perl distribution contains modules that define objects that mimic the behavior of that standard data types. For example, there is a class called &lt;code&gt;Tie::StdHash&lt;/code&gt; (in the file Tie::Hash) that mimics the behavior of a real hash. To alter that behavior we simply have to subclass &lt;code&gt;Tie::StdHash&lt;/code&gt; and override the methods that we&amp;rsquo;re interested in.&lt;/p&gt;

&lt;h3 id=&#34;span-id-using-tied-objects-using-tied-objects-span&#34;&gt;&lt;span id=&#34;using tied objects&#34;&gt;Using Tied Objects&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In your Perl program, you make use of a &lt;code&gt;tie&lt;/code&gt;d object by calling the &lt;code&gt;tie&lt;/code&gt; function. &lt;code&gt;tie&lt;/code&gt; takes two mandatory parameters: the variable that you are &lt;code&gt;tie&lt;/code&gt;ing and the name of the class to &lt;code&gt;tie&lt;/code&gt; it to, followed by any number of optional parameters. For example, if we had written the hash with fixed keys discussed earlier (which we will do soon), we could use the class in our program like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use Tie::Hash::FixedKey;

  my %person;

  my @keys = qw(forename surname date_of_birth gender);

  tie %person, &#39;Tie::Hash::FixedWidth&#39;, @keys;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After running this code, &lt;code&gt;%person&lt;/code&gt; can still be used like a hash, but its behavior will have been changed. Any attempt to assign a value to a key outside the list that we used in the call to &lt;code&gt;tie&lt;/code&gt; will fail in some way that we get to specify when we write the module.&lt;/p&gt;

&lt;p&gt;If for some reason we wanted to get to the underlying object that is tied to the hash, then we can use the &lt;code&gt;tied&lt;/code&gt; function. For example,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my $obj = tied(%person);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will give us back the Tie::Hash::FixedKeys object that is tied to our &lt;code&gt;%person&lt;/code&gt; hash. This is sometimes used to extend the functionality in ways that aren&amp;rsquo;t available through the standard hash interface. In our fixed keys example, we might want the user to be able to extend or reduce the list of valid keys. There is no way to do this in the standard hash interface so we would need to add new methods called, say, &lt;code&gt;add_keys&lt;/code&gt; and &lt;code&gt;del_keys&lt;/code&gt;, which can be called like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  tied(%person)-&amp;gt;add_keys(&#39;weight&#39;, &#39;height&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you have finished with the tied object and want to return it to being an ordinary hash, you can use the &lt;code&gt;untie&lt;/code&gt; function. For example,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  untie %person;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;returns &lt;code&gt;%person&lt;/code&gt; to being an ordinary hash.&lt;/p&gt;

&lt;p&gt;To tie an object to a Perl hash, your object needs to define the following set of methods. Notice that they are all named in upper case. This is the standard for function names that Perl is going to call for you.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_TIEHASH&#34;&gt;TIEHASH&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This is the constructor function. It is called when the user calls the &lt;code&gt;tie&lt;/code&gt; function. It is passed the name of the class and the list of parameters that were passed to &lt;code&gt;tie&lt;/code&gt;. It should return a reference to the new tied object.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_FETCH&#34;&gt;FETCH&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This is the method that is called when the user accesses a value from the hash. The method is passed a reference to the tied object and the key that the user is trying to access. It should return the value associated with the given key (or &lt;code&gt;undef&lt;/code&gt; if the key isn&amp;rsquo;t found).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_STORE&#34;&gt;STORE&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This method is called when the user tries to store a value against a key in the tied hash. It is passed a reference to the object, together with the key and value pair.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_DELETE&#34;&gt;DELETE&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This method is called when the user calls the &lt;code&gt;delete&lt;/code&gt; function to remove one of the key/value pairs in the tied hash. It is passed a reference to the tied object and the key that the user wishes to remove. The return value becomes the return value from the &lt;code&gt;delete&lt;/code&gt; call. To emulate the &amp;lsquo;real&amp;rsquo; &lt;code&gt;delete&lt;/code&gt; function, this should be the value that was stored in the hash before it was deleted.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_CLEAR&#34;&gt;CLEAR&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This method is called when the user clears the whole hash (usually by assigning an empty list to the hash). It is passed a reference to the tied object.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_EXISTS&#34;&gt;EXISTS&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This method is called when the user calls the &lt;code&gt;exists&lt;/code&gt; function to see whether a given key exists in the hash. It is passed a reference to the tied object and the key to search for. It should return a true value if the key is found and false otherwise.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_FIRSTKEY&#34;&gt;FIRSTKEY&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This method is called when one of the hash iterator functions (&lt;code&gt;each&lt;/code&gt; or &lt;code&gt;keys&lt;/code&gt;) is called for the first time. It is passed a reference to the tied object and should return the first key in the hash.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_NEXTKEY&#34;&gt;NEXTKEY&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This method is called when one of the iterator functions is called. It is passed a reference to the tied object and the name of the last key that was processed. It should return the name of the next key or &lt;code&gt;undef&lt;/code&gt; if there are no more keys.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_UNTIE&#34;&gt;UNTIE&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This method is called when the &lt;code&gt;untie&lt;/code&gt; function is called. It is passed a reference to the tied object.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_DESTROY&#34;&gt;DESTROY&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This method is called when the tied variable goes out of scope. It is passed a reference to the tied object.&lt;/p&gt;

&lt;p&gt;As you can see, there are a large number of methods to implement, but in the next section we&amp;rsquo;ll see how you can get away with only implementing some of them.&lt;/p&gt;

&lt;h3 id=&#34;span-id-a-first-example-tie-hash-fixedkeys-a-first-example-tie-hash-fixedkeys-span&#34;&gt;&lt;span id=&#34;a first example: tie::hash::fixedkeys&#34;&gt;A First Example: Tie::Hash::FixedKeys&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s take a look at the implementation of Tie::Hash::FixedKeys. This module is available on CPAN if you want to take a closer look.&lt;/p&gt;

&lt;p&gt;Writing the module is made far easier for use by the existence of a package called Tie::StdHash. This is a tied hash that mirrors the behavior of a standard Perl hash. This package is stored in the module Tie::Hash. This means that if you wrote code like the following example, then you would have a tied hash that acts the same way as a &amp;lsquo;real&amp;rsquo; hash.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Tie::Hash;

    my %hash;

    tie %hash, &#39;Tie::StdHash&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far, so good. But it hasn&amp;rsquo;t really achieved much. The hash &lt;code&gt;%hash&lt;/code&gt; is now a tied object, but we haven&amp;rsquo;t changed any of its functionalities. Tie::StdHash works much better if it is used as a base class from which you inherit behavior. For example, the start of the Tie::Hash::FixedKeys class looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package Tie::Hash::FixedKeys;

    use strict;
    use Tie::Hash;
    use Carp;
    use vars qw(@ISA);

    @ISA = qw(Tie::StdHash);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is standard for a Perl object, but notice that we&amp;rsquo;ve loaded the Tie::Hash module (with &lt;code&gt;use Tie::Hash&lt;/code&gt;) and have told our package to inherit behavior from Tie::StdHash by putting Tie::StdHash in the &lt;code&gt;@ISA&lt;/code&gt; package variable.&lt;/p&gt;

&lt;p&gt;If we stopped there, our Tie::Hash::FixedKeys package would have the same behavior as a standard Perl hash. This is because each time Perl tried to find one of the tie interface methods (like &lt;a href=&#34;http://localhost:1313/pub/2001/09/04/tiedhash.html#item_FETCH&#34;&gt;&lt;code&gt;FETCH&lt;/code&gt;&lt;/a&gt; or &lt;a href=&#34;http://localhost:1313/pub/2001/09/04/tiedhash.html#item_STORE&#34;&gt;&lt;code&gt;STORE&lt;/code&gt;&lt;/a&gt;) in our package it would fail and would call the version found in our parent class, Tie::StdHash.&lt;/p&gt;

&lt;p&gt;At this point we can start to change the standard hash behavior by simply overriding the methods that we want to change. We&amp;rsquo;ll start by implementing the &lt;a href=&#34;http://localhost:1313/pub/2001/09/04/tiedhash.html#item_TIEHASH&#34;&gt;&lt;code&gt;TIEHASH&lt;/code&gt;&lt;/a&gt; method differently.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub TIEHASH {
      my $class = shift;

      my %hash;

      @hash{@_} = (undef) x @_;

      bless \%hash, $class;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;a href=&#34;http://localhost:1313/pub/2001/09/04/tiedhash.html#item_TIEHASH&#34;&gt;&lt;code&gt;TIEHASH&lt;/code&gt;&lt;/a&gt; function is passed the name of the class as its first parameter, so we &lt;code&gt;shift&lt;/code&gt; that into &lt;code&gt;$class&lt;/code&gt; in the first line. The rest of the parameters in &lt;code&gt;@_&lt;/code&gt; are whatever extra parameters have been passed into the &lt;code&gt;tie&lt;/code&gt; call. In the example of how to use our proposed class at the start of this article, we passed it the list of valid keys. Therefore, we take this list of keys and (using a hash slice) we initialize a hash so that it has &lt;code&gt;undef&lt;/code&gt; as the value for each of these keys. Finally, we take a reference to this hash, bless it into the required class and return the reference.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s worth pointing out here, the one caveat about using Tie::StdHash. In order to use the default behavior, your new class &lt;em&gt;must&lt;/em&gt; be based on a hash reference and this hash must contain &lt;em&gt;only&lt;/em&gt; real hash data. We couldn&amp;rsquo;t, for example, invent a key called &lt;code&gt;_keys&lt;/code&gt; that would contain a list of valid key names as, for example, this key would be shown if the user called the &lt;code&gt;keys&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;At this point we have a hash that has values (of &lt;code&gt;undef&lt;/code&gt;) for each of the allowed keys. This doesn&amp;rsquo;t yet prevent us from adding new keys. For that we need to override the STORE method.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub STORE {
      my ($self, $key, $val) = @_;

      unless (exists $self-&amp;gt;{$key}) {
        croak &amp;quot;invalid key [$key] in hash\n&amp;quot;;
        return;
      }

      $self-&amp;gt;{$key} = $val;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The three parameters passed to the &lt;a href=&#34;http://localhost:1313/pub/2001/09/04/tiedhash.html#item_STORE&#34;&gt;&lt;code&gt;STORE&lt;/code&gt;&lt;/a&gt; method are a reference to the tied object, and a new key/value pair. We need the &lt;a href=&#34;http://localhost:1313/pub/2001/09/04/tiedhash.html#item_STORE&#34;&gt;&lt;code&gt;STORE&lt;/code&gt;&lt;/a&gt; method to prevent new keys being added to the underlying hash, and we achieve that by checking that the given key exists before setting the value. Note that as our underlying object is a real hash, we can check this simply by using the &lt;code&gt;exists&lt;/code&gt; function. If the key doesn&amp;rsquo;t exist we give the user a friendly warning and return from the method without changing the hash.&lt;/p&gt;

&lt;p&gt;We have now prevented the hash from growing by adding keys, but it is still possible to remove keys from the hash (and our &lt;a href=&#34;http://localhost:1313/pub/2001/09/04/tiedhash.html#item_STORE&#34;&gt;&lt;code&gt;STORE&lt;/code&gt;&lt;/a&gt; implementation would prevent them from being set once they had been removed), so we also need to override the implementation of &lt;a href=&#34;http://localhost:1313/pub/2001/09/04/tiedhash.html#item_DELETE&#34;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub DELETE {
      my ($self, $key) = @_;

      return unless exists $self-&amp;gt;{$key};

      my $ret = $self-&amp;gt;{$key};

      $self-&amp;gt;{$key} = undef;

      return $ret;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once again, we don&amp;rsquo;t actually want to change the existing set of keys in the hash, so we check to see whether the key already exists and return immediately if it doesn&amp;rsquo;t. If the key &lt;em&gt;does&lt;/em&gt; exist, then we don&amp;rsquo;t want to actually delete it, so we simply set the value back to &lt;code&gt;undef&lt;/code&gt;. Notice that we note the value before deleting it so that we can return it from the method, thus mimicking the behavior of the real &lt;code&gt;delete&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s one other way to affect the keys in our hash. Code like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %hash = ();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will cause the &lt;a href=&#34;http://localhost:1313/pub/2001/09/04/tiedhash.html#item_CLEAR&#34;&gt;&lt;code&gt;CLEAR&lt;/code&gt;&lt;/a&gt; method to be called. The default behavior for this method is to remove all of the data from the hash. We need to replace this with a method that will reset all of the values to &lt;code&gt;undef&lt;/code&gt; without changing the keys in any way.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub CLEAR {
      my $self = shift;

      $self-&amp;gt;{$_} = undef foreach keys %$self;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that&amp;rsquo;s all that we need to do. All of the other functionality of a standard hash is inherited from Tie::StdHash. You can fetch values from our hash as normal without us writing any more lines of code. Built-in Perl functions like &lt;code&gt;each&lt;/code&gt; and &lt;code&gt;keys&lt;/code&gt; also work as expected.&lt;/p&gt;

&lt;h3 id=&#34;span-id-another-example-tie-hash-regex-another-example-tie-hash-regex-span&#34;&gt;&lt;span id=&#34;another example: tie::hash::regex&#34;&gt;Another Example: Tie::Hash::Regex&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s look at another example. This module came about from a discussion on Perlmonks a couple of months ago. Someone asked whether it was possible to match hash keys approximately. I suggested that a hash that matched keys as regular expressions might solve their problem and wrote the first draft of this module. I&amp;rsquo;m grateful to Jeff Pinyan, who made some suggestions for improvements to the module.&lt;/p&gt;

&lt;p&gt;In order to make this change to the behavior of the hash, we need to override the behavior of the &lt;a href=&#34;http://localhost:1313/pub/2001/09/04/tiedhash.html#item_FETCH&#34;&gt;&lt;code&gt;FETCH&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;http://localhost:1313/pub/2001/09/04/tiedhash.html#item_EXISTS&#34;&gt;&lt;code&gt;EXISTS&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;http://localhost:1313/pub/2001/09/04/tiedhash.html#item_DELETE&#34;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt; methods. Here&amp;rsquo;s the &lt;a href=&#34;http://localhost:1313/pub/2001/09/04/tiedhash.html#item_FETCH&#34;&gt;&lt;code&gt;FETCH&lt;/code&gt;&lt;/a&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  sub FETCH {
    my $self = shift;
    my $key = shift;    

    my $is_re = (ref $key eq &#39;Regexp&#39;);

    return $self-&amp;gt;{$key} if !$is_re &amp;amp;&amp;amp; exists $self-&amp;gt;{$key};

    $key = qr/$key/ unless $is_re;

    /$key/ and return $self-&amp;gt;{$_} for keys %$self;

    return;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Knowing what we know about tied objects, this is pretty simple to follow. We start by getting the reference to the tied object (which will be a hash reference) and the required key. We then check to see whether the key is a reference to a precompiled regular expression (which would have been compiled with &lt;code&gt;qr//&lt;/code&gt;. If the key &lt;em&gt;isn&amp;rsquo;t&lt;/em&gt; a regex, then we start by checking whether the key exists in the hash. If it does, we return the associated value. If the key isn&amp;rsquo;t found, then we assume that it is a regex to search for. At this point we compile the regex as if it isn&amp;rsquo;t already precompiled (this gives us a performance boost as we could potentially need to match the regex against all of the keys in the hash). Finally, we check each key in the hash in turn against the regex and if it matches, then we return the associated value. If there are no matches we simply &lt;code&gt;return&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;At this point you may realize that it&amp;rsquo;s possible for more than one key to match a regex and you may suggest that it would be nice for &lt;a href=&#34;http://localhost:1313/pub/2001/09/04/tiedhash.html#item_FETCH&#34;&gt;&lt;code&gt;FETCH&lt;/code&gt;&lt;/a&gt; to return &lt;em&gt;all&lt;/em&gt; matches as if it was called in scalar context. This is a nice idea, but in current versions of Perl the syntax &lt;code&gt;$hash{$key}&lt;/code&gt; &lt;em&gt;always&lt;/em&gt; calls &lt;a href=&#34;http://localhost:1313/pub/2001/09/04/tiedhash.html#item_FETCH&#34;&gt;&lt;code&gt;FETCH&lt;/code&gt;&lt;/a&gt; in scalar context (and the syntax &lt;code&gt;@hash{@keys}&lt;/code&gt; calls &lt;a href=&#34;http://localhost:1313/pub/2001/09/04/tiedhash.html#item_FETCH&#34;&gt;&lt;code&gt;FETCH&lt;/code&gt;&lt;/a&gt; once in scalar context for each element of &lt;code&gt;@keys&lt;/code&gt;) so this won&amp;rsquo;t work. To get round this, you can use the slightly kludgey syntax &lt;code&gt;@vals = tied(%hash)-&amp;gt;FETCH($pattern)&lt;/code&gt; and the version of the module on CPAN supports this.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;http://localhost:1313/pub/2001/09/04/tiedhash.html#item_EXISTS&#34;&gt;&lt;code&gt;EXISTS&lt;/code&gt;&lt;/a&gt; method uses similar processing, but in this case we return 1 if the key is found instead of the associated value.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  sub EXISTS {
    my $self = shift;
    my $key = shift;

    my $is_re = (ref $key eq &#39;Regexp&#39;);

    return 1 if !$is_re &amp;amp;&amp;amp; exists $self-&amp;gt;{$key};

    $key = qr/$key/ unless $is_re;

    /$key/ &amp;amp;&amp;amp; return 1 for keys %$key;

    return;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;a href=&#34;http://localhost:1313/pub/2001/09/04/tiedhash.html#item_DELETE&#34;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt; method is somewhat different. In this case, we can delete &lt;em&gt;all&lt;/em&gt; matching key/value pairs, which we do with the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  sub DELETE {
    my $self = shift;
    my $key = shift;

    my $is_re = (ref $key eq &#39;Regexp&#39;);

    return delete $self-&amp;gt;{$key} if !$is_re &amp;amp;&amp;amp; exists $self-&amp;gt;{$key};

    $key = qr/$key/ unless $is_re;

    for (keys %$self) {
      if (/$key/) {
        delete $self-&amp;gt;{$_};
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I should point out that there is another similar module on CPAN called Tie::RegexpHash written by robert Rothenberg. Tie::RegexpHash actually does the opposite to Tie::Hash::Regex. When you store a value in it, the key is a regular expression and any time you look up a value with a key, you will get the value associated with the first regex key that matches your string. It&amp;rsquo;s interesting to note that Tie::RegexpHash &lt;em&gt;isn&amp;rsquo;t&lt;/em&gt; based on Tie::StdHash and, as a result, contains a lot more code than Tie::Hash::Regex.&lt;/p&gt;

&lt;p&gt;Another recent addition to CPAN is Tie::Hash::Approx, which was written by Briac Pilpré. This addresses a similar problem, but instead of using regex matching, it uses Jarkko Hietaniemi&amp;rsquo;s String::Approx module.&lt;/p&gt;

&lt;h3 id=&#34;span-id-conclusion-tie-hash-cannabinol-conclusion-tie-hash-cannabinol-span&#34;&gt;&lt;span id=&#34;conclusion: tie::hash::cannabinol&#34;&gt;Conclusion: Tie::Hash::Cannabinol&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;As a final example, here&amp;rsquo;s something that isn&amp;rsquo;t quite so useful. This is a hash that forgets just about everything that you tell it. Its &lt;code&gt;exists&lt;/code&gt; function isn&amp;rsquo;t exactly to be trusted either.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package Tie::Hash::Cannabinol;

    use strict;
    use vars qw($VERSION @ISA);
    use Tie::Hash;

    $VERSION = &#39;0.01&#39;;
    @ISA = qw(Tie::StdHash);

    sub STORE {
      my ($self, $key, $val) = @_;

      return if rand &amp;gt; .75;

      $self-&amp;gt;{$key} = $val;
    }

    sub FETCH {
      my ($self, $key) = @_;

      return if rand &amp;gt; .75;

      return $self-&amp;gt;{rand keys %$self};
    }

    sub EXISTS {
      return rand &amp;gt; .5;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, it&amp;rsquo;s simple to make some radical alterations to the behavior of Perl hashes using &lt;code&gt;tie&lt;/code&gt; and the Tie::StdHash base class. As I said at the start of the article, this often enables you to create new &amp;ldquo;objects&amp;rdquo; without having to make the leap to full object orientation in your programs.&lt;/p&gt;

&lt;p&gt;And it isn&amp;rsquo;t just hashes that you can do it for. The standard Perl distribution also comes with packages called Tie::StdArray, Tie::StdHandle and Tie::StdScalar.&lt;/p&gt;

&lt;p&gt;Have fun with them.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Creating Data Output Files Using the Template Toolkit</title>
      <link>http://localhost:1313/pub/2001/01/tt2.html/</link>
      <pubDate>Tue, 23 Jan 2001 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2001/01/tt2.html/</guid>
      <description>

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Table of Contents&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;•&lt;a href=&#34;#a%20more%20complex%20example&#34;&gt;A more complex example&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
•&lt;a href=&#34;#producing%20xml&#34;&gt;Producing XML&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
•&lt;a href=&#34;#multiple%20formats&#34;&gt;Multiple Formats&lt;/a&gt;&lt;br /&gt;
&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;span-id-introducing-the-template-toolkit-introducing-the-template-toolkit-span&#34;&gt;&lt;span id=&#34;introducing the template toolkit&#34;&gt;Introducing the Template Toolkit&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;There are a number of Perl modules that are universally recognised as The Right Thing To Use for certain tasks. If you accessed a database without using DBI, pulled data from the WWW without using on of the LWP modules or parsed XML without using XML::Parser or one of its subclasses then you&amp;rsquo;d run the risk of being shunned by polite Perl society.&lt;/p&gt;

&lt;p&gt;I believe that the year 2000 saw the emergence of another &amp;lsquo;must have&amp;rsquo; Perl module - the Template Toolkit. I don&amp;rsquo;t think I&amp;rsquo;m alone in this belief as the Template Toolkit won the &amp;lsquo;Best New Module&amp;rsquo; award at the Perl Conference last summer. Version 2.0 of the Template Toolkit (known as TT2 to its friends) was recently released to the CPAN.&lt;/p&gt;

&lt;p&gt;TT2 was designed and written by Andy Wardley &amp;lt;&lt;a href=&#34;mailto:abw@cre.canon.co.uk&#34;&gt;abw@cre.canon.co.uk&lt;/a&gt;&amp;gt;. It was born out of Andy&amp;rsquo;s previous templating module, Text::Metatext, in best Fred Brooks &amp;lsquo;plan to throw one away&amp;rsquo; manner; and aims to be the most useful (or, at least, the most &lt;em&gt;used&lt;/em&gt;) Perl templating system.&lt;/p&gt;

&lt;p&gt;TT2 provides a way to take a file of fixed boilerplate text (the template) and embed variable data within it. One obvious use of this is in the creation of dynamic web pages and this is where a lot of the attention that TT2 has received has been focussed. In this article, I hope to demonstrate that TT2 is just as useful in non-web applications.&lt;/p&gt;

&lt;h3 id=&#34;span-id-using-the-template-toolkit-using-the-template-toolkit-span&#34;&gt;&lt;span id=&#34;using the template toolkit&#34;&gt;Using the Template Toolkit&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s look at how we&amp;rsquo;d use TT2 to process a simple data file. TT2 is an object oriented Perl module. Having downloaded it from CPAN and installed it in the usual manner, using it in your program is as easy as putting the lines&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Template;

    my $tt = Template-&amp;gt;new;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in your code. The constructor function, &lt;code&gt;new&lt;/code&gt;, takes a number of optional parameters which are documented in the copious manual pages that come with the module, but for the purposes of this article we&amp;rsquo;ll keep things as simple as possible.&lt;/p&gt;

&lt;p&gt;To process the template, you would call the &lt;code&gt;process&lt;/code&gt; method like this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $tt-&amp;gt;process(&#39;my_template&#39;, \%data)
      || die $tt-&amp;gt;error;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We pass two parameters to &lt;code&gt;process&lt;/code&gt;, the first is the name of the file containing the template to process (in this case, my_template) and the second is a reference to a hash which contains the data items that you want to use in the template. If processing the template gives any kind of error, the program will die with a (hopefully) useful error message.&lt;/p&gt;

&lt;p&gt;So what kinds of things can go in &lt;code&gt;%data&lt;/code&gt;? The answer is just about anything. Here&amp;rsquo;s an example showing data about English Premier League football teams.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @teams = ({ name =&amp;gt; &#39;Man Utd&#39;,
                   played =&amp;gt; 16,
                   won =&amp;gt; 12,
                   drawn =&amp;gt; 3,
                   lost =&amp;gt; 1 },
                 { name =&amp;gt; &#39;Bradford&#39;,
                   played =&amp;gt; 16,
                   won =&amp;gt; 2,
                   drawn =&amp;gt; 5,
                   lost =&amp;gt; 9 });

    my %data = ( name =&amp;gt; &#39;English Premier League&#39;,
                 season =&amp;gt; &#39;2000/01&#39;,
                 teams =&amp;gt; \@teams );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This creates three data items which can be accessed within the template, called &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;season&lt;/code&gt; and &lt;code&gt;teams&lt;/code&gt;. Notice that &lt;code&gt;teams&lt;/code&gt; is a complex data structure.&lt;/p&gt;

&lt;p&gt;Here is a template that we might use to process this data.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    League Standings

    League Name: [% name %]
    Season     : [% season %]

    Teams:
    [% FOREACH team = teams -%]
    [% team.name %] [% team.played -%] 
     [% team.won %] [% team.drawn %] [% team.lost %]
    [% END %]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running this template with this data gives us the following output&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    League Standings

    League Name: English Premier League
    Season     : 2000/01

    Teams:
    Man Utd 16 12 3 1
    Bradford 16 2 5 9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hopefully the syntax of the template is simple enough to follow. There are a few points to note.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Template processing directives are written using a simple language which is not Perl.&lt;/li&gt;
&lt;li&gt;The keys of the &lt;code&gt;%data&lt;/code&gt; have become the names of the data variables within the template.&lt;/li&gt;
&lt;li&gt;Template processing directives are surrounded by &lt;code&gt;[%&lt;/code&gt; and &lt;code&gt;%]&lt;/code&gt; sequences.&lt;/li&gt;
&lt;li&gt;If these tags are replaced with &lt;code&gt;[%-&lt;/code&gt; &lt;code&gt;-%]&lt;/code&gt; then the preceding or following linefeed is suppressed.&lt;/li&gt;
&lt;li&gt;In the &lt;code&gt;FOREACH&lt;/code&gt; loop, each element of the &lt;code&gt;teams&lt;/code&gt; list was assigned, in turn, to the temporary variable &lt;code&gt;team&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Each item assigned to the &lt;code&gt;team&lt;/code&gt; variable is a Perl hash. Individual values within the hash are accessed using a dot notation.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It&amp;rsquo;s probably the first and last of these points which are the most important. The first point emphasises the separation of the data acquisition logic from the presentation logic. The person creating the presentation template doesn&amp;rsquo;t need to know Perl, they only need to know the data items which will be passed into the template.&lt;/p&gt;

&lt;p&gt;The last point demonstrates the way that TT2 protects the template designer from the implementation of the data structures. The data objects passed to the template processor can be scalars, arrays, hashes, objects or even subroutines. The template processor will just interpret your data correctly and Do The Right Thing to return the correct value to you. In this example each team was a hash, but in a larger system each team might be an object, in which case &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;played&lt;/code&gt;, etc. would be accessor methods to the underlying object attributes. No changes would be required to the template as the template processor would realise that it needed to call methods rather than access hash values.&lt;/p&gt;

&lt;h3 id=&#34;span-id-a-more-complex-example-a-more-complex-example-span&#34;&gt;&lt;span id=&#34;a more complex example&#34;&gt;A more complex example&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Stats about the English Football League are usually presented in a slightly more complex format that the one we used above. A full set of stats will show the number of games that a team has won, lost or drawn, the number of goals scored for and against the team and the number of points that the team therefore has. Teams gain three points for a win and one point for a draw. When teams have the same number of points they are separated by the goal difference, that is the number of goals the team has scored minus the number of team scored against them. To complicate things even further, the games won, drawn and lost and the goals for and against are often split between home and away games.&lt;/p&gt;

&lt;p&gt;Therefore if you have a data source which lists the team name togther with the games won, drawn and lost and the goals for and against split into home and away (a total of eleven data items) you can calculate all of the other items (goal difference, points awarded and even position in the league). Let&amp;rsquo;s take such a file, but we&amp;rsquo;ll only look at the top three teams. It will look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Man Utd,7,1,0,26,4,5,2,1,15,6
  Arsenal,7,1,0,17,4,2,3,3,7,9
  Leicester,4,3,1,10,8,4,2,2,7,4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A simple script to read this data into an array of hashes will look something like this (I&amp;rsquo;ve simplified the names of the data columns - w, d, and l are games won, drawn and lost and f and a are goals scored for and against; h and a at the front of a data item name indicates whether it&amp;rsquo;s a home or away statistic):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my @cols = qw(name hw hd hl hf ha aw ad al af aa);

  my @teams;
  while (&amp;lt;&amp;gt;) {
    chomp;

    my %team;

    @team{@cols} = split /,/;

    push @teams, \%team;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then go thru the teams again and calculate all of the derived data items:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  foreach (@teams) {
    $_-&amp;gt;{w} = $_-&amp;gt;{hw} + $_-&amp;gt;{aw};
    $_-&amp;gt;{d} = $_-&amp;gt;{hd} + $_-&amp;gt;{ad};
    $_-&amp;gt;{l} = $_-&amp;gt;{hl} + $_-&amp;gt;{al};

    $_-&amp;gt;{pl} = $_-&amp;gt;{w} + $_-&amp;gt;{d} + $_-&amp;gt;{l};


    $_-&amp;gt;{f} = $_-&amp;gt;{hf} + $_-&amp;gt;{af};
    $_-&amp;gt;{a} = $_-&amp;gt;{ha} + $_-&amp;gt;{aa};

    $_-&amp;gt;{gd} = $_-&amp;gt;{f} - $_-&amp;gt;{a};

    $_-&amp;gt;{pt} = (3 * $_-&amp;gt;{w}) + $_-&amp;gt;{d};
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then produce a list sorted in descending order:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  @teams 
    = sort { $b-&amp;gt;{pt} &amp;lt;=&amp;gt; $b-&amp;gt;{pt}
             || $b-&amp;gt;{gd} &amp;lt;=&amp;gt; $a-&amp;gt;{gd} } @teams;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally add the league position data item:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $teams[$_]-&amp;gt;{pos} = $_ + 1 
    foreach 0 .. $#teams;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Having pulled all of our data into an internal data structure we can start to produce output using out templates. A template to create a CSV file containing the data split between home and away stats would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  [% FOREACH team = teams -%]
  [% team.pos %],[% team.name %],[% team.pl %],[% team.hw %],
  [%- team.hd %],[% team.hl %],[% team.hf %],[% team.ha %],
  [%- team.aw %],[% team.ad %],[% team.al %],[% team.af %],
  [%- team.aa %],[% team.gd %],[% team.pt %]
  [%- END %]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And processing it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $tt-&amp;gt;process(&#39;split.tt&#39;, { teams =&amp;gt; \@teams }, &#39;split.csv&#39;)
    || die $tt-&amp;gt;error;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;produces the following output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  1,Man Utd,16,7,1,0,26,4,5,2,1,15,6,31,39
  2,Arsenal,16,7,1,0,17,4,2,3,3,7,9,11,31
  3,Leicester,16,4,3,1,10,8,4,2,2,7,4,5,29
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that we&amp;rsquo;ve introduced the third parameter to &lt;code&gt;process&lt;/code&gt;. If this parameter is missing then the TT2 sends its output to &lt;code&gt;STDOUT&lt;/code&gt;. If this parameter is a scalar then it is taken as the name of a file to write the output to. This parameter can also be (amongst other things) a filehandle or a reference to an object which is assumed to implement a &lt;code&gt;print&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;If we weren&amp;rsquo;t interested in the split between home and away games, then we could use a simpler template like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  [% FOREACH team = teams -%]
  [% team.pos %],[% team.name %],[% team.pl %],[% team.w %],
  [%- team.d %],[% team.l %],[% team.f %],[% team.a %],
  [%- team.aa %],[% team.gd %],[% team.pt %]
  [% END -%]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which would produce output like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  1,Man Utd,16,12,3,1,41,10,6,31,39
  2,Arsenal,16,9,4,3,24,13,9,11,31
  3,Leicester,16,8,5,3,17,12,4,5,29
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-producing-xml-producing-xml-span&#34;&gt;&lt;span id=&#34;producing xml&#34;&gt;Producing XML&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;This is starting to show some of the power and flexibility of TT2, but you may be thinking that you could just as easily produce this output with a &lt;code&gt;foreach&lt;/code&gt; loop and a couple of &lt;code&gt;print&lt;/code&gt; statements in your code. This is, of course, true; but that&amp;rsquo;s because I&amp;rsquo;ve chosen a deliberately simple example to explain the concepts. What if we wanted to produce an XML file containing the data? And what if (as I mentioned earlier) the league data was held in an object? The code would then look even easier as most of the code we&amp;rsquo;ve written earlier would be hidden away in &lt;code&gt;FootballLeague.pm&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use FootballLeague;
  use Template;

  my $league = FootballLeague-&amp;gt;new(name =&amp;gt; &#39;English Premier&#39;);

  my $tt = Template-&amp;gt;new;

  $tt-&amp;gt;process(&#39;league_xml.tt&#39;, { league =&amp;gt; $league })
    || die $tt-&amp;gt;error;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the template in &lt;code&gt;league_xml.tt&lt;/code&gt; would look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;
  &amp;lt;!DOCTYPE LEAGUE SYSTEM &amp;quot;league.dtd&amp;quot;&amp;gt;

  &amp;lt;league name=&amp;quot;[% league.name %]&amp;quot; season=&amp;quot;[% league.season %]&amp;quot;&amp;gt;
  [% FOREACH team = league.teams -%]
    &amp;lt;team name=&amp;quot;[% team.name %]&amp;quot;
          pos=&amp;quot;[% team.pos %]&amp;quot;
          played=&amp;quot;[% team.pl %]&amp;quot;
          goal_diff=&amp;quot;[% team.gd %]&amp;quot;
          points=&amp;quot;[% team.pt %]&amp;quot;&amp;gt;
       &amp;lt;stats type=&amp;quot;home&amp;quot;&amp;gt;
              win=&amp;quot;[% team.hw %]&amp;quot;
              draw=&amp;quot;[%- team.hd %]&amp;quot;
              lose=&amp;quot;[% team.hl %]&amp;quot;
              for=&amp;quot;[% team.hf %]&amp;quot;
              against=&amp;quot;[% team.ha %]&amp;quot; /&amp;gt;
       &amp;lt;stats type=&amp;quot;away&amp;quot;&amp;gt;
              win=&amp;quot;[% team.aw %]&amp;quot;
              draw=&amp;quot;[%- team.ad %]&amp;quot;
              lose=&amp;quot;[% team.al %]&amp;quot;
              for=&amp;quot;[% team.af %]&amp;quot;
              against=&amp;quot;[% team.aa %]&amp;quot; /&amp;gt;
    &amp;lt;/team&amp;gt;
  [% END -%]
  &amp;lt;/league&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that as we&amp;rsquo;ve passed the whole object into &lt;code&gt;process&lt;/code&gt; then we need to put an extra level of indirection on our template variables - everything is now a component of the &lt;code&gt;league&lt;/code&gt; variable. Other than that, everything in the template is very similar to what we&amp;rsquo;ve used before. Presumably now &lt;code&gt;team.name&lt;/code&gt; calls an accessor function rather than carrying out a hash lookup, but all of this is transparent to our template designer.&lt;/p&gt;

&lt;h3 id=&#34;span-id-multiple-formats-multiple-formats-span&#34;&gt;&lt;span id=&#34;multiple formats&#34;&gt;Multiple Formats&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;As a final example, let&amp;rsquo;s suppose that we need to create out football league tables in a number of formats. Perhaps we are passing this data on to other people and they can&amp;rsquo;t all use the same format. Some of our users need CSV files and others need XML. Some require data split between home and away matches and other just want the totals. In total, then, we&amp;rsquo;ll need four different templates, but the good news is that they can use the same data object. All the script needs to do is to establish which template is required and process it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use FootballLeague;
  use Template;

  my ($name, $type, $stats) = @_;

  my $league = FootballLeague-&amp;gt;new(name =&amp;gt; $name);

  my $tt = Template-&amp;gt;new;

  $tt-&amp;gt;process(&amp;quot;league_${type}_$stats.tt&amp;quot;, 
               { league =&amp;gt; $league }
               &amp;quot;league_$stats.$type&amp;quot;)
    || die $tt-&amp;gt;error;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example, calling this script as&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  league.pl &#39;English Premier&#39; xml split
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will process a template called &lt;code&gt;league_xml_split.tt&lt;/code&gt; and put the results in a file called &lt;code&gt;league_split.xml&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This starts to show the true strength of the Template Toolkit. If we later wanted to add another file format - perhaps we wanted to create a league table HTML page or even a LaTeX document - then we would just need to create the appropriate template and name it according to our existing naming convention. We would need to make no changes to the code.&lt;/p&gt;

&lt;p&gt;I hope you can now see why the Template Toolkit is fast becoming an essential part of many people&amp;rsquo;s Perl installation.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

