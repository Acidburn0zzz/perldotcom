<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Barrie Slaymaker on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/authors/barrie-slaymaker/</link>
    <description>Recent content in Barrie Slaymaker on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 24 Sep 2002 00:00:00 -0800</lastBuildDate>
    <atom:link href="/authors/barrie-slaymaker/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>An AxKit Image Gallery</title>
      <link>http://localhost:1313/pub/2002/09/24/axkit.html/</link>
      <pubDate>Tue, 24 Sep 2002 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2002/09/24/axkit.html/</guid>
      <description>

&lt;p&gt;AxKit is not limited to working with pure XML data. Starting with this article, we&amp;rsquo;ll work with and around non-XML data by developing an image browser that works with two types of non-XML data: a directory listing built from operating system calls (file names and statistics) and image files. Furthermore, it will be built from small modules that you can adapt to your needs or use elsewhere, like the &lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=4#My::Thumbnailer&#34;&gt;thumbnail generator&lt;/a&gt; or the &lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=3#XML::Filter::TableWrapper&#34;&gt;HTML table wrapper&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;By the time we&amp;rsquo;re done, several articles from now, we&amp;rsquo;d like an application that:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;provides navigation around a tree of directories containing images,&lt;/li&gt;
&lt;li&gt;displays &lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=1#proofsheet.png&#34;&gt;image galleries with thumbnails&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;ignores nonimage files,&lt;/li&gt;
&lt;li&gt;allows you to define and present a custom set of information (&amp;ldquo;meta data&amp;rdquo;) about each image,&lt;/li&gt;
&lt;li&gt;allows you to view the complete images with and without metadata,&lt;/li&gt;
&lt;li&gt;uses a non-AxKit mod_perl handler to generate thumbnail images on the fly, and&lt;/li&gt;
&lt;li&gt;allows you to edit the metadata information in-browser&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That feature list should allow us to build a &amp;ldquo;real world&amp;rdquo; application (rather than the weather examples we&amp;rsquo;ve discussed so far), and hopefully a useful one as well. Here&amp;rsquo;s a screenshot of the page created by this article and the next:&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;proofsheet.png&#34;&gt;&lt;/span&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2002_09_24_axkit/proofsheet.png&#34; alt=&#34;Example page.&#34; width=&#34;472&#34; height=&#34;661&#34; /&gt;&lt;/p&gt;

&lt;p&gt;That page has four sections:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Heading&lt;/strong&gt;: Tells you where you are and offers navigation up the directory tree.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Folders&lt;/strong&gt;: links to the parent directory and any sub folders (Jim and Mary).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Images&lt;/strong&gt;: offers a thumbnail and caption area for each image. Clicking on an image or image title takes you to the full-size variant.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Footer&lt;/strong&gt;: A breadcrumbs display for getting back up the directory tree after scrolling down through a large page of images.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We&amp;rsquo;ll implement the (most challenging) third section in this article and the other section in the next article.&lt;/p&gt;

&lt;p&gt;If you want to review the basics of AxKit and Apache configuration, then here are the previous articles in this series:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/03/12/axkit.html&#34;&gt;Introducing AxKit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/04/16/axkit.html&#34;&gt;XSP, Taglibs and Pipelines&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/07/02/axkit.html&#34;&gt;Taglib TMTOWTDI&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;span id=&#34;WorkingWithNonXMLDataAsXML&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&#34;working-with-non-xml-data-as-xml&#34;&gt;Working with non-XML data as XML&lt;/h3&gt;

&lt;p&gt;The easiest way to actually work with non-XML data in AxKit is to turn it in to XML often and feed it to AxKit. AxKit itself takes this approach in its new directory handling feature &amp;ndash; thanks to Matt Sergeant and JÃ¶rg Walters AxKit can now scan the directory and build an XML document with all of the data. This is a lot like what native Apache does when it serves up an HTML directory listing, but it allows you to filter it. The main part of this article is about filtering this directory listing in order to create a gallery, or proofsheet, of thumbnail images.&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;p&gt;&lt;strong&gt;In This Series&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/03/16/axkit.html&#34;&gt;Introducing AxKit&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
The first in a series of articles by Barrie Slaymaker on setting up and running AxKit. AxKit is a mod_perl application for dynamically transforming XML. In this first article, we focus on getting started with AxKit.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/04/16/axkit.html&#34;&gt;XSP, Taglibs and Pipelines&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
Barrie explains what a &amp;quot;taglib&amp;quot; is, and how to use them to create dynamic pages inside of AxKit.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/07/02/axkit.html&#34;&gt;Taglib TMTOWTDI&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
Continuing our look at AxKit tag libraries, Barrie explains the use of SimpleTaglib and LogicSheets.&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;In this case, we&amp;rsquo;ll be using a relatively recent addition to AxKit&amp;rsquo;s standard toolkit, SAX Machines, integrated in to AxKit thanks to Kip Hampton. (disclaimer: &lt;a href=&#34;https://metacpan.org/pod/XML::SAX::Machines&#34;&gt;XML::SAX::Machines&lt;/a&gt; is a module I wrote.) The SAX machine we&amp;rsquo;ll create will be a straight pipeline with a few filters, a lot like the pipelines that AxKit uses. This pipeline will dissect directory listings and generate a list of images segmented into rows for easy display purposes. We don&amp;rsquo;t get in to the details of SAX or SAX machines except to bolt together three building blocks; all of the gory details are handled for us by other modules. If you are interested in the gory details, then see &lt;a href=&#34;https://www.xml.com/pub/a/2002/02/13/sax-machines.html&#34;&gt;Part One&lt;/a&gt; and &lt;a href=&#34;https://www.xml.com/pub/a/2002/03/20/machines.html&#34;&gt;Part Two&lt;/a&gt; of Kip&amp;rsquo;s article &amp;ldquo;Introducing XML::SAX::Machines&amp;rdquo; on &lt;a href=&#34;https://www.xml.com/&#34;&gt;XML.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;After the SAX machine builds our list of images, XSLT will be used to merge in metadata (like image titles and comments) from independant XML files and format the result for the browser. The resulting pages look like:&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;ManagingNonXMLData&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&#34;managing-non-xml-data-the-images&#34;&gt;Managing non-XML data (the images)&lt;/h3&gt;

&lt;p&gt;On the other hand, it doesn&amp;rsquo;t make sense to XMLify raw image data (though things like &lt;a href=&#34;http://www.w3.org/TR/SVG/&#34;&gt;SVG&lt;/a&gt;&amp;ndash;covered in &lt;a href=&#34;http://www.xml.com/pub/at/22&#34;&gt;XML.com&amp;rsquo;s Sacre SVG articles&lt;/a&gt;&amp;ndash;and &lt;a href=&#34;https://wiki.gnome.org/Apps/Dia/&#34;&gt;dia&lt;/a&gt; files are a natural fit), so we&amp;rsquo;ll take advantage of AxKit&amp;rsquo;s integration with Apache and mod_perl to delegate image handlng to these more suitable tools.&lt;/p&gt;

&lt;p&gt;This is done by using a distinctive URL for thumbnail image files and a custom mod_perl handler, &lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=4#My::Thumbnailer&#34;&gt;My::Thumbnailer&lt;/a&gt; to convert full-size images to thumbnails. Neither AxKit nor mod_perl code will be used to serve the images, that will be left to Apache.&lt;/p&gt;

&lt;p&gt;Thumbnails will be autogenerated in files with the same name as the main image file with a leading period (&amp;ldquo;.&amp;rdquo;) stuck on the front. In Unix land, this indicates a hidden file, and we don&amp;rsquo;t want thumbnails (or other dotfiles) showing up in our gallery pages.&lt;/p&gt;

&lt;p&gt;My::Thumbnailer uses the relatively new &lt;a href=&#34;https://metacpan.org/pod/Imager&#34;&gt;Imager&lt;/a&gt; module by Arnar M. Hrafnkelsson and Tony Cook. This is a best-of-breed module that competes with the likes of the venerable &lt;a href=&#34;https://metacpan.org/pod/GD&#34;&gt;GD&lt;/a&gt;, the juggernaut &lt;a href=&#34;https://metacpan.org/pod/Image::Magick&#34;&gt;Image::Magick&lt;/a&gt;, and &lt;a href=&#34;https://metacpan.org/pod/Graphics::Libplot&#34;&gt;Graphics::Libplot&lt;/a&gt;). Imager is gaining a reputation for speed, quality and a full-featured API.&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;TheMetaFile&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&#34;the-meta-file&#34;&gt;The &lt;code&gt;.meta&lt;/code&gt; file&lt;/h3&gt;

&lt;p&gt;Before we delve in to the implementation, let&amp;rsquo;s look at one of the more subtle points of this design. Our previous examples have all been of straight pipelines that successively process a source document into an HTML page. In this application, however, we&amp;rsquo;ll be funneling data from the source document and a collection of related files we&amp;rsquo;ll call meta files.&lt;/p&gt;

&lt;p&gt;This subtlety is not apparent from the &lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=1#proofsheet.png&#34;&gt;screenshot&lt;/a&gt;, but if you look closely you can see that the caption for the first image (&amp;ldquo;A baby picture&amp;rdquo;) contains more information than the captions for the other eight. This is because the first image has a meta file that contains a title and a comment to be displayed while the others don&amp;rsquo;t (though they could).&lt;/p&gt;

&lt;p&gt;The first image (&amp;ldquo;A baby picture&amp;rdquo;) is from a file named &lt;code&gt;a-look.jpeg&lt;/code&gt;, for which there is a meta file named &lt;code&gt;a-look.meta&lt;/code&gt; in the same directory that looks like (&lt;strong&gt;bold&lt;/strong&gt; shows the data that ends up getting sent to the browser):&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;a-look.meta&#34;&gt;&lt;/span&gt;
        &lt;meta&gt;
          &lt;title&gt;A baby picture&lt;/title&gt;
          &lt;comment&gt;
            &lt;b&gt;ME!&lt;/b&gt;.  Well, not really.  Actually, it&amp;rsquo;s some
            random image from the &amp;lsquo;net.
          &lt;/comment&gt;
        &lt;/meta&gt;&lt;/p&gt;

&lt;p&gt;An important feature of this file is that its contents and how they are presented within the caption area are completely unspecified by the core image gallery code. This makes our image gallery highly customizable: the site designer can determine what meta information needs to be associated with each image and how that information gets presented. Data can be presented in the thumbnail caption, in the expanded view, or used for nondisplay purposes.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s what&amp;rsquo;s in each caption area:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;The title&lt;/strong&gt;. If a .meta file is found for an image and it has a nonempty &lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; element, then it is used as the name, otherwise the image&amp;rsquo;s filename is stripped of extensions and used.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;The last modified time of the image file&lt;/strong&gt; (in server-local time, unfortunately).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;A comment&lt;/strong&gt; (optional): if a .meta file has a &lt;code&gt;&amp;lt;comment&amp;gt;&lt;/code&gt; element, including XHTML markup, it is displayed.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Why a .meta file per image instead of one huge file? It will hopefully allow admins to manage images and meta files together and to allow us to access an image&amp;rsquo;s meta information in a single file, a natural thing to do in AxKit. By having a pair of files for each image, you can use simple filesystem manipulations to move them around, or use filesystem links to make an image appear in multiple directories, perhaps with the same meta file, perhaps with different ones. This way we don&amp;rsquo;t need to develop a lot of complex features to get a lot of mileage out of our image gallery (though we could if need be).&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;ThePipeline&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&#34;the-pipeline&#34;&gt;The Pipeline&lt;/h3&gt;

&lt;p&gt;No AxKit implementation documentation would be complete without detailing the pipeline. Here is the pipeline for the image proofsheet page shown above (click on any of the boxes to take you to the discussion about that portion of the pipeline, click on any of the miniature versions of this diagram to come to this one):&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;pipeline.png&#34;&gt;&lt;/span&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2002_09_24_axkit/pipeline.png&#34; alt=&#34;The AxKit pipeline for the image gallery application, take 1&#34; width=&#34;450&#34; height=&#34;385&#34; /&gt;&lt;br /&gt;
The blue documents are content: the directory listing, the meta files and the generated HTML. This does not show the image processing, see &lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=4#My::Thumbnailer&#34;&gt;My::Thumbnailer&lt;/a&gt; for that.&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/p&gt;

&lt;p&gt;In this case, unlike our previous pipelines, data does not flow in a purely linear fashion: The directory listing from AxKit (&lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=2#filelist&#34;&gt;&amp;lt;filelist&amp;gt;&lt;/a&gt;) feeds the pipeline and is massaged by three SAX filters and then by four XSLT filters. There are so many filters because this application is built to be customizable by tweaking specific filters or by adding other filters to the pipeline. It also uses several SAX filters available on CPAN to make life much easier for us.&lt;/p&gt;

&lt;p&gt;In actual use, you may want to add more filters for things like branding, distinguishing groups of images by giving directory heirarchies different backgrounds or titles, adding ad banners, etc.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a brief description of what each filter does, and why each is an independant filter:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=2#My::ProofSheetMachine&#34;&gt;My::ProofSheetMachine&lt;/a&gt; is a short module that builds a &lt;a href=&#34;https://metacpan.org/pod/XML::SAX::Machines&#34;&gt;SAX Machine Pipeline&lt;/a&gt;. SAX filters are used in this application to handle tasks that are more suited to Perl than to XSLT or XSP:

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=2#My::Filelist2Data&#34;&gt;My::FileList2Data&lt;/a&gt; is another short module that uses the &lt;a href=&#34;https://metacpan.org/pod/XML::Simple&#34;&gt;XML::Simple&lt;/a&gt; module from CPAN to convert the &lt;code&gt;&amp;lt;filelist&amp;gt;&lt;/code&gt; in to a Perl data structure that is passed on. This is its own filter because we want to customize XML::Simple and the resulting data structure a bit before passing it on.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=3#My::ProofSheet&#34;&gt;My::ProofSheet&lt;/a&gt; is the heart of the gallery page generation. It builds a list of images from the filelist data structure and adds information about the thumbnail images and meta files.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=3#XML::Filter::TableWrapper&#34;&gt;XML::Filter::TableWrapper&lt;/a&gt; is a module from CPAN that is used to wrap a possibly lengthy list of images into rows of no more than five images each.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=3#rowsplitter.xsl&#34;&gt;rowsplitter.xsl&lt;/a&gt; takes each row of images and makes it into two table rows: one for the images and one for the captions. This is easier to do in XSLT than in SAX, so here is where we shift from SAX processing to XSLT processing.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=3#metamerger.xsl&#34;&gt;metamerger.xsl&lt;/a&gt; examines each caption to see if My::ProofSheet put the URL for a meta file in it. If so, it opens the meta file and inserts it in the caption. This is a separate filter because the site admin may prefer to write a custom filter here to integrate meta information from some other source, like a single master file or a centralized database.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=4#captionstyler.xsl&#34;&gt;captionstyler.xsl&lt;/a&gt; looks at each caption and rewrites it to be XHTML. This is a separate filter for two reasons: it allows the look and feel of the captions to be altered without having to mess with the other filters and, because it is the only filter that cares about the contents of the meta file, the site admin can alter the schema of the meta files and then alter this filter to match.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=4#pagestyler.xsl&#34;&gt;pagestyler.xsl&lt;/a&gt; converts everything outside of the caption elements in to HTML. It is separate so that the page look and feel can be altered per-site or per-directory without affecting the caption content, etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are several key things to note about this design. The first is that the separation of the process into multiple filters offers the administrator the ability to modify the site&amp;rsquo;s content and styling. Second, because AxKit is built on Apache&amp;rsquo;s configuration engine, which filters are used for a particular directory request can be selected based on URL, directory path, query string parameters, browser types, etc. The third point to note is the use of SAX processors to handle tasks that are easier (far easier in some cases) to implement in Perl, while XSLT is used when it is more (programmer and/or processor) efficient.&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;httpd.conf&#34;&gt;&lt;/span&gt;&lt;span id=&#34;TheConfiguration&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&#34;the-configuration&#34;&gt;The Configuration&lt;/h3&gt;

&lt;p&gt;Here&amp;rsquo;s how we configure AxKit to do all of this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ##
    ## Init the httpd to use our &amp;quot;private install&amp;quot; libraries
    ##
    PerlRequire startup.pl

    ##
    ## AxKit Configuration
    ##
    PerlModule AxKit

    &amp;lt;Directory &amp;quot;/home/me/htdocs&amp;quot;&amp;gt;
        Options -All +Indexes +FollowSymLinks

        # Tell mod_dir to translate / to /index.xml or /index.xsp
        DirectoryIndex index.xml index.xsp
        AddHandler axkit .xml .xsp

        AxDebugLevel 10

        AxTraceIntermediate /home/me/axtrace

        AxGzipOutput Off

        AxAddXSPTaglib AxKit::XSP::Util
        AxAddXSPTaglib AxKit::XSP::Param

        AxAddStyleMap text/xsl \
                      Apache::AxKit::Language::LibXSLT

        AxAddStyleMap application/x-saxmachines \
                      Apache::AxKit::Language::SAXMachines

    &amp;lt;/Directory&amp;gt;


    &amp;lt;Directory &amp;quot;/home/me/htdocs/04&amp;quot;&amp;gt;
        # Enable XML directory listings (see Generating File Lists)
        AxHandleDirs On

        #######################
        # Begin pipeline config
        AxAddRootProcessor application/x-saxmachines . \
            {http://axkit.org/2002/filelist}filelist
        PerlSetVar AxSAXMachineClass &amp;quot;My::ProofSheetMachine&amp;quot;

        # The absolute stylesheet URLs are because
        # I prefer to keep stylesheets out of the
        # htdocs for security reasons.
        AxAddRootProcessor text/xsl file:///home/me/04/rowsplitter.xsl \
            {http://axkit.org/2002/filelist}filelist

        AxAddRootProcessor text/xsl file:///home/me/04/metamerger.xsl \
            {http://axkit.org/2002/filelist}filelist

        AxAddRootProcessor text/xsl file:///home/me/04/captionstyler.xsl \
            {http://axkit.org/2002/filelist}filelist

        AxAddRootProcessor text/xsl file:///home/me/04/pagestyler.xsl \
            {http://axkit.org/2002/filelist}filelist
        # End pipeline config
        #####################

        # This is read by My::ProofSheetMachine
        PerlSetVar MyColumns 5

        # This is read by My::ProofSheet
        PerlSetVar MyMaxX 100

        # Send thumbnail image requests to our
        # thumbnail generator
        &amp;lt;FilesMatch &amp;quot;^\.&amp;quot;&amp;gt;
            SetHandler  perl-script
            PerlHandler My::Thumbnailer
            PerlSetVar  MyMaxX 100
            PerlSetVar  MyMaxY 100
        &amp;lt;/FilesMatch&amp;gt;

    &amp;lt;/Directory&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first &lt;code&gt;&amp;lt;Directory&amp;gt;&lt;/code&gt; section contains the AxKit directives we introduced in &lt;a href=&#34;http://localhost:1313/pub/2002/07/02/axkit.html?page=2#MixingAndMatching&#34;&gt;article 1&lt;/a&gt; and a new stylesheet mapping for &lt;code&gt;application/x-saxmachines&lt;/code&gt; that allows us to use a SAX machine in the pipeline. Otherwise, all of the configuration directives key to this example are in the &lt;code&gt;&amp;lt;Directory &amp;quot;/home/me/htdocs/04&amp;quot;&amp;gt;&lt;/code&gt; section.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We saw basic examples of how AxKit works with the Apache configuration engine in &lt;a href=&#34;http://localhost:1313/pub/2002/07/02/axkit.html?page=2#MixingAndMatching&#34;&gt;article 1&lt;/a&gt; and &lt;a href=&#34;http://localhost:1313/pub/2002/04/16/axkit.html#httpd.conf&#34;&gt;article 2&lt;/a&gt; in this series. We&amp;rsquo;ll use this photo gallery application to demonstrate many of the more powerful mechanisms in a future article.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;By setting &lt;code&gt;AxHandleDirs On&lt;/code&gt;, we tell AxKit to generate the &amp;lt;filelist&amp;gt; document (&lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=2#GeneratingFileLists&#34;&gt;described in the section Generating File Lists&lt;/a&gt;) in the 04 directory and below.&lt;/p&gt;

&lt;p&gt;Then it&amp;rsquo;s off to configure the pipeline for the 04 directory hierarchy. To do this, we take advantage of the fact that AxKit places all elements in the filelist document in to the namespace &lt;code&gt;http://axkit.org/2002/filelist&lt;/code&gt;. The &lt;code&gt;AxAddRootProcessor&lt;/code&gt;&amp;rsquo;s third parameter causes AxKit to look at all documents it serves from the 04 directory tree and check to see whether the root element matches the namespace and element name.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This is specified in the notation used by James Clark in his &lt;a href=&#34;http://www.jclark.com/xml/xmlns.htm&#34;&gt;introduction to XML namespaces&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If the document matches, and all AxKit-generated filelists will, then the MIME type and the stylesheet specified in the first two parameters are added to the pipeline. The four &lt;code&gt;AxAddRootProcessor&lt;/code&gt; directives add the SAX machine and the four XSLT filters we described in &lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html#ThePipeline&#34;&gt;the section &amp;ldquo;The Pipeline&amp;rdquo;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;When loading a SAX machine into the pipeline, you can give it a simple list of SAX filters (&lt;a href=&#34;https://metacpan.org/search?q=XML%3A%3AFilter&#34;&gt;there are many available on CPAN&lt;/a&gt;) and it will build a pipeline of them. This is done with a (not shown) &lt;code&gt;PerlSetVar AxSAXMachineFilters &amp;quot;...&amp;quot;&lt;/code&gt; directive. The limitation with this directive is that you cannot pass in any initialization values to the filters and we want to.&lt;/p&gt;

&lt;p&gt;So, instead, we use the &lt;code&gt;PerlSetVar AxSAXMachineClass &amp;quot;My::ProofSheetMachine&amp;quot;&lt;/code&gt; to tell the Apache::AxKit::Language::SAXMachines module to load the class &lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=2#My::ProofSheetMachine&#34;&gt;My::ProofSheetMachine&lt;/a&gt; and let that class construct the SAX machine.&lt;/p&gt;

&lt;p&gt;The final part of the configuration uses a &lt;code&gt;&amp;lt;Files&amp;gt;&lt;/code&gt; section to forward all requests for thumbnail images to the mod_perl handler in &lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=4#My::Thumbnailer&#34;&gt;My::Thumbnailer&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;WalkingThePipeline&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&#34;walking-the-pipeline&#34;&gt;Walking the Pipeline&lt;/h3&gt;

&lt;p&gt;Now that we have our filters in place, let&amp;rsquo;s walk the pipeline and take a look at each filter and what it emits.&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;filelist&#34;&gt;&lt;/span&gt;&lt;span id=&#34;GeneratingFileLists&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&#34;generating-file-lists&#34;&gt;Generating File Lists&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html#pipeline.png&#34; id=&#34;pipeline_filelist.png&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2002_09_24_axkit/pipeline_filelist.png&#34; alt=&#34;&amp;lt;filelist&amp;gt; document&amp;#39;s position in the processing pipeline&#34; width=&#34;110&#34; height=&#34;84&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;First, here&amp;rsquo;s a look at the &lt;code&gt;&amp;lt;filelist&amp;gt;&lt;/code&gt; document that feeds the chain. This is created by AxKit when it serves a directory request in much the same way that Apache creates HTML directory listings. AxKit only generates these pages when &lt;code&gt;AxHandleDirs On&lt;/code&gt; directive. This causes AxKit to scan the directory for the above screenshot and emit XML like (whitespace added, repetitive stuff elided):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
    &amp;lt;!DOCTYPE filelist PUBLIC
      &amp;quot;-//AXKIT/FileList XML V1.0//EN&amp;quot;
      &amp;quot;file:///dev/null&amp;quot;
    &amp;gt;
    &amp;lt;filelist xmlns=&amp;quot;http://axkit.org/2002/filelist&amp;quot;&amp;gt;
      &amp;lt;directory
        atime=&amp;quot;1032276941&amp;quot;
        mtime=&amp;quot;1032276939&amp;quot;
        ctime=&amp;quot;1032276939&amp;quot;
        readable=&amp;quot;1&amp;quot;
        writable=&amp;quot;1&amp;quot;
        executable=&amp;quot;1&amp;quot;
        size=&amp;quot;4096&amp;quot; &amp;gt;.&amp;lt;/directory&amp;gt;
      &amp;lt;directory ...&amp;gt;..&amp;lt;/directory&amp;gt;
      &amp;lt;directory ...&amp;gt;Mary&amp;lt;/directory&amp;gt;
      &amp;lt;directory ...&amp;gt;Jim&amp;lt;/directory&amp;gt;
      &amp;lt;file mtime=&amp;quot;1031160766&amp;quot; ...&amp;gt;a-look.jpeg&amp;lt;/file&amp;gt;
      &amp;lt;file mtime=&amp;quot;1031160787&amp;quot; ...&amp;gt;a-lotery.jpeg&amp;lt;/file&amp;gt;
      &amp;lt;file mtime=&amp;quot;1031160771&amp;quot; ...&amp;gt;a-lucky.jpeg&amp;lt;/file&amp;gt;
      &amp;lt;file mtime=&amp;quot;1032197214&amp;quot; ...&amp;gt;a-look.meta&amp;lt;/file&amp;gt;
      &amp;lt;file mtime=&amp;quot;1035239142&amp;quot; ...&amp;gt;foo.html&amp;lt;/file&amp;gt;
      ...
    &amp;lt;/filelist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The emboldened bits are the pieces of data we want to display: some filenames and their modification times. Some things to notice:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;All of the elements &amp;ndash; most importantly the root element as we&amp;rsquo;ll see in a bit &amp;ndash; are in a special namespace, &lt;code&gt;http://axkit.org/2002/filelist&lt;/code&gt;, using the &lt;code&gt;xmlns=&lt;/code&gt; attribute (see &lt;a href=&#34;http://www.jclark.com/xml/xmlns.htm&#34;&gt;James Clark&amp;rsquo;s introduction&lt;/a&gt; for details).&lt;/li&gt;
&lt;li&gt;The entries are in unsorted order. We might want to allow the user to sort by different attributes someday, but this means that we at least need to sort the results somehow.&lt;/li&gt;
&lt;li&gt;They contain the complete output from the &lt;code&gt;stat()&lt;/code&gt; system call as attributes, so we can use the &lt;code&gt;mtime&lt;/code&gt; attribute to derive a modification time.&lt;/li&gt;
&lt;li&gt;There are files in there (&lt;code&gt;a-look.meta&lt;/code&gt; and &lt;code&gt;foo.html&lt;/code&gt;) that we clearly should not be displayed as images.&lt;/li&gt;
&lt;li&gt;The filename for &lt;code&gt;a-look.jpeg&lt;/code&gt; is not emboldened: We&amp;rsquo;ll use the &lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; element from the &lt;code&gt;a-look.meta&lt;/code&gt; file instead.&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- --&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
    &amp;lt;!DOCTYPE filelist PUBLIC
      &amp;quot;-//AXKIT/FileList XML V1.0//EN&amp;quot;
      &amp;quot;file:///dev/null&amp;quot;
    &amp;gt;
    &amp;lt;filelist xmlns=&amp;quot;http://axkit.org/2002/filelist&amp;quot;&amp;gt;
      &amp;lt;directory
        atime=&amp;quot;1032276941&amp;quot;
        mtime=&amp;quot;1032276939&amp;quot;
        ctime=&amp;quot;1032276939&amp;quot;
        readable=&amp;quot;1&amp;quot;
        writable=&amp;quot;1&amp;quot;
        executable=&amp;quot;1&amp;quot;
        size=&amp;quot;4096&amp;quot; &amp;gt;.&amp;lt;/directory&amp;gt;
      &amp;lt;directory ...&amp;gt;..&amp;lt;/directory&amp;gt;
      &amp;lt;directory ...&amp;gt;Mary&amp;lt;/directory&amp;gt;
      &amp;lt;directory ...&amp;gt;Jim&amp;lt;/directory&amp;gt;
      &amp;lt;file mtime=&amp;quot;1031160766&amp;quot; ...&amp;gt;a-look.jpeg&amp;lt;/file&amp;gt;
      &amp;lt;file mtime=&amp;quot;1031160787&amp;quot; ...&amp;gt;a-lotery.jpeg&amp;lt;/file&amp;gt;
      &amp;lt;file mtime=&amp;quot;1031160771&amp;quot; ...&amp;gt;a-lucky.jpeg&amp;lt;/file&amp;gt;
      &amp;lt;file mtime=&amp;quot;1032197214&amp;quot; ...&amp;gt;a-look.meta&amp;lt;/file&amp;gt;
      &amp;lt;file mtime=&amp;quot;1035239142&amp;quot; ...&amp;gt;foo.html&amp;lt;/file&amp;gt;
      ...
    &amp;lt;/filelist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span id=&#34;My::ProofSheetMachine&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&#34;my-proofsheetmachine&#34;&gt;My::ProofSheetMachine&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html#pipeline.png&#34; id=&#34;pipeline_proofsheetmachine_pm.png&#34;&gt;&lt;/a&gt; &lt;img src=&#34;http://localhost:1313/images/_pub_2002_09_24_axkit/pipeline_proofsheetmachine_pm.png&#34; alt=&#34;My::ProofSheetMachine&amp;#39;s position in the processing pipeline.&#34; width=&#34;110&#34; height=&#34;84&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The processing pipeline is kicked off with a set of three SAX filters built by the My::ProofSheetMachine module:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package My::ProofSheetMachine;

    use strict;

    use XML::SAX::Machines qw( Pipeline );
    use My::ProofSheet;
    use XML::Filter::TableWrapper;

    sub new {
        my $proto = shift;
        return bless {}, ref $proto || $proto;
    }

    sub get_machine {
        my $self = shift;
        my ( $r ) = @_;

        my $m = Pipeline(
            My::Filelist2Data
            =&amp;gt; My::ProofSheet-&amp;gt;new( Request =&amp;gt; $r ),
            =&amp;gt; XML::Filter::TableWrapper-&amp;gt;new(
                ListTags =&amp;gt; &amp;quot;{}images&amp;quot;,
                Columns  =&amp;gt; $r-&amp;gt;dir_config( &amp;quot;MyColumns&amp;quot; ) || 3,
            ),
        );

        return $m;
    }

    1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This module provides a minimal constructor, &lt;code&gt;new()&lt;/code&gt; so it can be instantiated (this is an Apache::AxKit::Language::SAXMachines requirement, we don&amp;rsquo;t need that for our sake). AxKit will call the &lt;code&gt;get_machine()&lt;/code&gt; method once each request to obtain the SAX machine is used. SAX machines are not reused from request to request.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$r&lt;/code&gt; is a reference to the &lt;a href=&#34;https://metacpan.org/pod/Apache::Request&#34;&gt;Apache request&lt;/a&gt; object (well, actually, to an AxKit subclass of it). This is passed into &lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=3#My::ProofSheet&#34;&gt;My::ProofSheet&lt;/a&gt;, which uses to interact query some &lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=2#httpd.conf&#34;&gt;httpd.conf&lt;/a&gt; settings, to control AxKit&amp;rsquo;s cache, and to probe the filesystem through Apache.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$r&lt;/code&gt; is also queried in this module to see whether there is a &lt;code&gt;MyColumns&lt;/code&gt; setting for this request, with a default in case, it&amp;rsquo;s not. The &lt;code&gt;ListTags&lt;/code&gt; setting tells &lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=3#XML::Filter::TableWrapper&#34;&gt;XML::Filter::TableWrapper&lt;/a&gt; to segment the image list produced by the first two filters into rows of images (preparing it to be an HTML table, in other words).&lt;/p&gt;

&lt;p&gt;The need to pass parameters like this to the SAX filters is the sole reason we&amp;rsquo;re using a SAX machine factory class like this. This class is specified by using &lt;code&gt;PerlSetVar AxSAXMachineClass&lt;/code&gt;; if we didn&amp;rsquo;t need to initialize the filters like this, then we could have listed them in a &lt;code&gt;PerlSetVar AxSAXMachineFilters&lt;/code&gt; directive. For more details on how SAX machines are integrated with AxKit, see &lt;a href=&#34;https://metacpan.org/pod/Apache::AxKit::Language::SAXMachines&#34;&gt;the man page&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Currently, only one SAX machine is allowed in an AxKit pipeline at a time (though different pipelines can have different machines in them). This is a limitation of the configuration system more than anything and may well change if need be. However, if we need to add SAX processors to the end of the machine, then the &lt;code&gt;PerlSetVar AxSAXMachineFilters&lt;/code&gt; can be used to insert site-specific filters after the main machine (and before the XSLT processors).&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;My::Filelist2Data&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&#34;my-filelist2data&#34;&gt;My::Filelist2Data&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html#pipeline.png&#34; id=&#34;pipeline_filelist.png2&#34;&gt;&lt;/a&gt;
&lt;img src=&#34;http://localhost:1313/images/_pub_2002_09_24_axkit/pipeline_filelist2data_pm.png&#34; alt=&#34;My::Filelist2Data&amp;#39;s position in the processing pipeline.&#34; width=&#34;110&#34; height=&#34;84&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Converting the &lt;code&gt;&amp;lt;filelist&amp;gt;&lt;/code&gt; into a proofsheet takes a bit of detailed data munging. This is quite easy in Perl, so the first step in our pipeline is to convert the XML file listing into data. &lt;a href=&#34;https://metacpan.org/pod/XML::Simple&#34;&gt;XML::Simple&lt;/a&gt; provides this functionality for us, and we overload it so we can grab the resulting data structure and pass it on:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package My::Filelist2Data;

    use XML::Simple;
    @ISA = qw( XML::Simple );

    use strict;

    sub new {
        my $proto = shift;
        my %opts = @_;

        # The Handler value is passed in by the Pipeline()
        # call in My::ProofSheetMachine.
        my $h = delete $opts{Handler};

        # Even if there&#39;s only one file element present,
        # make XML::Simple put it in an ARRAY so that
        # the downstream filter can depend on finding an
        # array of elements and not a single element.
        # This is an XML::Simple option that is almost
        # always set in practice.
        $opts{forcearray} = [qw( file )];

        # Each &amp;lt;file&amp;gt; and &amp;lt;directory&amp;gt; element contains
        # the file name as simple text content.  This
        # option tells XML::Simple to store it in the
        # data member &amp;quot;filename&amp;quot;.
        $opts{contentkey} = &amp;quot;filename&amp;quot;;

        # This subroutine gets called when XML::Simple
        # has converted the entire document with the
        # $data from the document.
        $opts{DataHandler} = sub {
            shift;
            my ( $data ) = @_;

            # If no files are found, place an array
            # reference in the right spot.  This is to
            # to simplify downstream filter code.
            $data-&amp;gt;{file}      ||= [];

            # Pass the data structure to the next filter.
            $h-&amp;gt;generate( $data );
        } if $h;

        # Call XML::Simple&#39;s constructor.
        return $proto-&amp;gt;SUPER::new( %opts );;
    }

    1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sending a data structure like this between SAX machines using a non-SAX event is known as &amp;ldquo;cheating.&amp;rdquo; But this is Perl, and allowing you to cheat responsibly and judiciously is one of Perl&amp;rsquo;s great strengths. This works and should work for the foreseeable future. If you&amp;rsquo;re planning on doing something like this for a general purpose filter, then it behooves you to also provide &lt;code&gt;set_handler&lt;/code&gt; and &lt;code&gt;get_handler&lt;/code&gt; methods so your filter can be repositioned after instantiation (something XML::SAX::Machines do if need be), but we don&amp;rsquo;t need to clutter this single-purpose example.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;&amp;lt;filelist&amp;gt;&lt;/code&gt; document gets converted to a Perl data structure where each element is a data member in a HASH or an array, like (data elided and rearranged to relate well to the source XML):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    {
      xmlns =&amp;gt; &#39;http://axkit.org/2002/filelist&#39;,
      directory =&amp;gt; [
        {
          atime      =&amp;gt; &#39;1032276941&#39;
          mtime      =&amp;gt; &#39;1032276939&#39;,
          ctime      =&amp;gt; &#39;1032276939&#39;,
          readable   =&amp;gt; &#39;1&#39;,
          writable   =&amp;gt; &#39;1&#39;,
          executable =&amp;gt; &#39;1&#39;,
          size       =&amp;gt; &#39;4096&#39;,
          content    =&amp;gt; &#39;.&#39;,
        },
        {
          ...
          content    =&amp;gt; &#39;..&#39;,
        },
        {
          ...
          content    =&amp;gt; &#39;Mary&#39;,
        },
        {
          ...
          content    =&amp;gt; &#39;Jim&#39;,
        }
      ]
      file =&amp;gt; [
        {
          mtime      =&amp;gt; &#39;1031160766&#39;,
          ...
          content    =&amp;gt; &#39;a-look.jpeg&#39;,
        },
        {
          mtime      =&amp;gt; &#39;1031160787&#39;,
          ...
          content    =&amp;gt; &#39;a-lotery.jpeg&#39;,
        },
        {
          mtime      =&amp;gt; &#39;1031160771&#39;,
          ...
          content    =&amp;gt; &#39;a-lucky.jpeg&#39;,
        },
        {
          mtime      =&amp;gt; &#39;035239142&#39;,
          ...
          content    =&amp;gt; &#39;foo.html&#39;,
        },
        ...
      ],
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span id=&#34;My::ProofSheet&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&#34;my-proofsheet&#34;&gt;My::ProofSheet&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html#pipeline.png&#34; id=&#34;pipeline_proofsheet_pm.png&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2002_09_24_axkit/pipeline_proofsheet_pm.png&#34; alt=&#34;My::ProofSheet&amp;#39;s position in the processing pipeline.&#34; width=&#34;110&#34; height=&#34;84&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Once the data is in Perl data structure, it&amp;rsquo;s easy to tweak it (making &lt;code&gt;mtime&lt;/code&gt; fields into something readable, for instance) and extend it (adding information about thumbnail images and .meta files, for instance). This is what My::ProofSheet does:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package My::ProofSheet;

    use XML::SAX::Base;
    @ISA = qw( XML::SAX::Base );

    # We need to access the Apache request object to
    # get the URI of the directory we&#39;re presenting,
    # its physical location on disk, and to probe
    # the files in it to see if they are images.
    use Apache;

    # My::Thumbnailer is an Apache/mod_perl module that
    # creates thumbnail images on the fly.  See below.
    use My::Thumbnailer qw( image_size thumb_limits );

    # XML::Generator::PerlData lets us take a Perl data
    # structure and emit it to the next filter serialized
    # as XML.
    use XML::Generator::PerlData;

    use strict;

    sub generate {
        my $self = shift;
        my ( $data ) = @_;

        # Get the AxKit request object so we can
        # ask it for the URI and use it to test
        # whether files are images or not.
        my $r = $self-&amp;gt;{Request};

        my $dirname = $r-&amp;gt;uri;      # &amp;quot;/04/Baby_Pictures/Other/&amp;quot;
        my $dirpath = $r-&amp;gt;filename; # &amp;quot;/home/me/htdocs/...Other/&amp;quot;


        my @images = map $self-&amp;gt;file2image( $_, $dirpath ),
            sort {
                $a-&amp;gt;{filename} cmp $b-&amp;gt;{filename}
            } @{$data-&amp;gt;{file}};

        # Use a handy SAX module to generate XML from our Perl
        # data structures.  The XML will look basically like:
        # Write XML that looks like
        #
        # &amp;lt;proofsheet&amp;gt;
        #   &amp;lt;images&amp;gt;
        #     &amp;lt;image&amp;gt;...&amp;lt;/image&amp;gt;
        #     &amp;lt;image&amp;gt;...&amp;lt;/image&amp;gt;
        #     ...
        #   &amp;lt;/images&amp;gt;
        #   &amp;lt;title&amp;gt;/04/BabyePictures/Others&amp;lt;/title&amp;gt;
        # &amp;lt;/proofsheet&amp;gt;
        #
        XML::Generator::PerlData-&amp;gt;new(
            rootname =&amp;gt; &amp;quot;proofsheet&amp;quot;,
            Handler =&amp;gt; $self,
        )-&amp;gt;parse( {
            title       =&amp;gt; $dirname,
            images      =&amp;gt; { image =&amp;gt; \@images },
        } );
    }


    sub file2image {
        my $self = shift;
        my ( $file, $dirpath ) = @_;

        # Remove the filename from the fields so it won&#39;t
        # show up in the &amp;lt;image&amp;gt; structure.
        my $fn = $file-&amp;gt;{filename};

        # Ignore hidden files (first char is a &amp;quot;.&amp;quot;).
        # Thumbnail images are cached as hidden files.
        return () if 0 == index $fn, &amp;quot;.&amp;quot;;

        # Ignore files Apache knows aren&#39;t images
        my $type = $self-&amp;gt;{Request}-&amp;gt;lookup_file( $fn )-&amp;gt;content_type;
        return () unless
            defined $type
            &amp;amp;&amp;amp; substr( $type, 0, 6 ) eq &amp;quot;image/&amp;quot;;

        # Strip the extension(s) off.
        ( my $name = $fn ) =~ s/\..*//;

        # A meta filename is the image filename with a &amp;quot;.meta&amp;quot;
        # extension instead of whatever extension it has.
        my $meta_fn   = &amp;quot;$name.meta&amp;quot;;
        my $meta_path = &amp;quot;$dirpath/$meta_fn&amp;quot;;

        # The thumbnail file is stored as a hidden file
        # named after the image file, but with a leading
        # &#39;.&#39; to hide it.
        my $thumb_fn   = &amp;quot;.$fn&amp;quot;;
        my $thumb_path = &amp;quot;$dirpath/$thumb_fn&amp;quot;;

        my $last_modified = localtime $file-&amp;gt;{mtime};

        my $image = {
            %$file,                  # Copy all fields
            type           =&amp;gt; $type, # and add a few
            name           =&amp;gt; $name,
            thumb_uri      =&amp;gt; $thumb_fn,
            path           =&amp;gt; &amp;quot;$dirpath/$fn&amp;quot;,
            last_modified  =&amp;gt; $last_modified,
        };

        if ( -e $meta_path ) {
            # Only add a URI to the meta info, metamerger.xsl will
            # slurp it up if and only if &amp;lt;meta_uri&amp;gt; is present.
            $image-&amp;gt;{meta_filename} = $meta_fn;
            $image-&amp;gt;{meta_uri}      = &amp;quot;file://$meta_path&amp;quot;;
        }

        # If the thumbnail exists, grab its width and height
        # so later stages can populate the &amp;lt;img&amp;gt; tag with them.
        # The eval {} is in case the image doesn&#39;t exist or
        # the library can&#39;t cope with the image format.
        # Disable caching AxKit&#39;s output if a failure occurs.
        eval {
            ( $image-&amp;gt;{thumb_width}, $image-&amp;gt;{thumb_height} )
                = image_size $thumb_path;
        } or $self-&amp;gt;{Request}-&amp;gt;no_cache( 1 );

        return $image;
    }


    1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When My::Filelist2Data calls &lt;code&gt;generate()&lt;/code&gt;, &lt;code&gt;generate()&lt;/code&gt; sorts and scans the list of files by filename, converts each to an image and sends a page title and the resulting list of images to the next filter (&lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=3#XML::Filter::TableWrapper&#34;&gt;XML::Filter::TableWrapper&lt;/a&gt;). Kip Hampton&amp;rsquo;s &lt;a href=&#34;https://metacpan.org/pod/XML::Generator::PerlData&#34;&gt;XML::Generator::PerlData&lt;/a&gt; is a Perl data -&amp;gt; XML serialization module. It&amp;rsquo;s not meant for generating generic XML; it focuses purely on building an XML representation of a Perl data structure. In this case, that&amp;rsquo;s ideal, because we will be generating the output document with XSLT templates and we don&amp;rsquo;t care about the exact order of the elements in each &lt;code&gt;&amp;lt;image&amp;gt;&lt;/code&gt; element, each &lt;code&gt;&amp;lt;image&amp;gt;&lt;/code&gt; element is just a hash of key/value pairs. We do control the order of the &lt;code&gt;&amp;lt;image&amp;gt;&lt;/code&gt; elements, however, by passing an ordered list of them in to XML::Generator::PerlData as an array.&lt;/p&gt;

&lt;p&gt;Sorting by filename may not be the preferred thing to do for all applications, because users may prefer to sort by the caption title for the image, but then again they may not, and this allows the site administrator to control sort order by naming the files appropriately. We can add always add sorting later.&lt;/p&gt;

&lt;p&gt;Another peculiarity of this code is that it doesn&amp;rsquo;t guarantee that there will be &lt;code&gt;thumb_width&lt;/code&gt; and &lt;code&gt;thumb_height&lt;/code&gt; values available. If you just drop the source images in a directory, then the first time the server generates this page, there will be no thumbnails available. In this case, the call to &lt;code&gt;no_cache(1)&lt;/code&gt; prevents AxKit from caching the output page so that suboptimal HTML does not get stuck in the cache. This will give the server another chance at generating it with proper tags, hoping of course that by the next time this page is requested, the requisite thumbnails will be available to measure.&lt;/p&gt;

&lt;p&gt;This approach gets the HTML to the browser fast, so the user&amp;rsquo;s browser window will clear quickly and start filling with the top of ths page, so the user will see some activity and be less likely to get impatient. The thumbnails will be generated when the browser sees all the &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; tags. The alternative approach would be to thumbnail the images inline, which would result in a significant delay on large listings before the first HTML hits the browser, or prethumbnailing.&lt;/p&gt;

&lt;p&gt;One thing to note about this approach is that many browsers will request images several at a time, which will cause several server processes to be thumbnailing several different images at once. This should result in lower lag on low-load servers because processes can interleave CPU time and disk I/O waits, and can take advantage of multiple processors, if present. On heavily loaded servers, of course, this might be a bad thing; pregenerating thumbnails there would be a good idea.&lt;/p&gt;

&lt;p&gt;The output from this filter looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;
    &amp;lt;proofsheet&amp;gt;
      &amp;lt;images&amp;gt;
        &amp;lt;image&amp;gt;
          &amp;lt;path&amp;gt;
            /home/barries/src/mball/AxKit/www/htdocs/04/Baby_Pictures/Others/a-look.jpeg
          &amp;lt;/path&amp;gt;
          &amp;lt;writable&amp;gt;1&amp;lt;/writable&amp;gt;
          &amp;lt;filename&amp;gt;a-look.jpeg&amp;lt;/filename&amp;gt;
          &amp;lt;thumb_uri&amp;gt;.a-look.jpeg&amp;lt;/thumb_uri&amp;gt;
          &amp;lt;meta_filename&amp;gt;a-look.meta&amp;lt;/meta_filename&amp;gt;
          &amp;lt;name&amp;gt;a-look&amp;lt;/name&amp;gt;
          &amp;lt;last_modified&amp;gt;Wed Sep  4 13:32:46 2002&amp;lt;/last_modified&amp;gt;
          &amp;lt;ctime&amp;gt;1032552249&amp;lt;/ctime&amp;gt;
          &amp;lt;meta_uri&amp;gt;
            file:///home/barries/src/mball/AxKit/www/htdocs/04/Baby_Pictures/Others/a-look.meta
          &amp;lt;/meta_uri&amp;gt;
          &amp;lt;mtime&amp;gt;1031160766&amp;lt;/mtime&amp;gt;
          &amp;lt;size&amp;gt;8522&amp;lt;/size&amp;gt;
          &amp;lt;readable&amp;gt;1&amp;lt;/readable&amp;gt;
          &amp;lt;type&amp;gt;image/jpeg&amp;lt;/type&amp;gt;
          &amp;lt;atime&amp;gt;1032553327&amp;lt;/atime&amp;gt;
        &amp;lt;/image&amp;gt;
        &amp;lt;image&amp;gt;
          &amp;lt;path&amp;gt;
            /home/barries/src/mball/AxKit/www/htdocs/04/Baby_Pictures/Others/a-lotery.jpeg
          &amp;lt;/path&amp;gt;
          &amp;lt;writable&amp;gt;1&amp;lt;/writable&amp;gt;
          &amp;lt;filename&amp;gt;a-lotery.jpeg&amp;lt;/filename&amp;gt;
          &amp;lt;thumb_uri&amp;gt;.a-lotery.jpeg&amp;lt;/thumb_uri&amp;gt;
          &amp;lt;name&amp;gt;a-lotery&amp;lt;/name&amp;gt;
          &amp;lt;last_modified&amp;gt;Wed Sep  4 13:33:07 2002&amp;lt;/last_modified&amp;gt;
          &amp;lt;ctime&amp;gt;1032552249&amp;lt;/ctime&amp;gt;
          &amp;lt;mtime&amp;gt;1031160787&amp;lt;/mtime&amp;gt;
          &amp;lt;size&amp;gt;10113&amp;lt;/size&amp;gt;
          &amp;lt;readable&amp;gt;1&amp;lt;/readable&amp;gt;
          &amp;lt;type&amp;gt;image/jpeg&amp;lt;/type&amp;gt;
          &amp;lt;atime&amp;gt;1032553327&amp;lt;/atime&amp;gt;
        &amp;lt;/image&amp;gt;
      &amp;lt;/images&amp;gt;
      ...
      &amp;lt;title&amp;gt;/04/Baby_Pictures/Others&amp;lt;/title&amp;gt;
    &amp;lt;/proofsheet&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All the data from the original &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; elements are in each &lt;code&gt;&amp;lt;image&amp;gt;&lt;/code&gt; element along with the new fields. Note that the first &lt;code&gt;&amp;lt;image&amp;gt;&lt;/code&gt; contains the &lt;code&gt;&amp;lt;meta_uri&amp;gt;&lt;/code&gt; (pointing to &lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html#TheMetaFile&#34;&gt;a-look.meta&lt;/a&gt;) while the second doesn&amp;rsquo;t because there is no &lt;code&gt;a-lotery.meta&lt;/code&gt;. As expected both have the &lt;code&gt;&amp;lt;thumb_uri&amp;gt;&lt;/code&gt; tags. The parts in &lt;strong&gt;bold&lt;/strong&gt; face are the bits that our presentation happens to want; yours might want more or different bits.&lt;/p&gt;

&lt;p&gt;While there is a lot of extra information in this structure, it&amp;rsquo;s really just the output from one system call (&lt;code&gt;stat()&lt;/code&gt;) and some possibly useful byproducts of the My::ProofSheet machinations, so it&amp;rsquo;s very cheap information that some front end somewhere might want. It&amp;rsquo;s also easier to leave it all in than to emit just what our example frontend might want and will enable any future upstream filters or extentions to AxKit&amp;rsquo;s directory scanning to shine through.&lt;/p&gt;

&lt;p&gt;No &lt;code&gt;&amp;lt;thumb_width&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;thumb_height&amp;gt;&lt;/code&gt; tags are present because I copied this file from the axtrace directory (see the &lt;code&gt;AxTraceIntermediate&lt;/code&gt; directive in &lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=2#httpd.conf&#34;&gt;our httpd.conf file&lt;/a&gt;) after viewing a newly added directory. Here&amp;rsquo;s what the first &lt;code&gt;&amp;lt;image&amp;gt;&lt;/code&gt; element looks like when viewing after my browser had requested all thumbnails:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;
    &amp;lt;proofsheet&amp;gt;
      &amp;lt;images&amp;gt;
        &amp;lt;image&amp;gt;
          &amp;lt;thumb_width&amp;gt;72&amp;lt;/thumb_width&amp;gt;
          &amp;lt;path&amp;gt;
            /home/barries/src/mball/AxKit/www/htdocs/04/Baby_Pictures/Others/a-look.jpeg
          &amp;lt;/path&amp;gt;
          &amp;lt;writable&amp;gt;1&amp;lt;/writable&amp;gt;
          &amp;lt;filename&amp;gt;a-look.jpeg&amp;lt;/filename&amp;gt;
          &amp;lt;thumb_height&amp;gt;100&amp;lt;/thumb_height&amp;gt;
          &amp;lt;thumb_uri&amp;gt;.a-look.jpeg&amp;lt;/thumb_uri&amp;gt;
          &amp;lt;meta_filename&amp;gt;a-look.meta&amp;lt;/meta_filename&amp;gt;
          &amp;lt;name&amp;gt;a-look&amp;lt;/name&amp;gt;
          &amp;lt;last_modified&amp;gt;Wed Sep  4 13:32:46 2002&amp;lt;/last_modified&amp;gt;
          &amp;lt;ctime&amp;gt;1032552249&amp;lt;/ctime&amp;gt;
          &amp;lt;meta_uri&amp;gt;
            file:///home/barries/src/mball/AxKit/www/htdocs/04/Baby_Pictures/Others/a-look.meta
          &amp;lt;/meta_uri&amp;gt;
          &amp;lt;mtime&amp;gt;1031160766&amp;lt;/mtime&amp;gt;
          &amp;lt;size&amp;gt;8522&amp;lt;/size&amp;gt;
          &amp;lt;readable&amp;gt;1&amp;lt;/readable&amp;gt;
          &amp;lt;type&amp;gt;image/jpeg&amp;lt;/type&amp;gt;
          &amp;lt;atime&amp;gt;1032784360&amp;lt;/atime&amp;gt;
        &amp;lt;/image&amp;gt;
        ...
      &amp;lt;/images&amp;gt;
      &amp;lt;title&amp;gt;/04/Baby_Pictures/Others&amp;lt;/title&amp;gt;
    &amp;lt;/proofsheet&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span id=&#34;XML::Filter::TableWrapper&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&#34;xml-filter-tablewrapper&#34;&gt;XML::Filter::TableWrapper&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html#pipeline.png&#34; id=&#34;pipeline_tablewrapper_pm.png&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2002_09_24_axkit/pipeline_tablewrapper_pm.png&#34; alt=&#34;My::TableWrapper&amp;#39;s position in the processing pipeline&#34; width=&#34;110&#34; height=&#34;84&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://metacpan.org/pod/XML::Filter::TableWrapper&#34;&gt;XML::Filter::TableWrapper&lt;/a&gt; is a CPAN module is used to take the &lt;code&gt;&amp;lt;images&amp;gt;&lt;/code&gt; list and segmenting it by insert &lt;code&gt;&amp;lt;tr&amp;gt;...&amp;lt;/tr&amp;gt;&lt;/code&gt; tags around every (it&amp;rsquo;s configurable) &lt;code&gt;&amp;lt;image&amp;gt;&lt;/code&gt; elements. This configuration is done by the &lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=2#My::ProofSheetMachine&#34;&gt;My::ProofSheetMachine&lt;/a&gt; module we showed earlier:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    XML::Filter::TableWrapper-&amp;gt;new(
        ListTags =&amp;gt; &amp;quot;{}images&amp;quot;,
        Columns  =&amp;gt; $r-&amp;gt;dir_config( &amp;quot;MyColumns&amp;quot; ) || 3,
    ),
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output, for our list of 9 images, looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;
    &amp;lt;proofsheet&amp;gt;
      &amp;lt;images&amp;gt;
        &amp;lt;tr&amp;gt;
          &amp;lt;image&amp;gt;
            ...
          &amp;lt;/image&amp;gt;
          ... 4 more image elements...
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr&amp;gt;
          &amp;lt;image&amp;gt;
            ...
          &amp;lt;/image&amp;gt;
          ... 3 more image elements...
        &amp;lt;/tr&amp;gt;
      &amp;lt;/images&amp;gt;
      &amp;lt;title&amp;gt;/04/Baby_Pictures/Others&amp;lt;/title&amp;gt;
    &amp;lt;/proofsheet&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now all the presentation stylesheet (&lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=4#pagestyler.xsl&#34;&gt;pagestuler.xsl&lt;/a&gt;) can key off the &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; tags to build an HTML &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; or ignore them (and not pass them through) if it wants to display in a list format.&lt;/p&gt;

&lt;p&gt;While I&amp;rsquo;m sure this is possible in XSLT, I have no idea how to do it easily.&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;rowsplitter.xsl&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&#34;rowsplitter-xsl&#34;&gt;rowsplitter.xsl&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html#pipeline.png&#34; id=&#34;pipeline_rowsplitter_xsl.png&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2002_09_24_axkit/pipeline_rowsplitter_xsl.png&#34; alt=&#34;rowsplitter.xsl&amp;#39;s position in the processing pipeline.&#34; width=&#34;110&#34; height=&#34;84&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Experimentation with an early version of this application showed that presenting captions in the same table cell as the thumbnails when the thumbnails are of differing heights caused the captions to be showed at varying heights. This made it hard to scan the captions and added a lot of visual clutter to the page.&lt;/p&gt;

&lt;p&gt;One solution is to add an XSLT filter that splits each table row of image data in to two rows, one for the thumbnail and another for the caption:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;xsl:stylesheet
      version=&amp;quot;1.0&amp;quot;
      xmlns:xsl=&amp;quot;http://www.w3.org/1999/XSL/Transform&amp;quot;
    &amp;gt;

    &amp;lt;xsl:template match=&amp;quot;image&amp;quot; mode=&amp;quot;caption&amp;quot;&amp;gt;
      &amp;lt;caption&amp;gt;
        &amp;lt;xsl:copy-of select=&amp;quot;@*|*|node()&amp;quot; /&amp;gt;
      &amp;lt;/caption&amp;gt;
    &amp;lt;/xsl:template&amp;gt;

    &amp;lt;xsl:template match=&amp;quot;images/tr&amp;quot;&amp;gt;
      &amp;lt;xsl:copy-of select=&amp;quot;.&amp;quot; /&amp;gt;
      &amp;lt;tr&amp;gt;&amp;lt;xsl:apply-templates select=&amp;quot;image&amp;quot; mode=&amp;quot;caption&amp;quot; /&amp;gt;&amp;lt;/tr&amp;gt;
    &amp;lt;/xsl:template&amp;gt;

    &amp;lt;xsl:template match=&amp;quot;@*|node()&amp;quot;&amp;gt;
      &amp;lt;xsl:copy&amp;gt;
        &amp;lt;xsl:apply-templates select=&amp;quot;@*|node()&amp;quot;/&amp;gt;
      &amp;lt;/xsl:copy&amp;gt;
    &amp;lt;/xsl:template&amp;gt;

    &amp;lt;/xsl:stylesheet&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second template in this stylesheet matches each row (&lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; element) in the &lt;code&gt;&amp;lt;images&amp;gt;&lt;/code&gt; element and copies it verbatim and then emits a second &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; element right after it with a list of &lt;code&gt;&amp;lt;caption&amp;gt;&lt;/code&gt; elements with copies of the content of each of the &lt;code&gt;&amp;lt;image&amp;gt;&lt;/code&gt; tags in the original row. The first template is applied only to the &lt;code&gt;&amp;lt;image&amp;gt;&lt;/code&gt; tags when creating this second row due to the &lt;code&gt;mode=&amp;quot;caption&amp;quot;&lt;/code&gt; attributes.&lt;/p&gt;

&lt;p&gt;The third template is a standard piece of XSLT boilerplate that passes through all the XML that is not matched by the first two templates. This XML would otherwise be mangled (stripped of elements, to be specific) by the wacky default XSLT rules.&lt;/p&gt;

&lt;p&gt;Now, I know several ways to do this in Perl in the AxKit environment and none are so easy for me as using XSLT. &lt;a href=&#34;https://dictionary.cambridge.org/us/dictionary/english/ymmv&#34;&gt;YMMV&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The output from that stage looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;
    &amp;lt;proofsheet&amp;gt;
      &amp;lt;images&amp;gt;

        &amp;lt;tr&amp;gt;&amp;lt;image&amp;gt;...  &amp;lt;/image&amp;gt;   ...total of 5... &amp;lt;/tr&amp;gt;
        &amp;lt;tr&amp;gt;&amp;lt;caption&amp;gt;...&amp;lt;/caption&amp;gt; ...total of 5... &amp;lt;/tr&amp;gt;

        &amp;lt;tr&amp;gt;&amp;lt;image&amp;gt;...  &amp;lt;/image&amp;gt;   ...total of 4... &amp;lt;/tr&amp;gt;
        &amp;lt;tr&amp;gt;&amp;lt;caption&amp;gt;...&amp;lt;/caption&amp;gt; ...total of 4... &amp;lt;/tr&amp;gt;

      &amp;lt;/images&amp;gt;
      &amp;lt;title&amp;gt;/04/Baby_Pictures/Others&amp;lt;/title&amp;gt;
    &amp;lt;/proofsheet&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The content of each &lt;code&gt;&amp;lt;image&amp;gt;&lt;/code&gt; tag and each &lt;code&gt;&amp;lt;caption&amp;gt;&lt;/code&gt; tag is identical. It&amp;rsquo;s easier to do the transform this way and allows the frontend stylesheets the flexibility of doing things like putting the image filename or modification time in the same cell as the thumbnail.&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;metamerger.xsl&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&#34;metamerger-xsl&#34;&gt;metamerger.xsl&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html#pipeline.png&#34; id=&#34;pipeline_metamerger_xsl.png&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2002_09_24_axkit/pipeline_metamerger_xsl.png&#34; alt=&#34;metamerger.xsl&amp;#39;s position in the processing pipeline&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;As with the row splitter, expressing the metamerger in XSLT is an expedient way of merging in external XML documents, for several reasons. The first is for efficiency&amp;rsquo;s sake: We&amp;rsquo;re already using XSLT before and after this filter, and AxKit optimizes XSLT-&amp;gt;XSLT handoffs to avoid reparsing. Another is that the underlying implementation of AxKit&amp;rsquo;s XSLT engine is the speedy C of libxslt. A third is that we&amp;rsquo;re not altering the incoming file at all in this stage, so the XSLT does not get out of hand (I do not consider XSLT to be a very readable programming language; its XML syntax makes for very opaque source code).&lt;/p&gt;

&lt;p&gt;Another approach would be to go back and tweak &lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=3#My::ProofSheet&#34;&gt;My::ProofSheet&lt;/a&gt; to inherit from &lt;a href=&#34;https://metacpan.org/pod/XML::SAX::Machines&#34;&gt;XML::Filter::Merger&lt;/a&gt; and insert it using a SAX parser. That would be a bit slower, I suspect, because SAX parsing in general tends to be slower than XSLT&amp;rsquo;s internal parsing. It would rob the application of the configurability that having merging as a separate step engenders. By factoring this functionality in to the metamerger.xsl stylesheet, we offer the site designer the ability to pull data from other sources, or even to fly without any metadata at all.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s what metamerger.xsl looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;xsl:stylesheet
      version=&amp;quot;1.0&amp;quot;
      xmlns:xsl=&amp;quot;http://www.w3.org/1999/XSL/Transform&amp;quot;
    &amp;gt;

    &amp;lt;xsl:template match=&amp;quot;caption&amp;quot;&amp;gt;
      &amp;lt;caption&amp;gt;
        &amp;lt;xsl:copy-of select=&amp;quot;*|@*|node()&amp;quot; /&amp;gt;
        &amp;lt;xsl:copy-of select=&amp;quot;document( meta_uri )&amp;quot; /&amp;gt;
      &amp;lt;/caption&amp;gt;
    &amp;lt;/xsl:template&amp;gt;

    &amp;lt;xsl:template match=&amp;quot;*|@*&amp;quot;&amp;gt;
      &amp;lt;xsl:copy&amp;gt;
        &amp;lt;xsl:apply-templates select=&amp;quot;*|@*|node()&amp;quot; /&amp;gt;
      &amp;lt;/xsl:copy&amp;gt;
    &amp;lt;/xsl:template&amp;gt;

    &amp;lt;/xsl:stylesheet&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first template does all the work of matching each &lt;code&gt;&amp;lt;caption&amp;gt;&lt;/code&gt; element and copying its content, then parsing and inserting the document indicated by the &lt;code&gt;&amp;lt;meta_uri&amp;gt;&lt;/code&gt; element, if present. The &lt;code&gt;document()&lt;/code&gt; function turns into a noop if &lt;code&gt;&amp;lt;meta_uri&amp;gt;&lt;/code&gt; is not present. The second template is that same piece of boilerplate we saw in &lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=3#rowsplitter.xsl&#34;&gt;rowsplitter.xsl&lt;/a&gt; to copy through everything we don&amp;rsquo;t explicitly match.&lt;/p&gt;

&lt;p&gt;And here&amp;rsquo;s what the &lt;code&gt;&amp;lt;caption&amp;gt;&lt;/code&gt; for &lt;code&gt;a-look.jpeg&lt;/code&gt; now looks like (all the other &lt;code&gt;&amp;lt;caption&amp;gt;&lt;/code&gt; elements were left untouched because there are no other .meta files in this directory):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;caption&amp;gt;
      &amp;lt;thumb_width&amp;gt;72&amp;lt;/thumb_width&amp;gt;
      &amp;lt;path&amp;gt;/home/barries/src/mball/AxKit/www/htdocs/04/Baby_Pictures/Others/a-look.jpeg&amp;lt;/path&amp;gt;
      &amp;lt;writable&amp;gt;1&amp;lt;/writable&amp;gt;
      &amp;lt;filename&amp;gt;a-look.jpeg&amp;lt;/filename&amp;gt;
      &amp;lt;thumb_height&amp;gt;100&amp;lt;/thumb_height&amp;gt;
      &amp;lt;thumb_uri&amp;gt;.a-look.jpeg&amp;lt;/thumb_uri&amp;gt;
      &amp;lt;meta_filename&amp;gt;a-look.meta&amp;lt;/meta_filename&amp;gt;
      &amp;lt;name&amp;gt;a-look&amp;lt;/name&amp;gt;
      &amp;lt;last_modified&amp;gt;Wed Sep  4 13:32:46 2002&amp;lt;/last_modified&amp;gt;
      &amp;lt;ctime&amp;gt;1032552249&amp;lt;/ctime&amp;gt;
      &amp;lt;meta_uri&amp;gt;file:///home/barries/src/mball/AxKit/www/htdocs/04/Baby_Pictures/Others/a-look.meta&amp;lt;/meta_uri&amp;gt;
      &amp;lt;mtime&amp;gt;1031160766&amp;lt;/mtime&amp;gt;
      &amp;lt;size&amp;gt;8522&amp;lt;/size&amp;gt;
      &amp;lt;readable&amp;gt;1&amp;lt;/readable&amp;gt;
      &amp;lt;type&amp;gt;image/jpeg&amp;lt;/type&amp;gt;
      &amp;lt;atime&amp;gt;1032784360&amp;lt;/atime&amp;gt;
      &amp;lt;meta&amp;gt;
        &amp;lt;title&amp;gt;A baby picture&amp;lt;/title&amp;gt;
        &amp;lt;comment&amp;gt;&amp;lt;b&amp;gt;ME!&amp;lt;/b&amp;gt;.  Well, not really.  Actually, it&#39;s some random image from the &#39;net.
&amp;lt;/comment&amp;gt;
      &amp;lt;/meta&amp;gt;
    &amp;lt;/caption&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As mentioned before, this stylesheet does not care what you put in the meta file, it just inserts anything in that file from the root element on down. So you are free to put any meta information your application requires in the meta file and adjust the presentation filters to style it as you will.&lt;/p&gt;

&lt;p&gt;The .meta information is not inserted in to the &lt;code&gt;&amp;lt;image&amp;gt;&lt;/code&gt; tags because we know that none of our presentation will not need any of it there.&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;captionstyler.xsl&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&#34;captionstyler-xsl&#34;&gt;captionstyler.xsl&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html#pipeline.png&#34; id=&#34;pipeline_captionstyler_xsl.png&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2002_09_24_axkit/pipeline_captionstyler_xsl.png&#34; alt=&#34;captionstyler.xsl&amp;#39;s position in the processing pipeline&#34; width=&#34;110&#34; height=&#34;84&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The last two stages of our pipeline turn the data assembled so far into HTML. This is done in two stages in order to separate general layout and presentation from the presentation of the caption because the these portions of the presentation might need to vary independently between one collection of images and another.&lt;/p&gt;

&lt;p&gt;The caption stylesheet for this example is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;xsl:stylesheet
      version=&amp;quot;1.0&amp;quot;
      xmlns:xsl=&amp;quot;http://www.w3.org/1999/XSL/Transform&amp;quot;
    &amp;gt;

    &amp;lt;xsl:template match=&amp;quot;caption&amp;quot;&amp;gt;
      &amp;lt;caption width=&amp;quot;100&amp;quot; align=&amp;quot;left&amp;quot; valign=&amp;quot;top&amp;quot;&amp;gt;

        &amp;lt;a href=&amp;quot;{filename}&amp;quot;&amp;gt;
          &amp;lt;xsl:choose&amp;gt;
            &amp;lt;xsl:when test=&amp;quot;meta/title and string-length( meta/title )&amp;quot;&amp;gt;
              &amp;lt;xsl:copy-of select=&amp;quot;meta/title/node()&amp;quot; /&amp;gt;
            &amp;lt;/xsl:when&amp;gt;
            &amp;lt;xsl:otherwise&amp;gt;
              &amp;lt;xsl:value-of select=&amp;quot;name&amp;quot; /&amp;gt;
            &amp;lt;/xsl:otherwise&amp;gt;
          &amp;lt;/xsl:choose&amp;gt;
        &amp;lt;/a&amp;gt;&amp;lt;br /&amp;gt;

        &amp;lt;font size=&amp;quot;-1&amp;quot; color=&amp;quot;#808080&amp;quot;&amp;gt;
          &amp;lt;xsl:copy-of select=&amp;quot;last_modified/node()&amp;quot; /&amp;gt;
          &amp;lt;br /&amp;gt;
        &amp;lt;/font&amp;gt;

        &amp;lt;xsl:copy-of select=&amp;quot;meta/comment/node()&amp;quot; /&amp;gt;

      &amp;lt;/caption&amp;gt;
    &amp;lt;/xsl:template&amp;gt;

    &amp;lt;xsl:template match=&amp;quot;*|@*|node()&amp;quot;&amp;gt;
      &amp;lt;xsl:copy&amp;gt;
        &amp;lt;xsl:apply-templates /&amp;gt;
      &amp;lt;/xsl:copy&amp;gt;
    &amp;lt;/xsl:template&amp;gt;

    &amp;lt;/xsl:stylesheet&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first template replaces all &lt;code&gt;&amp;lt;caption&amp;gt;&lt;/code&gt; elements with new &lt;code&gt;&amp;lt;caption&amp;gt;&lt;/code&gt; cells with a default width and alignment, and then fills these with the name of the image, which is also a link to the underling image file, and the &lt;code&gt;&amp;lt;last_modified&lt;/code&gt; time string formatted by &lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=3#My::ProofSheet&#34;&gt;My::ProofSheet&lt;/a&gt; and any &lt;code&gt;&amp;lt;comment&amp;gt;&lt;/code&gt; that might be present in the meta file.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;&amp;lt;xsl:choose&amp;gt;&lt;/code&gt; element is what selects the title to display for the image. The first &lt;code&gt;&amp;lt;xsl:when&amp;gt;&lt;/code&gt;looks to see if there is a &lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; element in the meta file and uses it if present. The &lt;code&gt;&amp;lt;xsl:otherwise&amp;gt;&lt;/code&gt; defaults the name to the &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; set by My::ProofSheet.&lt;/p&gt;

&lt;p&gt;The captions output by this stage look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;caption width=&amp;quot;100&amp;quot; align=&amp;quot;left&amp;quot; valign=&amp;quot;top&amp;quot;&amp;gt;
      &amp;lt;a href=&amp;quot;a-look.jpeg&amp;quot;&amp;gt;A baby picture&amp;lt;/a&amp;gt;
      &amp;lt;br/&amp;gt;
      &amp;lt;font size=&amp;quot;-1&amp;quot; color=&amp;quot;#808080&amp;quot;&amp;gt;Wed Sep
        4 13:32:46 2002&amp;lt;br/&amp;gt;
      &amp;lt;/font&amp;gt;
      &amp;lt;b&amp;gt;ME!&amp;lt;/b&amp;gt;.  Well, not really.  Actually, it&#39;s
        some random image from the &#39;net.
    &amp;lt;/caption&amp;gt;
    &amp;lt;caption width=&amp;quot;100&amp;quot; align=&amp;quot;left&amp;quot; valign=&amp;quot;top&amp;quot;&amp;gt;
      &amp;lt;a href=&amp;quot;a-lotery.jpeg&amp;quot;&amp;gt;a-lotery&amp;lt;/a&amp;gt;
      &amp;lt;br/&amp;gt;
      &amp;lt;font size=&amp;quot;-1&amp;quot; color=&amp;quot;#808080&amp;quot;&amp;gt;Wed Sep
        4 13:33:07 2002&amp;lt;br/&amp;gt;&amp;lt;/font&amp;gt;
    &amp;lt;/caption&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The former is what comes out when a .meta file is found, the latter when it is not.&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;pagestyler.xsl&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&#34;pagestyler-xsl&#34;&gt;pagestyler.xsl&lt;/h4&gt;

&lt;p&gt;And now, the final stage. If you&amp;rsquo;ve made it this far, congratulations; this is the start of a real application and not just a toy, so it&amp;rsquo;s taken quite some time to get here.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html#pipeline.png&#34; id=&#34;pipeline_pagestyler_xsl.png&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2002_09_24_axkit/pipeline_pagestyler_xsl.png&#34; alt=&#34;pagestyler.xsl&amp;#39;s position in the processing pipeline&#34; width=&#34;110&#34; height=&#34;84&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The final stage of the processing pipeline generates an HTML page from the raw data, except for the attributes and content of &lt;code&gt;&amp;lt;caption&amp;gt;&lt;/code&gt; tags, which it passes through as-is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;xsl:stylesheet
      version=&amp;quot;1.0&amp;quot;
      xmlns:xsl=&amp;quot;http://www.w3.org/1999/XSL/Transform&amp;quot;
    &amp;gt;

    &amp;lt;xsl:template match=&amp;quot;/*&amp;quot;&amp;gt;
      &amp;lt;html&amp;gt;
        &amp;lt;head&amp;gt;
          &amp;lt;title&amp;gt;Images in &amp;lt;xsl:value-of select=&amp;quot;title&amp;quot; /&amp;gt;&amp;lt;/title&amp;gt;
        &amp;lt;/head&amp;gt;
        &amp;lt;body bgcolor=&amp;quot;#ffffff&amp;quot;&amp;gt;
          &amp;lt;xsl:apply-templates select=&amp;quot;images&amp;quot; /&amp;gt;
        &amp;lt;/body&amp;gt;
      &amp;lt;/html&amp;gt;
    &amp;lt;/xsl:template&amp;gt;


    &amp;lt;xsl:template match=&amp;quot;images&amp;quot;&amp;gt;
      &amp;lt;table&amp;gt;
        &amp;lt;xsl:apply-templates /&amp;gt;
      &amp;lt;/table&amp;gt;
    &amp;lt;/xsl:template&amp;gt;

    &amp;lt;xsl:template match=&amp;quot;tr&amp;quot;&amp;gt;
      &amp;lt;xsl:copy&amp;gt;
        &amp;lt;xsl:apply-templates select=&amp;quot;*&amp;quot; /&amp;gt;
      &amp;lt;/xsl:copy&amp;gt;
    &amp;lt;/xsl:template&amp;gt;

    &amp;lt;xsl:template match=&amp;quot;image&amp;quot;&amp;gt;
      &amp;lt;td align=&amp;quot;left&amp;quot; valign=&amp;quot;top&amp;quot;&amp;gt;
        &amp;lt;a href=&amp;quot;{filename}&amp;quot;&amp;gt;
          &amp;lt;img border=&amp;quot;0&amp;quot; src=&amp;quot;{thumb_uri}&amp;quot;&amp;gt;
            &amp;lt;xsl:if test=&amp;quot;thumb_width&amp;quot;&amp;gt;
              &amp;lt;xsl:attribute name=&amp;quot;width&amp;quot;&amp;gt;
                &amp;lt;xsl:value-of select=&amp;quot;thumb_width&amp;quot; /&amp;gt;
              &amp;lt;/xsl:attribute&amp;gt;
            &amp;lt;/xsl:if&amp;gt;
            &amp;lt;xsl:if test=&amp;quot;thumb_height&amp;quot;&amp;gt;
              &amp;lt;xsl:attribute name=&amp;quot;height&amp;quot;&amp;gt;
                &amp;lt;xsl:value-of select=&amp;quot;thumb_height&amp;quot; /&amp;gt;
              &amp;lt;/xsl:attribute&amp;gt;
            &amp;lt;/xsl:if&amp;gt;
          &amp;lt;/img&amp;gt;
        &amp;lt;/a&amp;gt;
      &amp;lt;/td&amp;gt;
    &amp;lt;/xsl:template&amp;gt;

    &amp;lt;xsl:template match=&amp;quot;@*|node()&amp;quot; mode=&amp;quot;caption&amp;quot;&amp;gt;
      &amp;lt;xsl:copy&amp;gt;
        &amp;lt;xsl:apply-templates select=&amp;quot;@*|node()&amp;quot; mode=&amp;quot;caption&amp;quot; /&amp;gt;
      &amp;lt;/xsl:copy&amp;gt;
    &amp;lt;/xsl:template&amp;gt;

    &amp;lt;xsl:template match=&amp;quot;caption&amp;quot;&amp;gt;
      &amp;lt;td&amp;gt;
        &amp;lt;xsl:apply-templates select=&amp;quot;@*|node()&amp;quot; mode=&amp;quot;caption&amp;quot; /&amp;gt;
      &amp;lt;/td&amp;gt;
    &amp;lt;/xsl:template&amp;gt;

    &amp;lt;/xsl:stylesheet&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first template generates the skeleton of the HTML page, the second one grabs the &lt;code&gt;&amp;lt;images&amp;gt;&lt;/code&gt; list from the source document, emits a &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;, the third copies the &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; tags, the fourth replaces all &lt;code&gt;&amp;lt;image&amp;gt;&lt;/code&gt; tags with &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt; tags containing the thumbnail image as a link to the underlying image (similar to what &lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=4#captionstyler.xsl&#34;&gt;captionstyler.xsl&lt;/a&gt; did with the picture name). The only subtlety here is that the optional &lt;code&gt;&amp;lt;thumb_width&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;thumb_height&amp;gt;&lt;/code&gt; elements are used, if present, to inform the browser of the size of the thumbnail in order to speed up the layout process (as mentioned before, pages that don&amp;rsquo;t contain this information are not cached so that when the thumbnails are generated, new HTML will be generated with it).&lt;/p&gt;

&lt;p&gt;The fourth template converts the &lt;code&gt;&amp;lt;caption&amp;gt;&lt;/code&gt; elements to &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt; elements and copies all their content through, since &lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=4#captionstyler.xsl&#34;&gt;captionstyler.xsl&lt;/a&gt; already did the presentation for them.&lt;/p&gt;

&lt;p&gt;Tweaking this stylesheet or replacing it controls the entire page layout other than thumbnail sizing (which is set by the optional &lt;code&gt;MyMaxX&lt;/code&gt; and &lt;code&gt;MyMaxY&lt;/code&gt; &lt;code&gt;PerlSetVar&lt;/code&gt; settings in &lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=2#httpd.conf&#34;&gt;httpd.conf&lt;/a&gt;). A different stylesheet in this point in the chain could choose to ignore the &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; tags and present a list style output. A later stylesheet could be added to add branding or advertising to the site, etc., etc.&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;My::Thumbnailer&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&#34;my-thumbnailer&#34;&gt;My::ThumbNailer&lt;/h4&gt;

&lt;p&gt;Here&amp;rsquo;s the apache module that generates thumbnails. The key thing to remember is that, unlike all the other code and XML shown in this article, this is called once per thumbnail image, not once per directory. When a browser requests a directory listing, it gets HTML from the pipeline above with lots of URIs for thumbnail images. It will then usually request each of those in turn. The &lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=2#httpd.conf&#34;&gt;httpd.conf&lt;/a&gt; file directs all requests for dotfiles to this module:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package My::Thumbnailer;

    # Allow other modules like My::ProofSheet to use some
    # of our utility routines.
    use Exporter;
    @ISA = qw( Exporter );
    @EXPORT_OK = qw( image_size thumb_limits );

    use strict;

    use Apache::Constants qw( DECLINED );
    use Apache::Request;
    use File::Copy;
    use Imager;


    sub image_size {
        my $img = shift;

        if ( ! ref $img ) {
            my $fn = $img;
            $img = Imager-&amp;gt;new;
            $img-&amp;gt;open( file =&amp;gt; $fn )
                or die $img-&amp;gt;errstr(), &amp;quot;: $fn&amp;quot;;
        }

        ( $img-&amp;gt;getwidth, $img-&amp;gt;getheight );
    }


    sub thumb_limits {
        my $r = shift;

        # See if the site admin has placed MyMaxX and/or
        # MyMaxY in the httpd.conf.
        my ( $max_w, $max_h ) = map
            $r-&amp;gt;dir_config( $_ ),
            qw( MyMaxX MyMaxY );

        return ( $max_w, $max_h )
            if $max_w || $max_h;

        # Default to scaling down to fit in a 100 x 100
        # pixel area (aspect ration will be maintained).
        return ( 100, 100 );
    }


    # Apache/mod_perl is configured to call
    # this handler for every dotfile
    # requested.  All thumbnail images are dotfiles,
    # some dotfiles may not be thumbnails.
    sub handler {
        my $r = Apache::Request-&amp;gt;new( shift );

        # We only want to handle images.
        # Let Apache handle non-images.
        goto EXIT
            unless substr( $r-&amp;gt;content_type, 0, 6 ) eq &amp;quot;image/&amp;quot;;

        # The actual image filename is the thumbnail
        # filename without the leading &amp;quot;.&amp;quot;.  There&#39;s
        ( my $orig_fn = $r-&amp;gt;filename ) =~ s{/\.([^/]+)\z}{/$1}
            or die &amp;quot;Can&#39;t parse &amp;quot;, $r-&amp;gt;filename;

        # Let Apache serve the thumbnail if it already
        # exists and is newer than the original file.
        {
            my $thumb_age = -M $r-&amp;gt;finfo;
            my $orig_age  = -M $orig_fn;
            goto EXIT
                if $thumb_age &amp;amp;&amp;amp; $thumb_age &amp;lt;= $orig_age;
        }

        # Read in the original file
        my $orig = Imager-&amp;gt;new;
        unless ( $orig-&amp;gt;open( file =&amp;gt; $orig_fn ) ) {
            # Imager can&#39;t hack the format, fall back
            # to the original image.  This can happen
            # if you forget to install libgif
            # (as I have done).
            goto FALLBACK
                if $orig-&amp;gt;errstr =~ /format not supported/;

            # Other errors are probably more serious.
            die $orig-&amp;gt;errstr, &amp;quot;: $orig_fn\n&amp;quot;;
        }

        my ( $w, $h ) = image_size( $orig );

        die &amp;quot;!\$w for &amp;quot;, $r-&amp;gt;filename, &amp;quot;\n&amp;quot; unless $w;
        die &amp;quot;!\$h for &amp;quot;, $r-&amp;gt;filename, &amp;quot;\n&amp;quot; unless $h;

        my ( $max_w, $max_h ) = thumb_limits( $r );

        # Scale down only,  If the image is smaller than
        # the thumbnail limits, let Apache serve it as-is.
        # thumb_limits() guarantees that either $max_w
        # or $max_h will be true.
        goto FALLBACK
            if ( ! $max_w || $w &amp;lt; $max_w )
            &amp;amp;&amp;amp; ( ! $max_h || $h &amp;lt; $max_h );

        # Scale down to the maximum dimension to the
        # requested size.  This can mess up for images
        # that are meant to be scaled on each axis
        # independantly, like graphic bars for HTML
        # page seperators, but that&#39;s a very small
        # demographic.
        my $thumb = $orig-&amp;gt;scale(
            $w &amp;gt; $h
                ? ( xpixels =&amp;gt; $max_w )
                : ( ypixels =&amp;gt; $max_h )
        );
        $thumb-&amp;gt;write( file =&amp;gt; $r-&amp;gt;filename,)
            or die $thumb-&amp;gt;errstr, &amp;quot;: &amp;quot;, $r-&amp;gt;filename;

        goto BONK;

    FALLBACK:
        # If we can&#39;t or don&#39;t want to build the thumbnail,
        # just copy the original and let Apache figure it out.
        warn &amp;quot;Falling back to &amp;quot;, $orig_fn, &amp;quot;\n&amp;quot;;
        copy( $orig_fn, $r-&amp;gt;filename );

    BONK:
        # Bump apache on the head just hard enough to make it
        # forget the thumbnail file&#39;s old stat() and
        # mime type since we&#39;ve most likely changed all
        # that now.  This is important for the headers
        # that control downstream caching, for instance,
        # or in case Imager changed mime types on us
        # (unlikely, but hey...)
        $r-&amp;gt;filename( $r-&amp;gt;filename );

    EXIT:
        # We never serve the image data, Apache is perfectly
        # good at doing this without our help.  Returning
        # DECLINED causes Apache to use the next handler in
        # its list of handlers.  Normally this is the default
        # Apache file handler.
        return DECLINED;
    }

    1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There should be enough inline commentary to explain that lot. The only thing I&amp;rsquo;ll say is that, to head off the gotophobes, I think the use of &lt;code&gt;goto&lt;/code&gt; makes this routine a lot clearer than the alternatives; the early versions did not use it and were less readable/maintainable. This is because the three normal exit routes happen to stack nicely up from the bottom so the fallthrough from one labeled chunk to the next happens nicely.&lt;/p&gt;

&lt;p&gt;The most glaring mistake here is that there is no file locking. We&amp;rsquo;ll add that in next time.&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;Summary&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&#34;summary&#34;&gt;Summary&lt;/h3&gt;

&lt;p&gt;The final result of the code in this article is to build the image proofsheet section of &lt;a href=&#34;http://localhost:1313/pub/2002/09/24/axkit.html?page=1#proofsheet.png&#34;&gt;the page we showed at the beginning of the article&lt;/a&gt;. The next article will complete that page, and then we&amp;rsquo;ll build the image presentation page and a metadata editor in future articles.&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;help&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&#34;help-and-thanks&#34;&gt;Help and thanks&lt;/h3&gt;

&lt;p&gt;In case of trouble, have a look at some of the &lt;a href=&#34;http://localhost:1313/pub/2002/03/12/axkit.html?page=3#help&#34;&gt;helpful resources we listed in the first article&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Taglib TMTOWTDI</title>
      <link>http://localhost:1313/pub/2002/07/02/axkit.html/</link>
      <pubDate>Tue, 02 Jul 2002 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2002/07/02/axkit.html/</guid>
      <description>

&lt;p&gt;As with many Perl systems, AxKit often provides multiple ways of doing things. Developers from other programming cultures may find these choices and freedom a bit bewildering at first but this (hopefully) soon gives way to the realization that the options provide power and freedom. When a tool set limits your choices too much, you end up doing things like driving screws with a nailgun. Of course, too many choices isn&amp;rsquo;t necessarily a good thing, but it&amp;rsquo;s better than too few.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/04/16/axkit.html&#34;&gt;Last time&lt;/a&gt;, we saw how to build a weather reporting application by implementing a simple taglib module, My::WeatherTaglib, in Perl and deploying it in &lt;span&gt;a pipeline&lt;/span&gt; with other XML filters. The pipeline approach allows one kind of flexibility: the freedom to decompose an application in the most appropriate manner for the requirements at hand and for the supporting organization.&lt;/p&gt;

&lt;p&gt;Another kind of flexibility is the freedom to implement filters using different technologies. For instance, it is sometimes wise to build taglibs in different ways. In this article, we&amp;rsquo;ll see how to build the same taglib using two other approaches. The first rebuild uses the technique implemented by the Cocoon project, &lt;a href=&#34;http://cocoon.apache.org/2.1/userdocs/xsp/logicsheet-concepts.html&#34;&gt;LogicSheets&lt;/a&gt;. The second uses JÃ¶rg Walter&amp;rsquo;s relatively new &lt;a href=&#34;http://search.cpan.org/doc/MSERGEANT/AxKit-1.51/lib/Apache/AxKit/Language/XSP/SimpleTaglib.pm&#34;&gt;SimpleTaglib&lt;/a&gt; in place of the &lt;a href=&#34;http://search.cpan.org/doc/MSERGEANT/AxKit-1.51/lib/Apache/AxKit/Language/XSP/TaglibHelper.pm&#34;&gt;TaglibHelper&lt;/a&gt; used for My::WeatherTaglib in the previous article. SimpleTaglib is a somewhat more powerful, and, oddly, more complex module than TaglibHelper (though the author intends to make it a bit simpler to use in the near future).&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;CHANGES&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&#34;changes&#34;&gt;CHANGES&lt;/h3&gt;

&lt;p&gt;AxKit v1.6 is now out with some nice bug fixes and performance improvements, mostly by Matt Sergeant and JÃ¶rg Walter, along with several new advanced features from Kip Hampton which we&amp;rsquo;ll be covering in future articles.&lt;/p&gt;

&lt;p&gt;Matt has also updated his AxKit compatible &lt;a href=&#34;http://search.cpan.org/doc/MSERGEANT/AxKit-1.6/lib/Apache/AxKit/Language/AxPoint.pm&#34;&gt;AxPoint&lt;/a&gt; PowerPoint-like HTML/PDF/etc. presentation system. If you&amp;rsquo;re going to attend any of the big Perl conferences this season, then you&amp;rsquo;re likely to see presentations built with AxPoint. It&amp;rsquo;s a nice system that&amp;rsquo;s also covered in an &lt;a href=&#34;https://www.xml.com/pub/2002/06/19/perl-xml.html&#34;&gt;XML.com article by Kip Hampton&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;AxTraceIntermediate&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&#34;axtraceintermediate&#34;&gt;AxTraceIntermediate&lt;/h4&gt;

&lt;p&gt;The one spiffy new feature I used &amp;ndash; rather more often than I&amp;rsquo;d like to admit &amp;ndash; in writing this article is the debugging directive &lt;code&gt;AxTraceIntermediate&lt;/code&gt;, added by JÃ¶rg Walter. This directive defines a directory in which AxKit will place a copy each of the intermediate documents passed between filters in the pipeline. So a setting like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    AxTraceIntermediate /home/barries/AxKit/www/axtrace
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will place one file in the &lt;code&gt;axtrace&lt;/code&gt; directory for each intermediate document. The full set of directives in &lt;code&gt;httpd.conf&lt;/code&gt; used for this article is &lt;a href=&#34;#httpd.conf&#34;&gt;shown later&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Here is the axtrace directory after requesting the URIs &lt;code&gt;/&lt;/code&gt; (from the first article), &lt;code&gt;/02/weather1.xsp&lt;/code&gt; (from the second article), &lt;code&gt;/03/weather1.xsp&lt;/code&gt; and &lt;code&gt;/03/weather2.xsp&lt;/code&gt; (both from this article):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    |index.xsp.XSP         # Perl source code for /index.xsp
    |index.xsp.0           # Output of XSP filter

    |02|weather1.xsp.XSP   # Perl source code for /02/weather1.xsp
    |02|weather1.xsp.0     # Output of XSP
    |02|weather1.xsp.1     # Output of weather.xsl
    |02|weather1.xsp.2     # Output of as_html.xsl

    |03|weather1.xsp.XSP   # Perl source code for /03/weather1.xsp
    |03|weather1.xsp.0     # Output of XSP
    |03|weather1.xsp.1     # Output of weather.xsl
    |03|weather1.xsp.2     # Output of as_html.xsl

    |03|weather2.xsp.XSP   # Perl source code for /02/weather2.xsp
    |03|weather2.xsp.0     # output of my_weather_taglib.xsl
    |03|weather2.xsp.1     # Output of XSP
    |03|weather2.xsp.2     # Output of weather.xsl
    |03|weather2.xsp.3     # Output of as_html.xsl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each filename is the path portion of the URI with the &lt;code&gt;/&lt;/code&gt;s replaced with &lt;code&gt;|&lt;/code&gt;s and a step number (or .XSP) appended. The numbered files are the intermediate documents and the &lt;code&gt;.XSP&lt;/code&gt; files are the Perl source code for any XSP filters that happened to be compiled for this request. Compare the &lt;code&gt;|03|weather2.xsp.*&lt;/code&gt; files to the &lt;a href=&#34;#weather2_pipeline.png&#34;&gt;the pipeline diagram&lt;/a&gt; for the /03/weather2.xsp request.&lt;/p&gt;

&lt;p&gt;Watch those &amp;ldquo;&lt;code&gt;|&lt;/code&gt;&amp;rdquo; characters: they force you to quote the filenames in most shells (and thus foil any use of wildcards):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $ xmllint --format &amp;quot;www/axtrace/|03|weather2.xsp.3&amp;quot;
    &amp;lt;?xml version=&amp;quot;1.0&amp;quot; standalone=&amp;quot;yes&amp;quot;?&amp;gt;
    &amp;lt;html&amp;gt;
      &amp;lt;head&amp;gt;
        &amp;lt;meta content=&amp;quot;text/html; charset=UTF-8&amp;quot; http-equiv=&amp;quot;Content-Type&amp;quot;/&amp;gt;
        &amp;lt;title&amp;gt;My Weather Report&amp;lt;/title&amp;gt;
      &amp;lt;/head&amp;gt;
      &amp;lt;body&amp;gt;
        &amp;lt;h1&amp;gt;&amp;lt;a name=&amp;quot;title&amp;quot;/&amp;gt;My Weather Report&amp;lt;/h1&amp;gt;
        &amp;lt;p&amp;gt;Hi! It&#39;s 12:43:52&amp;lt;/p&amp;gt;
        &amp;lt;p&amp;gt;The weather in Pittsburgh is Sunny
        ....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; The &lt;code&gt;.XSP&lt;/code&gt; files are only generated if the XSP sheet is recompiled, so you may need to &lt;code&gt;touch&lt;/code&gt; the source document or restart the server to generate a new one. Another gotcha is that if an error occurs halfway down the processing pipeline, then you can end up with stale files. In this case, the lower-numbered files (those generated by successful filters) will be from this request, but the higher-numbered files will be stale, left over from the previous requests. A slightly different issue can occur when using dynamic pipeline configurations (which we&amp;rsquo;ll cover in the future): you can end up with a shorter pipeline that only overwrites the lower-numbered files and leaves stale higher-numbered files around.&lt;/p&gt;

&lt;p&gt;These are pretty minor gotchas when compared to the usefulness of this feature, you just need to be aware of them to avoid confusion. When debugging for this article, I used a Perl script that does something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rm -f www/axtrace/*
    rm www/logs/*
    www/bin/apachectl stop
    sleep 1
    www/bin/apachectl start
    GET http://localhost:8080/03/weather1.xsp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to start each test run with a clean fileset.&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;UnderTheXSPHood&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&#34;under-the-xsp-hood&#34;&gt;Under the XSP Hood&lt;/h3&gt;

&lt;p&gt;Before we move on to the examples, let&amp;rsquo;s take a quick peek at how XSP pages are handled by AxKit. This will help us understand the tradeoffs inherent in the different approaches.&lt;/p&gt;

&lt;p&gt;AxKit implements XSP filters by compiling the source XSP page into a &lt;code&gt;handler()&lt;/code&gt; function that is called to generate the output page. This is compiled in to Perl bytecode, which is then run to generate the XSP output document:&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;xsp_compiler.png&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2002_07_02_axkit/xsp_compiler.png&#34; alt=&#34;XSP architecture&#34; width=&#34;340&#34; height=&#34;219&#34; /&gt;&lt;/span&gt;
This means that XSP page is not executed directly, but by running relatively efficient compiled Perl code. The bytecode is kept in memory so the overhead of parsing and code generation is not incurred for each request.&lt;/p&gt;

&lt;p&gt;There are three types of Perl code used in building the output document: code to build the bits of static content, code that was present verbatim in the source document &amp;ndash; enclosed in tags like &lt;code&gt;&amp;lt;xsp:logic&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;xsp:expr&amp;gt;&lt;/code&gt; &amp;ndash; and code that implements tags handled by registered taglib modules like My::WeatherTaglib from the last article.&lt;/p&gt;

&lt;p&gt;Taglib modules hook in to the XSP compiler by registering themselves as handlers for a namespace and then coughing up snippets of code to be compiled in to the &lt;code&gt;handler()&lt;/code&gt; routine:&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;xsp_taglib_hookin.png&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2002_07_02_axkit/xsp_taglib_hookin.png&#34; alt=&#34;XSP with Taglib Modules Hooking in&#34; width=&#34;351&#34; height=&#34;372&#34; /&gt;&lt;/span&gt;
The snippets of code can call back into the taglib module or out to other modules as needed. Modules like &lt;a href=&#34;http://search.cpan.org/doc/MSERGEANT/AxKit-1.51/lib/Apache/AxKit/Language/XSP/TaglibHelper.pm&#34;&gt;TaglibHelper&lt;/a&gt;, which we used to build My::WeatherTaglib and &lt;a href=&#34;http://search.cpan.org/doc/MSERGEANT/AxKit-1.51/lib/Apache/AxKit/Language/XSP/SimpleTaglib.pm&#34;&gt;SimpleTaglib&lt;/a&gt;, which we use later in this article for My::SimpleWeatherTaglib, automate the drudgery of building a taglib module so you don&amp;rsquo;t need to parse XML or even (usually) generate XML.&lt;/p&gt;

&lt;p&gt;You can view the source code that AxKit generates by cranking the &lt;code&gt;AxDebugLevel&lt;/code&gt; up to 10 (which places the code in Apache&amp;rsquo;s ErrorLog) or using the &lt;code&gt;AxTraceIntermediate&lt;/code&gt; directive mentioned above. Then you must persuade AxKit to recompile the XSP page by restarting the server and requesting a page. If either of the necessary directives are already present in a running server, then simply &lt;code&gt;touch&lt;/code&gt;ing the file to update its modification time will suffice.&lt;/p&gt;

&lt;p&gt;This can be useful for getting a &lt;em&gt;really&lt;/em&gt; good feel for what&amp;rsquo;s going on under the hood. I encourage new taglib authors to do this to see how the code for your taglib is actually executed. You&amp;rsquo;ll end up needing to do it to debug anyway (trust me :).&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;XSLT&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&#34;logicsheets-upstream-taglibs&#34;&gt;LogicSheets: Upstream Taglibs&lt;/h3&gt;

&lt;p&gt;AxKit uses a pipeline processing model and XSP includes tags like &lt;code&gt;&amp;lt;xsp:logic&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;xsp:expr&amp;gt;&lt;/code&gt; that allow you to embed Perl code in an XSP page. This allows taglibs to be implemented as XML filters that are placed upstream of the XSP processor. These usually use XSLT to and convert taglib invocations to inline code using XSP tags:&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;logic_sheet_pipeline.png&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2002_07_02_axkit/logic_sheet_pipeline.png&#34; alt=&#34;Upstream LogicSheets feeding the XSP processor&#34; width=&#34;420&#34; height=&#34;200&#34; /&gt;&lt;/span&gt;
In fact, this is how XSP was originally designed to operate and Cocoon uses this approach exclusively to this day (but with inline Java instead of Perl). I did not show this approach in the first article because it is considerably more awkward and less flexible than the taglib module approach offered by AxKit.&lt;/p&gt;

&lt;p&gt;The Cocoon project calls XSLT sheets that implement taglibs &lt;a href=&#34;http://cocoon.apache.org/2.1/userdocs/xsp/logicsheet-concepts.html&#34;&gt;LogicSheets&lt;/a&gt; a convention I follow in this article (I refer to the all-Perl taglib implementation as &amp;ldquo;taglib modules&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;weather2.xsp&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&#34;weather2-xsp&#34;&gt;&lt;code&gt;weather2.xsp&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;Before we look at the logicsheet version of the weather report taglib, here is the XSP page from the last article updated to use it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml-stylesheet href=&amp;quot;my_weather_taglib.xsl&amp;quot; type=&amp;quot;text/xsl&amp;quot;?&amp;gt;
&amp;lt;?xml-stylesheet href=&amp;quot;NULL&amp;quot;                  type=&amp;quot;application/x-xsp&amp;quot;?&amp;gt;
&amp;lt;?xml-stylesheet href=&amp;quot;weather.xsl&amp;quot;           type=&amp;quot;text/xsl&amp;quot;?&amp;gt;
&amp;lt;?xml-stylesheet href=&amp;quot;as_html.xsl&amp;quot;           type=&amp;quot;text/xsl&amp;quot;?&amp;gt;

&amp;lt;xsp:page
    xmlns:xsp=&amp;quot;http://apache.org/xsp/core/v1&amp;quot;
    xmlns:util=&amp;quot;http://apache.org/xsp/util/v1&amp;quot;
    xmlns:param=&amp;quot;http://axkit.org/NS/xsp/param/v1&amp;quot;
    xmlns:weather=&amp;quot;http://slaysys.com/axkit_articles/weather/&amp;quot;
&amp;gt;
&amp;lt;data&amp;gt;
  &amp;lt;title&amp;gt;&amp;lt;a name=&amp;quot;title&amp;quot;/&amp;gt;My Weather Report&amp;lt;/title&amp;gt;
  &amp;lt;time&amp;gt;
    &amp;lt;util:time format=&amp;quot;%H:%M:%S&amp;quot; /&amp;gt;
  &amp;lt;/time&amp;gt;
  &amp;lt;weather&amp;gt;
    &amp;lt;weather:report&amp;gt;
      &amp;lt;!-- Get the ?zip=12345 from the URI and pass it
           to the weather:report tag as a parameter --&amp;gt;
      &amp;lt;weather:zip&amp;gt;&amp;lt;param:zip/&amp;gt;&amp;lt;/weather:zip&amp;gt;
    &amp;lt;/weather:report&amp;gt;
  &amp;lt;/weather&amp;gt;
&amp;lt;/data&amp;gt;
&amp;lt;/xsp:page&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;p&gt;&lt;strong&gt;In This Series&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/03/12/axkit.html&#34;&gt;Introducing AxKit&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
The first in a series of articles by Barrie Slaymaker on setting up and running AxKit. AxKit is a mod_perl application for dynamically transforming XML. In this first article, we focus on getting started with AxKit.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/04/16/axkit.html&#34;&gt;XSP, Taglibs and Pipelines&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
Barrie explains what a &amp;quot;taglib&amp;quot; is, and how to use them to create dynamic pages inside of AxKit.&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The &lt;code&gt;&amp;lt;?xml-stylesheet href=&amp;quot;my_weather_taglib.xsl&amp;quot; type=&amp;quot;text/xsl&amp;quot;?&amp;gt;&lt;/code&gt; processing instruction causes &lt;code&gt;my_weather_taglib.xsl&lt;/code&gt; (which we&amp;rsquo;ll cover next) to be applied to the &lt;code&gt;weather2.xsp&lt;/code&gt; page before the XSP processor sees it. The other three PIs are identical to the previous version: the XSP processor is invoked, followed by the same &lt;a href=&#34;http://localhost:1313/pub/2002/04/16/axkit.html#weather.xsl&#34;&gt;presentation&lt;/a&gt; and &lt;a href=&#34;http://localhost:1313/pub/2002/04/16/axkit.html#as_html.xsl&#34;&gt;HTMLification&lt;/a&gt; XSLT stylesheets that we used last time.&lt;/p&gt;

&lt;p&gt;The only other change from the previous version is that this one uses the corrent URI for XSP tags. I accidently used a deprecated URI for XSP tags in the previous article and ended up tripping over it when I used the up-to-date URI in the LogicSheet for this one. Such is the life of a pointy-brackets geek.&lt;/p&gt;

&lt;p&gt;The ability to switch implementations without altering (much) code is one of XSP&amp;rsquo;s advantages over things like inline Perl code: the implementation is nicely decoupled from the API (the tags). The only reason we had to alter &lt;code&gt;weather1.xsp&lt;/code&gt; at all is because we&amp;rsquo;re switching from a more advanced approach (a taglib module, My::WeatherTaglib) that is configured in the &lt;code&gt;httpd.conf&lt;/code&gt; file to LogicSheets, which need per-document configuration when using &lt;code&gt;&amp;lt;xml-stylesheet&amp;gt;&lt;/code&gt; stylesheet specifications. AxKit has more flexible &lt;code&gt;httpd.conf&lt;/code&gt;, plugin and Perl based stylesheet specification mechanisms which we will cover in a future article; I&amp;rsquo;m using the processing instructions here because they are simple and obvious.&lt;/p&gt;

&lt;p&gt;The pipeline built by the processing instructions looks like:&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;weather2_pipeline.png&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2002_07_02_axkit/weather2_pipeline.png&#34; alt=&#34;The pipeline for weather2.xsp&#34; width=&#34;409&#34; height=&#34;197&#34; /&gt;&lt;/span&gt;
(does not show final compression stage).&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;my_weather_taglib.xsl&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&#34;my-weather-taglib-xsl&#34;&gt;&lt;code&gt;my_weather_taglib.xsl&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;Now that we&amp;rsquo;ve seen the source document and the overall pipeline, here is &lt;a href=&#34;http://localhost:1313/pub/2002/04/16/axkit.html#My::WeatherTaglib&#34;&gt;My::WeatherTaglib&lt;/a&gt; recast as a LogicSheet, &lt;code&gt;my_weather_taglib.xsl&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xsl:stylesheet
  version=&amp;quot;1.0&amp;quot;
  xmlns:xsl=&amp;quot;http://www.w3.org/1999/XSL/Transform&amp;quot;
  xmlns:xsp=&amp;quot;http://apache.org/xsp/core/v1&amp;quot;
  xmlns:weather=&amp;quot;http://slaysys.com/axkit_articles/weather/&amp;quot;
&amp;gt;

&amp;lt;xsl:output indent=&amp;quot;yes&amp;quot; /&amp;gt;

&amp;lt;xsl:template match=&amp;quot;xsp:page&amp;quot;&amp;gt;
  &amp;lt;xsl:copy&amp;gt;
    &amp;lt;xsp:structure&amp;gt;
      use Geo::Weather;
    &amp;lt;/xsp:structure&amp;gt;
    &amp;lt;xsl:apply-templates select=&amp;quot;@*|node()&amp;quot;/&amp;gt;
  &amp;lt;/xsl:copy&amp;gt;
&amp;lt;/xsl:template&amp;gt;

&amp;lt;xsl:template match=&amp;quot;weather:report&amp;quot;&amp;gt;
  &amp;lt;xsp:logic&amp;gt;
    my $zip = &amp;lt;xsl:apply-templates select=&amp;quot;weather:zip/*&amp;quot; /&amp;gt;;
    my $w = Geo::Weather-&amp;gt;new-&amp;gt;get_weather( $zip );
    die &amp;quot;Could not get weather for zipcode &#39;$zip&#39;\n&amp;quot; unless ref $w;
  &amp;lt;/xsp:logic&amp;gt;
  &amp;lt;state&amp;gt;&amp;lt;xsp:expr&amp;gt;$w-&amp;gt;{state}&amp;lt;/xsp:expr&amp;gt;&amp;lt;/state&amp;gt;
  &amp;lt;heat&amp;gt;&amp;lt;xsp:expr&amp;gt;$w-&amp;gt;{heat}&amp;lt;/xsp:expr&amp;gt;&amp;lt;/heat&amp;gt;
  &amp;lt;page&amp;gt;&amp;lt;xsp:expr&amp;gt;$w-&amp;gt;{page}&amp;lt;/xsp:expr&amp;gt;&amp;lt;/page&amp;gt;
  &amp;lt;wind&amp;gt;&amp;lt;xsp:expr&amp;gt;$w-&amp;gt;{wind}&amp;lt;/xsp:expr&amp;gt;&amp;lt;/wind&amp;gt;
  &amp;lt;city&amp;gt;&amp;lt;xsp:expr&amp;gt;$w-&amp;gt;{city}&amp;lt;/xsp:expr&amp;gt;&amp;lt;/city&amp;gt;
  &amp;lt;cond&amp;gt;&amp;lt;xsp:expr&amp;gt;$w-&amp;gt;{cond}&amp;lt;/xsp:expr&amp;gt;&amp;lt;/cond&amp;gt;
  &amp;lt;temp&amp;gt;&amp;lt;xsp:expr&amp;gt;$w-&amp;gt;{temp}&amp;lt;/xsp:expr&amp;gt;&amp;lt;/temp&amp;gt;
  &amp;lt;uv&amp;gt;&amp;lt;xsp:expr&amp;gt;$w-&amp;gt;{uv}&amp;lt;/xsp:expr&amp;gt;&amp;lt;/uv&amp;gt;
  &amp;lt;visb&amp;gt;&amp;lt;xsp:expr&amp;gt;$w-&amp;gt;{visb}&amp;lt;/xsp:expr&amp;gt;&amp;lt;/visb&amp;gt;
  &amp;lt;url&amp;gt;&amp;lt;xsp:expr&amp;gt;$w-&amp;gt;{url}&amp;lt;/xsp:expr&amp;gt;&amp;lt;/url&amp;gt;
  &amp;lt;dewp&amp;gt;&amp;lt;xsp:expr&amp;gt;$w-&amp;gt;{dewp}&amp;lt;/xsp:expr&amp;gt;&amp;lt;/dewp&amp;gt;
  &amp;lt;zip&amp;gt;&amp;lt;xsp:expr&amp;gt;$w-&amp;gt;{zip}&amp;lt;/xsp:expr&amp;gt;&amp;lt;/zip&amp;gt;
  &amp;lt;baro&amp;gt;&amp;lt;xsp:expr&amp;gt;$w-&amp;gt;{baro}&amp;lt;/xsp:expr&amp;gt;&amp;lt;/baro&amp;gt;
  &amp;lt;pic&amp;gt;&amp;lt;xsp:expr&amp;gt;$w-&amp;gt;{pic}&amp;lt;/xsp:expr&amp;gt;&amp;lt;/pic&amp;gt;
  &amp;lt;humi&amp;gt;&amp;lt;xsp:expr&amp;gt;$w-&amp;gt;{humi}&amp;lt;/xsp:expr&amp;gt;&amp;lt;/humi&amp;gt;
&amp;lt;/xsl:template&amp;gt;

&amp;lt;xsl:template match=&amp;quot;@*|node()&amp;quot;&amp;gt;
  &amp;lt;!-- Copy the rest of the doc almost verbatim --&amp;gt;
  &amp;lt;xsl:copy&amp;gt;
    &amp;lt;xsl:apply-templates select=&amp;quot;@*|node()&amp;quot;/&amp;gt;
  &amp;lt;/xsl:copy&amp;gt;
&amp;lt;/xsl:template&amp;gt;

&amp;lt;/xsl:stylesheet&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first &lt;code&gt;&amp;lt;xsl:template&amp;gt;&lt;/code&gt; inserts an &lt;code&gt;&amp;lt;xsp:structure&amp;gt;&lt;/code&gt; at the top of the page with some Perl code to &lt;code&gt;use Geo::Weather;&lt;/code&gt; so the Perl code in the later &lt;code&gt;&amp;lt;xsl:logic&amp;gt;&lt;/code&gt; element can refer to it. You could also preload Geo::Weather in &lt;code&gt;httpd.conf&lt;/code&gt; to share it amongst httpd processes and simplify this stylesheet, but that would introduce a bit of a maintainance hassle: keeping the server config and the LogicSheet in synchronization.&lt;/p&gt;

&lt;p&gt;The second &lt;code&gt;&amp;lt;xsl:template&amp;gt;&lt;/code&gt; replaces all occurences of &lt;code&gt;&amp;lt;weather:report&amp;gt;&lt;/code&gt; (assuming the &lt;code&gt;weather:&lt;/code&gt; prefix happens to map to the taglib URI; see &lt;a href=&#34;http://www.jclark.com/xml/xmlns.htm&#34;&gt;James Clark&amp;rsquo;s introduction to namespace&lt;/a&gt; for more details). In place of the &lt;code&gt;&amp;lt;weather:report&amp;gt;&lt;/code&gt; tag(s) will be some Perl code surrounded by &lt;code&gt;&amp;lt;xsp:logic&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;xsp:expr&amp;gt;&lt;/code&gt; tags. The &lt;code&gt;&amp;lt;xsp:logic&amp;gt;&lt;/code&gt; tag is used around Perl code that is just logic: any value the code returns is ignored. The &lt;code&gt;&amp;lt;xsp:expr&amp;gt;&lt;/code&gt; tags surround Perl code that returns a value to be emitted as text in the result document.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;get_weather()&lt;/code&gt; call returns a hash describing the most recent weather oberservations somewhere close to a given zip code:&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;hash&#34;&gt;&lt;/span&gt;
        {
          &amp;lsquo;city&amp;rsquo;  =&amp;gt; &amp;lsquo;Pittsburgh&amp;rsquo;,
          &amp;lsquo;state&amp;rsquo; =&amp;gt; &amp;lsquo;PA&amp;rsquo;,
          &amp;lsquo;cond&amp;rsquo;  =&amp;gt; &amp;lsquo;Sunny&amp;rsquo;,
          &amp;lsquo;temp&amp;rsquo;  =&amp;gt; &amp;lsquo;77&amp;rsquo;,
          &amp;hellip;
        };&lt;/p&gt;

&lt;p&gt;All those &lt;code&gt;&amp;lt;xsp:expr&amp;gt;&lt;/code&gt; tags extract the values from the hash one by one and build an XML data structure. The resulting XSP document looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;
    &amp;lt;xsp:page xmlns:xsp=&amp;quot;http://apache.org/xsp/core/v1&amp;quot;
 xmlns:util=&amp;quot;http://apache.org/xsp/util/v1&amp;quot;
 xmlns:param=&amp;quot;http://axkit.org/NS/xsp/param/v1&amp;quot;
 xmlns:weather=&amp;quot;http://slaysys.com/axkit_articles/weather/&amp;quot;&amp;gt;
      &amp;lt;xsp:structure&amp;gt;
          use Geo::Weather;
      &amp;lt;/xsp:structure&amp;gt;
      &amp;lt;data&amp;gt;
        &amp;lt;title&amp;gt;&amp;lt;a name=&amp;quot;title&amp;quot;/&amp;gt;My Weather Report&amp;lt;/title&amp;gt;
        &amp;lt;time&amp;gt;
          &amp;lt;util:time format=&amp;quot;%H:%M:%S&amp;quot;/&amp;gt;
        &amp;lt;/time&amp;gt;
        &amp;lt;weather&amp;gt;
          &amp;lt;xsp:logic&amp;gt;
            my $zip = &amp;lt;param:zip/&amp;gt;;
            my $w = Geo::Weather-&amp;gt;new-&amp;gt;get_weather( $zip );
            die &amp;quot;Could not get weather for zipcode &#39;$zip&#39;\n&amp;quot; unless ref $w;
          &amp;lt;/xsp:logic&amp;gt;
          &amp;lt;state&amp;gt;&amp;lt;xsp:expr&amp;gt;$w-&amp;gt;{state}&amp;lt;/xsp:expr&amp;gt;&amp;lt;/state&amp;gt;
          &amp;lt;heat&amp;gt;&amp;lt;xsp:expr&amp;gt;$w-&amp;gt;{heat}&amp;lt;/xsp:expr&amp;gt;&amp;lt;/heat&amp;gt;
          &amp;lt;page&amp;gt;&amp;lt;xsp:expr&amp;gt;$w-&amp;gt;{page}&amp;lt;/xsp:expr&amp;gt;&amp;lt;/page&amp;gt;
          &amp;lt;wind&amp;gt;&amp;lt;xsp:expr&amp;gt;$w-&amp;gt;{wind}&amp;lt;/xsp:expr&amp;gt;&amp;lt;/wind&amp;gt;
          &amp;lt;city&amp;gt;&amp;lt;xsp:expr&amp;gt;$w-&amp;gt;{city}&amp;lt;/xsp:expr&amp;gt;&amp;lt;/city&amp;gt;
          &amp;lt;cond&amp;gt;&amp;lt;xsp:expr&amp;gt;$w-&amp;gt;{cond}&amp;lt;/xsp:expr&amp;gt;&amp;lt;/cond&amp;gt;
          &amp;lt;temp&amp;gt;&amp;lt;xsp:expr&amp;gt;$w-&amp;gt;{temp}&amp;lt;/xsp:expr&amp;gt;&amp;lt;/temp&amp;gt;
          &amp;lt;uv&amp;gt;&amp;lt;xsp:expr&amp;gt;$w-&amp;gt;{uv}&amp;lt;/xsp:expr&amp;gt;&amp;lt;/uv&amp;gt;
          &amp;lt;visb&amp;gt;&amp;lt;xsp:expr&amp;gt;$w-&amp;gt;{visb}&amp;lt;/xsp:expr&amp;gt;&amp;lt;/visb&amp;gt;
          &amp;lt;url&amp;gt;&amp;lt;xsp:expr&amp;gt;$w-&amp;gt;{url}&amp;lt;/xsp:expr&amp;gt;&amp;lt;/url&amp;gt;
          &amp;lt;dewp&amp;gt;&amp;lt;xsp:expr&amp;gt;$w-&amp;gt;{dewp}&amp;lt;/xsp:expr&amp;gt;&amp;lt;/dewp&amp;gt;
          &amp;lt;zip&amp;gt;&amp;lt;xsp:expr&amp;gt;$w-&amp;gt;{zip}&amp;lt;/xsp:expr&amp;gt;&amp;lt;/zip&amp;gt;
          &amp;lt;baro&amp;gt;&amp;lt;xsp:expr&amp;gt;$w-&amp;gt;{baro}&amp;lt;/xsp:expr&amp;gt;&amp;lt;/baro&amp;gt;
          &amp;lt;pic&amp;gt;&amp;lt;xsp:expr&amp;gt;$w-&amp;gt;{pic}&amp;lt;/xsp:expr&amp;gt;&amp;lt;/pic&amp;gt;
          &amp;lt;humi&amp;gt;&amp;lt;xsp:expr&amp;gt;$w-&amp;gt;{humi}&amp;lt;/xsp:expr&amp;gt;&amp;lt;/humi&amp;gt;
        &amp;lt;/weather&amp;gt;
      &amp;lt;/data&amp;gt;
    &amp;lt;/xsp:page&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the output document of that XSP page looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
    &amp;lt;data&amp;gt;
      &amp;lt;title&amp;gt;&amp;lt;a name=&amp;quot;title&amp;quot;/&amp;gt;My Weather Report&amp;lt;/title&amp;gt;
      &amp;lt;time&amp;gt;17:06:15&amp;lt;/time&amp;gt;
      &amp;lt;weather&amp;gt;
        &amp;lt;state&amp;gt;PA&amp;lt;/state&amp;gt;
        &amp;lt;heat&amp;gt;77&amp;lt;/heat&amp;gt;
        &amp;lt;page&amp;gt;/search/search?what=WeatherLocalUndeclared
        &amp;amp;where=15206&amp;lt;/page&amp;gt;
        &amp;lt;wind&amp;gt;From the Northwest at 9 gusting to 16&amp;lt;/wind&amp;gt;
        &amp;lt;city&amp;gt;Pittsburgh&amp;lt;/city&amp;gt;
        &amp;lt;cond&amp;gt;Sunny&amp;lt;/cond&amp;gt;
        &amp;lt;temp&amp;gt;77&amp;lt;/temp&amp;gt;
        &amp;lt;uv&amp;gt;4&amp;lt;/uv&amp;gt;
        &amp;lt;visb&amp;gt;Unlimited miles&amp;lt;/visb&amp;gt;
        &amp;lt;url&amp;gt;http://www.weather.com/search/search?
        what=WeatherLocalUndeclared&amp;amp;where=15206&amp;lt;/url&amp;gt;
        &amp;lt;dewp&amp;gt;59&amp;lt;/dewp&amp;gt;
        &amp;lt;zip&amp;gt;15206&amp;lt;/zip&amp;gt;
        &amp;lt;baro&amp;gt;29.97 inches and steady&amp;lt;/baro&amp;gt;
        &amp;lt;pic&amp;gt;http://image.weather.com/web/common/wxicons/52/30.gif&amp;lt;/pic&amp;gt;
        &amp;lt;humi&amp;gt;54%&amp;lt;/humi&amp;gt;
      &amp;lt;/weather&amp;gt;
    &amp;lt;/data&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span id=&#34;LogicSheetAdvantages&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&#34;logicsheet-advantages&#34;&gt;LogicSheet Advantages&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;One taglib can generate XML that calls another taglib. Taglib modules may call each other at the Perl level, but taglib modules are XSP compiler plugins and do not cascade: The XSP compiler lives in a pipeline environment but does not use a pipeline internally.&lt;/li&gt;
&lt;li&gt;No need to add an &lt;code&gt;AxAddXSPTaglib&lt;/code&gt; directive and restart the Web server each time you write a tag lib.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Restarting a Web server just because a taglib has changed can be awkward in some environments, but this seems to be rare; restarting an Apache server is usually quick enough in a development environment and better not be necessary too often in a production environment.&lt;/p&gt;

&lt;p&gt;In the Cocoon community, LogicSheets can be registered and shared somewhat like the Perl community uses CPAN to share modules. This is an additional benefit when Cocooning, but does not carry much weight in the Perl world, which already has CPAN (there are many taglib modules on CPAN). There is no Java equivalent to CPAN in wide use, so Cocoon logic sheets need their own mechanism.&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;LogicSheetDisadvantages&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&#34;logicsheet-disadvantages&#34;&gt;LogicSheet Disadvantages&lt;/h4&gt;

&lt;p&gt;There are two fundamental drwabacks with LogicSheets, each with several symptoms. Many of the symptoms are minor, but they add up:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Requires inline code, usually in an XSLT stylesheet.

&lt;ul&gt;
&lt;li&gt;Putting Perl code in XML is awkward: You can&amp;rsquo;t easily syntax check the code (I happen to like to run &lt;code&gt;perl -cw ThisFile.pm&lt;/code&gt; a lot while writing Perl code) or take advantage of language-oriented editor features such as autoindenting, tags and syntax highlighting.&lt;/li&gt;
&lt;li&gt;The taglib author needs to work in four languages/APIs: XSLT (typically), XSP, Perl, and the taglib under development. XSLT and Perl are far from trivial, and though XSP is pretty simple, it&amp;rsquo;s easy to trip yourself up when context switching between them.&lt;/li&gt;
&lt;li&gt;LogicSheets are far less flexible than taglib modules. For instance, compare the rigidity of &lt;code&gt;my_weather_taglib.xsl&lt;/code&gt;&amp;rsquo;s output structure with the that of My::WeatherTaglib or My::SimpleWeatherTaglib. The LogicSheet approach requires hardcoding the result values, while the two taglib modules simply convert whatever is in the weather report data structures to XML.&lt;/li&gt;
&lt;li&gt;XSLT requires a fair amount of extra boilerplate to copy non-taglib bits of XSP pages through. This can usually be set up as boilerplate, but boilerplate in a program is just another thing to get in the way and require maintainance.&lt;/li&gt;
&lt;li&gt;LogicSheet are inherently single-purpose. Taglib modules, on the other hand, can be used as regular Perl modules. An authentication module can be used both as a taglib and as a regular module, for instance.&lt;/li&gt;
&lt;li&gt;LogicSheets need a working Web server for even the most basic functional testing since they need to be run in an XSP environment and AxKit does not yet support XSP outside a Web server. Writing taglib modules allows simple test suites to be written to vet the taglib&amp;rsquo;s code without needing a working Web server.&lt;/li&gt;
&lt;li&gt;Writing LogicSheets works best in an XML editor, otherwise you&amp;rsquo;ll need to escape all your &lt;code&gt;&amp;lt;&lt;/code&gt; characters, at least, and reading / writing XML-escaped Perl and Java code can be irksome.&lt;/li&gt;
&lt;li&gt;Embracing and extending a LogicSheet is difficult to do: The source XSP page needs to be aware of the fact that the taglib it&amp;rsquo;s using is using the base taglib and declare both of their namespaces. With taglib modules, Perl&amp;rsquo;s standard function import mechanism can be used to releive XSP authors of this duty.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Requires an additional stylesheet to process, usually XSLT. This means:

&lt;ul&gt;
&lt;li&gt;A more complex processing chain, which leads to XSP page complexity (and thus more likelihood of bugs) because each page must declare both the namespace for the taglib tags &lt;strong&gt;and&lt;/strong&gt; a processing instruction to run the taglib. As an example of a gotcha in this area, I used an outdated version of the XSP namespace URI in &lt;code&gt;weather2.xsp&lt;/code&gt; and the current URI in &lt;code&gt;my_weather_taglib.xsl&lt;/code&gt;. This caused me a bit of confusion, but the &lt;code&gt;AxTraceIntermediate&lt;/code&gt; directive helped shed some light on it.&lt;/li&gt;
&lt;li&gt;More disk files to check for changes each time an XSP page is served. Since each LogicSheet affects the output, each LogicSheet must be &lt;code&gt;stat()&lt;/code&gt;ed to see if it has changed since the last time the XSP page was compiled.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As you can probably tell, I feel that LogicSheets are a far more awkward and less flexible approach than writing taglibs as Perl modules using one of the helper libraries. Still, using upstream LogicSheets is a valid and perhaps occasionally useful technique for writing AxKit taglibs.&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;UpstreamGoodFor&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&#34;upstream-filters-good-for&#34;&gt;Upstream Filters good for?&lt;/h3&gt;

&lt;p&gt;So what is XSLT upstream of an XSP processor good for? You can do many things with it other than implementing LogicSheets. One use is to implement branding: altering things like logos, site name, and perhaps colors, or other customization, like administrator&amp;rsquo;s mail addresses on a login page that is shared by several sub-sites.&lt;/p&gt;

&lt;p&gt;A key advantage of doing transformations upstream of the XSP processor is that the XSP process caches the results of upstream transformations. XSP converts whatever document it receives in to Perl bytecode in memory and then just runs that bytecode if none of the upstream documents have changed.&lt;/p&gt;

&lt;p&gt;Another use is to convert source documents that declare what should be on a page to XSP documents that implement the machinery of a page. For instance, a survey site might have the source documents declare what questions to ask:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;survey&amp;gt;
      &amp;lt;question&amp;gt;
        &amp;lt;text&amp;gt;Have you ever eaten a Balut&amp;lt;/text&amp;gt;
        &amp;lt;response&amp;gt;Yes&amp;lt;/response&amp;gt;
        &amp;lt;response&amp;gt;No&amp;lt;/response&amp;gt;
        &amp;lt;response&amp;gt;Eeeewww&amp;lt;/response&amp;gt;
      &amp;lt;/question&amp;gt;
      &amp;lt;question&amp;gt;
        &amp;lt;text&amp;gt;Ok, then, well how about a nice haggis&amp;lt;/text&amp;gt;
        &amp;lt;response&amp;gt;Yes&amp;lt;/response&amp;gt;
        &amp;lt;response&amp;gt;No&amp;lt;/response&amp;gt;
        &amp;lt;response&amp;gt;Now that&#39;s more like it!&amp;lt;/response&amp;gt;
      &amp;lt;/question&amp;gt;
      ...
    &amp;lt;/survey&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;XSLT can be used to transform the survey definition in to an XSP page that uses the &lt;a href=&#34;http://search.cpan.org/doc/MSERGEANT/AxKit-XSP-PerForm-1.6/PerForm.pm&#34;&gt;PerForm taglib&lt;/a&gt; to automate form filling, etc. This approach allows pages to be defined in terms of what they are instead of how they should work.&lt;/p&gt;

&lt;p&gt;You can also use XSLT upstream of the XSP processor to do other things, like translate from a limited or simpler domain-specific tagset to a more complex or general purpose taglib written as a taglib module. This can allow you to define taglibs that are easier to use in terms of more powerful (but scary!) taglibs that are loaded in to the XSP processor.&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;My::SimpleWeatherTaglib&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&#34;my-simpleweathertaglib&#34;&gt;My::SimpleWeatherTaglib&lt;/h3&gt;

&lt;p&gt;A new-ish taglib helper module has been bundled in recent AxKit releases: JÃ¶rg Walter&amp;rsquo;s &lt;a href=&#34;http://search.cpan.org/doc/MSERGEANT/AxKit-1.51/lib/Apache/AxKit/Language/XSP/SimpleTaglib.pm&#34;&gt;SimpleTaglib&lt;/a&gt; (the full module name is Apache::AxKit::Language::XSP::SimpleTaglib). This module performs roughly the same function as Steve Willer&amp;rsquo;s &lt;a href=&#34;http://search.cpan.org/doc/MSERGEANT/AxKit-1.51/lib/Apache/AxKit/Language/XSP/TaglibHelper.pm&#34;&gt;TaglibHelper&lt;/a&gt;, but supports namespaces and uses a feature new to Perl, subroutine attributes, to specify the parameters and result formatting instead of a string.&lt;/p&gt;

&lt;p&gt;Here is My::SimpleWeatherTaglib:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package My::SimpleWeatherTaglib;

    use Apache::AxKit::Language::XSP::SimpleTaglib;

    $NS = &amp;quot;http://slaysys.com/axkit_articles/weather/&amp;quot;;

    package My::SimpleWeatherTaglib::Handlers;

    use strict;
    require Geo::Weather;

    ## Return the whole report for fixup later in the processing pipeline
    sub report :  child(zip) struct({}) {
        return &#39;Geo::Weather-&amp;gt;new-&amp;gt;get_weather( $attr_zip );&#39;
    }

    1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;$NS&lt;/code&gt; variable defines the namespace for this taglib. This module uses the same namespace as &lt;code&gt;my_weather_taglib.xsl&lt;/code&gt; and My::WeatherTaglib, because all three implement the same taglib (this repetetiveness is to demonstrate the differences between the approaches). See the &lt;a href=&#34;#MixingAndMatching&#34;&gt;Mixing and Matching Taglibs&lt;/a&gt; section to see how My::WeatherTaglib and My::SimpleWeatherTaglib can both be used in the same server instance.&lt;/p&gt;

&lt;p&gt;My::SimpleWeatherTaglib then shifts gears in to a new &lt;code&gt;package&lt;/code&gt;, My::SimpleWeatherTaglib::Handlers to define the subroutines for the taglib tags. Using a virgin package like this provides a clean place with which to declare the tag handlers. SimpleTaglib looks for the modules in the Foo::Handlers package if it&amp;rsquo;s &lt;code&gt;use()&lt;/code&gt;d in the Foo package (don&amp;rsquo;t use &lt;code&gt;require&lt;/code&gt; for this!).&lt;/p&gt;

&lt;p&gt;My::SimpleWeatherTaglib &lt;code&gt;require&lt;/code&gt;s Geo::Weather and declares a single tag, which handles the &lt;code&gt;&amp;lt;weather:report&amp;gt;&lt;/code&gt; tag in &lt;code&gt;weather1.xsp&lt;/code&gt; (which we&amp;rsquo;ll show in a moment).&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;require Geo::Weather;&lt;/code&gt; instead of &lt;code&gt;use Geo::Weather;&lt;/code&gt; is to avoid importing subroutines in to our otherwise &lt;code&gt;...::Handlers&lt;/code&gt; namespace which might look like a handler.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s something new afoot in the declaration for &lt;code&gt;sub report&lt;/code&gt;: subroutine attributes. Subroutine attributes are a new feature of Perl (as of perl5.6) that allow us to hang additional little bits of information on the subroutine declaration that describe it a bit more. &lt;a href=&#34;https://perldoc.perl.org/perlsub.html&#34;&gt;&lt;code&gt;perldoc perlsub&lt;/code&gt;&lt;/a&gt; for the details of this syntax. Some attributes are predefined by Perl, but modules may define others for their own purposes. In this case, the SimpleTaglib module defines a handful of attributes, some of which describe what parameters the taglib tag can take and others which describe how to convert the result value from the taglib implementation into XML output.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;child(zip)&lt;/code&gt; subroutine attribute tells the SimpleTaglib module that this handler expects a single child element named &lt;code&gt;zip&lt;/code&gt; in the taglib&amp;rsquo;s namespace. In &lt;code&gt;weather1.xsp&lt;/code&gt;, this ends up looking like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;weather:report&amp;gt;
      &amp;lt;!-- Get the ?zip=12345 from the URI and pass it
           to the weather:report tag as a parameter --&amp;gt;
      &amp;lt;weather:zip&amp;gt;&amp;lt;param:zip/&amp;gt;&amp;lt;/weather:zip&amp;gt;
    &amp;lt;/weather:report&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The text from the &lt;code&gt;&amp;lt;weather:zip&amp;gt;&lt;/code&gt; element (which will be filled in from the URI query string using the &lt;code&gt;param:&lt;/code&gt; taglib) will be made available in a variable named &lt;code&gt;$attr_zip&lt;/code&gt; at request time. The fact that the text from an element shows up in a variable beginning with &lt;code&gt;$attr_&lt;/code&gt; is confusing, but it does actually work that way.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;struct({})&lt;/code&gt; attribute specifies that the result of this tag will be returned as a Perl data structure that will be converted into XML. &lt;code&gt;Geo::Weather-&amp;gt;new-&amp;gt;get_weather( $zip )&lt;/code&gt; returns a HASH reference that looks like:&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;hash_2&#34;&gt;&lt;/span&gt;
        {
          &amp;lsquo;city&amp;rsquo;  =&amp;gt; &amp;lsquo;Pittsburgh&amp;rsquo;,
          &amp;lsquo;state&amp;rsquo; =&amp;gt; &amp;lsquo;PA&amp;rsquo;,
          &amp;lsquo;cond&amp;rsquo;  =&amp;gt; &amp;lsquo;Sunny&amp;rsquo;,
          &amp;lsquo;temp&amp;rsquo;  =&amp;gt; &amp;lsquo;77&amp;rsquo;,
          &amp;hellip;
        };&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;struct&lt;/code&gt; attribute tells SimpleTaglib to turn this in to XML like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;city&amp;gt;Pittsburgh&amp;lt;/city&amp;gt;
    &amp;lt;state&amp;gt;PA&amp;lt;/state&amp;gt;
    &amp;lt;cond&amp;gt;Sunny&amp;lt;/cond&amp;gt;
    &amp;lt;temp&amp;gt;77&amp;lt;/temp&amp;gt;
    ....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;{}&lt;/code&gt; in the &lt;code&gt;struct({})&lt;/code&gt; attribute specifies that the result nodes should be not be in a namespace (and thus have no namespace prefix), just like the static portions of our &lt;code&gt;weather1.xsp&lt;/code&gt; document. This is one of the advantages that SimpleTaglib has over other methods: It&amp;rsquo;s easier to emit nodes in different namespaces. To emit nodes in a specific namespace, put the namespace URI for that namespace inside the curlies: &lt;code&gt;struct({http://my.namespace.com/foo/bar})&lt;/code&gt;. The &lt;code&gt;{}&lt;/code&gt; notation is referred to as &lt;a href=&#34;http://www.jclark.com/xml/xmlns.htm&#34;&gt;James Clark (or jclark) notation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Now, the tricky bit. Harkening back to our &lt;a href=&#34;#UnderTheXSPHood&#34;&gt;discussion of how XSP is implemented&lt;/a&gt;, remember that the XSP processor compiles the XSP document into Perl code that is executed to build the output document. As XSP compiles the page, it keeps a lookout for tags in namespaces handled by taglib modules that have been configured in with &lt;code&gt;AxAddXSPTaglib&lt;/code&gt;. When XSP sees one of these tags, it calls in to the taglib module&amp;ndash;My::SimpleWeatherTaglib here&amp;ndash;for that namespace and requests a chunk of Perl source code to compile in place of the tag.&lt;/p&gt;

&lt;p&gt;Taglibs implemented with the SimpleTaglib module covered here declare handlers for each taglib tag (&lt;code&gt;sub report&lt;/code&gt;, for instance). That handler subroutine is called at parse time, not at request time. Its job is to return the chunk of code that will be compiled and then run later, at request time, to generate the output. So &lt;code&gt;report()&lt;/code&gt; returns a string containing a snippet of Perl code that calls into Geo::Weather. This Perl code will be compiled once, then run for each request.&lt;/p&gt;

&lt;p&gt;This is a key difference between the TaglibHelper module that My::WeatherTaglib used in the previous article and the SimpleTaglib module used here. SimpleTaglib calls My::SimpleWeatherTaglib&amp;rsquo;s &lt;code&gt;report()&lt;/code&gt; subroutine at compile time whereas TaglibHelper quietly, automatically arranges to call My::WeatherTaglib&amp;rsquo;s &lt;code&gt;report()&lt;/code&gt; subroutine at request time.&lt;/p&gt;

&lt;p&gt;This difference makes SimpleTaglib not so simple unless you are used to writing code that generates code that will be compiled and run later. On the other hand, &amp;ldquo;Programs that write programs are the happiest programs in the world&amp;rdquo; (Andrew Hume, according to a few places on the net). This is true here because we are able to return whatever code is appropriate for the task at hand. In this case, the code is so simple that we can return it directly. If the work to be done was more complicated, then we could also return a call to a subroutine of our own devising. So, while a good deal less simple than the approach taken by TaglibHelper, this approach does offer a bit more flexibility.&lt;/p&gt;

&lt;p&gt;SimpleTaglib&amp;rsquo;s author does promise that a new version of SimpleTaglib will offer the &amp;ldquo;call this subroutine at request time&amp;rdquo; API which I (and I suspect most others) would prefer most of the time.&lt;/p&gt;

&lt;p&gt;I will warn you that the documentation for SimpleTaglib does not stand on its own, so you need to have the source code for an example module or two to put it all together. Beyond the overly simple example presented here, the documentation refers you to a couple of others. Mind you, I&amp;rsquo;m casting stones while in my glass house here, because nobody has ever accused me of fully documenting my own modules.&lt;/p&gt;

&lt;p&gt;For reference, here is the &lt;code&gt;weather1.xsp&lt;/code&gt; from the previous article, which we are reusing verbatim for this example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;?xml-stylesheet href=&amp;quot;NULL&amp;quot;        type=&amp;quot;application/x-xsp&amp;quot;?&amp;gt;
    &amp;lt;?xml-stylesheet href=&amp;quot;weather.xsl&amp;quot; type=&amp;quot;text/xsl&amp;quot;?&amp;gt;
    &amp;lt;?xml-stylesheet href=&amp;quot;as_html.xsl&amp;quot; type=&amp;quot;text/xsl&amp;quot;?&amp;gt;

    &amp;lt;xsp:page
        xmlns:xsp=&amp;quot;http://www.apache.org/1999/XSP/Core&amp;quot;
        xmlns:util=&amp;quot;http://apache.org/xsp/util/v1&amp;quot;
        xmlns:param=&amp;quot;http://axkit.org/NS/xsp/param/v1&amp;quot;
        xmlns:weather=&amp;quot;http://slaysys.com/axkit_articles/weather/&amp;quot;
    &amp;gt;
    &amp;lt;data&amp;gt;
      &amp;lt;title&amp;gt;&amp;lt;a name=&amp;quot;title&amp;quot;/&amp;gt;My Weather Report&amp;lt;/title&amp;gt;
      &amp;lt;time&amp;gt;
        &amp;lt;util:time format=&amp;quot;%H:%M:%S&amp;quot; /&amp;gt;
      &amp;lt;/time&amp;gt;
      &amp;lt;weather&amp;gt;
        &amp;lt;weather:report&amp;gt;
          &amp;lt;!-- Get the ?zip=12345 from the URI and pass it
               to the weather:report tag as a parameter --&amp;gt;
          &amp;lt;weather:zip&amp;gt;&amp;lt;param:zip/&amp;gt;&amp;lt;/weather:zip&amp;gt;
        &amp;lt;/weather:report&amp;gt;
      &amp;lt;/weather&amp;gt;
    &amp;lt;/data&amp;gt;
    &amp;lt;/xsp:page&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The processing pipeline and intermediate files are also identical to those from the &lt;a href=&#34;http://localhost:1313/pub/2002/04/16/axkit.html&#34;&gt;previous article&lt;/a&gt;, so we won&amp;rsquo;t repeat them here. &lt;span id=&#34;MixingAndMatching&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&#34;mixing-and-matching-taglibs-using-httpd-conf&#34;&gt;Mixing and Matching Taglibs using &lt;code&gt;httpd.conf&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;As detailed in &lt;a href=&#34;http://localhost:1313/pub/2002/03/12/axkit.html&#34;&gt;the first article&lt;/a&gt; in this series, AxKit integrates tightly with Apache and Apache&amp;rsquo;s configuration engine. Apache allows different files and directories to have different configurations applied, including what taglibs are used. In the real world, for instance, it is sometimes necessary to have part of a site to use a new version of a taglib that might break an old portion.&lt;/p&gt;

&lt;p&gt;In the server I used to build the examples for this article, for instance, the &lt;code&gt;02/&lt;/code&gt; directory still uses My::WeatherTaglib from the last article, while the &lt;code&gt;03/&lt;/code&gt; directory uses the &lt;code&gt;my_weather_taglib.xsl&lt;/code&gt; for one of this article&amp;rsquo;s examples and My::SimpleWeatherTaglib for the other. This is done by combining Apache&amp;rsquo;s &lt;code&gt;&amp;lt;Directory&amp;gt;&lt;/code&gt; sections with the &lt;code&gt;AxAddXSPTaglib&lt;/code&gt; directive:&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;httpd.conf&#34;&gt;&lt;/span&gt;
        ##
        ## Init the httpd to use our &amp;ldquo;private install&amp;rdquo; libraries
        ##
        PerlRequire startup.pl&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ##
    ## AxKit Configuration
    ##
    PerlModule AxKit

    &amp;lt;Directory &amp;quot;/home/me/htdocs&amp;quot;&amp;gt;
        Options -All +Indexes +FollowSymLinks

        # Tell mod_dir to translate / to /index.xml or /index.xsp
        DirectoryIndex index.xml index.xsp
        AddHandler axkit .xml .xsp

        AxDebugLevel 10

        AxTraceIntermediate /home/me/axtrace

        AxGzipOutput Off

        AxAddXSPTaglib AxKit::XSP::Util
        AxAddXSPTaglib AxKit::XSP::Param

        AxAddStyleMap application/x-xsp \\
                      Apache::AxKit::Language::XSP

        AxAddStyleMap text/xsl \\
                      Apache::AxKit::Language::LibXSLT
    &amp;lt;/Directory&amp;gt;

    &amp;lt;Directory &amp;quot;/home/me/htdocs/02&amp;quot;&amp;gt;
        AxAddXSPTaglib My::WeatherTaglib
    &amp;lt;/Directory&amp;gt;

    &amp;lt;Directory &amp;quot;/home/me/htdocs/03&amp;quot;&amp;gt;
        AxAddXSPTaglib My::SimpleWeatherTaglib
    &amp;lt;/Directory&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See &lt;a href=&#34;http://httpd.apache.org/docs/current/sections.html&#34;&gt;How Directory, Location and Files sections work&lt;/a&gt; from the apache httpd documentation (v1.3 or 2.0) for the details of how to use &lt;a href=&#34;http://httpd.apache.org/docs/current/mod/core.html#directory&#34;&gt;&lt;code&gt;&amp;lt;Directory&amp;gt;&lt;/code&gt;&lt;/a&gt; and other httpd.conf sections to do this sort of thing.&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;help&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&#34;help-and-thanks&#34;&gt;Help and thanks&lt;/h3&gt;

&lt;p&gt;JÃ¶rg Walter as well as Matt Sergeant were of great help in writing this article, especially since I don&amp;rsquo;t do LogicSheets. JÃ¶rg also fixed a bug in absolutely no time and wrote the SimpleTaglib module and the &lt;code&gt;AxTraceIntermediate&lt;/code&gt; feature.&lt;/p&gt;

&lt;p&gt;In case of trouble, have a look at some of the &lt;a href=&#34;http://localhost:1313/pub/2002/03/12/axkit.html?page=3#help&#34;&gt;helpful resources we listed in the first article&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Copyright 2002, Robert Barrie Slaymaker, Jr. All Rights Reserved.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>XSP, Taglibs and Pipelines</title>
      <link>http://localhost:1313/pub/2002/04/16/axkit.html/</link>
      <pubDate>Tue, 16 Apr 2002 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2002/04/16/axkit.html/</guid>
      <description>

&lt;p&gt;In the &lt;a href=&#34;http://localhost:1313/pub/2002/03/12/axkit.html&#34;&gt;first article&lt;/a&gt; in this series, we saw how to install, configure and test AxKit, and we took a look at a simple processing pipeline. In this article, we will see how to write a simple 10-line XSP taglib and use it in a pipeline along with XSLT to build dynamic pages in such a way that gets the systems architects and coders out of the content maintenance business. Along the way, we&amp;rsquo;ll discuss &lt;a href=&#34;#why_pipelines&#34;&gt;the pipeline processing model&lt;/a&gt; that makes AxKit so powerful.&lt;/p&gt;

&lt;p&gt;First though, let us catch up on some changes in the AxKit world.&lt;/p&gt;

&lt;h3 id=&#34;changes&#34;&gt;CHANGES&lt;/h3&gt;

&lt;p&gt;Matt and company have released AxKit v1.5.1, and 1.5.2 looks as though it will be out soon. 1.5.1 provides a few improvements and bug fixes, especially in the XSP engine discussed in this article. The biggest additions are the inclusion of a set of demonstration pages that can be used to test and experiment with AxKit&amp;rsquo;s capabilities, and another module to help with writing taglibs (Jorge Walter&amp;rsquo;s &lt;a href=&#34;https://metacpan.org/pod/AxKit2::XSP::SimpleTaglib&#34;&gt;SimpleTaglib&lt;/a&gt;, which we&amp;rsquo;ll look at in the next article).&lt;/p&gt;

&lt;p&gt;There has also been a release policy change: The main AxKit distributions (AxKit-1.5.1.tar.gz for instance) will no longer contain the minimal set of prerequisites; these will now be bundled in a separate tarball. This policy change enables people to download just AxKit (when upgrading it, for instance) and recognizes the fact that AxKit is an &lt;a href=&#34;http://xml.apache.org/&#34;&gt;Apache project&lt;/a&gt; while the prerequisites aren&amp;rsquo;t. Until the prerequisite tarball gets released, the &lt;a href=&#34;http://localhost:1313/media/_pub_2002_04_16_axkit/axkit_articles-2.0.tar.gz&#34;&gt;source tarball&lt;/a&gt; that accompanies this article contains them all (though it installs them in a local directory only, for testing purposes). The main AxKit tarball still includes all the core AxKit modules.&lt;/p&gt;

&lt;h4 id=&#34;xsp-and-taglibs&#34;&gt;XSP and taglibs&lt;/h4&gt;

&lt;p&gt;We &lt;a href=&#34;http://localhost:1313/pub/2002/03/12/axkit.html?page=3&#34;&gt;touched on&lt;/a&gt; eXtensible Server Pages and taglibs in the last article; this time we&amp;rsquo;ll take a deeper look and try to see how &lt;a href=&#34;http://axkit.org/docs/xsp/index.xml&#34;&gt;XSP&lt;/a&gt;, taglibs and XSLT can be combined in a powerful and useful way.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A quick taglib refresher: A taglib is a collection of XML tags in an &lt;a href=&#34;http://www.jclark.com/xml/xmlns.htm&#34;&gt;XML namespace&lt;/a&gt; that act like conditionals or subroutine calls. Essentially, taglibs are a way of encoding logic and dynamic content in to pages without including raw &amp;ldquo;native&amp;rdquo; code (Perl, Java, COBOL; any of the popular Web programming languages) in the page; each taglib provides a set of related services and multiple taglibs may be used in the same XSP page.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For our example, we will build a &amp;ldquo;data driven&amp;rdquo; processing pipeline (clicking on a blue icon or arrow will take you to the relevant documentation or section of this article):&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;#&#34; id=&#34;weather1_flow.png&#34;&gt;&lt;/a&gt; &lt;img src=&#34;http://localhost:1313/images/_pub_2002_04_16_axkit/weather1_flow.png&#34; alt=&#34;weather1.xsp processing pipeline&#34; /&gt;
&amp;gt; &lt;img src=&#34;http://localhost:1313/images/_pub_2002_04_16_axkit/weather1_flow_icon.png&#34; alt=&#34;Example icon&#34; /&gt; NOTE: A little icon like this will be shown with the description of each piece of the pipeline with that piece hilighted. Clicking on those icons will bring you back to this diagram.&lt;/p&gt;

&lt;p&gt;This pipeline has five stages:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;the XSP document (&lt;a href=&#34;#weather1.xsp&#34;&gt;&lt;code&gt;weather1.xsp&lt;/code&gt;&lt;/a&gt;) defines what chunks of raw data (current time and weather readings) are needed for this page in a simple XML format,&lt;/li&gt;
&lt;li&gt;the XSP processor applies taglibs to assemble the raw data for the page,&lt;/li&gt;
&lt;li&gt;the first XSLT processor and stylesheet (&lt;a href=&#34;#weather.xsl&#34;&gt;&lt;code&gt;weather.xsl&lt;/code&gt;&lt;/a&gt;) format the raw data in to usable content,&lt;/li&gt;
&lt;li&gt;the second XSLT processor and stylesheet (&lt;a href=&#34;#as_html.xsl&#34;&gt;&lt;code&gt;as_html.xsl&lt;/code&gt;&lt;/a&gt;) lays out and generates the final page (&amp;ldquo;Result Doc&amp;rdquo;), and&lt;/li&gt;
&lt;li&gt;the Gzip compressor automatically compresses the output if the client can comprehend compressed content (even when an older browser is bashful and does not announce that it can cope with gzip-encoded content).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;span id=&#34;mimicry&#34;&gt;&lt;/span&gt;This multipass approach mimics those found in real applications; each stage has a specific purpose and can be designed and tested independently of the others.&lt;/p&gt;

&lt;p&gt;In a real application, there might well be more filters: Our second XSLT filter might be tweaked to build document without any &amp;ldquo;look and feel,&amp;rdquo; and an additional filter could be used to implement the &amp;ldquo;look and feel&amp;rdquo; of the presentation after the layout is complete. This would allow look and feel to be altered independently of the layout.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We call this a &amp;ldquo;data driven&amp;rdquo; pipeline because the document feeding the pipeline defines what data is needed to serve the page; it does not actually contain any content. Later stages add the content and format it. We&amp;rsquo;ll look at a &amp;ldquo;document driven&amp;rdquo; pipeline, which feeds the pipeline with the document to be served, in the next article.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span id=&#34;why_pipelines&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&#34;why-pipelines&#34;&gt;Why pipelines?&lt;/h4&gt;

&lt;p&gt;The XML pipeline-processing model used by AxKit is a powerful approach that brings technical and social advantages to document-processing systems lsuch as Web applications.&lt;/p&gt;

&lt;p&gt;On the social side, the concept of a pipeline or assembly line is simple enough to be taught to and grasped by nonprogrammers. Some of the approaches used by HTML-oriented tools (like many on CPAN) are not exactly designer-friendly: They rely on programmer-friendly concepts such as abstract data structures, miniature programming languages, &amp;ldquo;catch-all&amp;rdquo; pages and object-oriented techniques such as method dispatch. To be fair, some designers can and do learn the concepts, and others have Perl implementors who deploy these tools in simple patterns that are readily grasped.&lt;/p&gt;

&lt;p&gt;The reason that HTML-oriented tools have a hard time something as simple as a pipeline model is that HTML is a presentation language and does not lend itself to describing data structures or to incremental processing. The advantage of incremental processing is that the number of stages can be designed to fit the application and organization; with other tools, there&amp;rsquo;s often a one- or two-stage approach where the first stage is almost entirely in the realm of the Perl coders (&amp;ldquo;prepare thedata&amp;rdquo;) and the second is halfway in the realm of the coders and halfway in the designer&amp;rsquo;s realm.&lt;/p&gt;

&lt;p&gt;XML can be used both to describe data structures and mark up prose documents; this allows a pipeline to mingle data and prose in flexible ways. Each processing stage is XML-in, XML-out (except for the first and last, which often consume and generate other formats). However, the stages aren&amp;rsquo;t limited to dealing purely with XML: The taglibs we&amp;rsquo;re using show one way that stages can use Perl code (and, by extension, many other languages; see the &lt;a href=&#34;https://metacpan.org/search?q=Inline%3A%3A&#34;&gt;Inline&lt;/a&gt; series of modules), external libraries, and almost any non-XML data as needed. Not only does My::WeatherTaglib integrate with Perl code, it&amp;rsquo;s also requesting data over the Internet from a remote site.&lt;/p&gt;

&lt;p&gt;The use of XML as the carrier for data between the stages also allows each stage to be debugged and unit tested. The documents that forwarded between the stages are often passed as internal data structures instead of XML strings for efficiency&amp;rsquo;s sake, but they can be rendered (like the examples shown in this article) and examined, both for teaching purposes and debugging purposes. The uniform look and feel of XML, whatever it&amp;rsquo;s disadvantages, is at least readily understood by any competent Web designer.&lt;/p&gt;

&lt;p&gt;Pipelines are also handy mechanisms in that the individual stages are chosen at request time; different stages can be selected to deliver different views of the same content. AxKit provides several powerful mechanisms for configuring pipelines, the &lt;code&gt;&amp;lt;xml-stylesheet ...&amp;gt;&lt;/code&gt; approach used in this article is merely the simplest; future articles will explore building flexible pipelines.&lt;/p&gt;

&lt;p&gt;Pipelines also make a useful distinction between the manager (AxKit) and the processing technologies. Not only does this allow you to mix and match processing techniques as needed (AxKit ships with nine &amp;ldquo;Languages&amp;rdquo;, or types of XML processor, and several &amp;ldquo;Providers&amp;rdquo;, or data sources), it also allows new technologies to be incorporated in to existing sites when a new technology is needed.&lt;/p&gt;

&lt;p&gt;Moreover, technologies like XML and XSLT are standardized and are becoming widely accepted and supported. This means that most, if not all the documents in our example pipeline can be handed off to non-Perl coders without (much) fear of them mangling the code. When they do mangle it; tools such as xsltproc (shipped with libxslt, one of the AxKit XSLT processors) can be used to give the designers a first line of defense before calling in the programmers. Even taglibs, nonstandard though they are, leverage the XML standard to make logic and data available to noncoders in a (relatively) safe manner. For instance, &lt;a href=&#34;http://www.zvon.org/xxl/XSLTutorial/Output/index.html&#34;&gt;here&amp;rsquo;s an excellent online tutorial&lt;/a&gt; provided by &lt;a href=&#34;http://www.zvon.org/&#34;&gt;ZVON.org&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Mind you, XML and XSLT have their rough spots; the trick is that you don&amp;rsquo;t need to know all the quirky ins and outs of the XML specification or use XSLT for things that are painful to do in it. I mean, really, when was the last time you dealt with a &lt;a href=&#34;http://www.w3.org/TR/REC-xml/#Notations&#34;&gt;notation declaration&lt;/a&gt;? Most uses of XML use a small subset of the XML specification, and other tools such as XSP, XPathScript and various schema languages can be used where XSLT would only make the problem more difficult.&lt;/p&gt;

&lt;p&gt;What stages are appropriate depends on the application&amp;rsquo;s requirements and those of the organization(s) involved in building, operating and maintaining it. In the next article, we&amp;rsquo;ll examine a &amp;ldquo;document driven&amp;rdquo; pipeline and a taglib better suited for this approach that uses different stages.&lt;/p&gt;

&lt;p&gt;All that being said there will always be a place for the non-XML and non-pipelined solutions: XML and pipelines are &lt;em&gt;not&lt;/em&gt; panaceas. I still use other solutions when the applications or organizations I work with would not benefit from XML.&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;httpd.conf&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&#34;httpd-conf-the-axkit-configuration&#34;&gt;&lt;code&gt;httpd.conf&lt;/code&gt;: the AxKit configuration&lt;/h4&gt;

&lt;p&gt;Before we start in to the example code, let&amp;rsquo;s glance at the AxKit configuration. Feel free to &lt;a href=&#34;#My::WeatherTaglib&#34;&gt;skip ahead to the code&lt;/a&gt; if you like; otherwise, here&amp;rsquo;s the configuration we&amp;rsquo;ll use in &lt;code&gt;httpd.conf&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;httpd.conf2&#34;&gt;&lt;/span&gt;
        ##
        ## Init the httpd to use our &amp;ldquo;private install&amp;rdquo; libraries
        ##
        PerlRequire startup.pl&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ##
    ## AxKit Configuration
    ##
    PerlModule AxKit

    &amp;lt;Directory /home/me/htdocs&amp;quot;&amp;gt;
            Options -All +Indexes +FollowSymLinks

        # Tell mod_dir to translate / to /index.xml or /index.xsp
        DirectoryIndex index.xml index.xsp
        AddHandler axkit .xml .xsp

        AxDebugLevel 10

        AxGzipOutput Off

        AxAddXSPTaglib AxKit::XSP::Util
        AxAddXSPTaglib AxKit::XSP::Param
        AxAddXSPTaglib My::WeatherTaglib

        AxAddStyleMap application/x-xsp
                      Apache::AxKit::Language::XSP

        AxAddStyleMap text/xsl
                      Apache::AxKit::Language::LibXSLT
    &amp;lt;/Directory&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the same configuration from the &lt;a href=&#34;http://localhost:1313/pub/2002/03/12/axkit.html?page=2#testing&#34;&gt;the last article&lt;/a&gt;âmost of the directives and the processing model used by Apache and AxKit for them are described in detail there. The two directives in &lt;strong&gt;bold&lt;/strong&gt; have been added. The key directives for our example are &lt;code&gt;AxAddXSPTaglib&lt;/code&gt; and &lt;code&gt;AxAddStyleMap&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;AxAddXSPTaglib&lt;/code&gt; directives load three tag libraries: Kip Hampton&amp;rsquo;s &lt;a href=&#34;https://metacpan.org/pod/AxKit::XS::Util&#34;&gt;Util&lt;/a&gt; and &lt;a href=&#34;https://metacpan.org/pod/AxKit::XSP::Param&#34;&gt;Param&lt;/a&gt; taglibs and our very own &lt;a href=&#34;#My::WeatherTaglib&#34;&gt;WeatherTaglib&lt;/a&gt;. Util will allow our example to get at the system time; Param will allow it to parse URLs; and WeatherTaglib will allow us to fetch the current weather conditions for that zip code.&lt;/p&gt;

&lt;p&gt;The two &lt;code&gt;AxAddStyleMap&lt;/code&gt; directives map a pair of mime types to an XSP and an XSLT processor. Our example source document will refer to these mime types to configure instances of XSP and XSLT processors in to the processing pipeline.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We&amp;rsquo;re using Apache::AxKit::Language::LibXSLT to perform XSLT transforms, which uses the GNOME project&amp;rsquo;s &lt;a href=&#34;http://xmlsoft.org/XSLT/&#34;&gt;libxslt&lt;/a&gt; library under the hood. Different XSLT engines offer different sets of features. If you prefer, then you can also use Apache::AxKit::Language::Sablot for XSLT work. You can even use them in the same pipeline by assigning them to different mime types.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span id=&#34;My::WeatherTaglib&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&#34;a-href-weather1-flow-png-id-weather1-flow-weather-taglib-png-img-src-images-pub-2002-04-16-axkit-weather1-flow-weather-taglib-png-alt-my-weathertaglib-39-s-position-in-the-weather1-xsp-processing-pipeline-a-my-weathertaglib&#34;&gt;&lt;a href=&#34;#weather1_flow.png&#34; id=&#34;weather1_flow_weather_taglib.png&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2002_04_16_axkit/weather1_flow_weather_taglib.png&#34; alt=&#34;My::WeatherTaglib&amp;#39;s position in the weather1.xsp processing pipeline&#34; /&gt;&lt;/a&gt; My::WeatherTaglib&lt;/h4&gt;

&lt;p&gt;Here&amp;rsquo;s a taglib that uses &lt;a href=&#34;https://metacpan.org/pod/Geo::Weather&#34;&gt;Geo::Weather&lt;/a&gt; module on CPAN to take a zip code and fetch some weather observations from &lt;a href=&#34;https://weather.com/&#34;&gt;weather.com&lt;/a&gt; and convert them to XML:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package My::WeatherTaglib;

    $NS = &amp;quot;http://slaysys.com/axkit_articles/weather/&amp;quot;;
    @EXPORT_TAGLIB = ( &#39;report($zip)&#39; );

    use strict;
    use Apache::AxKit::Language::XSP::TaglibHelper;
    use Geo::Weather;

    sub report { Geo::Weather-&amp;gt;new-&amp;gt;get_weather( @_ ) }

    1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This taglib uses Steve Willer&amp;rsquo;s &lt;a href=&#34;https://metacpan.org/pod/Apache::AxKit::Language::XSP::TaglibHelper&#34;&gt;TaglibHelper&lt;/a&gt; (included with AxKit) to automate the drudgery of dealing with XML. Because of this, our example taglib distills a lot of power into a few lines of Perl. Don&amp;rsquo;t be fooled, though, there&amp;rsquo;s a lot going on behind the curtains with this module.&lt;/p&gt;

&lt;p&gt;When a tag like &lt;code&gt;&amp;lt;weather:report zip=&amp;quot;15206&amp;quot;/&amp;gt;&lt;/code&gt; is encountered in an XSP page, it will be translated into a call to &lt;code&gt;report( &amp;quot;15206&amp;quot; )&lt;/code&gt;, the result of the call will be converted to XML and will replace the original tag in the XSP output document.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;$NS&lt;/code&gt; variable sets the &lt;a href=&#34;http://www.jclark.com/xml/xmlns.htm&#34;&gt;namespace URI&lt;/a&gt; for the taglib; this configures XSP to direct all elements within the namespace &lt;code&gt;http://slaysys.com/axkit_articles/weather/&lt;/code&gt; to My::WeatherTaglib, as we&amp;rsquo;ll see in a bit.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;When used in an XSP page, all XML elements supplied by a taglib will have a namespace prefix. For instance, the prefix &lt;code&gt;weather:&lt;/code&gt; is mapped to My::WeatherTaglib&amp;rsquo;s namespace in the XSP page below. This prefix is not determined by the taglib&amp;8212;we could have chosen another; this section assumes that the prefix &lt;code&gt;weather:&lt;/code&gt; is used for the sake of clarity.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The &lt;code&gt;@EXPORT_TAGLIB&lt;/code&gt; specifies what functions will be exported as elements in this namespace and what parameters they accept (see &lt;a href=&#34;https://metacpan.org/pod/Apache::AxKit::Language::XSP::TaglibHelper&#34;&gt;the documentation&lt;/a&gt; for details). The &lt;code&gt;report($zip)&lt;/code&gt; export specification exports a tag that is invoked like &lt;code&gt;&amp;lt;weather:report zip=&amp;quot;...&amp;quot;/&amp;gt;&lt;/code&gt; or&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;weather:report&amp;gt;
        &amp;lt;weather:zip&amp;gt;15206&amp;lt;/weather:zip&amp;gt;
    &amp;lt;/weather:report&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The words &amp;ldquo;report&amp;rdquo; and &amp;ldquo;zip&amp;rdquo; in the &lt;code&gt;@TAGLIB_EXPORT&lt;/code&gt; definition are used to determine the taglib element and attribute names; the order of the parameters in the definition determines the order they are passed in to the function. When invoking a taglib, the XML may specify the parameters in any order in the XML. The names they are specified with are not important to or visible from the Perl code by default (see the &lt;a href=&#34;https://metacpan.org/pod/Apache::AxKit::Language::XSP::TaglibHelper&#34;&gt;*argument function specification&lt;/a&gt; for how to accept an XML tree if need be).&lt;/p&gt;

&lt;p&gt;All that&amp;rsquo;s left for us to do is to write the &amp;ldquo;body&amp;rdquo; of the taglib by &lt;code&gt;use()&lt;/code&gt;ing &lt;code&gt;Geo::Weather&lt;/code&gt; and writing the &lt;code&gt;report()&lt;/code&gt; subroutine.&lt;/p&gt;

&lt;p&gt;There are two major conveniences provided by TaglibHelper. The first is welding Perl subroutines to XML tags (via the &lt;code&gt;@EXPORT_TAGLIB&lt;/code&gt; definitions). The second is converting the Perl data structure returned by &lt;code&gt;report()&lt;/code&gt;, a hash reference like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    {
      city  =&amp;gt; &amp;quot;Pittsburgh&amp;quot;,
      state =&amp;gt; &amp;quot;PA&amp;quot;,
      cond  =&amp;gt; &amp;quot;Sunny&amp;quot;,
      temp  =&amp;gt; 76,
      pic   =&amp;gt; &amp;quot;http://image.weather.com/web/common/wxicons/52/26.gif&amp;quot;,
      url   =&amp;gt; &amp;quot;http://www.weather.com/search/search?where=15206&amp;quot;,
      ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in to &lt;a href=&#34;http://www.w3.org/TR/xml-fragment#defn-well-balanced&#34;&gt;well balanced&lt;/a&gt; XML like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      &amp;lt;city&amp;gt;Pittsburgh&amp;lt;/city&amp;gt;
      &amp;lt;state&amp;gt;PA&amp;lt;/state&amp;gt;
      &amp;lt;cond&amp;gt;Sunny&amp;lt;/cond&amp;gt;
      &amp;lt;temp&amp;gt;76&amp;lt;/temp&amp;gt;
      &amp;lt;pic&amp;gt;http://image.weather.com/web/common/wxicons/52/26.gif&amp;lt;/pic&amp;gt;
      &amp;lt;url&amp;gt;http://www.weather.com/search/search?where=15206&amp;lt;/url&amp;gt;
      ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TaglibHelper allows plain strings, data structures and strings of well-balanced XML to be returned. By writing a single one-line subroutine that returns a Perl data structure, we&amp;rsquo;ve written a taglib that requires no Perl expertise to use (any XHTML jock could use it safely using their favorite XML, HTML or text editor) and that can be used to serve up &amp;ldquo;data&amp;rdquo; responses for XML-RPC-like applications or &amp;ldquo;text&amp;rdquo; documents for human consumption.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;a href=&#34;https://metacpan.org/pod/Data::Dumper&#34;&gt;Data::Dumper&lt;/a&gt; module that ships with Perl is a good way to peer inside the data structures floating around in a request. Wehn run in AxKit, a quick &lt;code&gt;warn Dumper( $foo );&lt;/code&gt; will dump the data structure referred to by &lt;code&gt;$foo&lt;/code&gt; to the Apache error log.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The output XML from a taglib replaces the orignal tag in the result document. In our case, the replacement XML is not too useful as-is, it&amp;rsquo;s just data that looks a bit XMLish. Representing data structures as XML may seem awkward to Perl gurus, but it&amp;rsquo;s quite helpful if you want to get the Perl code safely out of the way and allow others to use XML tools to work with the data.&lt;/p&gt;

&lt;p&gt;The &amp;ldquo;data documents&amp;rdquo; from our XSP processor will upgraded in later processing stages to content that is presentable to the client; our XSP page neither knows nor cares how it is to be presented. Exporting the raw data as XML here is intended to show how to get the Perl gurus out of the critical path for content development by allowing site designers and content authors to do it.&lt;/p&gt;

&lt;p&gt;Emitting structured data from XSP pages is just one approach. Taglibs can return whatever the &amp;ldquo;best fit&amp;rdquo; is for a given application, whether that be raw data, pieces of content or an entire article.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://cocoon.apache.org/&#34;&gt;Cocoon&lt;/a&gt;, the system AxKit was primarily inspired by, uses a different approach to writing taglibs. AxKit also supports that approach, but it tends to be more awkward, so it will be examined in the next article. We&amp;rsquo;ll also look at Jorge Walter&amp;rsquo;s new &lt;a href=&#34;https://metacpan.org/pod/Apache::AxKit::Language::XSP::SimpleTaglib&#34;&gt;SimpleTaglib&lt;/a&gt; module then, which is newer and more flexible, but less portable than the TaglibHelper module we&amp;rsquo;re looking at here.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span id=&#34;weather1.xsp&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&#34;a-href-weather1-flow-png-id-weather1-flow-weather-xsp-png-img-src-images-pub-2002-04-16-axkit-weather1-flow-weather-xsp-png-alt-my-weathertaglib-39-s-position-in-the-weather1-xsp-processing-pipeline-a-weather1-xsp-using-my-weathertaglib&#34;&gt;&lt;a href=&#34;#weather1_flow.png&#34; id=&#34;weather1_flow_weather_xsp.png&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2002_04_16_axkit/weather1_flow_weather_xsp.png&#34; alt=&#34;My::WeatherTaglib&amp;#39;s position in the weather1.xsp processing pipeline&#34; /&gt;&lt;/a&gt; &lt;code&gt;weather1.xsp&lt;/code&gt;: Using My::WeatherTaglib&lt;/h4&gt;

&lt;p&gt;Here&amp;rsquo;s a page (&lt;code&gt;weather1.xsp&lt;/code&gt;) that uses the My::WeatherTaglib and the &amp;ldquo;standard&amp;rdquo; XSP &lt;a href=&#34;https://metacpan.org/pod/AxKit::XSP::Util&#34;&gt;util taglib&lt;/a&gt; we used in the previous article:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;?xml-stylesheet href=&amp;quot;NULL&amp;quot;        type=&amp;quot;application/x-xsp&amp;quot;?&amp;gt;
    &amp;lt;?xml-stylesheet href=&amp;quot;weather.xsl&amp;quot; type=&amp;quot;text/xsl&amp;quot;         ?&amp;gt;
    &amp;lt;?xml-stylesheet href=&amp;quot;as_html.xsl&amp;quot; type=&amp;quot;text/xsl&amp;quot;         ?&amp;gt;

    &amp;lt;xsp:page
        xmlns:xsp=&amp;quot;http://www.apache.org/1999/XSP/Core&amp;quot;
        xmlns:util=&amp;quot;http://apache.org/xsp/util/v1&amp;quot;
        xmlns:param=&amp;quot;http://axkit.org/NS/xsp/param/v1&amp;quot;
        xmlns:weather=&amp;quot;http://slaysys.com/axkit_articles/weather/&amp;quot;
    &amp;gt;
    &amp;lt;data&amp;gt;
      &amp;lt;title&amp;gt;&amp;lt;a name=&amp;quot;title&amp;quot;/&amp;gt;My weather report&amp;lt;/title&amp;gt;
      &amp;lt;time&amp;gt;
        &amp;lt;util:time format=&amp;quot;%H:%M:%S&amp;quot; /&amp;gt;
      &amp;lt;/time&amp;gt;
      &amp;lt;weather&amp;gt;
        &amp;lt;weather:report&amp;gt;
          &amp;lt;!-- Get the ?zip=12345 from the URI and pass it
               to the weather:report tag as a parameter --&amp;gt;
          &amp;lt;weather:zip&amp;gt;&amp;lt;param:zip/&amp;gt;&amp;lt;/weather:zip&amp;gt;
        &amp;lt;/weather:report&amp;gt;
      &amp;lt;/weather&amp;gt;

    &amp;lt;/data&amp;gt;
    &amp;lt;/xsp:page&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When &lt;code&gt;weather1.xsp&lt;/code&gt; is requested, AxKit parses the &lt;code&gt;&amp;lt;?xml-stylesheet ...?&amp;gt;&lt;/code&gt; processing instructions and uses the &lt;code&gt;AxAddStyleMap&lt;/code&gt; directives to build the processing chain &lt;a href=&#34;#weather1_flow.png&#34;&gt;shown above&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;#weather1_flow.png&#34; id=&#34;weather1_flow_XSP.png&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2002_04_16_axkit/weather1_flow_XSP.png&#34; alt=&#34;My::WeatherTaglib&amp;#39;s position in the weather1.xsp processing pipeline&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The XSP processor is the first processor in the pipeline. As it parses the page, it sends all elements with &lt;code&gt;util:&lt;/code&gt;, &lt;code&gt;param:&lt;/code&gt; or &lt;code&gt;weather:&lt;/code&gt; prefixes to the &lt;a href=&#34;https://metacpan.org/pod/AxKit::XSP::Util&#34;&gt;Util&lt;/a&gt;, &lt;a href=&#34;https://metacpan.org/pod/AxKit::XSP::Param&#34;&gt;Param&lt;/a&gt;, and &lt;a href=&#34;#My::WeatherTaglib&#34;&gt;WeatherTaglib&lt;/a&gt; taglibs. This mapping is defined by the &lt;code&gt;xmlns:...&lt;/code&gt; attributes and by the namespace URIs that are hardcoded into each taglib&amp;rsquo;s implementation (see the &lt;code&gt;$NS&lt;/code&gt; variable in &lt;a href=&#34;#My::WeatherTaglib&#34;&gt;My::WeatherTaglib&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;In this page, the &lt;code&gt;&amp;lt;util:time&amp;gt;&lt;/code&gt; element results in a call to Util&amp;rsquo;s &lt;code&gt;get_date()&lt;/code&gt; and the value of the &lt;code&gt;format=&lt;/code&gt; attribute is passed in as a parameter. The string returned by &lt;code&gt;get_date()&lt;/code&gt; is converted to XML and emitted instead of the &lt;code&gt;&amp;lt;util:time&amp;gt;&lt;/code&gt; element in the output page. This shows how to pass simple constant parameters to a taglib.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re getting slightly trickier with the &lt;code&gt;&amp;lt;weather:report&amp;gt;&lt;/code&gt; element: This construct fetches the zip parameter from the request URI&amp;rsquo;s query string (or form field) and passes it to WeatherTaglib&amp;rsquo;s &lt;code&gt;report()&lt;/code&gt; as the &lt;code&gt;$zip&lt;/code&gt; parameter. Thanks to Kip Hampton for the help in using AxKit::XSP::Param in this manner.&lt;/p&gt;

&lt;p&gt;Because we have the &lt;code&gt;AxDebugLevel&lt;/code&gt; set to &lt;code&gt;10&lt;/code&gt;, you can see these calls the compiled version of &lt;code&gt;weather1.xsp&lt;/code&gt;; the generated Perl code is written to Apache&amp;rsquo;s error logâusually &lt;code&gt;$SERVER_ROOT/logs/error_log&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;&amp;lt;a name=&amp;quot;title&amp;quot;/&amp;gt;&lt;/code&gt; in the &lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; element is a contrivance put in this page to show off a feature later in the processing chain. Be glad it&amp;rsquo;s not the dreaded &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tag!&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;XSP_out&#34;&gt;&lt;/span&gt;&lt;a href=&#34;#weather1_flow.png&#34; id=&#34;weather1_flow_XSP_out.png&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2002_04_16_axkit/weather1_flow_XSP_out.png&#34; alt=&#34;My::WeatherTaglib&amp;#39;s position in the weather1.xsp processing pipeline&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The XML document that is outputted from the XSP processor and fed to the first XSLT processor looks like (taglib output in &lt;strong&gt;bold&lt;/strong&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
    &amp;lt;data&amp;gt;
      &amp;lt;title&amp;gt;&amp;lt;a name=&amp;quot;title&amp;quot;/&amp;gt;My weather report&amp;lt;/title&amp;gt;
      &amp;lt;time&amp;gt;16:11:55&amp;lt;/time&amp;gt;
      &amp;lt;weather&amp;gt;
        &amp;lt;state&amp;gt;PA&amp;lt;/state&amp;gt;
        &amp;lt;heat&amp;gt;N/A&amp;lt;/heat&amp;gt;
        &amp;lt;page&amp;gt;/search/search?where=15206&amp;lt;/page&amp;gt;
        &amp;lt;wind&amp;gt;From the Southwest at 10&amp;lt;/wind&amp;gt;
        &amp;lt;city&amp;gt;Pittsburgh&amp;lt;/city&amp;gt;
        &amp;lt;temp&amp;gt;76&amp;lt;/temp&amp;gt;
        &amp;lt;cond&amp;gt;Sunny&amp;lt;/cond&amp;gt;
        &amp;lt;uv&amp;gt;2&amp;lt;/uv&amp;gt;
        &amp;lt;visb&amp;gt;Unlimited&amp;lt;/visb&amp;gt;
        &amp;lt;url&amp;gt;http://www.weather.com/search/search?where=15206&amp;lt;/url&amp;gt;
        &amp;lt;dewp&amp;gt;53&amp;lt;/dewp&amp;gt;
        &amp;lt;zip&amp;gt;15206&amp;lt;/zip&amp;gt;
        &amp;lt;baro&amp;gt;29.75&amp;lt;/baro&amp;gt;
        &amp;lt;pic&amp;gt;http://image.weather.com/web/common/wxicons/52/26.gif&amp;lt;/pic&amp;gt;
        &amp;lt;humi&amp;gt;31&amp;lt;/humi&amp;gt;
      &amp;lt;/weather&amp;gt;
    &amp;lt;/data&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This data is largely presentation-neutralâkindly overlook the U.S. centric temperature scaleâit can be styled as needed.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;To generate this intermediate document, just commenting out all but the first &lt;code&gt;&amp;lt;?xml-stylesheet ... ?&amp;gt;&lt;/code&gt; processing instruction and request the page like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $ lynx -source localhost:8080/02/weather1.xsp?zip=15206 | xmllint --format -
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;xmllint&lt;/code&gt; is installed with the GNOMDE &lt;code&gt;libxsml&lt;/code&gt; library used by various parts of AxKit.&lt;/p&gt;

&lt;p&gt;When we cover how to build pipelines in more dynamic ways than using these stodgy old xml-stylesheet PIs, those techniques can be used to allow intermediate documents to be shown by varying the request URI.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;span-id-weather-xsl-span-a-href-weather1-flow-png-id-weather1-flow-weather-xsl-png-img-src-images-pub-2002-04-16-axkit-weather1-flow-weather-xsl-png-alt-my-weathertaglib-39-s-position-in-the-weather1-xsp-processing-pipeline-a-weather-xsl-converting-data-to-content&#34;&gt;&lt;span id=&#34;weather.xsl&#34;&gt;&lt;/span&gt;&lt;a href=&#34;#weather1_flow.png&#34; id=&#34;weather1_flow_weather_xsl.png&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2002_04_16_axkit/weather1_flow_weather_xsl.png&#34; alt=&#34;My::WeatherTaglib&amp;#39;s position in the weather1.xsp processing pipeline&#34; /&gt;&lt;/a&gt; &lt;code&gt;weather.xsl&lt;/code&gt;: Converting Data to Content&lt;/h4&gt;

&lt;p&gt;Here&amp;rsquo;s how we can convert the data document emitted by the XSP processor into more human-readable text. As described &lt;a href=&#34;#mimicry&#34;&gt;above&lt;/a&gt;, we&amp;rsquo;re taking a two-step approach to simulate a &amp;ldquo;real-world&amp;rdquo; scenario of turning our data into chunks of content in one (reusable) step and then laying the HTML out in a second step.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;weather.xsl&lt;/code&gt; is an XSLT stylesheet that uses several templates to convert the XSP output in to something more readable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;xsl:stylesheet
      version=&amp;quot;1.0&amp;quot;
      xmlns:xsl=&amp;quot;http://www.w3.org/1999/XSL/Transform&amp;quot;
    &amp;gt;

    &amp;lt;xsl:template match=&amp;quot;/data/time&amp;quot;&amp;gt;
      &amp;lt;time&amp;gt;Hi! It&#39;s &amp;lt;xsl:value-of select=&amp;quot;/data/time&amp;quot; /&amp;gt;&amp;lt;/time&amp;gt;
    &amp;lt;/xsl:template&amp;gt;

    &amp;lt;xsl:template match=&amp;quot;/data/weather&amp;quot;&amp;gt;
      &amp;lt;weather&amp;gt;The weather in
        &amp;lt;xsl:value-of select=&amp;quot;/data/weather/city&amp;quot; /&amp;gt;,
        &amp;lt;xsl:value-of select=&amp;quot;/data/weather/state&amp;quot;/&amp;gt; is
        &amp;lt;xsl:value-of select=&amp;quot;/data/weather/cond&amp;quot; /&amp;gt; and
        &amp;lt;xsl:value-of select=&amp;quot;/data/weather/temp&amp;quot; /&amp;gt;F
        (courtesy of &amp;lt;a href=&amp;quot;{/data/weather/url}&amp;quot;&amp;gt;The
        Weather Channel&amp;lt;/a&amp;gt;).
      &amp;lt;/weather&amp;gt;
    &amp;lt;/xsl:template&amp;gt;

    &amp;lt;xsl:template match=&amp;quot;@*|node()&amp;quot;&amp;gt;
      &amp;lt;!-- Copy the rest of the doc verbatim --&amp;gt;
      &amp;lt;xsl:copy&amp;gt;
        &amp;lt;xsl:apply-templates select=&amp;quot;@*|node()&amp;quot;/&amp;gt;
      &amp;lt;/xsl:copy&amp;gt;
    &amp;lt;/xsl:template&amp;gt;

    &amp;lt;/xsl:stylesheet&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;#weather1_flow.png&#34; id=&#34;weather1_flow_XSLT1.png&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2002_04_16_axkit/weather1_flow_XSLT1.png&#34; alt=&#34;My::WeatherTaglib&amp;#39;s position in the weather1.xsp processing pipeline&#34; /&gt;&lt;/a&gt; This is applied by the first XSLT processor in the pipeline.&lt;/p&gt;

&lt;p&gt;The interesting thing here is that we are using &lt;em&gt;two&lt;/em&gt; templates (shown in bold) to process different bits of the source XML. These templates &amp;ldquo;blurbify&amp;rdquo; the time and weather data in to presentable chunks and, as a side-effect, throw away unused data from the weather report.&lt;/p&gt;

&lt;p&gt;The third template just passes the rest through (XSLT has some annoying qualities, one of which is that it takes a complex bit of code to simple pass things through &amp;ldquo;as is&amp;rdquo;). However, this is boilerplate&amp;8212;right from the XSLT specification, in fact&amp;8212;and need not interfere with designers creating the two templates we actually want in this stylesheet.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Another annoying quality is that XSLT contructs look visually similar to the templates themselves. This violates the language design principle &amp;ldquo;different things should look different,&amp;rdquo; which is used in Perl and many other languages. This can be ameliorated by using an XSLT-aware editor or syntax hilighting to make the differences between XSLT statements and &amp;ldquo;payload&amp;rdquo; XML clear.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span id=&#34;XSLT1_out&#34;&gt;&lt;/span&gt;&lt;a href=&#34;#weather1_flow.png&#34; id=&#34;weather1_flow_XSLT1_out.png&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2002_04_16_axkit/weather1_flow_XSLT1_out.png&#34; alt=&#34;My::WeatherTaglib&amp;#39;s position in the weather1.xsp processing pipeline&#34; /&gt;&lt;/a&gt; The output from the first XSLT processor looks like (template output in &lt;strong&gt;bold&lt;/strong&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;
    &amp;lt;data&amp;gt;
      &amp;lt;title&amp;gt;&amp;lt;a name=&amp;quot;title&amp;quot;/&amp;gt;My weather report&amp;lt;/title&amp;gt;
      &amp;lt;time&amp;gt;Hi! It&#39;s 16:50:36&amp;lt;/time&amp;gt;
      &amp;lt;weather&amp;gt;The weather in
        Pittsburgh,
        PA is
        Sunny and
        76F
        (courtesy of &amp;lt;a href=&amp;quot;http://www.weather.com/search/search?where=15206&amp;quot;&amp;gt;The
        Weather Channel&amp;lt;/a&amp;gt;)
      &amp;lt;/weather&amp;gt;
    &amp;lt;/data&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have a set of chunks that can be placed on a Web page. This technique can be used to build sidebars, newspaper headlines, abstracts, contact lists, navigation cues, links, menus, etc., in a reusable fashion.&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;as_html.xsl&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&#34;a-href-weather1-flow-png-id-weather1-flow-as-html-xsl-png-img-src-images-pub-2002-04-16-axkit-weather1-flow-as-html-xsl-png-alt-my-weathertaglib-39-s-position-in-the-weather1-xsp-processing-pipeline-a-as-html-xsl-laying-out-the-page&#34;&gt;&lt;a href=&#34;#weather1_flow.png&#34; id=&#34;weather1_flow_as_html_xsl.png&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2002_04_16_axkit/weather1_flow_as_html_xsl.png&#34; alt=&#34;My::WeatherTaglib&amp;#39;s position in the weather1.xsp processing pipeline&#34; /&gt;&lt;/a&gt; &lt;code&gt;as_html.xsl&lt;/code&gt;: Laying out the page&lt;/h4&gt;

&lt;p&gt;The final step in this example is to insert the chunks we&amp;rsquo;ve built into a page of HTML using the &lt;code&gt;as_html.xsl&lt;/code&gt;stylesheet:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;xsl:stylesheet
        xmlns:xsl=&amp;quot;http://www.w3.org/1999/XSL/Transform&amp;quot;
        version=&amp;quot;1.0&amp;quot;&amp;gt;

    &amp;lt;xsl:output method=&amp;quot;html&amp;quot; /&amp;gt;

    &amp;lt;xsl:template match=&amp;quot;/&amp;quot;&amp;gt;
      &amp;lt;html&amp;gt;
        &amp;lt;head&amp;gt;
          &amp;lt;title&amp;gt;&amp;lt;xsl:value-of select=&amp;quot;/data/title&amp;quot; /&amp;gt;&amp;lt;/title&amp;gt;
        &amp;lt;/head&amp;gt;
        &amp;lt;body&amp;gt;
          &amp;lt;h1&amp;gt;&amp;lt;xsl:copy-of select=&amp;quot;/data/title/node()&amp;quot;   /&amp;gt;&amp;lt;/h1&amp;gt;
          &amp;lt;p &amp;gt;&amp;lt;xsl:copy-of select=&amp;quot;/data/time/node()&amp;quot;    /&amp;gt;&amp;lt;/p&amp;gt;
          &amp;lt;p &amp;gt;&amp;lt;xsl:copy-of select=&amp;quot;/data/weather/node()&amp;quot; /&amp;gt;&amp;lt;/p&amp;gt;
        &amp;lt;/body&amp;gt;
      &amp;lt;/html&amp;gt;
    &amp;lt;/xsl:template&amp;gt;

    &amp;lt;/xsl:stylesheet&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span id=&#34;result_doc&#34;&gt;&lt;/span&gt; &lt;a href=&#34;#weather1_flow.png&#34; id=&#34;weather1_flow_result_doc.png&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2002_04_16_axkit/weather1_flow_result_doc.png&#34; alt=&#34;My::WeatherTaglib&amp;#39;s position in the weather1.xsp processing pipeline&#34; /&gt;&lt;/a&gt; To generate the final HTML:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
    &amp;lt;meta content=&amp;quot;text/html; charset=UTF-8&amp;quot; http-equiv=&amp;quot;Content-Type&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;My weather report&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;&amp;lt;a name=&amp;quot;title&amp;quot;/&amp;gt;My weather report&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;Hi! It&#39;s 17:05:08&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;The weather in
        Pittsburgh,
        PA is
        Sunny and
        76F
        (courtesy of &amp;lt;a href=&amp;quot;http://www.weather.com/search/search?where=15206&amp;quot;&amp;gt;The
        Weather Channel&amp;lt;/a&amp;gt;).
    &amp;lt;/p&amp;gt;
    &amp;lt;/body&amp;gt;
    &amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using the &lt;code&gt;/data/title&lt;/code&gt; from the data document in two places in the result document is a minor example of the benefit of separating the original data generation from the final presentation. In the &lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; element, we&amp;rsquo;re using &lt;code&gt;xsl:value-of&lt;/code&gt;, which returns just the textual content; in the &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; element, we&amp;rsquo;re using &lt;code&gt;xsl:copy-of&lt;/code&gt;, which copies the tags and the text. This allows the title to contain markup that we strip in one place and use in another.&lt;/p&gt;

&lt;p&gt;This is similar to the situation often found in real applications where things like menus, buttons, location tell-tales (&amp;ldquo;Home &amp;gt;&amp;gt; Articles &amp;gt;&amp;gt; Foo&amp;rdquo; and the like) and links to related pages often occur in multiple places. Widgets like these make ideal &amp;ldquo;chunks&amp;rdquo; that the layout page can place as needed.&lt;/p&gt;

&lt;p&gt;This is only one example of a &amp;ldquo;final rendering&amp;rdquo; stage; different filters could be used instead to deliver different formats. For instance, we could use XSLT to deliver XML, XHTML, and/or plain text versions, or we could use an AxKit-specific processor, XPathScript, to convert to things like RTF, nroff, and miscellaneous documentation formats that XML would otherwise have a hard time delivering.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;AxKit optimizes this two-stage XSLT processing by passing the internal representation used by &lt;code&gt;libxslt&lt;/code&gt; directly between the two stages. This means that output from one stage goes directly to the next stage without having to be reparsed.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span id=&#34;real_world&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&#34;relating-weather1-xsp-to-the-real-world&#34;&gt;Relating &lt;code&gt;weather1.xsp&lt;/code&gt; to the real world&lt;/h4&gt;

&lt;p&gt;If you squint a little at the code in My::WeatherTaglib, then you can imagine using a &lt;a href=&#34;https://metacpan.org/pod/DBI&#34;&gt;DBI&lt;/a&gt; query instead of having Geo::Weather query a remote Web site (Geo::Weather is used instead of DBI in this article to keep the example code and tarball relatively simple).&lt;/p&gt;

&lt;p&gt;Writing queries and other business logic in to taglibs has several major advantages:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the XML taglib API puts a designer friendly face on the queries, allowing the XSP page to be tweaked or maintained by non-Perl literate folks with their preferred tools, hopefully getting you off the &amp;ldquo;please tweak the query parms&amp;rdquo; critical path.&lt;/li&gt;
&lt;li&gt;Since the taglib API is XML, standard XML editors will catch basic syntax errors without needing to call in the taglib maintainer.&lt;/li&gt;
&lt;li&gt;Schema validators and XSLT tools can also be used to allow the designers to check the higher-level syntax before pestering the taglib maintainer.&lt;/li&gt;
&lt;li&gt;The query parameters and output can be touched up with Perl, making the &amp;ldquo;high level&amp;rdquo; XML interface simpler and more idiot-proof.&lt;/li&gt;
&lt;li&gt;The output is XML, so other XML processors can be used to enhance the content and style. This allows, for instance, XSLT literate designers to work on the presentation without needing to learn or even see (and possibly corrupt) any Perl code or a new language (as is required with most HTML templating solutions).&lt;/li&gt;
&lt;li&gt;It&amp;rsquo;s quite difficult to accidently generate malformed XML using XSP: a well-formed XSP usually generates well-formed output.&lt;/li&gt;
&lt;li&gt;The queries are decoupled from the source XML, so they can be maintained without touching the XSP pages.&lt;/li&gt;
&lt;li&gt;The taglibs can be unit tested, unlike embedded code.&lt;/li&gt;
&lt;li&gt;Taglibs can be wrappers around existing modules, so the same Perl code can be shared by both the web front end and any other scripts or tools that need them.&lt;/li&gt;
&lt;li&gt;The plug-in nature of taglibs allows using many public and private XSP taglibs facilities for rapid prototyping. CPAN&amp;rsquo;s &lt;a href=&#34;https://metacpan.org/search?q=XSP%3A%3A&#34;&gt;chock full of &amp;lsquo;em&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;In addition to the &amp;ldquo;function&amp;rdquo; tags like the two demostrated above, you can program &amp;ldquo;conditional&amp;rdquo; tags that control whether or not a block of the XSP page is included; this gives you the ability to respond to user preferences or rights, for instance.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;a href=&#34;https://metacpan.org/pod/DBI&#34;&gt;DBI&lt;/a&gt; module lets you work with almost any database ranging from &lt;a href=&#34;https://metacpan.org/pod/DBD::CSV&#34;&gt;comma separated value&lt;/a&gt; files (with SQL JOIN support no less) through MySQL, PostgreSQL, Oracle, etc, etc., and returns Perl data structures just crying out to be returned from a taglib function and turned in to XML.&lt;/p&gt;

&lt;p&gt;For quick one-off pages and prototypes, the &lt;a href=&#34;https://metacpan.org/pod/AxKit::XSP::ESQL&#34;&gt;ESQL&lt;/a&gt; taglib allows you to embed SQL directly in XSP pages. This is not recommended practice because it&amp;rsquo;s not efficient enough for heavily trafficed sites (the database connection is rebuilt each time), and because mixing programming code in with the XML leads to some pretty unreadable and hard-to-maintain pages, but it is good for one-off pages and prototypes.&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;help&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&#34;help-and-thanks&#34;&gt;Help and thanks&lt;/h4&gt;

&lt;p&gt;In case of trouble, have a look at some of the &lt;a href=&#34;http://localhost:1313/pub/2002/03/12/axkit.html?page=3#help&#34;&gt;helpful resources we listed last time&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Thanks to Kip Hampton, Jeremy Mates and Martin Oldfield, for their thorough reviews, though I&amp;rsquo;m sure I managed to sneak some bugs by them. AxKit and many of the Perl modules it uses are primarily written by Matt Sergeant with extensive contributions from these good folks and others, so many thanks to all contributors as well.&lt;/p&gt;

&lt;p&gt;Copyright 2002, Robert Barrie Slaymaker, Jr. All Rights Reserved.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introducing AxKit</title>
      <link>http://localhost:1313/pub/2002/03/12/axkit.html/</link>
      <pubDate>Wed, 13 Mar 2002 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2002/03/12/axkit.html/</guid>
      <description>

&lt;p&gt;&lt;span id=&#34;series_intro&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&#34;series-introduction&#34;&gt;Series Introduction&lt;/h3&gt;

&lt;p&gt;This article is the first in a series of articles introducing the AxKit web application platform. Starting from the basics, this series explains how to install a basic AxKit server and then explores AxKit&amp;rsquo;s more powerful capabilities. Basic familiarity with (or ability to &lt;a href=&#34;http://www.google.com/&#34;&gt;google&lt;/a&gt; for) &lt;a href=&#34;http://www.w3.org/XML/&#34;&gt;XML&lt;/a&gt;, &lt;a href=&#34;http://httpd.apache.org&#34;&gt;Apache&lt;/a&gt;, and &lt;a href=&#34;http://perl.apache.org/&#34;&gt;mod_perl&lt;/a&gt; is assumed but expertise is not required. Some &lt;a href=&#34;#help&#34;&gt;References and Helpful Resources&lt;/a&gt; are provided at the end of this article to help get you started as well.&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;axkit&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&#34;axkit-what-is-it&#34;&gt;AxKit: What is it?&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;If you already know about AxKit and the wonders of server side XML processing, you may wish to &lt;a href=&#34;#installation&#34;&gt;skip to the Basic Installation&lt;/a&gt; section.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;AxKit is an application and document server that uses XML processing pipelines to generate and process content and deliver it to clients in a wide variety of formats. It&amp;rsquo;s important to note that AxKit is not limited to XML source documents; non-XML documents and data sources can be converted to XML as needed. A basic AxKit pipeline looks like:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2002_03_12_axkit/basic_pipeline.jpg&#34; alt=&#34;Axkit Processing Overview&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The source document may be an article, a data set, data returned by a database query, the output from a Perl routine, mod_perl handler, CGI script, etc., etc. This document is fed in to the first processor (&amp;ldquo;Transform 1&amp;rdquo;) which alters it according to a &amp;ldquo;stylesheet&amp;rdquo;, which specifies a set of transforms to apply to the document. The output from the first processor is fed to the second, the second to the third, and so on until the final document is passed to the browser.&lt;/p&gt;

&lt;p&gt;Processing techniques available conventional XML processing like &lt;a href=&#34;http://www.xslt.com/&#34;&gt;XSLT&lt;/a&gt;, advanced processing more suited to dynamic content (such as Perl versions of &lt;a href=&#34;http://axkit.org/docs/xsp/index.xml&#34;&gt;XSP&lt;/a&gt; and tag libraries), and low-level processing in Perl for those occasions where high level abstractions merely get in the way.&lt;/p&gt;

&lt;p&gt;AxKit provides seamless caching (of both code for generating dynamic content and for transformed documents), compression, and character set conversion. AxKit also allows other technologies (CGI scripts, session management tools, data converters, Perl modules, &lt;a href=&#34;https://metacpan.org/pod/Inline::C&#34;&gt;Inline::C&lt;/a&gt;, etc) to be used to extend its capabilities.&lt;/p&gt;

&lt;p&gt;The current version (v1.5) is tightly coupled with Apache/mod_perl and leverages the exceptional configurability and performance of that platform; work is underway to enable use in other environments like offline processing, cgi-bin, and standalone servers.&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;why_axkit&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&#34;why-axkit&#34;&gt;Why AxKit?&lt;/h3&gt;

&lt;p&gt;All the hype surrounding in-browser XML processing makes it seem like there should be little or no need for server-side XML processing. However, for a variety of reasons, XML in the browser is just not available everywhere and, when available, has limitations that server side processing addresses.&lt;/p&gt;

&lt;p&gt;Server-side XML processing allows content to be queried, reorganized, translated, styled, and so on, before sending the &amp;ldquo;final&amp;rdquo; HTML, XML, text, SVG, or other output to the browser. The server can implement heavy duty data processing using the most effective and appropriate tools (as opposed to the rather more limited tools available client-side, even when you can control the client configuration). The server can then decide to deliver a formatted document ready for presentation and display or to delegate presentation formatting (and its attendant processing overhead) to the client. In some sense, that&amp;rsquo;s an ideal approach: use the server to apply heavyweight or unusual transforms and offload the presentation formatting to the browser.&lt;/p&gt;

&lt;p&gt;Some of the advantages of using XML on the server are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;XML can be transformed on the server in to a wide variety of content delivery languages: XML, WML, XHTML, HTML, RTF, PDF, graphics formats, plain text, etc.&lt;/li&gt;
&lt;li&gt;Presentation can be separated from content and logic so that transforming the presentation does not mean altering the XML documents or settings on the authoring tools. This article demonstrates separating logic, content and presentation.&lt;/li&gt;
&lt;li&gt;Even using the same delivery language (HTML, say), documents can be formatted in different ways for differing display media, screen vs. printer, for instance.&lt;/li&gt;
&lt;li&gt;XML offers support for specifying the character encodings. Source documents can be transcoded into different character sets depending on the browser.&lt;/li&gt;
&lt;li&gt;XML documents can be expressed in a natural order for their &amp;ldquo;primary&amp;rdquo; display mode and reordered differently to provide different views of the data. Terms in a document&amp;rsquo;s glossary or index are not in document order, for instance.&lt;/li&gt;
&lt;li&gt;As the content and capabilities of a web site evolves, new XML tags can be introduced in new content without having to &amp;ldquo;upgrade&amp;rdquo; older articles. We&amp;rsquo;ll touch on tag libraries (taglibs) in this article and examine them in more depth in later articles.&lt;/li&gt;
&lt;li&gt;XML related technologies are becoming well known; hiring XML literate personnel is becomming easier. With in-house proprietary formats, you always have to train them yourself. With third party proprietary formats, you hope you can get good enough training to do what you need.&lt;/li&gt;
&lt;li&gt;XML processing tools (XSLT, editors, etc) are becoming commonly available, so adopting XML outside of the IT department is feasible. There&amp;rsquo;s still a gap in support for WYSIWYG authoring tools, though some are now commercially available.&lt;/li&gt;
&lt;li&gt;XML can optionally be transformed on the client for browsers that offer sufficient features, thus reducing server workload. Be prepared for slow client-side transforms on larger pages, and you will probably want to do reordering and subsetting operations on the server.&lt;/li&gt;
&lt;li&gt;XML can provide descriptions of the structure of your web site and its content in multiple formats. The &amp;ldquo;Semantic Web&amp;rdquo; is coming to a browser near you (&lt;em&gt;real&lt;/em&gt; soon now ;-). One of the biggest academic concerns about the web is the lack of semantic content. When looking at a page from a book in HTML format, who&amp;rsquo;s to say whether a heading enclosed by &amp;lt;H1&amp;gt; is a book&amp;rsquo;s author, title, publisher, or even a chapter or section heading? XML can be used to clarify such issues, and standards like the Resource Description Framework (RDF, of course) are gaining ground here.&lt;/li&gt;
&lt;li&gt;XML-based technologies like the RDF Site Summary (RSS) and the more general Resource Description Framework can be leveraged to allow automated navigation, syndication, and summarization of a web site by other web sites. This is especially applicable to portions of a web site containing current news and press releases; these are often reproduced on other sites&amp;rsquo; news summaries and &amp;ldquo;headlines&amp;rdquo; pages.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;AxKit enables all of this and far more. Unlike some more insular environments, AxKit happily bolts up to almost any other technology that you can load in to an Apache web server or reach using external requests.&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;installation&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&#34;basic-installation&#34;&gt;Basic Installation&lt;/h3&gt;

&lt;p&gt;This section will walk you through a manual installation, but there&amp;rsquo;s an easier way if you just want to play with AxKit: grab the &lt;a href=&#34;http://localhost:1313/media/_pub_2002_03_12_axkit/axkit_articles-1.0.tar.gz&#34;&gt;AxKit demo tarball&lt;/a&gt; for this article, untar it and run the &lt;code&gt;install&lt;/code&gt; script therein. The tarball includes the prerequisites necessary for most modern Unix-like systems and will be updated new versions and example code with each article. If this works for you (it&amp;rsquo;s been tested on both Linux and FreeBSD), you can skip all of the manual install instructions and jump to &lt;a href=&#34;#testing&#34;&gt;Testing AxKit&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;AxKit ties together a lot of different technologies and uses a lot of CPAN modules. Doing a basic manual install is not difficult if CPAN.pm (or equivalent; a CPANPLUS is in the works as of this writing) is working on your system.&lt;/p&gt;

&lt;p&gt;The first step in installing AxKit is big, but not usually difficult: installing Apache and mod_perl 1.x versions (2.x versions are in development but are not released at the time of this writing). The &lt;a href=&#34;http://perl.apache.org/docs/1.0/guide/&#34;&gt;mod_perl Developer&amp;rsquo;s Guide&lt;/a&gt; covers this process in detail. Here&amp;rsquo;s a quick recipe for a Unix system &amp;ldquo;private&amp;rdquo; (ie non-root) install in &lt;code&gt;/home/me/axkit_articles-1.0&lt;/code&gt; (vary the version numbers to suit):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir axkit_articles-1.0
$ cd axkit_articles-1.0
$ lynx http://httpd.apache.org/dist/httpd/  # Get the latest 1.x version of apache
$ lynx http://perl.apache.org/dist/  # Get the latest 1.x version of mod_perl.
$ gunzip apache_1.3.23.tar.gz
$ tar xf apache_1.3.23.tar
$ gunzip mod_perl-1.26.tar.gz
$ tar xf mod_perl-1.26.tar
$ cd mod_perl-1.26
$ perl Makefile.PL \
&amp;gt;   APACHE_SRC=../apache_1.3.23/src/ \
&amp;gt;   DO_HTTPD=1 \
&amp;gt;   USE_APACI=1 \
&amp;gt;   APACHE_PREFIX=/home/me/axkit_articles-1.0/www \
&amp;gt;   PREFIX=/home/me/axkit_articles-1.0/www \
&amp;gt;   EVERYTHING=1
$ make
$ make test
$ make install
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;It is usually wise to write your AxKit/mod_perl/Apache build process in to a script so that you can debug it, repeat it, and alter it as needed. Servers like these are immensely powerful and configurable; it&amp;rsquo;s pretty likely that you&amp;rsquo;ll want a reproducable, tweakable build environment for them.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;On Windows, look for the most recent Apache Win32 binary in &lt;a href=&#34;http://www.apache.org/dist/httpd/binaries/win32/&#34;&gt;http://httpd.apache.org/dist/binaries/win32/&lt;/a&gt; and then &lt;a href=&#34;http://perl.apache.org/docs/1.0/os/win32/index.html&#34;&gt;use &lt;code&gt;PPM&lt;/code&gt; to install a mod_perl binary&lt;/a&gt;. &lt;strong&gt;NOTE:&lt;/strong&gt; it is not recommended to use Windows for production Apache/mod_perl servers; Apache/mod_perl 1.x is not able to scale well on this platform; Apache/mod_perl 2.x is addressing the fundamental architectural disagreements that cause this.&lt;/p&gt;

&lt;p&gt;If all went well, running&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ www/bin/apachectl start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;should fire up a (non-AxKit) httpd on port 8080. In case of trouble (both packages are mature, so trouble is not frequent), see the &lt;a href=&#34;#help&#34;&gt;References and Helpful Resources&lt;/a&gt; section at the end of the article for some places to seek help.&lt;/p&gt;

&lt;p&gt;The next part is to install some AxKit prerequisites: the GNOME project&amp;rsquo;s libxml2 and libxslt will be used by the examples in this series of articles, though they project&amp;rsquo;s libxml2. To see if they are already installed, try:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ xml2-config --version
2.4.13                         # Need &amp;gt;= 2.4.13
$ xslt-config --version
1.0.10                         # Need &amp;gt;= 1.0.10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If not, grab them from the source tarball for the article or &lt;a href=&#34;https://download.gnome.org/GNOME/stable/sources/&#34;&gt;a random GNOME mirror&lt;/a&gt; and install them using &lt;code&gt;./configure &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install&lt;/code&gt;. The tarball above installs all of the prerequisites in the &amp;ldquo;private&amp;rdquo; install tree; here we&amp;rsquo;re installing them in the system&amp;rsquo;s shared locations to keep the manual install easy. See the commands generated by the install script if you want private copies.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Please note:&lt;/strong&gt; libxslt 1.0.10 has a known (very minor) failure in its test suite which causes &lt;code&gt;make&lt;/code&gt; to fail on some systems when testing &lt;code&gt;tests/exslt/sets/has-same-node.1.xsl&lt;/code&gt;. The &lt;code&gt;install&lt;/code&gt; script provided with this article&amp;rsquo;s source tarball removes the offending test before running &lt;code&gt;make&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now that all of the major prerequisites are installed, let&amp;rsquo;s let &lt;code&gt;CPAN.pm&lt;/code&gt; install the final pieces:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ su
Password:
# perl -MCPAN -e shell
...
cpan&amp;gt; install XML::LibXSLT
...
cpan&amp;gt; install AxKit::XSP::Util
...
cpan&amp;gt; quit
# exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The AxKit::XSP::Util installation should install AxKit and a number of other prerequisites. If CPAN.pm does not work for you, you might just want to grab the axkit-demo tarball mentioned above and install the packages you find there by hand. There are a lot of them, though, so getting CPAN working is propably the easiest way to do a manual install.&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;testing&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&#34;testing-axkit&#34;&gt;Testing AxKit&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;All of the relative directories mentioned from now on assume that you are in the &lt;code&gt;axkit_articles-x.y&lt;/code&gt; directory unless otherwise indicated.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Once all of the required modules are installed, tweak the &lt;code&gt;www/conf/httpd.conf&lt;/code&gt; file to load AxKit by adding:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##
## AxKit Configuration
##

PerlModule AxKit

&amp;lt;Directory &amp;quot;/home/me/axkit_articles-1.0/www/htdocs&amp;quot;&amp;gt;
    Options -All +Indexes +FollowSymLinks

    # Tell mod_dir to translate / to /index.xml or /index.xsp
    DirectoryIndex index.xsp
    AddHandler axkit .xml .xsp

    AxDebugLevel 10

    AxGzipOutput On

    AxAddXSPTaglib AxKit::XSP::Util

    AxAddStyleMap application/x-xsp \
                  Apache::AxKit::Language::XSP
&amp;lt;/Directory&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll walk through the configuration in a bit, but first let&amp;rsquo;s add a &lt;code&gt;www/htdocs/index.xsp&lt;/code&gt; test page that looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml-stylesheet href=&amp;quot;NULL&amp;quot; type=&amp;quot;application/x-xsp&amp;quot;?&amp;gt;
&amp;lt;xsp:page
    xmlns:xsp=&amp;quot;http://www.apache.org/1999/XSP/Core&amp;quot;
    xmlns:util=&amp;quot;http://apache.org/xsp/util/v1&amp;quot;
&amp;gt;
  &amp;lt;html&amp;gt;
    &amp;lt;body&amp;gt;
      &amp;lt;p&amp;gt;Hi! It&#39;s &amp;lt;util:time format=&amp;quot;%H:%M:%S&amp;quot;/&amp;gt;.&amp;lt;/p&amp;gt;
    &amp;lt;/body&amp;gt;
  &amp;lt;/html&amp;gt;
&amp;lt;/xsp:page&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you should be able to restart the server and request the test page like so (whitespace added for readability and so it can be compared to &lt;code&gt;index.xsp&lt;/code&gt; easily):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ www/bin/apachectl restart
$ lynx -source http://127.0.0.1:8080/
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;p&amp;gt;Hi! It&#39;s Tue Feb  5 16:26:31 2002.&amp;lt;/p&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each request should generate a new page with a different time stamp. You may need to tweak the &lt;code&gt;Port&lt;/code&gt; directive in &lt;code&gt;www/conf/httpd.conf&lt;/code&gt; if something&amp;rsquo;s already running on port 8080.&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;how&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&#34;how-the-example-works&#34;&gt;How the example works&lt;/h3&gt;

&lt;p&gt;Later articles in this series will examine various features of AxKit in more depth, for now let&amp;rsquo;s take a look at how the example from the installation section works.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In fact, hopefully by the next article, a new release of AxKit should have a simple demo facility for each of it&amp;rsquo;s major XML processing alternatives available. If so, the tarball accompanying the next article will contain the new release.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span id=&#34;how-config&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&#34;the-configuration&#34;&gt;The Configuration&lt;/h4&gt;

&lt;p&gt;AxKit integrates quite tightly with the Apache configuration engine. The Apache configuration engine is far more than a text file parser: it forms the core of Apache&amp;rsquo;s request handling capabilities and is the key to Apache&amp;rsquo;s flexibility and extensibility. The directives added to the server&amp;rsquo;s configuration above are a mix of native Apache directives and AxKit directives. Let&amp;rsquo;s walk through the first part of the request cycle and see how the Apache configuration directives affect the request.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The Apache httpd is primarily a configuration engine and a collection of special-purpose modules. This discussion glosses over the fact that several modules other than mod_perl and AxKit are used to process this request and refers to them all as &amp;ldquo;Apache&amp;rdquo;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;When the HTTP request arrives, Apache parses it and maps the path portion of the URL (&amp;ldquo;/&amp;rdquo;) to a location on the harddrive (&lt;code&gt;/home/me/axkit_articles-1.0/www/htdocs&lt;/code&gt;). The URI maps to a directory and the Apache directives &amp;ldquo;&lt;code&gt;DocumentRoot&lt;/code&gt;&amp;rdquo; (not shown, it&amp;rsquo;s part of the default install), &amp;ldquo;&lt;code&gt;&amp;lt;Directory&amp;gt;&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;Options +Indexes&lt;/code&gt;&amp;rdquo; and &amp;ldquo;&lt;code&gt;DirectoryIndex&lt;/code&gt;&amp;rdquo; cause Apache to map this URI to the file &lt;code&gt;index.xsp&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now that the underlying resource has been identified, Apache uses the &lt;code&gt;.xsp&lt;/code&gt; extension to figure out what module should deliver the resource to the browser. The &lt;code&gt;AddHandler AxKit .xsp&lt;/code&gt; directive tells Apache to delegate the response handling to AxKit. This is very similar to establishing a mod_perl handler for a URI except that it is implemented in C and is a bit faster than a standard mod_perl response handler.&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;how-processing&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&#34;the-processing-chain&#34;&gt;The Processing Chain&lt;/h4&gt;

&lt;p&gt;The test document, &lt;code&gt;index.xsp&lt;/code&gt; is an example of XSP, eXtensible Server Pages, one of the several languages that AxKit supports. We&amp;rsquo;ll get to how the XSP is processed in a moment.&lt;/p&gt;

&lt;p&gt;When AxKit begins the task of handling the response it has already, through cooperation with Apache&amp;rsquo;s configuration engine processed it&amp;rsquo;s configuration directives. These have the following effects:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;AxDebugLevel 10&lt;/code&gt;
Causes quite a lot of output in the &lt;code&gt;www/logs/error_log&lt;/code&gt;,&lt;/p&gt;

&lt;p&gt;&lt;code&gt;AxGzipOutput On&lt;/code&gt;
Enables automatic gzip compression (via Compress::Zlib). This is only used if the client can accept compressed documents. AxKit even goes the extra mile and compresses output for a few clients that can handle it but don&amp;rsquo;t set the HTTP &lt;code&gt;Accept-Encoding:&lt;/code&gt; header properly.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;AxAddStyleMap application/x-xsp Apache::AxKit::Language::XSP&lt;/code&gt;
Establishes a mapping between the MIME type &amp;ldquo;&lt;code&gt;application/x-xsp&lt;/code&gt;&amp;rdquo; and the Apache::AxKit::Language::XSP module. We&amp;rsquo;ll see shortly how this mapping tells AxKit what module to use when applying a type of transform.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;AxAddXSPTaglib&lt;/code&gt;
Notes that the XSP engine needs to load the AxKit::XSP::Util (this supplies some of the Perl code called by &lt;code&gt;index.xsp&lt;/code&gt;),&lt;/p&gt;

&lt;p&gt;The first thing AxKit needs to do when handling a response is to configure the processing pipeline. The first place AxKit looks for directions is in the source document; it scans the source document for &lt;code&gt;&amp;lt;?xml-stylesheet...?&amp;gt;&lt;/code&gt; processing instructions like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml-stylesheet href=&amp;quot;NULL&amp;quot; type=&amp;quot;application/x-xsp&amp;quot;?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;AxKit has two alternative mechanisms that provide far more power and flexibility; we&amp;rsquo;ll look at these as we walk through more advanced configurations in later articles.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The xml-stylesheet PIs specify a list of transforms to apply to the source document; these are applied in the order that they occur in the document. Each processing instruction specifies a stylesheet (&amp;ldquo;NULL&amp;rdquo; in this case: XSP doesn&amp;rsquo;t use them, we&amp;rsquo;ll cover that in a moment), and a processor type (&amp;ldquo;application/x-xsp&amp;rdquo;). The &lt;code&gt;AxAddStyleMap&lt;/code&gt; directives specify which Perl modules handle with processor types, and the one in our example maps &lt;code&gt;application/x-xsp&lt;/code&gt; to Apache::AxKit::Language::XSP.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s all quite complex; here&amp;rsquo;s a diagram that shows how the most important bits of this example affect the processing pipeline:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2002_03_12_axkit/config_flow.jpg&#34; alt=&#34;index.xsp configuration data flow&#34; /&gt;&lt;/p&gt;

&lt;p&gt;and the resulting pipeline looks like:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2002_03_12_axkit/index_xsp_pipeline.jpg&#34; alt=&#34;index.xsp processing pipeline&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As the diagram shows, the source &lt;code&gt;.xsp&lt;/code&gt; page is read from disk, then compiled in to Perl source code (using the &lt;code&gt;util:&lt;/code&gt; taglib as necessary) and cached on disk. The resulting source code is then run to generate the result document for this request, which is compressed (if the client supports compression), and sent to the client.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can see the source code in &lt;code&gt;www/logs/error_log&lt;/code&gt; when the &lt;code&gt;AxDebugLevel&lt;/code&gt; is set to at least 10.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Note that AxKit is smart enough to not cache the output document (there&amp;rsquo;s no cache between the XSP processor and the output); XSP is intended for dynamic pages and its output documents should not be cached.&lt;/p&gt;

&lt;p&gt;When &lt;code&gt;index.xsp&lt;/code&gt; is compiled, the resulting code builds the output document node by node. The &lt;code&gt;&amp;lt;util:time .../&amp;gt;&lt;/code&gt; tag is converted in to a subroutine call that calls perl&amp;rsquo;s &lt;code&gt;localtime&lt;/code&gt; function. See the &lt;code&gt;error_log&lt;/code&gt; to see the generated Perl (our &lt;code&gt;AxDebugLevel&lt;/code&gt; is set to 10, so XSP.pm emits this to the error log), and see the function &lt;code&gt;get_date()&lt;/code&gt; in AxKit::XSP::Util for the &lt;code&gt;localtime()&lt;/code&gt; call.&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;XSP&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&#34;xsp-and-taglibs&#34;&gt;XSP and Taglibs&lt;/h4&gt;

&lt;p&gt;XSP is unlike most XML processing &amp;ldquo;languages&amp;rdquo; in that it does not actually use stylesheets; instead, XSP pages contain special tags that are executed each time the page is requested. In &lt;code&gt;index.xsp&lt;/code&gt;, for instance, the &lt;code&gt;&amp;lt;util:time format=&amp;quot;%H:%M:%S&amp;quot;/&amp;gt;&lt;/code&gt; tag is converted in to Perl code which calls localtime.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Most XML filters apply a transform to the source XML to generate the result XML. These transforms are called &amp;ldquo;stylesheets&amp;rdquo;. As mentioned, XSP does not use stylesheets. We will cover stylesheet based transforms in future articles.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The &lt;code&gt;util:&lt;/code&gt; portion of the tag is a prefix indicating that the util taglib will handle that tag. The &lt;code&gt;util:&lt;/code&gt; prefix is an &lt;a href=&#34;http://www.jclark.com/xml/xmlns.htm&#34;&gt;XML namespace&lt;/a&gt; prefix and is not hard-coded; the &lt;code&gt;xmlns:util&lt;/code&gt; attribute in the root element of &lt;code&gt;index.xsp&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xsp:page
    xmlns:xsp=&amp;quot;http://www.apache.org/1999/XSP/Core&amp;quot;
    xmlns:util=&amp;quot;http://apache.org/xsp/util/v1&amp;quot;
&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;binds the &lt;code&gt;util:&lt;/code&gt; prefix to the taglib. The module that provides the code behind the &lt;code&gt;util:&lt;/code&gt; taglib, &lt;a href=&#34;https://metacpan.org/pod/AxKit::XSP::Util&#34;&gt;AxKit::XSP::Util&lt;/a&gt;, has the same URI (&amp;rdquo;&lt;code&gt;http://apache.org/xsp/util/v1&lt;/code&gt;&amp;rdquo;) hardcoded in it. When the &lt;code&gt;AxAddXSPTaglib&lt;/code&gt; directive is seen in the &lt;code&gt;httpd.conf&lt;/code&gt; file, AxKit::XSP::Util registers with the XSP module to handle all tags in that namespace.&lt;/p&gt;

&lt;p&gt;An XSP page may include as many taglib namespaces and tags as it needs. CPAN contains a &lt;a href=&#34;https://metacpan.org/search?q=AxKit%3A%3AXSP%3A%3A&#34;&gt;large and growing collection&lt;/a&gt; of taglibs for use with AxKit&amp;rsquo;s XSP implementation, and we&amp;rsquo;ll look at two ways of writing taglibs for Apache in the next two articles.&lt;/p&gt;

&lt;p&gt;The taglibs approach is superficially similar to many of the templating engines on CPAN; indeed, some of the the templating systems have been extended recently to includ taglibs. There are several important differences between these and XSP, however.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;XSP input files must be well formed XML, this makes it impossible to generate malformed XML. With templating systems, typos in the content markup can easily reach the browser with no warnings.&lt;/li&gt;
&lt;li&gt;The source document may be transformed before it is handed to the XSP processor. This allows you to build simple taglibs as XSLT transforms deployed upstream of the XSP processor. Because AxKit&amp;rsquo;s XSP translates XSP pages in to code and caches the code, these transforms will not be run each request; they are captured in the cached code. This can also be used to &amp;ldquo;capture&amp;rdquo; static transforms.&lt;/li&gt;
&lt;li&gt;XSP encourages content, logic, and presentation to be separated; XSP pages add logic to content and generate well formed XML that can be (and usually is) massaged by &amp;ldquo;real&amp;rdquo; stylesheets to effect different presentations.&lt;/li&gt;
&lt;li&gt;as with some of the more sophisticated templating systems, XSP is designed to be extensible; adding a taglib is as simple as configuring adding an &lt;code&gt;AxAddXSPTaglib&lt;/code&gt; statement to the &lt;code&gt;httpd.conf&lt;/code&gt; file and then referring to it in the source document. In the test code, the &lt;code&gt;&amp;lt;util:time&amp;gt;&lt;/code&gt; tag is provided by the &lt;code&gt;Apache::XSP::Util&lt;/code&gt; module, and you may load as many taglibs as necessary in to the server.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;span id=&#34;summary&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&#34;milepost-1-and-the-road-ahead&#34;&gt;Milepost 1 and the Road Ahead&lt;/h3&gt;

&lt;p&gt;This is the first article in this series, presenting AxKit&amp;rsquo;s installation and introducing one of AxKit&amp;rsquo;s processing technologies: XSP. In the next article we&amp;rsquo;ll see how to chain together filters to apply stylesheets to both static documents and XSP-generated documents to allow the same documents to be delivered in different forms. Following that we&amp;rsquo;ll examine how to write taglibs in Perl (the recommended approach) using some helper modules, and XSLT.&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;help&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&#34;references-and-helpful-resources&#34;&gt;References and Helpful Resources&lt;/h3&gt;

&lt;p&gt;There are several very helpful places to research problems, ask questions, and learn more. Try to find others who have had similar problems before posting a question, of course, but the user groups listed here are the place to ask:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://axkit.org&#34;&gt;the AxKit web site&lt;/a&gt; (which may have moved to an &lt;a href=&#34;http://xml.apache.org/&#34;&gt;xml.apache.org&lt;/a&gt; site by the time you read this)
The &amp;ldquo;official&amp;rdquo; AxKit web site.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.axkit.org/docs/guide.dkb&#34;&gt;The AxKit Guide&lt;/a&gt;
An in-depth introduction to AxKit.&lt;/p&gt;

&lt;p&gt;The axkit-users@axkit.org mailing list.
Browse the &lt;a href=&#34;http://axkit.org/cgi-bin/ezmlm-cgi/3&#34;&gt;archives&lt;/a&gt; or &lt;a href=&#34;http://axkit.org/mailinglist.xml&#34;&gt;subscribe&lt;/a&gt;. This is the place to discuss AxKit-specific problems and offer solutions, patches and success stories. The mod_perl resources listed here are perfect for general mod_perl build and support issues as well.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://perl.apache.org/docs/1.0/os/win32/index.html&#34;&gt;mod_perl Developer&amp;rsquo;s Guide&lt;/a&gt;
The first place to check for Apache+mod_perl build advice and debugging tips.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://mathforum.org/epigone/modperl&#34;&gt;modperl@perl.apache.org email archives&lt;/a&gt;
Look here to see if anyone else has had your problems and (usually) found a solution. This list is about to move to an @perl.org address at the time of this writing so I won&amp;rsquo;t point you to a soon-to-be-stale subscription form.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://code.activestate.com/lists/perl-xml/&#34;&gt;perl-xml@listserv1.ActiveState.com&lt;/a&gt;
A mailing list for general perl and XML questions, including axkit support. (subscribe at &lt;a href=&#34;http://listserv.activestate.com/mailman/listinfo/perl-xml&#34;&gt;http://listserv.activestate.com/mailman/listinfo/perl-xml&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;#axkit&lt;/code&gt; IRC channel at &lt;code&gt;irc.rhizomatic.net&lt;/code&gt;
A friendly place where you can often get quick advice right from experienced AxKit users and contributors.&lt;/p&gt;

&lt;p&gt;As with all online Open Source communities, please do try to pay forward any help you receive.&lt;/p&gt;

&lt;p&gt;Thanks to Martin Oldfield, Kip Hampton and Robin Berjon for their thorough technical reviews, though I&amp;rsquo;m sure I managed to sneak some bugs by them. AxKit and many of the Perl modules it uses are primarily written by Matt Sergeant with extensive contributions from these good folks and others, so many thanks to all contributors as well.&lt;/p&gt;

&lt;p&gt;Copyright 2002, Robert Barrie Slaymaker, Jr. All Rights Reserved.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

