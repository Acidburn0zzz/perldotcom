<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Stas Bekman on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/authors/stas-bekman/</link>
    <description>Recent content in Stas Bekman on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 02 Apr 2003 00:00:00 -0800</lastBuildDate>
    <atom:link href="/authors/stas-bekman/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Apache::VMonitor - The Visual System and Apache Server Monitor</title>
      <link>http://localhost:1313/pub/2003/04/02/mod_perl.html/</link>
      <pubDate>Wed, 02 Apr 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/04/02/mod_perl.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Stas Bekman is a coauthor of O&amp;rsquo;Reilly&amp;rsquo;s upcoming &lt;a href=&#34;http://www.oreilly.com/catalog/pmodperl/&#34;&gt;Practical mod_perl&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s important to be able to monitor your production system&amp;rsquo;s health. You want to monitor the memory and file system utilization, the system load, how much memory the processes use, whether you are running out of swap space, and so on. All these tasks are feasible when one has an interactive (telnet/ssh/other) access to the box the Web server is running on, but it&amp;rsquo;s quite a mess since different Unix tools report about different parts of the system. All of this means that you cannot watch the whole system at the one time; it requires lots of typing since one has to switch from one utility to another, unless many connections are open and then each terminal is dedicated to report about something specific.&lt;/p&gt;

&lt;p&gt;But if you are running mod_perl enabled Apache server, then you are in good company, since it allows you to run a special module called &lt;code&gt;Apache::VMonitor&lt;/code&gt; thatprovides most of the desired reports at once.&lt;/p&gt;

&lt;h3 id=&#34;span-id-apache-vmonitor-apache-vmonitor-span&#34;&gt;&lt;span id=&#34;apache::vmonitor&#34;&gt;Apache::VMonitor&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;Apache::VMonitor&lt;/code&gt; module provides even better monitoring functionality than top(1). It gives all the relevant information &lt;a href=&#34;#item_top&#34;&gt;&lt;code&gt;top(1)&lt;/code&gt;&lt;/a&gt; does, plus all the Apache specific information provided by Apache&amp;rsquo;s mod_status module, such as request processing time, last request&amp;rsquo;s URI, number of requests served by each child, etc. In addition, it emulates the reporting functions of the top(1), mount(1), &lt;a href=&#34;#item_df&#34;&gt;&lt;code&gt;df(1)&lt;/code&gt;&lt;/a&gt; utilities. There is a special mode for mod_perl processes. It has visual alerting capabilities and a configurable &lt;em&gt;automatic refresh&lt;/em&gt; mode. It provides a Web interface, which can be used to show or hide all sections dynamically.&lt;/p&gt;

&lt;p&gt;The module provides two main viewing modes:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Multi-processes and system overall status reporting mode&lt;/li&gt;
&lt;li&gt;A single process extensive reporting system&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;span-id-prerequisites-and-configuration-prerequisites-and-configuration-span&#34;&gt;&lt;span id=&#34;prerequisites_and_configuration&#34;&gt;Prerequisites and Configuration&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;You need to have &lt;strong&gt;Apache::Scoreboard&lt;/strong&gt; installed and configured in &lt;em&gt;httpd.conf&lt;/em&gt;, which in turn requires mod_status to be installed. You also have to enable the extended status for mod_status, for this module to work properly. In &lt;em&gt;httpd.conf&lt;/em&gt; add:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ExtendedStatus On
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You also need &lt;strong&gt;Time::HiRes&lt;/strong&gt; and &lt;strong&gt;GTop&lt;/strong&gt; to be installed. &lt;code&gt;GTop&lt;/code&gt; relies in turn on &lt;code&gt;libgtop&lt;/code&gt; library, which is not not available for all platforms.&lt;/p&gt;

&lt;p&gt;And, of course, you need a running mod_perl-enabled Apache server.&lt;/p&gt;

&lt;p&gt;To enable this module, you should modify a configuration in &lt;strong&gt;httpd.conf&lt;/strong&gt;, if you add the following configuration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;Location /system/vmonitor&amp;gt;
    SetHandler perl-script
    PerlHandler Apache::VMonitor
  &amp;lt;/Location&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The monitor will be displayed when you request &lt;a href=&#34;http://localhost/system/vmonitor.&#34;&gt;http://localhost/system/vmonitor.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;You probably want to protect this location from unwanted visitors. If you always access this location from the same IP address, then you can use a simple host-based authentication:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;Location /system/vmonitor&amp;gt;
    SetHandler perl-script
    PerlHandler Apache::VMonitor
    order deny, allow
    deny  from all
    allow from 132.123.123.3
  &amp;lt;/Location&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternatively you may use the Basic or other authentication schemes provided by Apache and various extensions.&lt;/p&gt;

&lt;p&gt;You can control the behavior of this module by configuring the following variables in the startup file or inside the &lt;code&gt;&amp;lt;Perl&amp;gt;&lt;/code&gt; section.&lt;/p&gt;

&lt;p&gt;You should load the module in &lt;em&gt;httpd.conf&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  PerlModule Apache::VMonitor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or from the the startup file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use Apache::VMonitor();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can alter the monitor reporting behavior by tweaking the following configuration arguments from within the startup file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $Apache::VMonitor::Config{BLINKING} = 1;
  $Apache::VMonitor::Config{REFRESH}  = 0;
  $Apache::VMonitor::Config{VERBOSE}  = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can control what sections are to be displayed when the tool is first accessed via:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $Apache::VMonitor::Config{SYSTEM}   = 1;
  $Apache::VMonitor::Config{APACHE}   = 1;
  $Apache::VMonitor::Config{PROCS}    = 1;
  $Apache::VMonitor::Config{MOUNT}    = 1;
  $Apache::VMonitor::Config{FS_USAGE} = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can control the sorting of the mod_perl processes reports. These report can be sorted by one of the following columns: &lt;em&gt;``pid&amp;rdquo;&lt;/em&gt;, &lt;em&gt;``mode&amp;rdquo;&lt;/em&gt;, &lt;em&gt;``elapsed&amp;rdquo;&lt;/em&gt;, &lt;em&gt;``lastreq&amp;rdquo;&lt;/em&gt;, &lt;em&gt;``served&amp;rdquo;&lt;/em&gt;, &lt;em&gt;``size&amp;rdquo;&lt;/em&gt;, &lt;em&gt;``share&amp;rdquo;&lt;/em&gt;, &lt;em&gt;``vsize&amp;rdquo;&lt;/em&gt;, &lt;em&gt;``rss&amp;rdquo;&lt;/em&gt;, &lt;em&gt;``client&amp;rdquo;&lt;/em&gt;, &lt;em&gt;``request&amp;rdquo;&lt;/em&gt;. For example to sort by process size, try the following setting:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $Apache::VMonitor::Config{SORT_BY}  = &amp;quot;size&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As the application provides an option to monitor processes other than mod_perl ones, you may set a regular expression to match the wanted processes. For example, to match the process names, which include &lt;em&gt;httpd_docs&lt;/em&gt;, &lt;em&gt;mysql&lt;/em&gt; and &lt;em&gt;squid&lt;/em&gt; string, the following regular expression is to be used:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $Apache::VMonitor::PROC_REGEX = join &amp;quot;\|&amp;quot;, qw(httpd_docs mysql squid);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will discuss all these configuration options and their influence on the application shortly.&lt;/p&gt;

&lt;h4 id=&#34;span-id-multiprocesses-and-system-overall-status-reporting-mode-multi-processes-and-system-overall-status-reporting-mode-span&#34;&gt;&lt;span id=&#34;multiprocesses_and_system_overall_status_reporting_mode&#34;&gt;Multi-processes and System Overall Status Reporting Mode&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The first mode is the one that is mainly used, since it allows you to monitor almost all important system resources from one location. For your convenience you can turn on and off different sections on the report, to make it possible for reports to fit into one screen.&lt;/p&gt;

&lt;p&gt;This mode comes with the following features.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_automatic_refreshing_mode&#34;&gt;Automatic Refreshing Mode&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;You can tell the application to refresh the report every few seconds. You can preset this value at the server startup. For example, to set the refresh to 60 seconds you should add the following configuration setting:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $Apache::VMonitor::Config{REFRESH} = 60;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A 0 (zero) value turns automatic refreshing off.&lt;/p&gt;

&lt;p&gt;When the server is started you can always adjust the refresh rate using the application user interface.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_top&#34;&gt;&lt;code&gt;top(1)&lt;/code&gt; Emulation: System Health Report&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Just like top(1), it shows current date/time, machine up-time, average load, all the system CPU and memory usage: CPU load, real memory and swap partition usage.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;#item_top&#34;&gt;&lt;code&gt;top(1)&lt;/code&gt;&lt;/a&gt; section includes a swap space usage visual alert capability. As we know swapping is undesirable on production systems. The system is said to be swapping when it has used all of its RAM and starts to page out unused memory pages to the slow swap partition, which slows down the whole system and may eventually lead to the machine crash.&lt;/p&gt;

&lt;p&gt;Therefore, the tool helps to detect abnormal situation by changing the swap report row&amp;rsquo;s color according to the following rules:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;         swap usage               report color
   ---------------------------------------------------------
   5Mb &amp;lt; swap &amp;lt; 10 MB             light red
   20% &amp;lt; swap (swapping is bad!)  red
   70% &amp;lt; swap (almost all used!)  red + blinking (if enabled)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that you can turn on the blinking mode with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $Apache::VMonitor::Config{BLINKING} = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The module doesn&amp;rsquo;t alert when swap is being used just a little (&amp;lt;5Mb), since it happens most of the time on many Unix systems, even when there is plenty of free RAM.&lt;/p&gt;

&lt;p&gt;If you don&amp;rsquo;t want the system section to be displayed set:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $Apache::VMonitor::Config{SYSTEM} = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The default is to display this section.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;top(1)&lt;/code&gt; Emulation: Apache/mod_perl Processes Status&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Then just like in real &lt;a href=&#34;#item_top&#34;&gt;&lt;code&gt;top(1)&lt;/code&gt;&lt;/a&gt; there is a report of the processes, but it shows all the relevant information about mod_perl processes only!&lt;/p&gt;

&lt;p&gt;The report includes the status of the process (&lt;em&gt;Starting&lt;/em&gt;, &lt;em&gt;Reading&lt;/em&gt;, &lt;em&gt;Sending&lt;/em&gt;, &lt;em&gt;Waiting&lt;/em&gt;, etc.), process&amp;rsquo; ID, time since current request was started, last request processing time, size, shared, virtual and resident size. It shows the last client&amp;rsquo;s IP and Request URI (only 64 chars, as this is the maximum length stored by underlying Apache core library).&lt;/p&gt;

&lt;p&gt;This report can be sorted by any column during the application uses, by clicking on the name of the column, or can be preset with the following setting:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $Apache::VMonitor::Config{SORT_BY}  = &amp;quot;size&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The valid choices are: &lt;em&gt;``pid&amp;rdquo;&lt;/em&gt;, &lt;em&gt;``mode&amp;rdquo;&lt;/em&gt;, &lt;em&gt;``elapsed&amp;rdquo;&lt;/em&gt;, &lt;em&gt;``lastreq&amp;rdquo;&lt;/em&gt;, &lt;em&gt;``served&amp;rdquo;&lt;/em&gt;, &lt;em&gt;``size&amp;rdquo;&lt;/em&gt;, &lt;em&gt;``share&amp;rdquo;&lt;/em&gt;, &lt;em&gt;``vsize&amp;rdquo;&lt;/em&gt;, &lt;em&gt;``rss&amp;rdquo;&lt;/em&gt;, &lt;em&gt;``client&amp;rdquo;&lt;/em&gt;, &lt;em&gt;``request&amp;rdquo;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The section is concluded with a report about the total memory being used by all mod_perl processes as reported by kernel, plus an extra number, which results from an attempt to approximately calculate the real memory usage when memory sharing is taking place. The calculation is performed by using the following logic:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;For each process, sum up the difference between shared and total memory.&lt;/li&gt;
&lt;li&gt;Now if we add the share size of the process with the maximum shared memory, then we would get all the memory that is actually used by all mod_perl processes apart from the parent process.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Please note that this might be incorrect for your system, so you should use this number on your own risk. We have verified this number on the Linux OS, by taken the number reported by &lt;code&gt;Apache::VMonitor&lt;/code&gt;, then stopping mod_perl and looking at the system memory usage. The system memory went down approximately by the number reported by the tool. Again, use this number wisely!&lt;/p&gt;

&lt;p&gt;If you don&amp;rsquo;t want the mod_perl processes section to be displayed set:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $Apache::VMonitor::Config{APACHE} = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The default is to display this section.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;top(1)&lt;/code&gt; Emulation: Any Processes&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This section, just like the mod_perl processes section, displays the information in a &lt;a href=&#34;#item_top&#34;&gt;&lt;code&gt;top(1)&lt;/code&gt;&lt;/a&gt; fashion. To enable this section you have to set:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $Apache::VMonitor::Config{PROCS} = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The default is not to display this section.&lt;/p&gt;

&lt;p&gt;Now you need to specify which processes are to be monitored. The regular expression that will match the desired processes is required for this section to work. For example, if you want to see all the processes whose name include any of these strings: &lt;em&gt;http&lt;/em&gt;, &lt;em&gt;mysql&lt;/em&gt; and &lt;em&gt;squid&lt;/em&gt;, then the following regular expression would be used:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $Apache::VMonitor::PROC_REGEX = join &amp;quot;\|&amp;quot;, qw(httpd mysql squid);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following snapshot visualizes the sections that have been discussed so far.&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2003_04_02_mod_perl/vmonitor5.1.png&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_04_02_mod_perl/vmonitor5.1_t.gif&#34; width=&#34;300&#34; height=&#34;276&#34; /&gt;&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;span class=&#34;secondary&#34;&gt; &lt;strong&gt;Figure 1.1: Emulation of top(1), Centralized Information About mod_perl and Selected Processes&lt;/strong&gt; &lt;/span&gt;
&lt;p&gt;(Click for larger image)&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;As you can see the swap memory is heavily used and therefore the swap memory report is colored in red.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_mount&#34;&gt;&lt;code&gt;mount(1)&lt;/code&gt; Emulation&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This section reports about mounted filesystems, the same way as if you have called &lt;a href=&#34;#item_mount&#34;&gt;&lt;code&gt;mount(1)&lt;/code&gt;&lt;/a&gt; with no parameters.&lt;/p&gt;

&lt;p&gt;If you want the &lt;a href=&#34;#item_mount&#34;&gt;&lt;code&gt;mount(1)&lt;/code&gt;&lt;/a&gt; section to be displayed set:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $Apache::VMonitor::Config{MOUNT} = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The default is NOT to display this section.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_df&#34;&gt;&lt;code&gt;df(1)&lt;/code&gt; Emulation&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This section completely reproduces the &lt;a href=&#34;#item_df&#34;&gt;&lt;code&gt;df(1)&lt;/code&gt;&lt;/a&gt; utility. For each mounted filesystem, it reports the number of total and available blocks (for both superuser and user), and usage in percents.&lt;/p&gt;

&lt;p&gt;In addition it reports about available and used file inodes in numbers and percents.&lt;/p&gt;

&lt;p&gt;This section has a capability of visual alert which is being triggered when either some filesystem becomes more than 90 percent full or there are less than 10 percent of free file inodes left. When this event happens, the filesystem-related report row will be displayed in the bold font and in the red color. A mount point directory will blink if the blinking is turned on. You can turn the blinking on with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $Apache::VMonitor::Config{BLINKING} = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you don&amp;rsquo;t want the &lt;a href=&#34;#item_df&#34;&gt;&lt;code&gt;df(1)&lt;/code&gt;&lt;/a&gt; section to be displayed set:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $Apache::VMonitor::Config{FS_USAGE} = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The default is to display this section.&lt;/p&gt;

&lt;p&gt;The following snapshot presents an example of the report consisting of the last two sections that were discussed (df(1) and &lt;a href=&#34;#item_mount&#34;&gt;&lt;code&gt;mount(1)&lt;/code&gt;&lt;/a&gt; emulation), plus the ever important mod_perl processes report.&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2003_04_02_mod_perl/vmonitor5.2.png&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_04_02_mod_perl/vmonitor5.2_t.gif&#34; width=&#34;300&#34; height=&#34;276&#34; /&gt;&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;span class=&#34;secondary&#34;&gt; &lt;strong&gt;Figure 1.2: Emulation of df(1) both Inodes and Blocks Utilization. Emulation of mount(1).&lt;/strong&gt; &lt;/span&gt;
&lt;p&gt;(Click for larger image)&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;You can see that &lt;em&gt;/mnt/cdrom&lt;/em&gt; and &lt;em&gt;/usr&lt;/em&gt; filesystems are utilized for more than 90 percent and therefore colored in red. (It&amp;rsquo;s normal for &lt;em&gt;/mnt/cdrom&lt;/em&gt;, which is a mounted cdrom, but critical for the &lt;em&gt;/usr&lt;/em&gt; filesystem which should be cleaned up or enlarged).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_abbreviations_and_hints&#34;&gt;abbreviations and hints&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The report uses many abbreviations, which might be knew for you. If you enable the VERBOSE mode with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $Apache::VMonitor::Config{VERBOSE} = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;this section will reveal all the full names of the abbreviations at the bottom of the report.&lt;/p&gt;

&lt;p&gt;The default is NOT to display this section.&lt;/p&gt;

&lt;h4 id=&#34;span-id-a-single-process-extensive-reporting-system-a-single-process-extensive-reporting-system-span&#34;&gt;&lt;span id=&#34;a_single_process_extensive_reporting_system&#34;&gt;A Single Process Extensive Reporting System&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;If you need to get an in-depth information about a single process, then you just need to click on its PID.&lt;/p&gt;

&lt;p&gt;If the chosen process is a mod_perl process, then the following info would be displayed:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Process type (child or parent), status of the process (&lt;em&gt;Starting&lt;/em&gt;, &lt;em&gt;Reading&lt;/em&gt;, &lt;em&gt;Sending&lt;/em&gt;, &lt;em&gt;Waiting&lt;/em&gt;, etc.), how long the current request is processed or the last one was processed if the process is inactive at the moment of the report take.&lt;/li&gt;
&lt;li&gt;How many bytes transferred so far. How many requests served per child and per slot.&lt;/li&gt;
&lt;li&gt;CPU times used by process: &lt;code&gt;total&lt;/code&gt;, &lt;code&gt;utime&lt;/code&gt;, &lt;code&gt;stime&lt;/code&gt;, &lt;code&gt;cutime&lt;/code&gt;, &lt;code&gt;cstime&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For all (mod_perl and non-mod_perl) processes the following information is reported:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;General process info: UID, GID, State, TTY, Command line arguments&lt;/li&gt;
&lt;li&gt;Memory Usage: Size, Share, VSize, RSS&lt;/li&gt;
&lt;li&gt;Memory Segments Usage: text, shared lib, date and stack.&lt;/li&gt;
&lt;li&gt;Memory Maps: start-end, offset, device_major:device_minor, inode, perm, library path.&lt;/li&gt;
&lt;li&gt;Loaded libraries sizes.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Just like the multi-process mode, this mode allows you to automatically refresh the page on the desired intervals.&lt;/p&gt;

&lt;p&gt;The following snapshots show an example of the report about one mod_perl process:&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2003_04_02_mod_perl/vmonitor5.3.png&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_04_02_mod_perl/vmonitor5.3_t.gif&#34; width=&#34;300&#34; height=&#34;276&#34; /&gt;&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;span class=&#34;secondary&#34;&gt; &lt;strong&gt;Figure 1.3: Extended information about processes: General Process Information&lt;/strong&gt; &lt;/span&gt;
&lt;p&gt;(Click for larger image)&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2003_04_02_mod_perl/vmonitor5.4.png&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_04_02_mod_perl/vmonitor5.4_t.gif&#34; width=&#34;300&#34; height=&#34;276&#34; /&gt;&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;span class=&#34;secondary&#34;&gt; &lt;strong&gt;Figure 1.4: Extended information about processes: Memory Maps&lt;/strong&gt; &lt;/span&gt;
&lt;p&gt;(Click for larger image)&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2003_04_02_mod_perl/vmonitor5.5.png&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_04_02_mod_perl/vmonitor5.5_t.gif&#34; width=&#34;300&#34; height=&#34;276&#34; /&gt;&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;span class=&#34;secondary&#34;&gt; &lt;strong&gt;Figure 1.5: Extended information about processes: Loaded Libraries&lt;/strong&gt; &lt;/span&gt;
&lt;p&gt;(Click for larger image)&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;span-id-references-references-span&#34;&gt;&lt;span id=&#34;references&#34;&gt;References&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The mod_perl site&amp;rsquo;s URL:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://perl.apache.org&#34;&gt;http://perl.apache.org&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://metacpan.org/pod/Time::HiRes&#34;&gt;Time::HiRes&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://metacpan.org/pod/Apache::Scoreboard&#34;&gt;Apache::Scoreboard&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://metacpan.org/pod/GTop&#34;&gt;GTop&lt;/a&gt;
&lt;code&gt;GTop&lt;/code&gt; relies in turn on libgtop library not available for all platforms&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Improving mod_perl Sites&#39; Performance: Part 8</title>
      <link>http://localhost:1313/pub/2003/03/04/mod_perl.html/</link>
      <pubDate>Tue, 04 Mar 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/03/04/mod_perl.html/</guid>
      <description>

&lt;p&gt;In this article we continue talking about how to optimize your site for performance without touching code, buying new hardware or telling casts. A few simple &lt;em&gt;httpd.conf&lt;/em&gt; configuration changes can improve the performance tremendously.&lt;/p&gt;

&lt;h3 id=&#34;span-id-choosing-minspareservers-maxspareservers-and-startservers-choosing-minspareservers-maxspareservers-and-startservers-span&#34;&gt;&lt;span id=&#34;choosing_minspareservers,_maxspareservers_and_startservers&#34;&gt;Choosing MinSpareServers, MaxSpareServers and StartServers&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;With mod_perl enabled, it might take as much as 20 seconds from the time you start the server until it is ready to serve incoming requests. This delay depends on the OS, the number of preloaded modules and the process load of the machine. It&amp;rsquo;s best to set &lt;a href=&#34;#item_startservers&#34;&gt;&lt;code&gt;StartServers&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;#item_minspareservers&#34;&gt;&lt;code&gt;MinSpareServers&lt;/code&gt;&lt;/a&gt; to high numbers, so that if you get a high load just after the server has been restarted, the fresh servers will be ready to serve requests immediately. With mod_perl, it&amp;rsquo;s usually a good idea to raise all three variables higher than normal.&lt;/p&gt;

&lt;p&gt;In order to maximize the benefits of mod_perl, you don&amp;rsquo;t want to kill servers when they are idle, rather you want them to stay up and available to handle new requests immediately. I think an ideal configuration is to set &lt;a href=&#34;#item_minspareservers&#34;&gt;&lt;code&gt;MinSpareServers&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;#item_maxspareservers&#34;&gt;&lt;code&gt;MaxSpareServers&lt;/code&gt;&lt;/a&gt; to similar values, maybe even the same. Having the &lt;a href=&#34;#item_maxspareservers&#34;&gt;&lt;code&gt;MaxSpareServers&lt;/code&gt;&lt;/a&gt; close to &lt;a href=&#34;#item_maxclients&#34;&gt;&lt;code&gt;MaxClients&lt;/code&gt;&lt;/a&gt; will completely use all of your resources (if &lt;a href=&#34;#item_maxclients&#34;&gt;&lt;code&gt;MaxClients&lt;/code&gt;&lt;/a&gt; has been chosen to take the full advantage of the resources), but it&amp;rsquo;ll make sure that at any given moment your system will be capable of responding to requests with the maximum speed (assuming that number of concurrent requests is not higher than &lt;a href=&#34;#item_maxclients&#34;&gt;&lt;code&gt;MaxClients&lt;/code&gt;&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s try some numbers. For a heavily loaded Web site and a dedicated machine, I would think of (note 400Mb is just for example):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Available to webserver RAM:   400Mb
  Child&#39;s memory size bounded:  10Mb
  MaxClients:                   400/10 = 40 (larger with mem sharing)
  StartServers:                 20
  MinSpareServers:              20
  MaxSpareServers:              35
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, if I want to use the server for many other tasks, but make it capable of handling a high load, I&amp;rsquo;d try:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Available to webserver RAM:   400Mb
  Child&#39;s memory size bounded:  10Mb
  MaxClients:                   400/10 = 40
  StartServers:                 5
  MinSpareServers:              5
  MaxSpareServers:              10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These numbers are taken off the top of my head, and shouldn&amp;rsquo;t be used as a rule, but rather as examples to show you some possible scenarios. Use this information with caution.&lt;/p&gt;

&lt;h3 id=&#34;span-id-summary-of-benchmarking-to-tune-all-5-parameters-summary-of-benchmarking-to-tune-all-5-parameters-span&#34;&gt;&lt;span id=&#34;summary_of_benchmarking_to_tune_all_5_parameters&#34;&gt;Summary of Benchmarking to Tune All 5 Parameters&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;OK, we&amp;rsquo;ve run various benchmarks &amp;ndash; let&amp;rsquo;s summarize the conclusions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;span id=&#34;item_maxrequestsperchild&#34;&gt;MaxRequestsPerChild&lt;/span&gt;&lt;/strong&gt;
If your scripts are clean and don&amp;rsquo;t leak memory, then set this variable to a number as large as possible (10000?). If you use &lt;code&gt;Apache::SizeLimit&lt;/code&gt;, then you can set this parameter to 0 (treated as infinity). You will want this parameter to be smaller if your code becomes gradually more unshared over the process&amp;rsquo; life. As well as this, &lt;code&gt;Apache::GTopLimit&lt;/code&gt; can help, with its shared memory limitation feature.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span id=&#34;item_startservers&#34;&gt;StartServers&lt;/span&gt;&lt;/strong&gt;
If you keep a small number of servers active most of the time, then keep this number low. Keep it low especially if &lt;a href=&#34;#item_maxspareservers&#34;&gt;&lt;code&gt;MaxSpareServers&lt;/code&gt;&lt;/a&gt; is also low, as if there is no load, Apache will kill its children before they have been utilized at all. If your service is heavily loaded, then make this number close to &lt;a href=&#34;#item_maxclients&#34;&gt;&lt;code&gt;MaxClients&lt;/code&gt;&lt;/a&gt;, and keep &lt;a href=&#34;#item_maxspareservers&#34;&gt;&lt;code&gt;MaxSpareServers&lt;/code&gt;&lt;/a&gt; equal to &lt;a href=&#34;#item_maxclients&#34;&gt;&lt;code&gt;MaxClients&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span id=&#34;item_minspareservers&#34;&gt;MinSpareServers&lt;/span&gt;&lt;/strong&gt;
If your server performs other work besides Web serving, then make this low so the memory of unused children will be freed when the load is light. If your server&amp;rsquo;s load varies (you get loads in bursts) and you want fast response for all clients at any time, then you will want to make it high, so that new children will be respawned in advance and are waiting to handle bursts of requests.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span id=&#34;item_maxspareservers&#34;&gt;MaxSpareServers&lt;/span&gt;&lt;/strong&gt;
The logic is the same as for &lt;a href=&#34;#item_minspareservers&#34;&gt;&lt;code&gt;MinSpareServers&lt;/code&gt;&lt;/a&gt; - low if you need the machine for other tasks, high if it&amp;rsquo;s a dedicated Web host and you want a minimal delay between the request and the response.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_maxclients&#34;&gt;MaxClients&lt;/span&gt;&lt;/strong&gt;
Not too low, so you don&amp;rsquo;t get into a situation where clients are waiting for the server to start serving them (they might wait, but not for very long). However, do not set it too high. With a high MaxClients, if you get a high load, then the server will try to serve all requests immediately. Your CPU will have a hard time keeping up, and if the child size * number of running children is larger than the total available RAM, then your server will start swapping. This will slow down everything, which in turn will make things even slower, until eventually your machine will die. It&amp;rsquo;s important that you take pains to ensure that swapping does not normally happen. Swap space is an emergency pool, not a resource to be used routinely. If you are low on memory and you badly need it, then buy it. Memory is cheap.&lt;/p&gt;

&lt;p&gt;But based on the test I conducted above, even if you have plenty of memory like I have (1Gb), increasing &lt;a href=&#34;#item_maxclients&#34;&gt;&lt;code&gt;MaxClients&lt;/code&gt;&lt;/a&gt; sometimes will give you no improvement in performance. The more clients are running, the more CPU time will be required, the less CPU time slices each process will receive. The response latency (the time to respond to a request) will grow, so you won&amp;rsquo;t see the expected improvement. The best approach is to find the minimum requirement for your kind of service and the maximum capability of your machine. Then start at the minimum and test as I did, successively raising this parameter until you find the region on the curve of the graph of latency and/or throughput against MaxClients where the improvement starts to diminish. Stop there and use it. When you make the measurements on a production server you will have the ability to tune them more precisely, since you will see the real numbers.&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t forget that if you add more scripts, or even just modify the existing ones, then the processes will grow in size as you compile in more code. When you do this, your parameters probably will need to be recalculated.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;span-id-keepalive-keepalive-span&#34;&gt;&lt;span id=&#34;keepalive&#34;&gt;KeepAlive&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;If your mod_perl server&amp;rsquo;s &lt;em&gt;httpd.conf&lt;/em&gt; includes the following directives:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  KeepAlive On
  MaxKeepAliveRequests 100
  KeepAliveTimeout 15
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you have a real performance penalty, since after completing the processing for each request, the process will wait for &lt;code&gt;KeepAliveTimeout&lt;/code&gt; seconds before closing the connection and will therefore not be serving other requests during this time. With this configuration, you will need many more concurrent processes on a server with high traffic.&lt;/p&gt;

&lt;p&gt;If you use some server status reporting tools, then you will see the process in &lt;em&gt;K&lt;/em&gt; status when it&amp;rsquo;s in &lt;code&gt;KeepAlive&lt;/code&gt; status.&lt;/p&gt;

&lt;p&gt;The chances are that you don&amp;rsquo;t want this feature enabled. Set it Off with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  KeepAlive Off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The other two directives don&amp;rsquo;t matter if &lt;code&gt;KeepAlive&lt;/code&gt; is &lt;code&gt;Off&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You might want to consider enabling this option if the client&amp;rsquo;s browser needs to request more than one object from your server for a single HTML page. If this is the situation, then by setting &lt;code&gt;KeepAlive&lt;/code&gt; &lt;code&gt;On&lt;/code&gt; you will save the HTTP connection overhead for all requests but the first one for each page.&lt;/p&gt;

&lt;p&gt;For example: If you have a page with 10 ad banners, which is not uncommon today, then your server will work more effectively if a single process serves them all during a single connection. However, your client will see a slightly slower response, since banners will be brought one at a time and not concurrently as is the case if each &lt;code&gt;IMG&lt;/code&gt; tag opens a separate connection.&lt;/p&gt;

&lt;p&gt;Since keepalive connections will not incur the additional three-way TCP handshake, turning it on will be kinder to the network.&lt;/p&gt;

&lt;p&gt;SSL connections benefit the most from &lt;code&gt;KeepAlive&lt;/code&gt; in cases where you haven&amp;rsquo;t configured the server to cache session ids.&lt;/p&gt;

&lt;p&gt;You have probably followed the usual advice to send all the requests for static objects to a plain Apache server. Since most pages include more than one unique static image, you should keep the default &lt;code&gt;KeepAlive&lt;/code&gt; setting of the non-mod_perl server, i.e. keep it &lt;code&gt;On&lt;/code&gt;. It will probably be a good idea also to reduce the timeout a little.&lt;/p&gt;

&lt;p&gt;One option would be for the proxy/accelerator to keep the connection open to the client but make individual connections to the server, read the response, buffer it for sending to the client and close the server connection. Obviously, you would make new connections to the server as required by the client&amp;rsquo;s requests.&lt;/p&gt;

&lt;p&gt;Also, you should know that &lt;code&gt;KeepAlive&lt;/code&gt; requests only work with responses that contain a &lt;code&gt;Content-Length&lt;/code&gt; header. To send this header do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $r-&amp;gt;header_out(&#39;Content-Length&#39;, $length);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-perlsetupenv-off-perlsetupenv-off-span&#34;&gt;&lt;span id=&#34;perlsetupenv_off&#34;&gt;PerlSetupEnv Off&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;PerlSetupEnv Off&lt;/code&gt; is another optimization you might consider. This directive requires mod_perl 1.25 or later.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;mod_perl&lt;/em&gt; fiddles with the environment to make it appear as if the script were being called under the CGI protocol. For example, the &lt;code&gt;$ENV{QUERY_STRING}&lt;/code&gt; environment variable is initialized with the contents of &lt;em&gt;Apache::args()&lt;/em&gt;, and the value returned by &lt;em&gt;Apache::server_hostname()&lt;/em&gt; is put into &lt;code&gt;$ENV{SERVER_NAME}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But &lt;code&gt;%ENV&lt;/code&gt; population is expensive. Those who have moved to the Perl Apache API no longer need this extra &lt;code&gt;%ENV&lt;/code&gt; population, and can gain by turning it &lt;strong&gt;Off&lt;/strong&gt;. Scripts using the &lt;code&gt;CGI.pm&lt;/code&gt; module require &lt;code&gt;PerlSetupEnv On&lt;/code&gt; because that module relies on a properly populated CGI environment table.&lt;/p&gt;

&lt;p&gt;By default it is &amp;ldquo;On.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Note that you can still set environment variables. For example, when you use the following configuration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  PerlSetupEnv Off
  PerlModule Apache::RegistryNG
  &amp;lt;Location /perl&amp;gt;
    PerlSetupEnv On
    PerlSetEnv TEST hi
    SetHandler perl-script
    PerlHandler Apache::RegistryNG
    Options +ExecCGI
  &amp;lt;/Location&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and issue a request (for example &lt;a href=&#34;http://localhost/perl/setupenvoff.pl)&#34;&gt;http://localhost/perl/setupenvoff.pl)&lt;/a&gt; for this script:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  setupenvoff.pl
  --------------
  use Data::Dumper;
  my $r = Apache-&amp;gt;request();
  $r-&amp;gt;send_http_header(&#39;text/plain&#39;);
  print Dumper(\%ENV);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you should see something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $VAR1 = {
            &#39;GATEWAY_INTERFACE&#39; =&amp;gt; &#39;CGI-Perl/1.1&#39;,
            &#39;MOD_PERL&#39; =&amp;gt; &#39;mod_perl/1.25&#39;,
            &#39;PATH&#39; =&amp;gt; &#39;/usr/lib/perl5/5.00503:... snipped ...&#39;,
            &#39;TEST&#39; =&amp;gt; &#39;hi&#39;
          };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that we have got the value of the environment variable &lt;em&gt;TEST&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-reducing-the-number-of-stat-calls-made-by-apache-reducing-the-number-of-stat-calls-made-by-apache-span&#34;&gt;&lt;span id=&#34;reducing_the_number_of_stat()_calls_made_by_apache&#34;&gt;Reducing the Number of &lt;code&gt;stat()&lt;/code&gt; Calls Made by Apache&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;If you watch the system calls that your server makes (using &lt;em&gt;truss&lt;/em&gt; or &lt;em&gt;strace&lt;/em&gt;) while processing a request, then you will notice that a few &lt;code&gt;stat()&lt;/code&gt; calls are made. For example, when I fetch &lt;a href=&#34;http://localhost/perl-status&#34;&gt;http://localhost/perl-status&lt;/a&gt; and I have my DocRoot set to &lt;em&gt;/home/httpd/docs&lt;/em&gt; I see:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  [snip]
  stat(&amp;quot;/home/httpd/docs/perl-status&amp;quot;, 0xbffff8cc) = -1
                      ENOENT (No such file or directory)
  stat(&amp;quot;/home/httpd/docs&amp;quot;, {st_mode=S_IFDIR|0755,
                                 st_size=1024, ...}) = 0
  [snip]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you have some dynamic content and your virtual relative URI is something like &lt;em&gt;/news/perl/mod_perl/summary&lt;/em&gt; (i.e., there is no such directory on the web server, the path components are only used for requesting a specific report), then this will generate &lt;code&gt;five(!)&lt;/code&gt; &lt;code&gt;stat()&lt;/code&gt; calls, before the &lt;code&gt;DocumentRoot&lt;/code&gt; is found. You will see something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  stat(&amp;quot;/home/httpd/docs/news/perl/mod_perl/summary&amp;quot;, 0xbffff744) = -1
                      ENOENT (No such file or directory)
  stat(&amp;quot;/home/httpd/docs/news/perl/mod_perl&amp;quot;,         0xbffff744) = -1
                      ENOENT (No such file or directory)
  stat(&amp;quot;/home/httpd/docs/news/perl&amp;quot;,                  0xbffff744) = -1
                      ENOENT (No such file or directory)
  stat(&amp;quot;/home/httpd/docs/news&amp;quot;,                       0xbffff744) = -1
                      ENOENT (No such file or directory)
  stat(&amp;quot;/home/httpd/docs&amp;quot;,
                      {st_mode=S_IFDIR|0755, st_size=1024, ...})  =  0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How expensive are those calls? Let&amp;rsquo;s use the &lt;code&gt;Time::HiRes&lt;/code&gt; module to find out.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  stat_call_sample.pl
  -------------------
  use Time::HiRes qw(gettimeofday tv_interval);
  my $calls = 1_000_000;

  my $start_time = [ gettimeofday ];

  stat &amp;quot;/app&amp;quot; for 1..$calls;

  my $end_time = [ gettimeofday ];

  my $elapsed = tv_interval($start_time,$end_time) / $calls;

  print &amp;quot;The average execution time: $elapsed seconds\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This script takes a time sample at the beginning, then does 1,000,000 &lt;code&gt;stat()&lt;/code&gt; calls to a nonexisting file, samples the time at the end and prints the average time it took to make a single &lt;code&gt;stat()&lt;/code&gt; call. I&amp;rsquo;m sampling a million stats, so I&amp;rsquo;d get a correct average result.&lt;/p&gt;

&lt;p&gt;Before we actually run the script, one should distinguish between two different situations. When the server is idle, the time between the first and the last system call will be much shorter than the same time measured on the loaded system. That is because on the idle system, a process can use CPU very often, and on the loaded system lots of processes compete over it and each process has to wait for a longer time to get the same amount of CPU time.&lt;/p&gt;

&lt;p&gt;So first we run the above code on the unloaded system:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % perl stat_call_sample.pl
  The average execution time: 4.209645e-06 seconds
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So it takes about 4 microseconds to execute a &lt;code&gt;stat()&lt;/code&gt; call. Now let&amp;rsquo;s start a CPU intensive process in one console. The following code keeps the CPU busy all the time.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % perl -e &#39;1**1 while 1&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now run the &lt;em&gt;stat_call_sample.pl&lt;/em&gt; script in the other console.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % perl stat_call_sample.pl
  The average execution time: 8.777301e-06 seconds
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see that the average time has more than doubled (about 8 microseconds). And this is obvious, since there were two processes competing for the CPU. Now if we run 4 occurrences of the above code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % perl -e &#39;1**1 while 1&#39; &amp;amp;
  % perl -e &#39;1**1 while 1&#39; &amp;amp;
  % perl -e &#39;1**1 while 1&#39; &amp;amp;
  % perl -e &#39;1**1 while 1&#39; &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And when running our script in parallel with these processes, we get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % perl stat_call_sample.pl
  2.0853558e-05 seconds
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;about 20 microseconds. So the average &lt;code&gt;stat()&lt;/code&gt; system call is five times longer now. Now, if you have 50 mod_perl processes that keep the CPU busy all the time, the &lt;code&gt;stat()&lt;/code&gt; call will be 50 times slower and it&amp;rsquo;ll take 0.2 milliseconds to complete a series of call. If you have five redundant calls as in the strace example above, then they add up to 1 millisecond. If you have more processes constantly consuming CPU, then this time adds up. Now multiply this time by the number of processes that you have and you get a few seconds lost. As usual, for some services, this loss is insignificant, while for others a very significant one.&lt;/p&gt;

&lt;p&gt;So why does Apache make all these redundant &lt;code&gt;stat()&lt;/code&gt; calls? You can blame the default installed &lt;code&gt;TransHandler&lt;/code&gt; for this inefficiency. Of course, you could supply your own, which will be smart enough not to look for this virtual path and immediately return &lt;code&gt;OK&lt;/code&gt;. But in cases where you have a virtual host that serves only dynamically generated documents, you can override the default &lt;code&gt;PerlTransHandler&lt;/code&gt; with this one:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;VirtualHost 10.10.10.10:80&amp;gt;
    ...
    PerlTransHandler  Apache::OK
    ...
  &amp;lt;/VirtualHost&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you see it affects only this specific virtual host.&lt;/p&gt;

&lt;p&gt;This has the effect of short circuiting the normal &lt;code&gt;TransHandler&lt;/code&gt; processing of trying to find a filesystem component that matches the given URI &amp;ndash; no more &amp;lsquo;stat&amp;rsquo;s!&lt;/p&gt;

&lt;p&gt;Watching your server under strace/truss can often reveal more performance hits than trying to optimize the code itself!&lt;/p&gt;

&lt;p&gt;For example, unless configured correctly, Apache might look for the &lt;em&gt;.htaccess&lt;/em&gt; file in many places, even if you don&amp;rsquo;t have one, and make many unnecessary &lt;code&gt;open()&lt;/code&gt; calls.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start with this simple configuration. We will try to reduce the number of irrelevant system calls.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  DocumentRoot &amp;quot;/home/httpd/docs&amp;quot;
  &amp;lt;Location /app/test&amp;gt;
    SetHandler perl-script
    PerlHandler Apache::MyApp
  &amp;lt;/Location&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above configuration allows us to make a request to &lt;em&gt;/app/test&lt;/em&gt; and the Perl &lt;code&gt;handler()&lt;/code&gt; defined in &lt;code&gt;Apache::MyApp&lt;/code&gt; will be executed. Notice that in the test setup there is no file to be executed (like in &lt;code&gt;Apache::Registry&lt;/code&gt;). There is no &lt;em&gt;.htaccess&lt;/em&gt; file as well.&lt;/p&gt;

&lt;p&gt;This is a typical generated trace.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  stat(&amp;quot;/home/httpd/docs/app/test&amp;quot;, 0xbffff8fc) = -1 ENOENT
        (No such file or directory)
  stat(&amp;quot;/home/httpd/docs/app&amp;quot;,      0xbffff8fc) = -1 ENOENT
        (No such file or directory)
  stat(&amp;quot;/home/httpd/docs&amp;quot;,
        {st_mode=S_IFDIR|0755, st_size=1024, ...}) = 0
  open(&amp;quot;/.htaccess&amp;quot;, O_RDONLY)                 = -1 ENOENT
        (No such file or directory)
  open(&amp;quot;/home/.htaccess&amp;quot;, O_RDONLY)            = -1 ENOENT
        (No such file or directory)
  open(&amp;quot;/home/httpd/.htaccess&amp;quot;, O_RDONLY)      = -1 ENOENT
        (No such file or directory)
  open(&amp;quot;/home/httpd/docs/.htaccess&amp;quot;, O_RDONLY) = -1 ENOENT
        (No such file or directory)
  stat(&amp;quot;/home/httpd/docs/test&amp;quot;, 0xbffff774)    = -1 ENOENT
        (No such file or directory)
  stat(&amp;quot;/home/httpd/docs&amp;quot;,
        {st_mode=S_IFDIR|0755, st_size=1024, ...}) = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we modify the &lt;code&gt;&amp;lt;Directory&amp;gt;&lt;/code&gt; entry and add AllowOverride None, which among other things disables &lt;em&gt;.htaccess&lt;/em&gt; files and will not try to open them.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;Directory /&amp;gt;
    AllowOverride None
  &amp;lt;/Directory&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We see that the four &lt;code&gt;open()&lt;/code&gt; calls for &lt;em&gt;.htaccess&lt;/em&gt; have gone:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  stat(&amp;quot;/home/httpd/docs/app/test&amp;quot;, 0xbffff8fc) = -1 ENOENT
        (No such file or directory)
  stat(&amp;quot;/home/httpd/docs/app&amp;quot;,      0xbffff8fc) = -1 ENOENT
        (No such file or directory)
  stat(&amp;quot;/home/httpd/docs&amp;quot;,
        {st_mode=S_IFDIR|0755, st_size=1024, ...}) = 0
  stat(&amp;quot;/home/httpd/docs/test&amp;quot;, 0xbffff774)    = -1 ENOENT
        (No such file or directory)
  stat(&amp;quot;/home/httpd/docs&amp;quot;,
        {st_mode=S_IFDIR|0755, st_size=1024, ...}) = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s try to shortcut the &lt;em&gt;app&lt;/em&gt; location with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Alias /app /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which makes Apache to look for the file in the &lt;em&gt;/&lt;/em&gt; directory and not under &lt;em&gt;/home/httpd/docs/app&lt;/em&gt;. Let&amp;rsquo;s run it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  stat(&amp;quot;//test&amp;quot;, 0xbffff8fc) = -1 ENOENT (No such file or directory)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wow, we&amp;rsquo;ve got only one stat call left!&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s remove the last &lt;code&gt;Alias&lt;/code&gt; setting and use:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    PerlTransHandler  Apache::OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;as explained above. When we issue the request, we see no &lt;code&gt;stat()&lt;/code&gt; calls. But this is possible only if you serve only dynamically generated documents, i.e. no CGI scripts. Otherwise, you will have to write your own &lt;em&gt;PerlTransHandler&lt;/em&gt; to handle requests as desired.&lt;/p&gt;

&lt;p&gt;For example, this &lt;em&gt;PerlTransHandler&lt;/em&gt; will not lookup the file on the filesystem if the URI starts with &lt;em&gt;/app&lt;/em&gt;, but will use the default &lt;em&gt;PerlTransHandler&lt;/em&gt; otherwise:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  PerlTransHandler &#39;sub { return shift-&amp;gt;uri() =~ m|^/app| \
                        ? Apache::OK : Apache::DECLINED;}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s see the same configuration using the &lt;code&gt;&amp;lt;Perl&amp;gt;&lt;/code&gt; section and a dedicated package:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;Perl&amp;gt;
    package My::Trans;
    use Apache::Constants qw(:common);
    sub handler{
       my $r = shift;
       return OK if $r-&amp;gt;uri() =~ m|^/app|;
       return DECLINED;
    }

    package Apache::ReadConfig;
    $PerlTransHandler = &amp;quot;My::Trans&amp;quot;;
  &amp;lt;/Perl&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you see we have defined the &lt;code&gt;My::Trans&lt;/code&gt; package and implemented the &lt;code&gt;handler()&lt;/code&gt; function. Then we have assigned this handler to the &lt;code&gt;PerlTransHandler&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Of course you can move the code in the module into an external file, (e.g. &lt;em&gt;My/Trans.pm&lt;/em&gt;) and configure the &lt;code&gt;PerlTransHandler&lt;/code&gt; with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  PerlTransHandler My::Trans
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in the normal way (no &lt;code&gt;&amp;lt;Perl&amp;gt;&lt;/code&gt; section required).&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;span-id-references-references-span&#34;&gt;&lt;span id=&#34;references&#34;&gt;References&lt;/span&gt;&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;The mod_perl site&amp;rsquo;s URL: &lt;a href=&#34;http://perl.apache.org/&#34;&gt;http://perl.apache.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Time::HiRes&#34;&gt;Time::HiRes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Improving mod_perl Sites&#39; Performance: Part 7</title>
      <link>http://localhost:1313/pub/2003/02/05/mod_perl.html/</link>
      <pubDate>Wed, 05 Feb 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/02/05/mod_perl.html/</guid>
      <description>

&lt;p&gt;Correct configuration of the &lt;code&gt;MinSpareServers&lt;/code&gt;, &lt;code&gt;MaxSpareServers&lt;/code&gt;, &lt;code&gt;StartServers&lt;/code&gt;, &lt;code&gt;MaxClients&lt;/code&gt;, and &lt;code&gt;MaxRequestsPerChild&lt;/code&gt; parameters is very important. There are no defaults. If they are too low, then you will underutilize the system&amp;rsquo;s capabilities. If they are too high, then chances are that the server will bring the machine to its knees.&lt;/p&gt;

&lt;p&gt;All the above parameters should be specified on the basis of the resources you have. With a plain Apache server, it&amp;rsquo;s no big deal if you run many servers since the processes are about 1Mb and don&amp;rsquo;t eat a lot of your RAM. Generally, the numbers are even smaller with memory sharing. The situation is different with mod_perl. I have seen mod_perl processes of 20Mb and more. Now, if you have &lt;code&gt;MaxClients&lt;/code&gt; set to 50, then 50x20Mb = 1Gb. Maybe you don&amp;rsquo;t have 1Gb of RAM - so how do you tune the parameters? Generally, by trying different combinations and benchmarking the server. Again, mod_perl processes can be made much smaller when memory is shared.&lt;/p&gt;

&lt;p&gt;Before you start this task, you should be armed with the proper weapon. You need the &lt;strong&gt;crashme&lt;/strong&gt; utility, which will load your server with the mod_perl scripts you possess. You need it to have the ability to emulate a multiuser environment and to emulate the behavior of multiple clients calling the mod_perl scripts on your server simultaneously. While there are commercial solutions, you can get away with free ones that do the same job. You can use the ApacheBench utility that comes with the Apache distribution, the &lt;code&gt;crashme&lt;/code&gt; script which uses &lt;code&gt;LWP::Parallel::UserAgent&lt;/code&gt;, httperf or http_load all discussed in one of the previous articles.&lt;/p&gt;

&lt;p&gt;It is important to make sure that you run the load generator (the client which generates the test requests) on a system that is more powerful than the system being tested. After all, we are trying to simulate Internet users, where many users are trying to reach your service at once. Since the number of concurrent users can be quite large, your testing machine must be very powerful and capable of generating a heavy load. Of course, you should not run the clients and the server on the same machine. If you do, then your test results would be invalid. Clients will eat CPU and memory that should be dedicated to the server, and vice versa.&lt;/p&gt;

&lt;h3 id=&#34;span-id-configuration-tuning-with-apachebench-configuration-tuning-with-apachebench-span&#34;&gt;&lt;span id=&#34;configuration_tuning_with_apachebench&#34;&gt;Configuration Tuning with ApacheBench&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;m going to use the &lt;code&gt;ApacheBench&lt;/code&gt; (&lt;code&gt;ab&lt;/code&gt;) utility to tune our server&amp;rsquo;s configuration. We will simulate 10 users concurrently requesting a very light script at &lt;code&gt;http://www.example.com/perl/access/access.cgi&lt;/code&gt;. Each simulated user makes 10 requests.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % ./ab -n 100 -c 10 http://www.example.com/perl/access/access.cgi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The results are:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Document Path:          /perl/access/access.cgi
  Document Length:        16 bytes

  Concurrency Level:      10
  Time taken for tests:   1.683 seconds
  Complete requests:      100
  Failed requests:        0
  Total transferred:      16100 bytes
  HTML transferred:       1600 bytes
  Requests per second:    59.42
  Transfer rate:          9.57 kb/s received

  Connnection Times (ms)
                min   avg   max
  Connect:        0    29   101
  Processing:    77   124  1259
  Total:         77   153  1360
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only numbers we really care about are:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Complete requests:      100
  Failed requests:        0
  Requests per second:    59.42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s raise the request load to 100 x 10 (10 users, each making 100 requests):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % ./ab -n 1000 -c 10  http://www.example.com/perl/access/access.cgi
  Concurrency Level:      10
  Complete requests:      1000
  Failed requests:        0
  Requests per second:    139.76
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As expected, nothing changes &amp;ndash; we have the same 10 concurrent users. Now let&amp;rsquo;s raise the number of concurrent users to 50:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % ./ab -n 1000 -c 50  http://www.example.com/perl/access/access.cgi
  Complete requests:      1000
  Failed requests:        0
  Requests per second:    133.01
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We see that the server is capable of serving 50 concurrent users at 133 requests per second! Let&amp;rsquo;s find the upper limit. Using &lt;code&gt;-n 10000 -c 1000&lt;/code&gt; failed to get results (Broken Pipe?). Using &lt;code&gt;-n 10000 -c 500&lt;/code&gt; resulted in 94.82 requests per second. The server&amp;rsquo;s performance went down with the high load.&lt;/p&gt;

&lt;p&gt;The above tests were performed with the following configuration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  MinSpareServers 8
  MaxSpareServers 6
  StartServers 10
  MaxClients 50
  MaxRequestsPerChild 1500
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s kill each child after it serves a single request. We will use the following configuration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  MinSpareServers 8
  MaxSpareServers 6
  StartServers 10
  MaxClients 100
  MaxRequestsPerChild 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Simulate 50 users each generating a total of 20 requests:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % ./ab -n 1000 -c 50  http://www.example.com/perl/access/access.cgi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The benchmark timed out with the above configuration. I watched the output of &lt;strong&gt;&lt;code&gt;ps&lt;/code&gt;&lt;/strong&gt; as I ran it, the parent process just wasn&amp;rsquo;t capable of respawning the killed children at that rate. When I raised the &lt;code&gt;MaxRequestsPerChild&lt;/code&gt; to 10, I got 8.34 requests per second. Very bad - 18 times slower! You can&amp;rsquo;t benchmark the importance of the &lt;code&gt;MinSpareServers&lt;/code&gt;, &lt;code&gt;MaxSpareServers&lt;/code&gt; and &lt;code&gt;StartServers&lt;/code&gt; with this type of test.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s reset &lt;code&gt;MaxRequestsPerChild&lt;/code&gt; to 1500, but reduce &lt;code&gt;MaxClients&lt;/code&gt; to 10 and run the same test:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  MinSpareServers 8
  MaxSpareServers 6
  StartServers 10
  MaxClients 10
  MaxRequestsPerChild 1500
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I got 27.12 requests per second, which is better but still four to five times slower. (I got 133 with &lt;code&gt;MaxClients&lt;/code&gt; set to 50.)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Summary:&lt;/strong&gt; I have tested a few combinations of the server configuration variables (&lt;code&gt;MinSpareServers&lt;/code&gt;, &lt;code&gt;MaxSpareServers&lt;/code&gt;, &lt;code&gt;StartServers&lt;/code&gt;, &lt;code&gt;MaxClients&lt;/code&gt; and &lt;code&gt;MaxRequestsPerChild&lt;/code&gt;). The results I got are as follows:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MinSpareServers&lt;/code&gt;, &lt;code&gt;MaxSpareServers&lt;/code&gt; and &lt;code&gt;StartServers&lt;/code&gt; are only important for user response times. Sometimes users will have to wait a bit.&lt;/p&gt;

&lt;p&gt;The important parameters are &lt;code&gt;MaxClients&lt;/code&gt; and &lt;code&gt;MaxRequestsPerChild&lt;/code&gt;. &lt;code&gt;MaxClients&lt;/code&gt; should be not too big, so it will not abuse your machine&amp;rsquo;s memory resources, and not too small, for if it is, your users will be forced to wait for the children to become free to serve them. &lt;code&gt;MaxRequestsPerChild&lt;/code&gt; should be as large as possible, to get the full benefit of mod_perl, but watch your server at the beginning to make sure your scripts are not leaking memory, thereby causing your server (and your service) to die very fast.&lt;/p&gt;

&lt;p&gt;Also, it is important to understand that we didn&amp;rsquo;t test the response times in the tests above, but the ability of the server to respond under a heavy load of requests. If the test script was heavier, then the numbers would be different but the conclusions similar.&lt;/p&gt;

&lt;p&gt;The benchmarks were run with:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HW: RS6000, 1Gb RAM&lt;/li&gt;
&lt;li&gt;SW: AIX 4.1.5 . mod_perl 1.16, apache 1.3.3&lt;/li&gt;
&lt;li&gt;Machine running only mysql, httpd docs and mod_perl servers.&lt;/li&gt;
&lt;li&gt;Machine was _completely_ unloaded during the benchmarking.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;After each server restart when I changed the server&amp;rsquo;s configuration, I made sure that the scripts were preloaded by fetching a script at least once for every child.&lt;/p&gt;

&lt;p&gt;It is important to notice that none of the requests timed out, even if it was kept in the server&amp;rsquo;s queue for more than a minute! That is the way &lt;strong&gt;ab&lt;/strong&gt; works, which is OK for testing purposes but will be unacceptable in the real world - users will not wait for more than five to 10 seconds for a request to complete, and the client (i.e. the browser) will time out in a few minutes.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s take a look at some real code whose execution time is more than a few milliseconds. We will do some real testing and collect the data into tables for easier viewing.&lt;/p&gt;

&lt;p&gt;I will use the following abbreviations:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  NR    = Total Number of Request
  NC    = Concurrency
  MC    = MaxClients
  MRPC  = MaxRequestsPerChild
  RPS   = Requests per second
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running a mod_perl script with lots of mysql queries (the script under test is mysqld limited) (&lt;a href=&#34;http://www.example.com/perl/access/access.cgi?do_sub=query_form&#34;&gt;http://www.example.com/perl/access/access.cgi?do_sub=query_form&lt;/a&gt;), with the configuration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  MinSpareServers        8
  MaxSpareServers       16
  StartServers          10
  MaxClients            50
  MaxRequestsPerChild 5000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gives us:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     NR   NC    RPS     comment
  ------------------------------------------------
     10   10    3.33    # not a reliable figure
    100   10    3.94
   1000   10    4.62
   1000   50    4.09
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Conclusions:&lt;/strong&gt; Here I wanted to show that when the application is slow (not due to perl loading, code compilation and execution, but limited by some external operation) it almost does not matter what load we place on the server. The RPS (Requests per second) is almost the same. Given that all the requests have been served, you have the ability to queue the clients, but be aware that anything that goes into the queue means a waiting client and a client (browser) that might time out!&lt;/p&gt;

&lt;p&gt;Now we will benchmark the same script without using the mysql (code limited by perl only): (&lt;a href=&#34;http://www.example.com/perl/access/access.cgi&#34;&gt;http://www.example.com/perl/access/access.cgi&lt;/a&gt;), it&amp;rsquo;s the same script but it just returns the HTML form, without making SQL queries.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  MinSpareServers        8
  MaxSpareServers       16
  StartServers          10
  MaxClients            50
  MaxRequestsPerChild 5000

     NR   NC      RPS   comment
  ------------------------------------------------
     10   10    26.95   # not a reliable figure
    100   10    30.88
   1000   10    29.31
   1000   50    28.01
   1000  100    29.74
  10000  200    24.92
 100000  400    24.95
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Conclusions:&lt;/strong&gt; This time the script we executed was pure perl (not limited by I/O or mysql), so we see that the server serves the requests much faster. You can see the number of requests per second is almost the same for any load, but goes lower when the number of concurrent clients goes beyond &lt;code&gt;MaxClients&lt;/code&gt;. With 25 RPS, the machine simulating a load of 400 concurrent clients will be served in 16 seconds. To be more realistic, assuming a maximum of 100 concurrent clients and 30 requests per second, the client will be served in 3.5 seconds. Pretty good for a highly loaded server.&lt;/p&gt;

&lt;p&gt;Now we will use the server to its full capacity, by keeping all &lt;code&gt;MaxClients&lt;/code&gt; clients alive all the time and having a big &lt;code&gt;MaxRequestsPerChild&lt;/code&gt;, so that no child will be killed during the benchmarking.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  MinSpareServers       50
  MaxSpareServers       50
  StartServers          50
  MaxClients            50
  MaxRequestsPerChild 5000

     NR   NC      RPS   comment
  ------------------------------------------------
    100   10    32.05
   1000   10    33.14
   1000   50    33.17
   1000  100    31.72
  10000  200    31.60
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Conclusion: In this scenario, there is no overhead involving the parent server loading new children, all the servers are available, and the only bottleneck is contention for the CPU.&lt;/p&gt;

&lt;p&gt;Now we will change &lt;code&gt;MaxClients&lt;/code&gt; and watch the results: Let&amp;rsquo;s reduce &lt;code&gt;MaxClients&lt;/code&gt; to 10.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  MinSpareServers        8
  MaxSpareServers       10
  StartServers          10
  MaxClients            10
  MaxRequestsPerChild 5000

     NR   NC      RPS   comment
  ------------------------------------------------
     10   10    23.87   # not a reliable figure
    100   10    32.64
   1000   10    32.82
   1000   50    30.43
   1000  100    25.68
   1000  500    26.95
   2000  500    32.53
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Conclusions:&lt;/strong&gt; Very little difference! Ten servers were able to serve almost with the same throughput as 50. Why? My guess is because of CPU throttling. It seems that 10 servers were serving requests five times faster than when we worked with 50 servers. In that case, each child received its CPU time slice five times less frequently. So having a big value for &lt;code&gt;MaxClients&lt;/code&gt;, doesn&amp;rsquo;t mean that the performance will be better. You have just seen the numbers!&lt;/p&gt;

&lt;p&gt;Now we will start drastically to reduce &lt;code&gt;MaxRequestsPerChild&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  MinSpareServers        8
  MaxSpareServers       16
  StartServers          10
  MaxClients            50

     NR   NC    MRPC     RPS    comment
  ------------------------------------------------
    100   10      10    5.77
    100   10       5    3.32
   1000   50      20    8.92
   1000   50      10    5.47
   1000   50       5    2.83
   1000  100      10    6.51
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Conclusions:&lt;/strong&gt; When we drastically reduce &lt;code&gt;MaxRequestsPerChild&lt;/code&gt;, the performance starts to become closer to plain mod_cgi.&lt;/p&gt;

&lt;p&gt;Here are the numbers of this run with mod_cgi, for comparison:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  MinSpareServers        8
  MaxSpareServers       16
  StartServers          10
  MaxClients            50

     NR   NC    RPS     comment
  ------------------------------------------------
    100   10    1.12
   1000   50    1.14
   1000  100    1.13
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Conclusion&lt;/strong&gt;: mod_cgi is much slower. :) In the first test, when NR/NC was &lt;sup&gt;100&lt;/sup&gt;&amp;frasl;&lt;sub&gt;10&lt;/sub&gt;, mod_cgi was capable of 1.12 requests per second. In the same circumstances, mod_perl was capable of 32 requests per second, nearly 30 times faster! In the first test, each client waited about 100 seconds to be served. In the second and third tests, they waited 1,000 seconds!&lt;/p&gt;

&lt;h3 id=&#34;span-id-choosing-maxclients-choosing-maxclients-span&#34;&gt;&lt;span id=&#34;choosing_maxclients&#34;&gt;Choosing MaxClients&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;MaxClients&lt;/code&gt; directive sets the limit on the number of simultaneous requests that can be supported. No more than this number of child server processes will be created. To configure more than 256 clients, you must edit the &lt;code&gt;HARD_SERVER_LIMIT&lt;/code&gt; entry in &lt;code&gt;httpd.h&lt;/code&gt; and recompile. In our case, we want this variable to be as small as possible, so we can limit the resources used by the server children. Since we can restrict each child&amp;rsquo;s process size with &lt;code&gt;Apache::SizeLimit&lt;/code&gt; or &lt;code&gt;Apache::GTopLimit&lt;/code&gt;, the calculation of &lt;code&gt;MaxClients&lt;/code&gt; is pretty straightforward:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;               Total RAM Dedicated to the Webserver
  MaxClients = ------------------------------------
                     MAX child&#39;s process size
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So if I have 400Mb left for the Web server to run with, then I can set &lt;code&gt;MaxClients&lt;/code&gt; to be of 40 if I know that each child is limited to 10Mb of memory (e.g. with &lt;code&gt;Apache::SizeLimit&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;You will be wondering what will happen to your server if there are more concurrent users than &lt;code&gt;MaxClients&lt;/code&gt; at any time. This situation is signified by the following warning message in the &lt;code&gt;error_log&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  [Sun Jan 24 12:05:32 1999] [error] server reached MaxClients setting,
  consider raising the MaxClients setting
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is no problem &amp;ndash; any connection attempts over the &lt;code&gt;MaxClients&lt;/code&gt; limit will normally be queued, up to a number based on the &lt;code&gt;ListenBacklog&lt;/code&gt; directive. When a child process is freed at the end of a different request, the connection will be served.&lt;/p&gt;

&lt;p&gt;It &lt;strong&gt;is an error&lt;/strong&gt; because clients are being put in the queue rather than getting served immediately, despite the fact that they do not get an error response. The error can be allowed to persist to balance available system resources and response time, but sooner or later you will need to get more RAM so you can start more child processes. The best approach is to try not to have this condition reached at all, and if you reach it often you should start to worry about it.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s important to understand how much real memory a child occupies. Your children can share memory between them when the OS supports that. You must take action to allow the sharing to happen. We have disscussed this in one of the previous article whose main topic was shared memory. If you do this, then chances are that your &lt;code&gt;MaxClients&lt;/code&gt; can be even higher. But it seems that it&amp;rsquo;s not so simple to calculate the absolute number. If you come up with a solution, then please let us know! If the shared memory was of the same size throughout the child&amp;rsquo;s life, then we could derive a much better formula:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;               Total_RAM + Shared_RAM_per_Child * (MaxClients - 1)
  MaxClients = ---------------------------------------------------
                              Max_Process_Size
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                    Total_RAM - Shared_RAM_per_Child
  MaxClients = ---------------------------------------
               Max_Process_Size - Shared_RAM_per_Child
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s roll some calculations:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Total_RAM            = 500Mb
  Max_Process_Size     =  10Mb
  Shared_RAM_per_Child =   4Mb

              500 - 4
 MaxClients = --------- = 82
               10 - 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With no sharing in place&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                 500
 MaxClients = --------- = 50
                 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With sharing in place you can have 64 percent more servers without buying more RAM.&lt;/p&gt;

&lt;p&gt;If you improve sharing and keep the sharing level, let&amp;rsquo;s say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Total_RAM            = 500Mb
  Max_Process_Size     =  10Mb
  Shared_RAM_per_Child =   8Mb

              500 - 8
 MaxClients = --------- = 246
               10 - 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;392 percent more servers! Now you can feel the importance of having as much shared memory as possible.&lt;/p&gt;

&lt;h3 id=&#34;span-id-choosing-maxrequestsperchild-choosing-maxrequestsperchild-span&#34;&gt;&lt;span id=&#34;choosing_maxrequestsperchild&#34;&gt;Choosing MaxRequestsPerChild&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;MaxRequestsPerChild&lt;/code&gt; directive sets the limit on the number of requests that an individual child server process will handle. After &lt;code&gt;MaxRequestsPerChild&lt;/code&gt; requests, the child process will die. If &lt;code&gt;MaxRequestsPerChild&lt;/code&gt; is 0, then the process will live forever.&lt;/p&gt;

&lt;p&gt;Setting &lt;code&gt;MaxRequestsPerChild&lt;/code&gt; to a non-zero limit solves some memory leakage problems caused by sloppy programming practices, whereas a child process consumes more memory after each request.&lt;/p&gt;

&lt;p&gt;If left unbounded, then after a certain number of requests the children will use up all the available memory and leave the server to die from memory starvation. Note that sometimes standard system libraries leak memory too, especially on OSes with bad memory management (e.g. Solaris 2.5 on x86 arch).&lt;/p&gt;

&lt;p&gt;If this is your case, then you can set &lt;code&gt;MaxRequestsPerChild&lt;/code&gt; to a small number. This will allow the system to reclaim the memory that a greedy child process consumed, when it exits after &lt;code&gt;MaxRequestsPerChild&lt;/code&gt; requests.&lt;/p&gt;

&lt;p&gt;But beware &amp;ndash; if you set this number too low, you will lose some of the speed bonus you get from mod_perl. Consider using &lt;code&gt;Apache::PerlRun&lt;/code&gt; if this is the case.&lt;/p&gt;

&lt;p&gt;Another approach is to use the &lt;code&gt;Apache::SizeLimit&lt;/code&gt; or the &lt;code&gt;Apache::GTopLimit&lt;/code&gt; modules. By using either of these modules you should be able to discontinue using the &lt;code&gt;MaxRequestPerChild&lt;/code&gt;, although for some developers, using both in combination does the job. In addition the latter module allows you to kill any servers whose shared memory size drops below a specified limit.&lt;/p&gt;

&lt;h1 id=&#34;span-id-references-references-span&#34;&gt;&lt;span id=&#34;references&#34;&gt;References&lt;/span&gt;&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;The mod_perl site&amp;rsquo;s URL: &lt;a href=&#34;http://perl.apache.org/&#34;&gt;http://perl.apache.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Apache::GTopLimit&#34;&gt;Apache::GTopLimit&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Improving mod_perl Sites&#39; Performance: Part 6</title>
      <link>http://localhost:1313/pub/2003/01/07/mod_perl.html/</link>
      <pubDate>Tue, 07 Jan 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/01/07/mod_perl.html/</guid>
      <description>

&lt;p&gt;It&amp;rsquo;s desirable to avoid forking under &lt;code&gt;mod_perl&lt;/code&gt;, as when you do, you are forking the entire Apache server &amp;ndash; lock, stock and barrel. Not only is your Perl code and Perl interpreter being duplicated, but so is &lt;code&gt;mod_ssl&lt;/code&gt;, &lt;code&gt;mod_rewrite&lt;/code&gt;, &lt;code&gt;mod_log&lt;/code&gt;, &lt;code&gt;mod_proxy&lt;/code&gt;, &lt;code&gt;mod_speling&lt;/code&gt; (it&amp;rsquo;s not a typo!) or whatever modules you have used in your server, all the core routines.&lt;/p&gt;

&lt;p&gt;Modern operating systems come with a light version of fork, which adds a little overhead when called, since it was optimized to do the absolute minimum of memory pages duplications. The &lt;em&gt;copy-on-write&lt;/em&gt; technique is what allows it to do so. The gist of this technique is as follows: The parent process&amp;rsquo; memory pages aren&amp;rsquo;t immediately copied to the child&amp;rsquo;s space on fork(); this is done only when the child or the parent modifies the data in some memory pages. Before the pages get modified, they get marked as dirty and the child has no choice but to copy the pages that are to be modified since they cannot be shared any more.&lt;/p&gt;

&lt;p&gt;If you need to call a Perl program from your &lt;code&gt;mod_perl&lt;/code&gt; code, then it&amp;rsquo;s better to try to covert the program into a module and call it as a function without spawning a special process to do that. Of course, if you cannot do that or the program is not written in Perl, then you have to call via &lt;code&gt;system()&lt;/code&gt; or its equivalent, which spawns a new process. If the program is written in C, then you can try to write a Perl glue code with help of XS or SWIG architectures, and then the program will be executed as a Perl subroutine.&lt;/p&gt;

&lt;p&gt;Also, by trying to spawn a sub-process, you might be trying to do the &lt;em&gt;&amp;ldquo;wrong thing&amp;rdquo;&lt;/em&gt;. If what you really want is to send information to the browser and then do some post-processing, then look into the &lt;code&gt;PerlCleanupHandler&lt;/code&gt; directive. The latter allows you to tell the child process after request has been processed and user has received the response. This doesn&amp;rsquo;t release the &lt;code&gt;mod_perl&lt;/code&gt; process to serve other requests, but it allows you to send the response to the client faster. If this is the situation and you need to run some cleanup code, then you may want to register this code during the request processing stage like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my $r = shift;
  $r-&amp;gt;register_cleanup(\&amp;amp;do_cleanup);
  sub do_cleanup{ #some clean-up code here }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But when a long-term process needs to be spawned, there is not much choice but to use fork(). We cannot just run this process within the Apache process because it&amp;rsquo;ll keep the Apache process busy, instead of allowing it to do the job it was designed to do. Also, if Apache stops, then the long-term process might be terminated as well unless coded properly to detach from Apache&amp;rsquo;s process group.&lt;/p&gt;

&lt;p&gt;In the following sections, I&amp;rsquo;m going to discuss how to properly spawn new processes under &lt;code&gt;mod_perl&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-forking-a-new-process-forking-a-new-process-span&#34;&gt;&lt;span id=&#34;forking_a_new_process&#34;&gt;Forking a New Process&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;This is a typical way to call &lt;code&gt;fork()&lt;/code&gt; under &lt;code&gt;mod_perl&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  defined (my $kid = fork) or die &amp;quot;Cannot fork: $!\n&amp;quot;;
  if ($kid) {
    # Parent runs this block
  } else {
    # Child runs this block
    # some code comes here
    CORE::exit(0);
  }
  # possibly more code here usually run by the parent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When using fork(), you should check its return value, because if it returns &lt;code&gt;undef&lt;/code&gt;, it means that the call was unsuccessful and no process was spawned; something that can happen when the system is running too many processes and cannot spawn new ones.&lt;/p&gt;

&lt;p&gt;When the process is successfully forked, the parent receives the PID of the newly spawned child as a returned value of the &lt;code&gt;fork()&lt;/code&gt; call and the child receives 0. Now the program splits into two. In the above example, the code inside the first block after &lt;em&gt;if&lt;/em&gt; will be executed by the parent and the code inside the first block after &lt;em&gt;else&lt;/em&gt; will be executed by the child process.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s important not to forget to explicitly call &lt;code&gt;exit()&lt;/code&gt; at the end of the child code when forking - if you don&amp;rsquo;t and there is some code outside the &lt;em&gt;if/else block&lt;/em&gt;, then the child process will execute it as well. But under &lt;code&gt;mod_perl&lt;/code&gt; there is another nuance: You must use &lt;code&gt;CORE::exit()&lt;/code&gt; and not &lt;code&gt;exit()&lt;/code&gt;, which would be automatically overriden by &lt;code&gt;Apache::exit()&lt;/code&gt; if used in conjunction with &lt;code&gt;Apache::Registry&lt;/code&gt; and similar modules. We actually do want the spawned process to quit when its work is done, otherwise, it&amp;rsquo;ll just stay alive, use resources and do nothing.&lt;/p&gt;

&lt;p&gt;The parent process usually completes its execution path and enters the pool of free servers to wait for a new assignment. If the execution path is to be aborted earlier for some reason, then one should use Apache::exit() or die(). In the case of &lt;code&gt;Apache::Registry&lt;/code&gt; or &lt;code&gt;Apache::PerlRun&lt;/code&gt; handlers, a simple &lt;code&gt;exit()&lt;/code&gt; will do the correct thing.&lt;/p&gt;

&lt;p&gt;The child shares with parent its memory pages until it has to modify some of them, which triggers a &lt;em&gt;copy-on-write&lt;/em&gt; process that copies these pages to the child&amp;rsquo;s domain before the child is allowed to modify them. But this all happens afterward. At the moment the &lt;code&gt;fork()&lt;/code&gt; call is executed, the only work to be done before the child process goes on its separate way is to set up the page tables for the virtual memory, which imposes almost no delay at all.&lt;/p&gt;

&lt;h3 id=&#34;span-id-freeing-the-parent-process-freeing-the-parent-process-span&#34;&gt;&lt;span id=&#34;freeing_the_parent_process&#34;&gt;Freeing the Parent Process&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In the child code, you must also close all pipes to the connection socket that were opened by the parent process (i.e. &lt;code&gt;STDIN&lt;/code&gt; and &lt;code&gt;STDOUT&lt;/code&gt;) and inherited by the child, so the parent will be able to complete the request and free itself for serving other requests. If you need the &lt;code&gt;STDIN&lt;/code&gt; and/or &lt;code&gt;STDOUT&lt;/code&gt; streams, then you should reopen them. You may need to close or reopen the &lt;code&gt;STDERR&lt;/code&gt; filehandle. It&amp;rsquo;s opened to append to the &lt;em&gt;error_log&lt;/em&gt; file as inherited from its parent, so chances are that you will want to leave it untouched.&lt;/p&gt;

&lt;p&gt;Under &lt;code&gt;mod_perl&lt;/code&gt;, the spawned process also inherits a file descriptor that&amp;rsquo;s tied to the socket through which all communication between the server and the client occur. Therefore, we need to free this stream in the forked process. If we don&amp;rsquo;t do that, then the server cannot be restarted while the spawned process is still running. If an attempt is made to restart the server, then you will get the following error:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  [Mon Dec 11 19:04:13 2000] [crit]
  (98)Address already in use: make_sock:
    could not bind to address 127.0.0.1 port 8000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Apache::SubProcess&lt;/code&gt; comes to our aid and provides a method &lt;code&gt;cleanup_for_exec()&lt;/code&gt;, which takes care of closing this file descriptor.&lt;/p&gt;

&lt;p&gt;So the simplest way to free the parent process is to close all three &lt;code&gt;STD*&lt;/code&gt; streams if we don&amp;rsquo;t need them, and untie the Apache socket. In addition, you may want to change the process&amp;rsquo; current directory to &lt;em&gt;/&lt;/em&gt; so the forked process won&amp;rsquo;t keep the mounted partition busy, if this is to be unmounted at a later time. To summarize all this issues, here is an example of the fork that takes care of freeing the parent process.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use Apache::SubProcess;
  defined (my $kid = fork) or die &amp;quot;Cannot fork: $!\n&amp;quot;;
  if ($kid) {
    # Parent runs this block
  } else {
    # Child runs this block
      $r-&amp;gt;cleanup_for_exec(); # untie the socket
      chdir &#39;/&#39; or die &amp;quot;Can&#39;t chdir to /: $!&amp;quot;;
      close STDIN;
      close STDOUT;
      close STDERR;

    # some code comes here

      CORE::exit(0);
  }
  # possibly more code here usually run by the parent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, between the freeing-parent code and child-process termination, the real code is to be placed.&lt;/p&gt;

&lt;h3 id=&#34;span-id-detaching-the-forked-process-detaching-the-forked-process-span&#34;&gt;&lt;span id=&#34;detaching_the_forked_process&#34;&gt;Detaching the Forked Process&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Now what happens if the forked process is running and we decide that we need to restart the Web server? This forked process will be aborted, since when the parent process dies during the restart, it&amp;rsquo;ll kill its child processes as well. In order to avoid this, we need to detach the process from its parent session by opening a new session. We do this with help of &lt;code&gt;setsid()&lt;/code&gt; system call, provided by the &lt;code&gt;POSIX&lt;/code&gt; module:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use POSIX &#39;setsid&#39;;

  defined (my $kid = fork) or die &amp;quot;Cannot fork: $!\n&amp;quot;;
  if ($kid) {
    # Parent runs this block
  } else {
    # Child runs this block
      setsid or die &amp;quot;Can&#39;t start a new session: $!&amp;quot;;
      ...
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the spawned child process has a life of its own, and it doesn&amp;rsquo;t depend on the parent any longer.&lt;/p&gt;

&lt;h3 id=&#34;span-id-avoiding-zombie-processes-avoiding-zombie-processes-span&#34;&gt;&lt;span id=&#34;avoiding_zombie_processes&#34;&gt;Avoiding Zombie Processes&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Now let&amp;rsquo;s talk about zombie processes.&lt;/p&gt;

&lt;p&gt;Normally, every process has its parent. Many processes are children of the &lt;code&gt;init&lt;/code&gt; process, whose &lt;code&gt;PID&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;. When you fork a process, you must &lt;code&gt;wait()&lt;/code&gt; or &lt;code&gt;waitpid()&lt;/code&gt; for it to finish. If you don&amp;rsquo;t &lt;code&gt;wait()&lt;/code&gt; for it, then it becomes a zombie.&lt;/p&gt;

&lt;p&gt;A zombie is a process that doesn&amp;rsquo;t have a parent. When the child quits, it reports the termination to its parent. If no parent wait()s to collect the exit status of the child, then it gets &lt;em&gt;&amp;ldquo;confused&amp;rdquo;&lt;/em&gt; and becomes a ghost process. This process can be seen as a process, but not killed. It will be killed only when you stop the parent process that spawned it!&lt;/p&gt;

&lt;p&gt;Generally, the &lt;code&gt;ps(1)&lt;/code&gt; utility displays these processes with the &lt;code&gt;&amp;lt;defunct&amp;gt;&lt;/code&gt; tag, and you will see the zombies counter increment when doing top(). These zombie processes can take up system resources and are generally undesirable.&lt;/p&gt;

&lt;p&gt;So the proper way to do a fork is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my $r = shift;
  $r-&amp;gt;send_http_header(&#39;text/plain&#39;);

  defined (my $kid = fork) or die &amp;quot;Cannot fork: $!&amp;quot;;
  if ($kid) {
    waitpid($kid,0);
    print &amp;quot;Parent has finished\n&amp;quot;;
  } else {
      # do something
      CORE::exit(0);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In most cases, the only reason you would want to fork is when you need to spawn a process that will take a long time to complete. So if the Apache process that spawns this new child process has to wait for it to finish, then you have gained nothing. You can neither wait for its completion (because you don&amp;rsquo;t have the time to), nor continue because you will get yet another zombie process. This is called a blocking call, since the process is blocked to do anything else before this call gets completed.&lt;/p&gt;

&lt;p&gt;The simplest solution is to ignore your dead children. Just add this line before the &lt;code&gt;fork()&lt;/code&gt; call:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $SIG{CHLD} = &#39;IGNORE&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you set the &lt;code&gt;CHLD&lt;/code&gt; (&lt;code&gt;SIGCHLD&lt;/code&gt; in C) signal handler to &lt;code&gt;&#39;IGNORE&#39;&lt;/code&gt;, all the processes will be collected by the &lt;code&gt;init&lt;/code&gt; process and are therefore prevented from becoming zombies. This doesn&amp;rsquo;t work everywhere, however. It proved to work at least on the Linux OS.&lt;/p&gt;

&lt;p&gt;Note that you cannot localize this setting with &lt;code&gt;local()&lt;/code&gt;. If you do, then it won&amp;rsquo;t have the desired effect.&lt;/p&gt;

&lt;p&gt;So now the code would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my $r = shift;
  $r-&amp;gt;send_http_header(&#39;text/plain&#39;);

  $SIG{CHLD} = &#39;IGNORE&#39;;

  defined (my $kid = fork) or die &amp;quot;Cannot fork: $!\n&amp;quot;;
  if ($kid) {
    print &amp;quot;Parent has finished\n&amp;quot;;
  } else {
      # do something time-consuming
      CORE::exit(0);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that &lt;code&gt;waitpid()&lt;/code&gt; call is gone. The $SIG{CHLD} = &amp;rsquo;IGNORE&amp;rsquo;; statement protects us from zombies, as explained above.&lt;/p&gt;

&lt;p&gt;Another, more portable but slightly more expensive solution, is to use a double fork approach.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my $r = shift;
  $r-&amp;gt;send_http_header(&#39;text/plain&#39;);

  defined (my $kid = fork) or die &amp;quot;Cannot fork: $!\n&amp;quot;;
  if ($kid) {
    waitpid($kid,0);
  } else {
    defined (my $grandkid = fork) or die &amp;quot;Kid cannot fork: $!\n&amp;quot;;
    if ($grandkid) {
      CORE::exit(0);
    } else {
      # code here
      # do something long lasting
      CORE::exit(0);
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$grandkid&lt;/code&gt; becomes a &lt;em&gt;&amp;ldquo;child of init&amp;rdquo;&lt;/em&gt;, i.e. the child of the process whose PID is 1.&lt;/p&gt;

&lt;p&gt;Note that the previous two solutions do allow you to know the exit status of the process, but in my example I didn&amp;rsquo;t care about it.&lt;/p&gt;

&lt;p&gt;Another solution is to use a different &lt;em&gt;SIGCHLD&lt;/em&gt; handler:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use POSIX &#39;WNOHANG&#39;;
  $SIG{CHLD} = sub { while( waitpid(-1,WNOHANG)&amp;gt;0 ) {} };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is useful when you &lt;code&gt;fork()&lt;/code&gt; more than one process. The handler could call &lt;code&gt;wait()&lt;/code&gt; as well, but for a variety of reasons involving the handling of stopped processes and the rare event when two children exit at nearly the same moment, the best technique is to call &lt;code&gt;waitpid()&lt;/code&gt; in a tight loop with a first argument of &lt;code&gt;-1&lt;/code&gt; and a second argument of &lt;code&gt;WNOHANG&lt;/code&gt;. Together, these arguments tell &lt;code&gt;waitpid()&lt;/code&gt; to reap the next child that&amp;rsquo;s available, and prevent the call from blocking if there happens to be no child ready for reaping. The handler will loop until &lt;code&gt;waitpid()&lt;/code&gt; returns a negative number or zero, indicating that no additional reapable children remain.&lt;/p&gt;

&lt;p&gt;While you test and debug your code that uses one of the above examples, you might want to write some debug information to the error_log file so you know what happens.&lt;/p&gt;

&lt;p&gt;Read &lt;em&gt;perlipc&lt;/em&gt; manpage for more information about signal handlers.&lt;/p&gt;

&lt;h3 id=&#34;span-id-a-complete-fork-example-a-complete-fork-example-span&#34;&gt;&lt;span id=&#34;a_complete_fork_example&#34;&gt;A Complete Fork Example&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Now let&amp;rsquo;s put all the bits of code together and show a well-written fork code that solves all the problems discussed so far. I will use an &amp;lt;Apache::Registry&amp;gt; script for this purpose:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  proper_fork1.pl
  ---------------
  use strict;
  use POSIX &#39;setsid&#39;;
  use Apache::SubProcess;

  my $r = shift;
  $r-&amp;gt;send_http_header(&amp;quot;text/plain&amp;quot;);

  $SIG{CHLD} = &#39;IGNORE&#39;;
  defined (my $kid = fork) or die &amp;quot;Cannot fork: $!\n&amp;quot;;
  if ($kid) {
    print &amp;quot;Parent $$ has finished, kid&#39;s PID: $kid\n&amp;quot;;
  } else {
      $r-&amp;gt;cleanup_for_exec(); # untie the socket
      chdir &#39;/&#39;                or die &amp;quot;Can&#39;t chdir to /: $!&amp;quot;;
      open STDIN, &#39;/dev/null&#39;  or die &amp;quot;Can&#39;t read /dev/null: $!&amp;quot;;
      open STDOUT, &#39;&amp;gt;/dev/null&#39;
          or die &amp;quot;Can&#39;t write to /dev/null: $!&amp;quot;;
      open STDERR, &#39;&amp;gt;/tmp/log&#39; or die &amp;quot;Can&#39;t write to /tmp/log: $!&amp;quot;;
      setsid or die &amp;quot;Can&#39;t start a new session: $!&amp;quot;;

      select STDERR;
      local $| = 1;
      warn &amp;quot;started\n&amp;quot;;
      # do something time-consuming
      sleep 1, warn &amp;quot;$_\n&amp;quot; for 1..20;
      warn &amp;quot;completed\n&amp;quot;;

      CORE::exit(0); # terminate the process
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The script starts with the usual declaration of the strict mode, loading the &lt;code&gt;POSIX&lt;/code&gt; and &lt;code&gt;Apache::SubProcess&lt;/code&gt; modules and importing of the &lt;code&gt;setsid()&lt;/code&gt; symbol from the &lt;code&gt;POSIX&lt;/code&gt; package.&lt;/p&gt;

&lt;p&gt;The HTTP header is sent next, with the &lt;em&gt;Content-type&lt;/em&gt; of &lt;em&gt;text/plain&lt;/em&gt;. The gets ready to ignore the child, to avoid zombies and the fork is called.&lt;/p&gt;

&lt;p&gt;The program gets its personality split after &lt;code&gt;fork&lt;/code&gt; and the &lt;code&gt;if&lt;/code&gt; conditional evaluates to a true value for the parent process, and to a false value for the child process; the first block is executed by the parent and the second by the child.&lt;/p&gt;

&lt;p&gt;The parent process announces his PID and the PID of the spawned process and finishes its block. If there will be any code outside, then it will be executed by the parent as well.&lt;/p&gt;

&lt;p&gt;The child process starts its code by disconnecting from the socket, changing its current directory to &lt;code&gt;/&lt;/code&gt;, opening the STDIN and STDOUT streams to &lt;em&gt;/dev/null&lt;/em&gt;, which in effect closes them both before opening. In fact, in this example we don&amp;rsquo;t need neither of these, so I could just &lt;code&gt;close()&lt;/code&gt; both. The child process completes its disengagement from the parent process by opening the STDERR stream to &lt;em&gt;/tmp/log&lt;/em&gt;, so it could write there, and creating a new session with help of setsid(). Now the child process has nothing to do with the parent process and can do the actual processing that it has to do. In our example, it performs a simple series of warnings, which are logged into &lt;em&gt;/tmp/log&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      select STDERR;
      local $|=1;
      warn &amp;quot;started\n&amp;quot;;
      # do something time-consuming
      sleep 1, warn &amp;quot;$_\n&amp;quot; for 1..20;
      warn &amp;quot;completed\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The localized setting of &lt;code&gt;$|=1&lt;/code&gt; is there, so we can see the output generated by the program immediately. In fact, it&amp;rsquo;s not required when the output is generated by warn().&lt;/p&gt;

&lt;p&gt;Finally, the child process terminates by calling:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      CORE::exit(0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which makes sure that it won&amp;rsquo;t get out of the block and run some code that it&amp;rsquo;s not supposed to run.&lt;/p&gt;

&lt;p&gt;This code example will allow you to verify that indeed the spawned child process has its own life, and its parent is free as well. Simply issue a request that will run this script, watch that the warnings are started to be written into the &lt;em&gt;/tmp/log&lt;/em&gt; file and issue a complete server stop and start. If everything is correct, then the server will successfully restart and the long-term process will still be running. You will know that it&amp;rsquo;s still running if the warnings will still be printed into the &lt;em&gt;/tmp/log&lt;/em&gt; file. You may need to raise the number of warnings to do above 20, to make sure that you don&amp;rsquo;t miss the end of the run.&lt;/p&gt;

&lt;p&gt;If there are only five warnings to be printed, then you should see the following output in this file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  started
  1
  2
  3
  4
  5
  completed
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-starting-a-long-running-external-program-starting-a-long-running-external-program-span&#34;&gt;&lt;span id=&#34;starting_a_long_running_external_program&#34;&gt;Starting a Long-Running External Program&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;But what happens if we cannot just run a Perl code from the spawned process and we have a compiled utility, i.e. a program written in C. Or we have a Perl program that cannot be easily converted into a module, and thus called as a function. Of course, in this case, we have to use system(), exec(), &lt;code&gt;qx()&lt;/code&gt; or &lt;code&gt;``&lt;/code&gt; (back ticks) to start it.&lt;/p&gt;

&lt;p&gt;When using any of these methods and when the &lt;em&gt;Taint&lt;/em&gt; mode is enabled, we must at least add the following code to untaint the &lt;em&gt;PATH&lt;/em&gt; environment variable and delete a few other insecure environment variables. This information can be found in the &lt;em&gt;perlsec&lt;/em&gt; manpage.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ENV{&#39;PATH&#39;} = &#39;/bin:/usr/bin&#39;;
  delete @ENV{&#39;IFS&#39;, &#39;CDPATH&#39;, &#39;ENV&#39;, &#39;BASH_ENV&#39;};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now all we have to do is to reuse the code from the previous section.&lt;/p&gt;

&lt;p&gt;First, we move the core program into the &lt;em&gt;external.pl&lt;/em&gt; file, add the shebang first line so the program will be executed by Perl, tell the program to run under &lt;em&gt;Taint&lt;/em&gt; mode (-T) and possibly enable the &lt;em&gt;warnings&lt;/em&gt; mode (-w) and make it executable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  external.pl
  -----------
  #!/usr/bin/perl -Tw

  open STDIN, &#39;/dev/null&#39;  or die &amp;quot;Can&#39;t read /dev/null: $!&amp;quot;;
  open STDOUT, &#39;&amp;gt;/dev/null&#39;
      or die &amp;quot;Can&#39;t write to /dev/null: $!&amp;quot;;
  open STDERR, &#39;&amp;gt;/tmp/log&#39; or die &amp;quot;Can&#39;t write to /tmp/log: $!&amp;quot;;

  select STDERR;
  local $|=1;
  warn &amp;quot;started\n&amp;quot;;
  # do something time-consuming
  sleep 1, warn &amp;quot;$_\n&amp;quot; for 1..20;
  warn &amp;quot;completed\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we replace the code that moved into the external program with &lt;code&gt;exec()&lt;/code&gt; to call it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  proper_fork_exec.pl
  -------------------
  use strict;
  use POSIX &#39;setsid&#39;;
  use Apache::SubProcess;

  $ENV{&#39;PATH&#39;} = &#39;/bin:/usr/bin&#39;;
  delete @ENV{&#39;IFS&#39;, &#39;CDPATH&#39;, &#39;ENV&#39;, &#39;BASH_ENV&#39;};

  my $r = shift;
  $r-&amp;gt;send_http_header(&amp;quot;text/html&amp;quot;);

  $SIG{CHLD} = &#39;IGNORE&#39;;

  defined (my $kid = fork) or die &amp;quot;Cannot fork: $!\n&amp;quot;;
  if ($kid) {
    print &amp;quot;Parent has finished, kid&#39;s PID: $kid\n&amp;quot;;
  } else {
      $r-&amp;gt;cleanup_for_exec(); # untie the socket
      chdir &#39;/&#39;                or die &amp;quot;Can&#39;t chdir to /: $!&amp;quot;;
      open STDIN, &#39;/dev/null&#39;  or die &amp;quot;Can&#39;t read /dev/null: $!&amp;quot;;
      open STDOUT, &#39;&amp;gt;/dev/null&#39;
          or die &amp;quot;Can&#39;t write to /dev/null: $!&amp;quot;;
      open STDERR, &#39;&amp;gt;&amp;amp;STDOUT&#39;  or die &amp;quot;Can&#39;t dup stdout: $!&amp;quot;;
      setsid or die &amp;quot;Can&#39;t start a new session: $!&amp;quot;;

      exec &amp;quot;/home/httpd/perl/external.pl&amp;quot; or die &amp;quot;Cannot execute exec: $!&amp;quot;;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that &lt;code&gt;exec()&lt;/code&gt; never returns unless it fails to start the process. Therefore, you shouldn&amp;rsquo;t put any code after exec()&amp;ndash;it will be not executed in the case of success. Use &lt;code&gt;system()&lt;/code&gt; or back-ticks instead if you want to continue doing other things in the process. But then you probably will want to terminate the process after the program has finished. So you will have to write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      system &amp;quot;/home/httpd/perl/external.pl&amp;quot; or die &amp;quot;Cannot execute system: $!&amp;quot;;
      CORE::exit(0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another important nuance is that we have to close all &lt;code&gt;STD*&lt;/code&gt; streams in the forked process, even if the called program does that.&lt;/p&gt;

&lt;p&gt;If the external program is written in Perl, then you may pass complicated data structures to it using one of the methods to serialize Perl data and then to restore it. The &lt;code&gt;Storable&lt;/code&gt; and &lt;code&gt;FreezeThaw&lt;/code&gt; modules come handy. Let&amp;rsquo;s say that we have program &lt;em&gt;master.pl&lt;/em&gt; calling program &lt;em&gt;slave.pl&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  master.pl
  ---------
  # we are within the C&amp;lt;mod_perl&amp;gt; code
  use Storable ();
  my @params = (foo =&amp;gt; 1, bar =&amp;gt; 2);
  my $params = Storable::freeze(\@params);
  exec &amp;quot;./slave.pl&amp;quot;, $params or die &amp;quot;Cannot execute exec: $!&amp;quot;;

  slave.pl
  --------
  #!/usr/bin/perl -w
  use Storable ();
  my @params = @ARGV ? @{ Storable::thaw(shift)||[] } : ();
  # do something
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, &lt;em&gt;master.pl&lt;/em&gt; serializes the &lt;code&gt;@params&lt;/code&gt; data structure with &lt;code&gt;Storable::freeze&lt;/code&gt; and passes it to &lt;em&gt;slave.pl&lt;/em&gt; as a single argument. &lt;em&gt;slave.pl&lt;/em&gt; restores it with &lt;code&gt;Storable::thaw&lt;/code&gt;, by shifting the first value of the &lt;code&gt;ARGV&lt;/code&gt; array if available. The &lt;code&gt;FreezeThaw&lt;/code&gt; module does a similar thing.&lt;/p&gt;

&lt;h3 id=&#34;span-id-starting-a-short-running-external-program-starting-a-short-running-external-program-span&#34;&gt;&lt;span id=&#34;starting_a_short_running_external_program&#34;&gt;Starting a Short-Running External Program&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Sometimes you need to call an external program and you cannot continue before this program completes its run and optionally returns some result. In this case, the fork solution doesn&amp;rsquo;t help. But we have a few ways to execute this program. First using system():&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  system &amp;quot;perl -e &#39;print 5+5&#39;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We believe that you will never call the Perl interperter for doing this simple calculation, but for the sake of a simple example it&amp;rsquo;s good enough.&lt;/p&gt;

&lt;p&gt;The problem with this approach is that we cannot get the results printed to &lt;code&gt;STDOUT&lt;/code&gt;, and that&amp;rsquo;s where back-ticks or &lt;code&gt;qx()&lt;/code&gt; help. If you use either:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my $result = `perl -e &#39;print 5+5&#39;`;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my $result = qx{perl -e &#39;print 5+5&#39;};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the whole output of the external program will be stored in the &lt;code&gt;$result&lt;/code&gt; variable.&lt;/p&gt;

&lt;p&gt;Of course, you can use other solutions, such as opening a pipe (&lt;code&gt;|&lt;/code&gt; to the program) if you need to submit many arguments and more evolved solutions provided by other Perl modules like &lt;code&gt;IPC::Open2&lt;/code&gt;, which allows to open a process for both reading and writing.&lt;/p&gt;

&lt;h3 id=&#34;span-id-executing-system-or-exec-in-the-right-way-executing-system-or-exec-in-the-right-way-span&#34;&gt;&lt;span id=&#34;executing_system()_or_exec()_in_the_right_way&#34;&gt;Executing &lt;code&gt;system()&lt;/code&gt; or &lt;code&gt;exec()&lt;/code&gt; in the Right Way&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;exec()&lt;/code&gt; and &lt;code&gt;system()&lt;/code&gt; system calls behave identically in the way they spawn a program. For example, let&amp;rsquo;s use &lt;code&gt;system()&lt;/code&gt;. Consider the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  system(&amp;quot;echo&amp;quot;,&amp;quot;Hi&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perl will use the first argument as a program to execute, find &lt;code&gt;/bin/echo&lt;/code&gt; along the search path, invoke it directly and pass the &lt;em&gt;Hi&lt;/em&gt; string as an argument.&lt;/p&gt;

&lt;p&gt;Perl&amp;rsquo;s &lt;code&gt;system()&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; the &lt;code&gt;system(3)&lt;/code&gt; call (from the C-library). This is how the arguments to &lt;code&gt;system()&lt;/code&gt; get interpreted. When there is a single argument to system(), it&amp;rsquo;ll be checked for having shell metacharacters first (like &lt;code&gt;*&lt;/code&gt;,&lt;code&gt;?&lt;/code&gt;), and if there are any&amp;ndash;Perl interpreter invokes a real shell program (/bin/sh -c on Unix platforms). If you pass a list of arguments to system(), then they will be not checked for metacharacters, but split into words if required and passed directly to the C-level &lt;code&gt;execvp()&lt;/code&gt; system call, which is more efficient. That&amp;rsquo;s a &lt;em&gt;very&lt;/em&gt; nice optimization. In other words, only if you do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  system &amp;quot;sh -c &#39;echo *&#39;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will the operating system actually &lt;code&gt;exec()&lt;/code&gt; a copy of &lt;code&gt;/bin/sh&lt;/code&gt; to parse your command. But even then, since &lt;em&gt;sh&lt;/em&gt; is almost certainly already running somewhere, the system will notice that (via the disk inode reference) and replace your virtual memory page table with one pointing to the existing program code plus your data space, thus will not create this overhead.&lt;/p&gt;

&lt;h3 id=&#34;span-id-references-references-span&#34;&gt;&lt;span id=&#34;references&#34;&gt;References&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;mod_perl&lt;/code&gt; site&amp;rsquo;s URL: &lt;a href=&#34;http://perl.apache.org/&#34;&gt;http://perl.apache.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Apache::SubProcess&#34;&gt;Apache-SubProcess&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Storable&#34;&gt;Storable&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Improving mod_perl Sites&#39; Performance: Part 5</title>
      <link>http://localhost:1313/pub/2002/12/04/mod_perl.html/</link>
      <pubDate>Wed, 04 Dec 2002 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2002/12/04/mod_perl.html/</guid>
      <description>

&lt;h3 id=&#34;span-id-sharing-memory-sharing-memory-span&#34;&gt;&lt;span id=&#34;sharing_memory&#34;&gt;Sharing Memory&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;As we have learned in the previous article, sharing memory helps us save memory with mod_perl, giving us a huge speed increase; but we pay the price with a big memory footprint. I presented a few techniques to save memory by trying to share more of it. In this article, we will see other techniques allowing you to save even more memory.&lt;/p&gt;

&lt;h3 id=&#34;span-id-preloading-registry-scripts-at-server-startup-preloading-registry-scripts-at-server-startup-span&#34;&gt;&lt;span id=&#34;preloading_registry_scripts_at_server_startup&#34;&gt;Preloading Registry Scripts at Server Startup&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;What happens if you find yourself stuck with Perl CGI scripts and you cannot or don&amp;rsquo;t want to move most of the stuff into modules to benefit from modules preloading, so the code will be shared by the children? Luckily, you can preload scripts as well. This time the &lt;code&gt;Apache::RegistryLoader&lt;/code&gt; module comes to your aid. &lt;code&gt;Apache::RegistryLoader&lt;/code&gt; compiles &lt;code&gt;Apache::Registry&lt;/code&gt; scripts at server startup.&lt;/p&gt;

&lt;p&gt;For example, to preload the script &lt;em&gt;/perl/test.pl&lt;/em&gt;, which is in fact the file &lt;em&gt;/home/httpd/perl/test.pl&lt;/em&gt;, you would do the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use Apache::RegistryLoader ();
  Apache::RegistryLoader-&amp;gt;new-&amp;gt;handler(&amp;quot;/perl/test.pl&amp;quot;,
                            &amp;quot;/home/httpd/perl/test.pl&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should put this code either into a &lt;code&gt;&amp;lt;Perl&amp;gt;&lt;/code&gt; section or into a startup script.&lt;/p&gt;

&lt;p&gt;But what if you have a bunch of scripts located under the same directory and you don&amp;rsquo;t want to list them one by one? Take the benefit of Perl modules and put them to good use - the &lt;code&gt;File::Find&lt;/code&gt; module will do most of the work for you.&lt;/p&gt;

&lt;p&gt;The following code walks the directory tree under which all &lt;code&gt;Apache::Registry&lt;/code&gt; scripts are located. For each file it encounters with the extension &lt;em&gt;.pl&lt;/em&gt;, it calls the &lt;code&gt;Apache::RegistryLoader::handler()&lt;/code&gt; method to preload the script in the parent server, before pre-forking the child processes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use File::Find qw(finddepth);
  use Apache::RegistryLoader ();
  {
    my $scripts_root_dir = &amp;quot;/home/httpd/perl/&amp;quot;;
    my $rl = Apache::RegistryLoader-&amp;gt;new;
    finddepth
      (
       sub {
         return unless /\.pl$/;
         my $url = &amp;quot;$File::Find::dir/$_&amp;quot;;
         $url =~ s|$scripts_root_dir/?|/|;
         warn &amp;quot;pre-loading $url\n&amp;quot;;
           # preload $url
         my $status = $rl-&amp;gt;handler($url);
         unless($status == 200) {
           warn &amp;quot;pre-load of `$url&#39; failed, status=$status\n&amp;quot;;
         }
       },
       $scripts_root_dir);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that I didn&amp;rsquo;t use the second argument to &lt;code&gt;handler()&lt;/code&gt; here, as in the first example. To make the loader smarter about the URI to filename translation, you might need to provide a &lt;code&gt;trans()&lt;/code&gt; function to translate the URI to a filename. URI to filename translation normally doesn&amp;rsquo;t happen until HTTP request time, so the module is forced to roll its own translation. If the filename is omitted and a &lt;code&gt;trans()&lt;/code&gt; function was not defined, then the loader will try using the URI relative to &lt;strong&gt;ServerRoot&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;A simple &lt;code&gt;trans()&lt;/code&gt; function can be like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  sub mytrans {
    my $uri = shift;
    $uri =~ s|^/perl/|/home/httpd/perl/|;
    return $uri;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can easily derive the right translation by looking at the &lt;code&gt;Alias&lt;/code&gt; directive. The above &lt;code&gt;mytrans()&lt;/code&gt; function is matching our &lt;code&gt;Alias&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Alias /perl/ /home/httpd/perl/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After defining the URI to filename translation function, you should pass it during the creation of the &lt;code&gt;Apache::RegistryLoader&lt;/code&gt; object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my $rl = Apache::RegistryLoader-&amp;gt;new(trans =&amp;gt; \&amp;amp;mytrans);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I won&amp;rsquo;t show any benchmarks here, since the effect is absolutely the same as with preloading modules.&lt;/p&gt;

&lt;h3 id=&#34;span-id-modules-initializing-at-server-startup-modules-initializing-at-server-startup-span&#34;&gt;&lt;span id=&#34;modules_initializing_at_server_startup&#34;&gt;Modules Initializing at Server Startup&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;We have just learned that it&amp;rsquo;s important to preload the modules and scripts at the server startup. It turns out that it&amp;rsquo;s not enough for some modules and you have to prerun their initialization code to get more memory pages shared. Basically you will find an information about specific modules in their respective manpages. I will present a few examples of widely used modules where the code can be initialized.&lt;/p&gt;

&lt;h4 id=&#34;span-id-initializing-dbi-pm-initializing-dbi-pm-span&#34;&gt;&lt;span id=&#34;initializing_dbi.pm&#34;&gt;Initializing DBI.pm&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The first example is the &lt;code&gt;DBI&lt;/code&gt; module. As you know, &lt;code&gt;DBI&lt;/code&gt; works with many database drivers in the &lt;code&gt;DBD::&lt;/code&gt; namespace, such as &lt;code&gt;DBD::mysql&lt;/code&gt;. It&amp;rsquo;s not enough to preload &lt;code&gt;DBI&lt;/code&gt;; you should initialize &lt;code&gt;DBI&lt;/code&gt; with the &lt;code&gt;driver(s)&lt;/code&gt; that you are going to use (usually a single driver is used) if you want to minimize memory use after forking the child processes. Note that you want to do this under mod_perl and other environments where shared memory is important. In other circumstances, you shouldn&amp;rsquo;t initialize drivers.&lt;/p&gt;

&lt;p&gt;You probably know already that under mod_perl you should use the &lt;code&gt;Apache::DBI&lt;/code&gt; module to make the connection persistent, unless you want to open a separate connection for each user &amp;ndash; in which case, you should not use this module. &lt;code&gt;Apache::DBI&lt;/code&gt; automatically loads &lt;code&gt;DBI&lt;/code&gt; and overrides some of its methods, so you should continue coding just as though you were simply using the &lt;code&gt;DBI&lt;/code&gt; module.&lt;/p&gt;

&lt;p&gt;Just as with modules preloading, our goal is to find the startup environment that will lead to the smallest ``difference&amp;rdquo; between the shared and normal memory reported, which would mean a smaller total memory usage.&lt;/p&gt;

&lt;p&gt;And again, in order to make it easy to measure, I will use only one child process. To do this, I will use these settings in &lt;em&gt;httpd.conf&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  MinSpareServers 1
  MaxSpareServers 1
  StartServers 1
  MaxClients 1
  MaxRequestsPerChild 100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;m going to run memory benchmarks on five different versions of the &lt;em&gt;startup.pl&lt;/em&gt; file. I always preload these modules:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use Gtop();
  use Apache::DBI(); # preloads DBI as well
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_option&#34;&gt;option 1&lt;/span&gt;&lt;/strong&gt;&lt;br /&gt;
Leave the file unmodified.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;option 2&lt;/strong&gt;&lt;br /&gt;
Install MySQL driver (I will use MySQL RDBMS for our test):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  DBI-&amp;gt;install_driver(&amp;quot;mysql&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s safe to use this method, since just like with &lt;code&gt;use()&lt;/code&gt;, if it can&amp;rsquo;t be installed it&amp;rsquo;ll &lt;code&gt;die()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;option 3&lt;/strong&gt;&lt;br /&gt;
Preload MySQL driver module:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use DBD::mysql;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;option 4&lt;/strong&gt;&lt;br /&gt;
Tell &lt;code&gt;Apache::DBI&lt;/code&gt; to connect to the database when the child process starts (&lt;code&gt;ChildInitHandler&lt;/code&gt;) - no driver is preloaded before the child gets spawned!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Apache::DBI-&amp;gt;connect_on_init(&#39;DBI:mysql:test::localhost&#39;,
                             &amp;quot;&amp;quot;,
                             &amp;quot;&amp;quot;,
                             {
                              PrintError =&amp;gt; 1, # warn() on errors
                              RaiseError =&amp;gt; 0, # don&#39;t die on error
                              AutoCommit =&amp;gt; 1, # commit executes
                              # immediately
                             }
                            )
  or die &amp;quot;Cannot connect to database: $DBI::errstr&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is the &lt;code&gt;Apache::Registry&lt;/code&gt; test script that I have used:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  preload_dbi.pl
  --------------
  use strict;
  use GTop ();
  use DBI ();

  my $dbh = DBI-&amp;gt;connect(&amp;quot;DBI:mysql:test::localhost&amp;quot;,
                         &amp;quot;&amp;quot;,
                         &amp;quot;&amp;quot;,
                         {
                          PrintError =&amp;gt; 1, # warn() on errors
                          RaiseError =&amp;gt; 0, # don&#39;t die on error
                          AutoCommit =&amp;gt; 1, # commit executes
                                           # immediately
                         }
                        )
    or die &amp;quot;Cannot connect to database: $DBI::errstr&amp;quot;;

  my $r = shift;
  $r-&amp;gt;send_http_header(&#39;text/plain&#39;);

  my $do_sql = &amp;quot;show tables&amp;quot;;
  my $sth = $dbh-&amp;gt;prepare($do_sql);
  $sth-&amp;gt;execute();
  my @data = ();
  while (my @row = $sth-&amp;gt;fetchrow_array){
    push @data, @row;
  }
  print &amp;quot;Data: @data\n&amp;quot;;
  $dbh-&amp;gt;disconnect(); # NOP under Apache::DBI

  my $proc_mem = GTop-&amp;gt;new-&amp;gt;proc_mem($$);
  my $size  = $proc_mem-&amp;gt;size;
  my $share = $proc_mem-&amp;gt;share;
  my $diff  = $size - $share;
  printf &amp;quot;%8s %8s %8s\n&amp;quot;, qw(Size Shared Diff);
  printf &amp;quot;%8d %8d %8d (bytes)\n&amp;quot;,$size,$share,$diff;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The script opens a connection to the database &lt;em&gt;&amp;lsquo;test&amp;rsquo;&lt;/em&gt; and issues a query to learn what tables the databases has. When the data is collected and printed the connection would be closed in the regular case, but &lt;code&gt;Apache::DBI&lt;/code&gt; overrides it with empty method. When the data is processed, some code to print the memory usage follows &amp;ndash; this should already be familiar to you.&lt;/p&gt;

&lt;p&gt;The server was restarted before each new test.&lt;/p&gt;

&lt;p&gt;So here are the results of the five tests that were conducted, sorted by the &lt;em&gt;Diff&lt;/em&gt; column:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;After the first request:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Version     Size   Shared     Diff        Test type
  --------------------------------------------------------------------
        1  3465216  2621440   843776  install_driver
        2  3461120  2609152   851968  install_driver &amp;amp; connect_on_init
        3  3465216  2605056   860160  preload driver
        4  3461120  2494464   966656  nothing added
        5  3461120  2482176   978944  connect_on_init
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;After the second request (all the subsequent request showed the same results):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Version     Size   Shared    Diff         Test type
  --------------------------------------------------------------------
        1  3469312  2609152   860160  install_driver
        2  3481600  2605056   876544  install_driver &amp;amp; connect_on_init
        3  3469312  2588672   880640  preload driver
        4  3477504  2482176   995328  nothing added
        5  3481600  2469888  1011712  connect_on_init
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now what do we conclude from looking at these numbers. First, we see that only after a second reload do we get the final memory footprint for a specific request in question (if you pass different arguments the memory usage might and will be different).&lt;/p&gt;

&lt;p&gt;But both tables show the same pattern of memory usage. We can clearly see that the real winner is the &lt;em&gt;startup.pl&lt;/em&gt; file&amp;rsquo;s version where the MySQL driver was installed (1). Since we want to have a connection ready for the first request made to the freshly spawned child process, we generally use the second version (2), which uses somewhat more memory, but has almost the same number of shared memory pages. The third version only preloads the driver, resulting in smaller shared memory. The last two versions having nothing initialized (4) and having only the &lt;code&gt;connect_on_init()&lt;/code&gt; method used (5). The former is a little bit better than the latter, but both significantly worse than the first two versions.&lt;/p&gt;

&lt;p&gt;To remind you why do we look for the smallest value in the column &lt;em&gt;diff&lt;/em&gt;, recall the real memory usage formula:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  RAM_dedicated_to_mod_perl = diff * number_of_processes
                            + the_processes_with_largest_shared_memory
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that the smaller the diff is, the bigger the number of processes you can have using the same amount of RAM. Therefore, every 100K difference counts, when you multiply it by the number of processes. If we take the number from the version (1) vs. (4) and assume that we have 256M of memory dedicated to mod_perl processes, we will get the following numbers using the formula derived from the above formula:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;               RAM - largest_shared_size
  N_of Procs = -------------------------
                        Diff

                268435456 - 2609152
  (ver 1)  N =  ------------------- = 309
                      860160

                268435456 - 2469888
  (ver 5)  N =  ------------------- = 262
                     1011712
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So you can see the difference - 17 percent more child processes in the first version.&lt;/p&gt;

&lt;h4 id=&#34;span-id-initializing-cgi-pm-initializing-cgi-pm-span&#34;&gt;&lt;span id=&#34;initializing_cgi.pm&#34;&gt;Initializing CGI.pm&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;CGI.pm&lt;/code&gt; is a big module that by default postpones the compilation of its methods until they are actually needed, thus making it possible to use it under a slow mod_cgi handler without adding a big overhead. That&amp;rsquo;s not what we want under mod_perl, and if you use &lt;code&gt;CGI.pm&lt;/code&gt; you should precompile the methods that you are going to use at the server startup in addition to preloading the module. Use the compile method for that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use CGI;
  CGI-&amp;gt;compile(&#39;:all&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where you should replace the tag group &lt;code&gt;:all&lt;/code&gt; with the real tags and group tags that you are going to use if you want to optimize the memory usage.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m going to compare the shared memory footprint by using a script that is backward compatible with mod_cgi. You will see that you can improve the performance of these kind of scripts as well, but if you really want a fast code think about porting it to use &lt;code&gt;Apache::Request&lt;/code&gt; for the CGI interface, and some other module for HTML generation.&lt;/p&gt;

&lt;p&gt;So here is the &lt;code&gt;Apache::Registry&lt;/code&gt; script that I&amp;rsquo;m going to use to make the comparison:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  preload_cgi_pm.pl
  -----------------
  use strict;
  use CGI ();
  use GTop ();

  my $q = new CGI;
  print $q-&amp;gt;header(&#39;text/plain&#39;);
  print join &amp;quot;\n&amp;quot;, map {&amp;quot;$_ =&amp;gt; &amp;quot;.$q-&amp;gt;param($_) } $q-&amp;gt;param;
  print &amp;quot;\n&amp;quot;;

  my $proc_mem = GTop-&amp;gt;new-&amp;gt;proc_mem($$);
  my $size  = $proc_mem-&amp;gt;size;
  my $share = $proc_mem-&amp;gt;share;
  my $diff  = $size - $share;
  printf &amp;quot;%8s %8s %8s\n&amp;quot;, qw(Size Shared Diff);
  printf &amp;quot;%8d %8d %8d (bytes)\n&amp;quot;,$size,$share,$diff;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The script initializes the &lt;code&gt;CGI&lt;/code&gt; object, sends a HTTP header and then prints all the arguments and values that were passed to the script if there were any. As usual, at the end, I print the memory usage.&lt;/p&gt;

&lt;p&gt;As usual, I am going to use a single child process, using the usual settings in &lt;em&gt;httpd.conf&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  MinSpareServers 1
  MaxSpareServers 1
  StartServers 1
  MaxClients 1
  MaxRequestsPerChild 100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;m going to run memory benchmarks on three different versions of the &lt;em&gt;startup.pl&lt;/em&gt; file. I always preload this module:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use Gtop();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;option 1&lt;/strong&gt;&lt;br /&gt;
Leave the file unmodified.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;option 2&lt;/strong&gt;&lt;br /&gt;
Preload &lt;code&gt;CGI.pm&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use CGI ();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;option 3&lt;/strong&gt;&lt;br /&gt;
Preload &lt;code&gt;CGI.pm&lt;/code&gt; and pre-compile the methods that I&amp;rsquo;m going to use in the script:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use CGI ();
  CGI-&amp;gt;compile(qw(header param));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The server was restarted before each new test.&lt;/p&gt;

&lt;p&gt;So here are the results of the three tests that were conducted, sorted by the &lt;em&gt;Diff&lt;/em&gt; column:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;After the first request:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Version     Size   Shared     Diff        Test type
  --------------------------------------------------------------------
        1  3321856  2146304  1175552  not preloaded
        2  3321856  2326528   995328  preloaded
        3  3244032  2465792   778240  preloaded &amp;amp; methods+compiled
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;After the second request (all the subsequent request showed the same results):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Version     Size   Shared    Diff         Test type
  --------------------------------------------------------------------
        1  3325952  2134016  1191936 not preloaded
        2  3325952  2314240  1011712 preloaded
        3  3248128  2445312   802816 preloaded &amp;amp; methods+compiled
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The first version shows the results of the script execution when &lt;code&gt;CGI.pm&lt;/code&gt; wasn&amp;rsquo;t preloaded. The second version has the module preloaded. The third is when it&amp;rsquo;s both preloaded and the methods that are going to be used are precompiled at the server startup.&lt;/p&gt;

&lt;p&gt;By looking at version one of the second table, we can conclude that preloading adds about 20K to the shared size. As I have mentioned at the beginning of this section, that&amp;rsquo;s how &lt;code&gt;CGI.pm&lt;/code&gt; was implemented &amp;ndash; to reduce the load overhead. This means that preloading CGI almost hardly changes anything. But if we compare the second and the third versions, then we will see a significant difference of 207K (1011712-802816), and I have only used a few methods (the &lt;em&gt;header&lt;/em&gt; method loads a few more methods transparently for a user). Imagine how much memory I&amp;rsquo;m going to save if I&amp;rsquo;m going to precompile all the methods that I&amp;rsquo;m using in other scripts that use &lt;code&gt;CGI.pm&lt;/code&gt; and do a little bit more than the script that I have used in the test.&lt;/p&gt;

&lt;p&gt;But even in our simple case using the same formula, what do we see? (assuming that I have 256MB dedicated for mod_perl)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;               RAM - largest_shared_size
  N_of Procs = -------------------------
                        Diff

                268435456 - 2134016
  (ver 1)  N =  ------------------- = 223
                      1191936

                268435456 - 2445312
  (ver 3)  N =  ------------------- = 331
                     802816
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If I preload &lt;code&gt;CGI.pm&lt;/code&gt; and precompile a few methods that I use in the test script, I can have 50 percent more child processes than when I don&amp;rsquo;t preload and precompile the methods that I am going to use.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve heard that the 3.x generation of &lt;code&gt;CGI.pm&lt;/code&gt; will be less bloated, but it&amp;rsquo;s in a beta state as of this writing.&lt;/p&gt;

&lt;h3 id=&#34;span-id-increasing-shared-memory-with-mergemem-increasing-shared-memory-with-mergemem-span&#34;&gt;&lt;span id=&#34;increasing_shared_memory_with_mergemem&#34;&gt;Increasing Shared Memory With mergemem&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;mergemem&lt;/code&gt; is an experimental utility for linux, which looks &lt;em&gt;very&lt;/em&gt; interesting for us mod_perl users: &lt;a href=&#34;http://www.complang.tuwien.ac.at/ulrich/mergemem/&#34;&gt;http://www.complang.tuwien.ac.at/ulrich/mergemem/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;It looks like it could be run periodically on your server to find and merge duplicate pages. It won&amp;rsquo;t halt your httpds during the merge, this aspect has been taken into consideration already during the design of mergemem: Merging is not performed with one big system call. Instead most operation is in userspace, making a lot of small system calls.&lt;/p&gt;

&lt;p&gt;Therefore, blocking of the system should not happen. And, if it really should turn out to take too much time you can reduce the priority of the process.&lt;/p&gt;

&lt;p&gt;The worst case that can happen is this: &lt;code&gt;mergemem&lt;/code&gt; merges two pages and immediately afterward, they will be split. The split costs about the same as the time consumed by merging.&lt;/p&gt;

&lt;p&gt;This software comes with a utility called &lt;code&gt;memcmp&lt;/code&gt; to tell you how much you might save.&lt;/p&gt;

&lt;h3 id=&#34;span-id-references-references-span&#34;&gt;&lt;span id=&#34;references&#34;&gt;References&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The mod_perl site&amp;rsquo;s URL: &lt;a href=&#34;http://perl.apache.org/&#34;&gt;http://perl.apache.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;mergemem project &lt;a href=&#34;http://www.complang.tuwien.ac.at/ulrich/mergemem/&#34;&gt;http://www.complang.tuwien.ac.at/ulrich/mergemem/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Improving mod_perl Sites&#39; Performance: Part 4</title>
      <link>http://localhost:1313/pub/2002/07/30/mod_perl.html/</link>
      <pubDate>Tue, 30 Jul 2002 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2002/07/30/mod_perl.html/</guid>
      <description>

&lt;h3 id=&#34;span-id-introduction-introduction-span&#34;&gt;&lt;span id=&#34;introduction&#34;&gt;Introduction&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;If your OS supports sharing of memory (and most sane systems do), you might save a lot of RAM by sharing it between child processes. This will allow you to run more processes and hopefully better satisfy the client, without investing extra money into buying more memory.&lt;/p&gt;

&lt;p&gt;This is only possible when you preload code at server startup. However, during a child process&amp;rsquo; life, its memory pages tend to become unshared. There is no way we can make Perl allocate memory so that (dynamic) variables land on different memory pages from constants, so the &lt;strong&gt;copy-on-write&lt;/strong&gt; effect will hit you almost at random.&lt;/p&gt;

&lt;p&gt;If you are pre-loading many modules, you might be able to trade off the memory that stays shared against the time for an occasional fork by tuning &lt;code&gt;MaxRequestsPerChild&lt;/code&gt;. Each time a child reaches this upper limit and dies, it should release its unshared pages. The new child which replaces it will share its fresh pages until it scribbles on them.&lt;/p&gt;

&lt;p&gt;The ideal is a point where your processes usually restart before too much memory becomes unshared. You should take some measurements to see if it makes a real difference, and to find the range of reasonable values. If you have success with this, tuning the value of &lt;code&gt;MaxRequestsPerChild&lt;/code&gt; will probably be peculiar to your situation and may change with changing circumstances.&lt;/p&gt;

&lt;p&gt;It is very important to understand that your goal is not to have &lt;code&gt;MaxRequestsPerChild&lt;/code&gt; to be 10000. Having a child serving 300 requests on precompiled code is already a huge overall speedup, so if it is 100 or 10000 it probably does not really matter if you can save RAM by using a lower value.&lt;/p&gt;

&lt;p&gt;Do not forget that if you preload most of your code at server startup, the newly forked child gets ready very very fast, because it inherits most of the preloaded code and the perl interpreter from the parent process.&lt;/p&gt;

&lt;p&gt;During the life of the child, its memory pages (which aren&amp;rsquo;t really its own to start with, it uses the parent&amp;rsquo;s pages) gradually get `dirty&amp;rsquo; - variables which were originally inherited and shared are updated or modified &amp;ndash; and the &lt;em&gt;copy-on-write&lt;/em&gt; happens. This reduces the number of shared memory pages, thus increasing the memory requirement. Killing the child and spawning a new one allows the new child to get back to the pristine shared memory of the parent process.&lt;/p&gt;

&lt;p&gt;The recommendation is that &lt;code&gt;MaxRequestsPerChild&lt;/code&gt; should not be too large, otherwise you lose some of the benefit of sharing memory.&lt;/p&gt;

&lt;h3 id=&#34;span-id-how-shared-is-my-memory-how-shared-is-my-memory-span&#34;&gt;&lt;span id=&#34;how_shared_is_my_memory&#34;&gt;How Shared Is My Memory?&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;You&amp;rsquo;ve probably noticed that the word shared is repeated many times in relation to &lt;code&gt;mod_perl&lt;/code&gt;. Indeed, shared memory might save you a lot of money, since with sharing in place you can run many more servers than without it.&lt;/p&gt;

&lt;p&gt;How much shared memory do you have? You can see it by either using the memory utility that comes with your system or you can deploy the &lt;code&gt;GTop&lt;/code&gt; module:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use GTop ();
  print &amp;quot;Shared memory of the current process: &amp;quot;,
    GTop-&amp;gt;new-&amp;gt;proc_mem($$)-&amp;gt;share,&amp;quot;\n&amp;quot;;

  print &amp;quot;Total shared memory: &amp;quot;,
    GTop-&amp;gt;new-&amp;gt;mem-&amp;gt;share,&amp;quot;\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you watch the output of the &lt;code&gt;top&lt;/code&gt; utility, don&amp;rsquo;t confuse the &lt;code&gt;RES&lt;/code&gt; (or &lt;code&gt;RSS&lt;/code&gt;) columns with the &lt;code&gt;SHARE&lt;/code&gt; column. &lt;code&gt;RES&lt;/code&gt; is RESident memory, which is the size of pages currently swapped in.&lt;/p&gt;

&lt;h3 id=&#34;span-id-calculating-real-memory-usage-calculating-real-memory-usage-span&#34;&gt;&lt;span id=&#34;calculating_real_memory_usage&#34;&gt;Calculating Real Memory Usage&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;I have shown how to measure the size of the process&amp;rsquo; shared memory, but we still want to know what the real memory usage is. Obviously this cannot be calculated simply by adding up the memory size of each process because that wouldn&amp;rsquo;t account for the shared memory.&lt;/p&gt;

&lt;p&gt;On the other hand we cannot just subtract the shared memory size from the total size to get the real memory usage numbers, because in reality each process has a different history of processed requests, therefore the shared memory is not the same for all processes.&lt;/p&gt;

&lt;p&gt;So how do we measure the real memory size used by the server we run? It&amp;rsquo;s probably too difficult to give the exact number, but I&amp;rsquo;ve found a way to get a fair approximation, which was verified in the following way. I calculated the real memory used by a technique you will see in the moment, and then stopped the Apache server and saw that the memory usage report indicated that the total used memory went down by almost the same number I&amp;rsquo;ve calculated. Note that some OSs do smart memory pages caching so you may not see the memory usage decrease as soon as it actually happens when you quit the application.&lt;/p&gt;

&lt;p&gt;This is a technique I&amp;rsquo;ve used:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;For each process sum up the difference between shared and system memory. To calculate a difference for a single process use:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use GTop;
  my $proc_mem = GTop-&amp;gt;new-&amp;gt;proc_mem($$);
  my $diff     = $proc_mem-&amp;gt;size - $proc_mem-&amp;gt;share;
  print &amp;quot;Difference is $diff bytes\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Now if we add the shared memory size of the process with maximum shared memory, we will get all the memory that actually is being used by all httpd processes, except for the parent process.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Finally, add the size of the parent process.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Please note that this might be incorrect for your system, so you use this number on your own risk.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve used this technique to display real memory usage in the module &lt;code&gt;Apache::VMonitor&lt;/code&gt; (see the previous article), so instead of trying to manually calculate this number you can use this module to do it automatically. In fact in the calculations used in this module there is no separation between the parent and child processes, they are all counted indifferently using the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use GTop ();
  my $gtop = GTop-&amp;gt;new;
  my $total_real = 0;
  my $max_shared = 0;
  # @mod_perl_pids is initialized by Apache::Scoreboard,
  # irrelevant here
  my @mod_perl_pids = some_code();
  for my $pid (@mod_perl_pids)
    my $proc_mem = $gtop-&amp;gt;proc_mem($pid);
    my $size     = $proc_mem-&amp;gt;size($pid);
    my $share    = $proc_mem-&amp;gt;share($pid);
    $total_real += $size - $share;
    $max_shared  = $share if $max_shared &amp;lt; $share;
  }
  $total_real += $max_shared;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So as you see we that we accumulate the difference between the shared and reported memory:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $total_real  += $size-$share;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and at the end add the biggest shared process size:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $total_real += $max_shared;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So now &lt;code&gt;$total_real&lt;/code&gt; contains approximately the really used memory.&lt;/p&gt;

&lt;h3 id=&#34;span-id-are-my-variables-shared-are-my-variables-shared-span&#34;&gt;&lt;span id=&#34;are_my_variables_shared&#34;&gt;Are My Variables Shared?&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;How do you find out if the code you write is shared between the processes or not? The code should be shared, except where it is on a memory page with variables that change. Some variables are read-only in usage and never change. For example, if you have some variables that use a lot of memory and you want them to be read-only. As you know the variable becomes unshared when the process modifies its value.&lt;/p&gt;

&lt;p&gt;So imagine that you have this 10Mb in-memory database that resides in a single variable, you perform various operations on it and want to make sure that the variable is still shared. For example if you do some matching regular expression (regex) processing on this variable and want to use the &lt;code&gt;pos()&lt;/code&gt; function, will it make the variable unshared or not?&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Apache::Peek&lt;/code&gt; module comes to rescue. Let&amp;rsquo;s write a module called &lt;em&gt;MyShared.pm&lt;/em&gt; which we preload at server startup, so all the variables of this module are initially shared by all children.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  MyShared.pm
  ---------
  package MyShared;
  use Apache::Peek;

  my $readonly = &amp;quot;Chris&amp;quot;;

  sub match    { $readonly =~ /\w/g;               }
  sub print_pos{ print &amp;quot;pos: &amp;quot;,pos($readonly),&amp;quot;\n&amp;quot;;}
  sub dump     { Dump($readonly);                  }
  1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This module declares the package &lt;code&gt;MyShared&lt;/code&gt;, loads the &lt;code&gt;Apache::Peek&lt;/code&gt; module and defines the lexically scoped &lt;code&gt;$readonly&lt;/code&gt; variable which is supposed to be a variable of large size (think about a huge hash data structure), but we will use a small one to simplify this example.&lt;/p&gt;

&lt;p&gt;The module also defines three subroutines: &lt;code&gt;match()&lt;/code&gt; that does a simple character matching, &lt;code&gt;print_pos()&lt;/code&gt; that prints the current position of the matching engine inside the string that was last matched and finally the &lt;code&gt;dump()&lt;/code&gt; subroutine that calls the &lt;code&gt;Apache::Peek&lt;/code&gt; module&amp;rsquo;s &lt;code&gt;Dump()&lt;/code&gt; function to dump a raw Perl data-type of the &lt;code&gt;$readonly&lt;/code&gt; variable.&lt;/p&gt;

&lt;p&gt;Here is the script that prints the process ID (PID) and calls all three functions. The goal is to check whether &lt;code&gt;pos()&lt;/code&gt; makes the variable &lt;em&gt;dirty&lt;/em&gt; and therefore unshared.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  share_test.pl
  -------------
  use MyShared;
  print &amp;quot;Content-type: text/plain\r\n\r\n&amp;quot;;
  print &amp;quot;PID: $$\n&amp;quot;;
  MyShared::match();
  MyShared::print_pos();
  MyShared::dump();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before you restart the server, in &lt;em&gt;httpd.conf&lt;/em&gt; set:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  MaxClients 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;for easier tracking. You need at least two servers to compare the print outs of the test program. Having more than two can make the comparison process harder.&lt;/p&gt;

&lt;p&gt;Now open two browser windows and issue the request for this script several times in both windows, so you get different processes PIDs reported in the two windows and each process has processed a different number of requests to the &lt;em&gt;share_test.pl&lt;/em&gt; script.&lt;/p&gt;

&lt;p&gt;In the first window you will see something like that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  PID: 27040
  pos: 1
  SV = PVMG(0x853db20) at 0x8250e8c
    REFCNT = 3
    FLAGS = (PADBUSY,PADMY,SMG,POK,pPOK)
    IV = 0
    NV = 0
    PV = 0x8271af0 &amp;quot;Chris&amp;quot;\0
    CUR = 5
    LEN = 6
    MAGIC = 0x853dd80
      MG_VIRTUAL = &amp;amp;vtbl_mglob
      MG_TYPE = &#39;g&#39;
      MG_LEN = 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And in the second window:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  PID: 27041
  pos: 2
  SV = PVMG(0x853db20) at 0x8250e8c
    REFCNT = 3
    FLAGS = (PADBUSY,PADMY,SMG,POK,pPOK)
    IV = 0
    NV = 0
    PV = 0x8271af0 &amp;quot;Chris&amp;quot;\0
    CUR = 5
    LEN = 6
    MAGIC = 0x853dd80
      MG_VIRTUAL = &amp;amp;vtbl_mglob
      MG_TYPE = &#39;g&#39;
      MG_LEN = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We see that all the addresses of the supposedly big structure are the same (&lt;code&gt;0x8250e8c&lt;/code&gt; and &lt;code&gt;0x8271af0&lt;/code&gt;), therefore the variable data structure is almost completely shared. The only difference is in &lt;code&gt;SV.MAGIC.MG_LEN&lt;/code&gt; record, which is not shared.&lt;/p&gt;

&lt;p&gt;So given that the &lt;code&gt;$readonly&lt;/code&gt; variable is a big one, its value is still shared between the processes, while part of the variable data structure is non-shared. But it&amp;rsquo;s almost insignificant because it takes a very little memory space.&lt;/p&gt;

&lt;p&gt;Now if you need to compare more than variable, doing it by hand can be quite time consuming and error prune. Therefore it&amp;rsquo;s better to correct the testing script to dump the Perl data-types into files (e.g &lt;em&gt;/tmp/dump.$$&lt;/em&gt;, where &lt;code&gt;$$&lt;/code&gt; is the PID of the process) and then using &lt;code&gt;diff(1)&lt;/code&gt; utility to see whether there is some difference.&lt;/p&gt;

&lt;p&gt;So correcting the &lt;code&gt;dump()&lt;/code&gt; function to write the info to the file will do the job. Notice that I use &lt;code&gt;Devel::Peek&lt;/code&gt; and not &lt;code&gt;Apache::Peek&lt;/code&gt;. The both are almost the same, but &lt;code&gt;Apache::Peek&lt;/code&gt; prints it output directly to the opened socket so I cannot intercept and redirect the result to the file. Since &lt;code&gt;Devel::Peek&lt;/code&gt; dumps results to the STDERR stream I can use the old trick of saving away the default STDERR handler, and open a new filehandler using the STDERR. In our example when &lt;code&gt;Devel::Peek&lt;/code&gt; now prints to STDERR it actually prints to our file. When I&amp;rsquo;m done, I make sure to restore the original STDERR filehandler.&lt;/p&gt;

&lt;p&gt;So this is the resulting code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  MyShared2.pm
  ---------
  package MyShared2;
  use Devel::Peek;

  my $readonly = &amp;quot;Chris&amp;quot;;

  sub match    { $readonly =~ /\w/g;               }
  sub print_pos{ print &amp;quot;pos: &amp;quot;,pos($readonly),&amp;quot;\n&amp;quot;;}
  sub dump{
    my $dump_file = &amp;quot;/tmp/dump.$$&amp;quot;;
    print &amp;quot;Dumping the data into $dump_file\n&amp;quot;;
    open OLDERR, &amp;quot;&amp;gt;&amp;amp;STDERR&amp;quot;;
    open STDERR, &amp;quot;&amp;gt;&amp;quot;.$dump_file or die &amp;quot;Can&#39;t open $dump_file: $!&amp;quot;;
    Dump($readonly);
    close STDERR ;
    open STDERR, &amp;quot;&amp;gt;&amp;amp;OLDERR&amp;quot;;
  }
  1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When if I modify the code to use the modified module:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  share_test2.pl
  -------------
  use MyShared2;
  print &amp;quot;Content-type: text/plain\r\n\r\n&amp;quot;;
  print &amp;quot;PID: $$\n&amp;quot;;
  MyShared2::match();
  MyShared2::print_pos();
  MyShared2::dump();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And run it as before (with MaxClients 2), two dump files will be created in the directory &lt;em&gt;/tmp&lt;/em&gt;. In our test these were created as &lt;em&gt;/tmp/dump.1224&lt;/em&gt; and &lt;em&gt;/tmp/dump.1225&lt;/em&gt;. When I run diff(1):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % diff /tmp/dump.1224 /tmp/dump.1225
  12c12
  &amp;lt;       MG_LEN = 1
  ---
  &amp;gt;       MG_LEN = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We see that the two padlists (of the variable &lt;code&gt;readonly&lt;/code&gt;) are different, as we have observed before when I did a manual comparison.&lt;/p&gt;

&lt;p&gt;In fact we if we think about these results again, we get to a conclusion that there is no need for two processes to find out whether the variable gets modified (and therefore unshared). It&amp;rsquo;s enough to check the datastructure before the script was executed and after that. You can modify the &lt;code&gt;MyShared2&lt;/code&gt; module to dump the padlists into a different file after each invocation and than to run the &lt;code&gt;diff(1)&lt;/code&gt; on the two files.&lt;/p&gt;

&lt;p&gt;If you want to watch whether some lexically scoped (with &lt;code&gt;my())&lt;/code&gt; variables in your &lt;code&gt;Apache::Registry&lt;/code&gt; script inside the same process get changed between invocations you can use the &lt;code&gt;Apache::RegistryLexInfo&lt;/code&gt; module instead. Since it does exactly this: it makes a snapshot of the padlist before and after the code execution and shows the difference between the two. This specific module was written to work with &lt;code&gt;Apache::Registry&lt;/code&gt; scripts so it won&amp;rsquo;t work for loaded modules. Use the technique I have described above for any type of variables in modules and scripts.&lt;/p&gt;

&lt;p&gt;Surely another way of ensuring that a scalar is readonly and therefore sharable is to either use the &lt;code&gt;constant&lt;/code&gt; pragma or &lt;code&gt;readonly&lt;/code&gt; pragma. But then you won&amp;rsquo;t be able to make calls that alter the variable even a little, like in the example that I&amp;rsquo;ve just showen, because it will be a true constant variable and you will get compile time error if you try this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  MyConstant.pm
  -------------
  package MyConstant;
  use constant readonly =&amp;gt; &amp;quot;Chris&amp;quot;;

  sub match    { readonly =~ /\w/g;               }
  sub print_pos{ print &amp;quot;pos: &amp;quot;,pos(readonly),&amp;quot;\n&amp;quot;;}
  1;

  % perl -c MyConstant.pm

  Can&#39;t modify constant item in match position at MyConstant.pm line
  5, near &amp;quot;readonly)&amp;quot;
  MyConstant.pm had compilation errors.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However this code is just right:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  MyConstant1.pm
  -------------
  package MyConstant1;
  use constant readonly =&amp;gt; &amp;quot;Chris&amp;quot;;

  sub match { readonly =~ /\w/g; }
  1;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-preloading-perl-modules-at-server-startup-preloading-perl-modules-at-server-startup-span&#34;&gt;&lt;span id=&#34;preloading_perl_modules_at_server_startup&#34;&gt;Preloading Perl Modules at Server Startup&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;You can use the &lt;code&gt;PerlRequire&lt;/code&gt; and &lt;code&gt;PerlModule&lt;/code&gt; directives to load commonly used modules such as &lt;code&gt;CGI.pm&lt;/code&gt;, &lt;code&gt;DBI&lt;/code&gt; and etc., when the server is started. On most systems, server children will be able to share the code space used by these modules. Just add the following directives into &lt;em&gt;httpd.conf&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  PerlModule CGI
  PerlModule DBI
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But an even better approach is to create a separate startup file (where you code in plain perl) and put there things like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use DBI ();
  use Carp ();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Don&amp;rsquo;t forget to prevent importing of the symbols exported by default by the module you are going to preload, by placing empty parentheses &lt;code&gt;()&lt;/code&gt; after a module&amp;rsquo;s name. Unless you need some of these in the startup file, which is unlikely. This will save you a few more memory bits.&lt;/p&gt;

&lt;p&gt;Then you &lt;code&gt;require()&lt;/code&gt; this startup file in &lt;em&gt;httpd.conf&lt;/em&gt; with the &lt;code&gt;PerlRequire&lt;/code&gt; directive, placing it before the rest of the mod_perl configuration directives:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  PerlRequire /path/to/start-up.pl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;CGI.pm&lt;/code&gt; is a special case. Ordinarily &lt;code&gt;CGI.pm&lt;/code&gt; autoloads most of its functions on an as-needed basis. This speeds up the loading time by deferring the compilation phase. When you use mod_perl, FastCGI or another system that uses a persistent Perl interpreter, you will want to precompile the functions at initialization time. To accomplish this, call the package function &lt;code&gt;compile()&lt;/code&gt; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use CGI ();
  CGI-&amp;gt;compile(&#39;:all&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The arguments to &lt;code&gt;compile()&lt;/code&gt; are a list of method names or sets, and are identical to those accepted by the &lt;code&gt;use()&lt;/code&gt; and &lt;code&gt;import()&lt;/code&gt; operators. Note that in most cases you will want to replace &lt;code&gt;&#39;:all&#39;&lt;/code&gt; with the tag names that you actually use in your code, since generally you only use a subset of them.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s conduct a memory usage test to prove that preloading, reduces memory requirements.&lt;/p&gt;

&lt;p&gt;In order to have an easy measurement I will use only one child process, therefore I will use this setting:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  MinSpareServers 1
  MaxSpareServers 1
  StartServers 1
  MaxClients 1
  MaxRequestsPerChild 100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;m going to use the &lt;code&gt;Apache::Registry&lt;/code&gt; script &lt;em&gt;memuse.pl&lt;/em&gt; which consists of two parts: the first one preloads a bunch of modules (that most of them aren&amp;rsquo;t going to be used), the second part reports the memory size and the shared memory size used by the single child process that I start. and of course it prints the difference between the two sizes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  memuse.pl
  ---------
  use strict;
  use CGI ();
  use DB_File ();
  use LWP::UserAgent ();
  use Storable ();
  use DBI ();
  use GTop ();

  my $r = shift;
  $r-&amp;gt;send_http_header(&#39;text/plain&#39;);
  my $proc_mem = GTop-&amp;gt;new-&amp;gt;proc_mem($$);
  my $size  = $proc_mem-&amp;gt;size;
  my $share = $proc_mem-&amp;gt;share;
  my $diff  = $size - $share;
  printf &amp;quot;%10s %10s %10s\n&amp;quot;, qw(Size Shared Difference);
  printf &amp;quot;%10d %10d %10d (bytes)\n&amp;quot;,$size,$share,$diff;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First I restart the server and execute this CGI script when none of the above modules preloaded. Here is the result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     Size   Shared     Diff
  4706304  2134016  2572288 (bytes)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I take all the modules:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use strict;
  use CGI ();
  use DB_File ();
  use LWP::UserAgent ();
  use Storable ();
  use DBI ();
  use GTop ();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and copy them into the startup script, so they will get preloaded. The script remains unchanged. I restart the server and execute it again. I get the following.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     Size   Shared    Diff
  4710400  3997696  712704 (bytes)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s put the two results into one table:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Preloading    Size   Shared     Diff
     Yes     4710400  3997696   712704 (bytes)
      No     4706304  2134016  2572288 (bytes)
  --------------------------------------------
  Difference    4096  1863680 -1859584
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can clearly see that when the modules weren&amp;rsquo;t preloaded the shared memory pages size, were about 1864Kb smaller relative to the case where the modules were preloaded.&lt;/p&gt;

&lt;p&gt;Assuming that you have had 256M dedicated to the web server, if you didn&amp;rsquo;t preload the modules, you could have:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  268435456 = X * 2572288 + 2134016

  X = (268435456 - 2134016) / 2572288 = 103
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;103 servers.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s calculate the same thing with modules preloaded:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  268435456 = X * 712704 + 3997696

  X = (268435456 - 3997696) / 712704 = 371
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can have almost 4 times more servers!!!&lt;/p&gt;

&lt;p&gt;Remember that I have mentioned before that memory pages gets dirty and the size of the shared memory gets smaller with time? So I have presented the ideal case where the shared memory stays intact. Therefore the real numbers will be a little bit different, but not far from the numbers in our example.&lt;/p&gt;

&lt;p&gt;Also it&amp;rsquo;s obvious that in your case it&amp;rsquo;s possible that the process size will be bigger and the shared memory will be smaller, since you will use different modules and a different code, so you won&amp;rsquo;t get this fantastic ratio, but this example is certainly helps to feel the difference.&lt;/p&gt;

&lt;h3 id=&#34;span-id-references-references-span&#34;&gt;&lt;span id=&#34;references&#34;&gt;References&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The mod_perl site&amp;rsquo;s URL: &lt;a href=&#34;http://perl.apache.org/&#34;&gt;http://perl.apache.org/&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://metacpan.org/pod/GTop&#34;&gt;GTop&lt;/a&gt; relies in turn on libgtop library not available for all platforms&lt;/p&gt;

&lt;p&gt;Visit &lt;a href=&#34;http://home-of-linux.org/gnome/libgtop/&#34;&gt;http://home-of-linux.org/gnome/libgtop/&lt;/a&gt; for more information&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://metacpan.org/pod/Apache::Peek&#34;&gt;Apache::Peek&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://metacpan.org/pod/Devel::Peek&#34;&gt;Devel::Peek&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Improving mod_perl Sites&#39; Performance: Part 3</title>
      <link>http://localhost:1313/pub/2002/07/16/mod_perl.html/</link>
      <pubDate>Tue, 16 Jul 2002 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2002/07/16/mod_perl.html/</guid>
      <description>

&lt;p&gt;In this article we will continue the topic started in the previous article. This time we talk about tools that help us with code profiling and memory usage measuring.&lt;/p&gt;

&lt;h3 id=&#34;span-id-code-profiling-techniques-code-profiling-techniques-span&#34;&gt;&lt;span id=&#34;code_profiling_techniques&#34;&gt;Code Profiling Techniques&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The profiling process helps you to determine which subroutines or just snippets of code take the longest time to execute and which subroutines are called most often. You will probably just want to optimize those.&lt;/p&gt;

&lt;p&gt;When do you need to profile your code? You do that when you suspect that some part of your code is being called very often and so there may be a need to optimize it to significantly improve the overall performance.&lt;/p&gt;

&lt;p&gt;For example, you might have used the &lt;code&gt;diagnostics&lt;/code&gt; pragma, which extends the terse diagnostics normally emitted by both the Perl compiler and the Perl interpreter, augmenting them with the more verbose and endearing descriptions found in the &lt;code&gt;perldiag&lt;/code&gt; manpage. If you&amp;rsquo;ve ever done so, then you know that it might slow your code down tremendously, so let&amp;rsquo;s first see whether or not it actually does.&lt;/p&gt;

&lt;p&gt;We will run a benchmark, once with diagnostics enabled and once disabled, on a subroutine called &lt;em&gt;test_code&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The code inside the subroutine does an arithmetic and a numeric comparison of two strings. It assigns one string to another if the condition tests true but the condition always tests false. To demonstrate the &lt;code&gt;diagnostics&lt;/code&gt; overhead the comparison operator is intentionally &lt;em&gt;wrong&lt;/em&gt;. It should be a string comparison, not a numeric one.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use Benchmark;
  use diagnostics;
  use strict;

  my $count = 50000;

  disable diagnostics;
  my $t1 = timeit($count,\&amp;amp;test_code);

  enable  diagnostics;
  my $t2 = timeit($count,\&amp;amp;test_code);

  print &amp;quot;Off: &amp;quot;,timestr($t1),&amp;quot;\n&amp;quot;;
  print &amp;quot;On : &amp;quot;,timestr($t2),&amp;quot;\n&amp;quot;;

  sub test_code{
    my ($a,$b) = qw(foo bar);
    my $c;
    if ($a == $b) {
      $c = $a;
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For only a few lines of code we get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Off:  1 wallclock secs ( 0.81 usr +  0.00 sys =  0.81 CPU)
  On : 13 wallclock secs (12.54 usr +  0.01 sys = 12.55 CPU)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With &lt;code&gt;diagnostics&lt;/code&gt; enabled, the subroutine &lt;code&gt;test_code()&lt;/code&gt; is 16 times slower than with &lt;code&gt;diagnostics&lt;/code&gt; disabled!&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s fix the comparison the way it should be, by replacing &lt;code&gt;==&lt;/code&gt; with &lt;code&gt;eq&lt;/code&gt;, so we get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my ($a,$b) = qw(foo bar);
    my $c;
    if ($a eq $b) {
      $c = $a;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and run the same benchmark again:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Off:  1 wallclock secs ( 0.57 usr +  0.00 sys =  0.57 CPU)
  On :  1 wallclock secs ( 0.56 usr +  0.00 sys =  0.56 CPU)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now there is no overhead at all. The &lt;code&gt;diagnostics&lt;/code&gt; pragma slows things down only when warnings are generated.&lt;/p&gt;

&lt;p&gt;After we have verified that using the &lt;code&gt;diagnostics&lt;/code&gt; pragma might adds a big overhead to execution runtime, let&amp;rsquo;s use the code profiling to understand why this happens. We are going to use &lt;code&gt;Devel::DProf&lt;/code&gt; to profile the code. Let&amp;rsquo;s use this code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  diagnostics.pl
  --------------
  use diagnostics;
  print &amp;quot;Content-type: text/html\n\n&amp;quot;;
  test_code();
  sub test_code{
    my ($a,$b) = qw(foo bar);
    my $c;
    if ($a == $b) {
      $c = $a;
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run it with the profiler enabled, and then create the profiling stastics with the help of dprofpp:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % perl -d:DProf diagnostics.pl
  % dprofpp

  Total Elapsed Time = 0.342236 Seconds
    User+System Time = 0.335420 Seconds
  Exclusive Times
  %Time ExclSec CumulS #Calls sec/call Csec/c  Name
   92.1   0.309  0.358      1   0.3089 0.3578  main::BEGIN
   14.9   0.050  0.039   3161   0.0000 0.0000  diagnostics::unescape
   2.98   0.010  0.010      2   0.0050 0.0050  diagnostics::BEGIN
   0.00   0.000 -0.000      2   0.0000      -  Exporter::import
   0.00   0.000 -0.000      2   0.0000      -  Exporter::export
   0.00   0.000 -0.000      1   0.0000      -  Config::BEGIN
   0.00   0.000 -0.000      1   0.0000      -  Config::TIEHASH
   0.00   0.000 -0.000      2   0.0000      -  Config::FETCH
   0.00   0.000 -0.000      1   0.0000      -  diagnostics::import
   0.00   0.000 -0.000      1   0.0000      -  main::test_code
   0.00   0.000 -0.000      2   0.0000      -  diagnostics::warn_trap
   0.00   0.000 -0.000      2   0.0000      -  diagnostics::splainthis
   0.00   0.000 -0.000      2   0.0000      -  diagnostics::transmo
   0.00   0.000 -0.000      2   0.0000      -  diagnostics::shorten
   0.00   0.000 -0.000      2   0.0000      -  diagnostics::autodescribe
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s not easy to see what is responsible for this enormous overhead, even if &lt;code&gt;main::BEGIN&lt;/code&gt; seems to be running most of the time. To get the full picture we must see the OPs tree, which shows us who calls whom, so we run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % dprofpp -T
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the output is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; main::BEGIN
   diagnostics::BEGIN
      Exporter::import
         Exporter::export
   diagnostics::BEGIN
      Config::BEGIN
      Config::TIEHASH
      Exporter::import
         Exporter::export
   Config::FETCH
   Config::FETCH
   diagnostics::unescape
   .....................
   3159 times [diagnostics::unescape] snipped
   .....................
   diagnostics::unescape
   diagnostics::import
 diagnostics::warn_trap
   diagnostics::splainthis
      diagnostics::transmo
      diagnostics::shorten
      diagnostics::autodescribe
 main::test_code
   diagnostics::warn_trap
      diagnostics::splainthis
         diagnostics::transmo
         diagnostics::shorten
         diagnostics::autodescribe
   diagnostics::warn_trap
      diagnostics::splainthis
         diagnostics::transmo
         diagnostics::shorten
        diagnostics::autodescribe
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we see that two executions of &lt;code&gt;diagnostics::BEGIN&lt;/code&gt; and 3161 of &lt;code&gt;diagnostics::unescape&lt;/code&gt; are responsible for most of the running overhead.&lt;/p&gt;

&lt;p&gt;If we comment out the &lt;code&gt;diagnostics&lt;/code&gt; module, we get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Total Elapsed Time = 0.079974 Seconds
    User+System Time = 0.059974 Seconds
  Exclusive Times
  %Time ExclSec CumulS #Calls sec/call Csec/c  Name
   0.00   0.000 -0.000      1   0.0000      -  main::test_code
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is possible to profile code running under mod_perl with the &lt;code&gt;Devel::DProf&lt;/code&gt; module, available on CPAN. However, you must have apache version 1.3b3 or higher and the &lt;code&gt;PerlChildExitHandler&lt;/code&gt; enabled during the httpd build process. When the server is started, &lt;code&gt;Devel::DProf&lt;/code&gt; installs an &lt;code&gt;END&lt;/code&gt; block to write the &lt;em&gt;tmon.out&lt;/em&gt; file. This block will be called at server shutdown. Here is how to start and stop a server with the profiler enabled:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % setenv PERL5OPT -d:DProf
  % httpd -X -d `pwd` &amp;amp;
  ... make some requests to the server here ...
  % kill `cat logs/httpd.pid`
  % unsetenv PERL5OPT
  % dprofpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Devel::DProf&lt;/code&gt; package is a Perl code profiler. It will collect information on the execution time of a Perl script and of the subs in that script (remember that &lt;code&gt;print()&lt;/code&gt; and &lt;code&gt;map()&lt;/code&gt; are just like any other subroutines you write, but they come bundled with Perl!)&lt;/p&gt;

&lt;p&gt;Another approach is to use &lt;code&gt;Apache::DProf&lt;/code&gt;, which hooks &lt;code&gt;Devel::DProf&lt;/code&gt; into mod_perl. The &lt;code&gt;Apache::DProf&lt;/code&gt; module will run a &lt;code&gt;Devel::DProf&lt;/code&gt; profiler inside each child server and write the &lt;em&gt;tmon.out&lt;/em&gt; file in the directory &lt;code&gt;$ServerRoot/logs/dprof/$$&lt;/code&gt; when the child is shutdown (where &lt;code&gt;$$&lt;/code&gt; is the number of the child process). All it takes is to add to &lt;em&gt;httpd.conf&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  PerlModule Apache::DProf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remember that any PerlHandler that was pulled in before &lt;code&gt;Apache::DProf&lt;/code&gt; in the &lt;em&gt;httpd.conf&lt;/em&gt; or &lt;em&gt;startup.pl&lt;/em&gt;, will not have its code debugging information inserted. To run &lt;code&gt;dprofpp&lt;/code&gt;, chdir to &lt;code&gt;$ServerRoot/logs/dprof/$$&lt;/code&gt; and run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % dprofpp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Lookup the &lt;code&gt;ServerRoot&lt;/code&gt; directive&amp;rsquo;s value in &lt;em&gt;httpd.conf&lt;/em&gt; to figure out what your &lt;code&gt;$ServerRoot&lt;/code&gt; is.)&lt;/p&gt;

&lt;h3 id=&#34;span-id-measuring-the-memory-of-the-process-measuring-the-memory-of-the-process-span&#34;&gt;&lt;span id=&#34;measuring_the_memory_of_the_process&#34;&gt;Measuring the Memory of the Process&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;One very important aspect of performance tuning is to make sure that your applications don&amp;rsquo;t use much memory, since if they do you cannot run many servers and therefore in most cases under a heavy load the overall performance degrades.&lt;/p&gt;

&lt;p&gt;In addition the code may not be clean and leak memory, which is even worse. In this case, the same process serves many requests and after each request more memory is used. After a while all your RAM will be used and machine will start swapping (use the swap partition) which is a very undesirable event, since it may lead to a machine crash.&lt;/p&gt;

&lt;p&gt;The simplest way to figure out how big the processes are and see whether they grow is to watch the output of &lt;code&gt;top(1)&lt;/code&gt; or &lt;code&gt;ps(1)&lt;/code&gt; utilities.&lt;/p&gt;

&lt;p&gt;For example the output of top(1):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    8:51am  up 66 days,  1:44,  1 user,  load average: 1.09, 2.27, 2.61
  95 processes: 92 sleeping, 3 running, 0 zombie, 0 stopped
  CPU states: 54.0% user,  9.4% system,  1.7% nice, 34.7% idle
  Mem:  387664K av, 309692K used,  77972K free, 111092K shrd,  70944K buff
  Swap: 128484K av,  11176K used, 117308K free                170824K cached

     PID USER PRI NI SIZE  RSS SHARE STAT LIB %CPU %MEM   TIME COMMAND
  29225 nobody 0  0  9760 9760  7132 S      0 12.5  2.5   0:00 httpd_perl
  29220 nobody 0  0  9540 9540  7136 S      0  9.0  2.4   0:00 httpd_perl
  29215 nobody 1  0  9672 9672  6884 S      0  4.6  2.4   0:01 httpd_perl
  29255 root   7  0  1036 1036   824 R      0  3.2  0.2   0:01 top
    376 squid  0  0 15920  14M   556 S      0  1.1  3.8 209:12 squid
  29227 mysql  5  5  1892 1892   956 S N    0  1.1  0.4   0:00 mysqld
  29223 mysql  5  5  1892 1892   956 S N    0  0.9  0.4   0:00 mysqld
  29234 mysql  5  5  1892 1892   956 S N    0  0.9  0.4   0:00 mysqld
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which starts with overall information of the system and then displays the most active processes at the given moment. So for example if we look at the &lt;code&gt;httpd_perl&lt;/code&gt; processes we can see the size of the resident (&lt;code&gt;RSS&lt;/code&gt;) and shared (&lt;code&gt;SHARE&lt;/code&gt;) memory segments. This sample was taken on the production server running linux.&lt;/p&gt;

&lt;p&gt;But of course we want to see all the apache/mod_perl processes, and that&amp;rsquo;s where &lt;code&gt;ps(1)&lt;/code&gt; comes to help. The options of this utility vary from one Unix flavor to another, and some flavors provide their own tools. Let&amp;rsquo;s check the information about mod_perl processes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % ps -o pid,user,rss,vsize,%cpu,%mem,ucomm -C httpd_perl
    PID USER      RSS   VSZ %CPU %MEM COMMAND
  29213 root     8584 10264  0.0  2.2 httpd_perl
  29215 nobody   9740 11316  1.0  2.5 httpd_perl
  29216 nobody   9668 11252  0.7  2.4 httpd_perl
  29217 nobody   9824 11408  0.6  2.5 httpd_perl
  29218 nobody   9712 11292  0.6  2.5 httpd_perl
  29219 nobody   8860 10528  0.0  2.2 httpd_perl
  29220 nobody   9616 11200  0.5  2.4 httpd_perl
  29221 nobody   8860 10528  0.0  2.2 httpd_perl
  29222 nobody   8860 10528  0.0  2.2 httpd_perl
  29224 nobody   8860 10528  0.0  2.2 httpd_perl
  29225 nobody   9760 11340  0.7  2.5 httpd_perl
  29235 nobody   9524 11104  0.4  2.4 httpd_perl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you can see the resident (&lt;code&gt;RSS&lt;/code&gt;) and virtual (&lt;code&gt;VSZ&lt;/code&gt;) memory segments (and shared memory segment if you ask for it) of all mod_perl processes. Please refer to the &lt;code&gt;top(1)&lt;/code&gt; and &lt;code&gt;ps(1)&lt;/code&gt; man pages for more information.&lt;/p&gt;

&lt;p&gt;You probably agree that using &lt;code&gt;top(1)&lt;/code&gt; and &lt;code&gt;ps(1)&lt;/code&gt; are cumbersome if we want to use memory size sampling during the benchmark test. We want to have a way to print memory sizes during the program execution at desired places. If you have &lt;code&gt;GTop&lt;/code&gt; modules installed, which is a perl glue to the &lt;code&gt;libgtop&lt;/code&gt; library, it&amp;rsquo;s exactly what we need.&lt;/p&gt;

&lt;p&gt;Note: &lt;code&gt;GTop&lt;/code&gt; requires the &lt;code&gt;libgtop&lt;/code&gt; library but is not available for all platforms. Visit &lt;a href=&#34;http://www.home-of-linux.org/gnome/libgtop/&#34;&gt;http://www.home-of-linux.org/gnome/libgtop/&lt;/a&gt; to check whether your platform/flavor is supported.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;GTop&lt;/code&gt; provides an API for retrieval of information about processes and the whole system. We are only interested in memory sampling API methods. To print all the process related memory information we can execute the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use GTop;
  my $gtop = GTop-&amp;gt;new;
  my $proc_mem = $gtop-&amp;gt;proc_mem($$);
  for (qw(size vsize share rss)) {
      printf &amp;quot;   %s =&amp;gt; %d\n&amp;quot;, $_, $proc_mem-&amp;gt;$_();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When executed we see the following output (in bytes):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      size =&amp;gt; 1900544
     vsize =&amp;gt; 3108864
     share =&amp;gt; 1392640
       rss =&amp;gt; 1900544
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So if we are interested in to print the process resident memory segment before and after some event we just do it: For example if we want to see how much extra memory was allocated after a variable creation we can write the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use GTop;
  my $gtop = GTop-&amp;gt;new;
  my $before = $gtop-&amp;gt;proc_mem($$)-&amp;gt;rss;
  my $x = &#39;a&#39; x 10000;
  my $after  = $gtop-&amp;gt;proc_mem($$)-&amp;gt;rss;
  print &amp;quot;diff: &amp;quot;,$after-$before, &amp;quot; bytes\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the output&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  diff: 20480 bytes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we can see that Perl has allocated extra 20480 bytes to create &lt;code&gt;$x&lt;/code&gt; (of course the creation of &lt;code&gt;after&lt;/code&gt; needed a few bytes as well, but it&amp;rsquo;s insignificant compared to a size of &lt;code&gt;$x&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Apache::VMonitor&lt;/code&gt; module with help of the &lt;code&gt;GTop&lt;/code&gt; module allows you to watch all your system information using your favorite browser from anywhere in the world without a need to telnet to your machine. If you are looking into what information you can retrieve with &lt;code&gt;GTop&lt;/code&gt;, you should examine &lt;code&gt;Apache::VMonitor&lt;/code&gt;, as it deploys a big part of the API that &lt;code&gt;GTop&lt;/code&gt; provides.&lt;/p&gt;

&lt;p&gt;If you are running a true BSD system, you may use &lt;code&gt;BSD::Resource::getrusage&lt;/code&gt; instead of &lt;code&gt;GTop&lt;/code&gt;. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  print &amp;quot;used memory = &amp;quot;.(BSD::Resource::getrusage)[2].&amp;quot;\n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For more information refer to the &lt;code&gt;BSD::Resource&lt;/code&gt; manpage.&lt;/p&gt;

&lt;h3 id=&#34;span-id-measuring-the-memory-usage-of-subroutines-measuring-the-memory-usage-of-subroutines-span&#34;&gt;&lt;span id=&#34;measuring_the_memory_usage_of_subroutines&#34;&gt;Measuring the Memory Usage of Subroutines&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;With help of &lt;code&gt;Apache::Status&lt;/code&gt; you can find out the size of each and every subroutine.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Build and install mod_perl as you always do, make sure it&amp;rsquo;s version 1.22 or higher.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Configure /perl-status if you haven&amp;rsquo;t already:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;Location /perl-status&amp;gt;
    SetHandler perl-script
    PerlHandler Apache::Status
    order deny,allow
    #deny from all
    #allow from ...
  &amp;lt;/Location&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Add to httpd.conf&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  PerlSetVar StatusOptionsAll On
  PerlSetVar StatusTerse On
  PerlSetVar StatusTerseSize On
  PerlSetVar StatusTerseSizeMainSummary On

  PerlModule B::TerseSize
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Start the server (best in httpd -X mode)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;From your favorite browser fetch &lt;a href=&#34;http://localhost/perl-status&#34;&gt;http://localhost/perl-status&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Click on &amp;lsquo;Loaded Modules&amp;rsquo; or &amp;lsquo;Compiled Registry Scripts&amp;rsquo;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Click on the module or script of your choice (you might need to run some script/handler before you will see it here unless it was preloaded)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Click on &amp;lsquo;Memory Usage&amp;rsquo; at the bottom&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You should see all the subroutines and their respective sizes.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now you can start to optimize your code, or test which of several implementations is of the least size.&lt;/p&gt;

&lt;p&gt;For example let&amp;rsquo;s compare &lt;code&gt;CGI.pm&lt;/code&gt;&amp;rsquo;s OO vs. procedural interfaces:&lt;/p&gt;

&lt;p&gt;As you will see below the first OO script uses about 2k bytes while the second script (procedural interface) uses about 5k.&lt;/p&gt;

&lt;p&gt;Here are the code examples and the numbers:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;cgi_oo.pl
      &amp;mdash;&amp;mdash;&amp;mdash;
      use CGI ();
      my $q = CGI-&amp;gt;new;
      print $q-&amp;gt;header;
      print $q-&amp;gt;b(&amp;ldquo;Hello&amp;rdquo;);&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cgi_mtd.pl
      &amp;mdash;&amp;mdash;&amp;mdash;
      use CGI qw(header b);
      print header();
      print b(&amp;ldquo;Hello&amp;rdquo;);&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;After executing each script in single server mode (-X) the results are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Totals: 1966 bytes | 27 OPs&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  handler 1514 bytes | 27 OPs
  exit     116 bytes |  0 OPs
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Totals: 4710 bytes | 19 OPs&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  handler  1117 bytes | 19 OPs
  basefont  120 bytes |  0 OPs
  frameset  120 bytes |  0 OPs
  caption   119 bytes |  0 OPs
  applet    118 bytes |  0 OPs
  script    118 bytes |  0 OPs
  ilayer    118 bytes |  0 OPs
  header    118 bytes |  0 OPs
  strike    118 bytes |  0 OPs
  layer     117 bytes |  0 OPs
  table     117 bytes |  0 OPs
  frame     117 bytes |  0 OPs
  style     117 bytes |  0 OPs
  Param     117 bytes |  0 OPs
  small     117 bytes |  0 OPs
  embed     117 bytes |  0 OPs
  font      116 bytes |  0 OPs
  span      116 bytes |  0 OPs
  exit      116 bytes |  0 OPs
  big       115 bytes |  0 OPs
  div       115 bytes |  0 OPs
  sup       115 bytes |  0 OPs
  Sub       115 bytes |  0 OPs
  TR        114 bytes |  0 OPs
  td        114 bytes |  0 OPs
  Tr        114 bytes |  0 OPs
  th        114 bytes |  0 OPs
  b         113 bytes |  0 OPs
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Note, that the above is correct if you didn&amp;rsquo;t precompile all &lt;code&gt;CGI.pm&lt;/code&gt;&amp;rsquo;s methods at server startup. Since if you did, the procedural interface in the second test will take up to 18k and not 5k as we saw. That&amp;rsquo;s because the whole of &lt;code&gt;CGI.pm&lt;/code&gt;&amp;rsquo;s namespace is inherited and it already has all its methods compiled, so it doesn&amp;rsquo;t really matter whether you attempt to import only the symbols that you need. So if you have:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use CGI  qw(-compile :all);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in the server startup script. Having:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use CGI qw(header);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use CGI qw(:all);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is essentially the same. You will have all the symbols precompiled at startup imported even if you ask for only one symbol. It seems to me like a bug, but probably that&amp;rsquo;s how &lt;code&gt;CGI.pm&lt;/code&gt; works.&lt;/p&gt;

&lt;p&gt;BTW, you can check the number of opcodes in the code by a simple command line run. For example comparing &amp;lsquo;my %hash&amp;rsquo; vs. &amp;lsquo;my %hash = ()&amp;rsquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % perl -MO=Terse -e &#39;my %hash&#39; | wc -l
  -e syntax OK
      4

  % perl -MO=Terse -e &#39;my %hash = ()&#39; | wc -l
  -e syntax OK
     10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first one has fewer opcodes.&lt;/p&gt;

&lt;p&gt;Note that you shouldn&amp;rsquo;t use &lt;code&gt;Apache::Status&lt;/code&gt; module on production server as it adds quite a bit of overhead to each request.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;span-id-references-references-span&#34;&gt;&lt;span id=&#34;references&#34;&gt;References&lt;/span&gt;&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;The mod_perl site&amp;rsquo;s URL: &lt;a href=&#34;http://perl.apache.org&#34;&gt;http://perl.apache.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Devel::DProf&#34;&gt;Devel::DProf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Apache::DProf&#34;&gt;Apache::DProf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Apache::VMonitor&#34;&gt;Apache::VMonitor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/GTop&#34;&gt;GTop&lt;/a&gt;
The home of the C library: &lt;a href=&#34;http://www.home-of-linux.org/gnome/libgtop/&#34;&gt;http://www.home-of-linux.org/gnome/libgtop/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/BSD::Resource&#34;&gt;BSD::Resource&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Improving mod_perl Sites&#39; Performance: Part 2</title>
      <link>http://localhost:1313/pub/2002/06/19/mod_perl.html/</link>
      <pubDate>Wed, 19 Jun 2002 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2002/06/19/mod_perl.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;In this article we will talk about tools that we need before we can start working on the performance of our service.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;span-id-essential-tools-essential-tools-span&#34;&gt;&lt;span id=&#34;essential_tools&#34;&gt;Essential Tools&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;In order to improve performance, we need measurement tools. The main tool categories are benchmarking and code profiling.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s important to understand that, in a large number of the benchmarking tests that we will execute, we will not look at the absolute result numbers but the relation between two or more result sets. The purpose of the benchmarks is to try to show which coding approach is preferable. You shouldn&amp;rsquo;t try to compare the &lt;strong&gt;absolute&lt;/strong&gt; results presented in the articles with those that you get while running the same benchmarks on your machine, since you won&amp;rsquo;t have the exact hardware and software setup anyway. This kind of comparison would be misleading. If you compare the relative results from the tests running on your machine, then you will do the right thing.&lt;/p&gt;

&lt;h3 id=&#34;span-id-benchmarking-applications-benchmarking-applications-span&#34;&gt;&lt;span id=&#34;benchmarking_applications&#34;&gt;Benchmarking Applications&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;How much faster is mod_perl than mod_cgi (aka plain Perl/CGI)? There are many ways to benchmark the two. I&amp;rsquo;ll present a few examples and numbers below. Check out the &lt;code&gt;benchmark&lt;/code&gt; directory of the mod_perl distribution for more examples.&lt;/p&gt;

&lt;p&gt;There is no need to write a special benchmark though. If you want to impress your boss or colleagues, then just take some heavy CGI script you have (e.g. a script that crunches some data and prints the results to STDOUT), open two xterms and call the same script in mod_perl mode in one xterm and in mod_cgi mode in the other. You can use &lt;code&gt;lwp-get&lt;/code&gt; from the &lt;code&gt;LWP&lt;/code&gt; package to emulate the browser. The &lt;code&gt;benchmark&lt;/code&gt; directory of the mod_perl distribution includes such an example.&lt;/p&gt;

&lt;h4 id=&#34;span-id-benchmarking-perl-code-benchmarking-perl-code-span&#34;&gt;&lt;span id=&#34;benchmarking_perl_code&#34;&gt;Benchmarking Perl Code&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;If you are going to write your own benchmarking utility, then use the &lt;code&gt;Benchmark&lt;/code&gt; module and the &lt;code&gt;Time::HiRes&lt;/code&gt; module where you need better time precision (&amp;lt;10msec).&lt;/p&gt;

&lt;p&gt;An example of the &lt;code&gt;Benchmark.pm&lt;/code&gt; module usage:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  benchmark.pl
  ------------
  use Benchmark;

  timethis (1_000,
   sub {
    my $x = 100;
    my $y = log ($x ** 100)  for (0..10000);
  });

  % perl benchmark.pl
  timethis 1000: 25 wallclock secs (24.93 usr +  0.00 sys = 24.93 CPU)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to get the benchmark results in microseconds, then you will have to use the &lt;code&gt;Time::HiRes&lt;/code&gt; module. Its usage is similar to &lt;code&gt;Benchmark&lt;/code&gt;&amp;rsquo;s.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use Time::HiRes qw(gettimeofday tv_interval);
  my $start_time = [ gettimeofday ];
  sub_that_takes_a_teeny_bit_of_time();
  my $end_time = [ gettimeofday ];
  my $elapsed = tv_interval($start_time,$end_time);
  print &amp;quot;The sub took $elapsed seconds.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-benchmarking-a-graphic-hits-counter-with-persistent-db-connections-benchmarking-a-graphic-hits-counter-with-persistent-db-connections-span&#34;&gt;&lt;span id=&#34;benchmarking_a_graphic_hits_counter_with_persistent_db_connections&#34;&gt;Benchmarking a Graphic Hits Counter with Persistent DB Connections&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Here are the numbers from Michael Parker&amp;rsquo;s mod_perl presentation at the Perl Conference (Aug, 98). The script is a standard hits counter, but it logs the counts into a mysql relational DataBase:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Benchmark: timing 100 iterations of cgi, perl...  [rate 1:28]

    cgi: 56 secs ( 0.33 usr 0.28 sys = 0.61 cpu)
    perl: 2 secs ( 0.31 usr 0.27 sys = 0.58 cpu)

    Benchmark: timing 1000 iterations of cgi,perl...  [rate 1:21]

    cgi: 567 secs ( 3.27 usr 2.83 sys = 6.10 cpu)
    perl: 26 secs ( 3.11 usr 2.53 sys = 5.64 cpu)

    Benchmark: timing 10000 iterations of cgi, perl   [rate 1:21]

    cgi: 6494 secs (34.87 usr 26.68 sys = 61.55 cpu)
    perl: 299 secs (32.51 usr 23.98 sys = 56.49 cpu)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We don&amp;rsquo;t know what server configurations were used for these tests, but I guess the numbers speak for themselves.&lt;/p&gt;

&lt;p&gt;The source code of the script was available online, but, sadly, isn&amp;rsquo;t anymore. However, you can reproduce the same performance speedup with pretty much any CGI script written in Perl.&lt;/p&gt;

&lt;h4 id=&#34;span-id-benchmarking-response-times-with-apachebench-benchmarking-response-times-with-apachebench-span&#34;&gt;&lt;span id=&#34;benchmarking_response_times_with_apachebench&#34;&gt;Benchmarking Response Times With ApacheBench&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;ApacheBench (&lt;strong&gt;ab&lt;/strong&gt;) is a tool for benchmarking your Apache HTTP server. It is designed to give you an idea of the performance that your current Apache installation can give. In particular, it shows you how many requests per second your Apache server is capable of serving. The &lt;strong&gt;ab&lt;/strong&gt; tool comes bundled with the Apache source distribution.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s try it. We will simulate 10 users concurrently requesting a light script at &lt;code&gt;www.example.com/perl/test.pl&lt;/code&gt;. Each simulated user makes 10 requests.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % ./ab -n 100 -c 10 www.example.com/perl/test.pl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The results are:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Document Path:          /perl/test.pl
  Document Length:        319 bytes

  Concurrency Level:      10
  Time taken for tests:   0.715 seconds
  Complete requests:      100
  Failed requests:        0
  Total transferred:      60700 bytes
  HTML transferred:       31900 bytes
  Requests per second:    139.86
  Transfer rate:          84.90 kb/s received

  Connection Times (ms)
                min   avg   max
  Connect:        0     0     3
  Processing:    13    67    71
  Total:         13    67    74
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can see that under load of 10 concurrent users our server is capable of processing 140 requests per second. Of course, this benchmark is correct only when the script under test is used. We can also learn about the average processing time, which in this case was 67 milliseconds. Other numbers reported by &lt;code&gt;ab&lt;/code&gt; may or may not be of interest to you.&lt;/p&gt;

&lt;p&gt;For example, if we believe that the script &lt;em&gt;perl/test.pl&lt;/em&gt; is not efficient, then we will try to improve it and run the benchmark again to see whether we have any improvement in performance.&lt;/p&gt;

&lt;h4 id=&#34;span-id-benchmarking-response-times-with-httperf-benchmarking-response-times-with-httperf-span&#34;&gt;&lt;span id=&#34;benchmarking_response_times_with_httperf&#34;&gt;Benchmarking Response Times With httperf&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;httperf is a utility written by David Mosberger. Just like ApacheBench, it measures the performance of the Web server.&lt;/p&gt;

&lt;p&gt;A sample command line is shown below:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  httperf --server hostname --port 80 --uri /test.html \
   --rate 150 --num-conn 27000 --num-call 1 --timeout 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command causes httperf to use the Web server on the host with IP name &lt;code&gt;hostname&lt;/code&gt;, running at port 80. The Web page being retrieved is &lt;em&gt;/test.html&lt;/em&gt; and, in this simple test, the same page is retrieved repeatedly. The rate at which requests are issued is 150 per second. The test involves initiating a total of 27,000 TCP connections and on each connection one HTTP call is performed. A call consists of sending a request and receiving a reply.&lt;/p&gt;

&lt;p&gt;The timeout option defines the number of seconds that the client is willing to wait to hear back from the server. If this timeout expires, then the tool considers the corresponding call to have failed. Note that with a total of 27,000 connections and a rate of 150 per second, the total test duration will be approximately 180 seconds (27,000/150), independently of what load the server can actually sustain. Here is a result that one might get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     Total: connections 27000 requests 26701 replies 26701 test-duration 179.996 s

     Connection rate: 150.0 conn/s (6.7 ms/conn, &amp;lt;=47 concurrent connections)
     Connection time [ms]: min 1.1 avg 5.0 max 315.0 median 2.5 stddev 13.0
     Connection time [ms]: connect 0.3

     Request rate: 148.3 req/s (6.7 ms/req)
     Request size [B]: 72.0

     Reply rate [replies/s]: min 139.8 avg 148.3 max 150.3 stddev 2.7 (36 samples)
     Reply time [ms]: response 4.6 transfer 0.0
     Reply size [B]: header 222.0 content 1024.0 footer 0.0 (total 1246.0)
     Reply status: 1xx=0 2xx=26701 3xx=0 4xx=0 5xx=0

     CPU time [s]: user 55.31 system 124.41 (user 30.7% system 69.1% total 99.8%)
     Net I/O: 190.9 KB/s (1.6*10^6 bps)

     Errors: total 299 client-timo 299 socket-timo 0 connrefused 0 connreset 0
     Errors: fd-unavail 0 addrunavail 0 ftab-full 0 other 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-benchmarking-response-times-with-http-load-benchmarking-response-times-with-http-load-span&#34;&gt;&lt;span id=&#34;benchmarking_response_times_with_http_load&#34;&gt;Benchmarking Response Times With http_load&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;http_load&lt;/code&gt; is yet another utility that does Web server load testing. It can simulate a 33.6 modem connection (&lt;em&gt;-throttle&lt;/em&gt;) and allows you to provide a file with a list of URLs, which we be fetched randomly. You can specify how many parallel connections to run using the &lt;em&gt;-parallel N&lt;/em&gt; option, or you can specify the number of requests to generate per second with &lt;em&gt;-rate N&lt;/em&gt; option. Finally, you can tell the utility when to stop by specifying either the test time length (&lt;em&gt;-seconds N&lt;/em&gt;) or the total number of fetches (&lt;em&gt;-fetches N&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;A sample run with the file &lt;em&gt;urls&lt;/em&gt; including:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  http://www.example.com/foo/
  http://www.example.com/bar/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We ask to generate three requests per second and run for only two seconds. Here is the generated output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % ./http_load -rate 3 -seconds 2 urls
  http://www.example.com/foo/: check-connect SUCCEEDED, ignoring
  http://www.example.com/bar/: check-connect SUCCEEDED, ignoring
  http://www.example.com/bar/: check-connect SUCCEEDED, ignoring
  http://www.example.com/bar/: check-connect SUCCEEDED, ignoring
  http://www.example.com/foo/: check-connect SUCCEEDED, ignoring
  5 fetches, 3 max parallel, 96870 bytes, in 2.00258 seconds
  19374 mean bytes/connection
  2.49678 fetches/sec, 48372.7 bytes/sec
  msecs/connect: 1.805 mean, 5.24 max, 0.79 min
  msecs/first-response: 291.289 mean, 560.338 max, 34.349 min
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So you can see that it has reported 2.5 requests per second. Of course, for the real test you will want to load the server heavily and run the test for a longer time to get more reliable results.&lt;/p&gt;

&lt;p&gt;Note that when you provide a file with a list of URLs make sure that you don&amp;rsquo;t have empty lines in it. If you do, then the utility won&amp;rsquo;t work, complaining:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ./http_load: unknown protocol -
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-benchmarking-response-times-with-the-crashme-script-benchmarking-response-times-with-crashme-script-span&#34;&gt;&lt;span id=&#34;benchmarking_response_times_with_the_crashme_script&#34;&gt;Benchmarking Response Times With crashme Script&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;This is another crashme suite originally written by Michael Schilli (and was located at &lt;a href=&#34;http://www.linux-magazin.de&#34;&gt;http://www.linux-magazin.de&lt;/a&gt; site, but now the link has gone). I made a few modifications, mostly adding &lt;code&gt;my()&lt;/code&gt; operators. I also allowed it to accept more than one url to test, since sometimes you want to test more than one script.&lt;/p&gt;

&lt;p&gt;The tool provides the same results as &lt;strong&gt;ab&lt;/strong&gt; above but it also allows you to set the timeout value, so requests will fail if not served within the time out period. You also get values for &lt;strong&gt;Latency&lt;/strong&gt; (seconds per request) and &lt;strong&gt;Throughput&lt;/strong&gt; (requests per second). It can do a complete simulation of your favorite Netscape browser :) and give you a better picture.&lt;/p&gt;

&lt;p&gt;I have noticed while running these two benchmarking suites, that &lt;strong&gt;ab&lt;/strong&gt; gave me results from two and a half to three times better. Both suites were run on the same machine, with the same load and the same parameters, but the implementations were different.&lt;/p&gt;

&lt;p&gt;Sample output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  URL(s):          http://www.example.com/perl/access/access.cgi
  Total Requests:  100
  Parallel Agents: 10
  Succeeded:       100 (100.00%)
  Errors:          NONE
  Total Time:      9.39 secs
  Throughput:      10.65 Requests/sec
  Latency:         0.85 secs/Request
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #!/usr/bin/perl -w

  use LWP::Parallel::UserAgent;
  use Time::HiRes qw(gettimeofday tv_interval);
  use strict;

  ###
  # Configuration
  ###

  my $nof_parallel_connections = 10;
  my $nof_requests_total = 100;
  my $timeout = 10;
  my @urls = (
            &#39;http://www.example.com/perl/faq_manager/faq_manager.pl&#39;,
            &#39;http://www.example.com/perl/access/access.cgi&#39;,
           );


  ##################################################
  # Derived Class for latency timing
  ##################################################

  package MyParallelAgent;
  @MyParallelAgent::ISA = qw(LWP::Parallel::UserAgent);
  use strict;

  ###
  # Is called when connection is opened
  ###
  sub on_connect {
    my ($self, $request, $response, $entry) = @_;
    $self-&amp;gt;{__start_times}-&amp;gt;{$entry} = [Time::HiRes::gettimeofday];
  }

  ###
  # Are called when connection is closed
  ###
  sub on_return {
    my ($self, $request, $response, $entry) = @_;
    my $start = $self-&amp;gt;{__start_times}-&amp;gt;{$entry};
    $self-&amp;gt;{__latency_total} += Time::HiRes::tv_interval($start);
  }

  sub on_failure {
    on_return(@_);  # Same procedure
  }

  ###
  # Access function for new instance var
  ###
  sub get_latency_total {
    return shift-&amp;gt;{__latency_total};
  }

  ##################################################
  package main;
  ##################################################
  ###
  # Init parallel user agent
  ###
  my $ua = MyParallelAgent-&amp;gt;new();
  $ua-&amp;gt;agent(&amp;quot;pounder/1.0&amp;quot;);
  $ua-&amp;gt;max_req($nof_parallel_connections);
  $ua-&amp;gt;redirect(0);    # No redirects

  ###
  # Register all requests
  ###
  foreach (1..$nof_requests_total) {
    foreach my $url (@urls) {
      my $request = HTTP::Request-&amp;gt;new(&#39;GET&#39;, $url);
      $ua-&amp;gt;register($request);
    }
  }

  ###
  # Launch processes and check time
  ###
  my $start_time = [gettimeofday];
  my $results = $ua-&amp;gt;wait($timeout);
  my $total_time = tv_interval($start_time);

  ###
  # Requests all done, check results
  ###

  my $succeeded     = 0;
  my %errors = ();

  foreach my $entry (values %$results) {
    my $response = $entry-&amp;gt;response();
    if($response-&amp;gt;is_success()) {
      $succeeded++; # Another satisfied customer
    } else {
      # Error, save the message
      $response-&amp;gt;message(&amp;quot;TIMEOUT&amp;quot;) unless $response-&amp;gt;code();
      $errors{$response-&amp;gt;message}++;
    }
  }

  ###
  # Format errors if any from %errors
  ###
  my $errors = join(&#39;,&#39;, map &amp;quot;$_ ($errors{$_})&amp;quot;, keys %errors);
  $errors = &amp;quot;NONE&amp;quot; unless $errors;

  ###
  # Format results
  ###

  #@urls = map {($_,&amp;quot;.&amp;quot;)} @urls;
  my @P = (
        &amp;quot;URL(s)&amp;quot;          =&amp;gt; join(&amp;quot;\n\t\t &amp;quot;, @urls),
        &amp;quot;Total Requests&amp;quot;  =&amp;gt; &amp;quot;$nof_requests_total&amp;quot;,
        &amp;quot;Parallel Agents&amp;quot; =&amp;gt; $nof_parallel_connections,
        &amp;quot;Succeeded&amp;quot;       =&amp;gt; sprintf(&amp;quot;$succeeded (%.2f%%)\n&amp;quot;,
                                   $succeeded * 100 / $nof_requests_total),
        &amp;quot;Errors&amp;quot;          =&amp;gt; $errors,
        &amp;quot;Total Time&amp;quot;      =&amp;gt; sprintf(&amp;quot;%.2f secs\n&amp;quot;, $total_time),
        &amp;quot;Throughput&amp;quot;      =&amp;gt; sprintf(&amp;quot;%.2f Requests/sec\n&amp;quot;,
                                   $nof_requests_total / $total_time),
        &amp;quot;Latency&amp;quot;         =&amp;gt; sprintf(&amp;quot;%.2f secs/Request&amp;quot;,
                                   ($ua-&amp;gt;get_latency_total() || 0) /
                                   $nof_requests_total),
       );

  my ($left, $right);
  ###
  # Print out statistics
  ###
  format STDOUT =
  @&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; @*
  &amp;quot;$left:&amp;quot;,        $right
  .

  while(($left, $right) = splice(@P, 0, 2)) {
    write;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-benchmarking-perlhandlers-benchmarking-perlhandlers-span&#34;&gt;&lt;span id=&#34;benchmarking_perlhandlers&#34;&gt;Benchmarking PerlHandlers&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;Apache::Timeit&lt;/code&gt; module does &lt;code&gt;PerlHandler&lt;/code&gt; Benchmarking. With the help of this module you can log the time taken to process the request, just like you&amp;rsquo;d use the &lt;code&gt;Benchmark&lt;/code&gt; module to benchmark a regular Perl script. Of course, you can extend this module to perform more advanced processing like putting the results into a database for a later processing. But all it takes is adding this configuration directive inside &lt;em&gt;httpd.conf&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  PerlFixupHandler Apache::Timeit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since scripts running under &lt;code&gt;Apache::Registry&lt;/code&gt; are running inside the PerlHandler these are benchmarked as well.&lt;/p&gt;

&lt;p&gt;An example of the lines which show up in the &lt;em&gt;error_log&lt;/em&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  timing request for /perl/setupenvoff.pl:
    0 wallclock secs ( 0.04 usr +  0.01 sys =  0.05 CPU)
  timing request for /perl/setupenvoff.pl:
    0 wallclock secs ( 0.03 usr +  0.00 sys =  0.03 CPU)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Apache::Timeit&lt;/code&gt; package is a part of the &lt;em&gt;Apache-Perl-contrib&lt;/em&gt; files collection available from CPAN.&lt;/p&gt;

&lt;h2 id=&#34;span-id-references-references-span&#34;&gt;&lt;span id=&#34;references&#34;&gt;References&lt;/span&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The mod_perl site&amp;rsquo;s URL:
&lt;a href=&#34;http://perl.apache.org&#34;&gt;http://perl.apache.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;httperf &amp;ndash; webserver Benchmarking tool
&lt;a href=&#34;http://www.hpl.hp.com/personal/David_Mosberger/httperf.html&#34;&gt;http://www.hpl.hp.com/personal/David_Mosberger/httperf.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;http_load &amp;ndash; another webserver Benchmarking tool
&lt;a href=&#34;http://www.acme.com/software/http_load/&#34;&gt;http://www.acme.com/software/http_load/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Apache-Perl-contrib package
&lt;a href=&#34;http://perl.apache.org/dist/contrib/&#34;&gt;http://perl.apache.org/dist/contrib/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Time::HiRes&#34;&gt;Time::HiRes&lt;/a&gt; and &lt;a href=&#34;https://metacpan.org/pod/Benchmark&#34;&gt;Benchmark&lt;/a&gt; is a part of the Core Perl&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LWP&lt;/code&gt; (libwww-perl)
&lt;a href=&#34;https://metacpan.org/release/libwww-perl&#34;&gt;https://metacpan.org/release/libwww-perl&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Return to &lt;a href=&#34;http://localhost:1313/&#34;&gt;Perl.com&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Improving mod_perl Sites&#39; Performance: Part 1</title>
      <link>http://localhost:1313/pub/2002/05/29/mod_perl-opt.html/</link>
      <pubDate>Wed, 29 May 2002 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2002/05/29/mod_perl-opt.html/</guid>
      <description>

&lt;p&gt;In the next series of articles, we are going to talk about mod_perl performance issues. We will try to look at as many aspects of the mod_perl driven service as possible: hardware, software, Perl coding and finally the mod_perl specific aspects.&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-big-picture-the-big-picture-span&#34;&gt;&lt;span id=&#34;the_big_picture&#34;&gt;The Big Picture&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;To make the user&amp;rsquo;s Web browsing experience as painless as possible, every effort must be made to wring the last drop of performance from the server. There are many factors that affect Web site usability, but speed is one of the most important. This applies to any Web server, not just Apache, so it is important that you understand it.&lt;/p&gt;

&lt;p&gt;How do we measure the speed of a server? Since the user (and not the computer) is the one that interacts with the Web site, one good speed measurement is the time elapsed between the moment when one clicks on a link or presses a &lt;em&gt;Submit&lt;/em&gt; button to the moment when the resulting page is fully rendered.&lt;/p&gt;

&lt;p&gt;The requests and replies are broken into packets. A request may be made up of several packets; a reply may be many thousands. Each packet has to make its way from one machine to another, perhaps passing through many interconnection nodes. We must measure the time starting from when the first packet of the request leaves our user&amp;rsquo;s machine to when the last packet of the reply arrives back there.&lt;/p&gt;

&lt;p&gt;A Web server is only one of the entities the packets see along their way. If we follow them from browser to server and back again, then they may travel by different routes through many different entities. Before they are processed by your server, the packets might have to go through proxy (accelerator) servers and, if the request contains more than one packet, packets might arrive to the server by different routes with different arrival times. Therefore, it&amp;rsquo;s possible that some packets that arrive earlier will have to wait for other packets before they could be reassembled into a chunk of the request message that will be then read by the server. Then the whole process is repeated in reverse.&lt;/p&gt;

&lt;p&gt;You could work hard to fine-tune your Web server&amp;rsquo;s performance, but a slow Network Interface Card (NIC) or a slow network connection from your server might defeat it all. That&amp;rsquo;s why it&amp;rsquo;s important to think about the big picture and to be aware of possible bottlenecks between the server and the Web.&lt;/p&gt;

&lt;p&gt;Of course, there is little that you can do if the user has a slow connection. You might tune your scripts and Web server to process incoming requests quickly, so you will need only a small number of working servers, but you might find that the server processes are all busy waiting for slow clients to accept their responses.&lt;/p&gt;

&lt;p&gt;But there are techniques to cope with this. For example, you can deliver the response compressed. If you are delivering a pure text respond, then gzip compression will sometimes reduce the size of the respond by 10 times.&lt;/p&gt;

&lt;p&gt;You should analyze all the involved components when you try to create the best service for your users, and not the Web server or the code that the Web server executes. A Web service is like a car: If one of the parts or mechanisms is broken, then the car may not operate smoothly and it can even stop dead if pushed too far without fixing it.&lt;/p&gt;

&lt;p&gt;Let me stress it again: If you want to be successful in the Web service business, then you should start worrying about the client&amp;rsquo;s browsing experience and &lt;strong&gt;not only&lt;/strong&gt; how good your code benchmarks are.&lt;/p&gt;

&lt;h3 id=&#34;span-id-operating-system-and-hardware-analysis-operating-system-and-hardware-analysis-span&#34;&gt;&lt;span id=&#34;operating_system_and_hardware_analysis&#34;&gt;Operating System and Hardware Analysis&lt;/span&gt;&lt;/h3&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;Previously in the Series&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://perl.com/pub/2002/05/22/mod_perl-isp.html&#34;&gt;Finding a mod_perl ISP... or Becoming One&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;http://perl.com/pub/2002/05/14/mod_perl.html&#34;&gt;The Perl You Need To Know - Part 3&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;http://perl.com/pub/2002/05/07/mod_perl.html&#34;&gt;The Perl You Need To Know - Part 2&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/04/23/mod_perl.html&#34;&gt;The Perl You Need To Know&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/04/10/mod_perl.html&#34;&gt;Installing mod_perl without superuser privileges&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/03/22/modperl.html&#34;&gt;mod_perl in 30 minutes&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/02/26/whatismodperl.html&#34;&gt;Why mod_perl?&lt;/a&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Before you start to optimize server configuration and learn to write more-efficient code, you need to consider the demands that will be placed on the hardware and the operating System. There is no point in investing a lot of time and money in configuration tuning and code optimizing, only to find that your server&amp;rsquo;s performance is poor because you did not choose a suitable platform in the first place.&lt;/p&gt;

&lt;p&gt;Because hardware platforms and operating systems are developing rapidly (even while you are reading this article), the following advisory discussion must be in general terms, without mentioning specific vendors names.&lt;/p&gt;

&lt;h3 id=&#34;span-id-choosing-the-right-operating-system-choosing-the-right-operating-system-span&#34;&gt;&lt;span id=&#34;choosing_the_right_operating_system&#34;&gt;Choosing the Right Operating System&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;I will try to talk about what characteristics and features you should be looking for to support a mod_perl enabled Apache server, then when you know what you want from your OS, you can go out and find it. Visit the Web sites of the operating systems you are interested in. You can gauge user&amp;rsquo;s opinions by searching the relevant discussions in newsgroup and mailing list archives. Deja - &lt;a href=&#34;http://deja.com&#34;&gt;http://deja.com&lt;/a&gt; and eGroups - &lt;a href=&#34;http://egroups.com&#34;&gt;http://egroups.com&lt;/a&gt; are good examples. I will leave this fan research to you. But probably the best shot will be to ask mod_perl users, as they know the best.&lt;/p&gt;

&lt;h4 id=&#34;span-id-stability-and-robustness-requirements-stability-and-robustness-requirements-span&#34;&gt;&lt;span id=&#34;stability_and_robustness_requirements&#34;&gt;Stability and Robustness Requirements&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Probably the most important features in an OS are stability and robustness. You are in the Internet business. You do not keep normal 9 a.m. to 5 p.m. working hours like conventional businesses. You are open 24 hours a day. You cannot afford to be off-line, because your customers will shop at another service (unless you have a monopoly &amp;hellip;). If the OS of your choice crashes every day, then first conduct a little investigation. There might be a simple reason that you can fix. There are OSs that won&amp;rsquo;t work unless you reboot them twice a day. You don&amp;rsquo;t want to use this type of OS, no matter how good the OS&amp;rsquo; vendor sales department is. Do not follow flushy advertisements; follow developers&amp;rsquo; advice instead.&lt;/p&gt;

&lt;p&gt;Generally, people who have used the OS for some time can tell you a lot about its stability. Ask them. Try to find people who are doing similar things to what you are planning to do, they may even be using the same software. There are often compatibility issues to resolve. You may need to become familiar with patching and compiling your OS.&lt;/p&gt;

&lt;h4 id=&#34;span-id-good-memory-management-importance-good-memory-management-importance-span&#34;&gt;&lt;span id=&#34;good_memory_management_importance&#34;&gt;Good Memory-Management Importance&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;You want an OS with a good memory-management implementation. Some OSs are well-known as memory hogs. The same code can use twice as much memory on one OS compared to another. If the size of the mod_perl process is 10Mb and you have tens of these running, then it definitely adds up!&lt;/p&gt;

&lt;h4 id=&#34;span-id-say-no-to-memory-leaks-say-no-to-memory-leaks-span&#34;&gt;&lt;span id=&#34;say_no_to_memory_leaks&#34;&gt;Say No to Memory Leaks&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Some OSs and/or their libraries (e.g. C runtime libraries) suffer from memory leaks. A leak is when some process requests a chunk of memory for temporary storage, but then does not subsequently release it. The chunk of memory is not then available for any purpose until the process that requested it dies. You cannot afford such leaks. A single mod_perl process sometimes serves thousands of requests before it terminates. So if a leak occurs on each request, then the memory demands could become huge. Of course, your code can be the cause of the memory leaks as well, but it&amp;rsquo;s easy to detect and solve. Certainly, we can reduce the number of requests to be served during the process&amp;rsquo; life, but that can degrade performance.&lt;/p&gt;

&lt;h4 id=&#34;span-id-memory-sharing-capabilities-is-a-must-memory-sharing-capabilities-is-a-must-span&#34;&gt;&lt;span id=&#34;memory_sharing_capabilities_is_a_must&#34;&gt;Memory-Sharing Capabilities Is a Must&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;You want an OS with good memory-sharing capabilities. If you preload the Perl modules and scripts at server startup, then they are shared between the spawned children (at least for a part of a process&amp;rsquo; life - memory pages can become ``dirty&amp;rdquo; and cease to be shared). This feature can reduce memory consumption a lot!&lt;/p&gt;

&lt;p&gt;And, of course, you don&amp;rsquo;t want an OS that doesn&amp;rsquo;t have memory-sharing capabilities.&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-real-cost-of-support-the-real-cost-of-support-span&#34;&gt;&lt;span id=&#34;the_real_cost_of_support&#34;&gt;The Real Cost of Support&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;If you are in a big business, then you probably do not mind paying another $1,000 for some fancy OS with bundled support. But if your resources are low, then you will look for cheaper and free OSs. Free does not mean bad, it can be quite the opposite. Free OSs can have the best support you can find. Some do.&lt;/p&gt;

&lt;p&gt;It is easy to understand - most of the people are not rich and will try to use a cheaper or free OS first if it does the work for them. Since it really fits their needs, many people keep using it and eventually know it well enough to be able to provide support for others in trouble. Why would they do this for free? One reason is for the spirit of the first days of the Internet, when there was no commercial Internet and people helped each other, because someone helped them in first place. I was there, I was touched by that spirit and I&amp;rsquo;m keen to keep that spirit alive.&lt;/p&gt;

&lt;p&gt;But, let&amp;rsquo;s get back to the real world. We are living in material world, and our bosses pay us to keep the systems running. So if you feel that you cannot provide the support yourself and you do not trust the available free resources, then you must pay for an OS backed by a company, and blame them for any problem. Your boss wants to be able to sue someone if the project has a problem caused by the external product that is being used in the project. If you buy a product and the company selling it claims support, then you have someone to sue or at least to put the blame on.&lt;/p&gt;

&lt;p&gt;If we go with open source and it fails we do not have someone to sue &amp;hellip; wrong &amp;ndash; in the past several years, many companies have realized how good the open-source products are and started to provide an official support for these products. So your boss cannot just dismiss your suggestion of using an open-source operating system. You can get a paid support just like with any other commercial OS vendor.&lt;/p&gt;

&lt;p&gt;Also remember that the less money you spend on OS and software, the more you will be able to spend on faster and stronger hardware. Of course, for some companies money is a nonissue, but there are many companies for which it is a &lt;strong&gt;big&lt;/strong&gt; issue.&lt;/p&gt;

&lt;h4 id=&#34;span-id-ouch-discontinued-products-ouch-discontinued-products-span&#34;&gt;&lt;span id=&#34;ouch..._discontinued_products&#34;&gt;Ouch &amp;hellip; Discontinued Products&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The OSs in this hazard group tend to be developed by a single company or organization.&lt;/p&gt;

&lt;p&gt;You might find yourself in a position where you have invested a lot of time and money into developing some proprietary software that is bundled with the OS you chose (say writing a mod_perl handler that takes advantage of some proprietary features of the OS and that will not run on any other OS). Things are under control, the performance is great and you sing with happiness on your way to work. Then, one day, the company that supplies your beloved OS goes bankrupt (not unlikely nowadays), or they produce a newer incompatible version and they will not support the old one (happens all the time). You are stuck with their early masterpiece, no support and no source code! What are you going to do? Invest more money into porting the software to another OS &amp;hellip;&lt;/p&gt;

&lt;p&gt;Free and open-source OSs are probably less susceptible to this kind of problem. Development is usually distributed between many companies and developers. So if a person who developed an important part of the kernel lost interest in continuing, then someone else will pick the falling flag and carry on. Of course, if tomorrow some better project shows up, then developers might migrate there and finally drop the development. But in practice, people are often given support on older versions and helped to migrate to current versions. Development tends to be more incremental than revolutionary, so upgrades are less traumatic, and there is usually plenty of notice of the forthcoming changes so that you have time to plan for them.&lt;/p&gt;

&lt;p&gt;Of course, with open-source OSs you can have the source code! So you can always have a go yourself, but do not under-estimate the amounts of work involved. There are many, many man-years of work in an OS.&lt;/p&gt;

&lt;h4 id=&#34;span-id-keeping-up-with-os-releases-keeping-up-with-os-releases-span&#34;&gt;&lt;span id=&#34;keeping_up_with_os_releases&#34;&gt;Keeping Up with OS Releases&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Actively developed OSs generally try to keep pace with the latest technology developments, and continually optimize the kernel and other parts of the OS to become better and faster. Nowadays, Internet and networking in general are the hottest topics for system developers. Sometimes a simple OS upgrade to the latest stable version can save you an expensive hardware upgrade. Also, remember that when you buy new hardware, chances are that the latest software will make the most of it.&lt;/p&gt;

&lt;p&gt;If a new product supports an old one by virtue of backward compatibility with previous products of the same family, then you might not reap all the benefits of the new product&amp;rsquo;s features. Perhaps you get almost the same functionality for much less money if you were to buy an older model of the same product.&lt;/p&gt;

&lt;h3 id=&#34;span-id-choosing-the-right-hardware-choosing-the-right-hardware-span&#34;&gt;&lt;span id=&#34;choosing_the_right_hardware&#34;&gt;Choosing the Right Hardware&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Sometimes the most expensive machine is not the one that provides the best performance. Your demands on the platform hardware are based on many aspects and affect many components. Let&amp;rsquo;s discuss some of them.&lt;/p&gt;

&lt;p&gt;In the discussion I use terms that may be unfamiliar to you:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Cluster&lt;/strong&gt;: a group of machines connected together to perform one big or many small computational tasks in a reasonable time. Clustering can also be used to provide &amp;lsquo;fail-over,&amp;rsquo; where if one machine fails, then its processes are transferred to another without interruption of service. And you may be able to take one of the machines down for maintenance (or an upgrade) and keep your service running &amp;ndash; the main server will simply not dispatch the requests to the machine that was taken down.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Load balancing&lt;/strong&gt;: users are given the name of one of your machines but perhaps it cannot stand the heavy load. You can use a clustering approach to distribute the load over a number of machines. The central server, which users access initially when they type the name of your service, works as a dispatcher. It just redirects requests to other machines. Sometimes the central server also collects the results and returns them to the users. You can get the advantages of clustering, too.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Network Interface Card&lt;/strong&gt; (NIC): a hardware component that allows you to connect your machine to the network. It performs packets sending and receiving, newer cards can encrypt and decrypt packets and perform digital signing and verifying of the such. These are coming in different speeds categories varying from 10Mbps to 10Gbps and faster. The most used type of the NIC card is the one that implements the Ethernet networking protocol.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Random Access Memory&lt;/strong&gt; (RAM): It&amp;rsquo;s the memory that you have in your computer. (Comes in units of 8Mb, 16Mb, 64Mb, 256Mb, etc.)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Redundant Array of Inexpensive Disks&lt;/strong&gt; (RAID): an array of physical disks, usually treated by the operating system as one single disk, and often forced to appear that way by the hardware. The reason for using RAID is often simply to achieve a high data transfer rate, but it may also be to get adequate disk capacity or high reliability. Redundancy means that the system is capable of continued operation even if a disk fails. There are various types of RAID array and several different approaches to implementing them. Some systems provide protection against failure of more than one drive and some (`hot-swappable&amp;rsquo;) systems allow a drive to be replaced without even stopping the OS.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;span-id-machine-strength-demands-according-to-expected-site-traffic-machine-strength-demands-according-to-expected-site-traffic-span&#34;&gt;&lt;span id=&#34;machine_strength_demands_according_to_expected_site_traffic&#34;&gt;Machine Strength Demands According to Expected Site Traffic&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;If you are building a fan site and you want to amaze your friends with a mod_perl guest book, then any old 486 machine could do it. If you are in a serious business, then it is important to build a scalable server. If your service is successful and becomes popular, then the traffic could double every few days, and you should be ready to add more resources to meet demand. While we can define the Web server scalability more precisely, the important thing is to make sure that you can add more power to your &lt;code&gt;webserver(s)&lt;/code&gt; without investing much additional money in software development (you will need a little software effort to connect your servers, if you add more of them). This means that you should choose hardware and OSs that can talk to other machines and become a part of a cluster.&lt;/p&gt;

&lt;p&gt;On the other hand, if you prepare for a lot of traffic and buy a monster to do the work for you, then what happens if your service doesn&amp;rsquo;t prove to be as successful as you thought? Then you&amp;rsquo;ve spent too much money, and meanwhile faster processors and other hardware components have been released; so you lose.&lt;/p&gt;

&lt;p&gt;Wisdom and prophecy, that&amp;rsquo;s all it takes :)&lt;/p&gt;

&lt;h4 id=&#34;span-id-single-strong-machine-vs-many-weaker-machines-single-strong-machine-vs-many-weaker-machines-span&#34;&gt;&lt;span id=&#34;single_strong_machine_vs._many_weaker_machines&#34;&gt;Single Strong Machine vs. Many Weaker Machines&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Let&amp;rsquo;s start with a claim that a 4-year-old processor is still powerful and can be put to a good use. Now let&amp;rsquo;s say that for a given amount of money you can probably buy either one new very strong machine or about 10 older but very cheap machines. I claim that with 10 old machines connected into a cluster and by deploying load balancing you will be able to serve about five times more requests than with one single new machine.&lt;/p&gt;

&lt;p&gt;Why is that? Because generally the performance improvement on a new machine is marginal while the price is much higher. Ten machines will do faster disk I/O than one single machine, even if the new disk is quite a bit faster. Yes, you have more administration overhead, but there is a chance you will have it anyway, for in a short time the new machine you have just bought might not stand the load. Then you will have to purchase more equipment and think about how to implement load balancing and Web server file system distribution anyway.&lt;/p&gt;

&lt;p&gt;Why I am so convinced? Look at the busiest services on the Internet: search engines, Web/e-mail servers and the like &amp;ndash; most of them use a clustering approach. You may not always notice it, because they hide the real implementation details behind proxy servers.&lt;/p&gt;

&lt;h4 id=&#34;span-id-getting-fast-internet-connection-getting-fast-internet-connection-span&#34;&gt;&lt;span id=&#34;getting_fast_internet_connection&#34;&gt;Getting Fast Internet Connection&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;You have the best hardware you can get, but the service is still crawling. Make sure you have a fast Internet connection. Not as fast as your ISP claims it to be, but fast as it should be. The ISP might have a good connection to the Internet, but put many clients on the same line. If these are heavy clients, then your traffic will have to share the same line and your throughput will suffer. Think about a dedicated connection and make sure it is truly dedicated. Don&amp;rsquo;t trust the ISP, check it!&lt;/p&gt;

&lt;p&gt;The idea of having a connection to &lt;strong&gt;the Internet&lt;/strong&gt; is a little misleading. Many Web hosting and co-location companies have large amounts of bandwidth, but still have poor connectivity. The public exchanges, such as MAE-East and MAE-West, frequently become overloaded, yet many ISPs depend on these exchanges.&lt;/p&gt;

&lt;p&gt;Private peering means that providers can exchange traffic much quicker.&lt;/p&gt;

&lt;p&gt;Also, if your Web site is of global interest, check that the ISP has good global connectivity. If the Web site is going to be visited mostly by people in a certain country or region, then your server should probably be located there.&lt;/p&gt;

&lt;p&gt;Bad connectivity can directly influence your machine&amp;rsquo;s performance. Here is a story one of the developers told on the mod_perl mailing list:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What relationship has 10 percent packet loss on one upstream provider got to do with machine memory ?&lt;/p&gt;

&lt;p&gt;Yes &amp;hellip; a lot. For a nightmare week, the box was located downstream of a provider who was struggling with some serious bandwidth problems of his own &amp;hellip; people were connecting to the site via this link, and packet loss was such that retransmits and TCP stalls were keeping httpd heavies around for much longer than normal &amp;hellip; instead of blasting out the data at high or even modem speeds, they would be stuck at 1k/sec or stalled out &amp;hellip; people would press stop and refresh, httpds would take 300 seconds to timeout on writes to no-one &amp;hellip; it was a nightmare. Those problems didn&amp;rsquo;t go away till I moved the box to a place closer to some decent backbones.&lt;/p&gt;

&lt;p&gt;Note that with a proxy, this only keeps a lightweight httpd tied up, assuming the page is small enough to fit in the buffers. If you are a busy Internet site, then you always have some slow clients. This is a difficult thing to simulate in benchmark testing, though.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;span-id-tuning-i-o-performance-tuning-i-o-performance-span&#34;&gt;&lt;span id=&#34;tuning_i/o_performance&#34;&gt;Tuning I/O Performance&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;If your service is I/O bound (does a lot of read/write operations to disk), then you need a very fast disk, especially if the you need a relational database, which are the main I/O stream creators. So you should not spend the money on video card and monitor! A cheap card and a 14-inch monochrome monitor are perfectly adequate for a Web server; you will probably access it by &lt;code&gt;telnet&lt;/code&gt; or &lt;code&gt;ssh&lt;/code&gt; most of the time. Look for disks with the best price/performance ratio. Of course, ask around and avoid disks that have a reputation for head-crashes and other disasters.&lt;/p&gt;

&lt;p&gt;You must think about RAID or similar systems if you have an enormous data set to serve (what is an enormous data set nowadays? Gigabytes, terabytes?) or you expect a really big Web traffic.&lt;/p&gt;

&lt;p&gt;OK, you have a fast disk, what&amp;rsquo;s next? You need a fast disk controller. There may be one embedded on your computer&amp;rsquo;s motherboard. If the controller is not fast enough, then you should buy a faster one. Don&amp;rsquo;t forget that it may be necessary to disable the original controller.&lt;/p&gt;

&lt;h4 id=&#34;span-id-how-much-memory-is-enough-how-much-memory-is-enough-span&#34;&gt;&lt;span id=&#34;how_much_memory_is_enough&#34;&gt;How Much Memory Is Enough?&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;How much RAM do you need? Nowadays, chances are that you will hear: ``Memory is cheap, the more you buy the better.&amp;rdquo; But how much is enough? The answer is pretty straightforward: &lt;em&gt;you do not want your machine to swap&lt;/em&gt;. When the CPU needs to write something into memory, but memory is already full, it takes the least frequently used memory pages and swaps them out to disk. This means you have to bear the time penalty of writing the data to disk. If another process then references some of the data that happens to be on one of the pages that has just been swapped out, then the CPU swaps it back in again, probably swapping out some other data that will be needed very shortly by some other process. Carried to the extreme, the CPU and disk start to &lt;em&gt;thrash&lt;/em&gt; hopelessly in circles, without getting any real work done. The less RAM there is, the more often this scenario arises. Worse, you can exhaust swap space as well, and then your troubles really start.&lt;/p&gt;

&lt;p&gt;How do you make a decision? You know the highest rate at which your server expects to serve pages and how long it takes on average to serve one. Now you can calculate how many server processes you need. If you know the maximum size your servers can grow to, then you know how much memory you need. If your OS supports memory sharing, then you can make best use of this feature by preloading the modules and scripts at server startup, and so you will need less memory than you have calculated.&lt;/p&gt;

&lt;p&gt;Do not forget that other essential system processes need memory as well, so you should plan not only for the Web server, but also take into account the other players. Remember that requests can be queued, so you can afford to let your client wait for a few moments until a server is available to serve it. Most of the time your server will not have the maximum load, but you should be ready to bear the peaks. You need to reserve at least 20 percent of free memory for peak situations. Many sites have crashed a few moments after a big scoop about them was posted and an unexpected number of requests suddenly came in. (Like Slashdot effect.) If you are about to announce something cool, then be aware of the possible consequences.&lt;/p&gt;

&lt;h4 id=&#34;span-id-getting-a-faulttolerant-cpu-getting-a-fault-tolerant-cpu-span&#34;&gt;&lt;span id=&#34;getting_a_faulttolerant_cpu&#34;&gt;Getting a Fault-Tolerant CPU&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Make sure that the CPU is operating within its specifications. Many boxes are shipped with incorrect settings for CPU clock speed, power supply voltage, etc. Sometimes a cooling fan is not fitted. It may be ineffective because a cable assembly fouls the fan blades. Like faulty RAM, an overheating processor can cause all kinds of strange and unpredictable things to happen. Some CPUs are known to have bugs that can be serious in certain circumstances. Try not to get one of them.&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;Previously in the Series&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://perl.com/pub/2002/05/22/mod_perl-isp.html&#34;&gt;Finding a mod_perl ISP... or Becoming One&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;http://perl.com/pub/2002/05/14/mod_perl.html&#34;&gt;The Perl You Need To Know - Part 3&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;http://perl.com/pub/2002/05/07/mod_perl.html&#34;&gt;The Perl You Need To Know - Part 2&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/04/23/mod_perl.html&#34;&gt;The Perl You Need To Know&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/04/10/mod_perl.html&#34;&gt;Installing mod_perl without superuser privileges&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/03/22/modperl.html&#34;&gt;mod_perl in 30 minutes&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/02/26/whatismodperl.html&#34;&gt;Why mod_perl?&lt;/a&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;span-id-detecting-and-avoiding-bottlenecks-detecting-and-avoiding-bottlenecks-span&#34;&gt;&lt;span id=&#34;detecting_and_avoiding_bottlenecks&#34;&gt;Detecting and Avoiding Bottlenecks&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;You might use the most expensive components, but still get bad performance. Why? Let me introduce an annoying word: bottleneck.&lt;/p&gt;

&lt;p&gt;A machine is an aggregate of many components. Almost any one of them may become a bottleneck.&lt;/p&gt;

&lt;p&gt;If you have a fast processor but a small amount of RAM, then the RAM will probably be the bottleneck. The processor will be under-utilized, usually it will be waiting for the kernel to swap the memory pages in and out, because memory is too small to hold the busiest pages.&lt;/p&gt;

&lt;p&gt;If you have a lot of memory, a fast processor, a fast disk, but a slow disk controller, then the disk controller will be the bottleneck. The performance will still be bad, and you will have wasted money.&lt;/p&gt;

&lt;p&gt;A slow NIC can cause a bottleneck as well and make the whole service run slow. This is a most important component, since Web servers are much more often network-bound than they are disk-bound (i.e. having more network traffic than disk utilization)&lt;/p&gt;

&lt;h4 id=&#34;span-id-solving-hardware-requirement-conflicts-solving-hardware-requirement-conflicts-span&#34;&gt;&lt;span id=&#34;solving_hardware_requirement_conflicts&#34;&gt;Solving Hardware Requirement Conflicts&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;It may happen that the combination of software components that you find yourself using gives rise to conflicting requirements for the optimization of tuning parameters. If you can separate the components onto different machines, then you may find that this approach (a kind of clustering) solves the problem, at much less cost than buying faster hardware, because you can tune the machines individually to suit the tasks they should perform.&lt;/p&gt;

&lt;p&gt;For example, if you need to run a relational database engine and mod_perl server, then it can be wise to put the two on different machines, since while RDBMS need a very fast disk, mod_perl processes need lots of memory. So by placing the two on different machines it&amp;rsquo;s easy to optimize each machine at separate and satisfy the each software components requirements in the best way.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;span-id-references-references-span&#34;&gt;&lt;span id=&#34;references&#34;&gt;References&lt;/span&gt;&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;The mod_perl site&amp;rsquo;s URL: &lt;a href=&#34;http://perl.apache.org&#34;&gt;http://perl.apache.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;For more information about RAID see the Disk-HOWTO, Module-HOWTO and Parallel-Processing-HOWTO available from the Linux Documentation Project and its mirrors (&lt;a href=&#34;http://www.linuxdoc.org/docs.html#howto&#34;&gt;http://www.linuxdoc.org/docs.html#howto&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;For more information about clusters and high availability setups, see:&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Finding a mod_perl ISP... or Becoming One</title>
      <link>http://localhost:1313/pub/2002/05/22/mod_perl-isp.html/</link>
      <pubDate>Wed, 22 May 2002 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2002/05/22/mod_perl-isp.html/</guid>
      <description>

&lt;h2 id=&#34;span-id-introduction-introduction-span&#34;&gt;&lt;span id=&#34;introduction&#34;&gt;Introduction&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;In this article we will talk about the nuances of providing &lt;code&gt;mod_perl&lt;/code&gt; services and present a few ISPs that successfully provide them.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;You installed &lt;code&gt;mod_perl&lt;/code&gt; on your box at home, and you fell in love with it. So now you want to convert your CGI scripts (which are currently running on your favorite ISP&amp;rsquo;s machine) to run under &lt;code&gt;mod_perl&lt;/code&gt;. Then you discover that your ISP has never heard of &lt;code&gt;mod_perl&lt;/code&gt;, or he refuses to install it for you.&lt;/li&gt;
&lt;li&gt;You are an old sailor in the ISP business, you have seen it all, you know how many ISPs are out there, and you know that the sales margins are too low to keep you happy. You are looking for some new service almost no one else provides, to attract more clients to become your users and, hopefully, to have a bigger slice of the action than your competitors.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you are planning to become an ISP that provides &lt;code&gt;mod_perl&lt;/code&gt; services or are just looking for such a provider, this article is for you.&lt;/p&gt;

&lt;h3 id=&#34;span-id-gory-details-gory-details-span&#34;&gt;&lt;span id=&#34;gory_details&#34;&gt;Gory Details&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;An ISP has three choices:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;ISPs probably cannot let users run scripts under &lt;code&gt;mod_perl&lt;/code&gt; on the main server. There are many reasons for this:&lt;/p&gt;

&lt;p&gt;Scripts might leak memory, due to sloppy programming. There will not be enough memory to run as many servers as required, and clients will be not satisfied with the service because it will be slow.&lt;/p&gt;

&lt;p&gt;The question of file permissions is a very important issue: any user who is allowed to write and run a CGI script can at least read (if not write) any other files that belong to the same user and/or group under which the Web server is running. Note that it&amp;rsquo;s impossible to run &lt;code&gt;suEXEC&lt;/code&gt; and &lt;code&gt;cgiwrap&lt;/code&gt; extensions under &lt;code&gt;mod_perl&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Another issue is the security of the database connections. If you use &lt;code&gt;Apache::DBI&lt;/code&gt;, by hacking the &lt;code&gt;Apache::DBI&lt;/code&gt; code you can pick a connection from the pool of cached connections, even if it was opened by someone else and your scripts are running on the same Web server.&lt;/p&gt;

&lt;p&gt;There are many more things to be aware of, so at this time you have to say &lt;em&gt;no&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Of course, as an ISP, you can run &lt;code&gt;mod_perl&lt;/code&gt; internally, without allowing your users to map their scripts, so that they will run under &lt;code&gt;mod_perl&lt;/code&gt;. If, as a part of your service, you provide scripts such as guest books, counters, etc. that are not available for user modification, you can still can have these scripts running very quickly.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;ldquo;But, hey, why can&amp;rsquo;t I let my users run their own servers, so I can wash my hands of them and don&amp;rsquo;t have to worry about how dirty and sloppy their code is? (Assuming that the users are running their servers under their own user names, to prevent them from stealing code and data from each other.)&amp;rdquo;&lt;/p&gt;

&lt;p&gt;This option is fine, as long as you are not concerned about your new systems resource requirements. If you have even very limited experience with &lt;code&gt;mod_perl&lt;/code&gt;, you will know that &lt;code&gt;mod_perl&lt;/code&gt;-enabled Apache servers &amp;ndash; while freeing up your CPU and allowing you to run scripts much faster &amp;ndash; have huge memory demands (5-20 times that of plain Apache).&lt;/p&gt;

&lt;p&gt;The size of these memory demands depends on the code length, the sloppiness of the programming, possible memory leaks the code might have, and all of that multiplied by the number of children each server spawns. A very simple example: a server, serving an average number of scripts, demanding 10MB of memory, spawns 10 children and already raises your memory requirements by 100MB (the real requirement is actually much smaller if your OS allows code sharing between processes, and if programmers exploit these features in their code). Now, multiply the average required size by the number of server users you intend to have and you will get the total memory requirement.&lt;/p&gt;

&lt;p&gt;Since ISPs never say &lt;em&gt;no&lt;/em&gt;, you&amp;rsquo;d better take the inverse approach &amp;ndash; think of the largest memory size you can afford, and then divide it by one user&amp;rsquo;s requirements (as I have shown in this example), and you will know how many &lt;code&gt;mod_perl&lt;/code&gt; users you can afford :)&lt;/p&gt;

&lt;p&gt;But what if you cannot tell how much memory your users may use? Their requirements from a single server can be very modest, but do you know how many servers they will run? After all, they have full control of &lt;code&gt;httpd.conf&lt;/code&gt; - and it has to be this way, since this is essential for the user running &lt;code&gt;mod_perl&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;All of this rumbling about memory leads to a single question: is it possible to prevent users from using more than X memory? Or another variation of the question: assuming you have as much memory as you want, can you charge users for their average memory usage?&lt;/p&gt;

&lt;p&gt;If the answer to either of the above questions is &lt;em&gt;yes&lt;/em&gt;, you are all set and your clients will prize your name for letting them run &lt;code&gt;mod_perl&lt;/code&gt;! There are tools to restrict resource usage (see, for example, the man pages for &lt;code&gt;ulimit(3)&lt;/code&gt;, &lt;code&gt;getrlimit(2)&lt;/code&gt;, &lt;code&gt;setrlimit(2)&lt;/code&gt;, and &lt;code&gt;sysconf(3)&lt;/code&gt;; the last three have the corresponding Perl modules &lt;code&gt;BSD::Resource&lt;/code&gt; and &lt;code&gt;Apache::Resource&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;If you have chosen this option, you have to provide your client with:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Shutdown and startup scripts installed together with the rest of your daemon startup scripts (e.g., the &lt;code&gt;/etc/rc.d&lt;/code&gt; directory), so that when you reboot your machine, the user&amp;rsquo;s server will be correctly shut down and will be back online the moment your system starts up. Also make sure to start each server under the user name the server belongs to, or you are going to be in big trouble!&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Proxy services (in forward or httpd accelerator mode) for the user&amp;rsquo;s virtual host. Since the user will have to run their server on an unprivileged port (&amp;gt;1024), you will have to forward all requests from &lt;code&gt;user.given.virtual.hostname:80&lt;/code&gt; (which is &lt;code&gt;user.given.virtual.hostname&lt;/code&gt; without the default port 80) to &lt;code&gt;your.machine.ip:port_assigned_to_user&lt;/code&gt;. You will also have to tell the users to code their scripts so that any self-referencing URLs are of the form &lt;code&gt;user.given.virtual.hostname&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Letting the user run a &lt;code&gt;mod_perl&lt;/code&gt; server immediately adds the requirement that the user be able to restart and configure their own server. Only root can bind to port 80; this is why your users have to use port numbers greater than 1024.&lt;/p&gt;

&lt;p&gt;Another solution would be to use a setuid startup script, but think twice before you go with it, since if users can modify the scripts, sometimes they will get a root access.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Another problem you will have to solve is how to assign ports to users. Since users can pick any port above 1024 to run their server, you will have to lay down some rules here so that multiple servers do not conflict.&lt;/p&gt;

&lt;p&gt;A simple example will demonstrate the importance of this problem. I am a malicious user or I am just a rival of some fellow who runs his server on your ISP. All I need to do is to find out what port my rival&amp;rsquo;s server is listening to (e.g. using &lt;code&gt;netstat(8)&lt;/code&gt;) and configure my own server to listen on the same port. Although I am unable to bind to this port, imagine what will happen when you reboot your system and my startup script happens to be run before my rival&amp;rsquo;s! I get the port first, and now all requests will be redirected to my server. I&amp;rsquo;ll leave to your imagination what nasty things might happen then.&lt;/p&gt;

&lt;p&gt;Of course, the ugly things will quickly be revealed, but not before the damage has been done.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Basically, you can preassign each user a port, without them having to worry about finding a free one, as well as enforce &lt;code&gt;MaxClients&lt;/code&gt; and similar values, by implementing the following scenario:&lt;/p&gt;

&lt;p&gt;For each user, have two configuration files: the main file, &lt;code&gt;httpd.conf&lt;/code&gt; (non-writable by user) and the user&amp;rsquo;s file, &lt;code&gt;username.httpd.conf&lt;/code&gt;, where they can specify their own configuration parameters and override the ones defined in &lt;code&gt;httpd.conf&lt;/code&gt;. Here is what the main configuration file looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  httpd.conf
  ----------
  # Global/default settings, the user may override some of these
  ...
  ...
  # Included so that user can set his own configuration
  Include username.httpd.conf

  # User-specific settings which will override any potentially
  # dangerous configuration directives in username.httpd.conf
  ...
  ...

  username.httpd.conf
  -------------------
  # Settings that your user would like to add/override, like
  # &amp;lt;Location&amp;gt; and PerlModule directives, etc.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apache reads the global/default settings first. It then reads the &lt;code&gt;Include&lt;/code&gt;d &lt;code&gt;username.httpd.conf&lt;/code&gt; file with whatever settings the user has chosen, and finally, it reads the user-specific settings that we don&amp;rsquo;t want the user to override, such as the port number. Even if the user changes the port number in his &lt;code&gt;username.httpd.conf&lt;/code&gt; file, Apache reads our settings last, so they take precedence. Note that you can use &amp;lt;&lt;code&gt;Perl&lt;/code&gt;&amp;gt; sections to make the configuration much easier.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A much better, but costly, solution is &lt;em&gt;co-location&lt;/em&gt;. Let the user hook his (or your) stand-alone machine into your network, and forget about this user. Of course, either the user or you will have to undertake all of the system administration chores and it will cost your client more money.&lt;/p&gt;

&lt;p&gt;Who are the people who seek &lt;code&gt;mod_perl&lt;/code&gt; support? They are people who run serious projects/businesses. Money is not usually an obstacle. They can afford a standalone box, thus achieving their goal of autonomy while keeping their ISP happy.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;span-id-isps-providing-code-mod-perl-code-services-isps-providing-mod-perl-services-span&#34;&gt;&lt;span id=&#34;isps_providing_&lt;code&gt;mod_perl&lt;/code&gt;_services&amp;rdquo;&amp;gt;ISPs Providing &lt;code&gt;mod_perl&lt;/code&gt; Services&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s present some of the ISPs that provide &lt;code&gt;mod_perl&lt;/code&gt; services.&lt;/p&gt;

&lt;p&gt;A Canadian company called Baremetal (&lt;a href=&#34;http://BareMetal.com/&#34;&gt;http://BareMetal.com/&lt;/a&gt;) provides &lt;code&gt;mod_perl&lt;/code&gt; services via front-end proxy and a shared &lt;code&gt;mod_perl&lt;/code&gt; backend, which, as their technical support claims, works reasonably well for folks that write good code. They&amp;rsquo;re willing to run a dedicated backend &lt;code&gt;mod_perl&lt;/code&gt; server for customers that need it. Some of their clients mix &lt;code&gt;mod_cgi&lt;/code&gt; and &lt;code&gt;mod_perl&lt;/code&gt; as a simple acceleration technique.
Basic service price is $30/month.&lt;/p&gt;

&lt;p&gt;For more information see &lt;a href=&#34;http://modperl-space.com/&#34;&gt;http://modperl-space.com/&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;BSB-Software GmbH, located in Frankfurt, Germany, provides their own &lt;code&gt;mod_perl&lt;/code&gt; applications for clients with standard requirements, thus preventing the security risks and allowing trusted users to use their own code, which is usually reviewed by the company&amp;rsquo;s system administrator. For the latter case, &lt;code&gt;httpd.conf&lt;/code&gt; is under the control of the ISP, so everything is monitored.
Please contact the company for the updated price list.&lt;/p&gt;

&lt;p&gt;For more information see &lt;a href=&#34;http://www.bsb-software.com/&#34;&gt;http://www.bsb-software.com/&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Digital Wire Consulting, an open-source-driven Ebusiness consulting company located in Zurich, Switzerland, provides shared and standalone &lt;code&gt;mod_perl&lt;/code&gt; systems. The company operates internationally.
Here are the specifics of this company:&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;Previously in the Series&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://perl.com/pub/2002/05/14/mod_perl.html&#34;&gt;The Perl You Need To Know - Part 3&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;http://perl.com/pub/2002/05/07/mod_perl.html&#34;&gt;The Perl You Need To Know - Part 2&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/04/23/mod_perl.html&#34;&gt;The Perl You Need To Know&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/04/10/mod_perl.html&#34;&gt;Installing mod_perl without superuser privileges&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/03/22/modperl.html&#34;&gt;mod_perl in 30 minutes&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/02/26/whatismodperl.html&#34;&gt;Why mod_perl?&lt;/a&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
&lt;li&gt;No restrictions in terms of CPU, bandwidth, etc. (so heavy-duty operations are better off with dedicated machines!)&lt;/li&gt;
&lt;li&gt;The user has to understand the risk that is involved if he/she is choosing a shared machine. Every user has their own virtual server.&lt;/li&gt;
&lt;li&gt;They offer dedicated servers at approximately $400/month (depending on configuration) + $500 setup.&lt;/li&gt;
&lt;li&gt;They don&amp;rsquo;t support any proxy setups. If someone is serious about running &lt;code&gt;mod_perl&lt;/code&gt; for a mission-critical application, then that person should be willing to pay for dedicated servers!&lt;/li&gt;
&lt;li&gt;For a shared server and a mid-size &lt;code&gt;mod_perl&lt;/code&gt; Web site, they charge roughly $100/month for hosting only! Installation and setup are extra and based on the time spent (one hour is $120). Please contact the company for the updated price list.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For more information see &lt;a href=&#34;http://www.dwc.ch/&#34;&gt;http://www.dwc.ch/&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Even &lt;em&gt;The Bunker&lt;/em&gt; (which claims to be UK&amp;rsquo;s safest site for secure computing) supports &lt;code&gt;mod_perl&lt;/code&gt;! Their standard server can include &lt;code&gt;mod_perl&lt;/code&gt; if requested. All of their users are provided with a dedicated machine.
For more information see &lt;a href=&#34;http://www.thebunker.net/hosting.htm&#34;&gt;http://www.thebunker.net/hosting.htm&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For more ISPs supporting &lt;code&gt;mod_perl&lt;/code&gt;, see &lt;a href=&#34;http://perl.apache.org/isp.html&#34;&gt;http://perl.apache.org/isp.html&lt;/a&gt;
If you are an ISP that supports &lt;code&gt;mod_perl&lt;/code&gt; and is not listed on the above page, please contact the person who maintains the list.&lt;/p&gt;

&lt;h3 id=&#34;span-id-references-references-span&#34;&gt;&lt;span id=&#34;references&#34;&gt;References&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mod_perl&lt;/code&gt; home page: &lt;a href=&#34;http://perl.apache.org/&#34;&gt;http://perl.apache.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mod_perl&lt;/code&gt; documentation: &lt;a href=&#34;http://perl.apache.org/#docs&#34;&gt;http://perl.apache.org/#docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;a partial list of ISPs supporting &lt;code&gt;mod_perl&lt;/code&gt;: &lt;a href=&#34;http://perl.apache.org/isp.html&#34;&gt;http://perl.apache.org/isp.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>The Perl You Need To Know - Part 3</title>
      <link>http://localhost:1313/pub/2002/05/14/mod_perl.html/</link>
      <pubDate>Wed, 15 May 2002 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2002/05/14/mod_perl.html/</guid>
      <description>

&lt;h3 id=&#34;span-id-introduction-introduction-span&#34;&gt;&lt;span id=&#34;introduction&#34;&gt;Introduction&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;This article is the third in our series talking about the essential Perl basics that you should know before starting to program for &lt;code&gt;mod_perl&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-variables-globally-lexically-scoped-and-fully-qualified-variables-globally-lexically-scoped-and-fully-qualified-span&#34;&gt;&lt;span id=&#34;variables_globally,_lexically_scoped_and_fully_qualified&#34;&gt;Variables Globally, Lexically Scoped and Fully Qualified&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;You will hear a lot about namespaces, symbol tables and lexical scoping in Perl discussions, but little of it will make any sense without a few key facts:&lt;/p&gt;

&lt;h4 id=&#34;span-id-symbols-symbol-tables-and-packages-typeglobs-symbols-symbol-tables-and-packages-typeglobs-span&#34;&gt;&lt;span id=&#34;symbols,_symbol_tables_and_packages;_typeglobs&#34;&gt;Symbols, Symbol Tables and Packages; Typeglobs&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;There are two important types of symbols: package global and lexical. We will talk about lexical symbols later; for now, we will talk only about package global symbols, which we will refer to as &lt;em&gt;global symbols&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The names of pieces of your code (subroutine names) and the names of your global variables are symbols. Global symbols reside in one symbol table or another. The code itself and the data do not; the symbols are the names of pointers that point (indirectly) to the memory areas that contain the code and data. (Note for C/C++ programmers: We use the term `pointer&amp;rsquo; in a general sense of one piece of data referring to another piece of data, and not in the specific sense as used in C or C++.)&lt;/p&gt;

&lt;p&gt;There is one symbol table for each package, (which is why &lt;em&gt;global symbols&lt;/em&gt; are really &lt;em&gt;package global symbols&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;You are always working in one package or another.&lt;/p&gt;

&lt;p&gt;Just as in C, where the first function you write must be called &lt;code&gt;main()&lt;/code&gt;, the first statement of your first Perl script is in package &lt;code&gt;main::&lt;/code&gt;, which is the default package. Unless you say otherwise by using the &lt;code&gt;package&lt;/code&gt; statement, your symbols are all in package &lt;code&gt;main::&lt;/code&gt;. You should be aware that files and packages are &lt;em&gt;not related&lt;/em&gt;. You can have any number of packages in a single file; and a single package can be in one file or spread among many files. However, it is common to have a single package in a single file. To declare a package you write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package mypackagename;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the following line you are in package &lt;code&gt;mypackagename&lt;/code&gt; and any symbols you declare reside in that package. When you create a symbol (variable, subroutine, etc.) Perl uses the name of the package in which you are currently working as a prefix to create the fully qualified name of the symbol.&lt;/p&gt;

&lt;p&gt;When you create a symbol, Perl creates a symbol table entry for that symbol in the current package&amp;rsquo;s symbol table (by default &lt;code&gt;main::&lt;/code&gt;). Each symbol table entry is called a &lt;em&gt;typeglob&lt;/em&gt;. Each typeglob can hold information on a scalar, an array, a hash, a subroutine (code), a filehandle, a directory handle and a format, each of which all have the same name. So you see now that there are two indirections for a global variable: the symbol (the thing&amp;rsquo;s name) points to its typeglob, and the entry in the typeglob for the thing&amp;rsquo;s type (scalar, array, etc.) points to the data. If we had a scalar and an array with the same name, then their name would point to the same typeglob, but for each type of data the typeglob points to somewhere different. Hence, the scalar&amp;rsquo;s data and the array&amp;rsquo;s data are completely separate and independent, they just happen to have the same name.&lt;/p&gt;

&lt;p&gt;Most of the time, only one part of a typeglob is used (yes, it&amp;rsquo;s a bit wasteful). By now, you know that you distinguish between them by using what the authors of the Camel book call a &lt;em&gt;funny character&lt;/em&gt;. So if we have a scalar called `&lt;code&gt;line&lt;/code&gt;,&amp;rsquo; then we would refer to it in code as &lt;code&gt;$line&lt;/code&gt;, and if we had an array of the same name, that would be written, &lt;code&gt;@line&lt;/code&gt;. Both would point to the same typeglob (which would be called &lt;code&gt;*line&lt;/code&gt;), but because of the &lt;em&gt;funny character&lt;/em&gt;, (also known as &lt;em&gt;decoration&lt;/em&gt;) Perl won&amp;rsquo;t confuse the two. Of course, we might confuse ourselves, so some programmers don&amp;rsquo;t ever use the same name for more than one type of variable.&lt;/p&gt;

&lt;p&gt;Every global symbol is in some package&amp;rsquo;s symbol table. To refer to a global symbol we could write the &lt;em&gt;fully qualified&lt;/em&gt; name, e.g. &lt;code&gt;$main::line&lt;/code&gt;. If we are in the same package as the symbol, then we can omit the package name, e.g. &lt;code&gt;$line&lt;/code&gt; (unless you use the &lt;code&gt;strict&lt;/code&gt; pragma and then you will have to predeclare the variable using the &lt;code&gt;vars&lt;/code&gt; pragma). We can also omit the package name if we have imported the symbol into our current package&amp;rsquo;s namespace. If we want to refer to a symbol that is in another package and which we haven&amp;rsquo;t imported, then we must use the fully qualified name, e.g. &lt;code&gt;$otherpkg::box&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Most of the time, you do not need to use the fully qualified symbol name, because most of the time you will refer to package variables from within the package. This is like C++ class variables. You can work entirely within package &lt;code&gt;main::&lt;/code&gt; and never even know you are using a package, nor that the symbols have package names. In a way, this is a pity, because you may fail to learn about packages and they are extremely useful.&lt;/p&gt;

&lt;p&gt;The exception is when you &lt;em&gt;import&lt;/em&gt; the variable from another package. This creates an alias for the variable in the &lt;em&gt;current&lt;/em&gt; package, so that you can access it without using the fully qualified name.&lt;/p&gt;

&lt;p&gt;While global variables are useful for sharing data and are necessary in some contexts, it is usually wiser to minimize their use and use &lt;em&gt;lexical variables&lt;/em&gt;, discussed next, instead.&lt;/p&gt;

&lt;p&gt;Note that when you create a variable, the low-level business of allocating memory to store the information is handled automatically by Perl. The intepreter keeps track of the chunks of memory to which the pointers are pointing and takes care of undefining variables. When all references to a variable have ceased to exist, then the Perl garbage collector is free to take back the memory used ready for recycling. However, Perl almost never returns back memory it has already used to the operating system during the lifetime of the process.&lt;/p&gt;

&lt;h3 id=&#34;span-id-lexical-variables-and-symbols-lexical-variables-and-symbols-span&#34;&gt;&lt;span id=&#34;lexical_variables_and_symbols&#34;&gt;Lexical Variables and Symbols&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The symbols for lexical variables (i.e. those declared using the keyword &lt;code&gt;my&lt;/code&gt;) are the only symbols that do &lt;em&gt;not&lt;/em&gt; live in a symbol table. Because of this, they are not available from outside the block in which they are declared. There is no typeglob associated with a lexical variable and a lexical variable can refer only to a scalar, an array or a hash.&lt;/p&gt;

&lt;p&gt;If you need access to the data from outside the package, then you can return it from a subroutine, or you can create a global variable (i.e. one that has a package prefix) that points or refers to it, and return that. The reference must be global so that you can refer to it by a fully qualified name. But just like in C, try to avoid having global variables. Using OO methods generally solves this problem by providing methods to get and set the desired value within the object that can be lexically scoped inside the package and passed by reference.&lt;/p&gt;

&lt;p&gt;The phrase ``lexical variable&amp;rdquo; is a bit of a misnomer, as we are really talking about ``lexical symbols.&amp;rdquo; The data can be referenced by a global symbol, too, and in such cases when the lexical symbol goes out of scope the data will still be accessible through the global symbol. This is perfectly legitimate and cannot be compared to the terrible mistake of taking a pointer to an automatic C variable and returning it from a function &amp;ndash; when the pointer is dereferenced there will be a segmentation fault. (Note for C/C++ programmers: having a function return a pointer to an auto variable is a disaster in C or C++; the Perl equivalent, returning a reference to a lexical variable created in a function is normal and useful.)&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;

&lt;a href=&#34;http://conferences.oreilly.com/oscon/&#34;&gt;O&amp;#39;Reilly Open Source Convention -- July 22-26, San Diego, CA.&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;From the Frontiers of Research to the Heart of the Enterprise&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://conferences.oreillynet.com/cs/os2002/view/e_sess/3032&#34;&gt;mod_perl 2.0, the Next Generation&lt;/a&gt; Stas Bekman will provide an overview of what&#39;s new in mod_perl 2.0 and what else is planned for the future in his talk at the upcoming &lt;a href=&#34;http://conferences.oreillynet.com/os2002/&#34;&gt;O&#39;Reilly Open Source Convention&lt;/a&gt;, this July 22-26, in San Diego.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;my()&lt;/code&gt; vs. &lt;code&gt;use vars&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;With use vars(), you are making an entry in the symbol table, and you are telling the compiler that you are going to be referencing that entry without an explicit package name.&lt;/p&gt;

&lt;p&gt;With my(), NO ENTRY IS PUT IN THE SYMBOL TABLE. The compiler figures out &lt;em&gt;at compile time&lt;/em&gt; which &lt;code&gt;my()&lt;/code&gt; variables (i.e. lexical variables) are the same as each other, and once you hit execute time you cannot look up those variables in the symbol table.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;my()&lt;/code&gt; vs. &lt;code&gt;local()&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;local()&lt;/code&gt; creates a temporal-limited package-based scalar, array, hash, or glob &amp;ndash; that&amp;rsquo;s to say, when the scope of definition is exited at runtime, the previous value (if any) is restored. References to such a variable are &lt;strong&gt;also&lt;/strong&gt; global &amp;hellip; only the value changes. (Aside: that is what causes variable suicide. :)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;my()&lt;/code&gt; creates a lexically limited nonpackage-based scalar, array, or hash &amp;ndash; when the scope of definition is exited at compile-time, the variable ceases to be accessible. Any references to such a variable at runtime turn into unique anonymous variables on each scope exit.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;span-id-use-require-do-inc-and-inc-explained-use-require-do-inc-and-inc-explained-span&#34;&gt;&lt;span id=&#34;use(),_require(),_do(),_%inc_and_@inc_explained&#34;&gt;use(), require(), do(), %INC and @INC Explained&lt;/span&gt;&lt;/h3&gt;

&lt;h4 id=&#34;span-id-the-inc-array-the-inc-array-span&#34;&gt;&lt;span id=&#34;the_@inc_array&#34;&gt;The @INC Array&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;@INC&lt;/code&gt; is a special Perl variable that is the equivalent to the shell&amp;rsquo;s &lt;code&gt;PATH&lt;/code&gt; variable. Whereas &lt;code&gt;PATH&lt;/code&gt; contains a list of directories to search for executables, &lt;code&gt;@INC&lt;/code&gt; contains a list of directories from which Perl modules and libraries can be loaded.&lt;/p&gt;

&lt;p&gt;When you &lt;code&gt;use()&lt;/code&gt;, &lt;code&gt;require()&lt;/code&gt; or &lt;code&gt;do()&lt;/code&gt; a filename or a module, Perl gets a list of directories from the &lt;code&gt;@INC&lt;/code&gt; variable and searches them for the file it was requested to load. If the file that you want to load is not located in one of the listed directories, then you have to tell Perl where to find the file. You can either provide a path relative to one of the directories in &lt;code&gt;@INC&lt;/code&gt;, or you can provide the full path to the file.&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-inc-hash-the-inc-hash-span&#34;&gt;&lt;span id=&#34;the_%inc_hash&#34;&gt;The %INC Hash&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;%INC&lt;/code&gt; is another special Perl variable that is used to cache the names of the files and the modules that were successfully loaded and compiled by &lt;code&gt;use()&lt;/code&gt;, &lt;code&gt;require()&lt;/code&gt; or &lt;code&gt;do()&lt;/code&gt; statements. Before attempting to load a file or a module with &lt;code&gt;use()&lt;/code&gt; or require(), Perl checks whether it&amp;rsquo;s already in the &lt;code&gt;%INC&lt;/code&gt; hash. If it&amp;rsquo;s there, then the loading and therefore the compilation are not performed at all. Otherwise, the file is loaded into memory and an attempt is made to compile it. &lt;code&gt;do()&lt;/code&gt; does unconditional loading &amp;ndash; no lookup in the &lt;code&gt;%INC&lt;/code&gt; hash is made.&lt;/p&gt;

&lt;p&gt;If the file is successfully loaded and compiled, then a new key-value pair is added to &lt;code&gt;%INC&lt;/code&gt;. The key is the name of the file or module as it was passed to the one of the three functions we have just mentioned. If it was found in any of the &lt;code&gt;@INC&lt;/code&gt; directories except &lt;code&gt;&amp;quot;.&amp;quot;&lt;/code&gt;, then the value is the full path to it in the file system.&lt;/p&gt;

&lt;p&gt;The following examples will make it easier to understand the logic.&lt;/p&gt;

&lt;p&gt;First, let&amp;rsquo;s see what are the contents of &lt;code&gt;@INC&lt;/code&gt; on my system:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % perl -e &#39;print join &amp;quot;\n&amp;quot;, @INC&#39;
  /usr/lib/perl5/5.00503/i386-linux
  /usr/lib/perl5/5.00503
  /usr/lib/perl5/site_perl/5.005/i386-linux
  /usr/lib/perl5/site_perl/5.005
  .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that &lt;code&gt;.&lt;/code&gt; (current directory) is the last directory in the list.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s load the module &lt;code&gt;strict.pm&lt;/code&gt; and see the contents of &lt;code&gt;%INC&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % perl -e &#39;use strict; print map {&amp;quot;$_ =&amp;gt; $INC{$_}\n&amp;quot;} keys %INC&#39;

  strict.pm =&amp;gt; /usr/lib/perl5/5.00503/strict.pm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since &lt;code&gt;strict.pm&lt;/code&gt; was found in &lt;em&gt;/usr/lib/perl5/5.00503/&lt;/em&gt; directory and &lt;em&gt;/usr/lib/perl5/5.00503/&lt;/em&gt; is a part of &lt;code&gt;@INC&lt;/code&gt;, &lt;code&gt;%INC&lt;/code&gt; includes the full path as the value for the key &lt;code&gt;strict.pm&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s create the simplest module in &lt;code&gt;/tmp/test.pm&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  test.pm
  -------
  1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It does nothing, but returns a true value when loaded. Now let&amp;rsquo;s load it in different ways:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % cd /tmp
  % perl -e &#39;use test; print map {&amp;quot;$_ =&amp;gt; $INC{$_}\n&amp;quot;} keys %INC&#39;

  test.pm =&amp;gt; test.pm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since the file was found relative to &lt;code&gt;.&lt;/code&gt; (the current directory), the relative path is inserted as the value. If we alter &lt;code&gt;@INC&lt;/code&gt; by adding &lt;em&gt;/tmp&lt;/em&gt; to the end:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % cd /tmp
  % perl -e &#39;BEGIN{push @INC, &amp;quot;/tmp&amp;quot;} use test; \
  print map {&amp;quot;$_ =&amp;gt; $INC{$_}\n&amp;quot;} keys %INC&#39;

  test.pm =&amp;gt; test.pm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we still get the relative path, since the module was found first relative to &lt;code&gt;&amp;quot;.&amp;quot;&lt;/code&gt;. The directory &lt;em&gt;/tmp&lt;/em&gt; was placed after &lt;code&gt;.&lt;/code&gt; in the list. If we execute the same code from a different directory, then the &lt;code&gt;&amp;quot;.&amp;quot;&lt;/code&gt; directory won&amp;rsquo;t match,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % cd /
  % perl -e &#39;BEGIN{push @INC, &amp;quot;/tmp&amp;quot;} use test; \
  print map {&amp;quot;$_ =&amp;gt; $INC{$_}\n&amp;quot;} keys %INC&#39;

  test.pm =&amp;gt; /tmp/test.pm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;so we get the full path. We can also prepend the path with &lt;code&gt;unshift()&lt;/code&gt;, so it will be used for matching before &lt;code&gt;&amp;quot;.&amp;quot;&lt;/code&gt; and therefore we will get the full path as well:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % cd /tmp
  % perl -e &#39;BEGIN{unshift @INC, &amp;quot;/tmp&amp;quot;} use test; \
  print map {&amp;quot;$_ =&amp;gt; $INC{$_}\n&amp;quot;} keys %INC&#39;

  test.pm =&amp;gt; /tmp/test.pm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  BEGIN{unshift @INC, &amp;quot;/tmp&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;can be replaced with the more elegant:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use lib &amp;quot;/tmp&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which is almost equivalent to our &lt;code&gt;BEGIN&lt;/code&gt; block and is the recommended approach.&lt;/p&gt;

&lt;p&gt;These approaches to modifying &lt;code&gt;@INC&lt;/code&gt; can be labor intensive, since if you want to move the script around in the file-system, then you have to modify the path. This can be painful, for example, when you move your scripts from development to a production server.&lt;/p&gt;

&lt;p&gt;There is a module called &lt;code&gt;FindBin&lt;/code&gt; that solves this problem in the plain Perl world, but, unfortunately, it won&amp;rsquo;t work under mod_perl, since it&amp;rsquo;s a module, and as any module, it&amp;rsquo;s loaded only once. So the first script using it will have all the settings correct, but the rest of the scripts will not if they&amp;rsquo;re in a different directory from the first.&lt;/p&gt;

&lt;p&gt;For the sake of completeness, I&amp;rsquo;ll present this module anyway.&lt;/p&gt;

&lt;p&gt;If you use this module, then you don&amp;rsquo;t need to write a hard-coded path. The following snippet does all the work for you (the file is &lt;em&gt;/tmp/load.pl&lt;/em&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  load.pl
  -------
  #!/usr/bin/perl

  use FindBin ();
  use lib &amp;quot;$FindBin::Bin&amp;quot;;
  use test;
  print &amp;quot;test.pm =&amp;gt; $INC{&#39;test.pm&#39;}\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above example, &lt;code&gt;$FindBin::Bin&lt;/code&gt; is equal to &lt;em&gt;/tmp&lt;/em&gt;. If we move the script somewhere else&amp;hellip; e.g. &lt;em&gt;/tmp/x&lt;/em&gt; in the code above &lt;code&gt;$FindBin::Bin&lt;/code&gt; equals &lt;em&gt;/home/x&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % /tmp/load.pl

  test.pm =&amp;gt; /tmp/test.pm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is just like &lt;code&gt;use lib&lt;/code&gt; except that no hard-coded path is required.&lt;/p&gt;

&lt;p&gt;You can use this workaround to make it work under mod_perl.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  do &#39;FindBin.pm&#39;;
  unshift @INC, &amp;quot;$FindBin::Bin&amp;quot;;
  require test;
  #maybe test::import( ... ) here if need to import stuff
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This has a slight overhead, because it will load from disk and recompile the &lt;code&gt;FindBin&lt;/code&gt; module on each request. So it may not be worth it.&lt;/p&gt;

&lt;h4 id=&#34;span-id-modules-libraries-and-program-files-modules-libraries-and-program-files-span&#34;&gt;&lt;span id=&#34;modules,_libraries_and_program_files&#34;&gt;Modules, Libraries and Program Files&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Before we proceed, let&amp;rsquo;s define what we mean by &lt;em&gt;module&lt;/em&gt;, &lt;em&gt;library&lt;/em&gt; and &lt;em&gt;program file&lt;/em&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;span id=&#34;item_libraries&#34;&gt;Libraries&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span id=&#34;item_modules&#34;&gt;Modules&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span id=&#34;item_program_files&#34;&gt;Program Files&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;span-id-require-require-span&#34;&gt;&lt;span id=&#34;require()&#34;&gt;&lt;code&gt;require()&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;Previously in the Series&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://perl.com/pub/2002/05/07/mod_perl.html&#34;&gt;The Perl You Need To Know - Part 2&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/04/23/mod_perl.html&#34;&gt;The Perl You Need To Know&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/04/10/mod_perl.html&#34;&gt;Installing mod_perl without superuser privileges&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/03/22/modperl.html&#34;&gt;mod_perl in 30 minutes&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/02/26/whatismodperl.html&#34;&gt;Why mod_perl?&lt;/a&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code&gt;require()&lt;/code&gt; reads a file containing Perl code and compiles it. Before attempting to load the file, it looks up the argument in &lt;code&gt;%INC&lt;/code&gt; to see whether it has already been loaded. If it has, then &lt;code&gt;require()&lt;/code&gt; just returns without doing a thing. Otherwise, an attempt will be made to load and compile the file.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;require()&lt;/code&gt; has to find the file it has to load. If the argument is a full path to the file, then it just tries to read it. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  require &amp;quot;/home/httpd/perl/mylibs.pl&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the path is relative, then &lt;code&gt;require()&lt;/code&gt; will attempt to search for the file in all the directories listed in &lt;code&gt;@INC&lt;/code&gt;. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  require &amp;quot;mylibs.pl&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If there is more than one occurrence of the file with the same name in the directories listed in &lt;code&gt;@INC&lt;/code&gt;, then the first occurrence will be used.&lt;/p&gt;

&lt;p&gt;The file must return &lt;em&gt;TRUE&lt;/em&gt; as the last statement to indicate successful execution of any initialization code. Since you never know what changes the file will go through in the future, you cannot be sure that the last statement will always return &lt;em&gt;TRUE&lt;/em&gt;. That&amp;rsquo;s why the suggestion is to put ``&lt;code&gt;1;&lt;/code&gt;&amp;rdquo; at the end of file.&lt;/p&gt;

&lt;p&gt;Although you should use the real filename for most files, if the file is a module, then you may use the following convention instead:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  require My::Module;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is equal to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  require &amp;quot;My/Module.pm&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If &lt;code&gt;require()&lt;/code&gt; fails to load the file, either because it couldn&amp;rsquo;t find the file in question or the code failed to compile, or it didn&amp;rsquo;t return &lt;em&gt;TRUE&lt;/em&gt;, then the program would die(). To prevent this, the &lt;code&gt;require()&lt;/code&gt; statement can be enclosed into an &lt;code&gt;eval()&lt;/code&gt; exception-handling block, as in this example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  require.pl
  ----------
  #!/usr/bin/perl -w

  eval { require &amp;quot;/file/that/does/not/exists&amp;quot;};
  if ($@) {
    print &amp;quot;Failed to load, because : $@&amp;quot;
  }
  print &amp;quot;\nHello\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we execute the program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % ./require.pl

  Failed to load, because : Can&#39;t locate /file/that/does/not/exists in
  @INC (@INC contains: /usr/lib/perl5/5.00503/i386-linux
  /usr/lib/perl5/5.00503 /usr/lib/perl5/site_perl/5.005/i386-linux
  /usr/lib/perl5/site_perl/5.005 .) at require.pl line 3.

  Hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We see that the program didn&amp;rsquo;t die(), because &lt;em&gt;Hello&lt;/em&gt; was printed. This &lt;em&gt;trick&lt;/em&gt; is useful when you want to check whether a user has some module installed. If she hasn&amp;rsquo;t, then it&amp;rsquo;s not critical, because the program can run with reduced functionality without this module.&lt;/p&gt;

&lt;p&gt;If we remove the &lt;code&gt;eval()&lt;/code&gt; part and try again:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  require.pl
  ----------
  #!/usr/bin/perl -w

  require &amp;quot;/file/that/does/not/exists&amp;quot;;
  print &amp;quot;\nHello\n&amp;quot;;

  % ./require1.pl

  Can&#39;t locate /file/that/does/not/exists in @INC (@INC contains:
  /usr/lib/perl5/5.00503/i386-linux /usr/lib/perl5/5.00503
  /usr/lib/perl5/site_perl/5.005/i386-linux
  /usr/lib/perl5/site_perl/5.005 .) at require1.pl line 3.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The program just die()s in the last example, which is what you want in most cases.&lt;/p&gt;

&lt;p&gt;For more information, refer to the perlfunc manpage.&lt;/p&gt;

&lt;h4 id=&#34;span-id-use-use-span&#34;&gt;&lt;span id=&#34;use()&#34;&gt;&lt;code&gt;use()&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;use(), just like require(), loads and compiles files containing Perl code, but it works with modules only. The only way to pass a module to load is by its module name and not its filename. If the module is located in &lt;em&gt;MyCode.pm&lt;/em&gt;, then the correct way to &lt;code&gt;use()&lt;/code&gt; it is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use MyCode
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and not:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use &amp;quot;MyCode.pm&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;use()&lt;/code&gt; translates the passed argument into a file name replacing &lt;code&gt;::&lt;/code&gt; with the operating system&amp;rsquo;s path separator (normally &lt;code&gt;/&lt;/code&gt;) and appending &lt;em&gt;.pm&lt;/em&gt; at the end. So &lt;code&gt;My::Module&lt;/code&gt; becomes &lt;em&gt;My/Module.pm&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;use()&lt;/code&gt; is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; BEGIN { require Module; Module-&amp;gt;import(LIST); }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Internally it calls &lt;code&gt;require()&lt;/code&gt; to do the loading and compilation chores. When &lt;code&gt;require()&lt;/code&gt; finishes its job, &lt;code&gt;import()&lt;/code&gt; is called unless &lt;code&gt;()&lt;/code&gt; is the second argument. The following pairs are equivalent:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use MyModule;
  BEGIN {require MyModule; MyModule-&amp;gt;import; }

  use MyModule qw(foo bar);
  BEGIN {require MyModule; MyModule-&amp;gt;import(&amp;quot;foo&amp;quot;,&amp;quot;bar&amp;quot;); }

  use MyModule ();
  BEGIN {require MyModule; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first pair exports the default tags. This happens if the module sets &lt;code&gt;@EXPORT&lt;/code&gt; to a list of tags to be exported by default. The module&amp;rsquo;s mainpage normally describes which tags are exported by default.&lt;/p&gt;

&lt;p&gt;The second pair exports only the tags passed as arguments.&lt;/p&gt;

&lt;p&gt;The third pair describes the case where the caller does not want any symbols to be imported.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;import()&lt;/code&gt; is not a built-in function, it&amp;rsquo;s just an ordinary static method call into the ``&lt;code&gt;MyModule&lt;/code&gt;&amp;rdquo; package to tell the module to import the list of features back into the current package. See the Exporter manpage for more information.&lt;/p&gt;

&lt;p&gt;When you write your own modules, always remember that it&amp;rsquo;s better to use &lt;code&gt;@EXPORT_OK&lt;/code&gt; instead of &lt;code&gt;@EXPORT&lt;/code&gt;, since the former doesn&amp;rsquo;t export symbols unless it was asked to. Exports pollute the namespace of the module user. Also avoid short or common symbol names to reduce the risk of name clashes.&lt;/p&gt;

&lt;p&gt;When functions and variables aren&amp;rsquo;t exported you can still access them using their full names, like &lt;code&gt;$My::Module::bar&lt;/code&gt; or &lt;code&gt;$My::Module::foo()&lt;/code&gt;. By convention you can use a leading underscore on names to informally indicate that they are &lt;em&gt;internal&lt;/em&gt; and not for public use.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s a corresponding ``&lt;code&gt;no&lt;/code&gt;&amp;rdquo; command that un-imports symbols imported by &lt;code&gt;use&lt;/code&gt;, i.e., it calls &lt;code&gt;Module-&amp;gt;unimport(LIST)&lt;/code&gt; instead of &lt;code&gt;import()&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;span-id-do-do-span&#34;&gt;&lt;span id=&#34;do()&#34;&gt;&lt;code&gt;do()&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;While &lt;code&gt;do()&lt;/code&gt; behaves almost identically to require(), it reloads the file unconditionally. It doesn&amp;rsquo;t check &lt;code&gt;%INC&lt;/code&gt; to see whether the file was already loaded.&lt;/p&gt;

&lt;p&gt;If &lt;code&gt;do()&lt;/code&gt; cannot read the file, then it returns &lt;code&gt;undef&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; to report the error. If &lt;code&gt;do()&lt;/code&gt; can read the file but cannot compile it, then it returns &lt;code&gt;undef&lt;/code&gt; and puts an error message in &lt;code&gt;$@&lt;/code&gt;. If the file is successfully compiled, then &lt;code&gt;do()&lt;/code&gt; returns the value of the last expression evaluated.&lt;/p&gt;

&lt;h3 id=&#34;span-id-references-references-span&#34;&gt;&lt;span id=&#34;references&#34;&gt;References&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;An article by Mark-Jason Dominus about how Perl handles variables and namespaces, and the difference between &lt;code&gt;use vars()&lt;/code&gt; and &lt;code&gt;my()&lt;/code&gt; - &lt;a href=&#34;http://www.plover.com/~mjd/perl/FAQs/Namespaces.html&#34;&gt;http://www.plover.com/~mjd/perl/FAQs/Namespaces.html&lt;/a&gt; .&lt;/li&gt;

&lt;li&gt;&lt;p&gt;For an in-depth explanation of Perl data types, see chapters 3 and 6 in the book &lt;em&gt;``Advanced Perl Programming&amp;rdquo;&lt;/em&gt; by Sriram Srinivasan.&lt;/p&gt;

&lt;p&gt;And, of course, the ``&lt;em&gt;Programming Perl&lt;/em&gt;&amp;rdquo; by L.Wall, T. Christiansen and J.Orwant (also known as the ``&lt;em&gt;Camel&lt;/em&gt;&amp;rdquo; book, named after the camel picture on the cover of the book). Look at chapters 10, 11 and 21.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;em&gt;Exporter&lt;/em&gt;, &lt;em&gt;perlvar&lt;/em&gt;, &lt;em&gt;perlmod&lt;/em&gt; and &lt;em&gt;perlmodlib&lt;/em&gt; man pages.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>The Perl You Need To Know - Part 2</title>
      <link>http://localhost:1313/pub/2002/05/07/mod_perl.html/</link>
      <pubDate>Tue, 07 May 2002 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2002/05/07/mod_perl.html/</guid>
      <description>

&lt;h3 id=&#34;span-id-introduction-introduction-span&#34;&gt;&lt;span id=&#34;introduction&#34;&gt;Introduction&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In this article, we continue to talk about the essential Perl basics that you should know before starting to program for mod_perl.&lt;/p&gt;

&lt;h3 id=&#34;span-id-tracing-warnings-reports-tracing-warnings-reports-span&#34;&gt;&lt;span id=&#34;tracing warnings reports&#34;&gt;Tracing Warnings Reports&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Sometimes it&amp;rsquo;s hard to understand what a warning is complaining about. You see the source code, but you cannot understand why some specific snippet produces that warning. The mystery often results from the fact that the code can be called from different places if it&amp;rsquo;s located inside a subroutine.&lt;/p&gt;

&lt;p&gt;Here is an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  warnings.pl
  -----------
  #!/usr/bin/perl -w

  use strict;

  correct();
  incorrect();

  sub correct{
    print_value(&amp;quot;Perl&amp;quot;);
  }

  sub incorrect{
    print_value();
  }

  sub print_value{
    my $var = shift;
    print &amp;quot;My value is $var\n&amp;quot;;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the code above, &lt;code&gt;print_value()&lt;/code&gt; prints the passed value. Subroutine &lt;code&gt;correct()&lt;/code&gt; passes the value to print, but in subroutine &lt;code&gt;incorrect()&lt;/code&gt; we forgot to pass it. When we run the script:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % ./warnings.pl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we get the warning:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Use of uninitialized value at ./warnings.pl line 16.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perl complains about an undefined variable &lt;code&gt;$var&lt;/code&gt; at the line that attempts to print its value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  print &amp;quot;My value is $var\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But how do we know why it is undefined? The reason here obviously is that the calling function didn&amp;rsquo;t pass the argument. But how do we know who was the caller? In our example, there are two possible callers, in the general case there can be many of them, perhaps located in other files.&lt;/p&gt;

&lt;p&gt;We can use the &lt;code&gt;caller()&lt;/code&gt; function, which tells who has called us, but even that might not be enough: It&amp;rsquo;s possible to have a longer sequence of called subroutines, and not just two. For example, here it is sub &lt;code&gt;third()&lt;/code&gt; which is at fault, and putting sub &lt;code&gt;caller()&lt;/code&gt; in sub &lt;code&gt;second()&lt;/code&gt; would not help:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  sub third{
    second();
  }
  sub second{
    my $var = shift;
    first($var);
  }
  sub first{
    my $var = shift;
   print &amp;quot;Var = $var\n&amp;quot;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The solution is quite simple. What we need is a full calls stack trace to the call that triggered the warning.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Carp&lt;/code&gt; module comes to our aid with its &lt;code&gt;cluck()&lt;/code&gt; function. Let&amp;rsquo;s modify the script by adding a couple of lines. The rest of the script is unchanged.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  warnings2.pl
  -----------
  #!/usr/bin/perl -w

  use strict;
  use Carp ();
  local $SIG{__WARN__} = \&amp;amp;Carp::cluck;

  correct();
  incorrect();

  sub correct{
    print_value(&amp;quot;Perl&amp;quot;);
  }

  sub incorrect{
    print_value();
  }

  sub print_value{
    my $var = shift;
    print &amp;quot;My value is $var\n&amp;quot;;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now when we execute it, we see:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Use of uninitialized value at ./warnings2.pl line 19.
    main::print_value() called at ./warnings2.pl line 14
    main::incorrect() called at ./warnings2.pl line 7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Take a moment to understand the calls stack trace. The deepest calls are printed first. So the second line tells us that the warning was triggered in print_value(); the third, that &lt;code&gt;print_value()&lt;/code&gt; was called by subroutine, incorrect().&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  script =&amp;gt; incorrect() =&amp;gt; print_value()
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;

&lt;a href=&#34;http://conferences.oreilly.com/oscon/&#34;&gt;O&amp;#39;Reilly Open Source Convention -- July 22-26, San Diego, CA.&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;From the Frontiers of Research to the Heart of the Enterprise&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://conferences.oreillynet.com/cs/os2002/view/e_sess/3032&#34;&gt;mod_perl 2.0, the Next Generation&lt;/a&gt; Stas Bekman will provide an overview of what&#39;s new in mod_perl 2.0 and what else is planned for the future in his talk at the upcoming &lt;a href=&#34;http://conferences.oreillynet.com/os2002/&#34;&gt;O&#39;Reilly Open Source Convention&lt;/a&gt;, this July 22-26, in San Diego.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;We go into &lt;code&gt;incorrect()&lt;/code&gt; and indeed see that we forgot to pass the variable. Of course, when you write a subroutine such as &lt;code&gt;print_value&lt;/code&gt;, it would be a good idea to check the passed arguments before starting execution. We omitted that step to contrive an easily debugged example.&lt;/p&gt;

&lt;p&gt;Sure, you say, I could find that problem by simple inspection of the code!&lt;/p&gt;

&lt;p&gt;Well, you&amp;rsquo;re right. But I promise you that your task would be quite complicated and time consuming if your code has some thousands of lines. In addition, under mod_perl, certain uses of the &lt;code&gt;eval&lt;/code&gt; operator and ``here documents&amp;rdquo; are known to throw off Perl&amp;rsquo;s line numbering, so the messages reporting warnings and errors can have incorrect line numbers. This can be easily fixed by helping compiler with &lt;code&gt;#line&lt;/code&gt; directive. If you put the following at the beginning of the line in your script:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; #line 125
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then it will tell the compiler that the &lt;strong&gt;next&lt;/strong&gt; line is number 125 for reporting needs. Of course, the rest of the lines would be adapted as well.&lt;/p&gt;

&lt;p&gt;Getting the trace helps a lot.&lt;/p&gt;

&lt;h3 id=&#34;span-id-my-scoped-variable-in-nested-subroutines-my-scoped-variable-in-nested-subroutines-span&#34;&gt;&lt;span id=&#34;my() scoped variable in nested subroutines&#34;&gt;&lt;code&gt;my()&lt;/code&gt; Scoped Variable in Nested Subroutines&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Before we proceed let&amp;rsquo;s make the assumption that we want to develop the code under the &lt;code&gt;strict&lt;/code&gt; pragma. We will use lexically scoped variables (with help of the &lt;code&gt;my()&lt;/code&gt; operator) whenever it&amp;rsquo;s possible.&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-poison-the-poison-span&#34;&gt;&lt;span id=&#34;the poison&#34;&gt;The Poison&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Let&amp;rsquo;s look at this code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  nested.pl
  -----------
  #!/usr/bin/perl

  use strict;

  sub print_power_of_2 {
    my $x = shift;

    sub power_of_2 {
      return $x ** 2;
    }

    my $result = power_of_2();
    print &amp;quot;$x^2 = $result\n&amp;quot;;
  }

  print_power_of_2(5);
  print_power_of_2(6);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Don&amp;rsquo;t let the weird subroutine names fool you, the &lt;code&gt;print_power_of_2()&lt;/code&gt; subroutine should print the square of the number passed to it. Let&amp;rsquo;s run the code and see whether it works:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % ./nested.pl

  5^2 = 25
  6^2 = 25
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ouch, something is wrong. May be there is a bug in Perl and it doesn&amp;rsquo;t work correctly with the number 6? Let&amp;rsquo;s try again using 5 and 7:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  print_power_of_2(5);
  print_power_of_2(7);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And run it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % ./nested.pl

  5^2 = 25
  7^2 = 25
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wow, does it works only for 5? How about using 3 and 5:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  print_power_of_2(3);
  print_power_of_2(5);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the result is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % ./nested.pl

  3^2 = 9
  5^2 = 9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we start to understand &amp;ndash; only the first call to the &lt;code&gt;print_power_of_2()&lt;/code&gt; function works correctly. This makes us think that our code has some kind of memory for the results of the first execution, or it ignores the arguments in subsequent executions.&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-diagnosis-the-diagnosis-span&#34;&gt;&lt;span id=&#34;the diagnosis&#34;&gt;The Diagnosis&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Let&amp;rsquo;s follow the guidelines and use the &lt;code&gt;-w&lt;/code&gt; flag:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #!/usr/bin/perl -w
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Under Perl version 5.6.0+ we use the &lt;code&gt;warnings&lt;/code&gt; pragma:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #!/usr/bin/perl
  use warnings;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now execute the code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % ./nested.pl

  Variable &amp;quot;$x&amp;quot; will not stay shared at ./nested.pl line 9.
  5^2 = 25
  6^2 = 25
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have never seen such a warning message before and we don&amp;rsquo;t quite understand what it means. The &lt;code&gt;diagnostics&lt;/code&gt; pragma will certainly help us. Let&amp;rsquo;s prepend this pragma before the &lt;code&gt;strict&lt;/code&gt; pragma in our code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #!/usr/bin/perl -w

  use diagnostics;
  use strict;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And execute it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % ./nested.pl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Variable &amp;ldquo;$x&amp;rdquo; will not stay shared at ./nested.pl line 10 (#1)&lt;/p&gt;

&lt;p&gt;(W) An inner (nested) named subroutine is referencing a lexical variable defined in an outer subroutine.&lt;/p&gt;

&lt;p&gt;When the inner subroutine is called, it will probably see the value of the outer subroutine&amp;rsquo;s variable as it was before and during the *first* call to the outer subroutine; in this case, after the first call to the outer subroutine is complete, the inner and outer subroutines will no longer share a common value for the variable. In other words, the variable will no longer be shared.&lt;/p&gt;

&lt;p&gt;Furthermore, if the outer subroutine is anonymous and references a lexical variable outside itself, then the outer and inner subroutines will never share the given variable.&lt;/p&gt;

&lt;p&gt;This problem can usually be solved by making the inner subroutine anonymous, using the sub {} syntax. When inner anonymous subs that reference variables in outer subroutines are called or referenced, they are automatically rebound to the current values of such variables.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  5^2 = 25
  6^2 = 25
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well, now everything is clear. We have the &lt;strong&gt;inner&lt;/strong&gt; subroutine &lt;code&gt;power_of_2()&lt;/code&gt; and the &lt;strong&gt;outer&lt;/strong&gt; subroutine &lt;code&gt;print_power_of_2()&lt;/code&gt; in our code.&lt;/p&gt;

&lt;p&gt;When the inner &lt;code&gt;power_of_2()&lt;/code&gt; subroutine is called for the first time, it sees the value of the outer &lt;code&gt;print_power_of_2()&lt;/code&gt; subroutine&amp;rsquo;s &lt;code&gt;$x&lt;/code&gt; variable. On subsequent calls the inner subroutine&amp;rsquo;s &lt;code&gt;$x&lt;/code&gt; variable won&amp;rsquo;t be updated, no matter what new values are given to &lt;code&gt;$x&lt;/code&gt; in the outer subroutine. There are two copies of the &lt;code&gt;$x&lt;/code&gt; variable, no longer a single one shared by the two routines.&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-remedy-the-remedy-span&#34;&gt;&lt;span id=&#34;the remedy&#34;&gt;The Remedy&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;diagnostics&lt;/code&gt; pragma suggests that the problem can be solved by making the inner subroutine anonymous.&lt;/p&gt;

&lt;p&gt;An anonymous subroutine can act as a &lt;em&gt;closure&lt;/em&gt; with respect to lexically scoped variables. Basically, this means that if you define a subroutine in a particular &lt;strong&gt;lexical&lt;/strong&gt; context at a particular moment, then it will run in that same context later, even if called from outside that context. The upshot of this is that when the subroutine &lt;strong&gt;runs&lt;/strong&gt;, you get the same copies of the lexically scoped variables that were visible when the subroutine was &lt;strong&gt;defined&lt;/strong&gt;. So you can pass arguments to a function when you define it, as well as when you invoke it.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s rewrite the code to use this technique:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  anonymous.pl
  --------------
  #!/usr/bin/perl

  use strict;

  sub print_power_of_2 {
    my $x = shift;

    my $func_ref = sub {
      return $x ** 2;
    };

    my $result = &amp;amp;$func_ref();
    print &amp;quot;$x^2 = $result\n&amp;quot;;
  }

  print_power_of_2(5);
  print_power_of_2(6);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now &lt;code&gt;$func_ref&lt;/code&gt; contains a reference to an anonymous function, which we later use when we need to get the power of two. (In Perl, a function is the same thing as a subroutine.) Since it is anonymous, the function will automatically be rebound to the new value of the outer scoped variable &lt;code&gt;$x&lt;/code&gt;, and the results will now be as expected.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s verify:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % ./anonymous.pl

  5^2 = 25
  6^2 = 36
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we can see that the problem is solved.&lt;/p&gt;

&lt;h3 id=&#34;span-id-when-you-cannot-get-rid-of-the-inner-subroutine-when-you-cannot-get-rid-of-the-inner-subroutine-span&#34;&gt;&lt;span id=&#34;when you cannot get rid of the inner subroutine&#34;&gt;When You Cannot Get Rid of the Inner Subroutine&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;First, you might wonder, why in the world will someone need to define an inner subroutine? Well, for example, to reduce some of Perl&amp;rsquo;s script startup overhead you might decide to write a daemon that will compile the scripts and modules only once, and cache the pre-compiled code in memory. When some script is to be executed, you just tell the daemon the name of the script to run and it will do the rest and do it much faster since compilation has already taken place.&lt;/p&gt;

&lt;p&gt;Seems like an easy task; and it is. The only problem is once the script is compiled, how do you execute it? Or let&amp;rsquo;s put it another way: After it was executed for the first time and it stays compiled in the daemon&amp;rsquo;s memory, how do you call it again? If you could get all developers to code their scripts so each has a subroutine called &lt;code&gt;run()&lt;/code&gt; that will actually execute the code in the script, then we&amp;rsquo;ve solved half the problem.&lt;/p&gt;

&lt;p&gt;But how does the daemon know to refer to some specific script if they all run in the &lt;code&gt;main::&lt;/code&gt; name space? One solution might be to ask the developers to declare a package in each and every script, and for the package name to be derived from the script name. However, since there is a chance that there will be more than one script with the same name but residing in different directories, then in order to prevent namespace collisions the directory has to be a part of the package name, too. And don&amp;rsquo;t forget that the script may be moved from one directory to another, so you will have to make sure that the package name is corrected each time the script gets moved.&lt;/p&gt;

&lt;p&gt;But why enforce these strange rules on developers, when we can arrange for our daemon to do this work? For every script that the daemon is about to execute for the first time, the script should be wrapped inside the package whose name is constructed from the mangled path to the script and a subroutine called run(). For example, if the daemon is about to execute the script &lt;em&gt;/tmp/hello.pl&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  hello.pl
  --------
  #!/usr/bin/perl
  print &amp;quot;Hello\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then prior to running it, the daemon will change the code to be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  wrapped_hello.pl
  ----------------
  package cache::tmp::hello_2epl;

  sub run{
    #!/usr/bin/perl
    print &amp;quot;Hello\n&amp;quot;;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The package name is constructed from the prefix &lt;code&gt;cache::&lt;/code&gt;, each directory separation slash is replaced with &lt;code&gt;::&lt;/code&gt;, and nonalphanumeric characters are encoded so that for example &lt;code&gt;.&lt;/code&gt; (a dot) becomes &lt;code&gt;_2e&lt;/code&gt; (an underscore followed by the ASCII code for a dot in hex representation).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; % perl -e &#39;printf &amp;quot;%x&amp;quot;,ord(&amp;quot;.&amp;quot;)&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;prints: &lt;code&gt;2e&lt;/code&gt;. The underscore is the same you see in URL encoding except the &lt;code&gt;%&lt;/code&gt; character is used instead (&lt;code&gt;%2E&lt;/code&gt;), but since &lt;code&gt;%&lt;/code&gt; has a special meaning in Perl (prefix of hash variable) it couldn&amp;rsquo;t be used.&lt;/p&gt;

&lt;p&gt;Now when the daemon is requested to execute the script &lt;em&gt;/tmp/hello.pl&lt;/em&gt;, all it has to do is to build the package name as before based on the location of the script and call its &lt;code&gt;run()&lt;/code&gt; subroutine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use cache::tmp::hello_2epl;
  cache::tmp::hello_2epl::run();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have just written a partial prototype of the daemon we wanted. The only outstanding problem is how to pass the path to the script to the daemon. This detail is left as an exercise for the reader.&lt;/p&gt;

&lt;p&gt;If you are familiar with the &lt;code&gt;Apache::Registry&lt;/code&gt; module, then you know that it works in almost the same way. It uses a different package prefix and the generic function is called &lt;code&gt;handler()&lt;/code&gt; and not run(). The scripts to run are passed through the HTTP protocol&amp;rsquo;s headers.&lt;/p&gt;

&lt;p&gt;Now you understand that there are cases where your normal subroutines can become inner, since if your script was a simple:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  simple.pl
  ---------
  #!/usr/bin/perl
  sub hello { print &amp;quot;Hello&amp;quot; }
  hello();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wrapped into a &lt;code&gt;run()&lt;/code&gt; subroutine it becomes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  simple.pl
  ---------
  package cache::simple_2epl;

  sub run{
    #!/usr/bin/perl
    sub hello { print &amp;quot;Hello&amp;quot; }
    hello();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Therefore, &lt;code&gt;hello()&lt;/code&gt; is an inner subroutine and if you have used &lt;code&gt;my()&lt;/code&gt; scoped variables defined and altered outside and used inside hello(), it won&amp;rsquo;t work as you expect starting from the second call, as was explained in the previous section.&lt;/p&gt;

&lt;h4 id=&#34;span-id-remedies-for-inner-subroutines-remedies-for-inner-subroutines-span&#34;&gt;&lt;span id=&#34;remedies for inner subroutines&#34;&gt;Remedies for Inner Subroutines&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;First of all, there is nothing to worry about, as long as you don&amp;rsquo;t forget to turn the warnings On. If you do happen to have the &lt;em&gt;``my() Scoped Variable in Nested Subroutines&amp;rdquo;&lt;/em&gt; problem, then Perl will always alert you.&lt;/p&gt;

&lt;p&gt;Given that you have a script that has this problem, what are the ways to solve it? There are many of them and we will discuss some of them here.&lt;/p&gt;

&lt;p&gt;We will use the following code to show the different solutions.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  multirun.pl
  -----------
  #!/usr/bin/perl -w

  use strict;

  for (1..3){
    print &amp;quot;run: [time $_]\n&amp;quot;;
    run();
  }

  sub run{
    my $counter = 0;

    increment_counter();
    increment_counter();

    sub increment_counter{
      $counter++;
      print &amp;quot;Counter is equal to $counter !\n&amp;quot;;
    }

  } # end of sub run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code executes the &lt;code&gt;run()&lt;/code&gt; subroutine three times, which in turn initializes the &lt;code&gt;$counter&lt;/code&gt; variable to 0 each time it is executed and then calls the inner subroutine &lt;code&gt;increment_counter()&lt;/code&gt; twice. Sub &lt;code&gt;increment_counter()&lt;/code&gt; prints &lt;code&gt;$counter&lt;/code&gt;&amp;rsquo;s value after incrementing it. One might expect to see the following output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  run: [time 1]
  Counter is equal to 1 !
  Counter is equal to 2 !
  run: [time 2]
  Counter is equal to 1 !
  Counter is equal to 2 !
  run: [time 3]
  Counter is equal to 1 !
  Counter is equal to 2 !
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But as we have already learned from the previous sections, this is not what we are going to see. Indeed, when we run the script we see:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % ./multirun.pl
  Variable &amp;quot;$counter&amp;quot; will not stay shared at ./nested.pl line 18.
  run: [time 1]
  Counter is equal to 1 !
  Counter is equal to 2 !
  run: [time 2]
  Counter is equal to 3 !
  Counter is equal to 4 !
  run: [time 3]
  Counter is equal to 5 !
  Counter is equal to 6 !
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Obviously, the &lt;code&gt;$counter&lt;/code&gt; variable is not reinitialized on each execution of run(). It retains its value from the previous execution, and sub &lt;code&gt;increment_counter()&lt;/code&gt; increments that.&lt;/p&gt;

&lt;p&gt;One of the workarounds is to use globally declared variables, with the &lt;code&gt;vars&lt;/code&gt; pragma.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  multirun1.pl
  -----------
  #!/usr/bin/perl -w

  use strict;
  use vars qw($counter);

  for (1..3){
    print &amp;quot;run: [time $_]\n&amp;quot;;
    run();
  }

  sub run {

    $counter = 0;

    increment_counter();
    increment_counter();

    sub increment_counter{
      $counter++;
      print &amp;quot;Counter is equal to $counter !\n&amp;quot;;
    }

  } # end of sub run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you run this and the other solutions offered below, then the expected output will be generated:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % ./multirun1.pl

  run: [time 1]
  Counter is equal to 1 !
  Counter is equal to 2 !
  run: [time 2]
  Counter is equal to 1 !
  Counter is equal to 2 !
  run: [time 3]
  Counter is equal to 1 !
  Counter is equal to 2 !
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By the way, the warning we saw before has gone, and so has the problem, since there is no &lt;code&gt;my()&lt;/code&gt; (lexically defined) variable used in the nested subroutine.&lt;/p&gt;

&lt;p&gt;Another approach is to use fully qualified variables. This is better, since less memory will be used, but it adds a typing overhead:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  multirun2.pl
  -----------
  #!/usr/bin/perl -w

  use strict;

  for (1..3){
    print &amp;quot;run: [time $_]\n&amp;quot;;
    run();
  }

  sub run {

    $main::counter = 0;

    increment_counter();
    increment_counter();

    sub increment_counter{
      $main::counter++;
      print &amp;quot;Counter is equal to $main::counter !\n&amp;quot;;
    }

  } # end of sub run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also pass the variable to the subroutine by value and make the subroutine return it after it was updated. This adds time and memory overheads, so it may not be good idea if the variable can be very large, or if speed of execution is an issue.&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t rely on the fact that the variable is small during the development of the application, it can grow quite big in situations you don&amp;rsquo;t expect. For example, a simple HTML form text entry field can return a few megabytes of data if one of your users is bored and wants to test how good your code is. It&amp;rsquo;s not uncommon to see users copy-and-paste 10Mb core dump files into a form&amp;rsquo;s text fields and then submit it for your script to process.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  multirun3.pl
  -----------
  #!/usr/bin/perl -w

  use strict;

  for (1..3){
    print &amp;quot;run: [time $_]\n&amp;quot;;
    run();
  }

  sub run {

    my $counter = 0;

    $counter = increment_counter($counter);
    $counter = increment_counter($counter);

    sub increment_counter{
      my $counter = shift;

      $counter++;
      print &amp;quot;Counter is equal to $counter !\n&amp;quot;;

      return $counter;
    }

  } # end of sub run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, you can use references to do the job. The version of &lt;code&gt;increment_counter()&lt;/code&gt; below accepts a reference to the &lt;code&gt;$counter&lt;/code&gt; variable and increments its value after first dereferencing it. When you use a reference, the variable you use inside the function is physically the same bit of memory as the one outside the function. This technique is often used to enable a called function to modify variables in a calling function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  multirun4.pl
  -----------
  #!/usr/bin/perl -w

  use strict;

  for (1..3){
    print &amp;quot;run: [time $_]\n&amp;quot;;
    run();
  }

  sub run {

    my $counter = 0;

    increment_counter(\$counter);
    increment_counter(\$counter);

    sub increment_counter{
      my $r_counter = shift;

      $$r_counter++;
      print &amp;quot;Counter is equal to $$r_counter !\n&amp;quot;;
    }

  } # end of sub run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is yet another and more obscure reference usage. We modify the value of &lt;code&gt;$counter&lt;/code&gt; inside the subroutine by using the fact that variables in &lt;code&gt;@_&lt;/code&gt; are aliases for the actual scalar parameters. Thus if you called a function with two arguments, then those would be stored in &lt;code&gt;$_[0]&lt;/code&gt; and &lt;code&gt;$_[1]&lt;/code&gt;. In particular, if an element &lt;code&gt;$_[0]&lt;/code&gt; is updated, then the corresponding argument is updated (or an error occurs if it is not updatable as would be the case of calling the function with a literal, e.g. &lt;em&gt;increment_counter(5)&lt;/em&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  multirun5.pl
  -----------
  #!/usr/bin/perl -w

  use strict;

  for (1..3){
    print &amp;quot;run: [time $_]\n&amp;quot;;
    run();
  }

  sub run {

    my $counter = 0;

    increment_counter($counter);
    increment_counter($counter);

    sub increment_counter{
      $_[0]++;
      print &amp;quot;Counter is equal to $_[0] !\n&amp;quot;;
    }

  } # end of sub run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The approach given above is generally not recommended because most Perl programmers will not expect &lt;code&gt;$counter&lt;/code&gt; to be changed by the function; the example where we used &lt;code&gt;\$counter&lt;/code&gt;, i.e. pass-by-reference would be preferred.&lt;/p&gt;

&lt;p&gt;Here is a solution that avoids the problem entirely by splitting the code into two files: The first is really just a wrapper and loader, the second file contains the heart of the code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  multirun6.pl
  -----------
  #!/usr/bin/perl -w

  use strict;
  require &#39;multirun6-lib.pl&#39; ;

  for (1..3){
    print &amp;quot;run: [time $_]\n&amp;quot;;
    run();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Separate file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  multirun6-lib.pl
  ----------------
  use strict ;

  my $counter;
  sub run {
    $counter = 0;
    increment_counter();
    increment_counter();
  }

  sub increment_counter{
    $counter++;
    print &amp;quot;Counter is equal to $counter !\n&amp;quot;;
  }

  1 ;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you have at least six workarounds to choose from.&lt;/p&gt;

&lt;p&gt;For more information, please refer to perlref and perlsub manpages.&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;Previously in the Series&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/04/23/mod_perl.html&#34;&gt;The Perl You Need To Know&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/04/10/mod_perl.html&#34;&gt;Installing mod_perl without superuser privileges&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/03/22/modperl.html&#34;&gt;mod_perl in 30 minutes&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/02/26/whatismodperl.html&#34;&gt;Why mod_perl?&lt;/a&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;span-id-perldoc-s-rarely-known-but-very-useful-options-perldoc-s-rarely-known-but-very-useful-options-span&#34;&gt;&lt;span id=&#34;perldoc&#39;s rarely known but very useful options&#34;&gt;perldoc&amp;rsquo;s Rarely Known But Very Useful Options&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s a known fact that one cannot become a Perl hacker and especially mod_perl hacker without knowing how to read Perl documentation and search through it. Books are good, but an easily accessible and searchable Perl reference at your fingertips is a great time saver. It always has the up-to-date information for the version of perl you&amp;rsquo;re using.&lt;/p&gt;

&lt;p&gt;Of course, you can use online Perl documentation at the Web: &lt;a href=&#34;https://perldoc.perl.org&#34;&gt;perldoc&lt;/a&gt;. The &lt;code&gt;perldoc&lt;/code&gt; utility provides you with access to the documentation installed on your system. To find out what Perl manpages are available execute:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % perldoc perl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To find what functions perl has, execute:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % perldoc perlfunc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To learn the syntax and to find examples of a specific function, you would execute (e.g. for &lt;code&gt;open()&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % perldoc -f open
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: In perl5.005_03 and earlier, there is a bug in this and the &lt;code&gt;-q&lt;/code&gt; options of &lt;code&gt;perldoc&lt;/code&gt;. It won&amp;rsquo;t call &lt;code&gt;pod2man&lt;/code&gt;, but will display the section in POD format instead. Despite this bug it&amp;rsquo;s still readable and very useful.&lt;/p&gt;

&lt;p&gt;The Perl FAQ (&lt;em&gt;perlfaq&lt;/em&gt; manpage) is in several sections. To search through the sections for &lt;code&gt;open&lt;/code&gt; you would execute:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % perldoc -q open
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will show you all the matching question-and-answer sections, still in POD format.&lt;/p&gt;

&lt;p&gt;To read the &lt;em&gt;perldoc&lt;/em&gt; manpage you would execute:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % perldoc perldoc
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-references-references-span&#34;&gt;&lt;span id=&#34;references&#34;&gt;References&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Online documentation: &lt;a href=&#34;https://perldoc.perl.org&#34;&gt;perldoc&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The book ``&lt;em&gt;Programming Perl&lt;/em&gt;&amp;rdquo; 3rd edition by L.Wall, T. Christiansen and J.Orwant (also known as the ``&lt;em&gt;Camel&lt;/em&gt;&amp;rdquo; book, named after the camel picture on the cover of the book). You want to refer to Chapter 8 that talks about nested subroutines among other things.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;em&gt;perlref&lt;/em&gt; and &lt;em&gt;perlsub&lt;/em&gt; man pages.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>The Perl You Need To Know</title>
      <link>http://localhost:1313/pub/2002/04/23/mod_perl.html/</link>
      <pubDate>Tue, 23 Apr 2002 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2002/04/23/mod_perl.html/</guid>
      <description>

&lt;h3 id=&#34;span-id-introduction-introduction-span&#34;&gt;&lt;span id=&#34;introduction&#34;&gt;Introduction&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Before I delve into the details of mod_perl programming, it&amp;rsquo;s probably a good idea to review some important Perl basics. You will discover these invaluable when you start coding for mod_perl. I will start with pure Perl notes and gradually move to explaining the peculiarities of coding for mod_perl, presenting the traps one might fall into and explaining things obvious for some of us but may be not for the others.&lt;/p&gt;

&lt;h3 id=&#34;span-id-using-global-variables-and-sharing-them-between-modules-packages-using-global-variables-and-sharing-them-between-modules-packages-span&#34;&gt;&lt;span id=&#34;using global variables and sharing them between modules/packages&#34;&gt;Using Global Variables and Sharing Them Between Modules/Packages&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;It helps when you code your application in a structured way, using the perl packages, but as you probably know once you start using packages it&amp;rsquo;s much harder to share the variables between the various packagings. A configuration package comes to mind as a good example of the package that will want its variables to be accessible from the other modules.&lt;/p&gt;

&lt;p&gt;Of course, using the Object Oriented (OO) programming is the best way to provide an access to variables through the access methods. But if you are not yet ready for OO techniques, then you can still benefit from using the techniques I&amp;rsquo;m going to talk about.&lt;/p&gt;

&lt;h3 id=&#34;span-id-making-variables-global-making-variables-global-span&#34;&gt;&lt;span id=&#34;making variables global&#34;&gt;Making Variables Global&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;When you first wrote &lt;code&gt;$x&lt;/code&gt; in your code, you created a (package) global variable. It is visible everywhere in your program, although if used in a package other than the package in which it was declared (&lt;code&gt;main::&lt;/code&gt; by default), then it must be referred to with its fully qualified name, unless you have imported this variable with import(). This will work only if you do not use &lt;code&gt;strict&lt;/code&gt; pragma; but it&amp;rsquo;s important to use this pragma if you want to run your scripts under mod_perl.&lt;/p&gt;

&lt;h3 id=&#34;span-id-making-variables-global-with-strict-pragma-on-making-variables-global-with-strict-pragma-on-span&#34;&gt;&lt;span id=&#34;making variables global with strict pragma on&#34;&gt;Making Variables Global With strict Pragma On&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;First you use :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use strict;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then you use:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; use vars qw($scalar %hash @array);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This declares the named variables as package globals in the current package. They may be referred to within the same file and package with their unqualified names; and in different files/packages with their fully qualified names.&lt;/p&gt;

&lt;p&gt;With perl5.6 you can use the &lt;code&gt;our&lt;/code&gt; operator instead:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  our ($scalar, %hash, @array);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to share package global variables between packages, then here is what you can do.&lt;/p&gt;

&lt;h3 id=&#34;span-id-using-exporter-pm-to-share-global-variables-using-exporter-pm-to-share-global-variables-span&#34;&gt;&lt;span id=&#34;using exporter.pm to share global variables&#34;&gt;Using Exporter.pm to Share Global Variables&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Assume that you want to share the &lt;code&gt;CGI.pm&lt;/code&gt; object (I will use &lt;code&gt;$q&lt;/code&gt;) between your modules. For example, you create it in &lt;code&gt;script.pl&lt;/code&gt;, but you want it to be visible in &lt;code&gt;My::HTML&lt;/code&gt;. First, you make &lt;code&gt;$q&lt;/code&gt; global.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  script.pl:
  ----------------
  use vars qw($q);
  use CGI;
  use lib qw(.); 
  use My::HTML qw($q); # My/HTML.pm is in the same dir as script.pl
  $q = CGI-&amp;gt;new;
  My::HTML::printmyheader();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that I have imported &lt;code&gt;$q&lt;/code&gt; from &lt;code&gt;My::HTML&lt;/code&gt;. And &lt;code&gt;My::HTML&lt;/code&gt; does the export of &lt;code&gt;$q&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  My/HTML.pm
  ----------------
  package My::HTML;
  use strict;

  BEGIN {
    use Exporter ();

    @My::HTML::ISA         = qw(Exporter);
    @My::HTML::EXPORT      = qw();
    @My::HTML::EXPORT_OK   = qw($q);

  }
  use vars qw($q);
  sub printmyheader{
    # Whatever you want to do with $q... e.g.
    print $q-&amp;gt;header();
  }
  1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So the &lt;code&gt;$q&lt;/code&gt; is shared between the &lt;code&gt;My::HTML&lt;/code&gt; package and &lt;code&gt;script.pl&lt;/code&gt;. It will work vice versa as well, if you create the object in &lt;code&gt;My::HTML&lt;/code&gt; but use it in &lt;code&gt;script.pl&lt;/code&gt;. You have true sharing, since if you change &lt;code&gt;$q&lt;/code&gt; in &lt;code&gt;script.pl&lt;/code&gt;, then it will be changed in &lt;code&gt;My::HTML&lt;/code&gt; as well.&lt;/p&gt;

&lt;p&gt;What if you need to share &lt;code&gt;$q&lt;/code&gt; between more than two packages? For example you want My::Doc to share &lt;code&gt;$q&lt;/code&gt; as well.&lt;/p&gt;

&lt;p&gt;You leave &lt;code&gt;My::HTML&lt;/code&gt; untouched, and modify &lt;em&gt;script.pl&lt;/em&gt; to include:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; use My::Doc qw($q);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then you add the same &lt;code&gt;Exporter&lt;/code&gt; code that I used in &lt;code&gt;My::HTML&lt;/code&gt;, into &lt;code&gt;My::Doc&lt;/code&gt;, so that it also exports &lt;code&gt;$q&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;One possible pitfall is when you want to use &lt;code&gt;My::Doc&lt;/code&gt; in both &lt;code&gt;My::HTML&lt;/code&gt; and &lt;em&gt;script.pl&lt;/em&gt;. Only if you add&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use My::Doc qw($q);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;into &lt;code&gt;My::HTML&lt;/code&gt; will &lt;code&gt;$q&lt;/code&gt; be shared. Otherwise &lt;code&gt;My::Doc&lt;/code&gt; will not share &lt;code&gt;$q&lt;/code&gt; any more. To make things clear here is the code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  script.pl:
  ----------------
  use vars qw($q);
  use CGI;
  use lib qw(.); 
  use My::HTML qw($q); # My/HTML.pm is in the same dir as script.pl
  use My::Doc  qw($q); # Ditto
  $q = new CGI;

  My::HTML::printmyheader();  

  My/HTML.pm
  ----------------
  package My::HTML;
  use strict;

  BEGIN {
    use Exporter ();
    @My::HTML::ISA         = qw(Exporter);
    @My::HTML::EXPORT      = qw();
    @My::HTML::EXPORT_OK   = qw($q);
  }
  use vars     qw($q);
  use My::Doc  qw($q);
  sub printmyheader{
    # Whatever you want to do with $q... e.g.
    print $q-&amp;gt;header();
    My::Doc::printtitle(&#39;Guide&#39;);
  }
  1;  

  My/Doc.pm
  ----------------
  package My::Doc;
  use strict;

  BEGIN {
    use Exporter ();
    @My::Doc::ISA         = qw(Exporter);
    @My::Doc::EXPORT      = qw();
    @My::Doc::EXPORT_OK   = qw($q);
  }
  use vars qw($q);
  sub printtitle{
    my $title = shift || &#39;None&#39;;
    print $q-&amp;gt;h1($title);
  }
  1;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-using-the-perl-aliasing-feature-to-share-global-variables-using-the-perl-aliasing-feature-to-share-global-variables-span&#34;&gt;&lt;span id=&#34;using the perl aliasing feature to share global variables&#34;&gt;Using the Perl Aliasing Feature to Share Global Variables&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;As the title says, you can import a variable into a script or module without using &lt;code&gt;Exporter.pm&lt;/code&gt;. I have found it useful to keep all the configuration variables in one module &lt;code&gt;My::Config&lt;/code&gt;. But then I have to export all the variables in order to use them in other modules, which is bad for two reasons: polluting other packages&amp;rsquo; name spaces with extra tags which increases the memory requirements; and adding the overhead of keeping track of what variables should be exported from the configuration module and what imported, for some particular package. I solve this problem by keeping all the variables in one hash &lt;code&gt;%c&lt;/code&gt; and exporting that. Here is an example of &lt;code&gt;My::Config&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  package My::Config;
  use strict;
  use vars qw(%c);
  %c = (
    # All the configs go here
    scalar_var =&amp;gt; 5,

    array_var  =&amp;gt; [qw(foo bar)],
    hash_var   =&amp;gt; {
                   foo =&amp;gt; &#39;Foo&#39;,
                   bar =&amp;gt; &#39;BARRR&#39;,
                  },
  );
  1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now in packages that want to use the configuration variables I have either to use the fully qualified names such as &lt;code&gt;$My::Config::test&lt;/code&gt;, which I dislike, or import them as described in the previous section. But hey, since I have only one variable to handle, I can make things even simpler and save the loading of the &lt;code&gt;Exporter.pm&lt;/code&gt; package. I will use the Perl aliasing feature for exporting and saving the keystrokes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  package My::HTML;
  use strict;
  use lib qw(.);
    # Global Configuration now aliased to global %c
  use My::Config (); # My/Config.pm in the same dir as script.pl
  use vars qw(%c);
  *c = \%My::Config::c;

    # Now you can access the variables from the My::Config
  print $c{scalar_var};
  print $c{array_var}[0];
  print $c{hash_var}{foo};
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;

&lt;a href=&#34;http://conferences.oreilly.com/oscon/&#34;&gt;O&amp;#39;Reilly Open Source Convention -- July 22-26, San Diego, CA.&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;From the Frontiers of Research to the Heart of the Enterprise&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://conferences.oreillynet.com/cs/os2002/view/e_sess/3032&#34;&gt;mod_perl 2.0, the Next Generation&lt;/a&gt; Stas Bekman will provide an overview of what&#39;s new in mod_perl 2.0 and what else is planned for the future in his talk at the upcoming &lt;a href=&#34;http://conferences.oreillynet.com/os2002/&#34;&gt;O&#39;Reilly Open Source Convention&lt;/a&gt;, this July 22-26, in San Diego.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Of course, $c is global when you use it as described above, and if you change it, then it will affect any other packages you have aliased &lt;code&gt;$My::Config::c&lt;/code&gt; to.&lt;/p&gt;

&lt;p&gt;Note that aliases work either with global or &lt;code&gt;local()&lt;/code&gt; vars - you cannot write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my *c = \%My::Config::c; # ERROR!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which is an error. But you can write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  local *c = \%My::Config::c;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For more information about aliasing, refer to the Camel book, second edition, pages 51-52.&lt;/p&gt;

&lt;h3 id=&#34;span-id-using-nonhardcoded-configuration-module-names-using-non-hardcoded-configuration-module-names-span&#34;&gt;&lt;span id=&#34;using nonhardcoded configuration module names&#34;&gt;Using Non-Hardcoded Configuration Module Names&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;You have just seen how to use a configuration module for configuration centralization and an easy access to the information stored in this module. However, there is somewhat of a chicken-and-egg problem: how to let your other modules know the name of this file? Hardcoding the name is brittle &amp;ndash; if you have only a single project, then it should be fine. If you have more projects that use different configurations and you will want to reuse their code, then you will have to find all instances of the hardcoded name and replace it.&lt;/p&gt;

&lt;p&gt;Another solution could be to have the same name for a configuration module, like &lt;code&gt;My::Config&lt;/code&gt; but putting a different copy of it into different locations. But this won&amp;rsquo;t work under mod_perl because of the namespace collision. You cannot load different modules that use the same name; only the first one will be loaded.&lt;/p&gt;

&lt;p&gt;Luckily, there is another solution that allows us to be flexible. &lt;code&gt;PerlSetVar&lt;/code&gt; comes to rescue. Just like with environment variables, you can set server&amp;rsquo;s global Perl variables that can be retrieved from any module and script. Those statements are placed into the &lt;em&gt;httpd.conf&lt;/em&gt; file. For example&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  PerlSetVar FooBaseDir       /home/httpd/foo
  PerlSetVar FooConfigModule  Foo::Config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I &lt;code&gt;require()&lt;/code&gt; the file where the above configuration will be used.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  PerlRequire /home/httpd/perl/startup.pl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the &lt;em&gt;startup.pl&lt;/em&gt; I might have the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # retrieve the configuration module path
  use Apache:
  my $s             = Apache-&amp;gt;server;
  my $base_dir      = $s-&amp;gt;dir_config(&#39;FooBaseDir&#39;)      || &#39;&#39;;
  my $config_module = $s-&amp;gt;dir_config(&#39;FooConfigModule&#39;) || &#39;&#39;;
  die &amp;quot;FooBaseDir and FooConfigModule aren&#39;t set in httpd.conf&amp;quot; 
    unless $base_dir and $config_module;

    # build the real path to the config module
  my $path = &amp;quot;$base_dir/$config_module&amp;quot;;
  $path =~ s|::|/|;
  $path .= &amp;quot;.pm&amp;quot;;
    # I have something like &amp;quot;/home/httpd/foo/Foo/Config.pm&amp;quot;
    # now I can pull in the configuration module
  require $path;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I know the module name and it&amp;rsquo;s loaded, so for example if I need to use some variables stored in this module to open a database connection, then I will do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Apache::DBI-&amp;gt;connect_on_init
  (&amp;quot;DBI:mysql:${$config_module.&#39;::DB_NAME&#39;}::${$config_module.&#39;::SERVER&#39;}&amp;quot;,
   ${$config_module.&#39;::USER&#39;},
   ${$config_module.&#39;::USER_PASSWD&#39;},
   {
    PrintError =&amp;gt; 1, # warn() on errors
    RaiseError =&amp;gt; 0, # don&#39;t die on error
    AutoCommit =&amp;gt; 1, # commit executes immediately
   }
  );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where variable like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ${$config_module.&#39;::USER&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In my example are really:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $Foo::Config::USER
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to access these variable from within your code at the run time, instead accessing to the server object &lt;code&gt;$c&lt;/code&gt;, then use the request object &lt;code&gt;$r&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my $r = shift;
  my $base_dir      = $r-&amp;gt;dir_config(&#39;FooBaseDir&#39;)      || &#39;&#39;;
  my $config_module = $r-&amp;gt;dir_config(&#39;FooConfigModule&#39;) || &#39;&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-the-scope-of-the-special-perl-variables-the-scope-of-the-special-perl-variables-span&#34;&gt;&lt;span id=&#34;the scope of the special perl variables&#34;&gt;The Scope of the Special Perl Variables&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Now let&amp;rsquo;s talk about Special Perl Variables.&lt;/p&gt;

&lt;p&gt;Special Perl variables like &lt;code&gt;$|&lt;/code&gt; (buffering), &lt;code&gt;$^T&lt;/code&gt; (script&amp;rsquo;s start time), &lt;code&gt;$^W&lt;/code&gt; (warnings mode), &lt;code&gt;$/&lt;/code&gt; (input record separator), &lt;code&gt;$\&lt;/code&gt; (output record separator) and many more are all true global variables; they do not belong to any particular package (not even &lt;code&gt;main::&lt;/code&gt;) and are universally available. This means that if you change them, then you change them anywhere across the entire program; furthermore you cannot scope them with my(). However, you can local()ize them, which means that any changes you apply will only last until the end of the enclosing scope. In the mod_perl situation where the child server doesn&amp;rsquo;t usually exit, if in one of your scripts you modify a global variable, then it will be changed for the rest of the process&amp;rsquo; life and will affect all the scripts executed by the same process. Therefore, localizing these variables is highly recommended; I&amp;rsquo;d say even mandatory.&lt;/p&gt;

&lt;p&gt;I will demonstrate the case on the input record separator variable. If you undefine this variable, then the diamond operator (readline) will suck in the whole file at once if you have enough memory. Remembering this you should never write code like the example below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $/ = undef; # BAD!
  open IN, &amp;quot;file&amp;quot; ....
    # slurp it all into a variable
  $all_the_file = &amp;lt;IN&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The proper way is to have a &lt;code&gt;local()&lt;/code&gt; keyword before the special variable is changed, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  local $/ = undef; 
  open IN, &amp;quot;file&amp;quot; ....
    # slurp it all inside a variable
  $all_the_file = &amp;lt;IN&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But there is a catch. &lt;code&gt;local()&lt;/code&gt; will propagate the changed value to the code below it. The modified value will be in effect until the script terminates, unless it is changed again somewhere else in the script.&lt;/p&gt;

&lt;p&gt;A cleaner approach is to enclose the whole of the code that is affected by the modified variable in a block, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  {
    local $/ = undef; 
    open IN, &amp;quot;file&amp;quot; ....
      # slurp it all inside a variable
    $all_the_file = &amp;lt;IN&amp;gt;;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That way when Perl leaves the block it restores the original value of the &lt;code&gt;$/&lt;/code&gt; variable, and you don&amp;rsquo;t need to worry elsewhere in your program about its value being changed here.&lt;/p&gt;

&lt;p&gt;Note that if you call a subroutine after you&amp;rsquo;ve set a global variable but within the enclosing block, the global variable will be visible with its new value inside the subroutine.&lt;/p&gt;

&lt;h3 id=&#34;span-id-compiled-regular-expressions-compiled-regular-expressions-span&#34;&gt;&lt;span id=&#34;compiled regular expressions&#34;&gt;Compiled Regular Expressions&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;And finally I want to cover the pitfall many people have fallen into. Let&amp;rsquo;s talk about regular expressions use under mod_perl.&lt;/p&gt;

&lt;p&gt;When using a regular expression that contains an interpolated Perl variable, if it is known that the variable (or variables) will not change during the execution of the program, a standard optimization technique is to add the &lt;code&gt;/o&lt;/code&gt; modifier to the regex pattern. This directs the compiler to build the internal table once, for the entire lifetime of the script, rather than each time the pattern is executed. Consider:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my $pat = &#39;^foo$&#39;; # likely to be input from an HTML form field
  foreach( @list ) {
    print if /$pat/o;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;Previously in the Series&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/04/10/mod_perl.html&#34;&gt;Installing mod_perl without superuser privileges&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/03/22/modperl.html&#34;&gt;mod_perl in 30 minutes&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/02/26/whatismodperl.html&#34;&gt;Why mod_perl?&lt;/a&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;This is usually a big win in loops over lists, or when using the &lt;code&gt;grep()&lt;/code&gt; or &lt;code&gt;map()&lt;/code&gt; operators.&lt;/p&gt;

&lt;p&gt;In long-lived mod_perl scripts, however, the variable may change with each invocation and this can pose a problem. The first invocation of a fresh httpd child will compile the regex and perform the search correctly. However, all subsequent uses by that child will continue to match the original pattern, regardless of the current contents of the Perl variables the pattern is supposed to depend on. Your script will appear to be broken.&lt;/p&gt;

&lt;p&gt;There are two solutions to this problem:&lt;/p&gt;

&lt;p&gt;The first is to use &lt;code&gt;eval q//&lt;/code&gt;, to force the code to be evaluated each time. Just make sure that the eval block covers the entire loop of processing, and not just the pattern match itself.&lt;/p&gt;

&lt;p&gt;The above code fragment would be rewritten as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my $pat = &#39;^foo$&#39;;
  eval q{
    foreach( @list ) {
      print if /$pat/o;
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just saying:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  foreach( @list ) {
    eval q{ print if /$pat/o; };
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;means that I recompile the regex for every element in the list, even though the regex doesn&amp;rsquo;t change.&lt;/p&gt;

&lt;p&gt;You can use this approach if you require more than one pattern match operator in a given section of code. If the section contains only one operator (be it an &lt;code&gt;m//&lt;/code&gt; or &lt;code&gt;s///&lt;/code&gt;), then you can rely on the property of the null pattern, that reuses the last pattern seen. This leads to the second solution, which also eliminates the use of eval.&lt;/p&gt;

&lt;p&gt;The above code fragment becomes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my $pat = &#39;^foo$&#39;;
  &amp;quot;something&amp;quot; =~ /$pat/; # dummy match (MUST NOT FAIL!)
  foreach( @list ) {
    print if //;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only gotcha is that the dummy match that boots the regular expression engine must absolutely, positively succeed, otherwise the pattern will not be cached, and the &lt;code&gt;//&lt;/code&gt; will match everything. If you can&amp;rsquo;t count on fixed text to ensure the match succeeds, then you have two possibilities.&lt;/p&gt;

&lt;p&gt;If you can guarantee that the pattern variable contains no meta-characters (things like *, +, ^, $&amp;hellip;), then you can use the dummy match:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $pat =~ /\Q$pat\E/; # guaranteed if no meta-characters present
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If there is a possibility that the pattern can contain meta-characters, then you should search for the pattern or the nonsearchable \377 character as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;quot;\377&amp;quot; =~ /$pat|^\377$/; # guaranteed if meta-characters present
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another approach:&lt;/p&gt;

&lt;p&gt;It depends on the complexity of the regex to which you apply this technique. One common usage where a compiled regex is usually more efficient is to &amp;ldquo;&lt;em&gt;match any one of a group of patterns&lt;/em&gt;&amp;rdquo; over and over again.&lt;/p&gt;

&lt;p&gt;Maybe with a helper routine, it&amp;rsquo;s easier to remember. Here is one slightly modified from Jeffery Friedl&amp;rsquo;s example in his book &amp;ldquo;&lt;em&gt;Mastering Regular Expressions&lt;/em&gt;&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #####################################################
  # Build_MatchMany_Function
  # -- Input:  list of patterns
  # -- Output: A code ref which matches its $_[0]
  #            against ANY of the patterns given in the
  #            &amp;quot;Input&amp;quot;, efficiently.
  #
  sub Build_MatchMany_Function {
    my @R = @_;
    my $expr = join &#39;||&#39;, map { &amp;quot;\$_[0] =~ m/\$R[$_]/o&amp;quot; } ( 0..$#R );
    my $matchsub = eval &amp;quot;sub { $expr }&amp;quot;;
    die &amp;quot;Failed in building regex @R: $@&amp;quot; if $@;
    $matchsub;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example usage:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  @some_browsers = qw(Mozilla Lynx MSIE AmigaVoyager lwp libwww);
  $Known_Browser=Build_MatchMany_Function(@some_browsers);

  while (&amp;lt;ACCESS_LOG&amp;gt;) {
    # ...
    $browser = get_browser_field($_);
    if ( ! &amp;amp;$Known_Browser($browser) ) {
      print STDERR &amp;quot;Unknown Browser: $browser\n&amp;quot;;
    }
    # ...
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the next article, I&amp;rsquo;ll present a few other Perl basics directly related to the mod_perl programming.&lt;/p&gt;

&lt;h3 id=&#34;span-id-references-references-span&#34;&gt;&lt;span id=&#34;references&#34;&gt;References&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The book &amp;ldquo;&lt;em&gt;&lt;a href=&#34;http://www.oreilly.com/catalog/regex/&#34;&gt;Mastering Regular Expressions&lt;/a&gt;&lt;/em&gt;&amp;rdquo; by Jeffrey E. Friedl.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The book &amp;ldquo;&lt;em&gt;&lt;a href=&#34;http://www.oreilly.com/catalog/lperl3/&#34;&gt;Learning Perl&lt;/a&gt;&lt;/em&gt;&amp;rdquo; by Randal L. Schwartz (also known as the &amp;ldquo;&lt;em&gt;Llama&lt;/em&gt;&amp;rdquo; book, named after the llama picture on the cover of the book).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The book &amp;ldquo;&lt;em&gt;&lt;a href=&#34;http://www.oreilly.com/catalog/pperl3/&#34;&gt;Programming Perl&lt;/a&gt;&lt;/em&gt;&amp;rdquo; by L.Wall, T. Christiansen and J.Orwant (also known as the &amp;ldquo;&lt;em&gt;Camel&lt;/em&gt;&amp;rdquo; book, named after the camel picture on the cover of the book).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;em&gt;Exporter&lt;/em&gt;, &lt;em&gt;perlre&lt;/em&gt;, &lt;em&gt;perlvar&lt;/em&gt;, &lt;em&gt;perlmod&lt;/em&gt; and &lt;em&gt;perlmodlib&lt;/em&gt; man pages.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Installing mod_perl without superuser privileges</title>
      <link>http://localhost:1313/pub/2002/04/10/mod_perl.html/</link>
      <pubDate>Wed, 10 Apr 2002 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2002/04/10/mod_perl.html/</guid>
      <description>

&lt;p&gt;As you have seen from my previous articles, mod_perl enabled Apache consists of two main components: Perl modules and Apache itself. While installing Apache without root privileges is easy, one should know how to install Perl modules in a nonsystem-wide location. In this article, I&amp;rsquo;ll demonstrate ways to complete this task.&lt;/p&gt;

&lt;p&gt;In the examples, I&amp;rsquo;ll use &lt;em&gt;stas&lt;/em&gt; as a username, and &lt;em&gt;/home/stas&lt;/em&gt; as the home directory for that user.&lt;/p&gt;

&lt;h3 id=&#34;span-id-installing-perl-modules-into-a-directory-of-choice-installing-perl-modules-into-a-directory-of-choice-span&#34;&gt;&lt;span id=&#34;installing perl modules into a directory of choice&#34;&gt;Installing Perl Modules Into a Directory of Choice&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Since without superuser permissions you aren&amp;rsquo;t allowed to install modules into system directories such as &lt;em&gt;/usr/lib/perl5&lt;/em&gt;, you need to find out how to install the modules under your home directory. It&amp;rsquo;s easy.&lt;/p&gt;

&lt;p&gt;First, you have to decide where to install the modules. The simplest approach is to simulate the portion of the &lt;em&gt;/&lt;/em&gt; file system relevant to Perl under your home directory. Actually we need only two directories:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  /home/stas/bin
  /home/stas/lib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We don&amp;rsquo;t have to create them, since that will be done automatically when the first module is installed. Ninety-nine percent of the files will go into the &lt;em&gt;lib&lt;/em&gt; directory. Occasionally, when some module distribution comes with Perl scripts, these will go into the &lt;em&gt;bin&lt;/em&gt; directory. This directory will be created if it doesn&amp;rsquo;t exist.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s install the &lt;em&gt;CGI.pm&lt;/em&gt; package, which includes a few other &lt;code&gt;CGI::*&lt;/code&gt; modules. As usual, download the package from the CPAN repository, unpack it and &lt;code&gt;chdir&lt;/code&gt; to the newly created directory.&lt;/p&gt;

&lt;p&gt;Now do a standard &lt;code&gt;perl Makefile.PL&lt;/code&gt; to prepare a &lt;em&gt;Makefile&lt;/em&gt;, but this time tell &lt;code&gt;MakeMaker&lt;/code&gt; to use your Perl installation directories instead of the defaults.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % perl Makefile.PL PREFIX=/home/stas
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;PREFIX=/home/stas&lt;/code&gt; is the only part of the installation process that is different from usual. Note that if you don&amp;rsquo;t like how &lt;code&gt;MakeMaker&lt;/code&gt; chooses the rest of the directories, or if you are using an older version that requires an explicit declaration of all the target directories, then do this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % perl Makefile.PL PREFIX=/home/stas \
    INSTALLPRIVLIB=/home/stas/lib/perl5 \
    INSTALLSCRIPT=/home/stas/bin \
    INSTALLSITELIB=/home/stas/lib/perl5/site_perl \
    INSTALLBIN=/home/stas/bin \
    INSTALLMAN1DIR=/home/stas/lib/perl5/man  \
    INSTALLMAN3DIR=/home/stas/lib/perl5/man3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The rest is as usual:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % make
  % make test
  % make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;make install&lt;/code&gt; installs all the files in the private repository. Note that all the missing directories are created automatically, so there is no need to create them. Here (slightly edited) is what it does :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Installing /home/stas/lib/perl5/CGI/Cookie.pm
  Installing /home/stas/lib/perl5/CGI.pm
  Installing /home/stas/lib/perl5/man3/CGI.3
  Installing /home/stas/lib/perl5/man3/CGI::Cookie.3
  Writing /home/stas/lib/perl5/auto/CGI/.packlist
  Appending installation info to /home/stas/lib/perl5/perllocal.pod
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you have to use the explicit target parameters, then instead of a single &lt;code&gt;PREFIX&lt;/code&gt; parameter, you will find it useful to create a file called, for example, &lt;em&gt;~/.perl_dirs&lt;/em&gt; (where &lt;em&gt;~&lt;/em&gt; is &lt;code&gt;/home/stas&lt;/code&gt; in our example) containing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    PREFIX=/home/stas \
    INSTALLPRIVLIB=/home/stas/lib/perl5 \
    INSTALLSCRIPT=/home/stas/bin \
    INSTALLSITELIB=/home/stas/lib/perl5/site_perl \
    INSTALLBIN=/home/stas/bin \
    INSTALLMAN1DIR=/home/stas/lib/perl5/man  \
    INSTALLMAN3DIR=/home/stas/lib/perl5/man3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From now on, any time you want to install Perl modules locally, you simply execute:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % perl Makefile.PL `cat ~/.perl_dirs`
  % make
  % make test
  % make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using this method, you can easily maintain several Perl module repositories. For example, you could have one for production Perl and another for development:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % perl Makefile.PL `cat ~/.perl_dirs.production`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % perl Makefile.PL `cat ~/.perl_dirs.develop`
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-making-your-scripts-find-the-locally-installed-modules-making-your-scripts-find-the-locally-installed-modules-span&#34;&gt;&lt;span id=&#34;making your scripts find the locally installed modules&#34;&gt;Making Your Scripts Find the Locally Installed Modules&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Perl modules are generally placed in four main directories. To find these directories, execute:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % perl -V
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output contains important information about your Perl installation. At the end you will see:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Characteristics of this binary (from libperl):
  Built under linux
  Compiled at Apr  6 1999 23:34:07
  @INC:
    /usr/lib/perl5/5.00503/i386-linux
    /usr/lib/perl5/5.00503
    /usr/lib/perl5/site_perl/5.005/i386-linux
    /usr/lib/perl5/site_perl/5.005
    .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It shows us the content of the Perl special variable &lt;code&gt;@INC&lt;/code&gt;, which is used by Perl to look for its modules. It is equivalent to the &lt;code&gt;PATH&lt;/code&gt; environment variable in Unix shells that is used to find executable programs.&lt;/p&gt;

&lt;p&gt;Notice that Perl looks for modules in the &lt;em&gt;.&lt;/em&gt; directory too, which stands for the current directory. It&amp;rsquo;s the last entry in the above output.&lt;/p&gt;

&lt;p&gt;Of course, this example is from version &lt;em&gt;5.00503&lt;/em&gt; of Perl installed on my x86 architecture PC running Linux. That&amp;rsquo;s why you see &lt;em&gt;i386-linux&lt;/em&gt; and &lt;em&gt;5.00503&lt;/em&gt;. If your system runs a different version of Perl, operating system, processor or chipset architecture, then some of the directories will have different names.&lt;/p&gt;

&lt;p&gt;I also have a perl-5.6.1 installed under &lt;code&gt;/usr/local/lib/&lt;/code&gt; so when I do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % /usr/local/bin/perl5.6.1 -V
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I see:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  @INC:
    /usr/local/lib/perl5/5.6.1/i586-linux
    /usr/local/lib/perl5/5.6.1
    /usr/local/lib/site_perl/5.6.1/i586-linux
    /usr/local/lib/site_perl
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;Previously in the Series&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/03/22/modperl.html&#34;&gt;mod_perl in 30 minutes&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/02/26/whatismodperl.html&#34;&gt;Why mod_perl?&lt;/a&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Note that it&amp;rsquo;s still &lt;em&gt;Linux&lt;/em&gt;, but the newer Perl version uses the version of my Pentium processor (thus the &lt;em&gt;i586&lt;/em&gt; and not &lt;em&gt;i386&lt;/em&gt;). This makes use of compiler optimizations for Pentium processors when the binary Perl extensions are created.&lt;/p&gt;

&lt;p&gt;All the platform specific files, such as compiled C files glued to Perl with &lt;code&gt;XS&lt;/code&gt; or &lt;code&gt;SWIG&lt;/code&gt;, are supposed to go into the &lt;code&gt;i386-linux&lt;/code&gt;-like directories.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Important:&lt;/strong&gt; As we have installed the Perl modules into nonstandard directories, we have to let Perl know where to look for the four directories. There are two ways to accomplish this: You can set the &lt;code&gt;PERL5LIB&lt;/code&gt; environment variable or you can modify the &lt;code&gt;@INC&lt;/code&gt; variable in your scripts.&lt;/p&gt;

&lt;p&gt;Assuming that we use perl-5.00503, in our example the directories are:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /home/sbekman/lib/perl5/5.00503/i386-linux
    /home/sbekman/lib/perl5/5.00503
    /home/sbekman/lib/perl5/site_perl/5.005/i386-linux
    /home/sbekman/lib/perl5/site_perl/5.005
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As mentioned before, you find the exact directories by executing &lt;code&gt;perl -V&lt;/code&gt; and replacing the global Perl installation&amp;rsquo;s base directory with your home directory.&lt;/p&gt;

&lt;p&gt;Modifying &lt;code&gt;@INC&lt;/code&gt; is quite easy. The best approach is to use the &lt;code&gt;lib&lt;/code&gt; module (pragma), by adding the following snippet at the top of any of your scripts that require the locally installed modules.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use lib qw(/home/stas/lib/perl5/5.00503/
             /home/stas/lib/perl5/site_perl/5.005);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another way is to write code to modify &lt;code&gt;@INC&lt;/code&gt; explicitly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  BEGIN {
    unshift @INC,
      qw(/home/stas/lib/perl5/5.00503
         /home/stas/lib/perl5/5.00503/i386-linux
         /home/stas/lib/perl5/site_perl/5.005
         /home/stas/lib/perl5/site_perl/5.005/i386-linux);
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that with the &lt;code&gt;lib&lt;/code&gt; module we don&amp;rsquo;t have to list the corresponding architecture specific directories, since it adds them automatically if they exist (to be exact, when &lt;em&gt;$dir/$archname/auto&lt;/em&gt; exists).&lt;/p&gt;

&lt;p&gt;Also, notice that both approaches &lt;em&gt;prepend&lt;/em&gt; the directories to be searched to &lt;code&gt;@INC&lt;/code&gt;. This allows you to install a more recent module into your local repository and Perl will use it instead of the older one installed in the main system repository.&lt;/p&gt;

&lt;p&gt;Both approaches modify the value of &lt;code&gt;@INC&lt;/code&gt; at compilation time. The &lt;code&gt;lib&lt;/code&gt; module uses the &lt;em&gt;BEGIN&lt;/em&gt; block as well, but internally.&lt;/p&gt;

&lt;p&gt;Now, let&amp;rsquo;s assume the following scenario. I have installed the &lt;code&gt;LWP&lt;/code&gt; package in my local repository. Now I want to install another module (e.g. mod_perl) that has &lt;code&gt;LWP&lt;/code&gt; listed in its prerequisites list. I know that I have &lt;code&gt;LWP&lt;/code&gt; installed, but when I run &lt;code&gt;perl Makefile.PL&lt;/code&gt; for the module I&amp;rsquo;m about to install I&amp;rsquo;m told that I don&amp;rsquo;t have &lt;code&gt;LWP&lt;/code&gt; installed.&lt;/p&gt;

&lt;p&gt;There is no way for Perl to know that we have some locally installed modules. All it does is search the directories listed in &lt;code&gt;@INC&lt;/code&gt;, and since the latter contains only the default four directories (plus the &lt;em&gt;.&lt;/em&gt; directory), it cannot find the locally installed &lt;code&gt;LWP&lt;/code&gt; package. We cannot solve this problem by adding code to modify &lt;code&gt;@INC&lt;/code&gt;, but changing the &lt;code&gt;PERL5LIB&lt;/code&gt; environment variable will do the trick. If you are using &lt;code&gt;t?csh&lt;/code&gt; for interactive work, then do this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  setenv PERL5LIB /home/stas/lib/perl5/5.00503:
  /home/stas/lib/perl5/site_perl/5.005
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It should be a single line with directories separated by colons (&lt;code&gt;:&lt;/code&gt;) and no spaces. If you are a &lt;code&gt;(ba)?sh&lt;/code&gt; user, then do this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  export PERL5LIB=/home/stas/lib/perl5/5.00503:
  /home/stas/lib/perl5/site_perl/5.005
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, make it a single line. If you use bash, then you can use multi-line commands by terminating split lines with a backslash (&lt;code&gt;\&lt;/code&gt;), like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  export PERL5LIB=/home/stas/lib/perl5/5.00503:\
  /home/stas/lib/perl5/site_perl/5.005
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As with &lt;code&gt;use lib&lt;/code&gt;, Perl automatically prepends the architecture specific directories to &lt;code&gt;@INC&lt;/code&gt; if those exist.&lt;/p&gt;

&lt;p&gt;When you have done this, verify the value of the newly configured &lt;code&gt;@INC&lt;/code&gt; by executing &lt;code&gt;perl -V&lt;/code&gt; as before. You should see the modified value of &lt;code&gt;@INC&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % perl -V

  Characteristics of this binary (from libperl): 
  Built under linux
  Compiled at Apr  6 1999 23:34:07
  %ENV:
    PERL5LIB=&amp;quot;/home/stas/lib/perl5/5.00503:
    /home/stas/lib/perl5/site_perl/5.005&amp;quot;
  @INC:
    /home/stas/lib/perl5/5.00503/i386-linux
    /home/stas/lib/perl5/5.00503
    /home/stas/lib/perl5/site_perl/5.005/i386-linux
    /home/stas/lib/perl5/site_perl/5.005
    /usr/lib/perl5/5.00503/i386-linux
    /usr/lib/perl5/5.00503
    /usr/lib/perl5/site_perl/5.005/i386-linux
    /usr/lib/perl5/site_perl/5.005
    .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When everything works as you want it to, add these commands to your &lt;em&gt;.tcshrc&lt;/em&gt; or &lt;em&gt;.bashrc&lt;/em&gt; file. The next time you start a shell, the environment will be ready for you to work with the new Perl.&lt;/p&gt;

&lt;p&gt;Note that if you have a &lt;code&gt;PERL5LIB&lt;/code&gt; setting, then you don&amp;rsquo;t need to alter the &lt;code&gt;@INC&lt;/code&gt; value in your scripts. But if, for example, someone else (who doesn&amp;rsquo;t have this setting in the shell) tries to execute your scripts, then Perl will fail to find your locally installed modules. The best example is a crontab script that &lt;em&gt;might&lt;/em&gt; use a different SHELL environment and, therefore, the &lt;code&gt;PERL5LIB&lt;/code&gt; setting won&amp;rsquo;t be available to it.&lt;/p&gt;

&lt;p&gt;So the best approach is to have both the &lt;code&gt;PERL5LIB&lt;/code&gt; environment variable and the explicit &lt;code&gt;@INC&lt;/code&gt; extension code at the beginning of the scripts as described above.&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-cpan-pm-shell-and-locally-installed-modules-the-cpan-pm-shell-and-locally-installed-modules-span&#34;&gt;&lt;span id=&#34;the cpan.pm shell and locally installed modules&#34;&gt;The CPAN.pm Shell and Locally Installed Modules&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;CPAN.pm&lt;/code&gt; shell saves a great deal of time when dealing with the installation of Perl modules and keeping them up to date. It does the job for us, even detecting the missing modules listed in prerequisites, fetching and installing them. So you may wonder whether you can use &lt;code&gt;CPAN.pm&lt;/code&gt; to maintain your local repository as well.&lt;/p&gt;

&lt;p&gt;When you start the &lt;code&gt;CPAN&lt;/code&gt; interactive shell, it searches first for the user&amp;rsquo;s private configuration file and then for the system-wide one. When I&amp;rsquo;m logged as user &lt;code&gt;stas&lt;/code&gt;, the two files on my setup are:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /home/stas/.cpan/CPAN/MyConfig.pm
    /usr/lib/perl5/5.00503/CPAN/Config.pm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If there is no &lt;code&gt;CPAN&lt;/code&gt; shell configured on your system, then when you start the shell for the first time it will ask you a dozen configuration questions and then create the &lt;em&gt;Config.pm&lt;/em&gt; file for you.&lt;/p&gt;

&lt;p&gt;If you already have it system-wide configured, then you should have a &lt;code&gt;/usr/lib/perl5/5.00503/CPAN/Config.pm&lt;/code&gt;. If you have a different Perl version, then alter the path to use your Perl&amp;rsquo;s version number when looking up the file. Create the directory (&lt;code&gt;mkdir -p&lt;/code&gt; creates the whole path at once) where the local configuration file will go:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % mkdir -p /home/stas/.cpan/CPAN
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now copy the system wide configuration file to your local one.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % cp /usr/lib/perl5/5.00503/CPAN/Config.pm \
  /home/stas/.cpan/CPAN/MyConfig.pm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only thing left is to change the base directory of &lt;em&gt;.cpan&lt;/em&gt; in your local file to the one under your home directory. On my machine, I replace &lt;code&gt;/usr/src/.cpan&lt;/code&gt; (that&amp;rsquo;s where my system&amp;rsquo;s &lt;code&gt;.cpan&lt;/code&gt; directory resides) with &lt;code&gt;/home/stas&lt;/code&gt;. I use Perl, of course!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % perl -pi -e &#39;s|/usr/src|/home/stas|&#39; \
  /home/stas/.cpan/CPAN/MyConfig.pm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you have the local configuration file ready, you have to tell it what special parameters you need to pass when executing the &lt;code&gt;perl Makefile.PL&lt;/code&gt; stage.&lt;/p&gt;

&lt;p&gt;Open the file in your favorite editor and replace line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &#39;makepl_arg&#39; =&amp;gt; q[],
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &#39;makepl_arg&#39; =&amp;gt; q[PREFIX=/home/stas],
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you&amp;rsquo;ve finished the configuration. Assuming that you are logged in as the same user you have prepared the local installation for (&lt;em&gt;stas&lt;/em&gt; in our example), start it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % perl -MCPAN -e shell
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From now on, any module you try to install will be installed locally. If you need to install some system modules, then just become the superuser and install them in the same way. When you are logged in as the superuser, the system-wide configuration file will be used instead of your local one.&lt;/p&gt;

&lt;p&gt;If you have used more than just the &lt;code&gt;PREFIX&lt;/code&gt; variable, then modify &lt;em&gt;MyConfig.pm&lt;/em&gt; to use them. For example, if you have used these variables:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    perl Makefile.PL PREFIX=/home/stas \
    INSTALLPRIVLIB=/home/stas/lib/perl5 \
    INSTALLSCRIPT=/home/stas/bin \
    INSTALLSITELIB=/home/stas/lib/perl5/site_perl \
    INSTALLBIN=/home/stas/bin \
    INSTALLMAN1DIR=/home/stas/lib/perl5/man  \
    INSTALLMAN3DIR=/home/stas/lib/perl5/man3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then replace &lt;code&gt;PREFIX=/home/stas&lt;/code&gt; in the line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &#39;makepl_arg&#39; =&amp;gt; q[PREFIX=/home/stas],
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;with all the variables from above, so that the line becomes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &#39;makepl_arg&#39; =&amp;gt; q[PREFIX=/home/stas \
    INSTALLPRIVLIB=/home/stas/lib/perl5 \
    INSTALLSCRIPT=/home/stas/bin \
    INSTALLSITELIB=/home/stas/lib/perl5/site_perl \
    INSTALLBIN=/home/stas/bin \
    INSTALLMAN1DIR=/home/stas/lib/perl5/man  \
    INSTALLMAN3DIR=/home/stas/lib/perl5/man3],
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you arrange all the above parameters in one line, then you can remove the backslashes (&lt;code&gt;\&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&#34;span-id-making-a-local-apache-installation-making-a-local-apache-installation-span&#34;&gt;&lt;span id=&#34;making a local apache installation&#34;&gt;Making a Local Apache Installation&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Just like with Perl modules, if you don&amp;rsquo;t have permissions to install files into the system area, then you have to install them locally under your home directory. It&amp;rsquo;s almost the same as a plain installation, but you have to run the server listening to a port number greater than 1024, since only root processes can listen to lower-numbered ports.&lt;/p&gt;

&lt;p&gt;Another important issue you have to resolve is how to add startup and shutdown scripts to the directories used by the rest of the system services. You will have to ask your system administrator to assist you with this issue.&lt;/p&gt;

&lt;p&gt;To install Apache locally, all you have to do is to tell &lt;code&gt;.configure&lt;/code&gt; in the Apache source directory what target directories to use. If you are following the convention that I use, which makes your home directory look like the &lt;code&gt;/&lt;/code&gt; (base) directory, then the invocation parameters would be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ./configure --prefix=/home/stas
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apache will use the prefix for the rest of its target directories instead of the default &lt;code&gt;/usr/local/apache&lt;/code&gt;. If you want to see what they are, then before you proceed add the &lt;em&gt;&amp;ndash;show-layout&lt;/em&gt; option:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ./configure --prefix=/home/stas --show-layout
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You might want to put all the Apache files under &lt;code&gt;/home/stas/apache&lt;/code&gt; following Apache&amp;rsquo;s convention:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ./configure --prefix=/home/stas/apache
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to modify some or all of the names of the automatically created directories:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ./configure --prefix=/home/stas/apache \
    --sbindir=/home/stas/apache/sbin
    --sysconfdir=/home/stas/apache/etc
    --localstatedir=/home/stas/apache/var \
    --runtimedir=/home/stas/apache/var/run \
    --logfiledir=/home/stas/apache/var/logs \
    --proxycachedir=/home/stas/apache/var/proxy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s all!&lt;/p&gt;

&lt;p&gt;Also remember that you can start the script only under a user and group you belong to. You must set the &lt;code&gt;User&lt;/code&gt; and &lt;code&gt;Group&lt;/code&gt; directives in &lt;em&gt;httpd.conf&lt;/em&gt; to appropriate values.&lt;/p&gt;

&lt;h3 id=&#34;span-id-manual-local-mod-perl-enabled-apache-installation-manual-local-mod-perl-enabled-apache-installation-span&#34;&gt;&lt;span id=&#34;manual local mod_perl enabled apache installation&#34;&gt;Manual Local mod_perl Enabled Apache Installation&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Now that we have learned how to install local Apache and Perl modules separately, let&amp;rsquo;s see how to install mod_perl enabled Apache in our home directory. It&amp;rsquo;s almost as simple as doing each one separately, but there is one wrinkle you need to know about that I&amp;rsquo;ll mention at the end of this section.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say you have unpacked the Apache and mod_perl sources under &lt;em&gt;/home/stas/src&lt;/em&gt; and they look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % ls /home/stas/src
  /home/stas/src/apache_x.x.x
  /home/stas/src/mod_perl-x.xx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;em&gt;x.xx&lt;/em&gt; are the version numbers as usual. You want the Perl modules from the mod_perl package to be installed under &lt;em&gt;/home/stas/lib/perl5&lt;/em&gt; and the Apache files to go under &lt;em&gt;/home/stas/apache&lt;/em&gt;. The following commands will do that for you:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % perl Makefile.PL \
  PREFIX=/home/stas \
  APACHE_PREFIX=/home/stas/apache \
  APACHE_SRC=../apache_x.x.x/src \
  DO_HTTPD=1 \
  USE_APACI=1 \
  EVERYTHING=1
  % make &amp;amp;&amp;amp; make test &amp;amp;&amp;amp; make install 
  % cd ../apache_x.x.x
  % make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you need some parameters to be passed to the &lt;code&gt;.configure&lt;/code&gt; script, as we saw in the previous section, then use &lt;code&gt;APACI_ARGS&lt;/code&gt;. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  APACI_ARGS=&#39;--sbindir=/home/stas/apache/sbin, \
    --sysconfdir=/home/stas/apache/etc, \
    --localstatedir=/home/stas/apache/var, \
    --runtimedir=/home/stas/apache/var/run, \
    --logfiledir=/home/stas/apache/var/logs, \
    --proxycachedir=/home/stas/apache/var/proxy&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the above multi-line splitting will work only with &lt;code&gt;bash&lt;/code&gt;, &lt;code&gt;tcsh&lt;/code&gt; users will have to list all the parameters on a single line.&lt;/p&gt;

&lt;p&gt;Basically the installation is complete. The only remaining problem is the &lt;code&gt;@INC&lt;/code&gt; variable. This won&amp;rsquo;t be correctly set if you rely on the &lt;code&gt;PERL5LIB&lt;/code&gt; environment variable unless you set it explicitly in a startup file that is &lt;code&gt;require&lt;/code&gt;&amp;rsquo;d before loading any other module that resides in your local repository. A much nicer approach is to use the &lt;code&gt;lib&lt;/code&gt; pragma as we saw before, but in a slightly different way &amp;ndash; we use it in the startup file and it affects all the code that will be executed under mod_perl handlers. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  PerlRequire /home/stas/apache/perl/startup.pl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;code&gt;startup.pl&lt;/code&gt; starts with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use lib qw(/home/stas/lib/perl5/5.00503/
             /home/stas/lib/perl5/site_perl/5.005);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that you can still use the hard-coded &lt;code&gt;@INC&lt;/code&gt; modifications in the scripts themselves, but be aware that scripts modify &lt;code&gt;@INC&lt;/code&gt; in &lt;code&gt;BEGIN&lt;/code&gt; blocks and mod_perl executes the &lt;code&gt;BEGIN&lt;/code&gt; blocks only when it performs script compilation. As a result, &lt;code&gt;@INC&lt;/code&gt; will be reset to its original value after the scripts are compiled and the hard-coded settings will be forgotten.&lt;/p&gt;

&lt;p&gt;The only place you can alter the ``original&amp;rdquo; value is during the server configuration stage either in the startup file or by putting&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  PerlSetEnv Perl5LIB \
  /home/stas/lib/perl5/5.00503/:/home/stas/lib/perl5/site_perl/5.005
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in &lt;em&gt;httpd.conf&lt;/em&gt;, but the latter setting will be ignored if you use the &lt;code&gt;PerlTaintcheck&lt;/code&gt; setting, and I hope you do use it.&lt;/p&gt;

&lt;p&gt;The remainder of the mod_perl configuration and use is just the same as if you were installing mod_perl as a superuser.&lt;/p&gt;

&lt;h3 id=&#34;span-id-local-mod-perl-enabled-apache-installation-with-cpan-pm-local-mod-perl-enabled-apache-installation-with-cpan-pm-span&#34;&gt;&lt;span id=&#34;local mod_perl enabled apache installation with cpan.pm&#34;&gt;Local mod_perl Enabled Apache Installation with CPAN.pm&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Assuming that you have configured &lt;code&gt;CPAN.pm&lt;/code&gt; to install Perl modules locally as explained earlier in this article, the installation is simple. Start the &lt;code&gt;CPAN.pm&lt;/code&gt; shell, set the arguments to be passed to &lt;code&gt;perl Makefile.PL&lt;/code&gt; (modify the example setting to suit your needs), and tell &amp;lt;CPAN.pm&amp;gt; to do the rest for you:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % perl -MCPAN -eshell
  cpan&amp;gt; o conf makepl_arg &#39;DO_HTTPD=1 USE_APACI=1 EVERYTHING=1 \
        PREFIX=/home/stas APACHE_PREFIX=/home/stas/apache&#39;
  cpan&amp;gt; install mod_perl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you use &lt;code&gt;CPAN.pm&lt;/code&gt; for local installations, after the mod_perl installation is complete, you must make sure that the value of &lt;code&gt;makepl_arg&lt;/code&gt; is restored to its original value.&lt;/p&gt;

&lt;p&gt;The simplest way to do this is to quit the interactive shell by typing &lt;em&gt;quit&lt;/em&gt; and re-entering it. But if you insist, then here is how to make it work without quitting the shell. You really want to skip this :)&lt;/p&gt;

&lt;p&gt;If you want to continue working with &lt;code&gt;CPAN&lt;/code&gt; *without* quitting the shell, then you must:&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;Previously in the Series&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/03/22/modperl.html&#34;&gt;mod_perl in 30 minutes&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/02/26/whatismodperl.html&#34;&gt;Why mod_perl?&lt;/a&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;span id=&#34;item_remember_the_value_of_makepl_arg&#34;&gt;remember the value of &lt;code&gt;makepl_arg&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span id=&#34;item_change_it_to_suit_your_new_installation&#34;&gt;change it to suit your new installation&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span id=&#34;item_build_and_install_mod_perl&#34;&gt;build and install mod_perl&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span id=&#34;item_restore_it_after_completing_mod_perl_installation&#34;&gt;restore it after completing mod_perl installation&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;this is quite a cumbersome task as of this writing, but I believe that &lt;code&gt;CPAN.pm&lt;/code&gt; will eventually be improved to handle this more easily.&lt;/p&gt;

&lt;p&gt;So if you are still with me, then start the shell as usual:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % perl -MCPAN -eshell
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, read the value of the &lt;code&gt;makepl_arg&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  cpan&amp;gt; o conf makepl_arg

  PREFIX=/home/stas
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It will be something like &lt;code&gt;PREFIX=/home/stas&lt;/code&gt; if you configured &lt;code&gt;CPAN.pm&lt;/code&gt; to install modules locally. Save this value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  cpan&amp;gt; o conf makepl_arg.save PREFIX=/home/stas
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Second, set a new value, to be used by the mod_perl installation process. (You can add parameters to this line, or remove them, according to your needs.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  cpan&amp;gt; o conf makepl_arg &#39;DO_HTTPD=1 USE_APACI=1 EVERYTHING=1 \
        PREFIX=/home/stas APACHE_PREFIX=/home/stas/apache&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Third, let &amp;lt;CPAN.pm&amp;gt; build and install mod_perl for you:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  cpan&amp;gt; install mod_perl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fourth, reset the original value to &lt;code&gt;makepl_arg&lt;/code&gt;. We do this by printing the value of the saved variable and assigning it to &lt;code&gt;makepl_arg&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  cpan&amp;gt; o conf makepl_arg.save

  PREFIX=/home/stas

  cpan&amp;gt; o conf makepl_arg PREFIX=/home/stas
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not so neat, but a working solution. You could have written the value on a piece of paper instead of saving it to &lt;code&gt;makepl_arg.save&lt;/code&gt;, but you are more likely to make a mistake that way.&lt;/p&gt;

&lt;h3 id=&#34;span-id-references-references-span&#34;&gt;&lt;span id=&#34;references&#34;&gt;References&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The Apache site&amp;rsquo;s URL: &lt;a href=&#34;http://www.apache.org&#34;&gt;http://www.apache.org&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The mod_perl site&amp;rsquo;s URL: &lt;a href=&#34;http://perl.apache.org&#34;&gt;http://perl.apache.org&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;CPAN is the Comprehensive Perl Archive Network. The Master site&amp;rsquo;s URL is &lt;a href=&#34;http://cpan.org/.&#34;&gt;http://cpan.org/.&lt;/a&gt; CPAN is mirrored at more than 100 sites worldwide. (&lt;a href=&#34;http://cpan.org/SITES.html&#34;&gt;http://cpan.org/SITES.html&lt;/a&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>mod_perl in 30 minutes</title>
      <link>http://localhost:1313/pub/2002/03/22/modperl.html/</link>
      <pubDate>Fri, 22 Mar 2002 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2002/03/22/modperl.html/</guid>
      <description>

&lt;h3 id=&#34;span-id-introduction-introduction-span&#34;&gt;&lt;span id=&#34;introduction&#34;&gt;Introduction&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In the &lt;a href=&#34;http://localhost:1313/pub/2002/02/26/whatismodperl.html&#34;&gt;previous article&lt;/a&gt;, I&amp;rsquo;ve shown quite amazing Web performance reports from companies that have deployed mod_perl heavily. You might be surprised but you can quite easily get similarly amazing results if you move your service to mod_perl as well. In fact, getting started with mod_perl shouldn&amp;rsquo;t take you more than 30 minutes &amp;ndash; the time it takes to compile and configure the server on a decent machine and get it running.&lt;/p&gt;

&lt;p&gt;In this article I&amp;rsquo;ll show step-by-step installation and configuration scenarios, and chances are you will be able to run the basic statically compiled mod_perl setup without reading any other documents. Of course, you will want and need to read the documentation later, but I think you will agree with me that it&amp;rsquo;s ultimately cool to be able to get your feet wet without knowing much about the new technology up-front.&lt;/p&gt;

&lt;p&gt;The mod_perl installation was tested on many mainstream Unix platforms, so unless you have a nonstandard system, you shouldn&amp;rsquo;t have any problems building the basic mod_perl server.&lt;/p&gt;

&lt;p&gt;If you are a Windows user, then the easiest way is to use the binary package available from &lt;a href=&#34;http://perl.apache.org/distributions.html.&#34;&gt;http://perl.apache.org/distributions.html.&lt;/a&gt; From the same location, you can download the Linux RPM version and CVS snapshots. However, I always recommend to build the mod_perl from the source, and as you will see in a moment, it&amp;rsquo;s an easy thing to do.&lt;/p&gt;

&lt;h3 id=&#34;span-id-installing-mod-perl-is-easy-installing-mod-perl-is-easy-span&#34;&gt;&lt;span id=&#34;installing mod_perl is easy&#34;&gt;Installing mod_perl Is Easy&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;So let&amp;rsquo;s start with the installation process. If you are an experienced Unix user, then you need no explanation for the following commands. Just copy and paste them and you will get the server installed.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll use a &lt;code&gt;%&lt;/code&gt; sign as the shell program&amp;rsquo;s prompt.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % cd /usr/src
  % lwp-download http://www.apache.org/dist/httpd/apache_1.3.20.tar.gz
  % lwp-download http://perl.apache.org/dist/mod_perl-1.26.tar.gz
  % tar -zvxf apache_1.3.20.tar.gz
  % tar -zvxf mod_perl-1.26.tar.gz
  % cd mod_perl-1.26
  % perl Makefile.PL APACHE_SRC=../apache_1.3.20/src \
    DO_HTTPD=1 USE_APACI=1 EVERYTHING=1
  % make &amp;amp;&amp;amp; make test &amp;amp;&amp;amp; make install
  % cd ../apache_1.3.20
  % make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s all!&lt;/p&gt;

&lt;p&gt;What&amp;rsquo;s left is to add a few configuration lines to &lt;em&gt;httpd.conf&lt;/em&gt;, an Apache configuration file, start the server and enjoy mod_perl.&lt;/p&gt;

&lt;p&gt;If you have stumbled upon a problem at any of the above steps, then don&amp;rsquo;t despair &amp;ndash; the next section will explain in detail each step.&lt;/p&gt;

&lt;h3 id=&#34;span-id-installing-mod-perl-detailed-installing-mod-perl-detailed-span&#34;&gt;&lt;span id=&#34;installing mod_perl detailed&#34;&gt;Installing mod_perl Detailed&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;If you didn&amp;rsquo;t have the courage to try the steps in the previous section or you simply want to understand more before you try, then let&amp;rsquo;s go through the fine details of the installation process. If you have successfully installed mod_perl following the short scenario in the previous section, then you can skip this section and move on to the next one.&lt;/p&gt;

&lt;p&gt;Before we proceed, I should note that you have to become a &lt;em&gt;root&lt;/em&gt; user in order to install the files in a protected area. If you don&amp;rsquo;t have &lt;em&gt;root&lt;/em&gt; access, then you can install all the files under your home directory. We will talk about the nuances of this approach in a future articles. I&amp;rsquo;ll also assume that you have &lt;em&gt;perl&lt;/em&gt; and &lt;em&gt;gcc&lt;/em&gt; or an equivalent C compiler installed.&lt;/p&gt;

&lt;p&gt;I assume that all builds are being done in the &lt;em&gt;/home/stas/src&lt;/em&gt; directory. So we go into this directory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % cd /home/stas/src
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we download the latest source distributions of Apache and mod_perl. If you have the &lt;code&gt;LWP&lt;/code&gt; module installed (also known as &lt;em&gt;libwww&lt;/em&gt; and available from CPAN), then you should have the &lt;code&gt;lwp-download&lt;/code&gt; utility that partly imitates your favorite browser by allowing you to download files from the Internet. You can use any other method to retrieve these files. Just make sure that you save both files in the &lt;em&gt;/home/stas/src&lt;/em&gt; directory, as this will make it easier for you to follow the example installation process. Of course, you can install both packages anywhere on your file system.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % lwp-download http://www.apache.org/dist/httpd/apache_1.3.20.tar.gz
  % lwp-download http://perl.apache.org/dist/mod_perl-1.26.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can make sure that you&amp;rsquo;re downloading the latest stable versions by visiting the following distribution directories: &lt;em&gt;&lt;a href=&#34;http://www.apache.org/dist/httpd/&#34;&gt;http://www.apache.org/dist/httpd/&lt;/a&gt;&lt;/em&gt; and &lt;em&gt;&lt;a href=&#34;http://perl.apache.org/dist/&#34;&gt;http://perl.apache.org/dist/&lt;/a&gt;&lt;/em&gt;. As you have guessed already, the former URL is the main Apache distribution directory, the latter is the same thing for mod_perl.&lt;/p&gt;

&lt;p&gt;Untar both sources. You have to uncompress and untar the files. In addition to its main usage for tarring and untarring files, the GNU &lt;code&gt;tar&lt;/code&gt; utility is able to uncompress files compressed by the &lt;code&gt;gzip&lt;/code&gt; utility, when the &lt;code&gt;-z&lt;/code&gt; option is used.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % tar -zvxf apache_1.3.20.tar.gz
  % tar -zvxf mod_perl-1.26.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you have a non-GNU &lt;code&gt;tar&lt;/code&gt; utility, then chances are that it will be unable to decompress, so you need to do it in two steps. First, uncompress the packages with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % gzip -d apache_1.3.20.tar.gz
  % gzip -d mod_perl-1.26.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then untar them with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % tar -xvf apache_1.3.20.tar
  % tar -xvf mod_perl-1.26.tar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you don&amp;rsquo;t have &lt;code&gt;tar&lt;/code&gt; or &lt;code&gt;gzip&lt;/code&gt; utilities available, then install them or use their equivalents.&lt;/p&gt;

&lt;p&gt;Now go into the mod_perl source distribution directory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % cd mod_perl-1.26
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is to create the &lt;em&gt;Makefile&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % perl Makefile.PL APACHE_SRC=../apache_1.3.20/src \
    DO_HTTPD=1 USE_APACI=1 EVERYTHING=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mod_perl accepts a variety of parameters, in this scenario we are going to use those that will allow you to do almost everything with mod_perl. Once you learn more about mod_perl, you will be able to fine-tune the list of parameters passed to &lt;em&gt;Makefile.PL&lt;/em&gt;. In future articles, I&amp;rsquo;ll go through all the available options.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;perl Makefile.PL ...&lt;/code&gt; execution will check for prerequisites and tell you which required software packages are missing from your system. If you don&amp;rsquo;t have some of the Perl packages installed, then you will have to install these before you proceed. They all are available from CPAN and can be easily downloaded and installed.&lt;/p&gt;

&lt;p&gt;If you choose to install mod_perl with help of the &lt;code&gt;CPAN.pm&lt;/code&gt; module, then it will install all the missing modules for you. To do so, tell &lt;code&gt;CPAN.pm&lt;/code&gt; to install the &lt;code&gt;Bundle::Apache&lt;/code&gt; bundle.&lt;/p&gt;

&lt;p&gt;This step also executes the &lt;code&gt;./configure&lt;/code&gt; script from Apache&amp;rsquo;s source distribution directory (absolutely transparently for you), which prepares the Apache build configuration files. If you need to pass parameters to Apache&amp;rsquo;s &lt;code&gt;./configure&lt;/code&gt; script, then pass them as options to &lt;code&gt;perl Makefile.PL ...&lt;/code&gt;. In future articles we will talk about all the available options.&lt;/p&gt;

&lt;p&gt;Now you should build the &lt;em&gt;httpd&lt;/em&gt; executable by using the &lt;code&gt;make&lt;/code&gt; utility.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command prepares mod_perl extension files, installs them in the Apache source tree and builds the &lt;em&gt;httpd&lt;/em&gt; executable (the Web server itself) by compiling all the required files. Upon completion of the &lt;code&gt;make&lt;/code&gt; process, you get returned to the mod_perl source distribution directory.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;make test&lt;/code&gt; executes various mod_perl tests on the freshly built &lt;em&gt;httpd&lt;/em&gt; executable.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % make test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command starts the server on a nonstandard port (8529) and tests whether all parts of the built server function correctly. If something goes wrong, then the process will report it to you.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;make install&lt;/code&gt; completes the installation process of mod_perl by installing all the Perl files required for mod_perl to run and, of course, the server documentation (man pages).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can use the following commands concatenation style:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % make &amp;amp;&amp;amp; make test &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It simplifies the installation, since you don&amp;rsquo;t have to wait for each command to complete before starting the next one. When installing mod_perl for the first time, it&amp;rsquo;s better to do it step by step.&lt;/p&gt;

&lt;p&gt;If you choose the all-in-one approach, then you should know that if &lt;code&gt;make&lt;/code&gt; fails, then neither &lt;code&gt;make test&lt;/code&gt; nor &lt;code&gt;make install&lt;/code&gt; will be executed. If &lt;code&gt;make test&lt;/code&gt; fails, then &lt;code&gt;make install&lt;/code&gt; will not be executed.&lt;/p&gt;

&lt;p&gt;Finally, change to the Apache source distribution directory, run make install to create the Apache directory tree and install Apache header files (&lt;em&gt;*.h&lt;/em&gt;), default configuration files (&lt;em&gt;*.conf&lt;/em&gt;), the &lt;em&gt;httpd&lt;/em&gt; executable and a few other programs.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % cd ../apache_1.3.20
  % make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that, as with a plain Apache installation, any configuration files left from a previous installation won&amp;rsquo;t be overwritten by this process. You don&amp;rsquo;t need to back up your previously working configuration files before the installation.&lt;/p&gt;

&lt;p&gt;When the &lt;code&gt;make install&lt;/code&gt; process completes, it will tell you how to start a freshly built Web server (the path to the &lt;code&gt;apachectl&lt;/code&gt; utility that is being used to control the server) and where the installed configuration files are. Remember or, even better, write down both of them, since you will need this information. On my machine the two important paths are:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  /usr/local/apache/bin/apachectl
  /usr/local/apache/conf/httpd.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far, we have completed the building and installation of the mod_perl enabled Apache. The next steps are to configure &lt;em&gt;httpd.conf&lt;/em&gt;, write a little test script, start the server and check that the test script is working.&lt;/p&gt;

&lt;h3 id=&#34;span-id-configuring-and-starting-mod-perl-server-configuring-and-starting-mod-perl-server-span&#34;&gt;&lt;span id=&#34;configuring and starting mod_perl server&#34;&gt;Configuring and Starting mod_perl Server&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;First things first; we want to make sure that our Apache was built correctly and that we can serve plain HTML files with it. Why do that? To minimize the number of possible trouble makers, if we find out that mod_perl doesn&amp;rsquo;t work. After you know that Apache can serve HTML files, you don&amp;rsquo;t have to worry about it anymore. And if something goes wrong with mod_perl, you have eliminated the possibility that the &lt;em&gt;httpd&lt;/em&gt; binary or basic configurations are broken, you know that you are allowed to bind to the port you have configured your server to listen to, and that the browser you&amp;rsquo;re testing with is just fine. Again, you should follow these guidelines when installing mod_perl for the first time.&lt;/p&gt;

&lt;p&gt;Configure Apache as you always do. Set &lt;code&gt;Port&lt;/code&gt;, &lt;code&gt;User&lt;/code&gt;, &lt;code&gt;Group&lt;/code&gt;, &lt;code&gt;ErrorLog&lt;/code&gt; and other directives in the &lt;em&gt;httpd.conf&lt;/em&gt; file (remember I&amp;rsquo;ve asked you to remember the location of this file at the end of the previous section?). Use the defaults as suggested, customize only when you have to. Values that you need to customize are &lt;code&gt;ServerName&lt;/code&gt;, &lt;code&gt;Port&lt;/code&gt;, &lt;code&gt;User&lt;/code&gt;, &lt;code&gt;Group&lt;/code&gt;, &lt;code&gt;ServerAdmin&lt;/code&gt;, &lt;code&gt;DocumentRoot&lt;/code&gt; and a few others. You will find helpful hints preceding each directive. Follow them if in doubt.&lt;/p&gt;

&lt;p&gt;When you have edited the configuration file, it&amp;rsquo;s time to start the server. One of the ways to start and stop the server is to use the &lt;code&gt;apachectl&lt;/code&gt; utility. You start the server with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % /usr/local/apache/bin/apachectl start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And stop it with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % /usr/local/apache/bin/apachectl stop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that you have to be &lt;em&gt;root&lt;/em&gt; when starting the server if the server is going to listen on port &lt;code&gt;80&lt;/code&gt; or another privileged port (&amp;lt;1024).&lt;/p&gt;

&lt;p&gt;After you start the server, check in the &lt;em&gt;error_log&lt;/em&gt; file (&lt;em&gt;/usr/local/apache/logs/error_log&lt;/em&gt; is the file&amp;rsquo;s default location) that the server has indeed started. Don&amp;rsquo;t rely on the status &lt;code&gt;apachectl&lt;/code&gt; reports. You should see something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  [Thu Jun 22 17:14:07 2000] [notice] Apache/1.3.20 (Unix) 
  mod_perl/1.26 configured -- resuming normal operations
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now point your browser to &lt;em&gt;&lt;a href=&#34;http://localhost/&#34;&gt;http://localhost/&lt;/a&gt;&lt;/em&gt; or &lt;em&gt;&lt;a href=&#34;http://your.server.name/&#34;&gt;http://your.server.name/&lt;/a&gt;&lt;/em&gt; as configured with the &lt;code&gt;ServerName&lt;/code&gt; directive. If you have set a &lt;code&gt;Port&lt;/code&gt; directive with a value different from &lt;code&gt;80&lt;/code&gt;, then apply this port number at the end of the server name. If you have used port 8080, then test the server with &lt;em&gt;&lt;a href=&#34;http://localhost:8080/&#34;&gt;http://localhost:8080/&lt;/a&gt;&lt;/em&gt; or &lt;em&gt;&lt;a href=&#34;http://your.server.name:8080/&#34;&gt;http://your.server.name:8080/&lt;/a&gt;&lt;/em&gt;. You should see the infamous &lt;em&gt;``It worked&amp;rdquo;&lt;/em&gt; page, which is an &lt;code&gt;index.html&lt;/code&gt; file that &lt;code&gt;make install&lt;/code&gt; in the Apache source tree installs for you. If you don&amp;rsquo;t see this page, then something is wrong and you should check the contents of the &lt;em&gt;error_log&lt;/em&gt; file. You will find the path of the error log file by looking it up in the &lt;code&gt;ErrorLog&lt;/code&gt; directive in &lt;em&gt;httpd.conf&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;If everything works as expected, then shut down the server, open &lt;em&gt;httpd.conf&lt;/em&gt; in your favorite editor, and scroll to the end of the file, where we will add the mod_perl configuration directives (of course you can place them anywhere in the file).&lt;/p&gt;

&lt;p&gt;Assuming that you put all scripts that should be executed by the mod_perl enabled server in the &lt;em&gt;/home/httpd/perl/&lt;/em&gt; directory, add the following configuration directives:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Alias /perl/ /home/httpd/perl/

  PerlModule Apache::Registry
  &amp;lt;Location /perl&amp;gt;
    SetHandler perl-script
    PerlHandler Apache::Registry
    Options ExecCGI
    PerlSendHeader On
    allow from all
  &amp;lt;/Location&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Save the modified file.&lt;/p&gt;

&lt;p&gt;This configuration causes each URI starting with &lt;em&gt;/perl&lt;/em&gt; to be handled by the Apache mod_perl module. It will use the handler from the Perl module &lt;code&gt;Apache::Registry&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-preparing-the-scripts-directory-preparing-the-scripts-directory-span&#34;&gt;&lt;span id=&#34;preparing the scripts directory&#34;&gt;Preparing the Scripts Directory&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Now create a &lt;em&gt;/home/httpd/perl/&lt;/em&gt; directory if it doesn&amp;rsquo;t yet exist. In order for you and Apache to be able to read, write and execute files we have to set correct permissions. You could get away by simply doing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % chmod 0777  /home/httpd/perl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is very, very insecure and you &lt;strong&gt;should not&lt;/strong&gt; follow this approach on the production machine. This is good enough when you just want to try things out and want to have as few obstacles as possible. Once you understand how things work, you should tighten the permissions of files served by Apache. In future articles, we will talk about setting proper file permissions.&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-mod-perl-rules-apache-registry-script-the-mod-perl-rules-apache-registry-script-span&#34;&gt;&lt;span id=&#34;the mod_perl rules apache::registry script&#34;&gt;The ``mod_perl rules&amp;rdquo; Apache::Registry Script&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;As you probably know, mod_perl allows you to reuse CGI scripts written in Perl that were previously used under mod_cgi. Therefore, our first test script can be as simple as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  mod_perl_rules1.pl
  ------------------
  print &amp;quot;Content-type: text/plain\r\n\r\n&amp;quot;;
  print &amp;quot;mod_perl rules!\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Save this script in the &lt;em&gt;/home/httpd/perl/mod_perl_rules1.pl&lt;/em&gt; file. Notice that the &lt;em&gt;shebang&lt;/em&gt; line is not needed with mod_perl, but you can keep it if you want. So the following script can be used as well:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  mod_perl_rules1.pl
  ------------------
  #!/usr/bin/perl
  print &amp;quot;Content-type: text/plain\r\n\r\n&amp;quot;;
  print &amp;quot;mod_perl rules!\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course you can write the same script using the Apache Perl API:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  mod_perl_rules2.pl
  ------------------
  my $r = shift;
  $r-&amp;gt;send_http_header(&#39;text/plain&#39;);
  $r-&amp;gt;print(&amp;quot;mod_perl rules!\n&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Save this script in the &lt;em&gt;/home/httpd/perl/mod_perl_rules2.pl&lt;/em&gt; file.&lt;/p&gt;

&lt;p&gt;Now make both of the scripts executable and readable by the server. Remember that when you execute scripts from a shell, they are being executed by the user-name you are logged with. When instead you try to run the scripts by issuing requests, Apache needs to be able to read and execute them. So we make the script readable and executable by everybody:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % chmod 0755   /home/httpd/perl/mod_perl_rules1.pl \
                 /home/httpd/perl/mod_perl_rules2.pl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you don&amp;rsquo;t want other users to be able to read your script, then you should add yourself into the groupname the Web server is running with (as defined by the &lt;code&gt;Group&lt;/code&gt; directive) and then make the script owned by that group and tighten the permissions. For example, on my machine I run the server under the group &lt;em&gt;httpd&lt;/em&gt; and I&amp;rsquo;m the only one who is in the same group, so I can do the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % chown stas.httpd /home/httpd/perl/mod_perl_rules1.pl \
                 /home/httpd/perl/mod_perl_rules2.pl

  % chmod 0750   /home/httpd/perl/mod_perl_rules1.pl \
                 /home/httpd/perl/mod_perl_rules2.pl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first command makes the files belong to group &lt;em&gt;httpd&lt;/em&gt;, the second sets the proper execution and read permissions.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s secure, assuming that you have a dedicated groupname for your server.&lt;/p&gt;

&lt;p&gt;Also, remember that all the directories that lead to the script should be readable and executable by the server.&lt;/p&gt;

&lt;p&gt;You can test &lt;em&gt;mod_perl_rules1.pl&lt;/em&gt; from the command line, since it is essentially a regular Perl script.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % perl /home/httpd/perl/mod_perl_rules1.pl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should see the following output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  mod_perl rules!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You cannot test the second script by executing it from the command line since it uses the mod_perl API that is available only when run from within the mod_perl server.&lt;/p&gt;

&lt;p&gt;Make sure the server is running and issue these requests using your favorite browser:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  http://localhost/perl/mod_perl_rules1.pl
  http://localhost/perl/mod_perl_rules2.pl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In both cases you will see on the following response:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  mod_perl rules!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you see it&amp;ndash;&lt;strong&gt;congratulations&lt;/strong&gt;! You have a working mod_perl server.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re using port 8080 instead of 80, then you should use this number in the URL:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  http://localhost:8080/perl/mod_perl_rules1.pl
  http://localhost:8080/perl/mod_perl_rules2.pl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;localhost&lt;/code&gt; approach will work only if the browser is running on the same machine as the server. If not, then use the real server name for this test. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  http://your.server.name/perl/mod_perl_rules1.pl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If there is any problem, then please refer to the &lt;em&gt;error_log&lt;/em&gt; file for the error reports.&lt;/p&gt;

&lt;p&gt;Now it&amp;rsquo;s a time to move your CGI scripts from &lt;em&gt;/somewhere/cgi-bin&lt;/em&gt; directory to &lt;em&gt;/home/httpd/perl/&lt;/em&gt; and see them running much much faster, when requested from the newly configured base URL (&lt;em&gt;/perl/&lt;/em&gt;). If you were accessing the script as &lt;em&gt;/cgi-bin/test.pl&lt;/em&gt;, then it will now be accessed from &lt;em&gt;/perl/test.pl&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Some of your scripts might not work immediately and will require some minor tweaking or even a partial rewrite to work properly with mod_perl. Chances are that if you are not practicing sloppy programming, then the scripts will work without any modifications.&lt;/p&gt;

&lt;p&gt;If you have a problem with your scripts, then a good approach is to replace &lt;code&gt;Apache::Registry&lt;/code&gt; with &lt;code&gt;Apache::PerlRun&lt;/code&gt; in &lt;em&gt;httpd.conf&lt;/em&gt;, as the latter can execute really badly written scripts. Put the following configuration directives instead in &lt;em&gt;httpd.conf&lt;/em&gt; and restart the server:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  PerlModule Apache::PerlRun
  &amp;lt;Location /perl&amp;gt;
    SetHandler perl-script
    PerlHandler Apache::PerlRun
    Options ExecCGI
    PerlSendHeader On
    allow from all
  &amp;lt;/Location&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now your scripts should work, unless there is something in them mod_perl doesn&amp;rsquo;t accept. We will discuss these nuances in future articles.&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-mod-perl-rules-apache-perl-module-the-mod-perl-rules-apache-perl-module-span&#34;&gt;&lt;span id=&#34;the mod_perl rules apache perl module&#34;&gt;The ``mod_perl rules&amp;rdquo; Apache Perl Module&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;mod_perl is about running both scripts and handlers. Although I have started to present mod_perl using scripts, because it&amp;rsquo;s easier if you have written CGI scripts before, the more advanced use of mod_perl is about writing handlers. But have no fear. As you will see in a moment, writing handlers is almost as easy as writing scripts.&lt;/p&gt;

&lt;p&gt;To create a mod_perl handler module, all I have to do is to wrap the code I have used for the script into a &lt;code&gt;handler&lt;/code&gt; subroutine, add a statement to return the status to the server when the subroutine has successfully completed, and append a package declaration at the top of the code.&lt;/p&gt;

&lt;p&gt;Just as with scripts you can use either the CGI API you are probably used to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ModPerl/Rules1.pm
  ----------------
  package ModPerl::Rules1;
  use Apache::Constants qw(:common);

  sub handler{
    print &amp;quot;Content-type: text/plain\r\n\r\n&amp;quot;;
    print &amp;quot;mod_perl rules!\n&amp;quot;;
    return OK;
  }
  1; # satisfy require()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or the Apache Perl API that allows you to interact more intimately with the Apache core by providing an API unavailable under regular Perl. Of course, in the simple example that I show, using any of the approaches is fine, but when you need to use the API, this version of the code should be used.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ModPerl/Rules2.pm
  ----------------
  package ModPerl::Rules2;
  use Apache::Constants qw(:common);

  sub handler{
    my $r = shift;
    $r-&amp;gt;send_http_header(&#39;text/plain&#39;);
    print &amp;quot;mod_perl rules!\n&amp;quot;;
    return OK;
  }
  1; # satisfy require()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create a directory called &lt;em&gt;ModPerl&lt;/em&gt; under one of the directories in &lt;code&gt;@INC&lt;/code&gt; (e.g. &lt;em&gt;/usr/lib/perl5/site_perl/5.005&lt;/em&gt;), and put &lt;em&gt;Rules1.pm&lt;/em&gt; &lt;em&gt;Rules2.pm&lt;/em&gt; into it, the files should include the code from the above examples.&lt;/p&gt;

&lt;p&gt;To find out what the &lt;code&gt;@INC&lt;/code&gt; directories are, execute:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % perl -le &#39;print join &amp;quot;\n&amp;quot;, @INC&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On my machine it reports:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  /usr/lib/perl5/5.6.1/i386-linux
  /usr/lib/perl5/5.6.1
  /usr/lib/perl5/site_perl/5.6.1/i386-linux
  /usr/lib/perl5/site_perl/5.6.1
  /usr/lib/perl5/site_perl
  .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now add the following snippet to &lt;em&gt;httpd.conf&lt;/em&gt; to configure mod_perl to execute the &lt;code&gt;ModPerl::Rules::handler&lt;/code&gt; subroutine whenever a request to &lt;em&gt;mod_perl_rules1&lt;/em&gt; is made:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  PerlModule ModPerl::Rules1
  &amp;lt;Location /mod_perl_rules1&amp;gt;
    SetHandler perl-script
    PerlHandler ModPerl::Rules1
  &amp;lt;/Location&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you can issue a request to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  http://localhost/mod_perl_rules1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and just as with our &lt;em&gt;mod_perl_rules.pl&lt;/em&gt; scripts you will see:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  mod_perl rules!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;as the response.&lt;/p&gt;

&lt;p&gt;To test the second module &amp;lt;ModPerl::Rules2&amp;gt; add the same configuration, while replacing all 1&amp;rsquo;s with 2&amp;rsquo;s:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  PerlModule ModPerl::Rules2
  &amp;lt;Location /mod_perl_rules2&amp;gt;
    SetHandler perl-script
    PerlHandler ModPerl::Rules2
  &amp;lt;/Location&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And to test use the URI:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  http://localhost/mod_perl_rules2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-is-this-all-i-need-to-know-about-mod-perl-is-this-all-i-need-to-know-about-mod-perl-span&#34;&gt;&lt;span id=&#34;is this all i need to know about mod_perl&#34;&gt;Is This All I Need to Know About mod_perl?&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Obviously, the next question you&amp;rsquo;ll ask is: &lt;em&gt;``Is this all I need to know about mod_perl?&amp;rdquo;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The answer is: `yes and no.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;yes&lt;/em&gt; part:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Just like with Perl, you have to know little about mod_perl to do really cool stuff. The presented setup allows you to run your visitor counters and guest book much faster, and amaze your friends, usually without changing a single line of code.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;em&gt;No&lt;/em&gt; part:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A 50-fold improvement in guest book response times is great, but when you deploy a heavy service with thousands of concurrent users, taking into account a high-level competition between similar Web services, a delay of a few milliseconds might cost you a customer and probably many of them.&lt;/p&gt;

&lt;p&gt;Of course, when you test a single script and you are the only user, you don&amp;rsquo;t really care about squeezing yet another millisecond from response time, but it becomes a real issue when these milliseconds add up at the production site, with hundreds of users concurrently generating requests to various scripts on your site. Users aren&amp;rsquo;t merciful nowadays &amp;ndash; if there is another even less fancier site that provides the same service but a little bit faster, then chances are that they will go over there.&lt;/p&gt;

&lt;p&gt;Testing your scripts on an unloaded machine can be misleading, Everything might seem so perfect. But when you move them into a production machine, things don&amp;rsquo;t behave as well as they did on your development box. Many times you just run out of memory on busy services. You need to learn how to optimize your code to use less memory and how to make the memory shared.&lt;/p&gt;

&lt;p&gt;Debugging is something people prefer not to talk about, since the process can be tedious. Learning how to make the debugging process simpler and efficient is a must if you consider yourself a Web programmer. This task is especially not so straightforward when debugging CGI scripts, and even more complicated with mod_perl &amp;ndash; unless you know how, and then it suddenly becomes easy.&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;References&lt;/p&gt;
&lt;p&gt;The Apache site&#39;s URL: &lt;a href=&#34;http://www.apache.org/&#34; class=&#34;uri&#34;&gt;http://www.apache.org/&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
The mod_perl site&#39;s URL: &lt;a href=&#34;http://perl.apache.org/&#34; class=&#34;uri&#34;&gt;http://perl.apache.org/&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
CPAN is the Comprehensive Perl Archive Network. The Master site&#39;s URL is &lt;a href=&#34;http://cpan.org/&#34; class=&#34;uri&#34;&gt;http://cpan.org/&lt;/a&gt;. CPAN is mirrored at more than 100 sites worldwide. (http://cpan.org/SITES.html)&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;mod_perl has many features unavailable under mod_cgi when working with databases. Among others the most important are persistent connections.&lt;/p&gt;

&lt;p&gt;You have to know how to keep your service running nonstop and be able to recover fast if there are any problems.&lt;/p&gt;

&lt;p&gt;Finally, the most important thing is the Apache-Perl API, which allows you to do anything with a received request, even intervene in every stage of request processing. This gives you great flexibility and allows you to create things you couldn&amp;rsquo;t dream about with plain mod_cgi.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are many more things to learn about mod_perl and Web programming in general. In future articles, I&amp;rsquo;ll talk in details about all these issues.&lt;/p&gt;

&lt;h4 id=&#34;span-id-acknowledgements-acknowledgements-span&#34;&gt;&lt;span id=&#34;acknowledgements&#34;&gt;Acknowledgements&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Many thanks to Eric Cholet for reviewing this article.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

