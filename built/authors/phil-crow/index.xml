<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Phil Crow on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/authors/phil-crow/</link>
    <description>Recent content in Phil Crow on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 01 Mar 2007 00:00:00 -0800</lastBuildDate>
    <atom:link href="/authors/phil-crow/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>The Beauty of Perl 6 Parameter Passing</title>
      <link>http://localhost:1313/pub/2007/03/01/perl-6-parameter-passing.html/</link>
      <pubDate>Thu, 01 Mar 2007 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2007/03/01/perl-6-parameter-passing.html/</guid>
      <description>

&lt;p&gt;Perl 6 is not finished, but you can already play with it. I hope this article will encourage you to try it. Begin by installing &lt;a href=&#34;https://metacpan.org/pod/Pugs&#34;&gt;Pugs&lt;/a&gt;, a Perl 6 compiler implemented in Haskell. Note that you will also need Haskell (see directions in the Pugs &lt;em&gt;INSTALL&lt;/em&gt; file for how to get it).&lt;/p&gt;

&lt;p&gt;Of course, Pugs is not finished. It couldn&amp;rsquo;t be. The Perl 6 design is still in progress. However, Pugs still has many key features that are going to turn our favorite language into something even greater.&lt;/p&gt;

&lt;h3 id=&#34;a-simple-script&#34;&gt;A Simple Script&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;m about to take a big risk. I&amp;rsquo;m going to show you a script that performs Newton&amp;rsquo;s method. Please don&amp;rsquo;t give up before you get started.&lt;/p&gt;

&lt;p&gt;Sir Isaac Newton was a noted computer scientist and sometime astronomer, physicist, and mathematician, as the communications of the ACM once described him. He and others developed a fairly simple way of finding square roots. It goes like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #!/usr/bin/pugs
    use v6;

    my Num  $target = 9;
    my Num  $guess  = $target;

    while (abs( $guess**2 - $target ) &amp;gt; 0.005) {
        $guess += ( $target - $guess**2 ) / ( 2 * $guess );

        say $guess;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This version always finds the square root of 9, which conveniently is 3. This aids testing because I don&amp;rsquo;t have to remember a more interesting square root, for example, the square root of 2. When I run this, the output is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    5
    3.4
    3.0235294117647058823529411764705882352941
    3.0000915541313801785305561913481345845731
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last number is the square root of 9 accurate to three decimal places.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s what&amp;rsquo;s going on.&lt;/p&gt;

&lt;p&gt;Once Pugs is installed, you can use it in a shebang line (on Unix or Cygwin, at least). Otherwise, invoke the script through &lt;code&gt;pugs&lt;/code&gt; as you would for &lt;code&gt;perl&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ pugs newton
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To let Perl 6 know that I want Perl 6 and not Perl 5, I type &lt;code&gt;use v6;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In Perl 6, the basic primitive types are still scalar, array, and hash. There are also more types of scalars. In this case, I&amp;rsquo;m using the floating-point type Num for both the target (the number whose square root I want) and the guess (which I hope will improve until it is the square root of the target). I can use this syntax in Perl 5. In Perl 6 it will be the norm (or so I hope). I&amp;rsquo;ve used &lt;code&gt;my&lt;/code&gt; to limit the scope of the variables just as in Perl 5.&lt;/p&gt;

&lt;p&gt;Newton&amp;rsquo;s method always needs a guess. Without explaining, I&amp;rsquo;ll say that for square roots the guess makes little difference. To make it easy, I guessed the number itself. Obviously, that&amp;rsquo;s not a good guess, but it works eventually.&lt;/p&gt;

&lt;p&gt;The while loop goes until the square of the guess is close to the target. How close is up to me. I chose .005 to give about three places of accuracy.&lt;/p&gt;

&lt;p&gt;Inside the loop, the code improves the guess at each step using Newton&amp;rsquo;s formula. I won&amp;rsquo;t explain it at all. (I&amp;rsquo;ve resisted the strong temptation from my math-teacher days to explain a lot more. Be glad I resisted. But if you are curious, consult a calculus textbook. Or better yet, send me email. I&amp;rsquo;d love to say more!) I&amp;rsquo;ll present a more general form of the method soon, which may jog the memories of the calculus lovers in the audience, or not.&lt;/p&gt;

&lt;p&gt;Finally, at the end of each iteration, I used &lt;code&gt;say&lt;/code&gt; to print the answer. This beats writing: &lt;code&gt;print &amp;quot;$guess\n&amp;quot;;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Except for using &lt;code&gt;say&lt;/code&gt; and declaring the type of the numbers to be &lt;code&gt;Num&lt;/code&gt;, there&amp;rsquo;s not much to separate the above script from one I might have written in Perl 5. That&amp;rsquo;s okay. It&amp;rsquo;s about to get more Perl 6ish.&lt;/p&gt;

&lt;h3 id=&#34;an-exporting-module&#34;&gt;An Exporting Module&lt;/h3&gt;

&lt;p&gt;While it&amp;rsquo;s fine to have a script that finds square roots, it would be better to generalize this in a couple of ways. One good change is to make it a module so that others can share it. Another is to turn loose the power of Newton and look for other kinds of roots, like cube roots and other even more exotic ones.&lt;/p&gt;

&lt;p&gt;First, I&amp;rsquo;ll turn the script above into a module that exports a &lt;code&gt;newton&lt;/code&gt; sub. Then, I&amp;rsquo;ll tackle generalizing the method.&lt;/p&gt;

&lt;p&gt;When I&amp;rsquo;m finished, I want to be able to use the module like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #!/usr/bin/pugs

    use Newton;

    my $answer = newton(4);

    say $answer;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because &lt;code&gt;say&lt;/code&gt; is so helpful, I could combine the last two statements:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        say &amp;quot;{ newton(4) }&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s right, strings will run code if you put it in braces.&lt;/p&gt;

&lt;p&gt;The module, &lt;em&gt;Newton.pm&lt;/em&gt;, looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package Newton;
    use v6;

    sub newton(Num $target) is export {
        my Num  $guess  = $target;

        while (abs( $guess**2 - $target ) &amp;gt; 0.005) {
            $guess += ( $target - $guess**2 ) / ( 2 * $guess );
        }

        return $guess;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here begins the familiar package declaration borrowed from Perl 5. (In Perl 6 itself, &lt;code&gt;package&lt;/code&gt; identifies Perl 5 source code. The &lt;a href=&#34;https://metacpan.org/pod/v6&#34;&gt;v6&lt;/a&gt; module lets you run some Perl 6 code in Perl 5 programs.) Immediately following is &lt;code&gt;use v6;&lt;/code&gt;, just as in the original script.&lt;/p&gt;

&lt;p&gt;Declaring subs in Perl 6 doesn&amp;rsquo;t have to be any different than in Perl 5, but it should be. This one says it takes a numeric variable called &lt;code&gt;target&lt;/code&gt;. Such genuine prototypes allow for Perl 6 to report compilation errors when you call a sub with the wrong arguments. That single step will move Perl 6 onto the list of possible languages for a lot of large-scale application development shops.&lt;/p&gt;

&lt;p&gt;At the end of the declaration, just before the opening brace for the body, I included &lt;code&gt;is export&lt;/code&gt;. This puts &lt;code&gt;newton&lt;/code&gt; into the namespace of whoever uses the module (at least, if they use the module in the normal way; they could explicitly decline to take imports). There is no need to explicitly use &lt;code&gt;Exporter&lt;/code&gt; and set up &lt;code&gt;@EXPORT&lt;/code&gt; or its friends.&lt;/p&gt;

&lt;p&gt;The rest of the code is the same, except that it returns the answer and no longer proclaims its guess at each iteration.&lt;/p&gt;

&lt;h3 id=&#34;assigning-defaults&#34;&gt;Assigning Defaults&lt;/h3&gt;

&lt;p&gt;Adding genuine, compiler-enforced parameters to sub declarations is a giant leap forward for Perl. For many people, that particular looseness in Perl 5 keeps it out of any discussions about what language to use for a project. I experienced this unfortunate reality firsthand in my last job. There&amp;rsquo;s a lot more to declarations in Perl 6, though.&lt;/p&gt;

&lt;p&gt;Suppose I want to give the caller control over the accuracy of the method, yet I want to provide a sensible default if that caller doesn&amp;rsquo;t want to think of a good one. I might write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package Newton;
    use v6;

    sub newton(
        Num  $target,
        Num  :$epsilon = 0.005,  # note the colon
        Bool :$verbose = 0,
    ) is export {
        my Num  $guess  = $target;

        while (abs( $guess**2 - $target ) &amp;gt; $epsilon ) {
            $guess += ( $target - $guess**2 ) / ( 2 * $guess );
                    say $guess if $verbose;
        }

        return $guess;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here I&amp;rsquo;ve introduced two new optional parameters: &lt;code&gt;$verbose&lt;/code&gt;, for whether to print at each step (the default is to keep quiet) and &lt;code&gt;$epsilon&lt;/code&gt;, the Greek letter we math types often use for tolerances.&lt;/p&gt;

&lt;p&gt;While the caller might use this exactly as before, she now has options. She might say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $answer = newton(165, verbose =&amp;gt; 1, epsilon =&amp;gt; .00005);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This gives extra accuracy and prints the values at each iteration (which prints the value of the last iteration twice: once in the loop and again in the driving script). Note that the named parameters may appear in any order.&lt;/p&gt;

&lt;h3 id=&#34;making-assumptions&#34;&gt;Making Assumptions&lt;/h3&gt;

&lt;p&gt;Finally, Newton&amp;rsquo;s method can find roots for more things than just squares. To make this general requires a bit more work and some extra math (which I&amp;rsquo;ll again brush under the rug).&lt;/p&gt;

&lt;p&gt;It is easy enough to supply the function for which you want roots. For example, the squaring function could be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        sub f(Num $x) { $x**2 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, in the update line of the loop, write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $guess += ( $target - f($guess) ) / ( 2 * $guess );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Changing &lt;code&gt;f&lt;/code&gt; would change the roots you seek.&lt;/p&gt;

&lt;p&gt;The problem is on the far side of the division symbol. &lt;code&gt;2 * $guess&lt;/code&gt; depends on the function (it&amp;rsquo;s the first derivative, for those who care). I could require the caller to provide this, as in:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        sub fprime(Num $x) { 2 * $x }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then the update would be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $guess += ( $target - f($guess) ) / fprime($guess);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are two problems with this approach. First, you need a way for the caller to pass those functions into the sub. That&amp;rsquo;s actually pretty easy; just add parameters of type Code to the list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub newton(
        Num  $target,
        Code $f,
        Code $fprime,
        Num  :$epsilon = 0.005,
        Bool :$verbose = 0,
    ) is export {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second problem is that the caller may not know how to calculate &lt;code&gt;$fprime&lt;/code&gt;. Perhaps I should make calculus a prerequisite for using the module, but that just might scare away a few potential users. I want to provide a default, but the default depends on what the function is. If I knew what &lt;code&gt;$f&lt;/code&gt; was, I could estimate &lt;code&gt;$fprime&lt;/code&gt; for users.&lt;/p&gt;

&lt;p&gt;Perl 6 provides precisely this ability. Here&amp;rsquo;s the final module, a bit at a time:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package Newton;

    use v6;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s nothing new.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub approxfprime(Code $f, Num $x) {
        my Num $delta = 0.1;
        return ($f($x + $delta) - $f($x - $delta))/(2 * $delta);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For those who care (surely at least one person does), this is a second-order centered difference. For those who don&amp;rsquo;t, its an approximation suitable for use in the &lt;code&gt;newton&lt;/code&gt; sub. It takes a function and a number and returns an estimate of the value needed for division.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub newton(
        Num  $target,
        Code $f,
        Code :$fprime         = &amp;amp;approxfprime.assuming( f =&amp;gt; $f ),
        Num  :$epsilon        = 0.0005,
        Bool :$verbose        = 0,
    ) returns Num is export {
        my Num $guess  = $target / 2;

        while (abs($f($guess) - $target) &amp;gt; $epsilon) {

            $guess += ($target - $f($guess)) / $fprime($guess);

            say $guess if $verbose;
        }
        return $guess;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A script using this program could be as simple as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #!/usr/bin/pugs

    use Newton;

    sub f(Num $x) { return $x**3 }

    say &amp;quot;{ newton(8, \&amp;amp;f, verbose =&amp;gt; 1, epsilon =&amp;gt; .00005) }&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the caller must supply the function &lt;code&gt;f&lt;/code&gt;. The one in the example is for cube roots.&lt;/p&gt;

&lt;p&gt;If the caller provides the derivative as &lt;code&gt;fprime&lt;/code&gt;, I use it. Otherwise, as in the example, I use &lt;code&gt;approxfprime&lt;/code&gt;. Whereas a caller-supplied &lt;code&gt;fprime&lt;/code&gt; would take one number and return another, &lt;code&gt;approxfprime&lt;/code&gt; needs a number and a function. The function needed is the one the caller passed to &lt;code&gt;newton&lt;/code&gt;. How do you pass it on? Currying—that is, supplying one or more of the parameters of a function once, then using the simplified version after that.&lt;/p&gt;

&lt;p&gt;In Perl 6, you can obtain a reference to a sub by placing the sub sigil &lt;code&gt;&amp;amp;&lt;/code&gt; in front of the function&amp;rsquo;s name (providing it is in scope). To curry, add &lt;code&gt;.assuming&lt;/code&gt; to the end of that and supply values for one or more arguments in parentheses. All of this is harder to talk about than to do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Code :$fprime         = &amp;amp;approxfprime.assuming( f =&amp;gt; $f ),
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code means that the caller might supply a value. If this is the case, use it. Otherwise, use &lt;code&gt;approxfprime&lt;/code&gt; with the caller&amp;rsquo;s function in place of &lt;code&gt;f&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Perl 6 calling conventions are extremely well designed. Not only do they allow compile-time parameter checking, they also allow named parameters with or without complex defaults, even including curried default functions. This is going to be very powerful. In fact, with Pugs, it already is.&lt;/p&gt;

&lt;p&gt;There is a slightly more detailed version of the example from this article in the &lt;em&gt;examples/algorithms/&lt;/em&gt; directory of the Pugs distribution. It&amp;rsquo;s called &lt;em&gt;Newton.pm&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;disclaimer&#34;&gt;Disclaimer&lt;/h3&gt;

&lt;p&gt;As much as it pains me to say it, if you need heavy duty numerics, don&amp;rsquo;t code in pure Perl. Rather, use FORTRAN, C, or Perl with PDL. And be careful. Numerics is full of unexpected gotchas, which lead to poor performance or outright incorrect results. Unfortunately, Newton&amp;rsquo;s method, in the general case, is notoriously risky. When in doubt about numerics, do as I do and consult a professional in the field.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Generating UML and Sequence Diagrams</title>
      <link>http://localhost:1313/pub/2006/08/03/sequence-diagrams.html/</link>
      <pubDate>Thu, 03 Aug 2006 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2006/08/03/sequence-diagrams.html/</guid>
      <description>

&lt;p&gt;Imagine yourself in a meeting with management. You&amp;rsquo;re about to begin your third attempt to explain how to process online credit card payments. After a couple of sentences, you see some eyes glazing over. Someone says, &amp;ldquo;Perhaps you could draw us a picture.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Imagine me handling a recent request from my boss. He came in to the bat cave and said (in summary), &amp;ldquo;We want customers to sign up for email accounts without calling customer service. All the account creation code is in the customer care app.&amp;rdquo; It didn&amp;rsquo;t take long to find the relevant web screen, where the CSR presses Save to kick off the account creation, but there sure were a lot of layers between there and the final result. Keeping them in mind is hard enough when I&amp;rsquo;m deep in the problem. Three months from now, when an odd bug surfaces, it&amp;rsquo;ll be nearly impossible without the right memory aid.&lt;/p&gt;

&lt;p&gt;In both of these cases, the right diagram is the sequence diagram. (I&amp;rsquo;d show you mine for the situations above, but they&amp;rsquo;re secret.) Sequence diagrams clearly show the time flow of method or function calls between modules. For complex systems, these diagrams can save a lot of time&amp;ndash;like the time you and your fellow programmers spend during initial design, the time spent explaining what&amp;rsquo;s possible to management, the time you spend remembering how things work when you revisit an old system that needs a new feature, and especially the time it takes a new programmer in your shop to get up to speed.&lt;/p&gt;

&lt;p&gt;In short, sequence diagrams help with complex call stacks just as data model diagrams help with complex database schema.&lt;/p&gt;

&lt;p&gt;While the sequence diagram is useful to me, I don&amp;rsquo;t like on-screen drawing tools. Therefore, I wrote the original &lt;a href=&#34;https://metacpan.org/pod/UML::Sequence&#34;&gt;&lt;code&gt;UML::Sequence&lt;/code&gt;&lt;/a&gt; to make the drawings for me. With recent help from Dean Arnold, the current version has many nice features and is closer to standards compliance (but, both Dean and I prefer a useful diagram to a compliant one). Using &lt;code&gt;UML::Sequence&lt;/code&gt;, you can quickly make proposed diagrams of systems not yet built. You can even run it against existing programs to have it diagram what they actually do.&lt;/p&gt;

&lt;h3 id=&#34;reading-a-sequence-diagram&#34;&gt;Reading a Sequence Diagram&lt;/h3&gt;

&lt;p&gt;If you already know how to read sequence diagrams, you can skip to the next section.&lt;/p&gt;

&lt;p&gt;Because most uses of UML involve object-oriented projects, that&amp;rsquo;s where I&amp;rsquo;ve drawn my examples. Don&amp;rsquo;t think that objects are necessary for sequence diagrams. I&amp;rsquo;ve diagrammed many non-OO programs with it (including some in COBOL).&lt;/p&gt;

&lt;p&gt;A simple example will work best for a first look at UML sequence diagrams, so consider rolling two dice. My over-engineered solution gives a nice diagram to discuss. In it, I made each die an object of the &lt;code&gt;Die&lt;/code&gt; class and the pair of dice an object of the &lt;code&gt;DiePair&lt;/code&gt; class. To roll the dice, I wrote a little script. Here are these pieces:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package Die;
    use strict;

    sub new {
        my $class = shift;
        my $sides = shift || 6;
        return bless { SIDES =&amp;gt; $sides }, $class;
    }

    sub roll {
        my $self       = shift;
        $self-&amp;gt;{VALUE} = int( rand * $self-&amp;gt;{SIDES} ) + 1;

        return $self-&amp;gt;{VALUE};
    }

    1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Die&lt;/code&gt; constructor takes an optional number of sides for the new die object, but supplies six as a default. It bundles that number of sides into a hash reference, blesses, and returns it.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;roll()&lt;/code&gt; method makes a random number and uses it to pick a new value for the die, which it returns.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;DiePair&lt;/code&gt; is equally scintillating:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package DiePair;
    use strict;

    use Die;

    sub new {
        my $class     = shift;
        my $self      = {};
        $self-&amp;gt;{DIE1} = Die-&amp;gt;new( shift );
        $self-&amp;gt;{DIE2} = Die-&amp;gt;new( shift );

        return bless $self, $class;
    }

    sub roll {
        my $self   = shift;
        my $value1 = $self-&amp;gt;{DIE1}-&amp;gt;roll();
        my $value2 = $self-&amp;gt;{DIE2}-&amp;gt;roll();

        $self-&amp;gt;{TOTAL}   = $value1 + $value2;
        $self-&amp;gt;{DOUBLES} = ( $value1 == $value2 ) ? 1 : 0;

        return $self-&amp;gt;{TOTAL}, $self-&amp;gt;{DOUBLES};
    }

    1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The constructor makes two die objects and stores them in a hash reference, which it blesses and returns.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;roll()&lt;/code&gt; method rolls each die, storing the value, then totals them and decides whether the roll was doubles. It returns both total and doubles, saving the driver from having to call back for them.&lt;/p&gt;

&lt;p&gt;Rather than modeling a real game like craps, I use a small driver, which will simplify the resulting diagram.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #!/usr/bin/perl
    use strict;

    use DiePair;

    my $die_pair          = DiePair-&amp;gt;new(6, 6);
    my ($total, $doubles) = $die_pair-&amp;gt;roll();

    print &amp;quot;Your total is $total &amp;quot;;
    print &amp;quot;it was doubles&amp;quot; if $doubles;
    print &amp;quot;\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Figure 1 shows the sequence diagram for this driver.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_08_03_sequence-diagrams/roller.gif&#34; alt=&#34;the sequence diagram for the die roller&#34; /&gt;
&lt;em&gt;Figure 1. The sequence diagram for the die roller&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Each package has a box at the top of the diagram. The script is in the &lt;code&gt;main&lt;/code&gt; package (which is always Perl&amp;rsquo;s default). Time flows from top to bottom. Arrows represent method (or function) calls.&lt;/p&gt;

&lt;p&gt;The vertical boxes, or &lt;em&gt;activations&lt;/em&gt;, represent the life of a call. Between the activations are dashed lines called the &lt;em&gt;life lines&lt;/em&gt; of the objects.&lt;/p&gt;

&lt;p&gt;You can see that &lt;code&gt;main&lt;/code&gt; begins first (because its first activation is higher than the others). It calls &lt;code&gt;new()&lt;/code&gt; on the &lt;code&gt;DiePair&lt;/code&gt; class. That call lasts long enough for &lt;code&gt;DiePair&lt;/code&gt;&amp;rsquo;s constructor to call &lt;code&gt;new()&lt;/code&gt; on the &lt;code&gt;Die&lt;/code&gt; class twice.&lt;/p&gt;

&lt;p&gt;After making the objects, the script calls &lt;code&gt;roll()&lt;/code&gt; on the &lt;code&gt;DiePar&lt;/code&gt;, which forwards the request to the individual dice.&lt;/p&gt;

&lt;p&gt;This diagram is unorthodox. The boxes at the top &lt;em&gt;should&lt;/em&gt; represent individual instances, not classes. Sometimes I prefer this style because it compacts the diagram horizontally. Figure 2 shows a more orthodox diagram (divergent only in the lack of name underlining).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_08_03_sequence-diagrams/rollerinst.gif&#34; alt=&#34;a more orthodox UML diagram&#34; /&gt;
&lt;em&gt;Figure 2. A more orthodox UML diagram&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;You can see the individual &lt;code&gt;Die&lt;/code&gt; objects that the &lt;code&gt;DiePair&lt;/code&gt; instance aggregates, because there is now a box at the top for each object (use your imagination when thinking about the driver as an instance). The names do not come from the code; they are sequentially assigned from the class name.&lt;/p&gt;

&lt;p&gt;Diagrams like this are especially helpful when many classes interact. For instance, many of them start with a user event (like a button press on a GUI application) and show how the view communicates with the controller and how the controller in turn communicates with the data model.&lt;/p&gt;

&lt;p&gt;Another particularly useful application is for programs communicating via network sockets. In their diagrams, each program has a box, and the arrows represent writing on a socket. Note that UML sequence diagrams may also have dashed arrows, which show return values going back to callers. Unless there is something unusual about that value, there is no use to waste space on the diagram for those returns. However, in a network situation, showing the back and forth can be quite helpful. &lt;code&gt;UML::Sequence&lt;/code&gt; now has support for return arrows.&lt;/p&gt;

&lt;h3 id=&#34;using-uml-sequence&#34;&gt;Using UML::Sequence&lt;/h3&gt;

&lt;p&gt;Now that you understand how to read a sequence diagram, I can show you how to make them without mouse-driven drawing tools.&lt;/p&gt;

&lt;p&gt;Making diagrams with &lt;code&gt;UML::Sequence&lt;/code&gt; is a three-step process:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Create a program or a text file.&lt;/li&gt;
&lt;li&gt;Use &lt;em&gt;genericseq.pl&lt;/em&gt; to create an XML description of the diagram.&lt;/li&gt;
&lt;li&gt;Use a rendering script to turn the XML into an image file.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If the image is in the wrong format for your purposes, you might need an extra step to convert to another format.&lt;/p&gt;

&lt;h4 id=&#34;running-perl-programs&#34;&gt;Running Perl Programs&lt;/h4&gt;

&lt;p&gt;Here is how I generated Figure 1 above by running the driver program. If your program is in Perl, you can use this approach (see the next subsection for Java programs).&lt;/p&gt;

&lt;p&gt;First, create a file listing the subs you want to see in the diagram:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    DiePair::new
    DiePair::roll
    Die::new
    Die::roll
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I called this file &lt;em&gt;roller.methods&lt;/em&gt; to correspond to the script&amp;rsquo;s name, &lt;em&gt;roller&lt;/em&gt;. When you make your method list, remember that sequence diagrams are visual space hogs, so pick a short list of the most important methods.&lt;/p&gt;

&lt;p&gt;Then, run the program through the &lt;code&gt;genericseq.pl&lt;/code&gt; script:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ genericseq.pl UML::Sequence::PerlSeq roller.methods roller &amp;gt; roller.xml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://metacpan.org/pod/UML::Sequence::PerlSeq&#34;&gt;&lt;code&gt;UML::Sequence::PerlSeq&lt;/code&gt;&lt;/a&gt; uses the Perl debugger&amp;rsquo;s hooks to profile the code as it runs, watching for the methods listed in &lt;em&gt;roller.methods&lt;/em&gt;. The result is an XML file describing the calls that actually happened during this run.&lt;/p&gt;

&lt;p&gt;To turn this into a picture, use one of the image scripts:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ seq2svg.pl roller.xml &amp;gt; roller.svg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Obviously, &lt;code&gt;seq2svg.pl&lt;/code&gt; makes SVG images. If you have no way to view those, get Firefox 1.5, use a tool like the batik rasterizer, or use &lt;code&gt;seq2rast.pl&lt;/code&gt;, which makes PNG images directly using the &lt;a href=&#34;https://metacpan.org/pod/GD&#34;&gt;&lt;code&gt;GD&lt;/code&gt;&lt;/a&gt; module.&lt;/p&gt;

&lt;p&gt;If you want diagrams like Figure 2, use &lt;a href=&#34;https://metacpan.org/pod/UML::Sequence::PerlOOSeq&#34;&gt;&lt;code&gt;UML::Sequence::PerlOOSeq&lt;/code&gt;&lt;/a&gt; in place of &lt;code&gt;UML::Sequence::PerlSeq&lt;/code&gt; when you run &lt;code&gt;genericseq.pl&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;running-java-programs&#34;&gt;Running Java Programs&lt;/h4&gt;

&lt;p&gt;I wrote &lt;code&gt;UML::Sequence&lt;/code&gt; while working as a Java programmer, so I made it work on Java (at least sometimes it works). The process is similar to the above. First, make a methods file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ALL
    Roller
    DiePair
    Die
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here I use &lt;code&gt;ALL&lt;/code&gt; to mean all methods from the following classes. You can also list full signatures (but they have to be full, valid, and expressed in the internal signature format as if generated by &lt;code&gt;javap&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Then run &lt;code&gt;genericseq.pl&lt;/code&gt; with &lt;a href=&#34;https://metacpan.org/pod/UML::Sequence::JavaSeq&#34;&gt;UML::Sequence::JavaSeq&lt;/a&gt; in place of &lt;code&gt;UML::Sequence::PerlSeq&lt;/code&gt;. Of course, this requires you to have a Java development environment on your machine. In particular, it must be able to find &lt;em&gt;tools.jar&lt;/em&gt;, which provides the debugger hooks necessary to watch the calls.&lt;/p&gt;

&lt;p&gt;Produce the image from the resulting XML file as shown earlier for Perl programs.&lt;/p&gt;

&lt;h4 id=&#34;text-file-input&#34;&gt;Text File Input&lt;/h4&gt;

&lt;p&gt;While I pat myself on the back every time I make a sequence diagram of a running program, that&amp;rsquo;s not always (or even usually) practical. For instance, you might want to show the boss what you have planned for code you haven&amp;rsquo;t written yet. Alternately, you might have a program that is so complex that no amount of tweaking the methods file will restrict the diagram enough to make it useful.&lt;/p&gt;

&lt;p&gt;In these cases, there is a small text language you can use to specify the diagram. It is based on indentation and uses dot notation for method names. Here is a sample:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;At Home.Wash Car
    Garage.retrieve bucket
    Kitchen.prepare bucket
        Kitchen.pour soap in bucket
        Kitchen.fill bucket
    Garage.get sponge
    Garage.open door
    Driveway.apply soapy water
    Driveway.rinse
    Driveway.empty bucket
    Garage.close door
    Garage.replace sponge
    Garage.replace bucket
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each line will become an arrow in the final diagram (except the first line). Indentation indicates the call depth. The &amp;ldquo;class&amp;rdquo; name comes before the dot and the &amp;ldquo;method&amp;rdquo; name after it.&lt;/p&gt;

&lt;p&gt;There is no need for a methods file in this case, because presumably you didn&amp;rsquo;t bother to type things you didn&amp;rsquo;t care about. You may go directly to running &lt;code&gt;genericseq.pl&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ genericseq.pl UML::Sequence::SimpleSeq inputfile &amp;gt; wash.xml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once you have the XML file, render it as before.&lt;/p&gt;

&lt;h3 id=&#34;getting-fancy&#34;&gt;Getting Fancy&lt;/h3&gt;

&lt;p&gt;As I mentioned earlier, Dean Arnold recently added lots of cool features to amaze and impress your bosses and/or clients. In particular, he expanded the legal syntax for text outlines. Here is his sample of car washing with the new features:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AtHome.Wash Car
        /* the bucket is in the garage */
    Garage.retrieve bucket
    Kitchen.prepare bucket
        Kitchen.pour soap in bucket
        Kitchen.fill bucket
    Garage.get sponge
    Garage.checkDoor
            -&amp;gt; clickDoorOpener
        [ ifDoorClosed ] Garage.open door
    * Driveway.apply soapy water
    ! Driveway.rinse
    Driveway.empty bucket
    Garage.close door
    Garage.replace sponge
    Garage.replace bucket
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are several new features here:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;You can include UML annotations by using C-style comments, as shown on the second line of the example. Each annotation attaches to the following line as a footnote (or tooltip, if you install a third-party open source library).&lt;/li&gt;
&lt;li&gt;There is a &lt;code&gt;-&amp;gt;&lt;/code&gt; in front of &lt;code&gt;clickDoorOpener&lt;/code&gt;. This becomes an asynchronous message arrow. When &lt;code&gt;-&amp;gt;&lt;/code&gt; comes between a method and additional text, it indicates that a regular method is returning the value on the righthand side of the arrow. The return appears as a dashed arrow from the called activation back to the caller.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ifDoorClosed&lt;/code&gt; is in brackets, which mark a conditional in UML. These appear in the diagram in front of the method name.&lt;/li&gt;
&lt;li&gt;There is a star in front of &lt;code&gt;Driveway.apply&lt;/code&gt;, which indicates a loop construct in UML. (UML people call this &lt;em&gt;iteration&lt;/em&gt;.)&lt;/li&gt;
&lt;li&gt;There is an exclamation point in front of &lt;code&gt;Driveway.rinse&lt;/code&gt;, indicating urgency.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In addition to these changes to the outline syntax, both &lt;code&gt;seq2svg.pl&lt;/code&gt; and &lt;code&gt;seq2rast.pl&lt;/code&gt; now support options to control appearance (including colors) and to generate HTML imagemaps for raster versions of the diagrams. The imagemaps hyperlink diagram elements&amp;ndash;columns header and method call names&amp;ndash;to supporting documents. For example, clicking on the &lt;code&gt;Garage&lt;/code&gt; header will open &lt;em&gt;Garage.html&lt;/em&gt;, while clicking on &lt;code&gt;checkDoor&lt;/code&gt; will also open &lt;em&gt;Garage.html&lt;/em&gt;, but at the &lt;code&gt;#checkDoor&lt;/code&gt; anchor.&lt;/p&gt;

&lt;h3 id=&#34;summary&#34;&gt;Summary&lt;/h3&gt;

&lt;p&gt;UML Sequence diagrams are a great way to see how function or method calls (or network messages) flow through a multi-module application, whether it is object-oriented or not. Using &lt;code&gt;UML::Sequence&lt;/code&gt; and its helper scripts, you can make those diagrams without having to point and click in a drawing program.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://www.presicient.com/umlseq/deluxewash.html&#34;&gt;The imagemapped HTML version of car washing&lt;/a&gt; is viewable online.&lt;/p&gt;

&lt;p&gt;To read more about UML diagrams, check out the aptly named &lt;em&gt;UML Distilled&lt;/em&gt;, by Martin Fowler, available from your favorite bookseller.&lt;/p&gt;

&lt;p&gt;I recommend Walter Zorn&amp;rsquo;s &lt;a href=&#34;http://www.walterzorn.com/tooltip/tooltip_e.htm&#34;&gt;JavaScript, DHTML tooltips&lt;/a&gt; package to display embedded annotations.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://xml.apache.org/batik/&#34;&gt;Batik&lt;/a&gt; is an Apache project for managing and viewing SVG.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Still More Perl Lightning Articles</title>
      <link>http://localhost:1313/pub/2006/07/13/lightning-articles.html/</link>
      <pubDate>Thu, 13 Jul 2006 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2006/07/13/lightning-articles.html/</guid>
      <description>

&lt;p&gt;It has been common practice within the Perl community for ages to ship distributions with a &lt;em&gt;Makefile.PL&lt;/em&gt; so that the user will be able to install the packages when he retrieves them, either via the shell which the &lt;code&gt;CPAN/CPANPLUS&lt;/code&gt; modules offer or via manual CPAN download.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;Makefile.PL&lt;/em&gt; consists of meta-information, which in the case of the distribution &lt;a href=&#34;https://metacpan.org/pod/HTML::Tagset&#34;&gt;&lt;code&gt;HTML::Tagset&lt;/code&gt;&lt;/a&gt; is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; # This -*-perl-*- program writes the Makefile for installing this distribution.
 #
 # See &amp;quot;perldoc perlmodinstall&amp;quot; or &amp;quot;perldoc ExtUtils::MakeMaker&amp;quot; for
 # info on how to control how the installation goes.

 require 5.004;
 use strict;
 use ExtUtils::MakeMaker;

 WriteMakefile(
     NAME            =&amp;gt; &#39;HTML::Tagset&#39;,
     AUTHOR          =&amp;gt; &#39;Andy Lester &amp;lt;andy@petdance.com&amp;gt;&#39;,
     VERSION_FROM    =&amp;gt; &#39;Tagset.pm&#39;, # finds $VERSION
     ABSTRACT_FROM   =&amp;gt; &#39;Tagset.pm&#39;, # retrieve abstract from module
     PMLIBDIRS       =&amp;gt; [qw(lib/)],
     dist            =&amp;gt; { COMPRESS =&amp;gt; &#39;gzip -9f&#39;, SUFFIX =&amp;gt; &#39;gz&#39;, },
     clean           =&amp;gt; { FILES =&amp;gt; &#39;HTML-Tagset-*&#39; },
 );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of interest are the arguments to &lt;code&gt;WriteMakefile()&lt;/code&gt;, because they influence the &lt;em&gt;Makefile&lt;/em&gt; written by &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; after the user has invoked the usual build and install procedure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; % perl Makefile.PL
 % make
 % make test
 # make install
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;module-build-successor-of-extutils-makemaker&#34;&gt;&lt;code&gt;Module::Build&lt;/code&gt;, Successor of &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt;?&lt;/h3&gt;

&lt;p&gt;As Ken Williams grew tired of &lt;a href=&#34;https://metacpan.org/pod/ExtUtils::MakeMaker&#34;&gt;&lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt;&lt;/a&gt; and its portability issues, he invented &lt;a href=&#34;https://metacpan.org/pod/Module::Build&#34;&gt;&lt;code&gt;Module::Build&lt;/code&gt;&lt;/a&gt;, a successor of &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt;. One goal of &lt;code&gt;Module::Build&lt;/code&gt; is to run smoothly on most operating systems, because it takes advantage of creating Perl-valid syntax files only and does not rely upon crufty &lt;em&gt;Makefiles&lt;/em&gt;, which are often subject to misinterpretation, because so many incompatible flavors of &lt;code&gt;make&lt;/code&gt; exist in the wild.&lt;/p&gt;

&lt;p&gt;The current maintainer of &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt;, Michael G. Schwern, elaborated about this problem in his talk reachable via &amp;ldquo;&lt;a href=&#34;http://mungus.schwern.org/~schwern/talks/MakeMaker_Is_DOOMED/slides/&#34;&gt;MakeMaker is DOOMED&lt;/a&gt;.&amp;rdquo;&lt;/p&gt;

&lt;h3 id=&#34;module-build-distribution-skeleton&#34;&gt;&lt;code&gt;Module::Build&lt;/code&gt; Distribution &amp;ldquo;Skeleton&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;If you take in consideration the distribution &lt;code&gt;HTML::Tagset&lt;/code&gt; again, the rough skeleton suitable for &lt;code&gt;Module::Build&lt;/code&gt; having converted the &lt;em&gt;Makefile.PL&lt;/em&gt; by &lt;a href=&#34;https://metacpan.org/pod/Module::Build::Convert&#34;&gt;&lt;code&gt;Module::Build::Convert&lt;/code&gt;&lt;/a&gt; into a &lt;em&gt;Build.PL&lt;/em&gt;, the output would be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; # This -*-perl-*- program writes the Makefile for installing this distribution.
 #
 # See &amp;quot;perldoc perlmodinstall&amp;quot; or &amp;quot;perldoc ExtUtils::MakeMaker&amp;quot; for
 # info on how to control how the installation goes.
 # Note: this file has been initially generated by Module::Build::Convert 0.24_01

 require 5.004;
 use strict;
 use warnings;

 use Module::Build;

 my $build = Module::Build-&amp;gt;new
   (
    module_name =&amp;gt; &#39;HTML::Tagset&#39;,
    dist_author =&amp;gt; &#39;Andy Lester &amp;lt;andy@petdance.com&amp;gt;&#39;,
    dist_version_from =&amp;gt; &#39;Tagset.pm&#39;,
    add_to_cleanup =&amp;gt; [
                        &#39;HTML-Tagset-*&#39;
                      ],
    license =&amp;gt; &#39;unknown&#39;,
    create_readme =&amp;gt; 1,
    create_makefile_pl =&amp;gt; &#39;traditional&#39;,
   );

 $build-&amp;gt;create_build_script;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, while &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; prefers uppercased arguments, &lt;code&gt;Module::Build&lt;/code&gt; goes by entirely lowercased arguments, which obey the rule of least surprise by being as intuitive as a description can be.&lt;/p&gt;

&lt;p&gt;The build and installation procedure for a &lt;code&gt;Module::Build&lt;/code&gt; distribution is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; % perl Build.PL
 % perl Build
 % perl Build test
 # perl Build install
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;module-build-convert-s-state-of-operation&#34;&gt;&lt;code&gt;Module::Build::Convert&lt;/code&gt;&amp;rsquo;s State of Operation&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Module::Build::Convert&lt;/code&gt; actually does all of the background work and can be safely considered the back end, whereas &lt;code&gt;make2build&lt;/code&gt; is the practical front-end utility. &lt;code&gt;Module::Build::Convert&lt;/code&gt; currently exposes two kinds of operation: static approach and dynamic execution. The static approach parses the arguments contained within the &lt;em&gt;Makefile.PL&amp;rsquo;s&lt;/em&gt; &lt;code&gt;WriteMakefile()&lt;/code&gt; call, whereas dynamic execution runs the &lt;em&gt;Makefile.PL&lt;/em&gt; and captures the arguments provided to &lt;code&gt;WriteMakefile()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Module::Build::Convert&lt;/code&gt; parses statically by default, because the dynamic execution has the downside that code will be interpreted and the interpreted output will be written to the &lt;em&gt;Build.PL&lt;/em&gt;, so you have to conclude that the user of the distribution will end up with predefined values computed on the author&amp;rsquo;s system. This is something to avoid, whenever possible! If the parsing approach fails, perhaps looping endlessly on input, &lt;code&gt;Module::Build::Convert&lt;/code&gt; will reinitialize to perform dynamic execution of the &lt;em&gt;Makefile.PL&lt;/em&gt; instead.&lt;/p&gt;

&lt;h3 id=&#34;span-id-data-section-data-section-span&#34;&gt;&lt;span id=&#34;data_section&#34;&gt;Data Section&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Module::Build::Convert&lt;/code&gt; comes with a rather huge data section containing the argument conversion table, default arguments, sorting order, and begin and end code. If you wish to change this data, consider making a &lt;em&gt;~/.make2buildrc&lt;/em&gt; file by launching &lt;code&gt;make2build&lt;/code&gt; with the &lt;code&gt;-rc&lt;/code&gt; switch. &lt;em&gt;Do not&lt;/em&gt; edit the &lt;code&gt;Data&lt;/code&gt; section within &lt;code&gt;Module::Build::Convert&lt;/code&gt; directly, unless you are sure you want to submit a patch.&lt;/p&gt;

&lt;h4 id=&#34;argument-conversion&#34;&gt;Argument Conversion&lt;/h4&gt;

&lt;p&gt;On the left-hand side is the &lt;code&gt;MakeMaker&lt;/code&gt;&amp;rsquo;s argument name, and on the right-hand side the &lt;code&gt;Module::Build&lt;/code&gt;&amp;rsquo;s equivalent.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; NAME                  module_name
 DISTNAME              dist_name
 ABSTRACT              dist_abstract
 AUTHOR                dist_author
 VERSION               dist_version
 VERSION_FROM          dist_version_from
 PREREQ_PM             requires
 PL_FILES              PL_files
 PM                    pm_files
 MAN1PODS              pod_files
 XS                    xs_files
 INC                   include_dirs
 INSTALLDIRS           installdirs
 DESTDIR               destdir
 CCFLAGS               extra_compiler_flags
 EXTRA_META            meta_add
 SIGN                  sign
 LICENSE               license
 clean.FILES           @add_to_cleanup
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;default-arguments&#34;&gt;Default Arguments&lt;/h4&gt;

&lt;p&gt;These are default &lt;code&gt;Module::Build&lt;/code&gt; arguments to added. Arguments with a leading &lt;code&gt;#&lt;/code&gt; are ignored.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; #build_requires       HASH
 #recommends           HASH
 #conflicts            HASH
 license               unknown
 create_readme         1
 create_makefile_pl    traditional
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;sorting-order&#34;&gt;Sorting Order&lt;/h4&gt;

&lt;p&gt;This is the sorting order for &lt;code&gt;Module::Build&lt;/code&gt; arguments.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; module_name
 dist_name
 dist_abstract
 dist_author
 dist_version
 dist_version_from
 requires
 build_requires
 recommends
 conflicts
 PL_files
 pm_files
 pod_files
 xs_files
 include_dirs
 installdirs
 destdir
 add_to_cleanup
 extra_compiler_flags
 meta_add
 sign
 license
 create_readme
 create_makefile_pl
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;begin-code&#34;&gt;Begin Code&lt;/h4&gt;

&lt;p&gt;Code that precedes converted &lt;code&gt;Module::Build&lt;/code&gt; arguments. &lt;code&gt;$(UPPERCASE)&lt;/code&gt; are stubs being substituted by &lt;code&gt;Module::Build&lt;/code&gt; code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; use strict;
 use warnings;

 use Module::Build;

 $MAKECODE

 my $b = Module::Build-&amp;gt;new
 $INDENT(
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;end-code&#34;&gt;End Code&lt;/h4&gt;

&lt;p&gt;Code that follows converted &lt;code&gt;Module::Build&lt;/code&gt; arguments. &lt;code&gt;$(UPPERCASE)&lt;/code&gt; are stubs being substituted by &lt;code&gt;Module::Build&lt;/code&gt; code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $INDENT);

 $b-&amp;gt;create_build_script;

 $MAKECODE
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;make2build-basic-usage&#34;&gt;&lt;code&gt;make2build&lt;/code&gt; Basic Usage&lt;/h3&gt;

&lt;p&gt;Using &lt;code&gt;make2build&lt;/code&gt; is as easy as launching it in the directory of the distribution of which &lt;em&gt;Makefile.PL&lt;/em&gt; you wish to convert.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% make2build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may also provide the full path to the distribution, assuming, for example, you didn&amp;rsquo;t &lt;code&gt;cd&lt;/code&gt; directly into the distribution directory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% make2build /path/to/HTML-Tagset*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In both cases, the command will convert any found &lt;em&gt;Makefile.PL&lt;/em&gt; files and will generate no output because &lt;code&gt;make2build&lt;/code&gt; acts quiet by default.&lt;/p&gt;

&lt;h3 id=&#34;make2build-switches&#34;&gt;&lt;code&gt;make2build&lt;/code&gt; Switches&lt;/h3&gt;

&lt;p&gt;As &lt;code&gt;make2build&lt;/code&gt; aims to be a proper script, it of course, provides both the &lt;code&gt;-h&lt;/code&gt; (help screen) and &lt;code&gt;-V&lt;/code&gt; (version) switches.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; % make2build -h
 % make2build -V
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In case you end up with a mangled &lt;em&gt;Build.PL&lt;/em&gt; written, you can examine the parsing process by launching &lt;code&gt;make2build&lt;/code&gt; with the &lt;code&gt;-d&lt;/code&gt; switch, enabling the pseudo-interactive debugging mode.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; % make2build -d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Should you not like the indentation length or judge it to be too small, increase it via the &lt;code&gt;-l&lt;/code&gt; switch followed by an integer.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; % make2build -l length
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you don&amp;rsquo;t agree with the sorting order predefined in &lt;code&gt;Module::Build::Convert&lt;/code&gt;, you may enforce the native sorting order, which strives to arrange standard arguments with those seen available in the &lt;code&gt;Makefile.PL&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; % make2build -n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The argument conversion table, default arguments to add, the sorting order of the arguments, and the begin and end code aren&amp;rsquo;t absolute, either. Change them by invoking &lt;code&gt;make2build&lt;/code&gt; with the &lt;code&gt;-rc&lt;/code&gt; switch to create a resource configuration file in the home directory of the current user; that is likely &lt;em&gt;~/.make2build.rc&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; % make2build -rc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While &lt;code&gt;make2build&lt;/code&gt; is quiet by default, there are two verbosity levels. To enforce verbosity level 1, launch &lt;code&gt;make2build&lt;/code&gt; with &lt;code&gt;-v&lt;/code&gt;. To enforce verbosity level 2, use &lt;code&gt;-vv&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;With &lt;code&gt;-v&lt;/code&gt;, the code will warn about &lt;em&gt;Makefile.PL&lt;/em&gt; options it does not understand or skips. With &lt;code&gt;-vv&lt;/code&gt;, it will accumulate &lt;code&gt;-v&lt;/code&gt; output and the entire generated &lt;em&gt;Build.PL&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; % make2build -v
 % make2build -vv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may execute the &lt;em&gt;Makefile.PL&lt;/em&gt; in first place, but such usage is deprecated because &lt;code&gt;Module::Build::Convert&lt;/code&gt; downgrades automatically when needed.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; % make2build -x (deprecated)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;swinging-with-perl&#34;&gt;Swinging with Perl&lt;/h3&gt;

&lt;p&gt;Phil Crow&lt;/p&gt;

&lt;p&gt;Perl does not have a native graphical user interface (GUI) toolkit. So we use all manner of existing GUI tools in front of our Perl applications. Often we use a web browser. We have long had Perl/Tk and other libraries based on C/C++. Now we can also use Java&amp;rsquo;s Swing toolkit with similar ease.&lt;/p&gt;

&lt;p&gt;In my sample application, when the user presses a button, Perl evaluates an arithmetic expression from the input text box. The result appears in another text box. I&amp;rsquo;ll show the code for this application a piece at a time with a discussion after each piece. To see the whole thing, look in the examples directory of the &lt;a href=&#34;https://metacpan.org/pod/Java::Swing&#34;&gt;&lt;code&gt;Java::Swing&lt;/code&gt;&lt;/a&gt; distribution.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #!/usr/bin/perl
    use strict; use warnings;

    BEGIN {
        $ENV{CLASSPATH} .= &#39;:/path/to/Java/Swing/java&#39;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Java::Swing&lt;/code&gt; needs certain Java classes to be in the class path before it loads, so I&amp;rsquo;ve appended a path to those classes in a &lt;code&gt;BEGIN&lt;/code&gt; block (this block must come before using &lt;code&gt;Java::Swing&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Java::Swing;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This innocuous statement magically sets up namespaces for each Java Swing component, among other things.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $expression  = JTextField-&amp;gt;new();
    my $answer      = JTextField-&amp;gt;new( { columns =&amp;gt; 10 } );
    my $submit      = JButton   -&amp;gt;new(&amp;quot;Evaluate&amp;quot;);
    my $frame       = JFrame    -&amp;gt;new();
    my $root_pane   = $frame-&amp;gt;getContentPane();
    my $south_panel = JPanel-&amp;gt;new();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After using &lt;code&gt;Java::Swing&lt;/code&gt;, you can refer to Swing components as Perl classes. You can even pass named parameters to their constructors, as shown for the second &lt;code&gt;JTextField&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $south_panel-&amp;gt;add(JLabel-&amp;gt;new(&amp;quot;Answer:&amp;quot;), &amp;quot;West&amp;quot;);
    $south_panel-&amp;gt;add($answer,                &amp;quot;Center&amp;quot;);
    $south_panel-&amp;gt;add($submit,                &amp;quot;East&amp;quot;);

    $root_pane-&amp;gt;add($expression,  &amp;quot;North&amp;quot;);
    $root_pane-&amp;gt;add($south_panel, &amp;quot;South&amp;quot;);

    $frame-&amp;gt;setSize(300, 100);
    $frame-&amp;gt;show();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Most work with the components is the same as in any Java program. If you don&amp;rsquo;t understand the above code, consult a good book on Swing (like the one from O&amp;rsquo;Reilly).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $swinger = Java::Swing-&amp;gt;new();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This creates a &lt;code&gt;Java::Swing&lt;/code&gt; instance to connect event listeners and to control the event loop.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $swinger-&amp;gt;connect(
        &amp;quot;ActionListener&amp;quot;, $submit, { actionPerformed =&amp;gt; \&amp;amp;evaluate }
    );

    $swinger-&amp;gt;connect(
        &amp;quot;WindowListener&amp;quot;, $frame, { windowClosing =&amp;gt; \&amp;amp;ending }
    );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Connection is simple. Pass the listener type, the object to listen to, and a hash of code references to call back as events arrive.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $swinger-&amp;gt;start();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Start the event loop. After this, the program passively waits for event callbacks. It stops when one of the callbacks stops the event loop.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub evaluate {
        my $sender_name = shift;
        my $event       = shift;

        $answer-&amp;gt;setText(eval $expression-&amp;gt;getText());
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;My evaluation is simple. I retrieve the text from the expression &lt;code&gt;JTextField&lt;/code&gt;, &lt;code&gt;eval&lt;/code&gt; it, and pass the result to &lt;code&gt;setText&lt;/code&gt; on the answer &lt;code&gt;JTextField&lt;/code&gt;. Using &lt;code&gt;eval&lt;/code&gt; raises possible security concerns, so use it wisely.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub ending {
        $swinger-&amp;gt;stop();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the user closes the window, I stop the event loop by calling &lt;code&gt;stop&lt;/code&gt; on the &lt;code&gt;Java::Swing&lt;/code&gt; instance gained earlier. This kills the program.&lt;/p&gt;

&lt;p&gt;With &lt;code&gt;Java::Swing&lt;/code&gt;, you can build Swing apps in Perl with some important bits of syntactic sugar. First, you don&amp;rsquo;t need to have separate Java files or inline sections. Second, you can pass named arguments to constructors. Finally, you can easily connect event listeners to Perl callback code.&lt;/p&gt;

&lt;h3 id=&#34;scriptify-your-module&#34;&gt;Scriptify Your Module&lt;/h3&gt;

&lt;p&gt;Josh McAdams&lt;/p&gt;

&lt;p&gt;Recently during an MJD talk at Chicago.pm, I saw a little Perl trick that was so amazingly simple and yet so useful that it was hard to believe that more mongers in the crowd hadn&amp;rsquo;t heard of it. The trick involved taking your module and adding a driver routine to it so the module could run as a script.&lt;/p&gt;

&lt;p&gt;To illustrate, start with an example module that contains two utility subroutines that convert weights between pounds and kilograms. The subroutines accept some number and multiplies it by a conversion factor.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  package WeightConverter;

  use strict;
  use warnings;
  use constant LB_PER_KG =&amp;gt; 2.20462262;
  use constant KG_PER_LB =&amp;gt; 1/LB_PER_KG;

  sub kilograms_to_pounds { $_[0] * LB_PER_KG; }

  sub pounds_to_kilograms { $_[0] * KG_PER_LB; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Assuming that the real module has a little error checking and POD, this module would serve you just fine. However, what if you decided that we needed to be able to easily do weight conversions from the command line? One option would be to write a Perl script that used &lt;code&gt;WeightConverter&lt;/code&gt;. If that seems like too much effort, there is a one-liner that would do conversions.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  perl -MWeightConverter -e &#39;print WeightConverter::kilograms_to_pounds(1),&amp;quot;\n&amp;quot;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This would do the trick, but it is a lot to remember and isn&amp;rsquo;t very fun to type. There is a lot of benefit available from saving some form of script, and believe it or not, the module can hold that script. All that you have to do is write some driver subroutine and then call that subroutine if the module is not being used by another script. Here is an example driver for &lt;code&gt;WeightConverter&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This example driver script just loops through the command-line arguments and tries to find instances where the argument contains either a &lt;code&gt;k&lt;/code&gt; or &lt;code&gt;p&lt;/code&gt; equal to some value. Based on whether or not you are starting with pounds or kilograms, it calls the appropriate subroutine and prints the results.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  sub run {
    for (@ARGV) {
      if(/^[-]{0,2}(k|p)\w*=(.+)$/) {
        $1 eq &#39;k&#39; ?
          print &amp;quot;$2 kilograms is &amp;quot;, kilograms_to_pounds($2), &amp;quot; pounds\n&amp;quot; :
          print &amp;quot;$2 pounds is &amp;quot;, pounds_to_kilograms($2), &amp;quot; kilograms\n&amp;quot; ;
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now all that is left is to tell the module to run the &lt;code&gt;run&lt;/code&gt; subroutine if someone has run the module on its own. This is as easy as adding one line somewhere in the main body of the module.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  run unless caller;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All this statement does is execute the &lt;code&gt;run&lt;/code&gt; subroutine unless the &lt;code&gt;caller&lt;/code&gt; function returns a value. &lt;code&gt;caller&lt;/code&gt; will only return true if &lt;code&gt;WeightConverter&lt;/code&gt; is being used in another script. Now, this module is usable in other scripts as well as on the command line.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $&amp;gt; perl WeightConverter.pm -kilos=2 -pounds=145 -k=.345
  2 kilograms is 4.40924524 pounds
  145 pounds is 65.7708937051548 kilograms
  .345 kilograms is 0.7605948039 pounds
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mocks-in-your-test-fixtures&#34;&gt;Mocks in Your Test Fixtures&lt;/h3&gt;

&lt;p&gt;by chromatic&lt;/p&gt;

&lt;p&gt;Since writing &lt;code&gt;Test::MockObject&lt;/code&gt;, I&amp;rsquo;ve used it in nearly every complex test file I&amp;rsquo;ve written. It makes my life much easier to be able to control only what I need for the current group of tests.&lt;/p&gt;

&lt;p&gt;I wish I&amp;rsquo;d written &lt;code&gt;Test::MockObject::Extends&lt;/code&gt; earlier than I did; that module allows you to decorate an existing object with a mockable wrapper. It works just as the wrapped object does, but if you add any mocked methods, it will work like a regular mock object.&lt;/p&gt;

&lt;p&gt;This is very useful when you don&amp;rsquo;t want to go through all of the overhead of setting up your own mock object but do want to override one or two methods. (It&amp;rsquo;s almost always the right thing to do instead of using &lt;code&gt;Test::MockObject.&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;Another very useful test module is &lt;code&gt;Test::Class&lt;/code&gt;. It takes more work to understand and to use than &lt;code&gt;Test::More&lt;/code&gt;, but it pays back that investment by allowing you to group, reuse, and organize tests in the same way you would group, reuse, and organize objects in your code. Instead of writing your tests procedurally, from the start to the end of a test file, you organize them into classes.&lt;/p&gt;

&lt;p&gt;This is most useful when you&amp;rsquo;ve organized your code along similar lines. If you have a base class with a lot of behavior and a handful of subclasses that add and override a little bit of behavior, write a &lt;code&gt;Test::Class&lt;/code&gt;-based test for the base class and smaller tests that inherit from the base test for the subclasses.&lt;/p&gt;

&lt;p&gt;Goodbye, duplicate code.&lt;/p&gt;

&lt;h4 id=&#34;fixtures&#34;&gt;Fixtures&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Test::Class&lt;/code&gt; encourages you to group related tests into test methods. This allows you to override and extend those groups of tests in test subclasses. (Good OO design principles apply here; tests are still just code, after all.) One of the benefits of grouping tests in this way is that you can use test fixtures.&lt;/p&gt;

&lt;p&gt;A test fixture is another method that runs before every test method. You can use them to set up the test environment&amp;ndash;creating a new object to test, resetting test data, and generally making sure that tests don&amp;rsquo;t interfere with each other.&lt;/p&gt;

&lt;p&gt;A standard test fixture might resemble:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  sub make_fixture :Test( setup )
  {
      my $self        = shift;
      $self-&amp;gt;{object} = $self-&amp;gt;test_class()-&amp;gt;new();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Assuming that there&amp;rsquo;s a &lt;code&gt;test_class()&lt;/code&gt; method that returns the name of the class being tested, this fixture creates a new instance before every test method and stores it as the &lt;code&gt;object&lt;/code&gt; attribute. The test methods can then fetch this as normal.&lt;/p&gt;

&lt;h4 id=&#34;putting-them-together&#34;&gt;Putting Them Together&lt;/h4&gt;

&lt;p&gt;I recently built some tests for a large system using &lt;code&gt;Test::Class&lt;/code&gt;. Some of the tests had mockable features&amp;ndash;they dealt with file or database errors, for example. I found myself creating a lot of little &lt;code&gt;Test::MockObject::Extends&lt;/code&gt; instances within most of the tests.&lt;/p&gt;

&lt;p&gt;Then inspiration struck. Duplication is bad. Repetition is bad. Factor it out into one place.&lt;/p&gt;

&lt;p&gt;The insight was quick and sudden. If &lt;code&gt;Test::MockObject::Extends&lt;/code&gt; is transparent (and if it isn&amp;rsquo;t, please file a bug&amp;ndash;I&amp;rsquo;ll fix it), I can use it in the test fixture all the time and then be able to mock whenever I want without doing any setup. I changed my fixture to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  sub make_fixture :Test( setup )
  {
      my $self        = shift;
          my $object      = $self-&amp;gt;test_class()-&amp;gt;new();
      $self-&amp;gt;{object} = Test::MockObject::Extends-&amp;gt;new( $object );
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The rest of my code remained unchanged, except that now I could delete several identical lines from several test methods.&lt;/p&gt;

&lt;p&gt;Do note that, for this to work, you must adhere to good OO design principles in the code being tested. Don&amp;rsquo;t assume that &lt;code&gt;ref&lt;/code&gt; is always what you think it should be (and use the &lt;code&gt;isa()&lt;/code&gt; method instead).&lt;/p&gt;

&lt;p&gt;Sure, this is a one-line trick, but it removed a lot of busy work from my life and it illustrates two interesting techniques for managing tests. If you need simpler, more precise mocks, use &lt;code&gt;Test::MockObject::Extends&lt;/code&gt;. If you need better organization and less duplication in your test files, use &lt;code&gt;Test::Class&lt;/code&gt;. Like all good test modules, they work together almost flawlessly.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Testing Files and Test Modules</title>
      <link>http://localhost:1313/pub/2005/12/08/test_files.html/</link>
      <pubDate>Thu, 08 Dec 2005 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2005/12/08/test_files.html/</guid>
      <description>

&lt;p&gt;For the last several years, there has been more and more emphasis on automated testing. No self-respecting CPAN author can post a distribution without tests. Yet some things are hard to test. This article explains how writing &lt;code&gt;Test::Files&lt;/code&gt; gave me a useful tool for validating one module&amp;rsquo;s output and taught me a few things about the current state of Perl testing.&lt;/p&gt;

&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;My boss put me to work writing a moderately large suite in Perl. Among many other things, it needed to perform check out and commit operations on CVS repositories. In a quest to build quality tests for that module, I wrote &lt;a href=&#34;https://metacpan.org/pod/Test::Files&#34;&gt;&lt;code&gt;Test::Files&lt;/code&gt;&lt;/a&gt;, which is now on CPAN. This article explains how to use that module and, perhaps more importantly, how it tests itself.&lt;/p&gt;

&lt;h3 id=&#34;using-test-files&#34;&gt;Using &lt;code&gt;Test::Files&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;To use &lt;code&gt;Test::Files&lt;/code&gt;, first use &lt;a href=&#34;https://metacpan.org/pod/Test::More&#34;&gt;&lt;code&gt;Test::More&lt;/code&gt;&lt;/a&gt; and tell it how many tests you want to run.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use strict;
use warnings;
use Test::More tests =&amp;gt; 5;
use Test::Files;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After you use the module, there are four things it can help you do:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Compare one file to a string or to another file.&lt;/li&gt;
&lt;li&gt;Make sure that directories have the files you expect them to have.&lt;/li&gt;
&lt;li&gt;Compare all the files in one directory to all the files in another directory.&lt;/li&gt;
&lt;li&gt;Exclude some things from consideration.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;single-files&#34;&gt;Single Files&lt;/h3&gt;

&lt;p&gt;In the simplest case, you have written a file. Now it is time to validate it. That could look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;file_ok($file_name, &amp;quot;This is the\ntext\n&amp;quot;,
    &amp;quot;file one contents&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;file_ok&lt;/code&gt; function takes two (or optionally, and preferably, three) arguments. The first is the name of the file you want to validate. The second is a text string containing the text that should be in the file. The third is the name of the test. In the rush of writing, I&amp;rsquo;m likely to fail to mention the test names at some point, so let me say up front that all of the tests shown here take a name argument. Including a name makes finding the test easier.&lt;/p&gt;

&lt;p&gt;If the file agrees with the string, the test passes with only an OK message. Otherwise, the test will fail and diagnostic messages will show where the two differed. The diagnostic output is really the reason to use &lt;code&gt;Test::Files&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Some, including myself, prefer to check one file against another. I put one version in the distribution. The other one, my tests write. To compare two files, use:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;compare_ok($file1, $file2, $name);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As with &lt;code&gt;file_ok&lt;/code&gt;, if the files are the same, &lt;code&gt;Test::Files&lt;/code&gt; only reports an OK message. Failure shows where the files differ.&lt;/p&gt;

&lt;h3 id=&#34;directory-structures&#34;&gt;Directory Structures&lt;/h3&gt;

&lt;p&gt;Sometimes, you need to validate that certain files are present in a directory. Other times, you need to make that check exclusive so that only known files are present. Finally, you might want to know that not only is the directory structure is the same, but that the files contain the same data.&lt;/p&gt;

&lt;p&gt;To look for some files in a directory by name, write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dir_contains_ok($dir, [qw(list files here)], $name);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will succeed, even if the directory has some other files you weren&amp;rsquo;t looking for.&lt;/p&gt;

&lt;p&gt;To ensure that your list is exclusive, add only to the function name:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dir_only_contains_ok($dir, [qw(list all files here)], $name);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Both of these report a list of absent files if they fail due to them. The exclusive form also reports a list of unexpected files, if it sees any.&lt;/p&gt;

&lt;h3 id=&#34;directory-contents&#34;&gt;Directory Contents&lt;/h3&gt;

&lt;p&gt;If knowing that certain file names are present is not enough, use the &lt;code&gt;compare_dirs_ok&lt;/code&gt; function to check the contents of all files in one directory against files in another directory. A typical module might build one directory during &lt;code&gt;make test&lt;/code&gt;, with the other built ahead of time and shipped with the distribution.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;compare_dirs_ok($test_built, $shipped, $name);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will generate a separate diagnostic &lt;code&gt;diff&lt;/code&gt; output for each pair of files that differs, in addition to listing files that are missing from either distribution. (If you need to know which files are missing from the built directory, either reverse the order of the directories or use &lt;code&gt;dir_only_contains_ok&lt;/code&gt; in addition to &lt;code&gt;compare_dirs_ok&lt;/code&gt;. This is a bug and might eventually be fixed.) Even though this could yield many diagnostic reports, all of those separate failures only count as one failed test.&lt;/p&gt;

&lt;p&gt;There are many times when testing &lt;em&gt;all&lt;/em&gt; files in the directories is just wrong. In these cases, it is best to use &lt;a href=&#34;https://metacpan.org/pod/File::Find&#34;&gt;&lt;code&gt;File::Find&lt;/code&gt;&lt;/a&gt; or an equivalent, putting an exclusion criterion at the top of your wanted function and a call to &lt;code&gt;compare_ok&lt;/code&gt; at the bottom. This probably requires you to use &lt;code&gt;no_plan&lt;/code&gt; with &lt;code&gt;Test::More&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Test::More qw(no_plan);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Test::More&lt;/code&gt; wants to know the exact number of tests you are about to run. If you tell it the wrong number, the test harness will think something is wrong with your test script, causing it to report failures. To avoid this confusion, use &lt;code&gt;no_plan&lt;/code&gt;&amp;ndash;but keep in mind that plans are there for a reason. If your test dies, the plan lets the harness know how many tests it missed. If you have &lt;code&gt;no_plan&lt;/code&gt;, the harness doesn&amp;rsquo;t always have enough information to keep score. Thus, you should put such tests in separate scripts, so that the harness can count your other tests properly.&lt;/p&gt;

&lt;h3 id=&#34;filtering&#34;&gt;Filtering&lt;/h3&gt;

&lt;p&gt;While the above list of functions seemed sufficient during planning, reality set in as soon as I tried it out on my CVS module. I wanted to compare two CVS repositories: one ready for shipment with the distribution, the other built during testing. As soon as I tried the test it failed, not because the operative parts of the module were not working, but because the CVS timestamps differed between the two versions.&lt;/p&gt;

&lt;p&gt;To deal with cosmetic differences that should not count as failures, I added two functions to the above list: one for single files and the other for directories. These new functions accept a code reference that receives each line prior to comparison. It performs any needed alterations, and then returns a line suitable for comparison. My example function below redacts the offending timestamps. With the filtered versions in place, the tests pass and fail when they should.&lt;/p&gt;

&lt;p&gt;My final tests for the CVS repository directories look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;compare_dirs_filter_ok(
    &#39;t/cvsroot/CVSROOT&#39;,
    &#39;t/sampleroot/CVSROOT&#39;,
    \&amp;amp;chop_dates,
    &amp;quot;make repo&amp;quot;
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code reference argument comes between the directory names and the test name. The &lt;code&gt;chop_dates&lt;/code&gt; function is not particularly complex. It removes two kinds of dates favored by CVS, as shown in its comments.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub chop_dates {
    my $line =  shift;

    #  2003.10.15.13.45.57 (year month day hour minute sec)
    $line    =~ s/\d{4}(.\d\d){5}//;

    #  Thu Oct 16 18:00:28 2003
    $line    =~ s/\w{3} \w{3} \d\d? \d\d:\d\d:\d\d \d{4}//;

    return $line;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This shows the general behavior of filters. They receive a line of input which they must not directly change. Instead, they must return a new, corrected line.&lt;/p&gt;

&lt;p&gt;In addition to &lt;code&gt;compare_dirs_filter_ok&lt;/code&gt; for whole directory structures, there is also &lt;code&gt;compare_filter_ok&lt;/code&gt;, which works similarly for single file comparisons. (There is no &lt;code&gt;file_filter_ok&lt;/code&gt;, but maybe there should be.)&lt;/p&gt;

&lt;h3 id=&#34;testing-a-test-module&#34;&gt;Testing a Test Module&lt;/h3&gt;

&lt;p&gt;The most interesting part of writing &lt;code&gt;Test::Files&lt;/code&gt; was learning how to test it. Thanks to Schwern, I learned about &lt;a href=&#34;https://metacpan.org/pod/Test::Builder::Tester&#34;&gt;&lt;code&gt;Test::Builder::Tester&lt;/code&gt;&lt;/a&gt;, which eases the problems inherent in testing a Perl test module.&lt;/p&gt;

&lt;p&gt;The difficulty with testing Perl tests has to do with how they normally run. The venerable test harness scheme expects test scripts to produce pass and fail data on standard out and diagnostic help on standard error. This is a great design. The simplicity is exactly what you would expect from a Unix-inspired tool. Yet, it poses a problem for testing test modules.&lt;/p&gt;

&lt;p&gt;When eventual users use the test module, their harness expects it to write quite specific things to standard out and standard error. Among the things that must go to standard out are a sequence of lines such as &lt;code&gt;ok 1&lt;/code&gt;. When you write a test of the test module, its harness also expects to see this sort of data on standard out and standard error. Having two different sources of &lt;code&gt;ok 1&lt;/code&gt; is highly confusing, not least to the harness, which chokes on such duplications.&lt;/p&gt;

&lt;p&gt;Test module writers need a scheme to trap the output from the module being tested, check it for correct content, and report that result onto the actual standard channels for the harness to see. This is tricky, requiring care in diversion of file handles at the right moments without the knowledge of the module whose output is diverted. Doing this by hand is inelegant and prone to error. Further, multiple test scripts might have to recreate home-rolled solutions (introducing the oldest of known coding sins: duplication of code). Finally, the diagnostic output, in the event of failure, from homemade diverters is unlikely to be helpful when tests of the test module fail.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Enter &lt;code&gt;Test::Builder::Tester&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;To help us test testers, Mark Fowler collected some code from Schwern, and used it to make &lt;code&gt;Test::Builder::Tester&lt;/code&gt;. With it, tests of test modules are relatively painless and their failure diagnostics are highly informative. Here are two examples from the &lt;code&gt;Test::Files&lt;/code&gt; test suite. The first shows a file comparison that should pass:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;test_out(&amp;quot;ok 1 - passing file&amp;quot;);
compare_ok(&amp;quot;t/ok_pass.dat&amp;quot;, &amp;quot;t/ok_pass.same.dat&amp;quot;,
    &amp;quot;passing file&amp;quot;);
test_test(&amp;quot;passing file&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This test should work, generating &lt;code&gt;ok 1 - passing file&lt;/code&gt; on standard output. To tell &lt;code&gt;Test::Builder::Tester&lt;/code&gt; what the standard output should be, I called &lt;code&gt;test_out&lt;/code&gt;. After the test, I called &lt;code&gt;test_test&lt;/code&gt; with only the name of my test. (To avoid confusion, I made the test names the same.)&lt;/p&gt;

&lt;p&gt;Between the call to &lt;code&gt;test_out&lt;/code&gt; and the one to &lt;code&gt;test_test&lt;/code&gt;, &lt;code&gt;Test::Builder::Tester&lt;/code&gt; diverted the regular output channels so the harness won&amp;rsquo;t see them.&lt;/p&gt;

&lt;p&gt;The second example shows a failed test and how to check both standard out and standard error. The later contains the diagnostic data the module should generate.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;test_out(&amp;quot;not ok 1 - failing file&amp;quot;);
$line = line_num(+9);
test_diag(&amp;quot;    Failed test (t/03compare_ok.t at line $line)&amp;quot;,
&#39;+---+--------------------+-------------------+&#39;,
&#39;|   |Got                 |Expected           |&#39;,
&#39;| Ln|                    |                   |&#39;,
&#39;+---+--------------------+-------------------+&#39;,
&#39;|  1|This file           |This file          |&#39;,
&#39;*  2|is for 03ok_pass.t  |is for many tests  *&#39;,
&#39;+---+--------------------+-------------------+&#39;  );
compare_ok(&amp;quot;t/ok_pass.dat&amp;quot;, &amp;quot;t/ok_pass.diff.dat&amp;quot;,
    &amp;quot;failing file&amp;quot;);
test_test(&amp;quot;failing file&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Two new functions appear here. First, &lt;code&gt;line_num&lt;/code&gt; returns the current line number plus or minus an offset. Because failing tests report the line number of the failure, checking standard error for an exact match requires matching that number. Yet, no one wants his tests to break because he inserted a new line at the top of the script. With &lt;code&gt;line_num&lt;/code&gt;, you can obtain the line number of the test relative to where you are. Here, there are nine lines between the call to &lt;code&gt;line_num&lt;/code&gt; and the actual test.&lt;/p&gt;

&lt;p&gt;The other new function is &lt;code&gt;test_diag&lt;/code&gt;. It allows you to check the standard error output, where diagnostic messages appear. The easiest way to use it is to provide each line of output as a separate parameter.&lt;/p&gt;

&lt;h3 id=&#34;summary&#34;&gt;Summary&lt;/h3&gt;

&lt;p&gt;Now you know how to use &lt;code&gt;Test::Files&lt;/code&gt; and how to test modules that implement tests. There is one final way I use &lt;code&gt;Test::Files&lt;/code&gt;. I use it outside of module testing any time I want to know how the contents of text files in two directory hierarchies compare. With this, I can quickly locate differences in archives, for example, enabling me to debug builders of those archives. In one example, I used it compare more than 400 text files in two WebSphere .ear archives. My program had only about 30 operative lines (there were also comments and blank lines) and performed the comparison in under five seconds. This is testament to the leverage of Perl and CPAN.&lt;/p&gt;

&lt;p&gt;(Since doing that comparison, I have moved to a new company. In the process I exchanged WebSphere for &lt;code&gt;mod_perl&lt;/code&gt; and am generally happier with the latter.)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Symbol Table Manipulation</title>
      <link>http://localhost:1313/pub/2005/03/17/symtables.html/</link>
      <pubDate>Thu, 17 Mar 2005 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2005/03/17/symtables.html/</guid>
      <description>

&lt;p&gt;Having almost achieved the state of perfect laziness, one of my favorite modules is &lt;a href=&#34;https://metacpan.org/pod/Class::DBI::mysql&#34;&gt;Class::DBI::mysql&lt;/a&gt;. It makes MySQL database tables seem like classes, and their rows like objects. This completely relieves me from using SQL in most cases. This article explains how &lt;code&gt;Class::DBI::mysql&lt;/code&gt; carries out its magic. Instead of delving into the complexities of &lt;code&gt;Class::DBI::mysql&lt;/code&gt;, I will use a simpler case study: &lt;a href=&#34;https://metacpan.org/pod/Class::Colon&#34;&gt;Class::Colon&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;One of my favorite modules from CPAN is &lt;code&gt;Class::DBI::mysql&lt;/code&gt;. With it, I can almost forget I&amp;rsquo;m working with a database. Here&amp;rsquo;s an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/perl
use strict; use warnings;

package Users;

use base &#39;Class::DBI::mysql&#39;;

Users-&amp;gt;set_db(&#39;Main&#39;, &#39;dbi:mysql:rt3&#39;, &#39;rt_user&#39;, &#39;rt_pass&#39;);
Users-&amp;gt;set_up_table(&#39;Users&#39;);

package main;

my @column_names = qw( Name RealName );
print &amp;quot;@column_names\n&amp;quot;;
print &amp;quot;-&amp;quot; x 30 . &amp;quot;\n&amp;quot;;

my $user_iter = Users-&amp;gt;retrieve_all();

while (my $row = $user_iter-&amp;gt;next) {
    print $row-&amp;gt;Name, &amp;quot; &amp;quot;, $row-&amp;gt;RealName, &amp;quot;\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Except for the MySQL connection information, no trace of SQL or databases remains.&lt;/p&gt;

&lt;p&gt;My purpose here is not really to introduce you to this beautiful module. Instead, I&amp;rsquo;ll explain how to build façades like this. To do so, I&amp;rsquo;ll work through another, simpler CPAN module called &lt;code&gt;Class::Colon&lt;/code&gt;. It turns colon-delimited files into classes and their lines into objects. Here&amp;rsquo;s an example from a checkbook application. This program computes the balance of an account on a user-supplied date or the end of time if the user doesn&amp;rsquo;t supply one.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/perl
use strict; use warnings;

use Getopt::Std;
use Date;
use Class::Colon Trans =&amp;gt; [ qw(
    status type date=Date amount desc category memo
) ];

our $opt_d;
getopt(&#39;d&#39;);
my $date       = Date-&amp;gt;new($opt_d) if $opt_d;

my $account    = shift or die &amp;quot;usage: $0 [-d date] account_file\n&amp;quot;;
my $trans_list = Trans-&amp;gt;READ_FILE($account);
my $balance    = 0;

foreach my $trans (@$trans_list) {
    if (not defined $date or $date &amp;gt;= $trans-&amp;gt;date) {
        $balance += $trans-&amp;gt;amount;
    }
}

print &amp;quot;balance = $balance\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the use statement for &lt;code&gt;Class::Colon&lt;/code&gt;, I told it the name of the class to build (&lt;code&gt;Trans&lt;/code&gt;), followed by a list of fields in the order they appear in the file. The date field is really an object itself, so I used &lt;code&gt;=Date&lt;/code&gt; after the field name. This told &lt;code&gt;Class::Colon&lt;/code&gt; that a class named &lt;code&gt;Date&lt;/code&gt; will handle the date field. If the &lt;code&gt;Date&lt;/code&gt; class constructor were not named &lt;code&gt;new&lt;/code&gt;, I would have written &lt;code&gt;date=Date=constructor_name&lt;/code&gt;. My &lt;code&gt;Date&lt;/code&gt; class is primitive at best, it only provides comparisons like greater than. It only does that for dates in one format. I won&amp;rsquo;t embarrass myself further by showing it.&lt;/p&gt;

&lt;p&gt;After shifting in the name of the account file, the code calls &lt;code&gt;READ_FILE&lt;/code&gt; through &lt;code&gt;Trans&lt;/code&gt;, which &lt;code&gt;Class::Colon&lt;/code&gt; defined. This returns a list of &lt;code&gt;Trans&lt;/code&gt; objects. The fields in these objects are the ones given in the &lt;code&gt;Class::Colon&lt;/code&gt; use statement. They are easy to access through their named subroutines.&lt;/p&gt;

&lt;p&gt;The rest of the program loops through the transactions list checking dates. If the user didn&amp;rsquo;t give a date, or the current transaction happened before the user&amp;rsquo;s date, the program adds that amount to the total. Finally, it reports the balance.&lt;/p&gt;

&lt;p&gt;Though the example shows only the lookup access, you can easily change values. All of the accessors retrieve and store. Calling &lt;code&gt;WRITE_FILE&lt;/code&gt; puts the updated records back onto the disk.&lt;/p&gt;

&lt;p&gt;Other methods help with colon-delimited records. Some let you work with handles instead of file names. Others help you parse and produce strings so that you can drive your own input and output. See the &lt;code&gt;Class::Colon&lt;/code&gt; perldoc for details. (No, colon is not the only delimiter.)&lt;/p&gt;

&lt;h3 id=&#34;let-the-games-begin&#34;&gt;Let the Games Begin&lt;/h3&gt;

&lt;p&gt;Both &lt;code&gt;Class::DBI::mysql&lt;/code&gt; and &lt;code&gt;Class::Colon&lt;/code&gt; build classes at run time which look like any other classes. How do they do this? They manipulate symbol tables directly. To see what this means, I want to start small. Suppose I have a variable name like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $extremely_long_variable_indicator_string;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s not something I want to type often. I could make an alias in two steps like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;our $elvis;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, I declare an identifier with a better name. I must make it global. If strict is on, I should use &lt;code&gt;our&lt;/code&gt; to do this (though there are other older ways that also work). Lexical variables (the ones declared with my) don&amp;rsquo;t live in symbol tables, so the tricks below won&amp;rsquo;t work with them.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*elvis = \$extremely_long_variable_indicator_string;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I can point &lt;code&gt;$elvis&lt;/code&gt; to the longer version. The key is the &lt;code&gt;*&lt;/code&gt; sigil. It refers to the symbol table entry for &lt;code&gt;elvis&lt;/code&gt; (the name without any sigils). This line stores a reference to &lt;code&gt;$extremely_long_variable_indicator_string&lt;/code&gt; in the symbol table under &lt;code&gt;$elvis&lt;/code&gt;, but it doesn&amp;rsquo;t affect other entries like &lt;code&gt;@elvis&lt;/code&gt; or &lt;code&gt;%elvis&lt;/code&gt;. Now, both scalars point to the same data, so &lt;code&gt;$elvis&lt;/code&gt; is a genuine alias for the longer name. It is not just a copy.&lt;/p&gt;

&lt;p&gt;Unless you work with mean-spirited colleagues, or are into self-destructive behavior, you probably don&amp;rsquo;t need an alias just to gain a shorter name. However, the technique works in other situations you might actually encounter. In particular, it is the basis for the API simplification provided by &lt;code&gt;Class::Colon&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To understand what &lt;code&gt;Class::Colon&lt;/code&gt; does, remember that the subroutine is a primitive type in Perl. You can store subs just as you do variables. For instance, I could store a subroutine reference like this (the sigil for subs is &lt;code&gt;&amp;amp;&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $abbr;
$abbr = \&amp;amp;some_long_sub_name;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and use it to call the subroutine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my @answer = $abbr-&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, I have made a new scalar variable, &lt;code&gt;$abbr&lt;/code&gt;, which holds a reference to the subroutine. This is not quite the same as directly manipulating the symbol table, but you can do that too:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*alias     = \&amp;amp;some_long_sub_name;
my @retval = alias();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead of storing a reference to the subroutine in a variable, this code stores the subroutine in the symbol table itself. This means that subsequent code can access the subroutine as if it had declared the subroutine with its new name itself. Adjusting the symbol table is not really easier to read or write than storing a reference, but, in modules like &lt;code&gt;Class::Colon&lt;/code&gt;, symbol table changes are the essential step to simplifying the caller&amp;rsquo;s API.&lt;/p&gt;

&lt;h3 id=&#34;classes-from-sheer-magic&#34;&gt;Classes from Sheer Magic&lt;/h3&gt;

&lt;p&gt;The previous example demonstrated how to make symbol table entries whenever you want. These can save typing and/or make things more readable. The standard module &lt;a href=&#34;https://metacpan.org/pod/English&#34;&gt;English&lt;/a&gt; uses this technique to give meaningful English names to the standard punctuation variables (like &lt;code&gt;$_&lt;/code&gt;). You want more, though. You want to build classes out of thin air during run time.&lt;/p&gt;

&lt;p&gt;The key to fabricating classes is to realize that a class is just a package and a package is really just a symbol table (more or less). That, and the fact that symbol tables autovivify, is all you need to carry off hugely helpful deceptions like &lt;code&gt;Class::DBI::mysql&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;what-use-really-does&#34;&gt;What &lt;code&gt;use&lt;/code&gt; really does&lt;/h4&gt;

&lt;p&gt;This subsection explains how to pass data during a &lt;code&gt;use&lt;/code&gt; statement. If you already understand the &lt;code&gt;import&lt;/code&gt; subroutine, feel free to skip to the next section.&lt;/p&gt;

&lt;p&gt;When you use a module in Perl, you can provide information for that module to use during loading. While &lt;code&gt;Class::DBI::mysql&lt;/code&gt; waits for you to call routines before setting up classes, &lt;code&gt;Class::Colon&lt;/code&gt; does it during loading by implementing an import method.&lt;/p&gt;

&lt;p&gt;Whenever someone &lt;code&gt;use&lt;/code&gt;s your module, Perl calls its &lt;code&gt;import&lt;/code&gt; method (if it has one). &lt;code&gt;import&lt;/code&gt; receives the name of the class the caller used, plus all of the arguments provided by the caller.&lt;/p&gt;

&lt;p&gt;In the checkbook example above, the caller used &lt;code&gt;Class::Colon&lt;/code&gt; with this statement:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Class::Colon Trans =&amp;gt; [ qw(
    status type date=Date amount desc category memo
) ];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;import&lt;/code&gt; method of the &lt;code&gt;Class::Colon&lt;/code&gt; package receives the following as a result:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The string &lt;code&gt;Class::Colon&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;A list with two elements. First, the string &lt;code&gt;Trans&lt;/code&gt;. Second, a reference to the array which lists the fields.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The top of the &lt;code&gt;import&lt;/code&gt; routine stores these as shown below.&lt;/p&gt;

&lt;h4 id=&#34;inserting-into-non-existent-symbol-tables&#34;&gt;Inserting into non-existent symbol tables&lt;/h4&gt;

&lt;p&gt;The main magic of &lt;code&gt;Class::Colon&lt;/code&gt; happens in the &lt;code&gt;import&lt;/code&gt; routine. Here&amp;rsquo;s how that looks:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub import {
    my $class = shift;
    my %fakes = @_;

    foreach my $fake (keys %fakes) {
        no strict;
        *{&amp;quot;$fake\::NEW&amp;quot;}     = sub { return bless {}, shift; };

        foreach my $proxy_method qw(
                read_file  read_handle  objectify delim
                write_file write_handle stringify
        ) {
            my $proxy_name   = $fake  . &amp;quot;::&amp;quot; . uc $proxy_method;
            my $real_name    = $class . &amp;quot;::&amp;quot; .    $proxy_method;
            *{&amp;quot;$proxy_name&amp;quot;} = \&amp;amp;{&amp;quot;$real_name&amp;quot;};
        }

        my @attributes;
        foreach my $col (@{$fakes{$fake}}) {
            my ($name, $type, $constructor)  = split /=/, $col;
            *{&amp;quot;$fake\::$name&amp;quot;} = _make_accessor($name, $type, $constructor);
            push @attributes, $name;
        }
        $simulated_classes{$fake} = {ATTRS =&amp;gt; \@attributes, DELIM =&amp;gt; &#39;:&#39;};
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After shifting the arguments into meaningful variable names, the main loop walks through each requested class (the list of fakes). Inside the loop it disables &lt;code&gt;strict&lt;/code&gt;, because the necessary uses of so many symbolic references would upset it.&lt;/p&gt;

&lt;p&gt;There are four steps in the fabrication of each class:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Make the constructor&lt;/li&gt;
&lt;li&gt;Make the class methods&lt;/li&gt;
&lt;li&gt;Make the accessor methods&lt;/li&gt;
&lt;li&gt;Store the attribute names in order&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The constructor is about as simple as possible and the same for every fabricated class. It returns a hash reference blessed into the requested class. The cool thing is that you can insert code into a symbol table that doesn&amp;rsquo;t exist in advance. This constructor will be &lt;code&gt;NEW&lt;/code&gt;. (By convention, &lt;code&gt;Class::Colon&lt;/code&gt; uses uppercase names for its methods to avoid name collisions with the user&amp;rsquo;s fields).&lt;/p&gt;

&lt;p&gt;This code requires a little bit of careful quoting. Saying &lt;code&gt;*{&amp;quot;$fake\::NEW&amp;quot;}&lt;/code&gt; tells Perl to make an entry in the new package&amp;rsquo;s symbol table under &lt;code&gt;NEW&lt;/code&gt;. The backslash suppresses variable interpolation. While &lt;code&gt;$fake&lt;/code&gt; needs interpolation, interpolating &lt;code&gt;$fake::NEW&lt;/code&gt; would just yield &lt;code&gt;undef&lt;/code&gt;, because this is its first definition here.&lt;/p&gt;

&lt;p&gt;Perl has already done the hard part by the time it stores the constructor. It has brought the package into existence. Now it&amp;rsquo;s just a matter of making some aliases.&lt;/p&gt;

&lt;p&gt;For each provided method, the code makes an entry in the symbol table of the fabricated class. Those entries point to the methods of the &lt;code&gt;Class::Colon&lt;/code&gt; package, which serve as permanent shared delegates for all fabricated classes.&lt;/p&gt;

&lt;p&gt;Similarly, it builds an accessor for each attribute supplied by the caller in the &lt;code&gt;use&lt;/code&gt; statement. These routines require a bit of customization to look up the proper attribute name and to deal with object construction. Hence, there is a small routine called &lt;code&gt;_make_accessor&lt;/code&gt; which returns the proper closure for each accessor.&lt;/p&gt;

&lt;p&gt;Finally, it makes an entry for the new class in the master list of simulated classes. This allows easy lookup by name when calling class methods through the fabricated names. Note that there is nothing in the &lt;code&gt;import&lt;/code&gt; routine that limits the caller to one invocation. Further &lt;code&gt;use&lt;/code&gt; statements can bring additional classes to life. Alternatively, the caller can request several new classes with a single &lt;code&gt;use&lt;/code&gt; statement by including multiple hash keys.&lt;/p&gt;

&lt;p&gt;In the standard case, &lt;code&gt;_make_accessor&lt;/code&gt; works like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub _make_accessor {
    my $attribute   = shift;
    return sub {
        my $self            = shift;
        my $new_val         = shift;
        $self-&amp;gt;{$attribute} = $new_val if defined $new_val;
        return $self-&amp;gt;{$attribute};
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The actual routine is a bit more complex, so it can handle construction of attributes which are objects. Note that the value of &lt;code&gt;$attribute&lt;/code&gt;, which is in scope when the closure is created, will be kept with the sub and used whenever it is called. The actual code is a fairly standard Perl dual-use accessor. It assigns a new value to the attribute if the caller has passed it in. It always returns the value of the attribute.&lt;/p&gt;

&lt;h4 id=&#34;what-class-colon-provides&#34;&gt;What &lt;code&gt;Class::Colon&lt;/code&gt; provides&lt;/h4&gt;

&lt;p&gt;Just for sake of completeness, here is how &lt;code&gt;Class::Colon&lt;/code&gt; turns a string into a set of objects. Note the heavy use of methods through their previously-entered symbol table names.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub objectify {
    my $class    = shift;
    my $string   = shift;
    my $config   = $simulated_classes{$class};
    my $col_list = $config-&amp;gt;{ATTRS};

    my $new_object = $class-&amp;gt;NEW();
    my @cols       = split /$config-&amp;gt;{DELIM}/, $string;
    foreach my $i (0 .. @cols - 1) {
        my $method = $col_list-&amp;gt;[$i];
        $new_object-&amp;gt;$method($cols[$i]);
    }
    return $new_object;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All fabricated classes share this method (and the other class methods of &lt;code&gt;Class::Colon&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Recall that &lt;code&gt;NEW&lt;/code&gt; returns a blessed hash reference with nothing in it. In &lt;code&gt;objectify&lt;/code&gt;, the loop fills in the attributes by calling their accessors. This ensures the proper construction of any object attributes. Callers access &lt;code&gt;objectify&lt;/code&gt; indirectly when they call &lt;code&gt;READ_FILE&lt;/code&gt; and its cousins. They can also use it directly through its &lt;code&gt;OBJECTIFY&lt;/code&gt; alias.&lt;/p&gt;

&lt;h3 id=&#34;summary&#34;&gt;Summary&lt;/h3&gt;

&lt;p&gt;By making entries into symbol tables, you can create aliases for data that is hard to name. Further, you can create new symbol tables simply by referring to them. This allows you to build classes on the fly. Modules like &lt;code&gt;Class::DBI::mysql&lt;/code&gt; and &lt;code&gt;Class::Colon&lt;/code&gt; do this to provide classes representing tabular data.&lt;/p&gt;

&lt;p&gt;There are other uses of these techniques. For example, &lt;a href=&#34;https://metacpan.org/pod/Memoize&#34;&gt;Memoize&lt;/a&gt; wraps an original function with a cache scheme, storing the wrapped version in place of the original in the caller&amp;rsquo;s own symbol table. For functions which return the same result whenever the arguments are the same, this can save time. &lt;a href=&#34;https://metacpan.org/pod/Exporter&#34;&gt;Exporter&lt;/a&gt; does even more sophisticated work to pollute the caller&amp;rsquo;s symbol table with symbols from a used package. At heart, these schemes are similar to the one shown above. By carefully performing symbol table manipulations in modules, you can often greatly simplify an API, making client code easier to read, write, and maintain.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bringing Java into Perl</title>
      <link>http://localhost:1313/pub/2003/11/07/java.html/</link>
      <pubDate>Fri, 07 Nov 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/11/07/java.html/</guid>
      <description>

&lt;p&gt;In this article, I will show how to bring Java code into a Perl program with &lt;code&gt;Inline::Java&lt;/code&gt;. I won&amp;rsquo;t probe the internals of &lt;code&gt;Inline&lt;/code&gt; or &lt;code&gt;Inline::Java&lt;/code&gt;, but I will tell you what you need to make a Java class available in a program or module. The program/module distinction is important only in one small piece of syntax, which I will point out.&lt;/p&gt;

&lt;p&gt;The article starts with the Java code to be glued into Perl, then shows several approaches for doing so. First, the code is placed directly into a Perl program. Second, the code is placed into a module used by a program. Finally, the code is accessed via a small Perl proxy in the module.&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-java-code-the-java-code-span&#34;&gt;&lt;span id=&#34;the_java_code&#34;&gt;The Java Code&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Consider the following Java class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public class Hi {

        String greeting;

        public Hi(String greeting) {
            this.greeting = greeting;
        }

        public void setGreeting(String newGreeting) {
            greeting = newGreeting;
        }

        public String getGreeting() {
            return greeting;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This class is for demonstration only. Each of its objects is nothing but a wrapper for the string passed to the constructor. The only operations are accessors for that one string. Yet with this, we will learn most of what we need to know to use Java from Perl. Later, we will add a few features, to show how arrays are handled. That&amp;rsquo;s not as interesting as it sounds, since &lt;code&gt;Inline::Java&lt;/code&gt; almost always does all of the work without help.&lt;/p&gt;

&lt;h3 id=&#34;span-id-a-program-a-program-span&#34;&gt;&lt;span id=&#34;a_program&#34;&gt;A Program&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Since we&amp;rsquo;re talking about Perl, there is more than one way to incorporate our trivial Java class into a Perl program. (Vocabulary Note: Some people call Perl programs &amp;ldquo;scripts.&amp;rdquo; I try not to.) Here, I&amp;rsquo;ll show the most direct approach. Subsequent sections move to more and more indirect approaches, which are more often useful in practice.&lt;/p&gt;

&lt;p&gt;Not surprisingly, the most direct approach is the simplest to understand. See if you can follow this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #!/usr/bin/perl
    use strict; use warnings;

    use Inline Java =&amp;gt; &amp;lt;&amp;lt;&#39;EOJ&#39;;
    public class Hi {
        // The class body is shown in the Java Code above
    }
    EOJ

    my $greeter = Hi-&amp;gt;new(&amp;quot;howdy&amp;quot;);
    print $greeter-&amp;gt;getGreeting(), &amp;quot;\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Java class is the one above, so I have omitted all but the class declaration. The Perl code just wraps it, so it is tiny. To use &lt;code&gt;Inline::Java&lt;/code&gt;, say &lt;code&gt;use Inline Java =&amp;gt; code&lt;/code&gt; where &lt;code&gt;code&lt;/code&gt; tells &lt;code&gt;Inline&lt;/code&gt; where to look for the code. In this case, the code follows inline (clever naming, huh?). Note that single-quote context is safest here. There are other ways to include the code; we&amp;rsquo;ll see my favorite way later. The overly curious are welcome to consult the perldoc for all of the others.&lt;/p&gt;

&lt;p&gt;Once &lt;code&gt;Inline::Java&lt;/code&gt; has worked its magic &amp;ndash; and it is highly magical &amp;ndash; we can use the Java &lt;code&gt;Hi&lt;/code&gt; class as if it was a Perl package. &lt;code&gt;Inline::Java&lt;/code&gt; provides several ways to construct Java objects. I usually use the one shown here; namely, I pretend the Java constructor is called &lt;code&gt;new&lt;/code&gt;, just like many Perl constructors are. In honor of Java, you might rather say &lt;code&gt;my $greeter = new Hi(&amp;quot;howdy&amp;quot;);&lt;/code&gt;, but I usually avoid this indirect object form. You can even call the constructor by the class name as in &lt;code&gt;my $greeter = Hi-&amp;gt;Hi(&amp;quot;howdy&amp;quot;);&lt;/code&gt; (or, you could even say the pathological &lt;code&gt;my $greeter = Hi Hi(&amp;quot;howdy&amp;quot;);&lt;/code&gt;). Class methods are accessed just like the constructor, except that their names are the Java method names. Instance methods are called through an object reference, as if the reference were a Perl object.&lt;/p&gt;

&lt;p&gt;Note that &lt;code&gt;Inline::Java&lt;/code&gt; performs type conversions for us, so we can pass and receive Java primitive types in the appropriate Perl variables. This carries over to arrays, etc. When you think about what must be going on under the hood, you&amp;rsquo;ll realize what a truly magical module this is.&lt;/p&gt;

&lt;h3 id=&#34;span-id-a-module-a-module-span&#34;&gt;&lt;span id=&#34;a_module&#34;&gt;A Module&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;I often say that most Perl code begins life in a program. As time goes by, the good parts of that code, the ones that can be reused, are factored out into modules. Suppose our greeter is really popular, so many programs want to use it. We don&amp;rsquo;t want to have to include the Java code in each one (and possibly require each program to compile its own copy of the class file). Hence, we want a module. My module looks a lot like my earlier program, except for two features. First, I changed the way &lt;code&gt;Inline&lt;/code&gt; looks for the code, which has nothing to do with whether the code is in a program or a module. Second, reaching class methods from any package other than &lt;code&gt;main&lt;/code&gt; requires careful &amp;ndash; though not particularly difficult &amp;ndash; qualification of the method name.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package Hi;
    use strict; use warnings;

    use Inline Java =&amp;gt; &amp;quot;DATA&amp;quot;;

    sub new {
        my $class    = shift;
        my $greeting = shift;
        return Hi::Hi-&amp;gt;new($greeting);
    }

    1;

    __DATA__
    __Java__
    public class Hi {
        // The class body is shown in The Java Code above
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The package starts like all good packages, by using &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;warnings&lt;/code&gt;. The &lt;code&gt;use Inline&lt;/code&gt; statement is almost like the previous one, but the code lives in the &lt;code&gt;__DATA__&lt;/code&gt; segment instead of actually being inline. Note that when you put the code in the &lt;code&gt;__DATA__&lt;/code&gt; segment, you must include a marker for your language so that &lt;code&gt;Inline&lt;/code&gt; can find it. There are usually several choices for each language&amp;rsquo;s marker; I chose &lt;code&gt;__Java__&lt;/code&gt;. This allows &lt;code&gt;Inline&lt;/code&gt; to glue from multiple languages into one source file.&lt;/p&gt;

&lt;p&gt;The constructor is needed so that the caller does not need to know they are interfacing with &lt;code&gt;Inline::Java&lt;/code&gt;. They call the constructor with &lt;code&gt;Hi-&amp;gt;new(&amp;quot;greeting&amp;quot;)&lt;/code&gt; as they would for a typical package called &lt;code&gt;Hi&lt;/code&gt;. Yet, the module&amp;rsquo;s constructor must do a bit of work to get the right object for the caller. It starts by retrieving the arguments, then returns the result of the unusual call &lt;code&gt;Hi::Hi-&amp;gt;new(...)&lt;/code&gt;. The first &lt;code&gt;Hi&lt;/code&gt; is for the Perl package and the second is for the Java class; both are required. Just as in the program from the last section, there are multiple ways to call the constructor. I chose the direct method with the name &lt;code&gt;new&lt;/code&gt;. You could use the indirect object form and/or call the method by the class name. The returned object can be used as normal, so I just pass it back to the caller. All instance methods are passed directly through &lt;code&gt;Inline::Java&lt;/code&gt; without help from &lt;code&gt;Hi.pm&lt;/code&gt;. If there were class methods (declared with the &lt;code&gt;static&lt;/code&gt; keyword in Java), I would either have to provide a wrapper, or the caller would have to qualify the names. Neither solution is particularly difficult, but I favor the wrapper, to keep the caller&amp;rsquo;s effort to a minimum. This is my typical laziness at work. Since there will likely be several callers, and I will have to write them, I want to push any difficult parts into the module.&lt;/p&gt;

&lt;p&gt;If you need to adapt the behavior of the Java object for your Perl audience, you may insert routines in &lt;code&gt;Hi.pm&lt;/code&gt; to do that. For instance, perhaps you want a more typical Perl accessor, instead of the &lt;code&gt;get&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; pair used in the Java code. In this case, you must make your own genuine Perl object and proxy through it to the Java class. That might look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package Hi2;
    use strict; use warnings;

    use Inline Java =&amp;gt; &amp;quot;DATA&amp;quot;;

    sub new {
        my $class    = shift;
        my $greeting = shift;
        bless { OBJECT =&amp;gt; Hi2::Hi-&amp;gt;new($greeting) }, $class;
    }

    sub greeting {
        my $self      = shift;
        my $new_value = shift;
        if (defined $new_value) {
            $self-&amp;gt;{OBJECT}-&amp;gt;setGreeting($new_value);
        }
        return $self-&amp;gt;{OBJECT}-&amp;gt;getGreeting();
    }

    1;

    __DATA__
    __Java__
    public class Hi {
        // Body omitted again
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, the object returned from &lt;code&gt;Inline::Java&lt;/code&gt;, which I&amp;rsquo;ll call the Java object for short, is stored in the &lt;code&gt;OBJECT&lt;/code&gt; key of a hash-based &lt;code&gt;Hi2&lt;/code&gt; object that is returned to the caller. The distinction between the Perl package and the Java class is clear in this constructor call. The Perl package comes first, then the Java class, then the class method to call.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;greeting&lt;/code&gt; method, shifts in the &lt;code&gt;$new_value&lt;/code&gt;, which the caller supplies if she wants to change the value. If &lt;code&gt;$new_value&lt;/code&gt; is defined, &lt;code&gt;greeting&lt;/code&gt; passes the &lt;code&gt;set&lt;/code&gt; message to the Java object. In either case, it returns the current value to the caller, as Perl accessors usually do.&lt;/p&gt;

&lt;h3 id=&#34;span-id-a-pure-proxy-a-pure-proxy-span&#34;&gt;&lt;span id=&#34;a_pure_proxy&#34;&gt;A Pure Proxy&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In the last section, we saw how to make a Perl module access Java code. We also saw how to make the Perl module adapt between the caller&amp;rsquo;s expectation of Perl objects and the underlying Java objects. Here, we will see how to access Java classes that can&amp;rsquo;t be included in the Perl code.&lt;/p&gt;

&lt;p&gt;There are a lot of Java libraries. These are usually distributed in compiled form in so-called &lt;em&gt;.jar&lt;/em&gt; (&lt;strong&gt;j&lt;/strong&gt;ava &lt;strong&gt;ar&lt;/strong&gt;chive) files. This is good design on the part of the Java community, just as using modules is good design on the part of the Perl community. Just as we wanted to make the &lt;code&gt;Hi&lt;/code&gt; Java class available to lots of programs &amp;ndash; and thus placed it in a module &amp;ndash; so the Java people put reusable code in .jars. (Yes, Java people share the bad pun heritage of the Unix people, which brought us names like &lt;code&gt;yacc&lt;/code&gt;, &lt;code&gt;bison&lt;/code&gt;, &lt;code&gt;more&lt;/code&gt;, and &lt;code&gt;less&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;Suppose that our humble greeter is so popular that it has been greatly expanded and .jarred for worldwide use. Unless we provide an adapter like the one shown earlier, the caller must use the .jarred code from Perl in a Java-like way. So I will now show three pieces of code: 1) an expanded greeter, 2) a Perl driver that uses it, and 3) a mildly adapting Perl module the driver can use.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the expanded greeter; the two Perl pieces follow later:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    import java.util.Random;
    public class Higher {
        private static Random myRand = new Random();
        private String[] greetings;

        public Higher(String[] greetings) {
            this.greetings = greetings;
        }

        public void setGreetings(String[] newGreetings) {
            greetings = newGreetings;
        }

        public String[] getGreetings() {
            return greetings;
        }

        public void setGreeting(int index, String newGreeting) {
            greetings[index] = newGreeting;
        }

        public String getGreeting() {
            float randRet = myRand.nextFloat();
            int   index   = (int) (randRet * greetings.length);
            return greetings[index];
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now there are multiple greetings, so the constructor takes an array of &lt;code&gt;Strings&lt;/code&gt;. There are &lt;code&gt;get&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; pairs for the whole list of greetings and for single greetings. The single &lt;code&gt;get&lt;/code&gt; accessor returns one greeting at random. The single &lt;code&gt;set&lt;/code&gt; accessor takes the index of the greeting to replace and its new value.&lt;/p&gt;

&lt;p&gt;Note that Java arrays are fixed-size; don&amp;rsquo;t let &lt;code&gt;Inline::Java&lt;/code&gt; fool you into thinking otherwise. It is very good at making you think Java works just like Perl, even though this is not the case. Calling &lt;code&gt;setGreeting&lt;/code&gt; with an out-of-bounds index will be fatal unless trapped. Yes, you can trap Java exceptions with &lt;code&gt;eval&lt;/code&gt; and the &lt;code&gt;$@&lt;/code&gt; variable.&lt;/p&gt;

&lt;p&gt;This driver uses the newly expanded greeter through &lt;code&gt;Hi3.pm&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #!/usr/bin/perl
    use strict; use warnings;

    use Hi3;

    my $greeter = Hi3-&amp;gt;new([&amp;quot;Hello&amp;quot;, &amp;quot;Bonjour&amp;quot;, &amp;quot;Hey Y&#39;all&amp;quot;, &amp;quot;G&#39;Day&amp;quot;]);
    print $greeter-&amp;gt;getGreeting(), &amp;quot;\n&amp;quot;;
          $greeter-&amp;gt;setGreeting(0, &amp;quot;Howdy&amp;quot;);
    print $greeter-&amp;gt;getGreeting(), &amp;quot;\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Hi3&lt;/code&gt; module (directly below) provides access to the Java code. I called the constructor with an anonymous array. An array reference also works, but a simple list does not. The constructor returns a Java object (at least, it looks that way to us); the other calls just provide additional examples. Note, in particular, that &lt;code&gt;setGreeting&lt;/code&gt; expects an &lt;code&gt;int&lt;/code&gt; and a &lt;code&gt;String&lt;/code&gt;. &lt;code&gt;Inline::Java&lt;/code&gt; examines the arguments and coerces them into the best types it can. This nearly always works as expected. When it doesn&amp;rsquo;t, you need to look in the documentation for &amp;ldquo;CASTING.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Finally, this is &lt;code&gt;Hi3.pm&lt;/code&gt; (behold the power of Perl and the work of the &lt;code&gt;Inline&lt;/code&gt; developers):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package Hi3;
    use strict; use warnings;

    BEGIN {
        $ENV{CLASSPATH} .= &amp;quot;:/home/phil/jar_home/higher.jar&amp;quot;;
    }
    use Inline Java  =&amp;gt; &#39;STUDY&#39;,
               STUDY =&amp;gt; [&#39;Higher&#39;];

    sub new {
        my $class = shift;
        return Hi3::Higher-&amp;gt;new(@_);
    }

    1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To use a class hidden in a .jar I need to do three things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Make sure an absolute path to the .jar file is in the &lt;code&gt;CLASSPATH&lt;/code&gt;, &lt;em&gt;before&lt;/em&gt; using &lt;code&gt;Inline&lt;/code&gt;. A well-placed &lt;code&gt;BEGIN&lt;/code&gt; block makes this happen.&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;STUDY&lt;/code&gt; instead of providing Java source code.&lt;/li&gt;
&lt;li&gt;Add the &lt;code&gt;STUDY&lt;/code&gt; directive to the &lt;code&gt;use Inline&lt;/code&gt; statement. This tells &lt;code&gt;Inline::Java&lt;/code&gt; to look for named classes. In this case, the list has only one element: &lt;code&gt;Higher&lt;/code&gt;. Names in this list must be fully qualified if the corresponding class has a Java package.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The constructor just calls the &lt;code&gt;Higher&lt;/code&gt; constructor through &lt;code&gt;Inline::Java&lt;/code&gt;, as we have seen before.&lt;/p&gt;

&lt;p&gt;Yes, this is the whole module, all 15 lines of it.&lt;/p&gt;

&lt;p&gt;If you need an adapter between your caller and the Java library, you can put it in either Perl or Java code. I prefer to code such adapters in Perl when possible, following the plan we saw in the previous section. Yet occasionally, that is too painful, and I resort to Java. For example, the glue module &lt;code&gt;Java::Build::JVM&lt;/code&gt; uses both a Java and a Perl adapter to ease communication with the genuine &lt;code&gt;javac&lt;/code&gt; compiler. Look at the &lt;code&gt;Java::Build&lt;/code&gt; distribution from CPAN for details.&lt;/p&gt;

&lt;h3 id=&#34;span-id-anatomy-of-automated-compiling-a-brief-discussion-anatomy-of-automated-compiling-a-brief-discussion-span&#34;&gt;&lt;span id=&#34;anatomy_of_automated_compiling__a_brief_discussion&#34;&gt;Anatomy of Automated Compiling: A Brief Discussion&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;So what is &lt;code&gt;Inline::Java&lt;/code&gt; doing for us? When it finds our Java code, it makes a copy in the .java file of the proper name (&lt;code&gt;javac&lt;/code&gt; is adamant that class names and file names match). Then it uses our Java compiler to build a compiled version of the program. It puts that version in a directory, using an MD5 sum to ensure that recompiling happens when and only when the code changes.&lt;/p&gt;

&lt;p&gt;You can cruise through the directories looking at what it did. If something goes wrong, it will even give you hints about where to look. Here&amp;rsquo;s a tour of some of those directories. First, there is a base directory. If you don&amp;rsquo;t do anything special, it will be called &lt;em&gt;_Inline&lt;/em&gt;, under the working directory from which you launched the program. If you have a &lt;em&gt;.Inline&lt;/em&gt; directory in your home directory, all &lt;code&gt;Inline&lt;/code&gt; modules will use it. If you use the &lt;code&gt;DIRECTORY&lt;/code&gt; directive in your &lt;code&gt;use Inline&lt;/code&gt; statement, its value will be used instead. For ease of discussion, I&amp;rsquo;ll call the directory &lt;em&gt;_Inline&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Under &lt;em&gt;_Inline&lt;/em&gt; is a config file that describes the various &lt;code&gt;Inline&lt;/code&gt; languages available to you. More importantly, there are two subdirectories: &lt;em&gt;build&lt;/em&gt; and &lt;em&gt;lib&lt;/em&gt;. If your code compiles, the &lt;em&gt;build&lt;/em&gt; directory will be cleaned. (That&amp;rsquo;s the default behavior; you can include directives in your &lt;code&gt;use Inline&lt;/code&gt; statement to control this.) If not, the &lt;em&gt;build&lt;/em&gt; directory has a subdirectory for your program, with part of the MD5 sum in its name. That directory will hold the code in its .java file and the error output from javac in &lt;em&gt;cmd.out&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Code that successfully compiles ends up in &lt;em&gt;lib/auto&lt;/em&gt;. The actual .class files end up in a subdirectory, which is again named by class and MD5 sum. Typically, there will be three files there. The .class file is as normal. The other files describe the class. The .inl file has an &lt;code&gt;Inline&lt;/code&gt; description of the class. It contains the full MD5 sum, so code does not need to be recompiled unless it changes. It also says when the code was compiled, along with a lot of other information about the &lt;code&gt;Inline::Java&lt;/code&gt; currently installed. The .jdat file is specific to &lt;code&gt;Inline::Java&lt;/code&gt;. It lists the signatures of the methods available in the class. &lt;code&gt;Inline::Java&lt;/code&gt; finds these using Java&amp;rsquo;s reflection system (reflection is the Java term for symbolic references).&lt;/p&gt;

&lt;h3 id=&#34;span-id-see-also-see-also-span&#34;&gt;&lt;span id=&#34;see_also&#34;&gt;See Also&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;For more information on &lt;code&gt;Inline&lt;/code&gt; and &lt;code&gt;Inline::Java&lt;/code&gt; and the other inline modules, see their perldoc. If you want to join in, sign up for the &lt;a href=&#34;mailto:inline@perl.org&#34;&gt;inline@perl.org&lt;/a&gt; mailing list, which is archived at &lt;a href=&#34;http://nntp.x.perl.org/group/perl.inline&#34;&gt;nntp.x.perl.org/group/perl.inline&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-acknowledgements-acknowledgements-span&#34;&gt;&lt;span id=&#34;acknowledgements&#34;&gt;Acknowledgements&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Thanks to Brian Ingerson for &lt;code&gt;Inline&lt;/code&gt; and Patrick LeBoutillier for &lt;code&gt;Inline::Java&lt;/code&gt;. These excellent modules have saved me much time and heartache. In fact, I doubt I would have had the courage to use Java in Perl without them. Double thanks to Patrick LeBoutillier, since he took the time to read this article and correct some errors (including my failure to put &amp;ldquo;Bonjour&amp;rdquo; in the greetings list).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Perl Design Patterns, Part 3</title>
      <link>http://localhost:1313/pub/2003/08/15/design3.html/</link>
      <pubDate>Fri, 15 Aug 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/08/15/design3.html/</guid>
      <description>

&lt;p&gt;This is the third (and final) article in a series which form one Perl programmer&amp;rsquo;s response to the book &lt;em&gt;Design Patterns&lt;/em&gt; (also known as the Gang of Four book or simply as GoF, because four authors wrote it). As I showed in the &lt;a href=&#34;http://localhost:1313/pub/2003/08/07/design2.html&#34;&gt;second article&lt;/a&gt;, Perl provides the types needed to implement many patterns. The Strategy and Template Method patterns can be implemented with code references. Builder usually builds a structure based on references to some combination of hashes and lists. Interpreters can be implemented with simple tools like &lt;code&gt;split&lt;/code&gt; or with the king: &lt;code&gt;Parse::RecDescent&lt;/code&gt;, which brings the best of yacc into your Perl script (albeit with somewhat less efficiency than yacc).&lt;/p&gt;

&lt;p&gt;This article continues my treatment by considering patterns which rely on objects. As such, this article&amp;rsquo;s patterns bears the most resemblance to the GoF book. Before presenting some patterns, I&amp;rsquo;ll give you my two cents about object applicability.&lt;/p&gt;

&lt;h4 id=&#34;span-id-when-are-objects-good-when-are-objects-good-span&#34;&gt;&lt;span id=&#34;when_are_objects_good&#34;&gt;When Are Objects Good?&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;As Larry Wall reminds us about all programming constructs, you should use objects when they make sense and not when they don&amp;rsquo;t. So when do they make sense? This is partly a matter of taste. This subsection gives you my tastes.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s easier to say when objects are bad, which they are in these cases:&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;div class=&#34;secondary&#34;&gt;
&lt;h4 id=&#34;more-on-perl-design-patterns&#34;&gt;More on Perl Design Patterns:&lt;/h4&gt;
&lt;p&gt;• &lt;a href=&#34;http://localhost:1313/pub/2003/06/13/design1.html&#34;&gt;Perl Design Patterns, Part 1&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2003/08/07/design2.html&#34;&gt;Perl Design Patterns, Part 2&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
&lt;li&gt;There is only data, the methods are either trivial or non-existent. Data containers (also called nodes) are like this. For example, I should not need an object to return three numbers and a string to my caller.&lt;/li&gt;
&lt;li&gt;There are only methods. The Java Math class is like this. It won&amp;rsquo;t even let you make a Math object. Clearly its methods should just be built-in functions of the language.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Seeing the poor uses of objects gives insight into their effective use. Use objects when complexity is high and data is tightly coupled to the methods which act on it. High complexity makes these chief advantages of objects more important: separate namespaces, inheritance, and polymorphism.&lt;/p&gt;

&lt;p&gt;Now that I&amp;rsquo;ve spoken my peace, I&amp;rsquo;ll go on to the patterns which use objects.&lt;/p&gt;

&lt;h3 id=&#34;span-id-abstract-factory-abstract-factory-span&#34;&gt;&lt;span id=&#34;abstract_factory&#34;&gt;Abstract Factory&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;If you want to build platform independent programs, you need a way to access the underlying systems without having to recode for each one&amp;rsquo;s API. This is where a factory comes into play. The source code asks for an instance of a class, the class delivers a subclass instance suitable for use on the current platform. That class is called an abstract factory (or simply a factory). As we will see below, the platform might be a database. So the factory would return an object suitable for use with a particular database, but all the objects would have the same API.&lt;/p&gt;

&lt;p&gt;To show the basic idea, here is an example which delivers one of two types. There are four code files in this example. The first two are the greeters.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package Greet::Repeat;

sub new {
    my $class    = shift;
    my $self     = {
        greeting =&amp;gt; shift,
        repeat   =&amp;gt; shift,
    };
    return bless $self, $class;
}

sub greet {
    my $self = shift;
    print ($self-&amp;gt;{greeting} x $self-&amp;gt;{repeat});
}

1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This greeter&amp;rsquo;s constructor expects a greeting and a repeat count. It stores these in a hash, returning a blessed reference to it. When asked to greet, it prints the greeting repeatedly (hence the name). (I didn&amp;rsquo;t say this example was practical, but it is small.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package Greet::Stamp;
    use strict; use warnings;

    sub new {
        my $class    = shift;
        my $greeting = shift;
        return bless \$greeting, $class;
    }

    sub greet {
        my $greeting = shift;
        my $stamp    = localtime();
        print &amp;quot;$stamp $$greeting&amp;quot;;
    }

    1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This greeter only expects a greeting string, so it blesses a reference to the one it receives. When asked to greet, it prints the current time followed by the greeting.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the factory:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package GreetFactory;
    use strict; use warnings;

    sub instantiate {
        my $self           = shift;
        my $requested_type = shift;
        my $location       = &amp;quot;Greet/$requested_type.pm&amp;quot;;
        my $class          = &amp;quot;Greet::$requested_type&amp;quot;;

        require $location;

        return $class-&amp;gt;new(@_);
    }

    1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A Perl factory looks a lot like factories in other languages. This one has only one method. It returns the requested type to the caller. It uses the caller&amp;rsquo;s requested type as the name of the class to instantiate and as the name of the Perl module in which the class lives.&lt;/p&gt;

&lt;p&gt;Finally, you can use this factory with a script like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #!/usr/bin/perl
    use strict; use warnings;

    use GreetFactory;

    my $greeter_n = GreetFactory-&amp;gt;instantiate(&amp;quot;Repeat&amp;quot;, &amp;quot;Hello\n&amp;quot;, 3);
    $greeter_n-&amp;gt;greet();

    my $greeter_stamp = GreetFactory-&amp;gt;instantiate(&amp;quot;Stamp&amp;quot;, &amp;quot;Good-bye\n&amp;quot;);
    $greeter_stamp-&amp;gt;greet();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To make each greeter, call the &lt;code&gt;instantiate&lt;/code&gt; method of &lt;code&gt;GreetFactory&lt;/code&gt;, passing it the name of the class you want and any arguments that class&amp;rsquo;s constructor is expecting.&lt;/p&gt;

&lt;p&gt;This example shows you the basic idea. It is simple on purpose. But it does show how the factory can be ignorant of the underlying classes. Any new greeter added to the system must have a name of the form &lt;code&gt;Greet::Name&lt;/code&gt; and be placed into a &lt;code&gt;Greet&lt;/code&gt; subdirectory of an &lt;code&gt;@INC&lt;/code&gt; path member as &lt;code&gt;Name.pm&lt;/code&gt;. Then callers can use it without changing the factory. Now that you have seen a simple example, here is a more useful one.&lt;/p&gt;

&lt;p&gt;The Perl DBI (DataBase Interface) provides an excellent example of a factory. Each call to &lt;code&gt;DBI-&lt;/code&gt;connect&amp;gt;, expects the type of database and whatever information that database needs to establish a connection. This is a classic factory. It will load any DBD (DataBase Driver) you have installed on your system, upon request. Additional DBD&amp;rsquo;s can be added at any time. Once they are installed, any client can use them through the same DBI API. Here&amp;rsquo;s an example use of DBI:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use DBI;
    my $dbh      =
        DBI-&amp;gt;connect(&amp;quot;dbi:mysql:mydb:localhost&amp;quot;, &amp;quot;user&amp;quot;, &amp;quot;password&amp;quot;);
    ...
    my $sth      = $dbh-&amp;gt;prepare(&#39;select * from table&#39;);
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once the database handle is obtained (which is usually called &lt;code&gt;$dbh&lt;/code&gt;), it can be used almost without regard to the underlying engine. If you later move to Oracle, you would merely change the connect call. If a new database comes on the scene, some smart person in contact with Tim Bunce will implement a class for it. You can install and switch to it as soon as they finish their work. You might even be the implementer, but I doubt I will be.&lt;/p&gt;

&lt;h3 id=&#34;span-id-composite-composite-span&#34;&gt;&lt;span id=&#34;composite&#34;&gt;Composite&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;This pattern shows how to use the fully OO composite pattern. If you are interested in a simpler non-OO implementation see the Builder Pattern in Part 2 of this article series.&lt;/p&gt;

&lt;p&gt;Many applications require hierarchies of related items linked into a tree by relationship. Many people see a hierarchy of this type: a directory structure. At the top is the root directory. In the simplest case it includes two types of items: files and subdirectories. Each subdirectory is like the root directory. Note that this definition of the structure is recursive, which is typical of composites.&lt;/p&gt;

&lt;p&gt;One of the most popular examples of a composite structure today is an XML file. These files have a root element which contains various types of subelements, including tags and comments. Tags have attributes and some can contain subelements. This makes the classic composite tree. There are two important steps for a composite structure. The first is building it. The second is using it. We&amp;rsquo;ll see simple examples of both here.&lt;/p&gt;

&lt;p&gt;For the genuine pattern, there must be methods that act on both regular and composite elements (the elements with children are called composite elements). Invoking such a method on the root of a composite tree, or subtree, causes that root to do work on its own data AND to forward the request to its children. Those children do the same, collecting their own data and that of their children, until the bottom of the tree is reached. The return value is a collection of all this data.&lt;/p&gt;

&lt;p&gt;For a practical example consider using the DOM model to process XML. (You may obtain the &lt;code&gt;XML::DOM&lt;/code&gt; module from CPAN.) To find all the paragraphs in a document we could do something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use XML::DOM;
    my $parser = XML::DOM::Parser-&amp;gt;new();
    my $doc    = $parser-&amp;gt;parsefile(&amp;quot;file.xml&amp;quot;);
    foreach my $paragraph ($doc-&amp;gt;getElementsByTagName(&amp;quot;paragraph&amp;quot;)) {
        print &amp;quot;&amp;lt;p&amp;gt;&amp;quot;;
        foreach my $child ($paragraph-&amp;gt;getChildNodes) {
            print $child-&amp;gt;getNodeValue if ($child-&amp;gt;getNodeType eq TEXT_NODE);
        }
    }
    $doc-&amp;gt;dispose();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The call to &lt;code&gt;getElementsByTagName&lt;/code&gt; begins at the root (since I called it through &lt;code&gt;$doc&lt;/code&gt;). The root returns any of its children which are paragraphs, but it also forwards the request to all of its tag elements asking them to return their paragraphs. They do the same.&lt;/p&gt;

&lt;p&gt;An unrelated note: Notice that the above example ends with a call to dispose. &lt;code&gt;XML::DOM&lt;/code&gt; composite structures have references from parents to children and from children to parents. We usually call these circular links. Perl 5 garbage collection cannot harvest such structures. We must call dispose to break the extra links so the structure&amp;rsquo;s memory can be recovered. If you build structures with circular links, you must break those links yourself, otherwise your program will leak memory.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ve seen how useful a well crafted composite structure can be, but how could we build one for ourselves? The objects in the structure must all respond to the methods meant to walk the composite. They may return undef immediately, but they must exist. Further, the version of those methods in the composite objects (the ones which can have children), must take care to pass the message along to their children.&lt;/p&gt;

&lt;p&gt;To make this concrete, consider a non-binary tree (as we have been all along). Suppose we want to know how many nodes are in the tree. We can ask the root to &lt;code&gt;count_nodes&lt;/code&gt;. It should count itself and add that to the sum of &lt;code&gt;count_nodes&lt;/code&gt; calls to each child. Nodes which are not composite (i.e. have no children) return one. Composite nodes, return one plus the sums from their children. The code follows.&lt;/p&gt;

&lt;p&gt;There are four pieces of code: (1) A base class for tree nodes: &lt;code&gt;Node.pm&lt;/code&gt;, (2) A class for nodes that could have children: &lt;code&gt;Composite.pm&lt;/code&gt;, (3) A class for nodes that can&amp;rsquo;t have children: &lt;code&gt;Regular.pm&lt;/code&gt;, and (4) a driver to demonstrate that the system works: &lt;code&gt;comp&lt;/code&gt;. I&amp;rsquo;ll show these one at a time, in the order listed above.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package Node;
    use strict; use warnings;

    sub count_nodes {
        my $self       = shift;
        my $class_name = ref $self;
        die &amp;quot;$class_name does not implement count_nodes\n&amp;quot;;
    }

    1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only method here is &lt;code&gt;count_nodes&lt;/code&gt;. This serves as an implementation requirement (also called an abstract method). Attempting to use a Node subclass which doesn&amp;rsquo;t provide count_nodes results in a fatal run-time error. Every subclass should have an appropriate test to make sure this error never happens to users.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package Regular;

    use Node;
    @ISA = qw(Node);

    use strict; use warnings;

    sub new {
        my $class = shift;
        my $name  = shift;
        return bless \$name, $class;
    }

    sub count_nodes {
        return 1;
    }

    1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Regular nodes are blessed references to their names. They always count as a single node. (An unrelated note: it is sometimes convenient to turn on &lt;code&gt;strict&lt;/code&gt; after the preamble of a package, here that let&amp;rsquo;s me use &lt;code&gt;@ISA&lt;/code&gt; without qualifying it.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package Composite;

    use Node;
    @ISA = qw(Node);

    use strict; use warnings;

    sub new {
        my $class = shift;
        my $name  = shift;
        my $self  = { name =&amp;gt; $name, children =&amp;gt; [] };
        return bless $self, $class;
    }

    sub add_child {
        my $self      = shift;
        my $new_child = shift;

        push @{$self-&amp;gt;{children}}, $new_child;
        return $new_child;
    }

    sub count_nodes {
        my $self  = shift;
        my $count = 1;

        foreach my $child (@{$self-&amp;gt;{children}}) {
            $count += $child-&amp;gt;count_nodes();
        }
        return $count;
    }

    1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This class is similar to &lt;code&gt;Regular&lt;/code&gt;, but it needs a way to keep track of children. Since it also keeps its name, I used a hash for the object type. New children are just pushed onto a list. Counting includes one for the parent node, plus the total for each child. Since leaves of the tree also implement &lt;code&gt;count_nodes&lt;/code&gt;, we can process all &lt;code&gt;Node&lt;/code&gt; types together. This is the polymorphism advantage of objects and the heart of the Composite Pattern.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #!/usr/bin/perl
    use strict; use warnings;

    use Composite;
    use Regular;

    my $root     = Composite-&amp;gt;new(&amp;quot;Root&amp;quot;);

    my $eldest   = $root-&amp;gt;add_child(Composite-&amp;gt;new(&amp;quot;Jim&amp;quot;));
    my $middle   = $root-&amp;gt;add_child(Composite-&amp;gt;new(&amp;quot;Jane&amp;quot;));
                   $root-&amp;gt;add_child(Regular-&amp;gt;new(&amp;quot;Bob&amp;quot;));
    my $youngest = $root-&amp;gt;add_child(Composite-&amp;gt;new(&amp;quot;Joe&amp;quot;));

                   $eldest-&amp;gt;add_child(Regular-&amp;gt;new(&amp;quot;JII&amp;quot;));
    my $kayla    = $eldest-&amp;gt;add_child(Composite-&amp;gt;new(&amp;quot;Kayla&amp;quot;));
                   $kayla-&amp;gt;add_child(Regular-&amp;gt;new(&amp;quot;Max&amp;quot;));

    my $count = $root-&amp;gt;count_nodes();

    print &amp;quot;count: $count\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This contrived example manually builds a simple tree, then asks for a node count. The correct answer is 8.&lt;/p&gt;

&lt;h3 id=&#34;span-id-proxy-proxy-span&#34;&gt;&lt;span id=&#34;proxy&#34;&gt;Proxy&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In GoF the proxy pattern example shows a way to delay loading expensive components until the user actually wants them. In the course of the example they show a genuine proxy. Proxies refer all requests to some other object. Think of it like an intermediary for the mob. You make your request to your local thug, as if he could do the thing himself. He passes that on to someone else you never meet who actually does the job. (Note to John Ashcroft: I am only imaging this process, having NO personal experience with it. Honest.)&lt;/p&gt;

&lt;p&gt;Suppose an application could use several large files, but usually only needs one or two. Instead of reading all these files, I will delay loading the file until the caller wants to see it. The usual warning applies: this is contrived to explain the concept.&lt;/p&gt;

&lt;p&gt;Here is the class that actually stores and prints the files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package File;
    use strict; use warnings;

    sub new {
        my $class = shift;
        my $file  = shift;
        open FILE, &amp;quot;$file&amp;quot; or die &amp;quot;Couldn&#39;t read $file: $!\n&amp;quot;;
        my @data  = &amp;lt;FILE&amp;gt;;
        close FILE;
        return bless \@data, $class;
    }

    sub print_file {
        my $data = shift;
        print @$data;
    }

    sub DESTROY { }

    1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the &lt;code&gt;File&lt;/code&gt; constructor is called, it reads the file into an array for later use, returning a blessed reference to the data to the caller. When asked to print, it sends the data to the currently selected output handle (usually standard out).&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;DESTROY&lt;/code&gt; subroutine is called by Perl whenever a blessed reference is about to go out of scope. This allows us to perform clean-up which is guaranteed to happen. In this case, there is no necessary clean-up, but the approach I&amp;rsquo;m about to show for the proxy class ends up calling this method explicitly. That explicit call offends Perl so much that it complains to the screen. To avoid the warning, I included the stub.&lt;/p&gt;

&lt;p&gt;There is nothing special about the &lt;code&gt;File&lt;/code&gt; class shown above. The proxy follows.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package FileProxy;
    use strict; use warnings;

    use File;

    sub new {
        my $class = shift;
        my $self  = {
            params         =&amp;gt; \@_,
            wrapped_object =&amp;gt; undef,
        };
        return bless $self, $class;
    }

    sub AUTOLOAD {
        my $self    = shift;
        my $command = our $AUTOLOAD;
        $command    =~ s/.*://;

        unless (defined $self-&amp;gt;{wrapped_object}) {
            $self-&amp;gt;{wrapped_object} = File-&amp;gt;new(@{$self-&amp;gt;{params}});
        }
        $self-&amp;gt;{wrapped_object}-&amp;gt;$command(@_);
    }

    1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The constructor for the proxy takes the things necessary to build an actual &lt;code&gt;File&lt;/code&gt; object (namely the file name) and stores them as its &lt;code&gt;params&lt;/code&gt; attribute. The other attribute will eventually hold the wrapped &lt;code&gt;File&lt;/code&gt; object. The attributes are stored in hash, the hash&amp;rsquo;s reference is blessed and returned to the caller.&lt;/p&gt;

&lt;p&gt;Whenever Perl has no where else to go with a method call, it calls &lt;code&gt;AUTOLOAD&lt;/code&gt; (if there is one). So, the &lt;code&gt;AUTOLOAD&lt;/code&gt; in FileProxy handles all requests except &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;DESTROY&lt;/code&gt;, which appear explicitly. &lt;code&gt;AUTOLOAD&lt;/code&gt; is all caps to remind us that Perl calls it for us. While making this call, Perl sets the package global variable &lt;code&gt;$AUTOLOAD&lt;/code&gt; to the name of the method the caller invoked. The regular expression strips off the package names from &lt;code&gt;$AUTOLOAD&lt;/code&gt;, leaving only the method name.&lt;/p&gt;

&lt;p&gt;If the object is not yet defined, &lt;code&gt;AUTOLOAD&lt;/code&gt; calls File-&amp;gt;new passing it the arguments stored during construction. After that, the object is defined, so &lt;code&gt;AUTOLOAD&lt;/code&gt; calls the requested method on the wrapped object. The beauty of this mechanism is that the &lt;code&gt;FileProxy&lt;/code&gt; class only knows that the constructor is called &lt;code&gt;new&lt;/code&gt;. It does not need to change as changes to &lt;code&gt;File.pm&lt;/code&gt; are made. Any errors, such as no such method, will be fatal as usual.&lt;/p&gt;

&lt;p&gt;To use this proxied scheme we might employ a caller like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #!/usr/bin/perl
    use strict; use warnings;

    use FileProxy;

    my $file1 = FileProxy-&amp;gt;new(&amp;quot;art1&amp;quot;);
    my $file2 = FileProxy-&amp;gt;new(&amp;quot;art2&amp;quot;);

    $file1-&amp;gt;print_file();
    $file1-&amp;gt;print_file();
    $file2-&amp;gt;print_file();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With a couple of changes we could use this for any class. Here&amp;rsquo;s the new generic version:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package DelayLoad;
    use strict; use warnings;

    our %proxied_classes;

    sub import {
        shift;  # discard class name

        %proxied_classes = @_;

        foreach my $class (keys %proxied_classes) {
            require &amp;quot;$class.pm&amp;quot;;
        }
    }

    sub new {
        my $class = shift;
        my $self  = {
            type           =&amp;gt; shift,
            constructor    =&amp;gt; shift,
            params         =&amp;gt; \@_,
            wrapped_object =&amp;gt; undef,
        };
        return bless $self, $class;
    }

    sub AUTOLOAD {
        my $self    = shift;
        my $command = our $AUTOLOAD;
        $command    =~ s/.*://;

        if ($proxied_classes{$command}) {
            return $self-&amp;gt;new($command, $proxied_classes{$command}, @_);
        }
        else {
            unless (defined $self-&amp;gt;{wrapped_object}) {
                my $proxied_class       = $self-&amp;gt;{type};
                my $constructor         = $self-&amp;gt;{constructor};
                $self-&amp;gt;{wrapped_object} = $proxied_class
                                        -&amp;gt;$constructor(@{$self-&amp;gt;{params}});
            }
            $self-&amp;gt;{wrapped_object}-&amp;gt;$command(@_);
        }
    }

    1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first change is cosmetic: the name now reflects the nature of the proxy. Other changes include a new method: import. Even though its name is lower case, Perl calls it whenever the caller says &lt;code&gt;use DelayLoad&lt;/code&gt; (see below). It does two things. First, it stores the name of each proxied class in the &lt;code&gt;%proxied_classes&lt;/code&gt; package global. Second, it requires each module. &lt;code&gt;require&lt;/code&gt; is like use, but it happens at run time instead of compile time. (use also imports symbols, but then your object oriented module shouldn&amp;rsquo;t be exporting anything anyway.)&lt;/p&gt;

&lt;p&gt;The constructor now stores a bit more information. In addition to saving room for the wrapped object and storing the &lt;code&gt;params&lt;/code&gt;, it also records the name of the class and of that class&amp;rsquo;s constructor. These will be used in &lt;code&gt;AUTOLOAD&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The only other changes are in the &lt;code&gt;AUTOLOAD&lt;/code&gt; method. There are two changes. The easiest one is to look up the class and constructor names in the &lt;code&gt;DelayLoad&lt;/code&gt; object instead of just calling File-&amp;gt;new.&lt;/p&gt;

&lt;p&gt;The other change is used during construction. My explanation of it will make more sense, if you see the new caller first.&lt;/p&gt;

&lt;p&gt;The new version requires a couple of changes to the caller. One change is on the use line which becomes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use DelayLoad &amp;quot;File&amp;quot; =&amp;gt; &amp;quot;new&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This uses &lt;code&gt;DelayLoad&lt;/code&gt;, tells it we want to be able to delay loads for &lt;code&gt;File&lt;/code&gt; objects, and that &lt;code&gt;File&lt;/code&gt;&amp;rsquo;s constructor is called &lt;code&gt;new&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The other change is in how we construct the delayed object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $file1 = DelayLoad-&amp;gt;File(&amp;quot;art1&amp;quot;);
    my $file2 = DelayLoad-&amp;gt;File(&amp;quot;art2&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This explains the unexplained piece in &lt;code&gt;AUTOLOAD&lt;/code&gt; above. When the user calls the &lt;code&gt;File&lt;/code&gt; method, &lt;code&gt;AUTOLOAD&lt;/code&gt; notices that this ``method&amp;rdquo; is really the name of a delay loaded class. When the &lt;code&gt;if&lt;/code&gt; in &lt;code&gt;AUTOLOAD&lt;/code&gt; is true (i.e. the method is really a key in &lt;code&gt;%proxied_classes&lt;/code&gt;), the caller is given a new &lt;code&gt;DelayLoad&lt;/code&gt; object primed for later use. When the &lt;code&gt;if&lt;/code&gt; fails, &lt;code&gt;DelayLoad&lt;/code&gt; works like &lt;code&gt;FileLoad&lt;/code&gt;: it constructs the object, if needed and calls the requested method.&lt;/p&gt;

&lt;p&gt;The fundamental point of this example is that Perl allows us to implement proxies without knowing very much about the underlying class. In this case, &lt;code&gt;import&lt;/code&gt; receives the necessary information from the caller, &lt;code&gt;AUTOLOAD&lt;/code&gt; takes care of the rest. Making the caller work is not always a good idea. Here it makes sense. If she knows she wants to delay loading objects until they are really needed, she must at least know the API for those objects. In the API is the name of the constructor, which she mentions in the use statement so Perl can pass to &lt;code&gt;DelayLoad::import&lt;/code&gt; for her.&lt;/p&gt;

&lt;p&gt;Keep in mind that &lt;code&gt;AUTOLOAD&lt;/code&gt; is not designed for this sort of work. Its real purpose in life is to load subroutines on demand for the current package. It can&amp;rsquo;t do that here, since changing the subroutines affects all instances of a class. Here we are &lt;code&gt;AUTOLOAD&lt;/code&gt;ing data, not routines. By suitably adjusting &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;AUTOLOAD&lt;/code&gt;, you can make the proxy do many other things.&lt;/p&gt;

&lt;h3 id=&#34;span-id-summary-summary-span&#34;&gt;&lt;span id=&#34;summary&#34;&gt;Summary&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In this article, I have finally shown object oriented patterns. We saw how to implement a Factory so our callers can choose their favorite driver, how to build composite structures and routines that traverse them (without explicit &lt;code&gt;first_child&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt; pointers that would be needed in languages without quality built-in lists), and how to stand as a proxy between a caller and a class with &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;AUTOLOAD&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-author-s-note-author-s-note-span&#34;&gt;&lt;span id=&#34;author&#39;s_note&#34;&gt;Author&amp;rsquo;s Note&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;This is the final article in this series, but look for a book, &lt;em&gt;Design Patterns in Perl&lt;/em&gt; from Apress at your favorite bookseller in the near future.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Perl Design Patterns, Part 2</title>
      <link>http://localhost:1313/pub/2003/08/07/design2.html/</link>
      <pubDate>Thu, 07 Aug 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/08/07/design2.html/</guid>
      <description>

&lt;p&gt;This is the second in a series of articles which form one Perl programmer&amp;rsquo;s response to the book, &lt;em&gt;Design Patterns&lt;/em&gt; (also known as the Gang of Four book or simply as GoF, because four authors wrote it).&lt;/p&gt;

&lt;p&gt;As I showed in the &lt;a href=&#34;http://localhost:1313/pub/2003/06/13/design1.html&#34;&gt;first article&lt;/a&gt;, Perl provides the best patterns in its core and many others are modules which ship with Perl or are available from CPAN. There I considered Iterator (&lt;code&gt;foreach&lt;/code&gt;), Decorator (pipes and list filters), Flyweight (&lt;code&gt;Memoize.pm&lt;/code&gt;), and Singleton (bless an object in a &lt;code&gt;BEGIN&lt;/code&gt; block).&lt;/p&gt;

&lt;p&gt;People into patterns often talk about how knowing patterns makes describing designs easier. The parenthetical comments in the last sentence show how Perl takes this to new heights by including the patterns internally.&lt;/p&gt;

&lt;p&gt;This article continues my treatment by considering patterns which rely on data containers and/or code references (which are also called callbacks). Before showing the patterns let me explain these terms.&lt;/p&gt;

&lt;h4 id=&#34;span-id-data-containers-data-containers-span&#34;&gt;&lt;span id=&#34;data_containers&#34;&gt;Data Containers&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;I use data containers to mean any reference that holds a data structure. Arrays and hashes are common data containers, but hashes of lists of hashes storing things are more interesting. Careful use of these structure containers can often eliminate the need for objects.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a concrete example. Suppose I want a phone list. I might use a container like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $phone_list = {
        &#39;phil&#39; =&amp;gt; [
            { type =&amp;gt; &#39;home&#39;,  number =&amp;gt; &#39;555-0001&#39; },
            { type =&amp;gt; &#39;pager&#39;, number =&amp;gt; &#39;555-1000&#39; },
        ],
        &#39;frank&#39; =&amp;gt; [
            { type =&amp;gt; &#39;cell&#39;,  number =&amp;gt; &#39;555-9012&#39; },
            { type =&amp;gt; &#39;pager&#39;, number =&amp;gt; &#39;555-5678&#39; },
            { type =&amp;gt; &#39;home&#39;,  number =&amp;gt; &#39;555-1234&#39; },
        ],
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This container is housed in a hash. Its keys are names; its values are phone numbers. The numbers are listed in the order the person would like them used. (Call Frank on his cell phone first, then try his pager. If all else fails, use his home phone.)&lt;/p&gt;

&lt;p&gt;To use this structure I might do the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #!/usr/bin/perl
    use strict; use warnings;

    my $phone_list = {
        &#39;Phil&#39; =&amp;gt; [
            { type =&amp;gt; &#39;home&#39;,  number =&amp;gt; &#39;555-0001&#39; },
            { type =&amp;gt; &#39;pager&#39;, number =&amp;gt; &#39;555-1000&#39; },
        ],
        &#39;Frank&#39; =&amp;gt; [
            { type =&amp;gt; &#39;cell&#39;,  number =&amp;gt; &#39;555-9012&#39; },
            { type =&amp;gt; &#39;pager&#39;, number =&amp;gt; &#39;555-5678&#39; },
            { type =&amp;gt; &#39;home&#39;,  number =&amp;gt; &#39;555-1234&#39; },
        ],
    };

    my $person = shift or die &amp;quot;usage: $0 person\n&amp;quot;;

    foreach my $number (@{$phone_list-&amp;gt;{$person}}) {
        print &amp;quot;$number-&amp;gt;{type} $number-&amp;gt;{number}\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, the user supplies the name of the person he or she wants to reach as a command line argument which I store as &lt;code&gt;$person&lt;/code&gt;. I then loop through all the phone numbers for that person, printing the type and number.&lt;/p&gt;

&lt;p&gt;Of course, in practice your data would live outside your script. The example just shows what one data container can hold.&lt;/p&gt;

&lt;p&gt;If you need to use a structure made of data nodes, you can often avoid the need for a node object by using a data container instead. Object Oriented programming proponents would probably want me to make an object for each person. In that object they might even want me to store an object for each phone type in some cumbersome list container. My advice: don&amp;rsquo;t give in to pedants. Even in Java, I can build a structure like the one above (though not as easily). Doing so is often wise. Objects work better in more complex situations.&lt;/p&gt;

&lt;h4 id=&#34;span-id-what-s-a-code-reference-what-s-a-code-reference-span&#34;&gt;&lt;span id=&#34;what&#39;s_a_code_reference&#34;&gt;What&amp;rsquo;s a Code Reference?&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;A code reference is like any reference in Perl, but what it points to is a subroutine you can call. For instance, I could write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $doubler = sub { return 2 * $_[0]; };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then later in my program I would call that routine as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $doubled = &amp;amp;$doubler(5);  # $doubled is now 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example is contrived. But it lets you see the basic syntax of code references. If you assign a sub to a variable, you receive a code reference by the grace of Perl. To call the sub stored in the reference put an &lt;code&gt;&amp;amp;&lt;/code&gt; in front of the variable which stores it. This is like we do for other references, as in this standard hash walker:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    foreach my $key (keys %$hash_reference) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;&amp;amp;&lt;/code&gt; is the sigil (or funny character) for subroutines, just like &lt;code&gt;@&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt; are the sigils for arrays and hashes.&lt;/p&gt;

&lt;p&gt;Many patterns in GoF and outside it can be implemented well in Perl with code references. Languages which don&amp;rsquo;t provide code references are missing an important type.&lt;/p&gt;

&lt;p&gt;Having explained these tools, I&amp;rsquo;m ready to show you some patterns which use them.&lt;/p&gt;

&lt;h3 id=&#34;span-id-strategy-strategy-span&#34;&gt;&lt;span id=&#34;strategy&#34;&gt;Strategy&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;When you want to select from a series of choices for how something should be done, you need a strategy scheme. For example, you might want to sort based on a comparison function. Each time you sort, you should be able to specify the order strategy.&lt;/p&gt;

&lt;p&gt;Since Perl has code references, we can easily implement the strategy pattern without bloating our code base with a proliferation of classes whose sole purpose is to provide one function.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an example with the built-in sort:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sort { lc($a) cmp lc($b) } @items
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This sorts without regard to case. Notice how &lt;code&gt;sort&lt;/code&gt; is receiving the function directly in the call. Though we could do this for our own functions, it is more common to take a reference to the function as a required positional parameter.&lt;/p&gt;

&lt;p&gt;Suppose, for example, that we want to list all files in the current directory, or any of its subdirectories, with some property. There are two pieces to this task: (1) Scan down the directory tree for all the entries, and (2) Test each file to see if it meets the criterion. Ideally we would like to separate these tasks so we can reuse them independently (for instance scanning a directory tree is more common than any particular criterion). We will make the criterion a strategy executed by the directory scanner.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #!/usr/bin/perl
    use strict; use warnings;

    my @files = find_files(\&amp;amp;is_hidden, &amp;quot;.&amp;quot;);
    local $&amp;quot; = &amp;quot;\n&amp;quot;;
    print &amp;quot;@files\n&amp;quot;;

    sub is_hidden {
        my $file = shift;
        $file    =~ s!.*/!!;
        return 0 if ($file =~ /^\./);
        return 1;
    }

    sub find_files {
        my $callback = shift;
        my $path     = shift;
        my @retval;

        push   @retval, $path if &amp;amp;$callback($path);
        return @retval unless (-d $path);

        # identify children
        opendir DIR, $path or return;
        my @files = readdir DIR;
        closedir DIR;

        # visit each child
        foreach my $file (@files) {
            next if ($file =~ /^\.\.?$/);  # skip . and ..
            push @retval, find_files(&amp;quot;$path/$file&amp;quot;, $callback);
        }

        return @retval;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To understand this example, start with the initial call to &lt;code&gt;find_files&lt;/code&gt;. It passes two arguments. The first is a code reference. Note the syntax. As I pointed out in the introduction, to let Perl know I mean a subroutine, I put the &lt;code&gt;&amp;amp;&lt;/code&gt; sigil in front of &lt;code&gt;is_hidden&lt;/code&gt;. To make a reference to that routine (instead of calling it immediately), I put a backslash in front, just as I would to take any other kind of reference.&lt;/p&gt;

&lt;p&gt;When I use the callback in &lt;code&gt;find_files&lt;/code&gt;, &lt;code&gt;$callback&lt;/code&gt; has the reference to the code. To dereference it I put the &lt;code&gt;&amp;amp;&lt;/code&gt; sigil in front of it.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;find_files&lt;/code&gt; subroutine takes a path where the search begins and a code reference called &lt;code&gt;$callback&lt;/code&gt;. At each invocation, it stores the path in the return list, if callback returns true for that path. This allows you to reuse &lt;code&gt;find_files&lt;/code&gt; for many applications, changing only the callback subroutine to change the outcome. This is the strategy pattern, but without the hassle of subclassing the &lt;code&gt;find_files&lt;/code&gt; abstract base class and overriding the criterion method.&lt;/p&gt;

&lt;p&gt;In &lt;code&gt;find_files&lt;/code&gt;, I use recursion to descend the directory tree and its subtrees. First, I call the callback to see if the current path should go into the output. Then the real routine begins. What the callback does makes no difference to this routine. Any true or false value is OK with &lt;code&gt;find_files&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The recursion stops if the file is not a directory. At that point the list is immediately returned. (It could be empty or have the current path in it, depending on the callback&amp;rsquo;s return value.) Otherwise, all the files and subdirectories in the current path are read into &lt;code&gt;@files&lt;/code&gt;. Each of those entries is scanned by the recursive call to find_files (unless the file is . or .., which would create endless recursion). Whatever the recursive call to &lt;code&gt;find_files&lt;/code&gt; returns, it is pushed onto the end of the final output. When all children have been visited, &lt;code&gt;@result&lt;/code&gt; is returned to the caller.&lt;/p&gt;

&lt;p&gt;The CPAN module &lt;code&gt;File::Find&lt;/code&gt; robustly solves the problem approached quickly in my example above. It relies on exactly this kind of function callback.&lt;/p&gt;

&lt;p&gt;The Strategy Pattern uses a callback to perform a single task that varies from use to use. The next pattern uses a series of callbacks to implement the steps of an algorithm.&lt;/p&gt;

&lt;h3 id=&#34;span-id-template-method-template-method-span&#34;&gt;&lt;span id=&#34;template_method&#34;&gt;Template Method&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In some calculations the steps are known, but what the steps do is not. For example, computing charges for a rental might involve three steps:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Calculate amount due from rates.&lt;/li&gt;
&lt;li&gt;Calculate taxes.&lt;/li&gt;
&lt;li&gt;Add these together.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Yet different rentals might have different schemes for calculating the amount due from rates, and different jurisdictions usually have different tax schemes. A template method can implement the outline, deferring to callers for the individual schemes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package Calc;
    use strict; use warnings;

    sub calculate {
        my $class     = shift;   # discarded
        my $data      = shift;
        my $rate_calc = shift;   # a code ref
        my $tax_calc  = shift;   # also a code ref

        my $rate      = &amp;amp;$rate_calc($data);
        my $taxes     = &amp;amp;$tax_calc($data, $rate);
        my $answer    = $rate + $taxes;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here the caller supplies a data reference (probably to a hash or object) together with two code references which are used as callbacks. Each callback must expect the data reference as its first parameter. The &lt;code&gt;tax_calc&lt;/code&gt; code reference also receives the amount due from the rate calculator. This allows it to use a percentage of the amount together with information in the data reference.&lt;/p&gt;

&lt;p&gt;A caller might look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #!/usr/bin/perl
    use strict; use warnings;

    use Calc;

    my $rental = {
        days_used    =&amp;gt; 5,
        day_rate     =&amp;gt; 19.95,
        tax_rate     =&amp;gt; .13,
    };

    my $amount_owed = Calc-&amp;gt;calculate($rental, \&amp;amp;rate_calc, \&amp;amp;taxes);
    print &amp;quot;You owe $amount_owed\n&amp;quot;;

    sub rate_calc {
        my $data = shift;
        return $data-&amp;gt;{days_used} * $data-&amp;gt;{day_rate};
    }

    sub taxes {
        my $data     = shift;  # discarded
        my $subtotal = shift;

        return $data-&amp;gt;{tax_rate} * $subtotal;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I made this contrived caller so you can see the calling sequence. The data here is a simple hash. To save exporting from &lt;code&gt;Calc&lt;/code&gt;, I made calculate a class method, so I call it through its class. In the call, I pass a reference to my data hash and references to the two calculation routines.&lt;/p&gt;

&lt;p&gt;This can be made more complex if you like. One could even make a full-blown class hierarchy of calculators, allowing callers to select the one they want. This example is about as simple as I could make the template method pattern.&lt;/p&gt;

&lt;p&gt;Another approach to templates is to have the caller place methods in the template package. This approach amounts to an implementation of mixins a la Ruby. Here&amp;rsquo;s a sample that is more object oriented.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package Calc;

    sub calculate {
        my $self = shift;
        my $rate = $self-&amp;gt;calculate_rate();
        my $tax  = $self-&amp;gt;calculate_tax($rate);
        return $rate + $tax;
    }

    1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The whole module is really only the template method. To use it, you have to code &lt;code&gt;calculate_rate&lt;/code&gt; and &lt;code&gt;calculate_tax&lt;/code&gt; methods, or your script will die. Here&amp;rsquo;s a particular implementation of the scheme:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package CalcDaily;
    package Calc;
    use strict; use warnings;

    sub new {
        my $class = shift;
        my $self  = {
            days_used    =&amp;gt; shift,
            day_rate     =&amp;gt; shift,
            tax_rate     =&amp;gt; shift,
        };
        return bless $self, $class;
    }

    sub calculate_rate {
        my $data = shift;
        return $data-&amp;gt;{days_used} * $data-&amp;gt;{day_rate};
    }

    sub calculate_tax {
        my $data     = shift;  # discarded
        my $subtotal = shift;

        return $data-&amp;gt;{tax_rate} * $subtotal;
    }

    1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that I added a constructor and two methods to the &lt;code&gt;Calc&lt;/code&gt; package in a different source file. This is perfectly legal and occasionally useful. By doing this, the template is totally isolated. It doesn&amp;rsquo;t even know what sort of data will be stored in the objects of its own type. That does mean that only one &lt;code&gt;Calc&lt;/code&gt; subtype can be used at a time. If that&amp;rsquo;s a problem for you, do the standard thing: have &lt;code&gt;Calc&lt;/code&gt; call methods on objects in some separate hierarchy.&lt;/p&gt;

&lt;p&gt;There are two package statements at the top of the file, this is on purpose. The first one tells people (and crawlers) that this is the &lt;code&gt;CalcDaily&lt;/code&gt; package which rightfully belongs in &lt;code&gt;CalcDaily.pm&lt;/code&gt;, not the original &lt;code&gt;Calc&lt;/code&gt;, which belongs in &lt;code&gt;Calc.pm&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Finally, here&amp;rsquo;s the caller, which is only slightly modified:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #!/usr/bin/perl
    use strict; use warnings;
    use Calc;
    use CalcDaily;

    my $rental      = Calc-&amp;gt;new(5, 19.95, .13);
    my $amount_owed = $rental-&amp;gt;calculate();
    print &amp;quot;You owe $amount_owed\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This technique is similar to the one used in the debugger architecture for Perl. To make my own debugger, I need a name for it. I might choose &lt;code&gt;PhilDebug.pm&lt;/code&gt;. Then I have to make a file with that name in a Devel directory which is in my &lt;code&gt;@INC&lt;/code&gt; list. The first line in the file should be (but doesn&amp;rsquo;t have to be):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package Devel::PhilDebug;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This allows the CPAN indexer to properly catalog my module.&lt;/p&gt;

&lt;p&gt;The base package for debuggers is fixed as &lt;code&gt;DB&lt;/code&gt;. Perl expects to call the &lt;code&gt;DB&lt;/code&gt; function in that package. So all together it might look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package Devel::PhilDebug;
    package DB;

    sub DB {
        my @info = caller(0);
        print &amp;quot;@info\n&amp;quot;;
    }

    1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Any script will use this debugger if it is invoked as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    perl -d:PhilDebug script
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each time the debugger notices that a new statement is about to start, it first calls &lt;code&gt;DB::DB&lt;/code&gt;. This is a very powerful example of plug-and-play.&lt;/p&gt;

&lt;p&gt;It is not usually wise to pollute foreign classes with your own code. Yet, Perl permits this, because it is sometimes highly useful. There seems to be a theme here:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Don&amp;rsquo;t rule out dangerous things. Just avoid them, unless you have a good reason to use them.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The Strategy and Template patterns use code references to allow the caller to adjust the behavior of an algorithm. The template I showed used a data container to hold rental information. The next pattern makes more use of data containers.&lt;/p&gt;

&lt;h3 id=&#34;span-id-builder-builder-span&#34;&gt;&lt;span id=&#34;builder&#34;&gt;Builder&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Many structures external to your program should be represented with composites (like trees or the data container in the introduction) inside your program. There are two fundamentally different ways to represent these structures. For an object-oriented way to compose such structures see the Composite Pattern in GoF (which I will discuss in my next article).&lt;/p&gt;

&lt;p&gt;Here we&amp;rsquo;ll look at how to build a composite structure in a hash of hashes. You might rather build the objected-oriented version. Which you choose should depend on the complexity of the data and the methods to act on it. If data and methods are simple, you should probably use the hash structure. It will be faster, have built-in support, and be more familiar to Perl programmers who might need to maintain your code. If the complexities are large, you should use full-blown objects. They make the structure easier to understand for object-oriented programmers and provide more code-based documentation than simple hashes.&lt;/p&gt;

&lt;p&gt;So, hashes are superior structures for simple to moderately complex data. To see how to build a hash structure consider an example: visualizing an outline. For simplicity, I&amp;rsquo;ll represent the outline purely through indentation (not with Roman or other numerals). Here&amp;rsquo;s an example outline:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Grocery Store
        Milk
        Juice
        Butcher
            Thin sliced ham
            Chuck roast
        Cheese
    Cleaners
    Home Center
        Door
        Lock
        Shims
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This outline describes a theoretical shopping trip. I want to represent it internally in my program so I can play with it. (One of my favorite games is turning outlines into pictures, see below.)&lt;/p&gt;

&lt;p&gt;Instead of a full-blown object, I&amp;rsquo;ll use a little hash-based data container for each node in the tree. Each node will keep track of three things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Name&lt;/li&gt;
&lt;li&gt;Level&lt;/li&gt;
&lt;li&gt;Children (a list of other nodes)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To keep track of who is a child of whom, I&amp;rsquo;ll use a stack of these nodes. The node on the top of the stack is usually the parent of the next line of input. To show my method, I&amp;rsquo;ll intersperse comments with the script. At the bottom of this section the script appears in one piece.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #!/usr/bin/perl
    use strict; use warnings;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These lines are always a good idea.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $root = {
        name     =&amp;gt; &amp;quot;ROOT&amp;quot;,
        level    =&amp;gt; -1,
        children =&amp;gt; [],
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the root node. It&amp;rsquo;s a hash reference containing the three keys mentioned earlier. The root node is special. Since it isn&amp;rsquo;t in the file, I give it an artificial name and a level that is lower than anyone else&amp;rsquo;s. (In a moment, we will see that levels in the input will be zero or positive.) Initially the list of children is empty.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @stack;
    push @stack, $root;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The stack will keep track of the ancestry of each new node. For starters it needs the root node, which won&amp;rsquo;t ever be popped, because it is an ancestor of all the nodes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    while (&amp;lt;&amp;gt;) {
        /^(\s*)(.*)/;
        my $indentation = length $1 if defined ($1);
        my $name        = $2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To read the file, I chose a magic &lt;code&gt;while&lt;/code&gt;. For each line there will be two parts: the indentation (the leading spaces) and the name (the rest of the line). The regular expression captures any leading space into &lt;code&gt;$1&lt;/code&gt; and everything else (except the new line) into &lt;code&gt;$2&lt;/code&gt;. The length of the indentation is the important part, the bigger this is the more ancestors the node has. Lines starting at the margin have an indentation of 0 (which is why the &lt;code&gt;ROOT&lt;/code&gt; has a level of -1).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        while ($indentation &amp;lt;= $stack[-1]{level}) {
            pop @stack;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This loop handles ancestry. It pops the stack, until the node on top of the stack is the parent of the new node. Think of an example. When &lt;code&gt;Home Center&lt;/code&gt; comes along, &lt;code&gt;Cleaners&lt;/code&gt; and &lt;code&gt;ROOT&lt;/code&gt; are on the stack. &lt;code&gt;Home Center&lt;/code&gt;&amp;rsquo;s level is 0 (it&amp;rsquo;s at the margin), so is &lt;code&gt;Cleaners&lt;/code&gt;&amp;rsquo;. Thus, &lt;code&gt;Cleaners&lt;/code&gt; is popped (since 0 &amp;lt;= 0). Then only &lt;code&gt;ROOT&lt;/code&gt; remains, so popping stops (0 is not &amp;lt;= -1).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        my $node = {
            name     =&amp;gt; $name,
            level    =&amp;gt; $indentation,
            children =&amp;gt; [],
        };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This builds a new node for the current line. It&amp;rsquo;s name and level are set. We haven&amp;rsquo;t seen any children yet, but I make room for them in an empty list.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        push @{$stack[-1]{children}}, $node;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This line adds the new node to its parent&amp;rsquo;s list of children. Remember that the parent is sitting on top of the stack. The top of the stack is &lt;code&gt;$stack[-1]&lt;/code&gt; or the last element in the array.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        push @stack, $node;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This pushes the new node onto the stack, in case it has children. The closing brace ends the magic &lt;code&gt;while&lt;/code&gt; loop. For simplicity, I chose to display the output with &lt;code&gt;Data::Dumper&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Data::Dumper; print Dumper($root);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running this shows the tree (sideways) on standard out.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the whole code without interruption:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #!/usr/bin/perl
    use strict; use warnings;

    my $root = {
        name     =&amp;gt; &amp;quot;ROOT&amp;quot;,
        level    =&amp;gt; -1,
        children =&amp;gt; [],
    };

    my @stack;
    push @stack, $root;

    while (&amp;lt;&amp;gt;) {
        /^(\s*)(.*)/;
        my $indentation = length $1;
        my $name        = $2;
        while ($indentation &amp;lt;= $stack[-1]{level}) {
            pop @stack;
        }
        my $node = {
            name     =&amp;gt; $name,
            level    =&amp;gt; $indentation,
            children =&amp;gt; [],
        };
        push @{$stack[-1]{children}}, $node;
        push @stack, $node;
    }

    use Data::Dumper; print Dumper($root);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I promised to explain how structures like the one above can be turned into pictures. The CPAN module &lt;code&gt;UML::Sequence&lt;/code&gt; builds a structure similar to the one shown here. It then uses that to generate a UML Sequence diagram of the steps in SVG (Scalable Vector Graphics) format. That format can be converted with standard tools like Batik to PNG or JPEG. In practice the outlines which I turn into pictures represent call sequences for programs. Perl can even generate the outline by running the program. See &lt;code&gt;UML::Sequence&lt;/code&gt; for more details.&lt;/p&gt;

&lt;p&gt;When you have some interesting structured input, a builder might help make a good internal structure. One high value builder is &lt;code&gt;XML::DOM&lt;/code&gt;. Another with a slightly different approach is &lt;code&gt;XML::Twig&lt;/code&gt;. It is not coincidental that XML parsers are really builders, as XML files are non-binary trees.&lt;/p&gt;

&lt;h3 id=&#34;span-id-interpreter-interpreter-span&#34;&gt;&lt;span id=&#34;interpreter&#34;&gt;Interpreter&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;If you haven&amp;rsquo;t looked in GoF yet, start with the interpreter pattern. Laughter is good for the soul. The person who taught me patterns in Java did not even know why this pattern would not work in practice. He had heard it was somewhat slow, but he wasn&amp;rsquo;t sure. Well I&amp;rsquo;m sure.&lt;/p&gt;

&lt;p&gt;Luckily for us, Perl has alternatives. These range from quick and dirty to full blown. Here&amp;rsquo;s the litany covered with examples below:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;split&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;eval&lt;/code&gt;&amp;lsquo;ing Perl code&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Config::Auto&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Parse::RecDescent&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Since we already have a language we like (that&amp;rsquo;s Perl for those who haven&amp;rsquo;t been paying attention), interpreting is limited to small languages that do something for us. Usually these turn out to be configuration files, so I will focus on those. (See the builder section above if a tree can represent your data file.)&lt;/p&gt;

&lt;h4 id=&#34;span-id-splitting-splitting-span&#34;&gt;&lt;span id=&#34;splitting&#34;&gt;Splitting&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The easiest route involves &lt;code&gt;split&lt;/code&gt;. Suppose I have a config file which uses &lt;code&gt;variable=value&lt;/code&gt; settings. Comments and blanks should be ignored, all other lines should have a variable, value pair. That&amp;rsquo;s easy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub parse_config {
        my $file = shift;
        my %answer;

        open CONFIG, &amp;quot;$file&amp;quot; or die &amp;quot;Couldn&#39;t read config file $file: $!\n&amp;quot;;
        while (&amp;lt;CONFIG&amp;gt;) {
            next if (/^#|^\s*$/);  # skip blanks and comments
            my ($variable, $value) = split /=/;
            $answer{$variable} = $value;
        }
        close CONFIG;

        return %answer;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This subroutine expects a config file name. It opens and reads that file. Inside the magic &lt;code&gt;while&lt;/code&gt; loop the regex rejects lines which start with &amp;lsquo;#&amp;rsquo; and those which contain only whitespace. All other lines are split on &amp;lsquo;=&amp;rsquo;. The variables become keys in the &lt;code&gt;%answer&lt;/code&gt; hash. When all the lines are read, the caller gets the hash back.&lt;/p&gt;

&lt;p&gt;You could go much further along these lines, but see below for those who&amp;rsquo;ve gone before you (see especially &lt;code&gt;Config::Auto&lt;/code&gt;).&lt;/p&gt;

&lt;h4 id=&#34;span-id-evaluating-perl-code-evaluating-perl-code-span&#34;&gt;&lt;span id=&#34;evaluating_perl_code&#34;&gt;Evaluating Perl Code&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;My current favorite way to bring configuration information into a Perl program is to specify the config file in Perl. So, I might have a config file like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    our $db_name = &amp;quot;projectdb&amp;quot;;
    our $db_pass = &amp;quot;my_special_password_no_one_will_think_of&amp;quot;;
    our %personal = (
        name    =&amp;gt; &amp;quot;Phil Crow&amp;quot;,
        address =&amp;gt; &amp;quot;philcrow2000@yahoo.com&amp;quot;,
    );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To use this in a Perl program all I have to do is eval it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ...
    open CONFIG, &amp;quot;config.txt&amp;quot; or die &amp;quot;couldn&#39;t...\n&amp;quot;;
    my $config = join &amp;quot;&amp;quot;, &amp;lt;CONFIG&amp;gt;;
    close CONFIG;

    eval $config;
    die &amp;quot;Couldn&#39;t eval your config: $@\n&amp;quot; if $@;
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To read the file, I open it, then use join to put the angle read operator in list context. This lets me bring the whole file into a scalar. Once it&amp;rsquo;s in (and the file is closed for tidiness), I just eval the string I read. I need to check &lt;code&gt;$@&lt;/code&gt; to make sure the file was good Perl. After that, I&amp;rsquo;m ready to use the values just as if they appeared in the program originally.&lt;/p&gt;

&lt;h4 id=&#34;span-id-config-auto-for-those-who-can-t-be-bothered-config-auto-for-those-who-can-t-be-bothered-span&#34;&gt;&lt;span id=&#34;config::auto__for_those_who_can&#39;t_be_bothered&#34;&gt;Config::Auto &amp;ndash; For Those Who Can&amp;rsquo;t be Bothered&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;If you&amp;rsquo;re too lazy to write your own config handler, or if you have lots of configs outside your control, &lt;code&gt;Config::Auto&lt;/code&gt; may be for you. Basically, it takes a file and guesses how to turn it into a config hash. (It can even guess the name of your config file). Using it is easy (if it works):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #!/usr/bin/perl
    use strict; use warnings;

    use Config::Auto;

    my $config = Config::Auto::parse(&amp;quot;your.config&amp;quot;);
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What ends up in &lt;code&gt;$config&lt;/code&gt; depends on what your config file looks like (shock). For files which use &lt;code&gt;variable=value&lt;/code&gt; pairs, you get what you expect, which is exactly what the first example above generates for the same input. It is possible to specify a config file that &lt;code&gt;Config::Auto&lt;/code&gt; cannot understand (shock and amazement).&lt;/p&gt;

&lt;h4 id=&#34;span-id-real-hackers-use-parse-recdescent-real-hackers-use-parse-recdescent-span&#34;&gt;&lt;span id=&#34;real_hackers_use_parse::recdescent&#34;&gt;Real Hackers Use Parse::RecDescent&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;If the file you need to parse is complex, consider &lt;code&gt;Parse::RecDescent&lt;/code&gt;. It implements a clever top/down parser scheme. To use it, you specify a grammar. (You remember grammars, don&amp;rsquo;t you? If not, see below.) It builds a parser from your grammar. You feed text to the parser. It does whatever the grammar specifies in its actions.&lt;/p&gt;

&lt;p&gt;To give you a feel for how this works, I&amp;rsquo;ll parse small Roman numerals. The program below takes numbers from the keyboard and translates them from Roman numerals to decimal integers, so XXIX becomes 29.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #!/usr/bin/perl
    use strict; use warnings;

    use Parse::RecDescent;

    my $grammar = q{
        Numeral : TenList FiveList OneList /\Z/
                    { $item[1] + $item[2] + $item[3]; }
                | /quit/i { exit(0); }
                | &amp;lt;error&amp;gt;

        TenList : Ten(3)                  { 30            }
                | Ten(2) OptionalNine     { 20 + $item[2] }
                | Ten OptionalNine        { 10 + $item[2] }
                | OptionalNine            { $item[1]      }

        OptionalNine : One Ten { 9 }
                     |         { 0 }

        FiveList : One Five { 4 }
                 | Five     { 5 }
                 |          { 0 }

        OneList : /(I{0,3})/i { length $1 }

        Ten : /X/i

        Five : /V/i

        One : /I/i
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;my $parse = new Parse::RecDescent($grammar);&lt;/p&gt;

&lt;p&gt;while (&amp;lt;&amp;gt;) { chomp; my $value = $parse-&amp;gt;Numeral($_); print ``value: $value\n&amp;rdquo;; }&lt;/p&gt;

&lt;p&gt;As you can see &lt;code&gt;$grammar&lt;/code&gt; takes up most of the space in this program. The rest is pretty simple. Once I receive the parser from the &lt;code&gt;Parse::RecDescent&lt;/code&gt; constructor, I just call its Numeral method repeatedly.&lt;/p&gt;

&lt;p&gt;So what does the grammar mean? Let&amp;rsquo;s start at the top. Grammars are built from rules. The rule for a Numeral (the Roman kind) says:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    A Numeral takes the form of one of these choices
        a TenList then a FiveList then a OneList then the end of the string
        OR
        the word quit in any case (not a Numeral, but a way to quit)
        OR
        anything else, which is an error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll see what TenList and its friends are shortly. The code after the first choice is called an action. If the rule matches a possibility, it performs that possibility&amp;rsquo;s action. So if a valid Numeral is seen, the action is executed. This particular action adds up the values TenList, FiveList, and OneList have accumulated. The items are numbered starting with 1, so TenList&amp;rsquo;s value is in &lt;code&gt;$item[1]&lt;/code&gt;, etc.&lt;/p&gt;

&lt;p&gt;How does TenList get a value? Well, when Numeral starts matching, it looks first for a valid TenList. There are four choices:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    A TenList takes the form of one of these choices
        three Tens
        OR
        two Tens then an OptionalNine
        OR
        a Ten then an OptionalNine
        OR
        an OptionalNine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These choices are tried in order. A Ten is simply an upper- or lower-case X (see the Ten rule). The result of an action is the result of its last statement. So, if there are three tens, the TenList returns 30. If there are two tens, it returns 20 plus whatever OptionalNine returned.&lt;/p&gt;

&lt;p&gt;The Roman numeral IX is our 9. I call this an OptionalNine. (The names are completely arbitrary.) So after zero, one, or two X&amp;rsquo;s, there can be an IX which adds 9 to the total. If there is no IX, the OptionalNine will match the empty rule. That consumes no text from the input and returns zero according to its action.&lt;/p&gt;

&lt;p&gt;Roman numerals are a lot more complex than my little grammar can handle. For starters, by my calendar, we&amp;rsquo;re now in the year MMIII. There are no M&amp;rsquo;s in my grammar. Further, some Romans thought that IIIIII was perfectly valid. In my grammar three is the limit for all repetitions, and only I and X can repeat. Further, reductions can only take one away. So, IIX is not eight, it&amp;rsquo;s invalid. This grammar can recognize any normalized Roman numeral up to 38. Feel free to expand it.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Parse::RecDescent&lt;/code&gt; is not as fast as a yacc-generated parser, but it is easier to use. See the documentation in the distribution for more information, especially the tutorial which originally appeared in The Perl Journal.&lt;/p&gt;

&lt;p&gt;If you look at what&amp;rsquo;s inside the parser (say with &lt;code&gt;Data::Dumper&lt;/code&gt;) you might think this actually implements the interpreter pattern. After all, it makes a tree of objects from the grammar. Look closer and you will see the key difference. All of the objects in the tree are members of classes of like &lt;code&gt;Parse::RecDescent::Action&lt;/code&gt;, which were written by Damian Conway when he wrote the module. In the GoF interpreter pattern we are expected to build a class for each non-terminal in the grammar (above those classes would be Numeral, ReducedTen, etc.). Thus, the tree node types are different for each grammar.&lt;/p&gt;

&lt;p&gt;This difference has two implications: (1) it makes the &lt;code&gt;RecDescent&lt;/code&gt; parser generator simpler and (2) it&amp;rsquo;s result faster.&lt;/p&gt;

&lt;h3 id=&#34;span-id-summary-summary-span&#34;&gt;&lt;span id=&#34;summary&#34;&gt;Summary&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In this installment we have seen how to use code references to implement the Strategy and Template Method patterns. We even saw how to force our code into someone else&amp;rsquo;s class. Builder turns text into an internal structure, which most Interpreters also do. Those structures can often be simple combinations of hashes, lists, and scalars. If what you need to read is simpler, use split or &lt;code&gt;Config::Auto&lt;/code&gt;. If it is more complex, use &lt;code&gt;Parse::RecDescent&lt;/code&gt;. If that won&amp;rsquo;t do it fast enough, you might need one of the yaccs.&lt;/p&gt;

&lt;p&gt;Next time I will look at patterns which actually rely on objects.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Perl Design Patterns</title>
      <link>http://localhost:1313/pub/2003/06/13/design1.html/</link>
      <pubDate>Fri, 13 Jun 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/06/13/design1.html/</guid>
      <description>

&lt;h3 id=&#34;span-id-introduction-introduction-span&#34;&gt;&lt;span id=&#34;introduction&#34;&gt;Introduction&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In 1995, Design Patterns was published, and during the intervening years, it has had a great influence on how many developers write software. In this series of articles, I present my take on how the Design Patterns book (the so-called Gang of Four book, which I will call GoF) and its philosophy applies to Perl. While Perl is an OO language &amp;ndash; you could code the examples from GoF directly in Perl &amp;ndash; many of the problems the GoF is trying to solve are better solved in Perl-specific ways, using techniques not open to Java developers or those C++ developers who insist on using only objects. Even if developers in other languages are willing to consider procedural approaches, they can&amp;rsquo;t, for instance, use Perl&amp;rsquo;s immensely powerful built-in pattern support.&lt;/p&gt;

&lt;p&gt;Though these articles are self-contained, you will get more out of them if you are familiar with the GoF book (or better yet have it open on your desk while you read). If you don&amp;rsquo;t have the book, then try searching the Web - many people talk about these patterns. Since the Web and the book have diagrams of the object versions of the patterns, I will not reproduce those here, but can direct you to &lt;a href=&#34;http://www.tml.hut.fi/~pnr/GoF-models/html/&#34;&gt;this fine site&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I will show you how to implement the highest value patterns in Perl, most often by using Perl&amp;rsquo;s rich core language. I even include some objects.&lt;/p&gt;

&lt;p&gt;For the object-oriented implementations, I need you to understand the basics of Perl objects. You can learn that from printed sources like the &lt;a href=&#34;https://www.oreilly.com/catalog/cookbook&#34;&gt;Perl Cookbook&lt;/a&gt; by Tom Christiansen and Nat Torkington or &lt;a href=&#34;https://www.manning.com/books/object-oriented-perl&#34;&gt;Objected Oriented Perl&lt;/a&gt; by Damian Conway. But the simplest way to learn the basics is from &lt;a href=&#34;https://perldoc.perl.org/perltoot.html&#34;&gt;perldoc perltoot&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As motivation for my approach, let me start with a little object-oriented philosophy. Here are my two principles of objects:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Objects are good when data and methods are tightly bound.&lt;/li&gt;
&lt;li&gt;In most other cases, objects are overkill.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let me elaborate briefly on these principles.&lt;/p&gt;

&lt;h4 id=&#34;span-id-objects-are-good-when-data-and-methods-are-tightly-bound-objects-are-good-when-data-and-methods-are-tightly-bound-span&#34;&gt;&lt;span id=&#34;objects_are_good_when_data_and_methods_are_tightly_bound.&#34;&gt;Objects are good when data and methods are tightly bound.&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;When you are working for a company that rents cars (as I do), an object to represent a rental agreement makes sense. The data on the agreement is tightly bound to the methods you need to perform. To calculate the amount owed, you take the various rates and add them together, etc. This is a good use of an object (or actually several aggregated objects).&lt;/p&gt;

&lt;h4 id=&#34;span-id-in-most-other-cases-objects-are-overkill-in-most-other-cases-objects-are-overkill-span&#34;&gt;&lt;span id=&#34;in_most_other_cases,_objects_are_overkill.&#34;&gt;In most other cases, objects are overkill.&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Consider a few examples from other languages. Java has the &lt;code&gt;java.lang.Math&lt;/code&gt; class. It provides things such as sine and cosine. It only provides class methods and a couple of class constants. This should not be forced into an object-oriented framework, since there are no Math objects. Rather the functions should be put in the core, left out completely, or made into non-object-oriented functions. The last option is not even available in Java.&lt;/p&gt;

&lt;p&gt;Or think of the C++ standard template library. The whole templating framework is needed to make C++ backward compatible with C and to handle strong static-type checking. This makes for awkward object-oriented constructs for things that should be simple parts of the core language. To be specific, why shouldn&amp;rsquo;t the language just have a better array type at the outset? Then a few well-named built-in operations take care of stacks, queues, dequeues and many other structures we learned in school.&lt;/p&gt;

&lt;p&gt;So, in particular, I take exception to one consistent GoF trick: turning an idea into a full-blown class of objects. I prefer the Perl way of incorporating the most-important concepts into the core of the language. Since I prefer this Perl way, I won&amp;rsquo;t be showing how to objectify things that could more easily be a simple hash with no methods or a simple function with no class. I will invert the GoF trick: implement full-blown pattern classes with simpler Perl concepts.&lt;/p&gt;

&lt;p&gt;The patterns in this first article rely primarily on built-in features of Perl. Later articles will address other groups of patterns. Now that I&amp;rsquo;ve told you what I&amp;rsquo;m about to do, let&amp;rsquo;s start.&lt;/p&gt;

&lt;h3 id=&#34;span-id-iterator-iterator-span&#34;&gt;&lt;span id=&#34;iterator&#34;&gt;Iterator&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;There are many structures that you need to walk one element at a time. These include simple things such as arrays, moderate things such as the keys of a hash, and complex things such as the nodes of a tree.&lt;/p&gt;

&lt;p&gt;The Gang of Four suggest solving this problem with the above mentioned trick: turn a concept into an object. Here that means you should make an iterator object. Each class of objects that can reasonably be walked should have a method that returns an iterator object. The object itself always behaves in a uniform way. For example, consider the following code, which uses an iterator to walk the keys of a hash in Java.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for (Iterator iter = hash.keySet().iterator(); iter.hasNext();) {
        Object key   = iter.next();
        Object value = hash.get(key);
        System.out.println(key + &amp;quot;\t&amp;quot; + value);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The HashMap object has something that can be walked: its keys. You can ask it for this keySet. That Set will give you an Iterator on request to its iterator method. The Iterator responds to hasNext with a true value if there are more things to be walked, and false otherwise. Its next method delivers the next object in whatever sequence the Iterator is managing. With that key, the HashMap delivers the next value in response to get(key). This is neat and tidy in the completely OO framework of a language with limited operators and built-in types. It also perfectly exhibits the GoF iterator pattern.&lt;/p&gt;

&lt;p&gt;In Perl any built-in or user defined object which can be walked has a method which returns an ordered list of the items to be walked. To walk the list, simply place it inside the parentheses of a foreach loop. So the Perl version of the above hash key walker is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    foreach my $key (keys %hash) {
        print &amp;quot;$key\t$hash{$key}\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I could implement the pattern exactly as it is diagrammed in GoF, but Perl provides a better way. In Perl 6, it will even be possible to return a list that expands lazily, so the above will be more efficient than it is now. In Perl 5, the keys list is built completely when I call &lt;code&gt;keys&lt;/code&gt;. In the future, the keys list will be built on demand, saving memory in most cases, and time in cases where the loop ends early.&lt;/p&gt;

&lt;p&gt;The inclusion of iteration as a core concept represents Perl design at its finest. Instead of providing a clumsy mechanism in non-core code, as Java and C++ (through its standard template library) do, Perl incorporates this pattern into the core of the language. As I alluded to in the introduction, there is a Perl principle here:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;If a pattern is really valuable, then it should be part of the core language.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The above example is from the core of the language. To see that &lt;code&gt;foreach&lt;/code&gt; fully implements the iterator pattern, even for user-defined modules, consider an example from CPAN: &lt;a href=&#34;https://metacpan.org/pod/XML::DOM&#34;&gt;&lt;code&gt;XML::DOM&lt;/code&gt;&lt;/a&gt;. The DOM for XML was specified by Java programmers. One of the methods you can call on a DOM Document is &lt;code&gt;getElementsByTagName&lt;/code&gt;. In the DOM specification this returns a &lt;code&gt;NodeList&lt;/code&gt;, which is a Java Collection. Thus, the &lt;code&gt;NodeList&lt;/code&gt; works like the Set in the Java code above. You must ask it for an Iterator, then walk the Iterator.&lt;/p&gt;

&lt;p&gt;When Perl people implemented the DOM, they decided that &lt;code&gt;getElementsByTagName&lt;/code&gt; would return a proper Perl list. To walk the list one says something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    foreach my $element ($doc-&amp;gt;getElementsByTagName(&amp;quot;tag&amp;quot;)) {
        # ... process the element ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This stands in stark contrast to the overly verbose Java version:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    NodeList elements = doc.getElementsByTagName(&amp;quot;tag&amp;quot;);
    for (Iterator iter = elements.iterator(); iter.hasNext();) {
        Element element = (Element)iter.next();
        // ... process the element ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One beauty of Perl is its ability to combine procedural, object-oriented, and core concepts in such powerful ways. The facts that GoF suggests implementing a pattern with objects and that object only languages like Java require it do not mean that Perl programmers should ignore the non-object features of Perl.&lt;/p&gt;

&lt;p&gt;Perl succeeds largely by excellent use of the principle of promotion. Essential patterns are integrated into the core of the language. Useful things are implemented in modules. Useless things are usually missing.&lt;/p&gt;

&lt;p&gt;So the iterator pattern from GoF is a core part of Perl we hardly think about. The next pattern might actually require us to do some work.&lt;/p&gt;

&lt;h3 id=&#34;span-id-decorator-decorator-span&#34;&gt;&lt;span id=&#34;decorator&#34;&gt;Decorator&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In normal operation, a &lt;strong&gt;decorator&lt;/strong&gt; wraps an object, responding to the same API as the wrapped object. For example, suppose I add a compressing decorator to a file writing object. The caller passes a file writer to the decorator&amp;rsquo;s constructor, and calls &lt;code&gt;write&lt;/code&gt; on the decorator. The decorator&amp;rsquo;s write method first compresses the data, then calls the &lt;code&gt;write&lt;/code&gt; method of the file writer it wraps. Any other type of writer could be wrapped with the same decorator, so long as all writers respond to the same API. Other decorators can also be used in a chain. The text could be converted from ASCII to unicode by one decorator and compressed by another. The order of the decorators is important.&lt;/p&gt;

&lt;p&gt;In Perl, I can do this with objects, but I can also use a couple of language features to obtain most of the decorations I need, sometimes relying solely on built-in syntax.&lt;/p&gt;

&lt;p&gt;I/O is the most common use of decoration. Perl provides I/O decoration directly. Consider the above example: compressing while writing. Here are two ways to do this.&lt;/p&gt;

&lt;h4 id=&#34;span-id-use-the-shell-and-its-tools-use-the-shell-and-its-tools-span&#34;&gt;&lt;span id=&#34;use_the_shell_and_its_tools&#34;&gt;Use the Shell and Its Tools&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;When I open a file for writing in Perl, I can decorate via shell tools. Here is the above example in code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    open FILE, &amp;quot;| gzip &amp;gt; output.gz&amp;quot;
        or die &amp;quot;Couldn&#39;t open gzip and/or output.gz: $!\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now everything I write is passed through &lt;em&gt;gzip&lt;/em&gt; on its way to &lt;em&gt;output.gz&lt;/em&gt;. This works great so long as (1) you are willing to use the shell, which sometimes raises security issues; and (2) the shell has a tool to do what you need done. There is also an efficiency concern here. The operating system will spawn a new process for the gzip step. Process creation is about the slowest thing the OS can do without performing I/O.&lt;/p&gt;

&lt;h4 id=&#34;span-id-tying-tying-span&#34;&gt;&lt;span id=&#34;tying&#34;&gt;Tying&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;If you need more control over what happens to your data, then you can decorate it yourself with Perl&amp;rsquo;s tie mechanism. It will be even faster, easier to use, and more powerful in Perl 6, but it works in Perl 5. It does work within Perl&amp;rsquo;s OO framework; see &lt;a href=&#34;https://perldoc.perl.org/perltie.html&#34;&gt;perltie&lt;/a&gt; for more information.&lt;/p&gt;

&lt;p&gt;Suppose I want to preface each line of output on a handle with a time stamp. Here&amp;rsquo;s a tied class to do it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package AddStamp;
    use strict; use warnings;

    sub TIEHANDLE {
        my $class  = shift;
        my $handle = shift;
        return bless \$handle, $class;
    }

    sub PRINT {
        my $handle = shift;
        my $stamp  = localtime();

        print $handle &amp;quot;$stamp &amp;quot;, @_;
    }

    sub CLOSE {
        my $self = shift;
        close $self;
    }

    1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This class is minimal, in real life you need more code to make the decorator more robust and complete. For example, the above code does not check to make sure the handle is writable nor does it provide &lt;code&gt;PRINTF&lt;/code&gt;, so calls to &lt;code&gt;printf&lt;/code&gt; will fail. Feel free to fill in the details. (Again, see perldoc perltie for more information.)&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s what these pieces do. The constructor for a tied file handle class is called &lt;code&gt;TIEHANDLE&lt;/code&gt;. Its name is fixed and uppercase, because Perl calls this for you. This is a class method, so the first argument is the class name. The other argument is an open output handle. The constructor merely blesses a reference to this handle and returns that reference.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;PRINT&lt;/code&gt; method receives the object constructed in &lt;code&gt;TIEHANDLE&lt;/code&gt; plus all the arguments supplied to print. It calculates the time stamp and sends that together with the original arguments to the handle using the real print function. This is typical decoration at work. The decorating object responds to print just like a regular handle would. It does a little work, then calls the same method on the wrapped object.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;CLOSE&lt;/code&gt; method closes the handle. I could have inherited from &lt;a href=&#34;https://metacpan.org/pod/Tie::StdHandle&#34;&gt;Tie::StdHandle&lt;/a&gt; to gain this method and many more like it.&lt;/p&gt;

&lt;p&gt;Once I put &lt;em&gt;AddTimeStamp.pm&lt;/em&gt; in my lib path, I can use it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #!/usr/bin/perl
    use strict; use warnings;

    use AddStamp;

    open LOG, &amp;quot;&amp;gt;output.tmp&amp;quot; or die &amp;quot;Couldn&#39;t write output.tmp: $!\n&amp;quot;;
    tie *STAMPED_LOG, &amp;quot;AddStamp&amp;quot;, *LOG;

    while (&amp;lt;&amp;gt;) {
        print STAMPED_LOG;
    }

    close STAMPED_LOG;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After opening the file for writing as usual, I use the built-in &lt;code&gt;tie&lt;/code&gt; function to bind the &lt;code&gt;LOG&lt;/code&gt; handle to the &lt;code&gt;AddStamp&lt;/code&gt; class under the name &lt;code&gt;STAMPED_LOG&lt;/code&gt;. After that, I refer exclusively to &lt;code&gt;STAMPED_LOG&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If there are other tied decorators, then I can pass the tied handle to them. The only downside is that Perl 5 ties are slower than normal operations. Yet, in my experience, disks and networks are my bottlenecks so in memory inefficiency like this tends not to matter. Even if I make the script code execute 90 percent faster, I don&amp;rsquo;t save a noticeable amount of time, because it wasn&amp;rsquo;t using much time in the first place.&lt;/p&gt;

&lt;p&gt;This technique works for many of the built-in types: scalars, arrays, hashes, as well as file handles. &lt;em&gt;perltie&lt;/em&gt; explains how to tie each of those.&lt;/p&gt;

&lt;p&gt;Ties are great since they don&amp;rsquo;t require the caller to understand the magic you are employing behind their back. That is also true of GoF decorators with one clear exception: In Perl, you can change the behavior of built-in types.&lt;/p&gt;

&lt;h4 id=&#34;span-id-decorating-lists-decorating-lists-span&#34;&gt;&lt;span id=&#34;decorating_lists&#34;&gt;Decorating Lists&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;One of the most common tasks in Perl is to transform a list in some way. Perhaps you need to skip all entries in the list that start with underscore. Perhaps you need to sort or reverse the list. Many built-in functions are list filters. They take a list, do something to it and return a resultant list. This is similar to Unix filters, which expect lines of data on standard input, which they manipulate in some way, before sending the result to standard output. Just as in Unix, Perl list filters can be chained together. For example, suppose you want a list of all subdirectories of the current directory in reverse alphabetical order. Here&amp;rsquo;s one possible solution.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 1  #!/usr/bin/perl
 2  use strict; use warnings;
 3
 4  opendir DIR, &amp;quot;.&amp;quot;,
 5      or die &amp;quot;Can&#39;t read this directory, how did you get here?\n&amp;quot;;
 6  my @files = reverse sort map { -d $_ ? $_ : () } readdir DIR;
 7  closedir DIR;
 8  print &amp;quot;@files\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perl 6 will introduce a more meaningful notation for these operations, but you can learn to read them in Perl 5, with a little effort. Line 6 is the interesting one. Start reading it on the right (this is backward for Unix people). First, it reads the directory. Since &lt;code&gt;map&lt;/code&gt; expects a list, &lt;code&gt;readdir&lt;/code&gt; returns a list of all files in the directory. &lt;code&gt;map&lt;/code&gt; generates a list with the name of each file which is a directory (or &lt;code&gt;undef&lt;/code&gt; if the &lt;code&gt;-d&lt;/code&gt; test fails). &lt;code&gt;sort&lt;/code&gt; puts the list in ASCII-betical order. &lt;code&gt;reverse&lt;/code&gt; reverses that. The result is stored in &lt;code&gt;@files&lt;/code&gt; for later printing.&lt;/p&gt;

&lt;p&gt;You can make your own list filter quite easily. Suppose you wanted to replace the ugly &lt;code&gt;map&lt;/code&gt; usage above (I tend to think &lt;code&gt;map&lt;/code&gt; is always ugly) with a special purpose function, here&amp;rsquo;s how:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #!/usr/bin/perl
    use strict; use warnings;

    sub dirs_only (@) {
        my @retval;
        foreach my $entry (@_) {
            push @retval, $entry if (-d $entry);
        }
        return @retval;
    }

    opendir DIR, &amp;quot;.&amp;quot;
        or die &amp;quot;Can&#39;t read this directory, how did you get here?\n&amp;quot;;
    my @files = reverse sort { lc($a) cmp lc($b) } dirs_only readdir DIR;
    closedir DIR;
    local $&amp;quot; = &amp;quot;;&amp;quot;;
    print &amp;quot;@files\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The new &lt;code&gt;dirs_only&lt;/code&gt; routine replaces &lt;code&gt;map&lt;/code&gt; above, leaving out the entries we don&amp;rsquo;t want to see.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;sort&lt;/code&gt; now has an explicit comparison subroutine. This is to prevent it from thinking that &lt;code&gt;dirs_only&lt;/code&gt; is its comparison routine. Since I had to include this, I chose to take advantage of the situation and sort with more finesse: ignoring case.&lt;/p&gt;

&lt;p&gt;You can make such list filters to your heart&amp;rsquo;s content.&lt;/p&gt;

&lt;p&gt;I have now shown you the most important types of decoration. Any others you need could be implemented in the traditional GoF way.&lt;/p&gt;

&lt;p&gt;The next pattern feels like cheating, but then Perl often gives me that feeling.&lt;/p&gt;

&lt;h3 id=&#34;span-id-flyweight-flyweight-span&#34;&gt;&lt;span id=&#34;flyweight&#34;&gt;Flyweight&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The idea of reusing objects is the essence of the flyweight pattern. Thanks to Mark-Jason Dominus, Perl takes this far beyond what the GoF had in mind. Further, he did the work once and for all. Larry Wall likes this idea so much he&amp;rsquo;s promoting it to the core for Perl 6 (there&amp;rsquo;s that promotion concept again).&lt;/p&gt;

&lt;p&gt;What I want is this:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;For objects whose instances don&amp;rsquo;t matter (they are constants or random), those requesting a new object should be given the same one they already received whenever possible.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This pattern fails dramatically if separate instances matter. But if they don&amp;rsquo;t, then it would save time and memory.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an example of how this works in Perl. Suppose I want to provide a die class for games like Monopoly or Craps. My die class might look like this: (Warning: This example is contrived to show you the technique.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package CheapDie;
    use strict; use warnings;

    use Memoize;
    memoize(&#39;new&#39;);

    sub new {
        my $class = shift;
        my $sides = shift;
        return bless \$sides, $class;
    }

    sub roll {
        my $sides         = shift;
        my $random_number = rand;

        return int ($random_number * $sides) + 1;
    }

    1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On first glance, this looks like many other classes. It has a constructor called new. The constructor stores the received number of sides into a subroutine lexical variable (a.k.a. a my variable), returning a blessed reference to it. The roll method calculates a random number, scales it according to the number of sides, and returns the result.&lt;/p&gt;

&lt;p&gt;The only thing strange here are these two lines:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Memoize;
    memoize(&#39;new&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These exploit Perl&amp;rsquo;s magic extraordinarily well. The &lt;code&gt;memoize&lt;/code&gt; function modifies the calling package&amp;rsquo;s symbol table so that &lt;code&gt;new&lt;/code&gt; is wrapped. The wrapping function examines the incoming arguments (the number of sides in this case). If it has not seen those arguments before, then it would call the function as the user intended, storing the result in a cache and returning it to the user. This takes more time and memory than if I had not used the module.&lt;/p&gt;

&lt;p&gt;The savings come when the method is called again. When the wrapper notices a call with the same arguments it used before, it does not call the method. Rather, it sends the cached object instead. We don&amp;rsquo;t have to do anything special as a caller or as an object implementor. If your object is big, or slow to construct, then this technique would save you time and memory. In my case, it wastes both since the objects are so small.&lt;/p&gt;

&lt;p&gt;The only thing to keep in mind is that some methods don&amp;rsquo;t benefit from this technique. For example, if I memoize &lt;code&gt;roll&lt;/code&gt;, then it would return the same number each time, which is not exactly the desired result.&lt;/p&gt;

&lt;p&gt;Note too that &lt;a href=&#34;https://metacpan.org/pod/Memoize&#34;&gt;Memoize&lt;/a&gt; can be used in non-object situations - in fact the documentation for it doesn&amp;rsquo;t seem to contemplate using it for object factories.&lt;/p&gt;

&lt;p&gt;Not only do languages such as Java not have core functions for caching method returns, they don&amp;rsquo;t allow clever users to implement them. Mark-Jason Dominus did a fine thing implementing Memoize, but Larry Wall did a better thing by letting him. Imagine Java letting a user write a class that manipulated the caller&amp;rsquo;s symbol table at run time - I can almost hear the screams of terror. Of course, these techniques can be abused, but precluding them is a greater loss than rejecting poor code on the few occasions that some less-than-stellar programmer improperly adjusts the symbol table.&lt;/p&gt;

&lt;p&gt;In Perl all things are legal, but some are best left to modules with strong development communities. This allows regular users to take advantage of magic manipulations without worrying about whether our own magic will work. &lt;code&gt;Memoize&lt;/code&gt; is an example. Instead of rolling your own wrapped call and caching scheme, use the well-tested one that ships with Perl (and looked for the &amp;lsquo;is cached&amp;rsquo; trait to do this for routines in Perl 6).&lt;/p&gt;

&lt;p&gt;The next pattern is related to this one, so you can use flyweight to implement it.&lt;/p&gt;

&lt;h3 id=&#34;span-id-singleton-singleton-span&#34;&gt;&lt;span id=&#34;singleton&#34;&gt;Singleton&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In the flyweight pattern, we saw that there are sometimes resources that everyone can share. GoF calls the special case when there is a single resource that everyone needs to share the singleton pattern. Perhaps the resource is a hash of configuration parameters. Everyone should be able to look there, but it should only be built on startup (and possibly rebuilt on some signal).&lt;/p&gt;

&lt;p&gt;In most cases, you could just use &lt;code&gt;Memoize&lt;/code&gt;. That seems most reasonable to me. (See the flyweight section above.) In that case, everyone who wants access to the resource calls the constructor. The first person to do so causes the construction to happen and receives the object. Subsequent people call the constructor, but they receive the originally constructed object.&lt;/p&gt;

&lt;p&gt;There are many other ways to achieve this same effect. For instance, if you think your callers might pass you unexpected arguments, then &lt;code&gt;Memoize&lt;/code&gt; would make multiple instances, one for each set of arguments. In this case, managing the singleton with modules like &lt;a href=&#34;https://metacpan.org/pod/Cache::FastMemoryCache&#34;&gt;Cache::FastMemoryCache&lt;/a&gt; from CPAN may make more sense. You could even use a file lexical, assigning it a value in a &lt;code&gt;BEGIN&lt;/code&gt; block. Remember bless doesn&amp;rsquo;t have to be used in a method. You could say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package Name;
    my $singleton;
    BEGIN {
        $singleton = {
            attribute =&amp;gt; &#39;value&#39;,
            another   =&amp;gt; &#39;something&#39;,
        };
        bless $singleton, &amp;quot;Name&amp;quot;;
    }

    sub new {
        my $class = shift;
        return $singleton;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This avoids some of the overhead of Memoize and shows what I&amp;rsquo;m doing more directly. I made no attempt to take subclassing into account here. Maybe I should, but the pattern says a singleton should belong always to one class. The fundamental statement about singletons is:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;``There can only be one singleton.&amp;rdquo;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-summary-summary-span&#34;&gt;&lt;span id=&#34;summary&#34;&gt;Summary&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;All four of the patterns shown in this article use built-in features, or standard modules. The iterator is implemented with &lt;code&gt;foreach&lt;/code&gt;. The decorator is implemented for I/O with Unix pipe and redirection syntax or with a tied file handle. For lists, decorators are just functions which take and return lists. So, I might call decorators filters. Flyweights are shared objects easily implemented with the Memoize module. Singletons can be implemented as flyweights or with simple object techniques.&lt;/p&gt;

&lt;p&gt;The next time some uppity OO programmer starts going on about patterns, rest assured, you know how to use them. In fact, they are built-in to the core of your language (at least if you have the sense to use Perl).&lt;/p&gt;

&lt;p&gt;Next time, I will look at patterns which rely on code references or data containers.&lt;/p&gt;

&lt;h4 id=&#34;span-id-acknowledgements-and-background-acknowledgements-and-background-span&#34;&gt;&lt;span id=&#34;acknowledgements_and_background&#34;&gt;Acknowledgements and Background&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;I wrote these articles after taking a training course using GoF from a well-known training and consulting company. My writing is also informed by many people in the Perl community, including Mark-Jason Dominus, who showed at YAPC 2002, using his unique flair, how Perl deals with the iterator pattern. Though the writing here is mine, the inspiration comes from Dominus and many others in the Perl community, most of all Larry Wall, who have incorporated patterns into the heart of Perl during the years. As these patterns show, time and time again, Perl employs the principle of promotion carefully and well. Instead of adding a collection framework in source code modules, as Java and C++ do, Perl has only two collections: arrays and hashes. Both are core to the language. I think Perl&amp;rsquo;s greatest strength is the community&amp;rsquo;s choices of what to include in the core, what to ship along with the core, and what to leave out. Perl 6 will only make Perl more competitive in the war of language design ideas.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

