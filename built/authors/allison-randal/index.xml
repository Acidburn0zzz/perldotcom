<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Allison Randal on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/authors/allison-randal/</link>
    <description>Recent content in Allison Randal on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 25 Jun 2003 00:00:00 -0800</lastBuildDate>
    <atom:link href="/authors/allison-randal/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Perl 6 Design Philosophy</title>
      <link>http://localhost:1313/pub/2003/06/25/perl6essentials.html/</link>
      <pubDate>Wed, 25 Jun 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/06/25/perl6essentials.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: &lt;a href=&#34;http://www.oreilly.com/catalog/perl6es/index.html?CMP=IL7015&#34;&gt;Perl 6 Essentials&lt;/a&gt; is the first book to offer a peek into the next major version of the Perl language. It covers the development of Perl 6 syntax as well as Parrot, the language-independent interpreter developed as part of the Perl 6 design strategy. In this excerpt from Chapter 3 of the book, the authors take an in-depth look of some of the most important principles of natural language and their impact on the design decisions made in Perl 6.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;At the heart of every language is a core set of ideals that give the language its direction and purpose. If you really want to understand the choices that language designers make&amp;ndash;why they choose one feature over another or one way of expressing a feature over another&amp;ndash;the best place to start is with the reasoning behind the choices.&lt;/p&gt;

&lt;p&gt;Perl 6 has a unique set of influences. It has deep roots in Unix and the children of Unix, which gives it a strong emphasis on utility and practicality. It&amp;rsquo;s grounded in the academic pursuits of computer science and software engineering, which gives it a desire to solve problems the right way, not just the most expedient way. It&amp;rsquo;s heavily steeped in the traditions of linguistics and anthropology, which gives it the goal of comfortable adaptation to human use. These influences and others like them define the shape of Perl and what it will become.&lt;/p&gt;

&lt;h2 id=&#34;linguistic-and-cognitive-considerations&#34;&gt;Linguistic and Cognitive Considerations&lt;/h2&gt;

&lt;p&gt;Perl is a human language. Now, there are significant differences between Perl and languages like English, French, German, etc. For one, it is artificially constructed, not naturally occurring. Its primary use, providing a set of instructions for a machine to follow, covers a limited range of human existence. Even so, Perl is a language humans use for communicating. Many of the same mental processes that go into speaking or writing are duplicated in writing code. The process of learning to use Perl is much like learning to speak a second language. The mental processes involved in reading are also relevant. Even though the primary audience of Perl code is a machine, as often as not humans have to read the code while they&amp;rsquo;re writing it, reviewing it, or maintaining it.&lt;/p&gt;

&lt;p&gt;Many Perl design decisions have been heavily influenced by the principles of natural language. The following are some of the most important principles, the ones we come back to over and over again while working on the design and the ones that have had the greatest impact.&lt;/p&gt;

&lt;h3 id=&#34;the-waterbed-theory-of-complexity&#34;&gt;The Waterbed Theory of Complexity&lt;/h3&gt;

&lt;p&gt;The natural tendency in human languages is to keep overall complexity about equivalent, both from one language to the next, and over time as a language changes. Like a waterbed, if you push down the complexity in one part of the language, it increases complexity elsewhere. A language with a rich system of sounds (phonology) might compensate with a simpler syntax. A language with a limited sound system might have a complex way of building words from smaller pieces (morphology). No language is complex in every way, as that would be unusable. Likewise, no language is completely simple, as too few distinctions would render it useless.&lt;/p&gt;

&lt;p&gt;The same is true of computer languages. They require a constant balance between complexity and simplicity. Restricting the possible operators to a small set leads to a proliferation of user-defined methods and subroutines. This is not a bad thing, in itself, but it encourages code that is verbose and difficult to read. On the other hand, a language with too many operators encourages code that is heavy in line noise and difficult to read. Somewhere in the middle lies the perfect balance.&lt;/p&gt;

&lt;h3 id=&#34;the-principle-of-simplicity&#34;&gt;The Principle of Simplicity&lt;/h3&gt;

&lt;p&gt;In general, a simple solution is preferable to a complex one. A simple syntax is easier to teach, remember, use, and read. But this principle is in constant tension with the waterbed theory. Simplification in the wrong area is one danger to avoid. Another is false simplicity or oversimplification. Some problems are complex and require a complex solution. Perl 6 grammars aren&amp;rsquo;t simple. But they are complex at the language level in a way that allows simpler solutions at the user level.&lt;/p&gt;

&lt;h3 id=&#34;the-principle-of-adaptability&#34;&gt;The Principle of Adaptability&lt;/h3&gt;

&lt;p&gt;Natural languages grow and change over time. They respond to changes in the environment and to internal pressure. New vocabulary springs up to handle new communication needs. Old idioms die off as people forget them, and newer, more relevant idioms take their place. Complex parts of the system tend to break down and simplify over time. Change is what keeps language active and relevant to the people who use it. Only dead languages stop changing.&lt;/p&gt;

&lt;p&gt;The plan for Perl 6 explicitly includes plans for future language changes. No one believes that Perl 6.0.0 will be perfect, but at the same time, no one wants another change process quite as dramatic as Perl 6. So Perl 6 will be flexible and adaptable enough to allow gradual shifts over time. This has influenced a number of design decisions, including making it easy to modify how the language is parsed, lowering the distinctions between core operations and user-defined operations, and making it easy to define new operators.&lt;/p&gt;

&lt;h3 id=&#34;the-principle-of-prominence&#34;&gt;The Principle of Prominence&lt;/h3&gt;

&lt;p&gt;In natural languages, certain structures and stylistic devices draw attention to an important element. This could be emphasis, as in &amp;ldquo;The &lt;em&gt;dog&lt;/em&gt; stole my wallet&amp;rdquo; (the dog, not the man), or extra verbiage, as in &amp;ldquo;It was the dog who stole my wallet,&amp;rdquo; or a shift to an unusual word order, &amp;ldquo;My wallet was stolen by the dog&amp;rdquo; (my wallet, not my shoe, etc.), or any number of other verbal tricks.&lt;/p&gt;

&lt;p&gt;Perl is designed with its own set of stylistic devices to mark prominence, some within the language itself, and some that give users flexibility to mark prominence within their code. The &lt;code&gt;NAMED&lt;/code&gt; blocks use all capitals to draw attention to the fact that they&amp;rsquo;re outside the normal flow of control. Perl 5 has an alternate syntax for control structures like &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;for&lt;/code&gt;, which moves them to the end to serve as statement modifiers (because Perl is a left-to-right language, the left side is always a position of prominence). Perl 6 keeps this flexibility, and adds a few new control structures to the list.&lt;/p&gt;

&lt;p&gt;The balance for design is to decide which features deserve to be marked as prominent, and where the syntax needs a little flexibility so the language can be more expressive.&lt;/p&gt;

&lt;h3 id=&#34;the-principle-of-end-weight&#34;&gt;The Principle of End Weight&lt;/h3&gt;

&lt;p&gt;Natural languages place large complex elements at the end of sentences. So, even though &amp;ldquo;I gave Mary the book&amp;rdquo; and &amp;ldquo;I gave the book to Mary&amp;rdquo; are equally comfortable, &amp;ldquo;I gave the book about the history of development of peanut-based products in Indonesia to Mary&amp;rdquo; is definitely less comfortable than the other way around. This is largely a mental parsing problem. It&amp;rsquo;s easier to interpret the major blocks of the sentence all at once than to start with a few, work through a large chunk of minor information, and then go back to fill in the major sentence structure. Human memory is limited.&lt;/p&gt;

&lt;p&gt;End weight is one of the reasons regular expression modifiers were moved to the front in Perl 6. It&amp;rsquo;s easier to read a grammar rule when you know things like &amp;ldquo;this rule is case insensitive&amp;rdquo; right at the start. (It&amp;rsquo;s also easier for the machine to parse, which is almost as important.)&lt;/p&gt;

&lt;p&gt;End weight is also why there has been some desire to reorder the arguments in &lt;code&gt;grep&lt;/code&gt; to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grep @array { potentially long and complex block };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But that change causes enough cultural tension that it may not happen.&lt;/p&gt;

&lt;h3 id=&#34;the-principle-of-context&#34;&gt;The Principle of Context&lt;/h3&gt;

&lt;p&gt;Natural languages use context when interpreting meaning. The meanings of &amp;ldquo;hot&amp;rdquo; in &amp;ldquo;a hot day,&amp;rdquo; &amp;ldquo;a hot stereo,&amp;rdquo; &amp;ldquo;a hot idea,&amp;rdquo; and &amp;ldquo;a hot debate&amp;rdquo; are all quite different. The implied meaning of &amp;ldquo;it&amp;rsquo;s wet&amp;rdquo; changes depending on whether it&amp;rsquo;s a response to &amp;ldquo;Should I take a coat?&amp;rdquo; or &amp;ldquo;Why is the dog running around the kitchen?&amp;rdquo; The surrounding context allows us to distinguish these meanings. Context appears in other areas as well. A painting of an abstract orange sphere will be interpreted differently depending on whether the other objects in the painting are bananas, clowns, or basketball players. The human mind constantly tries to make sense of the universe, and it uses every available clue.&lt;/p&gt;

&lt;p&gt;Perl has always been a context-sensitive language. It makes use of context in a number of different ways. The most obvious use is scalar and list contexts, where a variable may return a different value depending on where and how it&amp;rsquo;s used. These have been extended in Perl 6 to include string context, boolean context, numeric context, and others. Another use of context is the &lt;code&gt;$_&lt;/code&gt; defaults, like &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;chomp&lt;/code&gt;, matches, and now &lt;code&gt;when&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Context-dependent features are harder to write an interpreter for, but they&amp;rsquo;re easier on the people who use the language daily. They fit in with the way humans naturally think, which is one of Perl&amp;rsquo;s top goals.&lt;/p&gt;

&lt;h3 id=&#34;the-principle-of-dwim&#34;&gt;The Principle of DWIM&lt;/h3&gt;

&lt;p&gt;In natural languages there is a notion called &amp;ldquo;native speaker&amp;rsquo;s intuition.&amp;rdquo; Someone who speaks a language fluently will be able to tell whether a sentence is correct, even if they can&amp;rsquo;t consciously explain the rules. (This has little to do with the difficulty English teachers have getting their students to use &amp;ldquo;proper&amp;rdquo; grammar. The rules of formal written English are very different from the rules of spoken English.)&lt;/p&gt;

&lt;p&gt;As much as possible, features should do what the user expects. This concept of DWIM, or &amp;ldquo;Do What I Mean,&amp;rdquo; is largely a matter of intuition. The user&amp;rsquo;s experiences, language exposure, and cultural background all influence their expectations. This means that intuition varies from person to person. An English speaker won&amp;rsquo;t expect the same things as a Dutch speaker, and an Ada programmer won&amp;rsquo;t expect the same things as a COBOL programmer.&lt;/p&gt;

&lt;p&gt;The trick in design is to use the programmer&amp;rsquo;s intuitions instead of fighting against them. A clearly defined set of rules will never match the power of a feature that &amp;ldquo;just seems right.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Perl 6 targets Perl programmers. What seems right to one Perl programmer may not seem right to another, so no feature will please everyone. But it is possible to catch the majority cases.&lt;/p&gt;

&lt;p&gt;Perl generally targets English speakers. It uses words like &amp;ldquo;given,&amp;rdquo; which gives English speakers a head start in understanding its behavior in code. Of course, not all Perl programmers are English speakers. In some cases idiomatic English is toned down for broader appeal. In grammar rules, ordinal modifiers have the form &lt;code&gt;1st&lt;/code&gt;, &lt;code&gt;2nd&lt;/code&gt;, &lt;code&gt;3rd&lt;/code&gt;, &lt;code&gt;4th&lt;/code&gt;, etc., because those are most natural for native English speakers. But they also have an alternate form &lt;code&gt;1th&lt;/code&gt;, &lt;code&gt;2th&lt;/code&gt;, etc., with the general rule *N*th, because the English endings for ordinal numbers are chaotic and unfriendly to non-native speakers.&lt;/p&gt;

&lt;h3 id=&#34;the-principle-of-reuse&#34;&gt;The Principle of Reuse&lt;/h3&gt;

&lt;p&gt;Human languages tend to have a limited set of structures and reuse them repeatedly in different contexts. Programming languages also employ a set of ordinary syntactic conventions. A language that used &lt;code&gt;{ }&lt;/code&gt; braces to delimit loops but paired keywords to delimit &lt;code&gt;if&lt;/code&gt; statements (like &lt;code&gt;if  ... then&lt;/code&gt; &lt;code&gt;... end if&lt;/code&gt;) would be incredibly annoying. Too many rules make it hard to find the pattern.&lt;/p&gt;

&lt;p&gt;In design, if you have a certain syntax to express one feature, it&amp;rsquo;s often better to use the same syntax for a related feature than to invent something entirely new. It gives the language an overall sense of consistency, and makes the new features easier to remember. This is part of why grammars are structured as classes. Grammars could use any syntax, but classes already express many of the features grammars need, like inheritance and the concept of creating an instance.&lt;/p&gt;

&lt;h3 id=&#34;the-principle-of-distinction&#34;&gt;The Principle of Distinction&lt;/h3&gt;

&lt;p&gt;The human mind has an easier time identifying big differences than small ones. The words &amp;ldquo;cat&amp;rdquo; and &amp;ldquo;dog&amp;rdquo; are easier to tell apart than &amp;ldquo;snore&amp;rdquo; and &amp;ldquo;shore.&amp;rdquo; Usually context provides the necessary clues, but if &amp;ldquo;cats&amp;rdquo; were &amp;ldquo;togs,&amp;rdquo; we would be endlessly correcting people who heard us wrong (&amp;ldquo;No, I said the Johnsons got a new dog, not tog, &lt;em&gt;dog&lt;/em&gt;.&amp;ldquo;).&lt;/p&gt;

&lt;p&gt;The design consideration is to build in visual clues to subtle contrasts. The language should avoid making too many different things similar. Excessive overloading reduces readability and increases the chance for confusion. This is part of the motivation for splitting the two meanings of &lt;code&gt;eval&lt;/code&gt; into &lt;code&gt;try&lt;/code&gt; and &lt;code&gt;eval&lt;/code&gt;, the two meanings of &lt;code&gt;for&lt;/code&gt; into &lt;code&gt;for&lt;/code&gt; and &lt;code&gt;loop&lt;/code&gt;, and the two uses of &lt;code&gt;sub&lt;/code&gt; into &lt;code&gt;sub&lt;/code&gt; and &lt;code&gt;method&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Distinction and reuse are in constant tension. If too many features are reused and overloaded, the language will begin to blur together. Far too much time will be spent trying to figure out exactly which use is intended. But, if too many features are entirely distinct, the language will lose all sense of consistency and coherence. Again, it&amp;rsquo;s a balance.&lt;/p&gt;

&lt;h3 id=&#34;language-cannot-be-separated-from-culture&#34;&gt;Language Cannot Be Separated from Culture&lt;/h3&gt;

&lt;p&gt;A natural language without a community of speakers is a dead language. It may be studied for academic reasons, but unless someone takes the effort to preserve the language, it will eventually be lost entirely. A language adds to the community&amp;rsquo;s sense of identity, while the community keeps the language relevant and passes it on to future generations. The community&amp;rsquo;s culture shapes the language and gives it a purpose for existence.&lt;/p&gt;

&lt;p&gt;Computer languages are equally dependent on the community behind them. You can measure it by corporate backing, lines of code in operation, or user interest, but it all boils down to this: a programming language is dead if it&amp;rsquo;s not used. The final sign of language death is when there are no compilers or interpreters for the language that will run on existing hardware and operating systems.&lt;/p&gt;

&lt;p&gt;For design work this means it&amp;rsquo;s not enough to only consider how a feature fits with other features in the language. The community&amp;rsquo;s traditions and expectations also weigh in, and some changes have a cultural price.&lt;/p&gt;

&lt;h3 id=&#34;the-principle-of-freedom&#34;&gt;The Principle of Freedom&lt;/h3&gt;

&lt;p&gt;In natural languages there is always more than one way to express an idea. The author or speaker has the freedom, and the responsibility, to pick the best phrasing&amp;ndash;to put just the right spin on the idea so it makes sense to their audience.&lt;/p&gt;

&lt;p&gt;Perl has always operated on the principle that programmers should have the freedom to choose how to express their code. It provides easy access to powerful features and leaves it to the individuals to use them wisely. It offers customs and conventions rather than enforcing laws.&lt;/p&gt;

&lt;p&gt;This principle influences design in several ways. If a feature is beneficial to the language as a whole, it won&amp;rsquo;t be rejected just because someone could use it foolishly. On the other hand, we aren&amp;rsquo;t above making some features difficult to use, if they should be used rarely.&lt;/p&gt;

&lt;p&gt;Another part of the design challenge is to build tools that will have many uses. No one wants a cookbook that reads like a Stephen King novel, and no one wants a one-liner with the elaborate structure of a class definition. The language has to be flexible to accommodate freedom.&lt;/p&gt;

&lt;h3 id=&#34;the-principle-of-borrowing&#34;&gt;The Principle of Borrowing&lt;/h3&gt;

&lt;p&gt;Borrowing is common in natural languages. When a new technology (food, clothing, etc.) is introduced from another culture, it&amp;rsquo;s quite natural to adopt the original name for it. Most of the time borrowed words are adapted to the new language. In English, no one pronounces &amp;ldquo;tortilla,&amp;rdquo; &amp;ldquo;lasagna,&amp;rdquo; or &amp;ldquo;champagne&amp;rdquo; exactly as in the original languages. They&amp;rsquo;ve been altered to fit the English sound system.&lt;/p&gt;

&lt;p&gt;Perl has always borrowed features, and Perl 6 will too. There&amp;rsquo;s no shame in acknowledging that another language did an excellent job implementing a particular feature. It&amp;rsquo;s far better to openly borrow a good feature than to pretend it&amp;rsquo;s original. Perl doesn&amp;rsquo;t have to be different just for the sake of being different. Most features won&amp;rsquo;t be adopted without any changes, though. Every language has its own conventions and syntax, and many aren&amp;rsquo;t compatible. So, Perl borrows features, but uses equivalent structures to express them.&lt;/p&gt;

&lt;h2 id=&#34;architectural-considerations&#34;&gt;Architectural Considerations&lt;/h2&gt;

&lt;p&gt;The second set of principles governs the overall architecture of Perl 6. These principles are connected to the past, present, and future of Perl, and define the fundamental purpose of Perl 6. No principle stands alone; each is balanced against the others.&lt;/p&gt;

&lt;h3 id=&#34;perl-should-stay-perl&#34;&gt;Perl Should Stay Perl&lt;/h3&gt;

&lt;p&gt;Everyone agrees that Perl 6 should still be Perl, but the question is, what exactly does that mean? It doesn&amp;rsquo;t mean Perl 6 will have exactly the same syntax. It doesn&amp;rsquo;t mean Perl 6 will have exactly the same features. If it did, Perl 6 would just be Perl 5. So, the core of the question is what makes Perl &amp;ldquo;Perl&amp;rdquo;?&lt;/p&gt;

&lt;h4 id=&#34;true-to-the-original-purpose&#34;&gt;True to the original purpose&lt;/h4&gt;

&lt;p&gt;Perl will stay true to its designer&amp;rsquo;s original intended purpose. Larry wanted a language that would get the job done without getting in his way. The language had to be powerful enough to accomplish complex tasks, but still lightweight and flexible. As Larry is fond of saying, &amp;ldquo;Perl makes the easy things easy and the hard things possible.&amp;rdquo; The fundamental design philosophy of Perl hasn&amp;rsquo;t changed. In Perl 6, the easy things are a little easier and the hard things are more possible.&lt;/p&gt;

&lt;h4 id=&#34;familiarity&#34;&gt;Familiarity&lt;/h4&gt;

&lt;p&gt;Perl 6 will be familiar to Perl 5 users. The fundamental syntax is still the same. It&amp;rsquo;s just a little cleaner and a little more consistent. The basic feature set is still the same. It adds some powerful features that will probably change the way we code in Perl, but they aren&amp;rsquo;t required.&lt;/p&gt;

&lt;p&gt;Learning Perl 6 will be like American English speakers learning Australian English, not English speakers learning Japanese. Sure, there are some vocabulary changes, and the tone is a little different, but it is still&amp;ndash;without any doubt&amp;ndash;English.&lt;/p&gt;

&lt;h4 id=&#34;translatable&#34;&gt;Translatable&lt;/h4&gt;

&lt;p&gt;Perl 6 will be mechanically translatable from Perl 5. In the long term, this isn&amp;rsquo;t nearly as important as what it will be like to write code in Perl 6. But during the transition phase, automatic translation will be important. It will allow developers to start moving ahead before they understand every subtle nuance of every change. Perl has always been about learning what you need now and learning more as you go.&lt;/p&gt;

&lt;h3 id=&#34;important-new-features&#34;&gt;Important New Features&lt;/h3&gt;

&lt;p&gt;Perl 6 will add a number of features such as exceptions, delegation, multi-method dispatch, continuations, coroutines, and currying, to name a few. These features have proven useful in other languages and provide a great deal of power for solving certain problems. They improve the stability and flexibility of the language.&lt;/p&gt;

&lt;p&gt;Many of these features are traditionally difficult to understand. Perl takes the same approach as always: provide powerful tools, make them easy to use, and leave it up to the user to decide whether and how to use them. Most users probably won&amp;rsquo;t even know they&amp;rsquo;re using currying when they use the &lt;code&gt;assuming&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;Features like these are an important part of preparing Perl for the future. Who knows what development paradigms might develop in a language that has this combination of advanced features in a form easily approachable by the average programmer. It may not be a revolution, but it&amp;rsquo;s certainly evolution.&lt;/p&gt;

&lt;h3 id=&#34;long-term-usability&#34;&gt;Long-Term Usability&lt;/h3&gt;

&lt;p&gt;Perl 6 isn&amp;rsquo;t a revision intended to last a couple of years and then be tossed out. It&amp;rsquo;s intended to last 20 years or more. This long-range vision affects the shape of the language and the process of building it. We&amp;rsquo;re not interested in the latest fad or in whipping up a few exciting tricks. We want strong, dependable tools with plenty of room to grow. And we&amp;rsquo;re not afraid to take a little extra time now to get it right. This doesn&amp;rsquo;t mean Perl 6.0 will be perfect, any more than any other release has been perfect. It&amp;rsquo;s just another step of progress.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;O&amp;rsquo;Reilly &amp;amp; Associates recently released (June 2003) &lt;a href=&#34;http://www.oreilly.com/catalog/perl6es/index.html?CMP=IL7015&#34;&gt;Perl 6 Essentials&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.oreilly.com/catalog/perl6es/chapter/&#34;&gt;Sample Chapter 1: Project Overview&lt;/a&gt;, is available free online.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You can also look at the &lt;a href=&#34;http://www.oreilly.com/catalog/perl6es/toc.html&#34;&gt;Table of Contents&lt;/a&gt;, the &lt;a href=&#34;http://www.oreilly.com/catalog/perl6es/inx.html&#34;&gt;Index&lt;/a&gt;, and the &lt;a href=&#34;http://www.oreilly.com/catalog/perl6es/desc.html&#34;&gt;Full Description&lt;/a&gt; of the book.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;For more information, or to order the book, &lt;a href=&#34;http://www.oreilly.com/catalog/perl6es/index.html?CMP=IL7015&#34;&gt;click here&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Synopsis 6</title>
      <link>http://localhost:1313/pub/2003/04/09/synopsis.html/</link>
      <pubDate>Wed, 09 Apr 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/04/09/synopsis.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 6&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This document summarizes Apocalypse 6, which covers subroutines and the new type system.&lt;/p&gt;

&lt;h3 id=&#34;span-id-subroutines-and-other-code-objects-subroutines-and-other-code-objects-span&#34;&gt;&lt;span id=&#34;subroutines_and_other_code_objects&#34;&gt;Subroutines and Other Code Objects&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Subroutines&lt;/strong&gt; (keyword: &lt;code&gt;sub&lt;/code&gt;) are noninheritable routines with parameter lists.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Methods&lt;/strong&gt; (keyword: &lt;code&gt;method&lt;/code&gt;) are inheritable routines that always have an associated object (known as their invocant) and belong to a particular class.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Submethods&lt;/strong&gt; (keyword: &lt;code&gt;submethod&lt;/code&gt;) are noninheritable methods, or subroutines masquerading as methods. They have an invocant and belong to a particular class.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Multimethods&lt;/strong&gt; (keyword: &lt;code&gt;multi&lt;/code&gt;) are routines that do not belong to a particular class, but which have one or more invocants.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rules&lt;/strong&gt; (keyword: &lt;code&gt;rule&lt;/code&gt;) are methods (of a grammar) that perform pattern matching. Their associated block has a special syntax (see Synopsis 5).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Macros&lt;/strong&gt; (keyword: &lt;code&gt;macro&lt;/code&gt;) are routines whose calls execute as soon as they are parsed (i.e. at compile-time). Macros may return another source code string or a parse-tree.&lt;/p&gt;

&lt;h4 id=&#34;span-id-standard-subroutines-standard-subroutines-span&#34;&gt;&lt;span id=&#34;standard_subroutines&#34;&gt;Standard Subroutines&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The general syntax for named subroutines is any of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     my RETTYPE sub NAME ( PARAMS ) TRAITS {...}
    our RETTYPE sub NAME ( PARAMS ) TRAITS {...}
                sub NAME ( PARAMS ) TRAITS {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The general syntax for anonymous subroutines is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub ( PARAMS ) TRAITS {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;ldquo;Trait&amp;rdquo; is the new name for a compile-time (&lt;code&gt;is&lt;/code&gt;) property. See &lt;a href=&#34;#traits_and_properties&#34;&gt;Traits and Properties&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-perl5ish-subroutine-declarations-perl5ish-subroutine-declarations-span&#34;&gt;&lt;span id=&#34;perl5ish_subroutine_declarations&#34;&gt;Perl5ish Subroutine Declarations&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;You can still declare a sub without parameter list, as in Perl 5:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Arguments still come in via the &lt;code&gt;@_&lt;/code&gt; array, but they are &lt;strong&gt;constant&lt;/strong&gt; aliases to actual arguments:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub say { print qq{&amp;quot;@_&amp;quot;\n}; }   # args appear in @_

    sub cap { $_ = uc $_ for @_ }   # Error: elements of @_ are constant
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you need to modify the elements of &lt;code&gt;@_&lt;/code&gt;, then declare it with the &lt;a href=&#34;#item_is_rw&#34;&gt;&lt;code&gt;is rw&lt;/code&gt;&lt;/a&gt; trait:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub swap (*@_ is rw) { @_[0,1] = @_[1,0] }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-blocks-blocks-span&#34;&gt;&lt;span id=&#34;blocks&#34;&gt;Blocks&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Raw blocks are also executable code structures in Perl 6.&lt;/p&gt;

&lt;p&gt;Every block defines a subroutine, which may either be executed immediately or passed in as a &lt;code&gt;Code&lt;/code&gt; reference argument to some other subroutine.&lt;/p&gt;

&lt;h4 id=&#34;span-id-pointy-subs-pointy-subs-span&#34;&gt;&lt;span id=&#34;pointy_subs&#34;&gt;&amp;ldquo;Pointy subs&amp;rdquo;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The arrow operator &lt;code&gt;-&amp;gt;&lt;/code&gt; is almost a synonym for the anonymous &lt;code&gt;sub&lt;/code&gt; keyword. The parameter list of a pointy sub does not require parentheses and a pointy sub may not be given traits.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $sq = -&amp;gt; $val { $val**2 };  # Same as: $sq = sub ($val) { $val**2 };

    for @list -&amp;gt; $elem {        # Same as: for @list, sub ($elem) {
        print &amp;quot;$elem\n&amp;quot;;        #              print &amp;quot;$elem\n&amp;quot;;
    }                           #          }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-stub-declarations-stub-declarations-span&#34;&gt;&lt;span id=&#34;stub_declarations&#34;&gt;Stub Declarations&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;To predeclare a subroutine without actually defining it, use a &amp;ldquo;stub block&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo {...};     # Yes, those three dots are part of the actual syntax
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The old Perl 5 form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is a compile-time error in Perl 6 (for reasons explained in Apocalypse 6).&lt;/p&gt;

&lt;h4 id=&#34;span-id-globally-scoped-subroutines-globally-scoped-subroutines-span&#34;&gt;&lt;span id=&#34;globally_scoped_subroutines&#34;&gt;Globally Scoped Subroutines&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Subroutines and variables can be declared in the global namespace, and are thereafter visible everywhere in a program.&lt;/p&gt;

&lt;p&gt;Global subroutines and variables are normally referred to by prefixing their identifier with &lt;code&gt;*&lt;/code&gt;, but it may be omitted if the reference is unambiguous:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $*next_id = 0;
    sub *saith($text)  { print &amp;quot;Yea verily, $text&amp;quot; }

    module A {
        my $next_id = 2;    # hides any global or package $next_id
        saith($next_id);    # print the lexical $next_id;
        saith($*next_id);   # print the global $next_id;
    }

    module B {
        saith($next_id);    # Unambiguously the global $next_id
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-lvalue-subroutines-lvalue-subroutines-span&#34;&gt;&lt;span id=&#34;lvalue_subroutines&#34;&gt;Lvalue Subroutines&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Lvalue subroutines return a &amp;ldquo;proxy&amp;rdquo; object that can be assigned to. It&amp;rsquo;s known as a proxy because the object usually represents the purpose or outcome of the subroutine call.&lt;/p&gt;

&lt;p&gt;Subroutines are specified as being lvalue using the &lt;a href=&#34;#item_is_rw&#34;&gt;&lt;code&gt;is rw&lt;/code&gt;&lt;/a&gt; trait.&lt;/p&gt;

&lt;p&gt;An lvalue subroutine may return a variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $lastval;
    sub lastval () is rw { return $lastval }

or the result of some nested call to an lvalue subroutine:

    sub prevval () is rw { return lastval() }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or a specially tied proxy object, with suitably programmed &lt;code&gt;FETCH&lt;/code&gt; and &lt;code&gt;STORE&lt;/code&gt; methods:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub checklastval ($passwd) is rw {
        my $proxy is Proxy(
                FETCH =&amp;gt; sub ($self) {
                            return lastval();
                         },
                STORE =&amp;gt; sub ($self, $val) {
                            die unless check($passwd);
                            lastval() = $val;
                         },
        );
        return $proxy;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-operator-overloading-operator-overloading-span&#34;&gt;&lt;span id=&#34;operator_overloading&#34;&gt;Operator Overloading&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Operators are just subroutines with special names.&lt;/p&gt;

&lt;p&gt;Unary operators are defined as prefix or postfix:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub prefix:OPNAME  ($operand) {...}
    sub postfix:OPNAME ($operand) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Binary operators are defined as infix:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub infix:OPNAME ($leftop, $rightop) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bracketing operators are defined as circumfix. The leading and trailing delimiters together are the name of the operator.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub circumfix:LEFTDELIM...RIGHTDELIM ($contents) {...}
    sub circumfix:DELIMITERS ($contents) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the left and right delimiters aren&amp;rsquo;t separated by &amp;ldquo;&lt;code&gt;...&lt;/code&gt;&amp;rdquo;, then the &lt;code&gt;DELIMITERS&lt;/code&gt; string must have an even number of characters. The first half is treated as the opening delimiter and the second half as the closing.&lt;/p&gt;

&lt;p&gt;Operator names can be any sequence of Unicode characters. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub infix:(c)        ($text, $owner) { return $text but Copyright($owner) }
    method prefix:± (Num $x) returns Num { return +$x | -$x }
    multi postfix:!             (Int $n) { $n&amp;lt;2 ?? 1 :: $n*($n-1)! }
    macro circumfix:&amp;lt;!--...--&amp;gt;   ($text) { &amp;quot;&amp;quot; }

    my $document = $text (c) $me;

    my $tolerance = ±7!;

    &amp;lt;!-- This is now a comment --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-parameters-and-arguments-parameters-and-arguments-span&#34;&gt;&lt;span id=&#34;parameters_and_arguments&#34;&gt;Parameters and Arguments&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Perl 6 subroutines may be declared with parameter lists.&lt;/p&gt;

&lt;p&gt;By default, all parameters are constant aliases to their corresponding arguments &amp;ndash; the parameter is just another name for the original argument, but the argument can&amp;rsquo;t be modified through it. To allow modification, use the &lt;a href=&#34;#item_is_rw&#34;&gt;&lt;code&gt;is rw&lt;/code&gt;&lt;/a&gt; trait. To pass-by-copy, use the &lt;a href=&#34;#item_is_copy&#34;&gt;&lt;code&gt;is copy&lt;/code&gt;&lt;/a&gt; trait.&lt;/p&gt;

&lt;p&gt;Parameters may be required or optional. They may be passed by position, or by name. Individual parameters may confer a scalar or list context on their corresponding arguments.&lt;/p&gt;

&lt;p&gt;Arguments destined for required parameters must come before those bound to optional parameters. Arguments destined for positional parameters must come before those bound to named parameters.&lt;/p&gt;

&lt;h4 id=&#34;span-id-invocant-parameters-invocant-parameters-span&#34;&gt;&lt;span id=&#34;invocant_parameters&#34;&gt;Invocant Parameters&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;A method invocant is specified as the first parameter in the parameter list, with a colon (rather than a comma) immediately after it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method get_name ($self:) {...}
    method set_name ($me: $newname) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The corresponding argument (the invocant) is evaluated in scalar context and is passed as the left operand of the method call operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print $obj.get_name();
    $obj.set_name(&amp;quot;Sam&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Multimethod invocants are specified at the start of the parameter list, with a colon terminating the list of invocants:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi handle_event ($window, $event: $mode) {...}    # two invocants
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Multimethod invocant arguments are passed positionally, though the first invocant can be passed via the method call syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Multimethod calls...
    handle_event($w, $e, $m);
    $w.handle_event($e, $m);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Invocants may also be passed using the indirect object syntax, with a colon after them. The colon is just a special form of the comma, and has the same precedence:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Indirect method call...
    set_name $obj: &amp;quot;Sam&amp;quot;;

    # Indirect multimethod call...
    handle_event $w, $e: $m;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Passing too many or too few invocants is a fatal error.&lt;/p&gt;

&lt;p&gt;The first invocant is always the topic of the corresponding method or multimethod.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 6&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-required-parameters-required-parameters-span&#34;&gt;&lt;span id=&#34;required_parameters&#34;&gt;Required Parameters&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Required parameters are specified at the start of a subroutine&amp;rsquo;s parameter list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub numcmp ($x, $y) { return $x &amp;lt;=&amp;gt; $y }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The corresponding arguments are evaluated in scalar context and may be passed positionally or by name. To pass an argument by name, specify it as a pair: &lt;code&gt;parameter_name =&amp;gt; argument_value&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $comparison = numcmp(2,7);
    $comparison = numcmp(x=&amp;gt;2, y=&amp;gt;7);
    $comparison = numcmp(y=&amp;gt;7, x=&amp;gt;2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Passing the wrong number of required arguments is a fatal error.&lt;/p&gt;

&lt;p&gt;The number of required parameters a subroutine has can be determined by calling its &lt;code&gt;.arity&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $args_required = &amp;amp;foo.arity;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-optional-parameters-optional-parameters-span&#34;&gt;&lt;span id=&#34;optional_parameters&#34;&gt;Optional Parameters&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Optional positional parameters are specified after all the required parameters and each is marked with a &lt;code&gt;?&lt;/code&gt; before the parameter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub my_substr ($str, ?$from, ?$len) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;=&lt;/code&gt; sign introduces a default value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub my_substr ($str, ?$from = 0, ?$len = Inf) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Default values can be calculated at run-time. They can even use the values of preceding parameters:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub xml_tag ($tag, ?$endtag = matching_tag($tag) ) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Arguments that correspond to optional parameters are evaluated in scalar context. They can be omitted, passed positionally, or passed by name:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my_substr(&amp;quot;foobar&amp;quot;);            # $from is 0, $len is infinite
    my_substr(&amp;quot;foobar&amp;quot;,1);          # $from is 1, $len is infinite
    my_substr(&amp;quot;foobar&amp;quot;,1,3);        # $from is 1, $len is 3
    my_substr(&amp;quot;foobar&amp;quot;,len=&amp;gt;3);     # $from is 0, $len is 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Missing optional arguments default to their default value, or to &lt;code&gt;undef&lt;/code&gt; if they have no default.&lt;/p&gt;

&lt;h4 id=&#34;span-id-named-parameters-named-parameters-span&#34;&gt;&lt;span id=&#34;named_parameters&#34;&gt;Named Parameters&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Named parameters follow any required or optional parameters in the signature. They are marked by a &lt;code&gt;+&lt;/code&gt; before the parameter.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub formalize($text, +$case, +$justify) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Arguments that correspond to named parameters are evaluated in scalar context. They can only be passed by name, so it doesn&amp;rsquo;t matter what order you pass them in, so long as they follow any positional arguments:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $formal = formalize($title, case=&amp;gt;&#39;upper&#39;);
    $formal = formalize($title, justify=&amp;gt;&#39;left&#39;);
    $formal = formalize($title, justify=&amp;gt;&#39;right&#39;, case=&amp;gt;&#39;title&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Named parameters are always optional. Default values for named parameters are defined in the same way as for optional parameters. Named parameters default to &lt;code&gt;undef&lt;/code&gt; if they have no default.&lt;/p&gt;

&lt;h4 id=&#34;span-id-list-parameters-list-parameters-span&#34;&gt;&lt;span id=&#34;list_parameters&#34;&gt;List Parameters&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;List parameters capture a variable length list of data. They&amp;rsquo;re used in subroutines like &lt;code&gt;print&lt;/code&gt;, where the number of arguments needs to be flexible. They&amp;rsquo;re also called &amp;ldquo;variadic parameters,&amp;rdquo; because they take a &lt;em&gt;variable&lt;/em&gt; number of arguments.&lt;/p&gt;

&lt;p&gt;Variadic parameters follow any required or optional parameters. They are marked by a &lt;code&gt;*&lt;/code&gt; before the parameter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub duplicate($n, *@data, *%flag) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Named variadic arguments are bound to the variadic hash (&lt;code&gt;*%flag&lt;/code&gt; in the above example). Such arguments are evaluated in scalar context. Any remaining variadic arguments at the end of the argument list are bound to the variadic array (&lt;code&gt;*@data&lt;/code&gt; above) and are evaluated in list context.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    duplicate(3, reverse=&amp;gt;1, collate=&amp;gt;0, 2, 3, 5, 7, 11, 14);

    # The @data parameter receives [2, 3, 5, 7, 11, 14]
    # The %flag parameter receives { reverse=&amp;gt;1, collate=&amp;gt;0 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Variadic scalar parameters capture what would otherwise be the first elements of the variadic array:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub head(*$head, *@tail)         { return $head }
    sub neck(*$head, *$neck, *@tail) { return $neck }
    sub tail(*$head, *@tail)         { return @tail }

    head(1, 2, 3, 4, 5);        # $head parameter receives 1
                                # @tail parameter receives [2, 3, 4, 5]

    neck(1, 2, 3, 4, 5);        # $head parameter receives 1
                                # $neck parameter receives 2
                                # @tail parameter receives [3, 4, 5]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Variadic scalars still impose list context on their arguments.&lt;/p&gt;

&lt;p&gt;Variadic parameters are treated lazily &amp;ndash; the list is only flattened into an array when individual elements are actually accessed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        @fromtwo = tail(1..Inf);        # @fromtwo contains a lazy [2..Inf]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-flattening-argument-lists-flattening-argument-lists-span&#34;&gt;&lt;span id=&#34;flattening_argument_lists&#34;&gt;Flattening Argument Lists&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The unary prefix operator &lt;code&gt;*&lt;/code&gt; flattens its operand (which allows the elements of an array to be used as an argument list). The &lt;code&gt;*&lt;/code&gt; operator also causes its operand &amp;ndash; and any subsequent arguments in the argument list &amp;ndash; to be evaluated in list context.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo($x, $y, $z) {...}    # expects three scalars
    @onetothree = 1..3;          # array stores three scalars

    foo(1,2,3);                  # okay:  three args found
    foo(@onetothree);            # error: only one arg
    foo(*@onetothree);           # okay:  @onetothree flattened to three args
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;*&lt;/code&gt; operator flattens lazily &amp;ndash; the array is only flattened if flattening is actually required within the subroutine. To flatten before the list is even passed into the subroutine, use the unary prefix &lt;code&gt;**&lt;/code&gt; operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    foo(**@onetothree);          # array flattened before &amp;amp;foo called
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-pipe-operators-pipe-operators-span&#34;&gt;&lt;span id=&#34;pipe_operators&#34;&gt;Pipe Operators&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The variadic array of a subroutine call can be passed in separately from the normal argument list, by using either of the &amp;ldquo;pipe&amp;rdquo; operators: &lt;code&gt;&amp;lt;==&lt;/code&gt; or &lt;code&gt;==&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Each operator expects to find a call to a variadic subroutine on its &amp;ldquo;sharp&amp;rdquo; end, and a list of values on its &amp;ldquo;blunt&amp;rdquo; end:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    grep { $_ % 2 } &amp;lt;== @data;

    @data ==&amp;gt; grep { $_ % 2 };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, it flattens the list of values on the blunt side. Then, it binds that flattened list to the variadic &lt;code&gt;parameter(s)&lt;/code&gt; of the subroutine on the sharp side. So both of the calls above are equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    grep { $_ % 2 } *@data;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Leftward pipes are a convenient way of explicitly indicating the typical right-to-left flow of data through a chain of operations:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @oddsquares = map { $_**2 } sort grep { $_ % 2 } @nums;

    # more clearly written as...

    @oddsquares = map { $_**2 } &amp;lt;== sort &amp;lt;== grep { $_ % 2 } &amp;lt;== @nums;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rightward pipes are a convenient way of reversing the normal data flow in a chain of operations, to make it read left-to-right:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @oddsquares =
            @nums ==&amp;gt; grep { $_ % 2 } ==&amp;gt; sort ==&amp;gt; map { $_**2 };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the operand on the sharp end of a pipe is not a call to a variadic operation, then it must be a variable, in which case the list operand is assigned to the variable. This special case allows for &amp;ldquo;pure&amp;rdquo; processing chains:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @oddsquares &amp;lt;== map { $_**2 } &amp;lt;== sort &amp;lt;== grep { $_ % 2 } &amp;lt;== @nums;

    @nums ==&amp;gt; grep { $_ % 2 } ==&amp;gt; sort ==&amp;gt; map { $_**2 } ==&amp;gt; @oddsquares;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-closure-parameters-closure-parameters-span&#34;&gt;&lt;span id=&#34;closure_parameters&#34;&gt;Closure Parameters&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Parameters declared with the &lt;code&gt;&amp;amp;&lt;/code&gt; sigil take blocks, closures, or subroutines as their arguments. Closure parameters can be required, optional, or named.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub limited_grep (Int $count, &amp;amp;block, *@list) {...}

    # and later...

    @first_three = limited_grep 3 {$_&amp;lt;10} @data;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Within the subroutine, the closure parameter can be used like any other lexically scoped subroutine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub limited_grep (Int $count, &amp;amp;block, *@list) {
        ...
        if block($nextelem) {...}
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The closure parameter can have its own signature (from which the parameter names may be omitted):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub limited_Dog_grep ($count, &amp;amp;block(Dog), Dog *@list) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and even a return type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub limited_Dog_grep ($count, &amp;amp;block(Dog) returns Bool, Dog *@list) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When an argument is passed to a closure parameter that has this kind of signature, the argument must be a &lt;code&gt;Code&lt;/code&gt; object with a compatible parameter list and return type.&lt;/p&gt;

&lt;h4 id=&#34;span-id-unpacking-array-parameters-unpacking-array-parameters-span&#34;&gt;&lt;span id=&#34;unpacking_array_parameters&#34;&gt;Unpacking Array Parameters&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Instead of specifying an array parameter as an array:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub quicksort (@data, ?$reverse, ?$inplace) {
        my $pivot := shift @data;
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it may be broken up into components in the signature, by specifying the parameter as if it were an anonymous array of parameters:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub quicksort ([$pivot, *@data], ?$reverse, ?$inplace) {
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This subroutine still expects an array as its first argument, just like the first version.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 6&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-attributive-parameters-attributive-parameters-span&#34;&gt;&lt;span id=&#34;attributive_parameters&#34;&gt;Attributive parameters&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;If a method&amp;rsquo;s parameter is declared with a &lt;code&gt;.&lt;/code&gt; after the sigil (like an attribute):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method initialize($.name, $.age) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then the argument is assigned directly to the object&amp;rsquo;s attribute of the same name. This avoids the frequent need to write code like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method initialize($name, $age) {
        $.name = $name;
        $.age  = $age;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-placeholder-variables-placeholder-variables-span&#34;&gt;&lt;span id=&#34;placeholder_variables&#34;&gt;Placeholder Variables&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Even though every bare block is a closure, bare blocks can&amp;rsquo;t have explicit parameter lists. Instead, they use &amp;ldquo;placeholder&amp;rdquo; variables, marked by a caret (&lt;code&gt;^&lt;/code&gt;) after their sigils.&lt;/p&gt;

&lt;p&gt;Using placeholders in a block defines an implicit parameter list. The signature is the list of distinct placeholder names, sorted in Unicode order. So:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    { $^y &amp;lt; $^z &amp;amp;&amp;amp; $^x != 2 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is a shorthand for:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub ($x,$y,$z) { $y &amp;lt; $z &amp;amp;&amp;amp; $x != 2 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-types-types-span&#34;&gt;&lt;span id=&#34;types&#34;&gt;Types&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;These are the standard type names in Perl 6 (at least this week):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    bit         single native bit
    int         native integer
    str         native string
    num         native floating point
    ref         native pointer 
    bool        native boolean
    Bit         Perl single bit (allows traits, aliasing, etc.)
    Int         Perl integer (allows traits, aliasing, etc.)
    Str         Perl string
    Num         Perl number
    Ref         Perl reference
    Bool        Perl boolean
    Array       Perl array
    Hash        Perl hash
    IO          Perl filehandle
    Code        Base class for all executable objects
    Routine     Base class for all nameable executable objects
    Sub         Perl subroutine
    Method      Perl method
    Submethod   Perl subroutine acting like a method
    Macro       Perl compile-time subroutine
    Rule        Perl pattern
    Block       Base class for all unnameable executable objects
    Bare        Basic Perl block
    Parametric  Basic Perl block with placeholder parameters
    Package     Perl 5 compatible namespace
    Module      Perl 6 standard namespace
    Class       Perl 6 standard class namespace
    Object      Perl 6 object
    Grammar     Perl 6 pattern matching namespace
    List        Perl list
    Lazy        Lazily evaluated Perl list
    Eager       Non-lazily evaluated Perl list
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-value-types-value-types-span&#34;&gt;&lt;span id=&#34;value_types&#34;&gt;Value Types&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Explicit types are optional. Perl variables have two associated types: their &amp;ldquo;value type&amp;rdquo; and their &amp;ldquo;variable type&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;The value type specifies what kinds of values may be stored in the variable. A value type is given as a prefix or with the &lt;code&gt;returns&lt;/code&gt; or &lt;code&gt;of&lt;/code&gt; keywords:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Dog $spot;
    my $spot returns $dog;
    my $spot of Dog;

    our Animal sub get_pet() {...}
    sub get_pet() returns Animal {...}
    sub get_pet() of Animal {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A value type on an array or hash specifies the type stored by each element:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Dog @pound;  # each element of the array stores a Dog

    my Rat %ship;   # the value of each entry stores a Rat
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-variable-types-variable-types-span&#34;&gt;&lt;span id=&#34;variable_types&#34;&gt;Variable Types&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The variable type specifies how the variable itself is implemented. It is given as a trait of the variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $spot is Scalar;             # this is the default
    my $spot is PersistentScalar;
    my $spot is DataBase;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Defining a variable type is the Perl 6 equivalent to tying a variable in Perl 5.&lt;/p&gt;

&lt;h4 id=&#34;span-id-hierarchical-types-hierarchical-types-span&#34;&gt;&lt;span id=&#34;hierarchical_types&#34;&gt;Hierarchical Types&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;A nonscalar type may be qualified, in order to specify what type of value each of its elements stores:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Egg $cup;                       # the value is an Egg
    my Egg @carton;                    # each elem is an Egg
    my Array of Egg @box;              # each elem is an array of Eggs
    my Array of Array of Egg @crate;   # each elem is an array of arrays of Eggs
    my Hash of Array of Recipe %book;  # each value is a hash of arrays of Recipes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each successive &lt;code&gt;of&lt;/code&gt; makes the type on its right a parameter of the type on its left. So:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Hash of Array of Recipe %book;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;means:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Hash(returns=&amp;gt;Array(returns=&amp;gt;Recipe)) %book;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because the actual variable can be hard to find when complex types are specified, there is a postfix form as well:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Hash of Array of Recipe %book;           # HoHoAoRecipe
    my %book of Hash of Array of Recipe;        # same thing
    my %book returns Hash of Array of Recipe;   # same thing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;returns&lt;/code&gt; form is more commonly seen in subroutines:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Hash of Array of Recipe sub get_book () {...}
    my sub get_book () of Hash of Array of Recipe {...}
    my sub get_book returns Hash of Array of Recipe {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-junctive-types-junctive-types-span&#34;&gt;&lt;span id=&#34;junctive_types&#34;&gt;Junctive Types&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Anywhere you can use a single type you can use a junction of types:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Int|Str $error = $val;              # can assign if $val~~Int or $val~~Str

    if $shimmer.isa(Wax &amp;amp; Topping) {...}   # $shimmer must inherit from both
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-parameter-types-parameter-types-span&#34;&gt;&lt;span id=&#34;parameter_types&#34;&gt;Parameter Types&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Parameters may be given types, just like any other variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub max (int @array is rw) {...}
    sub max (@array of int is rw) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-return-types-return-types-span&#34;&gt;&lt;span id=&#34;return_types&#34;&gt;Return Types&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;On a scoped subroutine, a return type can be specified before or after the name:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    our Egg sub lay {...}
    our sub lay returns Egg {...}

    my Rabbit sub hat {...}
    my sub hat returns Rabbit {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If a subroutine is not explicitly scoped, then it belongs to the current namespace (module, class, grammar, or package). Any return type must go after the name:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub lay returns Egg {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On an anonymous subroutine, any return type can only go after the name:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $lay = sub returns Egg {...};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;unless you use the &amp;ldquo;anonymous declarator&amp;rdquo; (&lt;code&gt;a&lt;/code&gt;/&lt;code&gt;an&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $lay = an Egg sub {...};
    $hat = a Rabbit sub {...};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-properties-and-traits-properties-and-traits-span&#34;&gt;&lt;span id=&#34;properties_and_traits&#34;&gt;Properties and Traits&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Compile-time properties are now called &amp;ldquo;traits.&amp;rdquo; The &lt;code&gt;is NAME (DATA)&lt;/code&gt; syntax defines traits on containers and subroutines, as part of their declaration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $pi is constant = 3;

    my $key is Persistent(file=&amp;gt;&amp;quot;.key&amp;quot;);

    sub fib is cached {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;will NAME BLOCK&lt;/code&gt; syntax is a synonym for &lt;code&gt;is NAME (BLOCK)&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $fh will undo { close $fh };    # Same as: my $fh is undo({ close $fh });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;but NAME (DATA)&lt;/code&gt; syntax specifies run-time properties on values:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $pi = 3 but Approximate(&amp;quot;legislated&amp;quot;);

    sub system {
        ...
        return $error but false if $error;
        return 0 but true;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-subroutine-traits-subroutine-traits-span&#34;&gt;&lt;span id=&#34;subroutine_traits&#34;&gt;Subroutine Traits&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;These traits may be declared on the subroutine as a whole (not on individual parameters).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_is_signature&#34;&gt;&lt;code&gt;is signature&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The signature of a subroutine &amp;ndash; normally declared implicitly, by providing a parameter list and/or return type.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_returns%2fis_returns&#34;&gt;&lt;code&gt;returns&lt;/code&gt;/&lt;code&gt;is returns&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The type returned by a subroutine.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_will_do&#34;&gt;&lt;code&gt;will do&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The block of code executed when the subroutine is called &amp;ndash; normally declared implicitly, by providing a block after the subroutine&amp;rsquo;s signature definition.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_is_rw&#34;&gt;&lt;code&gt;is rw&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Marks a subroutine as returning an lvalue.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_is_parsed&#34;&gt;&lt;code&gt;is parsed&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Specifies the rule by which a macro call is parsed.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_is_cached&#34;&gt;&lt;code&gt;is cached&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Marks a subroutine as being memoized&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_is_inline&#34;&gt;&lt;code&gt;is inline&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Suggests&lt;/em&gt; to the compiler that the subroutine is a candidate for optimization via inlining.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_is_tighter%2fis_looser%2fis_equiv&#34;&gt;&lt;code&gt;is tighter&lt;/code&gt;/&lt;code&gt;is looser&lt;/code&gt;/&lt;code&gt;is equiv&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Specifies the precedence of an operator relative to an existing operator.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_is_assoc&#34;&gt;&lt;code&gt;is assoc&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Specifies the associativity of an operator.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_pre%2fpost&#34;&gt;&lt;code&gt;PRE&lt;/code&gt;/&lt;code&gt;POST&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Mark blocks that are to be unconditionally executed before/after the subroutine&amp;rsquo;s &lt;code&gt;do&lt;/code&gt; block. These blocks must return a true value, otherwise an exception is thrown.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_first%2flast%2fnext%2fkeep%2fundo%2fetc%2e&#34;&gt;&lt;code&gt;FIRST&lt;/code&gt;/&lt;code&gt;LAST&lt;/code&gt;/&lt;code&gt;NEXT&lt;/code&gt;/&lt;code&gt;KEEP&lt;/code&gt;/&lt;code&gt;UNDO&lt;/code&gt;/etc.&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Mark blocks that are to be conditionally executed before or after the subroutine&amp;rsquo;s &lt;code&gt;do&lt;/code&gt; block. The return values of these blocks are ignored.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 6&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-parameter-traits-parameter-traits-span&#34;&gt;&lt;span id=&#34;parameter_traits&#34;&gt;Parameter Traits&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The following traits can be applied to many types of parameters.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_is_constant&#34;&gt;&lt;code&gt;is constant&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Specifies that the parameter cannot be modified (e.g. assigned to, incremented). It is the default for parameters.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;is rw&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Specifies that the parameter can be modified (assigned to, incremented, etc). Requires that the corresponding argument is an lvalue or can be converted to one.&lt;/p&gt;

&lt;p&gt;When applied to a variadic parameter, the &lt;code&gt;rw&lt;/code&gt; trait applies to each element of the list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub incr (*@vars is rw) { $_++ for @vars }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_is_ref&#34;&gt;&lt;code&gt;is ref&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Specifies that the parameter is passed by reference. Unlike &lt;a href=&#34;#item_is_rw&#34;&gt;&lt;code&gt;is rw&lt;/code&gt;&lt;/a&gt;, the corresponding argument must already be a suitable lvalue. No attempt at coercion or autovivification is made.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_is_copy&#34;&gt;&lt;code&gt;is copy&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Specifies that the parameter receives a distinct, read-writeable copy of the original argument. This is commonly known as &amp;ldquo;pass-by-value.&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub reprint ($text, $count is copy) {
        print $text while $count--&amp;gt;0;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_context&#34;&gt;&lt;code&gt;is context(TYPE)&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Specifies the context that a parameter applies to its argument. Typically used to cause a final list parameter to apply a series of scalar contexts:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # &amp;amp;format may have as many arguments as it likes,
    # each of which is evaluated in scalar context

    sub format(*@data is context(Scalar)) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-advanced-subroutine-features-advanced-subroutine-features-span&#34;&gt;&lt;span id=&#34;advanced_subroutine_features&#34;&gt;Advanced Subroutine Features&lt;/span&gt;&lt;/h3&gt;

&lt;h4 id=&#34;span-id-the-routine-the-routine-span&#34;&gt;&lt;span id=&#34;the_&amp;__routine&#34;&gt;The &lt;code&gt;&amp;amp;_&lt;/code&gt; routine&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;&amp;amp;_&lt;/code&gt; is always an alias for the current subroutine, much like the &lt;code&gt;$_&lt;/code&gt; alias for the current topic:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $anonfactorial = sub (Int $n) {
                            return 1 if $n&amp;lt;2;
                            return $n * &amp;amp;_($n-1)
                        };
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-the-caller-function-the-caller-function-span&#34;&gt;&lt;span id=&#34;the_caller_function&#34;&gt;The &lt;code&gt;caller&lt;/code&gt; Function&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;caller&lt;/code&gt; function returns an object that describes a particular &amp;ldquo;higher&amp;rdquo; dynamic scope, from which the current scope was called.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print &amp;quot;In &amp;quot;,           caller.sub,
          &amp;quot; called from &amp;quot;, caller.file,
          &amp;quot; line &amp;quot;,        caller.line,
          &amp;quot;\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;caller&lt;/code&gt; may be given arguments telling it what kind of higher scope to look for, and how many such scopes to skip over when looking:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $caller = caller;                      # immediate caller
    $caller = caller Method;               # nearest caller that is method
    $caller = caller Bare;                 # nearest caller that is bare block
    $caller = caller Sub, skip=&amp;gt;2;         # caller three levels up
    $caller = caller Block, label=&amp;gt;&#39;Foo&#39;;  # caller whose label is &#39;Foo&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-the-want-function-the-want-function-span&#34;&gt;&lt;span id=&#34;the_want_function&#34;&gt;The &lt;code&gt;want&lt;/code&gt; Function&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;want&lt;/code&gt; function returns an object that contains information about the context in which the current block, closure, or subroutine was called.&lt;/p&gt;

&lt;p&gt;The returned context object is typically tested with a smart match (&lt;code&gt;~~&lt;/code&gt;) or a &lt;code&gt;when&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   given want {
        when Scalar {...}           # called in scalar context
        when List   {...}           # called in list context
        when Lvalue {...}           # expected to return an lvalue
        when 2      {...}           # expected to return two values
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or has the corresponding methods called on it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       if (want.Scalar)    {...}    # called in scalar context
    elsif (want.List)      {...}    # called in list context
    elsif (want.rw)        {...}    # expected to return an lvalue
    elsif (want.count &amp;gt; 2) {...}    # expected to return more than two values
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-the-leave-function-the-leave-function-span&#34;&gt;&lt;span id=&#34;the_leave_function&#34;&gt;The &lt;code&gt;leave&lt;/code&gt; Function&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;A &lt;code&gt;return&lt;/code&gt; statement causes the innermost surrounding subroutine, method, rule, macro or multimethod to return.&lt;/p&gt;

&lt;p&gt;To return from other types of code structures, the &lt;code&gt;leave&lt;/code&gt; funtion is used:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    leave;                      # return from innermost block of any kind
    leave Method;               # return from innermost calling method
    leave &amp;amp;_ &amp;lt;== 1,2,3;         # Return from current sub. Same as: return 1,2,3
    leave &amp;amp;foo &amp;lt;== 1,2,3;       # Return from innermost surrounding call to &amp;amp;foo
    leave Loop, label=&amp;gt;&#39;COUNT&#39;; # Same as: last COUNT;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-temporization-temporization-span&#34;&gt;&lt;span id=&#34;temporization&#34;&gt;Temporization&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;temp&lt;/code&gt; function temporarily replaces a variable, subroutine or other object in a given scope:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    {
       temp $*foo = &#39;foo&#39;;      # Temporarily replace global $foo
       temp &amp;amp;bar = sub {...};   # Temporarily replace sub &amp;amp;bar
       ...
    } # Old values of $*foo and &amp;amp;bar reinstated at this point
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;temp&lt;/code&gt; invokes its argument&amp;rsquo;s &lt;code&gt;.TEMP&lt;/code&gt; method. The method is expected to return a reference to a subroutine that can later restore the current value of the object. At the end of the lexical scope in which the &lt;code&gt;temp&lt;/code&gt; was applied, the subroutine returned by the &lt;code&gt;.TEMP&lt;/code&gt; method is executed.&lt;/p&gt;

&lt;p&gt;The default &lt;code&gt;.TEMP&lt;/code&gt; method for variables simply creates a closure that assigns the variable&amp;rsquo;s pre-&lt;code&gt;temp&lt;/code&gt; value back to the variable.&lt;/p&gt;

&lt;p&gt;New kinds of temporization can be created by writing storage classes with their own &lt;code&gt;.TEMP&lt;/code&gt; methods:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class LoudArray is Array {
        method TEMP {
            print &amp;quot;Replacing $_.id() at $(caller.location)\n&amp;quot;;
            my $restorer = .SUPER::TEMP();
            return { 
                print &amp;quot;Restoring $_.id() at $(caller.location)\n&amp;quot;;
                $restorer();
            };
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also modify the behaviour of temporized code structures, by giving them a &lt;code&gt;TEMP&lt;/code&gt; block. As with &lt;code&gt;.TEMP&lt;/code&gt; methods, this block is expected to return a closure, which will be executed at the end of the temporizing scope to restore the subroutine to its pre-&lt;code&gt;temp&lt;/code&gt; state:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $next = 0;
    sub next {
        my $curr = $next++;
        TEMP {{ $next = $curr }}  # TEMP block returns the closure { $next = $curr }
        return $curr;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-wrapping-wrapping-span&#34;&gt;&lt;span id=&#34;wrapping&#34;&gt;Wrapping&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Every subroutine has a &lt;code&gt;.wrap&lt;/code&gt; method. This method expects a single argument consisting of a block, closure or subroutine. That argument must contain a call to the special &lt;code&gt;call&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub thermo ($t) {...}   # set temperature in Celsius, returns old temp

    # Add a wrapper to convert from Fahrenheit...

    $id = &amp;amp;thermo.wrap( { call( ($^t-32)/1.8 ) } );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The call to &lt;code&gt;.wrap&lt;/code&gt; replaces the original subroutine with the closure argument, and arranges that the closure&amp;rsquo;s call to &lt;code&gt;call&lt;/code&gt; invokes the original (unwrapped) version of the subroutine. In other words, the call to &lt;code&gt;.wrap&lt;/code&gt; has more or less the same effect as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;amp;old_thermo := &amp;amp;thermo;
    &amp;amp;thermo := sub ($t) { old_thermo( ($t-32)/1.8 ) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The call to &lt;code&gt;.wrap&lt;/code&gt; returns a unique identifier that can later be passed to the &lt;code&gt;.unwrap&lt;/code&gt; method, to undo the wrapping:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;amp;thermo.unwrap($id);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A wrapping can also be restricted to a particular dynamic scope with temporization:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Add a wrapper to convert from Kelvin
    # wrapper self-unwraps at end of current scope

    temp &amp;amp;thermo.wrap( { call($^t + 273.16) } );
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-currying-currying-span&#34;&gt;&lt;span id=&#34;currying&#34;&gt;Currying&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Every subroutine has an &lt;code&gt;.assuming&lt;/code&gt; method. This method takes a series of named arguments, whose names must match parameters of the subroutine itself:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;amp;textfrom := &amp;amp;substr.assuming(str=&amp;gt;$text, len=&amp;gt;Inf);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It returns a reference to a subroutine that implements the same behavior as the original subroutine, but has the values passed to &lt;code&gt;.assuming&lt;/code&gt; already bound to the corresponding parameters:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $all  = $textfrom(0);   # same as: $all  = substr($text,0,Inf);
    $some = $textfrom(50);  # same as: $some = substr($text,50,Inf);
    $last = $textfrom(-1);  # same as: $last = substr($text,-1,Inf);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The result of a &lt;code&gt;use&lt;/code&gt; statement is a (compile-time) object that also has an &lt;code&gt;.assuming&lt;/code&gt; method, allowing the user to bind parameters in all the module&amp;rsquo;s subroutines/methods/etc. simultaneously:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (use IO::Logging).assuming(logfile =&amp;gt; &amp;quot;.log&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-other-matters-other-matters-span&#34;&gt;&lt;span id=&#34;other_matters&#34;&gt;Other Matters&lt;/span&gt;&lt;/h3&gt;

&lt;h4 id=&#34;span-id-anonymous-hashes-vs-blocks-anonymous-hashes-vs-blocks-span&#34;&gt;&lt;span id=&#34;anonymous_hashes_vs_blocks&#34;&gt;Anonymous Hashes vs. Blocks&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;{...}&lt;/code&gt; is always a block/closure unless it consists of a single list, the first element of which is either a hash or a pair.&lt;/p&gt;

&lt;p&gt;The standard &lt;code&gt;pair LIST&lt;/code&gt; function is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub pair (*@LIST) {
        my @pairs;
        for @LIST -&amp;gt; $key, $val {
            push @pairs, $key=&amp;gt;$val;
        }
        return @pairs;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The standard &lt;code&gt;hash&lt;/code&gt; function takes a block, evaluates it in list context, and constructs an anonymous hash from the resulting key/value list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $ref = hash { 1, 2, 3, 4, 5, 6 };   # Anonymous hash
    $ref = sub  { 1, 2, 3, 4, 5, 6 };   # Anonymous sub returning list
    $ref =      { 1, 2, 3, 4, 5, 6 };   # Anonymous sub returning list
    $ref =      { 1=&amp;gt;2, 3=&amp;gt;4, 5=&amp;gt;6 };   # Anonymous hash
    $ref =      { 1=&amp;gt;2, 3, 4, 5, 6 };   # Anonymous hash
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-pairs-as-lvalues-pairs-as-lvalues-span&#34;&gt;&lt;span id=&#34;pairs_as_lvalues&#34;&gt;Pairs as lvalues&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Pairs can be used as lvalues. The value of the pair is the recipient of the assignment:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (key =&amp;gt; $var) = &amp;quot;value&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When binding pairs, names can be used to &amp;ldquo;match up&amp;rdquo; lvalues and rvalues:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (who =&amp;gt; $name, why =&amp;gt; $reason) := (why =&amp;gt; $because, who =&amp;gt; &amp;quot;me&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-outofscope-names-out-of-scope-names-span&#34;&gt;&lt;span id=&#34;outofscope_names&#34;&gt;Out-of-Scope Names&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;$CALLER::varname&lt;/code&gt; specifies the &lt;code&gt;$varname&lt;/code&gt; visible in the dynamic scope from which the current block/closure/subroutine was called.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$MY::varname&lt;/code&gt; specifies the lexical &lt;code&gt;$varname&lt;/code&gt; declared in the current lexical scope.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$OUTER::varname&lt;/code&gt; specifies the &lt;code&gt;$varname&lt;/code&gt; declared in the lexical scope surrounding the current lexical scope (i.e. the scope in which the current block was defined).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>On Topic</title>
      <link>http://localhost:1313/pub/2002/10/30/topic.html/</link>
      <pubDate>Wed, 30 Oct 2002 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2002/10/30/topic.html/</guid>
      <description>

&lt;p&gt;A few concepts in Perl 6 are strange at first sight. They seem hard to understand, but it&amp;rsquo;s only because they&amp;rsquo;re new and different. They aren&amp;rsquo;t deep mystical concepts known only to Tibetan lamas. Anyone can understand them, but it helps to start with a common-sense explanation.&lt;/p&gt;

&lt;p&gt;This article looks at the concepts of &amp;ldquo;topic&amp;rdquo; and &amp;ldquo;topicalizer&amp;rdquo;. The words aren&amp;rsquo;t quotes from a particularly nasty bit of Vogon poetry. They&amp;rsquo;re actually common terms from the field of linguistics &amp;hellip; which some might say is even worse. Still, the best way to understand topic in Perl is to understand its source.&lt;/p&gt;

&lt;h3 id=&#34;span-id-topic-in-linguistics-topic-in-linguistics-span&#34;&gt;&lt;span id=&#34;topic in linguistics&#34;&gt;Topic in Linguistics&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Every larger unit of human language has a topic &amp;ndash; whether it&amp;rsquo;s a sentence, a paragraph, a conversation or some other sizable chunk. The topic is the central idea of the unit. It&amp;rsquo;s the focus of what&amp;rsquo;s communicated. Native speakers usually have no trouble figuring out what the current topic is, when they think about it. If two little old ladies were talking over a cup of tea:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;ldquo;I saw Lister yesterday.&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;ldquo;Really? What&amp;rsquo;s he up to these days?&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;ldquo;Oh, you know, drunk again, and mooning over that awful Krissy Kochanski.&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;etc &amp;hellip;&lt;/p&gt;

&lt;p&gt;and someone asked an observer what the conversation was about, they would instantly reply &amp;ldquo;Lister&amp;rdquo;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-topicalizers-in-linguistics-topicalizers-in-linguistics-span&#34;&gt;&lt;span id=&#34;topicalizers in linguistics&#34;&gt;Topicalizers in Linguistics&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;A topicalizer is simply a word that marks some thing or some idea as the current topic. In English, we have topicalizers such as &amp;ldquo;for&amp;rdquo;, &amp;ldquo;given&amp;rdquo; and &amp;ldquo;regarding&amp;rdquo;:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;ldquo;For our first trick tonight, ladies and gentlemen, my partner Kryten will attempt to eat a boiled egg.&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;ldquo;Given that God is infinite, and that the universe is also infinite, would you like a toasted tea-cake?&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;ldquo;Regarding topicalizers, I should point out that this sentence starts with one.&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-topic-in-perl-topic-in-perl-span&#34;&gt;&lt;span id=&#34;topic in perl&#34;&gt;Topic in Perl&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Now we need to adapt the linguistic definition of topic to Perl. In Perl, the topic is the most important variable in a block of code. It can be any variable: a scalar, array, hash, object. To be more accurate, it&amp;rsquo;s the underlying storage location that&amp;rsquo;s the topic. This might sound a little too abstract, but it&amp;rsquo;s an important distinction. Variables are really only names we use to get at stored values. A single storage location can have multiple names. In English, &amp;ldquo;Rimmer&amp;rdquo;, &amp;ldquo;he&amp;rdquo; and &amp;ldquo;the hologram&amp;rdquo; could all appear in a text meaning the same person. In Perl $_, $name, %characters{&amp;lsquo;title&amp;rsquo;} and any number of other variables could appear in a section of code as different ways of accessing a single value. And if that value is the current topic then all the variables connected to it are too. This will be important later.&lt;/p&gt;

&lt;p&gt;At this point, the average reader is thinking &amp;ldquo;That&amp;rsquo;s very interesting, but why do I care what the topic is? I&amp;rsquo;ve gotten along just fine without it all these years. Why start now?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;And the answer is: it&amp;rsquo;s not required. No one has to understand topic to use it, any more than they have to understand gravity to catch a ball.&lt;/p&gt;

&lt;p&gt;Why? It&amp;rsquo;s a really simple rule. We&amp;rsquo;ll call it the first law of topics: Topic is $_. Any time a value becomes the current topic, $_ becomes another one of the names for that value. We say $_ is aliased to it. So, all it takes to use topic is to use $_ either explicitly or implicitly in all the old familiar places, like &lt;code&gt;chomp&lt;/code&gt;, &lt;code&gt;print&lt;/code&gt; and substitutions, and in a few new places, like &lt;code&gt;when&lt;/code&gt; statements and with unary dot.&lt;/p&gt;

&lt;p&gt;Even so, it&amp;rsquo;s still a good idea to understand topic. Understanding gravity makes a number of things that seem unrelated suddenly fit. Things like apples falling, planes crashing, the way the moon and sun move, baseball, and rollercoasters. It&amp;rsquo;s the same with topic. Any programmer can use $_ without understanding topic. But when they understand topic, it becomes a logical system instead of a random collection of &amp;ldquo;things $_ does&amp;rdquo;. I like logical systems.&lt;/p&gt;

&lt;h3 id=&#34;span-id-topicalizers-in-perl-topicalizers-in-perl-span&#34;&gt;&lt;span id=&#34;topicalizers in perl&#34;&gt;Topicalizers in Perl&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;A topicalizer in Perl is a keyword or construct that makes a value become the current topic. The current topicalizers are &lt;code&gt;given&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;method&lt;/code&gt;, &lt;code&gt;rule&lt;/code&gt;, &lt;code&gt;-&amp;gt;&lt;/code&gt;, certain bare closures, and &lt;code&gt;CATCH&lt;/code&gt; blocks, but the cast of characters keeps growing.&lt;/p&gt;

&lt;h4 id=&#34;span-id-coal-and-switches-coal-and-switches-span&#34;&gt;&lt;span id=&#34;coal and switches&#34;&gt;Coal and Switches&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Perl 6&amp;rsquo;s switch, the &lt;code&gt;given&lt;/code&gt; construct, is the prime example of a topicalizer. Its sole purpose is to make the value passed to it the current topic within the block.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    given $name {
        when &amp;quot;Lister&amp;quot; { print &amp;quot;I&#39;m a curryaholic.&amp;quot; }
        when &amp;quot;Cat&amp;quot;    { print &amp;quot;Orange?! With this suit?!&amp;quot; }
        when &amp;quot;Rimmer&amp;quot; { print &amp;quot;4,691 irradiated haggis.&amp;quot; }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, in this example, the &lt;code&gt;given&lt;/code&gt; makes $name the current topic by aliasing it to $_. Then the &lt;code&gt;when&lt;/code&gt; statements compare against $_. After the block, $_ regains the value in the outer scope. In Perl 6, $_ is just an ordinary lexical variable and every topicalizer creates its own $_ variable, lexically scoped to its associated block.&lt;/p&gt;

&lt;h4 id=&#34;span-id-fruit-loops-and-m-m-s-fruit-loops-and-m-m-s-span&#34;&gt;&lt;span id=&#34;fruit loops and m&amp;m&#39;s&#34;&gt;Fruit Loops and M&amp;amp;M&amp;rsquo;s&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;for&lt;/code&gt; loop is the classic topicalizer. It was topicalizing long before most of us had a word for the activity. &lt;code&gt;for&lt;/code&gt; is similar to &lt;code&gt;given&lt;/code&gt;, but instead of creating a single topic, it creates a series of topics, one for each iteration.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @orders {
        when /scone/ {
            print &amp;quot;Would you like some toast?&amp;quot;;
        }
        when /croissant/ {
            print &amp;quot;Hot, buttered, scrummy toast?&amp;quot;;
        }
        when /toast/ {
            print &amp;quot;Really? How about a muffin?&amp;quot;;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just like &lt;code&gt;given&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; takes a value, in this case the current element of the array, and makes it the topic.&lt;/p&gt;

&lt;p&gt;In simple cases like these, both &lt;code&gt;for&lt;/code&gt; and &lt;code&gt;given&lt;/code&gt; create the $_ alias read-write. This is the same as Perl 5: any change to $_ inside the block modifies the original value.&lt;/p&gt;

&lt;h4 id=&#34;span-id-bow-and-arrow-bow-and-arrow-span&#34;&gt;&lt;span id=&#34;bow and arrow&#34;&gt;Bow and Arrow&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The new and improved arrow (&lt;code&gt;-&amp;gt;&lt;/code&gt;) is the most flexible topicalizer. It appears in a variety of different contexts. By itself &lt;code&gt;-&amp;gt;&lt;/code&gt; creates an anonymous subroutine just like &lt;code&gt;sub&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        -&amp;gt; $param { ... }

        # is the same as:

        sub ($param) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only differences are that &lt;code&gt;-&amp;gt;&lt;/code&gt; doesn&amp;rsquo;t require parentheses around its parameter list, and that &lt;code&gt;-&amp;gt;&lt;/code&gt; topicalizes its first parameter.&lt;/p&gt;

&lt;p&gt;In the following example, the first expression creates an anonymous sub and stores it in $cleanup. When the sub stored in $cleanup executes, the $line parameter takes the string argument and becomes the current topic, so both $line and $_ are aliased to the value of $intro. The usual suspects, &lt;code&gt;chomp&lt;/code&gt;, substitution and &lt;code&gt;print&lt;/code&gt; then use the topic as default.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $cleanup = -&amp;gt; $line is rw {
        s:w/Captain Rimmer!/the bloke/;
        $line _= &amp;quot; who cleans the soup machine!&amp;quot;;
        print;
    }

    $intro = &amp;quot;Fear not, I&#39;m Captain Rimmer!&amp;quot;;
    $cleanup($intro);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unlike the simple &lt;code&gt;for&lt;/code&gt; and &lt;code&gt;given&lt;/code&gt;, the arrow creates its aliases read-only by default. The &lt;code&gt;is rw&lt;/code&gt; property marks both the named alias and the $_ alias as read-write. Without the property attached, any statements within the block that modify $line or $_ cause a compile-time error just as if they had been explicitly flagged &lt;code&gt;is constant&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The arrow isn&amp;rsquo;t limited to working alone. It can also combine with other topicalizers. When it does, it creates a named alias for the current topic.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @lines -&amp;gt; $line is rw {
        s:w/Captain Rimmer!/the bloke/;
        $line _= &amp;quot; who cleans the soup machine!&amp;quot;;
        print;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As the &lt;code&gt;for&lt;/code&gt; iterates over the array it aliases every element in turn to $line and to $_. This takes the place of the Perl 5 way of aliasing a loop variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Perl 5
    for my $line (@lines) {
        $line =~ s/Captain Rimmer!/the bloke/;
        $line .= &amp;quot; who cleans the soup machine!&amp;quot;;
        print $line;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Perl 6 way has some added benefits, though. Since the arrow aliases both $line and $_ to the current value, it works with the defaulting constructs, like &lt;code&gt;print&lt;/code&gt;, but also provides a more meaningful name than $_ when an explicitly named variable is necessary.&lt;/p&gt;

&lt;p&gt;The first example of &lt;code&gt;for&lt;/code&gt; and the example of the anonymous sub reference are fascinatingly similar. The only difference is one is stored in a variable to be called later and one is tacked onto a &lt;code&gt;for&lt;/code&gt;. Really, all the &lt;code&gt;for&lt;/code&gt; example has done is replace the loop&amp;rsquo;s block with an anonymous sub reference. This is the second advantage of the Perl 6 way. Because $line is now the parameter of a subroutine, it&amp;rsquo;s automatically lexically scoped to the block. The &lt;code&gt;my&lt;/code&gt; happens implicitly.&lt;/p&gt;

&lt;p&gt;The arrow also combines with constructs that aren&amp;rsquo;t topicalizers, like &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;while&lt;/code&gt;, and allows them to topicalize.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if %people{$name}{&#39;details&#39;}{&#39;age&#39;} -&amp;gt; $age {
        print &amp;quot;$age already?\n&amp;quot;;
        if $age &amp;gt; 3000000 {
            print &amp;quot;How was your stasis?\n&amp;quot;;
        } elsif $age &amp;lt; 10 {
            print &amp;quot;How &#39;bout a muffin?\n&amp;quot;;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As the &lt;code&gt;if&lt;/code&gt; tests the truth value of the element of the data structure, the arrow also aliases that value to $age and to $_. The example could have accessed the hash of hashes of hashes directly each time it needed the age value, but the short alias is much more convenient.&lt;/p&gt;

&lt;p&gt;This feature is really only useful with simple truth tests. The truth value tested in the following example isn&amp;rsquo;t &lt;code&gt;3&lt;/code&gt; or $counter, it&amp;rsquo;s the result of a complex conditional, &lt;code&gt;$counter &amp;gt; 3&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if $counter &amp;gt; 3 -&amp;gt; $value {
        # do something with $value
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The result will be true or false, but if it&amp;rsquo;s false, the block will never execute. In fact, when the truth test is false, $value is never aliased at all. It simply doesn&amp;rsquo;t exist. A lexically scoped variable with a true value would have the same effect.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if $counter &amp;gt; 3 {
        my $value = 1;
        # do something with $value
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So the arrow isn&amp;rsquo;t a Ronco plum-pitter, yoghurt-squirter, do-everything tool. When it&amp;rsquo;s useful, it&amp;rsquo;s very, very useful, but when it&amp;rsquo;s not&amp;hellip; well&amp;hellip; don&amp;rsquo;t use it. &lt;code&gt;:)&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-method-in-my-madness-method-in-my-madness-span&#34;&gt;&lt;span id=&#34;method in my madness&#34;&gt;Method in my Madness&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Methods topicalize their invocant. An invocant is the object on which a method is called. After saying that 10 times fast, anyone can see why it needed a name. The design team chose &amp;ldquo;invocant&amp;rdquo;. Methods topicalize the invocant when it&amp;rsquo;s a named parameter like $self:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method sub_ether ($self: $message) {
        .transmit( .encode($message) );
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and when it&amp;rsquo;s left implicit:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method sub_ether {
        .transmit( .encoded_message );
    }

    method sub_ether (: $message) {
        .transmit( .encode($message) );
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is handy in short methods. The unary dot is just another defaulting construct. Any method call without an explicit object executes on the current topic. In the previous examples, &lt;code&gt;.transmit&lt;/code&gt; is exactly the same as &lt;code&gt;$self.transmit&lt;/code&gt; and &lt;code&gt;$_.transmit&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-sub-of-all-fears-the-sub-of-all-fears-span&#34;&gt;&lt;span id=&#34;the sub of all fears&#34;&gt;The Sub of All Fears&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Unlike methods and the arrow, ordinary subs don&amp;rsquo;t topicalize, at least not by default. The following example will either print nothing, or else print a stray $_ that is in lexical scope wherever the sub is defined.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub eddy ($space, $time) {
        print;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Subs can topicalize, though, with a little help from the &lt;code&gt;is topic&lt;/code&gt; property. The property flags a parameter as the topic within the subroutine&amp;rsquo;s block. It can be attached to any parameter in the list, but not to more than one parameter at a time.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub eddy ($space, $time is topic) {
        print;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Built-in functions like &lt;code&gt;print&lt;/code&gt; that default to the current topic when they&amp;rsquo;re called are incredibly useful. Wouldn&amp;rsquo;t it be great to have user-defined subroutines that behaved the same way? But, since $_ is now just an ordinary lexical variable, a subroutine generally can&amp;rsquo;t access the topic from its caller. It can only access variables in the scope where it is defined.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;is given&lt;/code&gt; property gives subroutines access to their caller&amp;rsquo;s topic. It accesses the topic within the caller&amp;rsquo;s scope and binds it to the property&amp;rsquo;s parameter.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub print_quotes is given($default) {
        print &amp;quot;Random Quote: &amp;quot;;
        print $default;
    }
    ...
    given $quote {
        print_quotes;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;is given&lt;/code&gt; property can appear on subroutines with a full parameter list as well. The only restriction is that the property&amp;rsquo;s parameter can&amp;rsquo;t have the same name as a parameter in the full list.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub print_quotes (*@quotes) is given($default) {
        print &amp;quot;Random Quote: &amp;quot;;
        if ( @quotes.length &amp;gt; 0 ) {
            print @quotes;
        } else {
            print $default;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(A true simulation of the built-in print function would use multimethod dispatch, but that&amp;rsquo;s outside the scope of this article.)&lt;/p&gt;

&lt;p&gt;The property&amp;rsquo;s parameter can have any name, but a parameter named $_ or one that has the &lt;code&gt;is topic&lt;/code&gt; property attached will set the caller&amp;rsquo;s topic as the topic within the subroutine as well.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub print_quotes is given($_) {  
                # alias $_ to caller&#39;s $_
        print;  # prints the value of caller&#39;s $_
    }
    # or
    sub print_quotes is given($default is topic) { 
                # alias $default to caller&#39;s $_
                # and to $_ within the subroutine
        print;  # prints $default, the value of caller&#39;s $_
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-perl-rules-perl-rules-span&#34;&gt;&lt;span id=&#34;perl rules!&#34;&gt;Perl Rules!&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Grammar rules and closures within a rule topicalize their state object. This is convenient because it means methods on the state object can use the unary dot syntax.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    m:each/ aardvark { print .pos } /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The state object for a rule is similar to the $self object for a method. It&amp;rsquo;s an instance of a grammar class. Named rules are really just named methods called on the state object and anonymous rules and closures within a rule are really just anonymous methods called on the state object. Unfortunately, that&amp;rsquo;s just enough information to be tantalizing without actually being useful, but a full explanation could take up an entire article. Still, knowing that the state object is like a $self object is a step in the right direction.&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-catcher-in-the-try-the-catch-er-in-the-try-span&#34;&gt;&lt;span id=&#34;the catcher in the try&#34;&gt;The &lt;code&gt;CATCH&lt;/code&gt;-er in the &lt;code&gt;try&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;CATCH&lt;/code&gt; blocks always topicalize the error variable, &lt;code&gt;$!&lt;/code&gt;. This streamlines the exception catching syntax because the &lt;code&gt;CATCH&lt;/code&gt; block acts as its own switch statement.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    CATCH {
        when Err::WrongUniverse {
            try_new_universe();
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is much tidier than the equivalent:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    CATCH {
        if $!.isa(Err::WrongUniverse) {
            try_new_universe();
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-the-bare-truth-the-bare-truth-span&#34;&gt;&lt;span id=&#34;the bare truth&#34;&gt;The Bare Truth&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Bare closures topicalize their first argument. If the block uses placeholder variables, the topic is also aliased to the Unicode-abetically first variable. The topic is lexically scoped to the block, but it is a read-write parameter, so modifications to $_ within the block modify the original value.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %commands = (
        add  =&amp;gt; { $^a + $^b },
        incr =&amp;gt; { $_  + 1 },
    );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Constructs like &lt;code&gt;grep&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt; are no longer special because they use $_ within the block argument. They simply benefit from the normal behavior of bare blocks.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @names = map { chomp; split /\s*/; } @input;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-nesting-instinct-nesting-instinct-span&#34;&gt;&lt;span id=&#34;nesting instinct&#34;&gt;Nesting Instinct&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Nested topicalizers are a little more complicated. The following example starts with $name as the topic and the first case matches against it. Within the case, the &lt;code&gt;print&lt;/code&gt; also defaults to the current topic. The second case is a little more complicated; it contains a loop. Within the loop is another &lt;code&gt;print&lt;/code&gt; statement. This one also defaults to the current topic which is&amp;hellip; Hmmmm&amp;hellip; is the topic $name or $quote?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    given $name {
        when /Rimmer/ {
            print;
            print rimmer_quote();
        }
        when /Kryten/ {
            for kryten_quotes() -&amp;gt; $quote {
                print;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The answer falls out of a few simple rules:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;There is only one topic at a time.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A series of nested topicalizers doesn&amp;rsquo;t create a collection of topics. The interpreter doesn&amp;rsquo;t have to sort through a complicated set of options to know what the current topic is. There will never be any ambiguity. A script or module may have a series of different topics, but only one at a time.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Topic obeys the lexical scope of topicalizers.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For the programmer, determining the current topic is never any more complex than tracing outward to the nearest topicalizer. The scope of the topic is always restricted to the scope of the topicalizer that created it. So the example above will print the inner topic, $quote.&lt;/p&gt;

&lt;p&gt;An equivalent pair of nested topicalizers in Perl 5 would have printed the outer topic instead. That&amp;rsquo;s because topicalizers never created a $_ alias at the same time as a named alias. It&amp;rsquo;s a fairly common trick in Perl 5 to use a named alias with a &lt;code&gt;for&lt;/code&gt; loop to avoid clobbering $_. That trick doesn&amp;rsquo;t work anymore. Which brings us to the third rule:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;To keep outer topics, use a named alias.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It&amp;rsquo;s just the old trick inverted. Instead of using a named alias with the inner topicalizer to avoid clobbering the outer topic, it uses a named alias with the outer topicalizer to access it after the topic has changed.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        when /Kryten/ {
            for kryten_quotes() -&amp;gt; $quote {
                print $name;
                print;
            }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This really fits better with the way humans think. It makes more sense to give a name to the thing worth keeping than to give a name to the thing to be thrown away.&lt;/p&gt;

&lt;p&gt;Methods have the same problem, but in their case it means that even though the unary dot is really handy in simple methods, in more complex methods with nested topicalizers it&amp;rsquo;s better to use a named parameter for the invocant.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method locate ($self: *@characters) {
        .cleanup_names(@characters);
        for @characters -&amp;gt; $name {
            .display_location($name);
        }
        .change_location(&#39;Holly&#39;);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;.display_location&lt;/code&gt; method won&amp;rsquo;t call a method on $self, it will try to call a method on $name, and fail (unless $name is an object with a &lt;code&gt;.display_location&lt;/code&gt; method). The code will have to call the method as &lt;code&gt;$self.display_location()&lt;/code&gt; instead. It would be clearer to add $self in front of the other method calls as well, but that&amp;rsquo;s entirely a matter of style.&lt;/p&gt;

&lt;h4 id=&#34;span-id-multiple-aliases-multiple-aliases-span&#34;&gt;&lt;span id=&#34;multiple aliases&#34;&gt;Multiple aliases&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Another complication is that topicalizers aren&amp;rsquo;t restricted to a single alias. A &lt;code&gt;for&lt;/code&gt; loop might iterate through an array several parameters at a time:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @characters -&amp;gt; $role1, $role2, $role3 {
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;iterate through several arrays, one after the other, taking a few parameters at a time:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @humans, @betelgeusians, @vogons -&amp;gt; $role1, $role2 {
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or iterate through several arrays at the same time:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @characters; @locations -&amp;gt; $name; $place {
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But no matter how complicated the code gets, the topic stays the same. The rules of the game are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;There is only one topic.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This rule should look familiar. It might even deserve to be called &amp;ldquo;the second law of topics&amp;rdquo;. With nested topicalizers, the restriction means that two topics from different scopes will never be accessible at the same time. With multiple aliases, it means that while a topicalizer can create more than one alias, only one of the aliases can be the topic.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The topic is the first parameter.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This rule makes it easy to pick out the topic. In the first two examples, the topic is $role1, and in the third example it&amp;rsquo;s $name.&lt;/p&gt;

&lt;p&gt;There is one exception to the rule. The &lt;code&gt;is topic&lt;/code&gt; property can select any parameter as topic in place of the default first parameter.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @characters -&amp;gt; $role1, $role2 is topic, $role3 {
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-the-final-frontier-the-final-frontier-span&#34;&gt;&lt;span id=&#34;the final frontier&#34;&gt;The Final Frontier&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;That&amp;rsquo;s pretty much all there is to topic. Hopefully, this article has pushed one more thing into the &amp;ldquo;Gee, that&amp;rsquo;s easy!&amp;rdquo; category. But, if not, carry away one idea: that first law, &amp;ldquo;Topic is $_&amp;rdquo;. The next time conversation turns to Perl 6 and topic, that simple translation will make it understandable.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Synopsis 5</title>
      <link>http://localhost:1313/pub/2002/06/26/synopsis5.html/</link>
      <pubDate>Wed, 26 Jun 2002 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2002/06/26/synopsis5.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 5&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-summary-of-the-changes-in-apocalypse-5&#34;&gt;A summary of the changes in Apocalypse 5:&lt;/h3&gt;

&lt;h3 id=&#34;span-id-unchanged-features-unchanged-features-span&#34;&gt;&lt;span id=&#34;unchanged_features&#34;&gt;Unchanged features&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Capturing: (&amp;hellip;)&lt;/li&gt;
&lt;li&gt;Repetition quantifiers: *, +, and ?&lt;/li&gt;
&lt;li&gt;Alternatives: |&lt;/li&gt;
&lt;li&gt;Backslash escape: &lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Minimal matching suffix: ??, *?, +?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;span-id-modifiers-modifiers-span&#34;&gt;&lt;span id=&#34;modifiers&#34;&gt;Modifiers&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The extended syntax (&lt;code&gt;/x&lt;/code&gt;) is no longer required&amp;hellip;it&amp;rsquo;s the default.&lt;/li&gt;
&lt;li&gt;There are no &lt;code&gt;/s&lt;/code&gt; or &lt;code&gt;/m&lt;/code&gt; modifiers (changes to the meta-characters replace them - see below).&lt;/li&gt;
&lt;li&gt;There is no &lt;code&gt;/e&lt;/code&gt; evaluation modifier on substitutions; use &lt;code&gt;s/pattern/$( code() )/&lt;/code&gt; instead.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;/g&lt;/code&gt; modifier has been renamed to &lt;code&gt;e&lt;/code&gt; (for &lt;code&gt;each&lt;/code&gt;).&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Modifiers are now placed as adverbs at the &lt;em&gt;start&lt;/em&gt; of a match/substitution:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @matches = m:ei/\s* (\w*) \s* ,?/;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The single-character modifiers also have longer versions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        :i        :ignorecase
        :e        :each
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;code&gt;:c&lt;/code&gt; (or &lt;code&gt;:cont&lt;/code&gt;) modifier causes the match to continue from the string&amp;rsquo;s current &lt;code&gt;.pos&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    m:c/ pattern /        # start at end of
                          # previous match on $_
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The new &lt;code&gt;:o&lt;/code&gt; (&lt;code&gt;:once&lt;/code&gt;) modifier replaces the Perl 5 &lt;code&gt;?...?&lt;/code&gt; syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    m:once/ pattern /    # only matches first time
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The new &lt;code&gt;:w&lt;/code&gt; (&lt;code&gt;:word&lt;/code&gt;) modifier causes whitespace sequences to be replaced by &lt;code&gt;\s*&lt;/code&gt; or &lt;code&gt;\s+&lt;/code&gt; subpattern:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    m:w/ next cmd =   &amp;lt;condition&amp;gt;/
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Same as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    m/ \s* next \s+ cmd \s* = \s* &amp;lt;condition&amp;gt;/
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The new &lt;code&gt;:uN&lt;/code&gt; modifier specifies Unicode level:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    m:u0/ .&amp;lt;2&amp;gt; /        # match two bytes
    m:u1/ .&amp;lt;2&amp;gt; /        # match two codepoints
    m:u2/ .&amp;lt;2&amp;gt; /        # match two graphemes
    m:u3/ .&amp;lt;2&amp;gt; /        # match language dependently
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The new &lt;code&gt;:p5&lt;/code&gt; modifier allows Perl 5 regex syntax to be used instead:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    m:p5/(?mi)^[a-z]{1,2}(?=\s)/
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Any integer modifier specifies a count. What kind of count is determined by the character that follows.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If followed by an &lt;code&gt;x&lt;/code&gt;, it means repetition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s:4x{ (&amp;lt;ident&amp;gt;) = (\N+) $$}{$1 =&amp;gt; $2};

    # same as:

    s{ (&amp;lt;ident&amp;gt;) = (\N+) $$}{$1 =&amp;gt; $2} for 1..4;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If followed by an &lt;code&gt;st&lt;/code&gt;, &lt;code&gt;nd&lt;/code&gt;, &lt;code&gt;rd&lt;/code&gt;, or &lt;code&gt;th&lt;/code&gt;, it means find the *N*th occurance:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s:3rd/(\d+)/@data[$1]/;

    # same as:

    m/(\d+)/ &amp;amp;&amp;amp; m:c/(\d+)/ &amp;amp;&amp;amp; s:c/(\d+)/@data[$1]/;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;With the new &lt;code&gt;:any&lt;/code&gt; modifier, the regex will match every possible way (including overlapping) and return all matches.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $str = &amp;quot;abracadabra&amp;quot;;

    @substrings = $str =~ m:any/ a (.*) a /;

    # br brac bracad bracadabr c cad cadabr d dabr br
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;code&gt;:i&lt;/code&gt;, &lt;code&gt;:w&lt;/code&gt;, &lt;code&gt;:c&lt;/code&gt;, &lt;code&gt;:uN&lt;/code&gt;, and &lt;code&gt;:p5&lt;/code&gt; modifiers can be placed inside the regex (and are lexically scoped):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    m/:c alignment = [:i left|right|cent[er|re]] /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;User-defined modifiers will be possible&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        m:fuzzy/pattern/;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Single letter flags can be ``chained&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        s:ewi/cat/feline/
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;User-defined modifiers can also take arguments:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        m:fuzzy(&#39;bare&#39;)/pattern/;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Hence parentheses are no longer valid regex delimiters&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 5&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-changed-metacharacters-changed-metacharacters-span&#34;&gt;&lt;span id=&#34;changed_metacharacters&#34;&gt;Changed metacharacters&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;A dot &lt;code&gt;.&lt;/code&gt; now matches &lt;em&gt;any&lt;/em&gt; character including newline. (The &lt;code&gt;/s&lt;/code&gt; modifier is gone.)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; now always match the start/end of a string, like the old &lt;code&gt;\A&lt;/code&gt; and &lt;code&gt;\z&lt;/code&gt;. (The &lt;code&gt;/m&lt;/code&gt; modifier is gone.)&lt;/li&gt;
&lt;li&gt;A &lt;code&gt;$&lt;/code&gt; no longer matches an optional preceding &lt;code&gt;\n&lt;/code&gt; so it&amp;rsquo;s necessary to say &lt;code&gt;\n?$&lt;/code&gt; if that&amp;rsquo;s what you mean.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\n&lt;/code&gt; now matches a logical (platform independent) newline not just &lt;code&gt;\012&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;\A&lt;/code&gt;, &lt;code&gt;\Z&lt;/code&gt;, and &lt;code&gt;\z&lt;/code&gt; metacharacters are gone.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-new-metacharacters-new-metacharacters-span&#34;&gt;&lt;span id=&#34;new_metacharacters&#34;&gt;New metacharacters&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Because &lt;code&gt;/x&lt;/code&gt; is default:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#&lt;/code&gt; now always introduces a comment.&lt;/li&gt;
&lt;li&gt;Whitespace is now always metasyntactic, i.e. used only for layout and not matched literally (but see the :w modifier described above).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^^&lt;/code&gt; and &lt;code&gt;$$&lt;/code&gt; match line beginnings and endings. (The &lt;code&gt;/m&lt;/code&gt; modifier is gone.)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt; matches an ``anything&amp;rdquo;, while &lt;code&gt;\N&lt;/code&gt; matches an ``anything except newline&amp;rdquo;. (The &lt;code&gt;/s&lt;/code&gt; modifier is gone.)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-bracket-rationalization-bracket-rationalization-span&#34;&gt;&lt;span id=&#34;bracket_rationalization&#34;&gt;Bracket rationalization&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(...)&lt;/code&gt; still delimits a capturing group.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[...]&lt;/code&gt; is no longer a character class.&lt;/li&gt;
&lt;li&gt;It now delimits a non-capturing group.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{...}&lt;/code&gt; is no longer a repetition quantifier.&lt;/li&gt;
&lt;li&gt;It now delimits an embedded closure.&lt;/li&gt;
&lt;li&gt;You can call Perl code as part of a regex match.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Embedded code does not usually affect the match - it is only used for side-effects:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / (\S+) { print &amp;quot;string not blank\n&amp;quot;; $text = $1; }
       \s+  { print &amp;quot;but does contain whitespace\n&amp;quot; }
    /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It can affect the match if it calls &lt;code&gt;fail&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / (\d+) {$1&amp;lt;256 or fail} /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; are now extensible metasyntax delimiters or ``assertions&amp;rdquo; (i.e. they replace &lt;code&gt;(?...)&lt;/code&gt;).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-variable-non-interpolation-variable-non-interpolation-span&#34;&gt;&lt;span id=&#34;variable_(non)interpolation&#34;&gt;Variable (non-)interpolation&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;In Perl 6 regexes, variables don&amp;rsquo;t interpolate.&lt;/li&gt;
&lt;li&gt;Instead they&amp;rsquo;re passed ``raw&amp;rdquo; to the regex engine, which can then decide how to handle them (more on that below).&lt;/li&gt;
&lt;li&gt;The default way in which the engine handles a scalar is to match it as a \Q[&amp;hellip;] literal (i.e.it does not treat the interpolated string as a subpattern).&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In other words, a Perl 6: / $var /&lt;/p&gt;

&lt;p&gt;is like a Perl 5: / \Q$var\E /&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;(To get regex interpolation use an assertion - see below)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;An interpolated array:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / @cmds /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is matched as if it were an alternation of its elements:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / [ @cmds[0] | @cmds[1] | @cmds[2] | ... ] /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;And, of course, each one is matched as a literal.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;An interpolated hash matches a &lt;code&gt;/\w+/&lt;/code&gt; and then requires that sequence to be a valid key of the hash.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;So:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / %cmds /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;is like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / (\w+) { fail unless exists %cmds{$1} } /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-extensible-metasyntax-extensible-metasyntax-span&#34;&gt;&lt;span id=&#34;extensible_metasyntax_(&lt;...&gt;)&amp;ldquo;&amp;gt;Extensible metasyntax (&lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt;)&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The first character after &lt;code&gt;&amp;lt;&lt;/code&gt; determines the behaviour of the assertion.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A leading alphabetic character means it&amp;rsquo;s a grammatical assertion (i.e. a subpattern or a named character class - see below):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / &amp;lt;sign&amp;gt;? &amp;lt;mantissa&amp;gt; &amp;lt;exponent&amp;gt;? /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The special named assertions include:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / &amp;lt;before pattern&amp;gt; /    # was /(?=pattern)/
    / &amp;lt;after pattern&amp;gt; /     # was /(?&amp;lt;pattern)/ 
                            # but now a real pattern!

    / &amp;lt;ws&amp;gt; /                # match any whitespace

    / &amp;lt;sp&amp;gt; /                # match a space char
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A leading number, pair of numbers, or pair of scalars means it&amp;rsquo;s a repetition specifier:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / value was (\d&amp;lt;1,6&amp;gt;) with (\w&amp;lt;$m,$n&amp;gt;) /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A leading &lt;code&gt;$&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, or &lt;code&gt;&amp;amp;&lt;/code&gt; interpolates a variable or subroutine return value as a regex rather than as a literal:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / &amp;lt;$key_pat&amp;gt; = &amp;lt;@value_alternatives&amp;gt; /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A leading &lt;code&gt;(&lt;/code&gt; indicates a code assertion:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / (\d&amp;lt;1,3&amp;gt;) &amp;lt;( $1 &amp;lt; 256 )&amp;gt; /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Same as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / (\d&amp;lt;1,3&amp;gt;) {$1&amp;lt;256 or fail} /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A leading &lt;code&gt;{&lt;/code&gt; indicates code that produces a regex to be interpolated into the pattern at that point:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / (&amp;lt;ident&amp;gt;)  &amp;lt;{ cache{$1} //= get_body($1) }&amp;gt; /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A leading &lt;code&gt;[&lt;/code&gt; indicates an enumerated character class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / &amp;lt;[a-z_]&amp;gt;* /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A leading &lt;code&gt;-&lt;/code&gt; indicates a complemented character class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / &amp;lt;-[a-z_]&amp;gt; &amp;lt;-&amp;lt;alpha&amp;gt;&amp;gt; /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A leading &lt;code&gt;&#39;&lt;/code&gt; indicates an interpolated literal match (including whitespace):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / &amp;lt;&#39;match this exactly (whitespace matters)&#39;&amp;gt; /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The special assertion &lt;code&gt;&amp;lt;.&amp;gt;&lt;/code&gt; matches any logical grapheme (including a Unicode combining character sequences):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / seekto = &amp;lt;.&amp;gt; /  # Maybe a combined char
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A leading &lt;code&gt;!&lt;/code&gt; indicates a negated meaning (a zero-width assertion except for repetition specifiers):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / &amp;lt;!before _&amp;gt;    # We aren&#39;t before an _
      \w&amp;lt;!1,3&amp;gt;       # We match 0 or &amp;gt;3 word chars
    /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 5&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-backslash-reform-backslash-reform-span&#34;&gt;&lt;span id=&#34;backslash_reform&#34;&gt;Backslash reform&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;\p&lt;/code&gt; and &lt;code&gt;\P&lt;/code&gt; properties become intrinsic grammar rules (&lt;code&gt;&amp;lt;prop ...&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;!prop ...&amp;gt;&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;\L...\E&lt;/code&gt;, &lt;code&gt;\U...\E&lt;/code&gt;, and &lt;code&gt;\Q...\E&lt;/code&gt; sequences become &lt;code&gt;\L[...]&lt;/code&gt;, &lt;code&gt;\U[...]&lt;/code&gt;, and &lt;code&gt;\Q[...]&lt;/code&gt; (&lt;code&gt;\E&lt;/code&gt; is gone).&lt;/li&gt;
&lt;li&gt;Note that &lt;code&gt;\Q[...]&lt;/code&gt; will rarely be needed since raw variables interpolate as &lt;code&gt;eq&lt;/code&gt; matches, rather than regexes.&lt;/li&gt;
&lt;li&gt;Backreferences (e.g. &lt;code&gt;\1&lt;/code&gt;) are gone; &lt;code&gt;$1&lt;/code&gt; can be used instead, because it&amp;rsquo;s no longer interpolated.&lt;/li&gt;
&lt;li&gt;New backslash sequences, &lt;code&gt;\h&lt;/code&gt; and &lt;code&gt;\v&lt;/code&gt;, match horizontal and vertical whitespace respectively, including Unicode.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\s&lt;/code&gt; now matches any Unicode whitespace character.&lt;/li&gt;
&lt;li&gt;The new backslash sequence &lt;code&gt;\N&lt;/code&gt; matches anything except a logical newline; it is the negation of &lt;code&gt;\n&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;A series of other new capital backslash sequences are also the negation of their lower-case counterparts:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;\H&lt;/code&gt; matches anything but horizontal whitespace.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\V&lt;/code&gt; matches anything but vertical whitespace.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\T&lt;/code&gt; matches anything but a tab.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\R&lt;/code&gt; matches anything but a return.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\F&lt;/code&gt; matches anything but a formfeed.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\E&lt;/code&gt; matches anything but an escape.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\X...&lt;/code&gt; matches anything but the specified hex character.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-regexes-are-rules-regexes-are-rules-span&#34;&gt;&lt;span id=&#34;regexes_are_rules&#34;&gt;Regexes are rules&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The Perl 5 &lt;code&gt;qr/pattern/&lt;/code&gt; regex constructor is gone.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The Perl 6 equivalents are:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule { pattern }    # always takes {...} as delimiters
    rx/ pattern /       # can take (almost any) chars as delimiters
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If either needs modifiers, they go before the opening delimiter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $regex = rule :ewi { my name is (.*) };
    $regex = rx:ewi/ my name is (.*) /;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The name of the constructor was changed from &lt;code&gt;qr&lt;/code&gt; because it&amp;rsquo;s no longer an interpolating quote-like operator.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;As the syntax indicates, it is now more closely analogous to a &lt;code&gt;sub {...}&lt;/code&gt; constructor.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In fact, that analogy will run &lt;em&gt;very&lt;/em&gt; deep in Perl 6.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Just as a raw &lt;code&gt;{...}&lt;/code&gt; is now always a closure (which may still execute immediately in certain contexts and be passed as a reference in others)&amp;hellip;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;hellip;so too a raw &lt;code&gt;/.../&lt;/code&gt; is now always a regex (which may still match immediately in certain contexts and be passed as a reference in others).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Specifically, a &lt;code&gt;/.../&lt;/code&gt; matches immediately in a void or Boolean context, or when it is an explicit argument of a &lt;code&gt;=~&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Otherwise it&amp;rsquo;s a regex constructor.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;So this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $var = /pattern/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;no longer does the match and sets &lt;code&gt;$var&lt;/code&gt; to the result.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Instead it assigns a regex reference to &lt;code&gt;$var&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The two cases can always be distinguished using &lt;code&gt;m{...}&lt;/code&gt; or &lt;code&gt;rx{...}&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $var = m{pattern};    # Match regex, assign result
    $var = rx{pattern};   # Assign regex itself
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Note that this means that former magically lazy usages like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @list = split /pattern/, $str;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;are now just consequences of the normal semantics.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It&amp;rsquo;s now also possible to set up a user-defined subroutine that acts like grep:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub my_grep($selector, *@list) {
        given $selector {
            when RULE  { ... }
            when CODE  { ... }
            when HASH  { ... }
            # etc.
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Using &lt;code&gt;{...}&lt;/code&gt; or &lt;code&gt;/.../&lt;/code&gt; in the scalar context of the first argument causes it to produce a &lt;code&gt;CODE&lt;/code&gt; or &lt;code&gt;RULE&lt;/code&gt; reference, which the switch statement then selects upon.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-backtracking-control-backtracking-control-span&#34;&gt;&lt;span id=&#34;backtracking_control&#34;&gt;Backtracking control&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Backtracking over a single colon causes the regex engine not to retry the preceding atom:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    m:w/ \( &amp;lt;expr&amp;gt; [ , &amp;lt;expr&amp;gt; ]* : \) /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(i.e. there&amp;rsquo;s no point trying fewer &lt;code&gt;&amp;lt;expr&amp;gt;&lt;/code&gt; matches, if there&amp;rsquo;s no closing parenthesis on the horizon)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Backtracking over a double colon causes the surrounding group to immediately fail:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    m:w/ [ if :: &amp;lt;expr&amp;gt; &amp;lt;block&amp;gt;
         | for :: &amp;lt;list&amp;gt; &amp;lt;block&amp;gt;
         | loop :: &amp;lt;loop_controls&amp;gt;? &amp;lt;block&amp;gt;
         ]
    /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(i.e. there&amp;rsquo;s no point trying to match a different keyword if one was already found but failed)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Backtracking over a triple colon causes the current rule to fail outright (no matter where in the rule it occurs):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule ident {
          ( [&amp;lt;alpha&amp;gt;|_] \w* ) ::: { fail if %reserved{$1} }
        | &amp;quot; [&amp;lt;alpha&amp;gt;|_] \w* &amp;quot;
    }

    m:w/ get &amp;lt;ident&amp;gt;? /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(i.e. using an unquoted reserved word as an identifier is not permitted)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Backtracking over a &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; assertion causes the entire match to fail outright, no matter how many subrules down it happens:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule subname {
        ([&amp;lt;alpha&amp;gt;|_] \w*) &amp;lt;commit&amp;gt; { fail if %reserved{$1} }
    }
    m:w/ sub &amp;lt;subname&amp;gt;? &amp;lt;block&amp;gt; /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(i.e. using a reserved word as a subroutine name is instantly fatal to the ``surrounding&amp;rdquo; match as well)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A &amp;lt;cut&amp;gt; assertion always matches successfully, and has the side effect of deleting the parts of the string already matched.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Attempting to backtrack past a &amp;lt;cut&amp;gt; causes the complete match to fail (like backtracking past a &amp;lt;commit&amp;gt;. This is because there&amp;rsquo;s now no preceding text to backtrack into.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This is useful for throwing away successfully processed input when matching from an input stream or an iterator of arbitrary length.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 5&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-named-regexes-named-regexes-span&#34;&gt;&lt;span id=&#34;named_regexes&#34;&gt;Named Regexes&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The analogy between &lt;code&gt;sub&lt;/code&gt; and &lt;code&gt;rule&lt;/code&gt; extends much further.&lt;/li&gt;
&lt;li&gt;Just as you can have anonymous subs and named subs&amp;hellip;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;hellip;so too you can have anonymous regexes and &lt;em&gt;named&lt;/em&gt; regexes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule ident { [&amp;lt;alpha&amp;gt;|_] \w* }

    # and later...

    @ids = grep /&amp;lt;ident&amp;gt;/, @strings;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;As the above example indicates, it&amp;rsquo;s possible to refer to named regexes, such as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule serial_number { &amp;lt;[A-Z]&amp;gt; \d&amp;lt;8&amp;gt; })
    rule type { alpha | beta | production | deprecated | legacy }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in other regexes as named assertions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule identification { [soft|hard]ware &amp;lt;type&amp;gt; &amp;lt;serial_number&amp;gt; }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-nothing-is-illegal-nothing-is-illegal-span&#34;&gt;&lt;span id=&#34;nothing_is_illegal&#34;&gt;Nothing is illegal&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The null pattern is now illegal.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To match whatever the prior successful regex matched, use:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /&amp;lt;prior&amp;gt;/
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To match the zero-width string, use:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /&amp;lt;null&amp;gt;/
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-hypothetical-variables-hypothetical-variables-span&#34;&gt;&lt;span id=&#34;hypothetical_variables&#34;&gt;Hypothetical variables&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;In embedded closures it&amp;rsquo;s possible to bind a variable to a value that only ``sticks&amp;rdquo; if the surrounding pattern successfully matches.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A variable is declared with the keyword &lt;code&gt;let&lt;/code&gt; and then bound to the desired value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / (\d+) {let $num := $1} (&amp;lt;alpha&amp;gt;+)/
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Now &lt;code&gt;$num&lt;/code&gt; will only be bound if the digits are actually found.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If the match ever backtracks past the closure (i.e. if there are no alphabetics following), the binding is ``undone&amp;rdquo;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This is even more interesting in alternations:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / [ (\d+)      { let $num   := $1 }
      | (&amp;lt;alpha&amp;gt;+) { let $alpha := $2 }
      | (.)        { let $other := $3 }
      ]
    /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;There is also a shorthand for assignment to hypothetical variables:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / [ $num  := (\d+)
      | $alpha:= (&amp;lt;alpha&amp;gt;+)
      | $other:=(.)
      ]
    /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The numeric variables (&lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, etc.) are also ``hypothetical&amp;rdquo;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Numeric variables can be assigned to, and even re-ordered:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my ($key, $val) = m:w{ $1:=(\w+) =\&amp;gt; $2:=(.*?)
                         | $2:=(.*?) \&amp;lt;= $1:=(\w+)
                         };
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Repeated captures can be bound to arrays:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / @values:=[ (.*?) , ]* /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Pairs of repeated captures can be bound to hashes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / %options:=[ (&amp;lt;ident&amp;gt;) = (\N+) ]* /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Or just capture the keys (and leave the values undef):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / %options:=[ (&amp;lt;ident&amp;gt;) = \N+ ]* /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Subrules (e.g. &lt;code&gt;&amp;lt;rule&amp;gt;&lt;/code&gt;) also capture their result in a hypothetical variable of the same name as the rule:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / &amp;lt;key&amp;gt; =\&amp;gt; &amp;lt;value&amp;gt; { %hash{$key} = $value } /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-return-values-from-matches-return-values-from-matches-span&#34;&gt;&lt;span id=&#34;return_values_from_matches&#34;&gt;Return values from matches&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;A match always returns a ``match object&amp;rdquo;, which is also available as (lexical) &lt;code&gt;$0&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The match object evaluates differently in different contexts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;in boolean context it evaluates as true or false (i.e. did the match succeed?):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if /pattern/ {...}
    # or:
    /pattern/; if $0 {...}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;in numeric context it evaluates to the number of matches:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $match_count += m:e/pattern/;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;in string context it evaluates to the captured substring (if there was exactly one capture in the pattern) or to the entire text that was matched (if the pattern does not capture, or captures multiple elements):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print %hash{$text =~ /,? (&amp;lt;ident&amp;gt;)/};
    # or: 
    $text =~ /,? (&amp;lt;ident&amp;gt;)/  &amp;amp;&amp;amp;  print %hash{$0};
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;Within&lt;/em&gt; a regex, &lt;code&gt;$0&lt;/code&gt; acts like a hypothetical variable.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It controls what a regex match returns (like &lt;code&gt;$$&lt;/code&gt; does in yacc)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use &lt;code&gt;$0:=&lt;/code&gt; to override the default return behaviour described above:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule string1 { (&amp;lt;[&amp;quot;&#39;`]&amp;gt;) ([ \\. | &amp;lt;-[\\]&amp;gt; ]*?) $1 }

    $match = m/&amp;lt;string1&amp;gt;/;  # default: $match includes 
                            # opening and closing quotes

    rule string2 { (&amp;lt;[&amp;quot;&#39;`]&amp;gt;) $0:=([ \\. | &amp;lt;-[\\]&amp;gt; ]*?) $1 }

    $match = m/&amp;lt;string2&amp;gt;/;  # $match now excludes quotes
                            # because $0 explicitly bound 
                            # to second capture only
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this document is out of date and remains here for historic interest. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 5&lt;/a&gt; for the current design information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-matching-against-nonstrings-matching-against-non-strings-span&#34;&gt;&lt;span id=&#34;matching_against_nonstrings&#34;&gt;Matching against non-strings&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Anything that can be tied to a string can be matched against a regex. This feature is particularly useful with input streams:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @array := &amp;lt;$fh&amp;gt;;           # lazy when aliased
    my $array is from(\@array);   # tie scalar

    # and later...

    $array =~ m/pattern/;         # match from stream
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-grammars-grammars-span&#34;&gt;&lt;span id=&#34;grammars&#34;&gt;Grammars&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Potential ``collision&amp;rdquo; problem with named regexes&lt;/li&gt;
&lt;li&gt;Of course, a named &lt;code&gt;ident&lt;/code&gt; regex shouldn&amp;rsquo;t clobber someone else&amp;rsquo;s &lt;code&gt;ident&lt;/code&gt; regex.&lt;/li&gt;
&lt;li&gt;So some mechanism is needed to confine regexes to a namespace.&lt;/li&gt;
&lt;li&gt;If subs are the model for rules, then modules/classes are the obvious model for aggregating them.&lt;/li&gt;
&lt;li&gt;Such collections of rules are generally known as ``grammars&amp;rdquo;.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Just as a class can collect named actions together:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Identity {
        method name { &amp;quot;Name = $.name&amp;quot; }
        method age  { &amp;quot;Age  = $.age&amp;quot;  }
        method addr { &amp;quot;Addr = $.addr&amp;quot; }

        method desc {
            print .name(), &amp;quot;\n&amp;quot;,
                  .age(),  &amp;quot;\n&amp;quot;,
                  .addr(), &amp;quot;\n&amp;quot;;
        }

        # etc.
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;So too a grammar can collect a set of named rules together:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    grammar Identity {
        rule name :w { Name = (\N+) }
        rule age  :w { Age  = (\d+) }
        rule addr :w { Addr = (\N+) }
        rule desc {
            &amp;lt;name&amp;gt; \n
            &amp;lt;age&amp;gt;  \n
            &amp;lt;addr&amp;gt; \n
        }

        # etc.
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Like classes, grammars can inherit:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    grammar Letter {
        rule text     { &amp;lt;greet&amp;gt; &amp;lt;body&amp;gt; &amp;lt;close&amp;gt; }

        rule greet :w { [Hi|Hey|Yo] $to:=(\S+?) , $$}

        rule body     { &amp;lt;line&amp;gt;+ }

        rule close :w { Later dude, $from:=(.+) }

        # etc.
    }

    grammar FormalLetter is Letter {

        rule greet :w { Dear $to:=(\S+?) , $$}

        rule close :w { Yours sincerely, $from:=(.+) }

    }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Inherit rule definitions (polymorphically!)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;So there&amp;rsquo;s no need to respecify body, line, etc.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Perl 6 will come with at least one grammar predefined:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    grammar Perl {    # Perl&#39;s own grammar

        rule prog { &amp;lt;line&amp;gt;* }

        rule line { &amp;lt;decl&amp;gt;
                  | &amp;lt;loop&amp;gt;
                  | &amp;lt;label&amp;gt; [&amp;lt;cond&amp;gt;|&amp;lt;sideff&amp;gt;|;]
        }

        rule decl { &amp;lt;sub&amp;gt; | &amp;lt;class&amp;gt; | &amp;lt;use&amp;gt; }

        # etc. etc.
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Hence:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    given $source_code {
        $parsetree = m/&amp;lt;Perl::prog&amp;gt;/;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-transliteration-transliteration-span&#34;&gt;&lt;span id=&#34;transliteration&#34;&gt;Transliteration&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The tr/// quote-like operator now also has a subroutine form.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It can be given either a single &lt;code&gt;PAIR&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $str =~ tr( &#39;A-C&#39; =&amp;gt; &#39;a-c&#39; );
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Or a hash (or hash ref):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $str =~ tr( {&#39;A&#39;=&amp;gt;&#39;a&#39;, &#39;B&#39;=&amp;gt;&#39;b&#39;, &#39;C&#39;=&amp;gt;&#39;c&#39;} );
    $str =~ tr( {&#39;A-Z&#39;=&amp;gt;&#39;a-z&#39;, &#39;0-9&#39;=&amp;gt;&#39;A-F&#39;} );
    $str =~ tr( %mapping );
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Or two arrays (or array refs):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $str =~ tr( [&#39;A&#39;..&#39;C&#39;], [&#39;a&#39;..&#39;c&#39;] );
    $str =~ tr( @UPPER, @lower );
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Note that the array version can map one-or-more characters to one-or-more characters:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $str =~ tr( [&#39; &#39;,      &#39;&amp;lt;&#39;,    &#39;&amp;gt;&#39;,    &#39;&amp;amp;&#39;    ],
                [&#39;&amp;amp;nbsp;&#39;, &#39;&amp;amp;lt;&#39;, &#39;&amp;amp;gt;&#39;, &#39;&amp;amp;amp;&#39; ]);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;**&lt;/p&gt;

&lt;p&gt;**&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Return to &lt;a href=&#34;http://localhost:1313/&#34;&gt;Perl.com&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

