<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Perrin Harkins on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/authors/perrin-harkins/</link>
    <description>Recent content in Perrin Harkins on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 17 Oct 2001 00:00:00 -0800</lastBuildDate>
    <atom:link href="/authors/perrin-harkins/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Building a Large-scale E-commerce Site with Apache and mod_perl</title>
      <link>http://localhost:1313/pub/2001/10/17/etoys.html/</link>
      <pubDate>Wed, 17 Oct 2001 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2001/10/17/etoys.html/</guid>
      <description>

&lt;h3 id=&#34;span-id-common-myths-common-myths-span&#34;&gt;&lt;span id=&#34;common myths&#34;&gt;Common Myths&lt;/span&gt;&lt;/h3&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;Table of Contents&lt;/p&gt;
&lt;p&gt;• &lt;a href=&#34;#roll%20your%20own%20application%20server&#34;&gt;Roll Your Own Application Server&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;#case%20study:%20etoys.com&#34;&gt;Case Study: eToys.com&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;#apache::perlrun%20to%20the%20rescue&#34;&gt;Apache::PerlRun to the Rescue&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;#planning%20the%20new%20architecture&#34;&gt;Planning the New Architecture&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/17/etoys.html?page=2#surviving%20christmas%202000&#34;&gt;Surviving Christmas 2000&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/17/etoys.html?page=2#the%20architecture&#34;&gt;The Architecture&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/17/etoys.html?page=2#proxy%20servers&#34;&gt;Proxy Servers&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/17/etoys.html?page=2#application%20servers&#34;&gt;Application Servers&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/17/etoys.html?page=2#search%20servers&#34;&gt;Search Servers&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/17/etoys.html?page=2#load%20balancing%20and%20failover&#34;&gt;Load Balancing and Failover&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/17/etoys.html?page=3#code%20structure&#34;&gt;Code Structure&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/17/etoys.html?page=3#caching&#34;&gt;Caching&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/17/etoys.html?page=3#session%20tracking&#34;&gt;Session Tracking&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/17/etoys.html?page=3#security&#34;&gt;Security&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/17/etoys.html?page=3#exception%20handling&#34;&gt;Exception Handling&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/17/etoys.html?page=4#templates&#34;&gt;Templates&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/17/etoys.html?page=4#controller%20example&#34;&gt;Controller Example&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/17/etoys.html?page=4#performance%20tuning&#34;&gt;Performance Tuning&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/17/etoys.html?page=5#trap:%20nested%20exceptions&#34;&gt;Trap: Nested Exceptions&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/17/etoys.html?page=5#berkeley%20db&#34;&gt;Berkeley DB&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/17/etoys.html?page=5#valuable%20tools&#34;&gt;Valuable Tools&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/17/etoys.html?page=5#an%20open%20source%20success%20story&#34;&gt;An Open-Source Success Story&lt;/a&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;When it comes to building a large e-commerce Web site, everyone is full of advice. Developers will tell you that only a site built in C++ or Java (depending on which they prefer) can scale up to handle heavy traffic. Application server vendors will insist that you need a packaged all-in-one solution for the software. Hardware vendors will tell you that you need the top-of-the-line mega-machines to run a large site. This is a story about how we built a large e-commerce site using mainly open-source software and commodity hardware. We did it, and you can do it, too.&lt;/p&gt;

&lt;h3 id=&#34;span-id-perl-saves-perl-saves-span&#34;&gt;&lt;span id=&#34;perl saves&#34;&gt;Perl Saves&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Perl has long been the preferred language for developing CGI scripts. It combines supreme flexibility with rapid development. &lt;em&gt;Programming Perl&lt;/em&gt; is still O&amp;rsquo;Reilly&amp;rsquo;s top-selling technical book, and community support abounds. Lately though, Perl has come under attack from certain quarters. Detractors claim that it&amp;rsquo;s too slow for serious development work and that code written in Perl is too hard to maintain.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;mod_perl&lt;/code&gt; Apache module changes the whole performance picture for Perl. Embedding a Perl interpreter inside of Apache provides performance equivalent to Java servlets, and makes it an excellent choice for building large sites. Through the use of Perl&amp;rsquo;s object-oriented features and some basic coding rules, you can build a set of code that is a pleasure to maintain, or at least no worse than other languages.&lt;/p&gt;

&lt;h3 id=&#34;span-id-roll-your-own-application-server-roll-your-own-application-server-span&#34;&gt;&lt;span id=&#34;roll your own application server&#34;&gt;Roll Your Own Application Server&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;When you combine Apache, &lt;code&gt;mod_perl&lt;/code&gt; and open-source code available from CPAN (the Comprehensive Perl Archive Network), you get a set of features equivalent to a commercial application server:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Session handling&lt;/li&gt;
&lt;li&gt;Load balancing&lt;/li&gt;
&lt;li&gt;Persistent database connections&lt;/li&gt;
&lt;li&gt;Advanced HTML templating&lt;/li&gt;
&lt;li&gt;Security&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You also get some things you won&amp;rsquo;t get from a commercial product, such as a direct line to the core development team through the appropriate mailing list and the ability to fix problems yourself instead of waiting for a patch. Moreover, each part of the system is under your control, making you limited only by your team&amp;rsquo;s abilities.&lt;/p&gt;

&lt;h3 id=&#34;span-id-case-study-etoys-com-case-study-etoys-com-span&#34;&gt;&lt;span id=&#34;case study: etoys.com&#34;&gt;Case Study: eToys.com&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;When we first arrived at eToys in 1999, we found a situation that is probably familiar to many who have joined a growing startup Internet company. The system was based on CGI scripts talking to a MySQL database. Static file serving and dynamic content generation were sharing resources on the same machines. The CGI code was largely written in a Perl4-ish style and not as modular as it could be; which was not surprising since most of it was built as quickly as possible by a small team.&lt;/p&gt;

&lt;p&gt;Our major task was to figure out how to get this system to scale large enough to handle the expected Christmas traffic. The toy business is all about seasonality, and the difference between the peak selling season and the rest of the year is enormous. The site had barely survived the previous Christmas, and the MySQL database didn&amp;rsquo;t look like it could scale much further.&lt;/p&gt;

&lt;p&gt;The call had already been made to switch to Oracle, and a DBA team was in place. We didn&amp;rsquo;t have enough time to do a redesign of the software, so we had to scramble to put in place whatever performance improvements we could finish by Christmas.&lt;/p&gt;

&lt;h4 id=&#34;span-id-apache-perlrun-to-the-rescue-apache-perlrun-to-the-rescue-span&#34;&gt;&lt;span id=&#34;apache::perlrun to the rescue&#34;&gt;Apache::PerlRun to the Rescue&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Apache::PerlRun&lt;/code&gt; is a module that exists to smooth the transition between basic CGI and &lt;code&gt;mod_perl&lt;/code&gt;. It emulates a CGI environment, and provides some (but not all) of the performance benefits associated with code written for &lt;code&gt;mod_perl&lt;/code&gt;. Using this module and the persistent database connections provided by &lt;code&gt;Apache::DBI&lt;/code&gt;, we were able to do a basic port to &lt;code&gt;mod_perl&lt;/code&gt; and Oracle in time for Christmas, and combined with some new hardware we were ready to face the Christmas rush.&lt;/p&gt;

&lt;p&gt;The peak traffic lasted for eight weeks, most of which were spent frantically fixing things or nervously waiting for something else to break. Nevertheless, we made it through. During that time, we collected the following statistics:&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;

&lt;a href=&#34;http://conferences.oreilly.com/oscon/&#34;&gt;O&amp;#39;Reilly Open Source Convention -- July 22-26, San Diego, CA.&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;From the Frontiers of Research to the Heart of the Enterprise&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://conferences.oreillynet.com/cs/os2002/view/e_sess/2801&#34;&gt;Efficient Shared Data for mod_perl&lt;/a&gt;&lt;br /&gt;
Perrin Harkins discusses the performance and ease of use of different options for sharing data that are available on CPAN, from IPC::Shareable to Cache::Cache at the &lt;a href=&#34;http://conferences.oreillynet.com/os2002/&#34;&gt;O&#39;Reilly Open Source Convention&lt;/a&gt;, this July 22-26, in San Diego.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;60 - 70,000 sessions/hour&lt;/li&gt;
&lt;li&gt;800,000 page views/hour&lt;/li&gt;
&lt;li&gt;7,000 orders/hour&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;According to Media Metrix, we were the third-most-heavily trafficked e-commerce site, behind eBay and Amazon.&lt;/p&gt;

&lt;h3 id=&#34;span-id-planning-the-new-architecture-planning-the-new-architecture-span&#34;&gt;&lt;span id=&#34;planning the new architecture&#34;&gt;Planning the New Architecture&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;It was clear that we would need to do a redesign for 2000. We had reached the limits of the current system and needed to tackle some of the harder problems that we had been holding off on.&lt;/p&gt;

&lt;p&gt;Goals for the new system included moving away from offline page generation. The old system had been building HTML pages for each product and product category on the site in a batch job and dumping them out as static files. This was effective when we had a small database of products since the static files gave such good performance, but we had recently added a children&amp;rsquo;s bookstore to the site that increased the size of our product database by an order of magnitude and made the time required to generate each page prohibitive. We needed a strategy that would only require us to build pages that customers were actually interested in and would still provide solid performance.&lt;/p&gt;

&lt;p&gt;We also wanted to re-do the database schema for more flexibility, and structure the code in a more modular way that would make it easier for a team to share the development work without stepping on one another. We knew that the new codebase would have to be flexible enough to support a continuously evolving set of features.&lt;/p&gt;

&lt;p&gt;Not all of the team had significant experience with object-oriented Perl, so we brought in Randal Schwartz and Damian Conway to do training sessions with us. We created a set of coding standards, drafted a design and built our system.&lt;/p&gt;

&lt;h3 id=&#34;span-id-surviving-christmas-2000-surviving-christmas-2000-span&#34;&gt;&lt;span id=&#34;surviving christmas 2000&#34;&gt;Surviving Christmas 2000&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Our capacity planning was for three times the traffic of the previous peak. That&amp;rsquo;s what we tested to, and that&amp;rsquo;s about what we got:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;200,000+ sessions/hour&lt;/li&gt;
&lt;li&gt;2.5 million+ page views/hour&lt;/li&gt;
&lt;li&gt;20,000+ orders/hour&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The software survived, although one of the routers went up in smoke. Once again, we were rated the third-most-highly trafficked e-commerce site for the season.&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-architecture-the-architecture-span&#34;&gt;&lt;span id=&#34;the architecture&#34;&gt;The Architecture&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The machine strategy for the system is a fairly common one: low-cost Intel-based servers with a load-balancer in front of them, and big iron for the database.&lt;/p&gt;

&lt;p&gt;Like many commercial packages, we have separate systems for the front-end Web servers (which we call proxy servers) and the application servers that generate the dynamic content. Both the proxy servers and the application servers are load-balanced using dedicated hardware from f5 Networks. More details about each of the systems shown here is provided below.&lt;/p&gt;

&lt;p&gt;We chose to run Linux on our proxy and application servers, a common platform for &lt;code&gt;mod_perl&lt;/code&gt; sites. The ease of remote administration under Linux made the clustered approach possible. Linux also provided solid security features and automated build capabilities to help with adding new servers.&lt;/p&gt;

&lt;p&gt;The database servers are IBM NUMA-Q machines, which run &lt;em&gt;DYNIX/ptx&lt;/em&gt;.&lt;/p&gt;

&lt;h4 id=&#34;span-id-proxy-servers-proxy-servers-span&#34;&gt;&lt;span id=&#34;proxy servers&#34;&gt;Proxy Servers&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The proxy servers run a slim build of Apache, without &lt;code&gt;mod_perl&lt;/code&gt;. They have several standard Apache modules installed, in addition to our own customized version of &lt;em&gt;mod_session&lt;/em&gt;, which assigns session cookies. Because the processes are so small, we can run as many as 400 Apache children per machine. These servers handle all image requests themselves, and pass page requests on to the application servers. They communicate with the app servers using standard HTTP requests, and cache the page results when appropriate headers are sent from the app servers. The cached pages are stored on a shared NFS partition of a Network Appliance filer. Serving pages from the cache is nearly as fast as serving static files, i.e. &lt;em&gt;very&lt;/em&gt; fast.&lt;/p&gt;

&lt;p&gt;This kind of reverse-proxy setup is a commonly recommended approach when working with &lt;code&gt;mod_perl&lt;/code&gt;, since it uses the lightweight proxy processes to send the content to clients (who may be on slow connections) and frees the resource-intensive &lt;code&gt;mod_perl&lt;/code&gt; processes to move to the next request. For more information on why this configuration is helpful, see the &lt;code&gt;mod_perl&lt;/code&gt; developer&amp;rsquo;s guide at &lt;a href=&#34;http://perl.apache.org/guide/&#34;&gt;http://perl.apache.org/guide/&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;span-id-application-servers-application-servers-span&#34;&gt;&lt;span id=&#34;application servers&#34;&gt;Application Servers&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The application servers run &lt;code&gt;mod_perl&lt;/code&gt;, and little else. They have a local cache for Perl objects, using &lt;em&gt;Berkeley DB&lt;/em&gt;. The Web applications run here, and shared resources like HTML templates are mounted over NFS from the NetApp filer. Because they do the heavy lifting in this setup, these machines are somewhat beefy, with dual CPUs and 1GB of RAM each.&lt;/p&gt;

&lt;h4 id=&#34;span-id-search-servers-search-servers-span&#34;&gt;&lt;span id=&#34;search servers&#34;&gt;Search Servers&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;There is a third set of machines dedicated to handling searches. Since searching was such a large percentage of overall traffic, it was worthwhile to dedicate resources to it and take the load off the application servers and database.&lt;/p&gt;

&lt;p&gt;The software on these boxes is a multi-threaded daemon that we developed in-house using C++. The application servers talk to the search servers using a Perl module. The search daemon accepts a set of search conditions and returns a sorted list of object IDs of the products whose data fits those conditions. Then the application servers look up the data to display these products from the database. The search servers know nothing about HTML or the Web interface.&lt;/p&gt;

&lt;p&gt;This approach of finding the IDs with the search server and then retrieving the object data may sound like a performance hit, but in practice the object data usually comes from the application server&amp;rsquo;s cache rather than the database. This design allows us to minimize the duplicated data between the database and the search servers, making it easier and faster to refresh the index. It also allows us to reuse the same Perl code for retrieving product objects from the database, regardless of how they were found.&lt;/p&gt;

&lt;p&gt;The daemon uses a standard inverted word list approach to searching. The index is periodically built from the relevant data in Oracle. If you prefer an all-Perl solution, then there are modules on CPAN that implement this approach, including &lt;code&gt;Search::InvertedIndex&lt;/code&gt; and &lt;code&gt;DBIx::FullTextSearch&lt;/code&gt;. We chose to write our own because of the tight performance requirements on this part of the system, and because we had an unusually complex set of sorting rules for the returned IDs.&lt;/p&gt;

&lt;h3 id=&#34;span-id-load-balancing-and-failover-load-balancing-and-failover-span&#34;&gt;&lt;span id=&#34;load balancing and failover&#34;&gt;Load Balancing and Failover&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;We took pains to make sure that we would be able to provide load-balancing among nodes of the cluster and fault-tolerance in case one or more nodes failed. The proxy servers are balanced using a random selection algorithm. A user might end up on a different one on each request. These servers don&amp;rsquo;t hold any state information, so the goal is just to distribute the load evenly.&lt;/p&gt;

&lt;p&gt;The application servers use &amp;ldquo;sticky&amp;rdquo; load balancing. That means that once a user goes to a particular app server, all of her subsequent requests during that session will also be passed to the same app server. The f5 hardware accomplishes this using browser cookies.&lt;/p&gt;

&lt;p&gt;The load balancers run a periodic service check on each server and remove any servers that fail the check from rotation. When a server fails, all users that were &amp;ldquo;stuck&amp;rdquo; to that machine are moved to another one.&lt;/p&gt;

&lt;p&gt;In order to ensure that no data is lost if an app server dies, all updates are written to the database. As a result, user data like the contents of a shopping cart is preserved even in cases of catastrophic hardware failure on an app server. This is essential for a large e-commerce site.&lt;/p&gt;

&lt;p&gt;The database has a separate failover system, which we will not go into here. It follows standard practices recommended by our vendors.&lt;/p&gt;

&lt;h3 id=&#34;span-id-code-structure-code-structure-span&#34;&gt;&lt;span id=&#34;code structure&#34;&gt;Code Structure&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The code is structured around the classic Model-View-Controller pattern, originally from SmallTalk and now often applied to Web applications. The MVC pattern is a way of splitting an application&amp;rsquo;s responsibilities into three distinct layers.&lt;/p&gt;

&lt;p&gt;Classes in the Model layer represent business concepts and data, like products or users. These have an API but no end-user interface. They know nothing about HTTP or HTML and can be used in non-Web applications like cron jobs. They talk to the database and other data sources, and manage their own persistence.&lt;/p&gt;

&lt;p&gt;The Controller layer translates Web requests into appropriate actions on the Model layer. It handles parsing parameters, checking input, fetching the appropriate Model objects, and calling methods on them. Then it determines the appropriate View to use and sends the resulting HTML to the user.&lt;/p&gt;

&lt;p&gt;View objects are really HTML templates. The Controller passes data from the Model objects to them and they generate a Web page. These are implemented with the Template Toolkit, a powerful templating system written in Perl. The templates have some basic conditional statements and looping in them, but only enough to express the formatting logic. No application control flow is embedded in the templates.&lt;/p&gt;

&lt;h3 id=&#34;span-id-caching-caching-span&#34;&gt;&lt;span id=&#34;caching&#34;&gt;Caching&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The core of the performance strategy is a multi-tier caching system. On the application servers, data objects are cached in shared memory with a backing store on local disk. Applications specify how long a data object can be out of sync with the database, and all future accesses during that time are served from the high-speed cache. This type of cache control is known as ``time-to-live.&amp;rdquo; The local cache is implemented using a &lt;em&gt;Berkeley DB&lt;/em&gt; database. Objects are serialized with the standard &lt;em&gt;Storable&lt;/em&gt; module from CPAN.&lt;/p&gt;

&lt;p&gt;Data objects are divided into pieces when necessary to provide finer granularity for expiration times. For example, product inventory is updated more frequently than other product data. By splitting up the product data, we can use a short expiration for inventory that keeps it in tighter sync with the database, while still using a longer expiration for the less volatile parts of the product data.&lt;/p&gt;

&lt;p&gt;The application servers&amp;rsquo; object caches share product data between them using the IP Multicast protocol and custom daemons written in C. When a product is placed in the cache on one server, the data is replicated to the cache on all other servers. This technique is successful because of the high locality of access in product data. During the 2000 Christmas season this cache achieved a 99 percent hit ratio, thus taking a large amount of work off the database.&lt;/p&gt;

&lt;p&gt;In addition to caching the data objects, entire pages that are not user-specific, like product detail pages, can be cached. The application takes the shortest expiration time of the data objects used in the pages and specifies that to the proxy servers as a page expiration time, using standard &lt;em&gt;Expires&lt;/em&gt; headers. The proxy servers cache the generated page on a shared NFS partition. Pages served from this cache have performance close to that of static pages.&lt;/p&gt;

&lt;p&gt;To allow for emergency fixes, we added a hook to &lt;code&gt;mod_proxy&lt;/code&gt; that deletes the cached copy of a specified URL. This was used when a page needed to be changed immediately to fix incorrect information.&lt;/p&gt;

&lt;p&gt;An extra advantage of this &lt;code&gt;mod_proxy&lt;/code&gt; cache is the automatic handling of &lt;em&gt;If-Modified-Since&lt;/em&gt; requests. We did not need to implement this ourselves since &lt;code&gt;mod_proxy&lt;/code&gt; already provides it.&lt;/p&gt;

&lt;h3 id=&#34;span-id-session-tracking-session-tracking-span&#34;&gt;&lt;span id=&#34;session tracking&#34;&gt;Session Tracking&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Users are assigned session IDs using HTTP cookies. This is done at the proxy servers by our customized version of &lt;code&gt;mod_session&lt;/code&gt;. Doing it at the proxy ensures that users accessing cached pages will still get a session ID assigned. The session ID is simply a key into data stored on the server-side. User sessions are assigned to an application server and continue to use that server unless it becomes unavailable. This is called &amp;ldquo;sticky&amp;rdquo; load balancing. Session data and other data modified by the user &amp;ndash; such as shopping cart contents &amp;ndash; is written to both the object cache and the database. The double write carries a slight performance penalty, but it allows for fast read access on subsequent requests without going back to the database. If a server failure causes a user to be moved to a different application server, then the data is simply fetched from the database again.&lt;/p&gt;

&lt;h3 id=&#34;span-id-security-security-span&#34;&gt;&lt;span id=&#34;security&#34;&gt;Security&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;A large e-commerce site is a popular target for all types of attacks. When designing such a system, you have to assume that you will be attacked and build with security in mind, at the application level as well as the machine level.&lt;/p&gt;

&lt;p&gt;The main rule of thumb is &amp;ldquo;don&amp;rsquo;t trust the client!&amp;rdquo; User-specific data sent to the client is protected using multiple levels of encryption. SSL keeps sensitive data exchanges private from anyone snooping on network traffic. To prevent &amp;ldquo;session hijacking&amp;rdquo; (when someone tampers with their session ID in order to gain access to another user&amp;rsquo;s session), we include a Message Authentication Code (MAC) as part of the session cookie. This is generated using the standard &lt;code&gt;Digest::SHA1&lt;/code&gt; module from CPAN, with a seed phrase known only to our servers. By running the ID from the session cookie through this MAC algorithm, we can verify that the data being presented was generated by us and not tampered with.&lt;/p&gt;

&lt;p&gt;In situations where we need to include some state information in an HTML form or URL and don&amp;rsquo;t want it to be obvious to the user, we use the CPAN &lt;code&gt;Crypt::&lt;/code&gt; modules to encrypt and decrypt it. The &lt;code&gt;Crypt::CBC&lt;/code&gt; module is a good place to start.&lt;/p&gt;

&lt;p&gt;To protect against simple overload attacks, when someone uses a program to send high volumes of requests at our servers hoping to make them unavailable to customers, access to the application servers is controlled by a throttling program. The code is based on some work by Randal Schwartz in his &lt;code&gt;Stonehenge::Throttle&lt;/code&gt; module. Accesses for each user are tracked in compact logs written to an NFS partition. The program enforces limits on how many requests a user can make within a certain period of time.&lt;/p&gt;

&lt;p&gt;For more information on Web security concerns including the use of MAC, encryption and overload prevention, we recommend looking at the books &lt;em&gt;&lt;a href=&#34;http://www.oreilly.com/catalog/cgi2/&#34;&gt;CGI Programming with Perl, 2nd Edition&lt;/a&gt;&lt;/em&gt; and &lt;em&gt;&lt;a href=&#34;http://www.oreilly.com/catalog/wrapmod/&#34;&gt;Writing Apache Modules with Perl and C&lt;/a&gt;&lt;/em&gt;, both from &lt;a href=&#34;http://oreilly.com&#34;&gt;O&amp;rsquo;Reilly&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-exception-handling-exception-handling-span&#34;&gt;&lt;span id=&#34;exception handling&#34;&gt;Exception Handling&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;When planning this system, we considered using Java as the implementation language. We decided to go with Perl, but we really missed Java&amp;rsquo;s nice exception-handling features. Luckily, Graham Barr&amp;rsquo;s Error module from CPAN supplies similar capabilities in Perl.&lt;/p&gt;

&lt;p&gt;Perl already has support for trapping runtime errors and passing exception objects, but the Error module adds some nice syntactic sugar. The following code sample is typical of how we used the module:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try {
        do_some_stuff();
    } catch My::Exception with {
        my $E = shift;
        handle_exception($E);
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The module allows you to create your own exception classes and trap for specific types of exceptions.&lt;/p&gt;

&lt;p&gt;One nice benefit of this is the way it works with &lt;em&gt;DBI&lt;/em&gt;. If you turn on &lt;em&gt;DBI&amp;rsquo;s&lt;/em&gt; &lt;em&gt;RaiseError&lt;/em&gt; flag and use try blocks in places where you want to trap exceptions, the &lt;em&gt;Error&lt;/em&gt; module can turn &lt;em&gt;DBI&lt;/em&gt; errors into simple &lt;em&gt;Error&lt;/em&gt; objects.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try {
        $sth-&amp;gt;execute();
    } catch Error with {
        # roll back and recover
        $dbh-&amp;gt;rollback();
        # etc.
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code shows a condition where an error would indicate that we should roll back a database transaction. In practice, most &lt;code&gt;DBI&lt;/code&gt; errors indicate something unexpected happened with the database and the current action can&amp;rsquo;t continue. Those exceptions are allowed to propagate up to a top-level &lt;code&gt;try{}&lt;/code&gt; block that encloses the whole request. When errors are caught there, we log a stacktrace and send a friendly error page back to the user.&lt;/p&gt;

&lt;h3 id=&#34;span-id-templates-templates-span&#34;&gt;&lt;span id=&#34;templates&#34;&gt;Templates&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Both the HTML and the formatting logic for merging application data into it is stored in the templates. They use a CPAN module called &lt;em&gt;Template Toolkit&lt;/em&gt;, which provides a simple but powerful syntax for accessing the Perl data structures passed to them by the application. In addition to basics such as looping and conditional statements, it provides extensive support for modularization, allowing the use of includes and macros to simplify template maintenance and avoid redundancy.&lt;/p&gt;

&lt;p&gt;We found &lt;em&gt;Template Toolkit&lt;/em&gt; to be an invaluable tool on this project. Our HTML coders picked it up quickly and were able to do nearly all of the templating work without help from the Perl coders. We supplied them with documentation of what data would be passed to each template and they did the rest. If you have never experienced the joy of telling a project manager that the HTML team can handle his requested changes without any help from you, then you are seriously missing out!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Template Toolkit&lt;/em&gt; compiles templates into Perl bytecode and caches them in memory to improve efficiency. When template files change on disk they are picked up and re-compiled. This is similar to how other &lt;code&gt;mod_perl&lt;/code&gt; systems like Mason and &lt;code&gt;Apache::Registry&lt;/code&gt; work.&lt;/p&gt;

&lt;p&gt;By varying the template search path, we made it possible to assign templates to particular sections of the site, allowing a customized look and feel for specific areas. For example, the page header template in the bookstore section of the site can be different from the one in the video game store section. It is even possible to serve the same data with a different appearance in different parts of the site, allowing for co-branding of content.&lt;/p&gt;

&lt;p&gt;This is a sample of what a basic loop looks like when coded in &lt;em&gt;Template Toolkit&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [% FOREACH item = cart.items %]
    name: [% item.name %]
    price: [% item.price %]
    [% END %]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-controller-example-controller-example-span&#34;&gt;&lt;span id=&#34;controller example&#34;&gt;Controller Example&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s walk through a simple Hello World example that illustrates how the Model-View-Controller pattern is used in our code. We&amp;rsquo;ll start with the controller code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package ESF::Control::Hello;
    use strict;
    use ESF::Control;
    @ESF::Control::Hello::ISA = qw(ESF::Control);
    use ESF::Util;
    sub handler {
        ### do some setup work
        my $class = shift;
        my $apr = ESF::Util-&amp;gt;get_request();

        ### instantiate the model
        my $name = $apr-&amp;gt;param(&#39;name&#39;);

        # we create a new Model::Hello object.
        my $hello = ESF::Model::Hello-E&amp;lt;gt&amp;gt;new(NAME =E&amp;lt;gt&amp;gt; $name);

        ### send out the view
        my $view_data{&#39;hello&#39;} = $hello-&amp;gt;view();

        # the process_template() method is inherited
        # from the ESF::Control base class
        $class-&amp;gt;process_template(
                TEMPLATE =&amp;gt; &#39;hello.html&#39;,
                DATA     =&amp;gt; \%view_data);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In addition to the things you see here, there are a few interesting details about the &lt;code&gt;ESF::Control&lt;/code&gt; base class. All requests are dispatched to the &lt;code&gt;ESF::Control-&amp;gt;run()&lt;/code&gt; method first, wrapping them in a &lt;code&gt;try{}&lt;/code&gt; block before calling the appropriate &lt;code&gt;handler()&lt;/code&gt; method. It also provides the &lt;code&gt;process_template()&lt;/code&gt; method, which runs &lt;code&gt;Template Toolkit&lt;/code&gt; and then sends the results with appropriate HTTP headers. If the Controller specifies it, then the headers can include &lt;code&gt;Last-Modified&lt;/code&gt; and &lt;code&gt;Expires&lt;/code&gt; for control of page caching by the proxy servers.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s look at the corresponding Model code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package ESF::Model::Hello;
    use strict;
    sub new {
        my $class = shift;
        my %args = @_;
        my $self = bless {}, $class;
        $self{&#39;name&#39;} = $args{&#39;NAME&#39;} || &#39;World&#39;;
        return $self;
    }

    sub view {
        # the object itself will work for the view
        return shift;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a simple Model object. Most Model objects would have some database and cache interaction. They would include a &lt;code&gt;load()&lt;/code&gt; method that accepts an ID and loads the appropriate object state from the database. Model objects that can be modified by the application would also include a &lt;code&gt;save()&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;Note that because of Perl&amp;rsquo;s flexible OO style, it is not necessary to call &lt;code&gt;new()&lt;/code&gt; when loading an object from the database. The &lt;code&gt;load()&lt;/code&gt; and &lt;code&gt;new()&lt;/code&gt; methods can both be constructors for use in different circumstances, both returning a blessed reference.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;load()&lt;/code&gt; method typically handles cache management as well as database access. Here&amp;rsquo;s some pseudo-code showing a typical &lt;code&gt;load()&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub load {
        my $class = shift;
        my %args = @_;
        my $id = $args{&#39;ID&#39;};
        $self = _fetch_from_cache($id) ||
                _fetch_from_database($id);
        return $self;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The save method would use the same approach in reverse, saving first to the cache and then to the database.&lt;/p&gt;

&lt;p&gt;One final thing to notice about our Model class is the &lt;code&gt;view()&lt;/code&gt; method. This method exists to give the object an opportunity to shuffle it&amp;rsquo;s data around or create a separate data structure that is easier for use with a template. This can be used to hide a complex implementation from the template coders. For example, remember the partitioning of the product inventory data that we did to allow for separate cache expiration times? The product Model object is really a façade for several underlying implementation objects, but the &lt;code&gt;view()&lt;/code&gt; method on that class consolidates the data for use by the templates.&lt;/p&gt;

&lt;p&gt;To finish our Hello World example, we need a template to render the view. This one will do the job:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;HTML&amp;gt;
    &amp;lt;TITLE&amp;gt;Hello, My Oyster&amp;lt;/TITLE&amp;gt;
    &amp;lt;BODY&amp;gt;
        [% PROCESS header.html %]
        Hello [% hello.name %]!
        [% PROCESS footer.html %]
    &amp;lt;/BODY&amp;gt;
    &amp;lt;/HTML&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-performance-tuning-performance-tuning-span&#34;&gt;&lt;span id=&#34;performance tuning&#34;&gt;Performance Tuning&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Since Perl code executes so quickly under &lt;code&gt;mod_perl&lt;/code&gt;, the performance bottleneck is usually at the database. We applied all the documented tricks for improving &lt;code&gt;DBD::Oracle&lt;/code&gt; performance. We used bind variables, &lt;code&gt;prepare_cached()&lt;/code&gt;, &lt;code&gt;Apache::DBI&lt;/code&gt;, and adjustments to the &lt;code&gt;RowCache&lt;/code&gt; buffer size.&lt;/p&gt;

&lt;p&gt;The big win of course is avoiding going to the database in the first place. The caching work we did had a huge impact on performance. Fetching product data from the &lt;em&gt;Berkeley DB&lt;/em&gt; cache was about 10 times faster than fetching it from the database. Serving a product page from the proxy cache was about 10 times faster than generating it on the application server from cached data. Clearly, the site would never have survived under heavy load without the caching.&lt;/p&gt;

&lt;p&gt;Partitioning the data objects was also a big win. We identified several different subsets of product data that could be loaded and cached independently. When an application needed product data, it could specify which subset was required and skip loading the unnecessary data from the database.&lt;/p&gt;

&lt;p&gt;Another standard performance technique we followed was avoiding unnecessary object creation. The &lt;code&gt;Template&lt;/code&gt; object is created the first time it&amp;rsquo;s used and then cached for the life of the Apache process. Socket connections to search servers are cached in a way similar to what &lt;code&gt;Apache::DBI&lt;/code&gt; does for database connections. Resources that are used frequently within the scope of a request, such as database handles and session objects, were cached in &lt;code&gt;mod_perl&lt;/code&gt;&amp;rsquo;s &lt;code&gt;$r-&amp;gt;pnotes()&lt;/code&gt; until the end of the request.&lt;/p&gt;

&lt;h3 id=&#34;span-id-trap-nested-exceptions-trap-nested-exceptions-span&#34;&gt;&lt;span id=&#34;trap: nested exceptions&#34;&gt;Trap: Nested Exceptions&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;When trying out a new technology like the &lt;code&gt;Error&lt;/code&gt; module, there are bound to be some things to watch out for. We found a certain code structure that causes a memory leak every time it is executed. It involves nested &lt;code&gt;try{}&lt;/code&gt; blocks, and looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $foo;
    try {
        # some stuff...
        try {
            $foo++;
            # more stuff...
        } catch Error with {
            # handle error
        };

    } catch Error with {
        # handle other error
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s not Graham Barr&amp;rsquo;s fault that this leaks; it is simply a byproduct of the fact that the &lt;code&gt;try&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt; keywords are implemented using anonymous subroutines. This code is equivalent to the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $foo;
    $subref1 = sub {
        $subref2 = sub {
            $foo++;
        };
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This nested subroutine creates a closure for &lt;code&gt;$foo&lt;/code&gt; and will make a new copy of the variable each time it is executed. The situation is easy to avoid once you know to watch out for it.&lt;/p&gt;

&lt;h4 id=&#34;span-id-berkeley-db-berkeley-db-span&#34;&gt;&lt;span id=&#34;berkeley db&#34;&gt;Berkeley DB&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;One of the big wins in our architecture was the use of &lt;code&gt;Berkeley DB&lt;/code&gt;. Since most people are not familiar with it&amp;rsquo;s more advanced features, we&amp;rsquo;ll give a brief overview here.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;DB_File&lt;/code&gt; module is part of the standard Perl distribution. However, it only supports the interface of &lt;em&gt;Berkeley DB&lt;/em&gt; version 1.85, and doesn&amp;rsquo;t include the interesting features of later releases. To get those, you&amp;rsquo;ll need the &lt;code&gt;BerkeleyDB.pm&lt;/code&gt; module, available from CPAN. This module can be tricky to build, but comprehensive instructions are included.&lt;/p&gt;

&lt;p&gt;Newer versions of &lt;em&gt;Berkeley DB&lt;/em&gt; offer many features that help performance in a &lt;code&gt;mod_perl&lt;/code&gt; environment. To begin with, database files can be opened once at the start of the program and kept open, rather than opened and closed on each request. &lt;em&gt;Berkeley DB&lt;/em&gt; will use a shared memory buffer to improve data access speed for all processes using the database. Concurrent access is directly supported with locking handled for you by the database. This is a huge win over &lt;code&gt;DB_File&lt;/code&gt;, which requires you to do your own locking. Locks can be at a database level, or at a memory page level to allow multiple simultaneous writers. Transactions with rollback capability are also supported.&lt;/p&gt;

&lt;p&gt;This all sounds too good to be true, but there are some downsides. The documentation is somewhat sparse, and you will probably need to refer to the C API if you need to understand how to do anything complicated.&lt;/p&gt;

&lt;p&gt;A more serious problem is database corruption. When an Apache process using &lt;em&gt;Berkeley DB&lt;/em&gt; dies from a hard kill or a segfault, it can corrupt the database. A corrupted database will sometimes cause subsequent opening attempts to hang. According to the people we talked to at Sleepycat Software (which provides commercial support for &lt;em&gt;Berkeley DB&lt;/em&gt;), this can happen even with the transactional mode of operation. They are working on a way to fix the problem. In our case, none of the data stored in the cache was essential for operation so we were able to simply clear it out when restarting an application server.&lt;/p&gt;

&lt;p&gt;Another thing to watch out for is deadlocks. If you use the page-level locking option, then you have to handle deadlocks. There is a daemon included in the distribution that will watch for deadlocks and fix them, or you can handle them yourself using the C API.&lt;/p&gt;

&lt;p&gt;After trying a few different things, we recommend that you use database-level locking. It&amp;rsquo;s much simpler, and cured our problems. We didn&amp;rsquo;t see any significant performance hit from switching to this mode of locking. The one thing you need to watch out for when using exclusive database level write locks are long operations with cursors that tie up the database. We split up some of our operations into multiple writes in order to avoid this problem.&lt;/p&gt;

&lt;p&gt;If you have a good C coder on your team, you may want to try the alternate approach that we finally ended up with. You can write your own daemon around &lt;em&gt;Berkeley DB&lt;/em&gt; and use it in a client/server style over Unix sockets. This allows you to catch signals and ensure a safe shutdown. You can also write your own deadlock handling code this way.&lt;/p&gt;

&lt;h3 id=&#34;span-id-valuable-tools-valuable-tools-span&#34;&gt;&lt;span id=&#34;valuable tools&#34;&gt;Valuable Tools&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;If you plan to do any serious Perl development, then you should really take the time to become familiar with some of the available development tools. The debugger in particular is a lifesaver, and it works with &lt;code&gt;mod_perl&lt;/code&gt;. There is a profiler called &lt;code&gt;Devel::DProf&lt;/code&gt;, which also works with &lt;code&gt;mod_perl&lt;/code&gt;. It&amp;rsquo;s definitely the place to start when performance tuning your application.&lt;/p&gt;

&lt;p&gt;We found the ability to run our complete system on individual&amp;rsquo;s workstations to be extremely useful. Everyone could develop on his own machine, and coordinate changes using &lt;em&gt;CVS&lt;/em&gt; source control.&lt;/p&gt;

&lt;p&gt;For object modeling and design, we used the open-source &lt;code&gt;Dia&lt;/code&gt; program and &lt;em&gt;Rational Rose&lt;/em&gt;. Both support working with UML and are great for generating pretty class diagrams for your cubicle walls.&lt;/p&gt;

&lt;p&gt;Do Try This at Home&lt;/p&gt;

&lt;p&gt;Since we started this project, a number of development frameworks that offer support for this kind of architecture have come out. We don&amp;rsquo;t have direct experience using these, but they have a similar design and may prove useful to you if you want to take an MVC approach with your system.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Apache::PageKit&lt;/em&gt; is a &lt;code&gt;mod_perl&lt;/code&gt; module available from CPAN that provides a basic MVC structure for Web applications. It uses the &lt;em&gt;HTML::Template&lt;/em&gt; module for building views.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;OpenInteract&lt;/em&gt; is a recently released Web application framework in Perl, which works together with the persistence layer &lt;em&gt;SPOPS&lt;/em&gt;. Both are available from CPAN.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;Application Toolkit&lt;/em&gt; from Extropia is a comprehensive set of Perl classes for building Web apps. It has excellent documentation and takes good advantage of existing CPAN modules. You can find it on &lt;a href=&#34;http://www.extropia.com/&#34;&gt;http://www.extropia.com/&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you want a ready-to-use cache module, take a look at the Perl-cache project on &lt;a href=&#34;http://sourceforge.net/&#34;&gt;http://sourceforge.net/&lt;/a&gt;. This is the next generation of the popular &lt;code&gt;File::Cache&lt;/code&gt; module.&lt;/p&gt;

&lt;p&gt;The Java world has many options as well. The &lt;em&gt;Struts&lt;/em&gt; framework, part of the &lt;em&gt;Jakarta&lt;/em&gt; project, is a good open-source choice. There are also commercial products from several vendors that follow this sort of design. Top contenders include &lt;em&gt;ATG Dynamo&lt;/em&gt;, &lt;em&gt;BEA WebLogic&lt;/em&gt;, and &lt;em&gt;IBM WebSphere&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-an-open-source-success-story-an-open-source-success-story-span&#34;&gt;&lt;span id=&#34;an open source success story&#34;&gt;An Open-Source Success Story&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;By building on the open-source software and community, we were able to create a top-tier Web site with a minimum of cost and effort. The system we ended up with is scalable to huge amounts of traffic. It runs on mostly commodity hardware making it easy to grow when the need arises. Perhaps best of all, it provided tremendous learning opportunities for our developers, and made us a part of the larger development community.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ve contributed patches from our work back to various open-source projects, and provided help on mailing lists. We&amp;rsquo;d like to take this opportunity to officially thank the open-source developers who contributed to projects mentioned here. Without them, this would not have been possible. We also have to thank the hardworking Web developers at eToys. The store may be closed, but the talent that built it lives on.&lt;/p&gt;

&lt;p&gt;If you have questions about this material, you can contact us at the following e-mail addresses:&lt;/p&gt;

&lt;p&gt;Bill Hilf - &lt;a href=&#34;mailto:bill@hilfworks.com&#34;&gt;bill@hilfworks.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Perrin Harkins - &lt;a href=&#34;mailto:perrin@elem.com&#34;&gt;perrin@elem.com&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Choosing a Templating System</title>
      <link>http://localhost:1313/pub/2001/08/21/templating.html/</link>
      <pubDate>Tue, 21 Aug 2001 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2001/08/21/templating.html/</guid>
      <description>

&lt;h2 id=&#34;span-id-introduction-introduction-span&#34;&gt;&lt;span id=&#34;introduction&#34;&gt;Introduction&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;Go on, admit it: You&amp;rsquo;ve written a templating system. It&amp;rsquo;s OK, nearly everyone has at some point. You start with something beautifully simple like &lt;code&gt;$HTML =~ s/\$(\w+)/${$1}/g&lt;/code&gt; and end up adding conditionals, loops and includes until you&amp;rsquo;ve created your own unmaintainable monster.&lt;/p&gt;

&lt;p&gt;Luckily for you, you are not the first to think it might be nice to get the HTML out of your code. Many have come before, and more than a few have put their contributions up on CPAN. At this time, there are so many templating modules on CPAN that it&amp;rsquo;s almost certain you can find one that meets your needs. This document aims to be your guide to those modules, leading you down the path to the templating system of your dreams.&lt;/p&gt;

&lt;p&gt;And, if you just went straight to CPAN in the first place and never bothered to write your own, congratulations: You&amp;rsquo;re one step ahead of the rest of us.&lt;/p&gt;

&lt;h3 id=&#34;span-id-on-a-personal-note-on-a-personal-note-span&#34;&gt;&lt;span id=&#34;on a personal note&#34;&gt;On a Personal Note&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Nothing can start an argument faster on the mod_perl mailing list than a claim that one approach to templating is better than another. People get attached to the tools they&amp;rsquo;ve chosen. Therefore, let me say up front that I am biased. I&amp;rsquo;ve been at this for a while and I have opinions about what works best. I&amp;rsquo;ve tried to present a balanced appraisal of the features of various systems in this document, but it probably won&amp;rsquo;t take you long to figure out what I like. Besides, attempts to be completely unbiased lead to useless documents that don&amp;rsquo;t contain any real information. So take it all with a pound of salt and if you think I&amp;rsquo;ve been unfair to a particular tool through a factual error or omission, let me know.&lt;/p&gt;

&lt;h2 id=&#34;span-id-why-use-templates-why-use-templates-span&#34;&gt;&lt;span id=&#34;why use templates&#34;&gt;Why Use Templates?&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;Why bother using templates at all? Print statements and CGI.pm were good enough for grandpa, so why should you bother learning a new way to do things?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;consistency of appearance&#34;&gt;Consistency of Appearance&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;It doesn&amp;rsquo;t take a genius to see that making one navigation bar template and using it in all of your pages is easier to manage than hard-coding it everywhere. If you build your whole site like this, it&amp;rsquo;s much easier to make site-wide changes in the look and feel.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;reusability&#34;&gt;Reusability&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Along the same lines, building a set of commonly used components makes it easier to create new pages.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;better isolation from changes&#34;&gt;Better Isolation From Changes&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Which one changes more often: the logic of your application or the HTML used to display it? Actually the answer doesn&amp;rsquo;t matter, as long as it&amp;rsquo;s one of them. Templates can be a great abstraction layer between the application logic and the display logic, allowing one to be updated without touching the other.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;division of labor&#34;&gt;Division of Labor&lt;/span&gt;&lt;/strong&gt;
Separating your Perl code from your HTML means that when your marketing department decides everything should be green instead of blue, you don&amp;rsquo;t have to lift a finger. Just send them to the HTML coder down the hall. It&amp;rsquo;s a beautiful thing, getting out of the HTML business.&lt;/p&gt;

&lt;p&gt;Even if the same people in your organization write the Perl code and the HTML, you at last have the opportunity for more people to be working on the project in parallel.&lt;/p&gt;

&lt;h2 id=&#34;span-id-what-are-the-differences-what-are-the-differences-span&#34;&gt;&lt;span id=&#34;what are the differences&#34;&gt;What Are the Differences?&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;Before we look at the available options, let&amp;rsquo;s go through an explanation of some of the things that make them different.&lt;/p&gt;

&lt;h3 id=&#34;span-id-execution-models-execution-models-span&#34;&gt;&lt;span id=&#34;execution models&#34;&gt;Execution Models&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Although some try to be flexible about it, most templating systems expect you to use some variation of the two basic execution models, which I will refer to as ``pipeline&amp;rdquo; and ``callback.&amp;rdquo; In the callback style, you let the template take over and it has the application&amp;rsquo;s control flow coded into it. It uses callbacks to modules or snippets of in-line Perl code to retrieve data for display or perform actions such as user authentication. Some popular examples of systems using this model include Mason, Embperl and Apache::ASP.&lt;/p&gt;

&lt;p&gt;The pipeline style does all the work up front in a standard CGI or mod_perl handler, then decides which template to run and passes some data to it. The template has no control flow logic in it, just presentation logic, e.g. show this graphic if this item is on sale. Popular systems supporting this approach include HTML::Template and Template Toolkit.&lt;/p&gt;

&lt;p&gt;The callback model works well for publishing-oriented sites where the pages are essentially mix and match sets of articles and lists. Ideally, a site can be broken down into visual ``components&amp;rdquo; or pieces of pages that are general enough for an HTML coder to recombine them into entirely new kinds of pages without any help from a programmer.&lt;/p&gt;

&lt;p&gt;The callback model can get a bit hairy when you have to code logic that can result in totally different content being returned. For example, if you have a system that processes some form input and takes the user to different pages depending on the data submitted. In these situations, it&amp;rsquo;s easy to end up coding a spaghetti of includes and redirects, or putting what are really multiple pages in the same file.&lt;/p&gt;

&lt;p&gt;On the other hand, a callback approach can result in fewer files (if the Perl code is in the HTML file), and feels easier and more intuitive to many developers. It&amp;rsquo;s a simple step from static files to static files with a few in-line snippets of code in them. This is part of why PHP is so popular with new developers.&lt;/p&gt;

&lt;p&gt;The pipeline model is more like a traditional model-view-controller design. Working this way can provide additional performance tuning opportunities over an approach where you don&amp;rsquo;t know what data will be needed at the beginning of the request. You can aggregate database queries, make smarter choices about caching, etc. It can also promote a cleaner separation of application logic and presentation. However, this approach takes longer to get started with since it&amp;rsquo;s a bigger conceptual hurdle and always involves at least two files: one for the Perl code and one for the template.&lt;/p&gt;

&lt;p&gt;Keep in mind, many systems offer significant flexibility for customizing their execution models. For example, Mason users could write separate components for application logic and display, letting the logic components choose which display component to run after fetching their data. This allows it to be used in a pipeline style. A Template Toolkit application could be written to use a simple generic handler (like the Apache::Template module included in the distribution) with all the application logic placed in the template using object calls or in-line Perl. This would be using it in a callback style.&lt;/p&gt;

&lt;p&gt;HTML::Template and some of the AxKit XML processors are fairly rigid about insisting on a pipeline approach. Neither provide methods for calling back into Perl code during the HTML formatting stage; you have to do the work before running the template. The authors of these tools consider this a feature since it prevents developers from cheating on the separation of application code and presentation.&lt;/p&gt;

&lt;h3 id=&#34;span-id-languages-languages-span&#34;&gt;&lt;span id=&#34;languages&#34;&gt;Languages&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Here&amp;rsquo;s the big issue with templating systems. This is the one that always cranks up the flame on Web development mailing lists.&lt;/p&gt;

&lt;p&gt;Some systems use in-line Perl statements. They may provide some extra semantics, like Embperl&amp;rsquo;s operators for specifying whether the code&amp;rsquo;s output should be displayed or Mason&amp;rsquo;s &lt;code&gt;&amp;lt;%init&amp;gt;&lt;/code&gt; sections for specifying when the code gets run, but at the end of the day your templates are written in Perl.&lt;/p&gt;

&lt;p&gt;Other systems provide a specialized mini-language instead of (or in addition to) in-line Perl. These will typically have just enough syntax to handle variable substitution, conditionals and looping. HTML::Template and Template Toolkit are popular systems using this approach. AxKit straddles the fence, providing both a (not-so-) mini-language - XSLT - and an in-line Perl approach - XPathScript.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s how a typical discussion of the merits of these approaches might go:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IN-LINE:&lt;/strong&gt; Mini-languages are stupid. I already know Perl and it&amp;rsquo;s easy enough. Why would you want to use something different?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MINI-LANG:&lt;/strong&gt; Because my HTML coder doesn&amp;rsquo;t know Perl, and this is easier for him.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IN-LINE:&lt;/strong&gt; Maybe he should learn some Perl. He&amp;rsquo;d get paid more.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MINI-LANG:&lt;/strong&gt; Whatever. You just want to use in-line Perl so you can handle change requests by putting little hacks in the template instead of changing your modules. That&amp;rsquo;s sloppy coding.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IN-LINE:&lt;/strong&gt; That&amp;rsquo;s efficient coding. I can knock out data editing screens in half the time it takes you, and then I can go back through, putting all the in-line code into modules and just have the templates call them.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MINI-LANG:&lt;/strong&gt; You could, but you won&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IN-LINE:&lt;/strong&gt; Is it chilly up there in that ivory tower?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MINI-LANG:&lt;/strong&gt; Go write some VBScript, weenie.&lt;/p&gt;

&lt;p&gt;etc.&lt;/p&gt;

&lt;p&gt;Most people pick a side in this war and stay there. If you are one of the few who hasn&amp;rsquo;t decided yet, you should take a moment to think about who will be building and maintaining your templates, what skills those people have and what will allow them to work most efficiently.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an example of a simple chunk of template using first an in-line style (Apache::ASP in this case) and then a mini-language style (Template Toolkit). This code fetches an object and displays some properties of it. The data structures used are identical in both examples. First Apache::ASP:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;% my $product = Product-&amp;gt;load(&#39;sku&#39; =&amp;gt; &#39;bar1234&#39;); %&amp;gt;

  &amp;lt;% if ($product-&amp;gt;isbn) { %&amp;gt;
    It&#39;s a book!
  &amp;lt;% } else { %&amp;gt;
    It&#39;s NOT a book!
  &amp;lt;% } %&amp;gt;

  &amp;lt;% foreach my $item (@{$product-&amp;gt;related}) { %&amp;gt;
    You might also enjoy &amp;lt;% $item-&amp;gt;name %&amp;gt;.
  &amp;lt;% } %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now Template Toolkit:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  [% USE product(sku=bar1234) %]


  [% IF product.isbn %]
    It&#39;s a book!
  [% ELSE %]
    It&#39;s NOT a book!
  [% END %]

  [% FOREACH item = product.related %]
    You might also enjoy [% item.name %].
  [% END %]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is a third approach, based on parsing an HTML document into a DOM tree and then manipulating the contents of the nodes. The only module using this approach is HTML_Tree. The idea is similar to using a mini-language, but it doesn&amp;rsquo;t require any non-standard HTML tags and it doesn&amp;rsquo;t embed any logic about loops or conditionals in the template itself. This is nice because it means your templates are valid HTML documents that can be viewed in a browser and worked with in most standard HTML tools. It also means people working with the templates can put placeholder data in them for testing and it will simply be replaced when the template is used. This preview ability only breaks down when you need an if/else type construct in the template. In that situation, both the ``if&amp;rdquo; and ``else&amp;rdquo; chunks of HTML would show up when previewing.&lt;/p&gt;

&lt;h3 id=&#34;span-id-parsers-and-caching-parsers-and-caching-span&#34;&gt;&lt;span id=&#34;parsers and caching&#34;&gt;Parsers and Caching&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The parsers for these templating systems are implemented in one of three ways: They parse the template every time (``repeated parse&amp;rdquo;), they parse it and cache the resulting parse tree (``cached parse tree&amp;rdquo;), or they parse it, convert it to Perl code and compile it (``compiled&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;Systems that compile templates to Perl take advantage of Perl&amp;rsquo;s powerful run-time code evaluation capabilities. They examine the template, generate a chunk of Perl code from it and &lt;code&gt;eval&lt;/code&gt; the generated code. After that, subsequent requests for the template can be handled by running the compiled bytecode in memory. The complexity of the parsing and code generation steps varies based on the number of bells and whistles the system provides beyond straight in-line Perl statements.&lt;/p&gt;

&lt;p&gt;Compiling to Perl and then to Perl bytecode is slow on the first hit but provides excellent performance once the template has been compiled, since the template becomes a Perl subroutine call. This is the same approach used by systems like JSP (Java ServerPages). It is most effective in environments with a long-running Perl interpreter, like mod_perl.&lt;/p&gt;

&lt;p&gt;HTML::Template, HTML_Tree, and the 2.0 beta release of Embperl all use a cached parse tree approach. They parse templates into their respective internal data structures and then keep the parsed structure for each processed template in memory. This is similar to the compiled Perl approach in terms of performance and memory requirements, but does not actually involve Perl code generation and thus doesn&amp;rsquo;t require an &lt;code&gt;eval&lt;/code&gt; step. Which way is faster: caching the parse tree or compiling? It&amp;rsquo;s hard to objectively measure, but anecdotal evidence seems to support compilation. Template Toolkit used a cached parse tree approach for version 1, but switched to a compilation approach for version 2 after tests showed it to offer a significant speed increase. However, as will be discussed later, either approach is more than fast enough.&lt;/p&gt;

&lt;p&gt;In contrast to this, a repeated parse approach may sound slow. However, it can be pretty fast if the tokens being parsed for are simple enough. Systems using this approach generally use simple tokens, which allows them to use fast and simple parsers.&lt;/p&gt;

&lt;p&gt;Why would you ever use a system with this approach if compilation has better performance? Well, in an environment without a persistent Perl interpreter like vanilla CGI this can actually be faster than a compiled approach since the startup cost is lower. The caching of Perl bytecode done by compilation systems is useless when the Perl interpreter doesn&amp;rsquo;t stick around for more than one request.&lt;/p&gt;

&lt;p&gt;There are other reasons, too. Compiled Perl code takes up a lot of memory. If you have many unique templates, they can add up fast. Imagine how much RAM it would take up if each page that used server-side includes (SSI) had to stay in memory after they had been accessed. (Don&amp;rsquo;t worry, the &lt;code&gt;Apache::SSI&lt;/code&gt; module doesn&amp;rsquo;t use compilation so it doesn&amp;rsquo;t have this problem.)&lt;/p&gt;

&lt;h3 id=&#34;span-id-application-frameworks-vs-just-templates-application-frameworks-vs-just-templates-span&#34;&gt;&lt;span id=&#34;application frameworks vs. just templates&#34;&gt;Application Frameworks vs. Just Templates&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Some of the templating tools try to offer a comprehensive solution to the problems of Web development. Others offer just a templating solution and assume you will fit this together with other modules to build a complete system.&lt;/p&gt;

&lt;p&gt;Some common features offered in the frameworks include:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;url mapping&#34;&gt;URL Mapping&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;All of the frameworks offer a way to map a URL to a template file. In addition to simple mappings similar to the handling of static documents, some offer ways to intercept all requests within a certain directory for pre-processing, or to create an object inheritance scheme out of the directory structure of a site.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;session tracking&#34;&gt;Session Tracking&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Most interactive sites need to use some kind of session tracking to associate application state data with a user. Some tools make this simple by handling all the cookies or URL-munging for you and allowing you simply to read and write from an object or hash that contains the current user&amp;rsquo;s session data. A common approach is to use the Apache::Session module for storage.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;output caching&#34;&gt;Output Caching&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Caching is the key to good performance in many Web systems, and some of these tools provide user-controlled caching of output. This is one of the major features of both Mason and AxKit. AxKit can cache at the page level, while Mason also offers fine-grained caching of components within the page.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;form handling&#34;&gt;Form Handling&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;How will you live without CGI.pm to parse incoming form data? Many of these tools will do it for you, making it available in a convenient data structure. Some also validate form input, and even provide ``sticky&amp;rdquo; form widgets that keep their selected values when re-displayed or set up default values based on data you provide.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;debugging&#34;&gt;Debugging&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Everyone knows how painful it can be to debug a CGI script. Templating systems can make it worse, by screwing up Perl&amp;rsquo;s line numbers with generated code. To help fix the problem they&amp;rsquo;ve created, some offer built-in debugging support, including extra logging, or integration with the Perl debugger.&lt;/p&gt;

&lt;p&gt;If you want to use a system that just does templates but you need some of these other features and don&amp;rsquo;t feel like implementing them yourself, there are some tools on CPAN that provide a framework you can build upon. The libservlet distribution, which provides an interface similar to the Java servlet API, is independent of any particular templating system. Apache::PageKit and CGI::Application are other options in this vein, but both of these are currently tied to HTML::Template. OpenInteract is another framework, this time tied to Template Toolkit. All of these could be adapted for the ``just templates&amp;rdquo; module of your choice with fairly minimal effort.&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-contenders-the-contenders-span&#34;&gt;&lt;span id=&#34;the contenders&#34;&gt;The Contenders&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;OK, now that you know something about what separates these tools from one another, let&amp;rsquo;s take a look at the top choices for Perl templating systems. This is not an exhaustive list: I&amp;rsquo;ve only included systems that are currently maintained, well-documented and have managed to build up a significant user community. In short, I&amp;rsquo;ve left out about dozen less-popular systems. At the end of this section, I&amp;rsquo;ll mention a few systems that aren&amp;rsquo;t as commonly used but may be worth a look.&lt;/p&gt;

&lt;h3 id=&#34;span-id-ssi-ssi-span&#34;&gt;&lt;span id=&#34;ssi&#34;&gt;SSI&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;SSI is the granddaddy of templating systems, and the first one that many people used since it comes as a standard part of most Web servers. With mod_perl installed, mod_include gains some additional power. Specifically, it is able to take a new #perl directive that allows for in-line subroutine calls. It can also efficiently include the output of Apache::Registry scripts by using the Apache::Include module.&lt;/p&gt;

&lt;p&gt;The Apache::SSI module implements the functionality of mod_include entirely in Perl, including the additional #perl directive. The main reasons to use it are to post-process the output of another handler (with Apache::Filter) or to add your own directives. Adding directives is easy through subclassing. You might be tempted to implement a complete template processor in this way, by adding loops and other constructs, but it&amp;rsquo;s probably not worth the trouble with so many other tools out there.&lt;/p&gt;

&lt;p&gt;SSI follows the callback model and is mostly a mini-language, although you can sneak in bits of Perl code as anonymous subs in #perl directives. Because SSI uses a repeated parse implementation, it is safe to use it on large numbers of files without worrying about memory bloat.&lt;/p&gt;

&lt;p&gt;SSI is a great choice for sites with fairly simple templating needs, especially ones that just want to share some standard headers and footers between pages. However, you should consider whether your site will eventually need to grow into something with more flexibility and power before settling on this simple approach.&lt;/p&gt;

&lt;h3 id=&#34;span-id-html-mason-html-mason-span&#34;&gt;&lt;span id=&#34;html::mason&#34;&gt;HTML::Mason&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://www.masonhq.com/&#34;&gt;http://www.masonhq.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Mason has been around for a few years, and has built a loyal following. It was originally created as a Perl clone of some of the most interesting features from Vignette StoryServer, but has since become its own unique animal. It comes from a publishing background, and includes features oriented toward splitting pages into re-useable chunks, or ``components.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Mason uses in-line Perl with a compilation approach, but has a feature to help keep the Perl code out of the HTML coder&amp;rsquo;s way. Components (templates) can include a section of Perl at the end of the file that is wrapped inside a special tag indicating that it should be run first, before the rest of the template. This allows programmers to put all the logic for a component down at the bottom away from the HTML, and then use short in-line Perl snippets in the HTML to insert values, loop through lists, etc.&lt;/p&gt;

&lt;p&gt;Mason is a site development framework, not just a templating tool. It includes a handy caching feature that can be used for capturing the output of components or simply storing data that is expensive to compute. It is currently the only tool that offers this sort of caching as a built-in. It also implements an argument parsing scheme that allows a component to specify the names, types and default values that it expects to be passed, either from another component or from the values passed in the URI query string.&lt;/p&gt;

&lt;p&gt;While the documentation mostly demonstrates a callback execution model, it is possible to use Mason in a pipeline style. This can be accomplished in various ways, including building special components called ``autohandlers,&amp;rdquo; which run before anything else for requests within a certain directory tree. An autohandler could do some processing and set up data for a display template that includes only minimal in-line Perl. There is also support for an object-oriented site approach, applying concepts such as inheritance to the site directory structure. For example, the autohandler component at /store/book/ might inherit a standard layout from the autohandler at /store/, but override the background color and navigation bar. Then /store/music/ can do the same, with a different color. This can be a powerful paradigm for developing large sites. Note that this inheritance is only supported at the level of methods defined in autohandler components. You can&amp;rsquo;t override the component /store/foo.html with another one at /store/book/foo.html.&lt;/p&gt;

&lt;p&gt;Mason&amp;rsquo;s approach to debugging is to create ``debug files&amp;rdquo; that run Mason outside of a Web server environment, providing a fake Web request and activating the debugger. This can be helpful if you&amp;rsquo;re having trouble getting Apache::DB to behave under mod_perl, or using an execution environment that doesn&amp;rsquo;t provide built-in debugger support.&lt;/p&gt;

&lt;p&gt;Another unique feature is the ability to leave the static text parts of a large template on disk, and pull them in with a file seek when needed rather than keeping them in RAM. This exchanges some speed for a significant savings in memory when dealing with templates that are mostly static text.&lt;/p&gt;

&lt;p&gt;There are many other features in this package, including filtering of HTML output and a page previewing utility. Session support is not built-in, but a simple example showing how to integrate with Apache::Session is included. Mason&amp;rsquo;s feature set can be a bit overwhelming for newbies, but the high-quality documentation and helpful user community go a long way.&lt;/p&gt;

&lt;h3 id=&#34;span-id-html-embperl-html-embperl-span&#34;&gt;&lt;span id=&#34;html::embperl&#34;&gt;HTML::Embperl&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://perl.apache.org/embperl/&#34;&gt;http://perl.apache.org/embperl/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Embperl makes its language choice known up front: embedded perl. It is one of the most popular in-line Perl templating tools and has been around longer than most of the others. It has a solid reputation for speed and ease of use.&lt;/p&gt;

&lt;p&gt;It is commonly used in a callback style, with Embperl intercepting URIs and processing the requested file. However, it can optionally be invoked through a subroutine call from another program, allowing it to be used in a pipeline style. Templates are compiled to Perl bytecode and cached.&lt;/p&gt;

&lt;p&gt;Embperl has been around long enough to build an impressive list of features. It has the ability to run code inside a Safe compartment, support for automatically cleaning globals to make mod_perl coding easier, and extensive debugging tools including the ability to e-mail errors to an administrator.&lt;/p&gt;

&lt;p&gt;The main thing that sets Embperl apart from other in-line Perl systems is its tight HTML integration. It can recognize &lt;code&gt;TABLE&lt;/code&gt; tags and automatically iterate over them for the length of an array. It automatically provides sticky form widgets. An array or hash reference placed at the end of a query string in an &lt;code&gt;HREF&lt;/code&gt; or &lt;code&gt;SRC&lt;/code&gt; attribute will be automatically expanded into query string ``name=value&amp;rdquo; format. &lt;code&gt;META HTTP-EQUIV&lt;/code&gt; tags are turned into true HTTP headers.&lt;/p&gt;

&lt;p&gt;Another reason people like Embperl is that it makes some of the common tasks of Web application coding so simple. For example, all form data is always available just by reading the magic variable %fdat. Sessions are supported just as easily, by reading and writing to the magic %udat hash. There is also a hash for storing persistent application state. HTML-escaping is automatic (though it can be toggled on and off).&lt;/p&gt;

&lt;p&gt;Embperl includes something called EmbperlObject, which allows you to apply OO concepts to your site hierarchy in a similar way to the autohandler and inheritance features of Mason, mentioned above. This is a convenient way to code sites with styles that vary by area, and is worth checking out. EmbperlObject includes the ability to do overrides on a file level. This means that you can have a directory like /store/music that overrides specific templates and inherits the rest from a parent directory.&lt;/p&gt;

&lt;p&gt;One drawback of older versions of Embperl was the necessity to use built-in replacements for most of Perl&amp;rsquo;s control structures like ``if&amp;rdquo; and ``foreach&amp;rdquo; when they are being wrapped around non-Perl sections. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  [$ if ($foo) $]
    Looks like a foo!
  [$ else $]
    Nope, it&#39;s a bar.
  [$ endif $]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These may seem out of place in a system based around in-line Perl. As of version 1.2b2, it is possible to use Perl&amp;rsquo;s standard syntax instead:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  [$ if ($foo) { $]
    Looks like a foo!
  [$ } else { $]
    Nope, it&#39;s a bar.
  [$ } $]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At the time of this writing, a new 2.x branch of Embperl is in beta testing. This includes some interesting features such as a more flexible parsing scheme that can be modified to users&amp;rsquo; tastes. It also supports direct use of the Perl debugger on Embperl templates and provides performance improvements.&lt;/p&gt;

&lt;h3 id=&#34;span-id-apache-axkit-apache-axkit-span&#34;&gt;&lt;span id=&#34;apache::axkit&#34;&gt;Apache::AxKit&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://axkit.org/&#34;&gt;http://axkit.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;AxKit is the first mod_perl page generation system to be built from the ground up around XML. Technically, AxKit is not a templating tool but rather a framework for stringing together different modules that generate and transform XML data. In fact, it can optionally use Template Toolkit as an XML transformation language. However, it deserves coverage here since it is also the home of some templating tools that are not represented elsewhere.&lt;/p&gt;

&lt;p&gt;In its simplest form, AxKit maps XML files to XSL stylesheets that it can process using commonly available XSLT modules like XML::XSLT or XML::Sablotron. The rules for mapping a stylesheet to a request are flexible, and they can incorporate query strings, cookies and other attributes of the request. The idea is that you can use this feature to handle a wide variety of clients with differing display capabilities by choosing the right stylesheet.&lt;/p&gt;

&lt;p&gt;Recognizing that not everyone is a fan of XSL&amp;rsquo;s somewhat obtuse syntax, Matt Sergeant has provided an alternate stylesheet language called XPathScript. XPathScript allows you to write a stylesheet using text with embedded Perl code. This is similar to the other embedded Perl templating tools, but the focus is on using the built-in XPath functions for querying an XML document and manipulating the retrieved data. XPathScript can also be used in a declarative fashion, specifying the formatting of particular elements in the XML input. For example, this snippet will change all &lt;code&gt;&amp;lt;foo&amp;gt;&lt;/code&gt; tags in an XML document to BAR in the output::&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%
    $t-&amp;gt;{&#39;foo&#39;}{pre}   = &#39;BAR&#39;;
    $t-&amp;gt;{&#39;foo&#39;}{post}    = &#39;&#39;;
    $t-&amp;gt;{&#39;foo&#39;}{showtag} = 0;
  %&amp;gt;
  &amp;lt;%= apply_templates() %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By using XPathScript&amp;rsquo;s include function (which looks just like SSI), you can build libraries of useful transformations that use this technique.&lt;/p&gt;

&lt;p&gt;This is all well and good if you have a bunch of XML files sitting on a disk somewhere, but what about dynamic content? AxKit handles this by allowing you to substitute a different data source for the default file-based one. This can include running some dynamic code on each request to generate the XML data that will be transformed. The distribution includes a module for doing this called XSP. XSP is a language for building an XML DOM using in-line Perl and tag libraries. The tag libraries are specified as stylesheets that can turn XML tags into Perl code. This is demonstrated through the included SQL tag library, which allows you to write an XSP page using XML tags that will connect to a database, execute queries and generate an XML document with the results.&lt;/p&gt;

&lt;p&gt;AxKit has some nice performance boosts built into it. It can cache the full output of a page and serve it as a static file on future requests. It can also compress output to speed up downloads for browsers that understand gzip encoding. These can be done with other systems, but they require you to setup additional software. With AxKit, you just enable them in the configuration file.&lt;/p&gt;

&lt;p&gt;If all of these languages, tag libraries and stylesheets sound intimidating to you, AxKit may be overkill for your project. However, AxKit has the advantage of being built on approved W3C standards, and many of the skills used in developing for it carry over to other languages and tools.&lt;/p&gt;

&lt;h3 id=&#34;span-id-apache-asp-apache-asp-span&#34;&gt;&lt;span id=&#34;apache::asp&#34;&gt;Apache::ASP&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://www.apache-asp.org/&#34;&gt;http://www.apache-asp.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Apache::ASP started as a port of Microsoft&amp;rsquo;s Active Server Pages technology, and its basic design still follows that model. It uses in-line Perl with a compilation approach and provides a set of simple objects for accessing the request information and formulating a response. Scripts written for Microsoft&amp;rsquo;s ASP using Perl (via ActiveState&amp;rsquo;s PerlScript) can usually be run on this system without changes. (Pages written in VBScript are not supported.)&lt;/p&gt;

&lt;p&gt;Like the original ASP, it has hooks for calling specified code when certain events are triggered, such as the start of a new user session. It also provides the same easy-to-use state and session management. Storing and retrieving state data for a whole application or a specific user is as simple as a single method call. It can even support user sessions without cookies &amp;ndash; a unique feature among these systems.&lt;/p&gt;

&lt;p&gt;A significant addition that did not come from Microsoft ASP is the XML and XSLT support. There are two options provided: XMLSubs and XSLT transforms. XMLSubs is a way of adding custom tags to your pages. It maps XML tags to your subroutines, so that you can add something like &lt;code&gt;&amp;lt;site:header page=&amp;quot;Page Title&amp;quot; /&amp;gt;&lt;/code&gt; to your pages and have it translate into a subroutine call like &lt;code&gt;&amp;amp;site::header({title =&amp;gt; &amp;quot;Page Title&amp;quot;})&lt;/code&gt;. It can handle processing XML tags with body text as well.&lt;/p&gt;

&lt;p&gt;The XSLT support allows the output of ASP scripts to be filtered through XSLT for presentation. This allows your ASP scripts to generate XML data and then format that data with a separate XSL stylesheet. This support is provided through integration with the XML::XSLT module.&lt;/p&gt;

&lt;p&gt;Apache::ASP provides sticky widgets for forms through the use of the HTML::FillInForm module. It also has built-in support for removing extra whitespace from generated output, gzip compressing output (for browsers that support it), tracking performance using Time::HiRes, automatically mailing error messages to an administrator and many other conveniences and tuning options. This is a mature package that has evolved to handle real-world problems.&lt;/p&gt;

&lt;p&gt;One thing to note about the session and state management in this system is that it currently only supports clusters through the use of network file systems such as NFS or SMB. (Joshua Chamas, the module&amp;rsquo;s author, has reported much better results from Samba file sharing than from NFS.) This may be an issue for large-scale server clusters, which usually rely on a relational database for network storage of sessions. Support for database storage of sessions is planned in a future release. In the meantime, instructions are provided for hooking up to Apache::Session.&lt;/p&gt;

&lt;h3 id=&#34;span-id-text-template-text-template-span&#34;&gt;&lt;span id=&#34;text::template&#34;&gt;Text::Template&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://metacpan.org/pod/Text::Template&#34;&gt;Text::Template&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This module has become the de facto standard general purpose templating module on CPAN. It has an easy interface and thorough documentation. The examples in the docs show a pipeline execution style, but it&amp;rsquo;s easy to write a mod_perl handler that directly invokes templates, allowing a callback style. The module uses in-line Perl. It has the ability to run the in-line code in a Safe compartment, in case you are concerned about mistakes in the code crashing your server.&lt;/p&gt;

&lt;p&gt;The module relies on creative uses of in-line code to provide things that people usually expect from templating tools, like includes. This can be good or bad. For example, to include a file you could just call Text::Template::fill_in_file(filename). However, you&amp;rsquo;ll have to specify the complete file path and nothing will stop you from using /etc/passwd as the file to be included. Most of the fancier templating tools have concepts like include paths, which allow you to specify a list of directories to search for included files. You could write a subroutine that works this way, and make it available in your template&amp;rsquo;s namespace, but it&amp;rsquo;s not built in.&lt;/p&gt;

&lt;p&gt;Each template is loaded as a separate object. Templates are compiled to Perl and only parsed the first time they are used. However, to take full advantage of this caching in a persistent environment like mod_perl, your program will have to keep track of which templates have been used, since Text::Template does not have a way of globally tracking this and returning cached templates when possible.&lt;/p&gt;

&lt;p&gt;Text::Template is not tied to HTML, and is just a templating module, not a Web application framework. It is perfectly at home generating e-mails, PDFs, etc.&lt;/p&gt;

&lt;h3 id=&#34;span-id-template-toolkit-template-toolkit-span&#34;&gt;&lt;span id=&#34;template toolkit&#34;&gt;Template Toolkit&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://template-toolkit.org/&#34;&gt;http://template-toolkit.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;One of the more recent additions to the templating scene, Template Toolkit, is a flexible mini-language system. It has a complete set of directives for working with data, including loops and conditionals, and it can be extended in a number of ways. In-line Perl code can be enabled with a configuration option, but is generally discouraged. It uses compilation, caching the compiled bytecode in memory and optionally caching the generated Perl code for templates on disk. Although it is commonly used in a pipeline style, the included Apache::Template module allows templates to be invoked directly from URLs.&lt;/p&gt;

&lt;p&gt;Template Toolkit has a large feature set, so we&amp;rsquo;ll only be able cover some of the highlights here. The TT distribution sets a gold standard for documentation thoroughness and quality, so it&amp;rsquo;s easy to learn more if you choose to.&lt;/p&gt;

&lt;p&gt;One major difference between TT and other systems is that it provides simple access to complex data structures through the concept of a dot operator. This allows people who don&amp;rsquo;t know Perl to access nested lists and hashes or call object methods. For example, we could pass in this Perl data structure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $vars = {
           customer =&amp;gt; {
                        name    =&amp;gt; &#39;Bubbles&#39;,
                        address =&amp;gt; {
                                    city =&amp;gt; &#39;Townsville&#39;,
                                   }
                       }
          };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we can refer to the nested data in the template:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Hi there, [% customer.name %]!
  How are things in [% customer.address.city %]?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is simpler and more uniform than the equivalent syntax in Perl. If we pass in an object as part of the data structure, we can use the same notation to call methods within that object. If you&amp;rsquo;ve modeled your system&amp;rsquo;s data as a set of objects, this can be convenient.&lt;/p&gt;

&lt;p&gt;Templates can define macros and include other templates, and parameters can be passed to either. Included templates can optionally localize their variables so that changes made while the included template is executing do not affect the values of variables in the larger scope.&lt;/p&gt;

&lt;p&gt;There is a filter directive, which can be used for post-processing output. Uses for this range from simple HTML entity conversion to automatic truncation (useful for pulldown menus when you want to limit the size of entries) and printing to STDERR.&lt;/p&gt;

&lt;p&gt;TT supports a plugin API, which can be used to add extra capabilities to your templates. The provided plug-ins can be broadly organized into data access and formatting. Standard data access plugins include modules for accessing XML data or a DBI data source and using that data within your template. There&amp;rsquo;s a plugin for access to CGI.pm as well.&lt;/p&gt;

&lt;p&gt;Formatting plug-ins allow you to display things like dates and prices in a localized style. There&amp;rsquo;s also a table plugin for use in displaying lists in a multi-column format. These formatting plug-ins do a good job of covering the final 5 percent of data display problems that often cause people who are using an in-house system to embed a little bit of HTML in their Perl modules.&lt;/p&gt;

&lt;p&gt;In a similar vein, TT includes some nice convenience features for template writers, including eliminating white space around tags and the ability to change the tag delimiters &amp;ndash; things that may sound a little esoteric, but can sometimes make templates significantly easier to use.&lt;/p&gt;

&lt;p&gt;The TT distribution also includes a script called ttree, which allows for processing an entire directory tree of templates. This is useful for sites that pre-publish their templated pages and serve them statically. The script checks modification times and only updates pages that require it, providing a make-like functionality. The distribution also includes a sample set of template-driven HTML widgets that can be used to give a consistent look and feel to a collection of documents.&lt;/p&gt;

&lt;h3 id=&#34;span-id-html-template-html-template-span&#34;&gt;&lt;span id=&#34;html::template&#34;&gt;HTML::Template&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://metacpan.org/pod/HTML::Template&#34;&gt;HTML::Template&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;HTML::Template is a popular module among those looking to use a mini-language rather than in-line Perl. It uses a simple set of tags that allow looping (even on nested data structures) and conditionals in addition to basic value insertion. The tags are intentionally styled to look like HTML tags, which may be useful for some situations.&lt;/p&gt;

&lt;p&gt;As the documentation says, it ``does just one thing and it does quickly and carefully&amp;rdquo; &amp;ndash; there is no attempt to add application features like form-handling or session tracking. The module follows a pipeline execution style. Parsed templates are stored in a Perl data structure that can be cached in any combination of memory, shared memory (using IPC::SharedCache) and disk. The documentation is complete and well-written, with plenty of examples.&lt;/p&gt;

&lt;p&gt;You may be wondering how this module is different from Template Toolkit, the other popular mini-language system. Beyond the obvious differences in syntax, HTML::Template is faster and simpler, while Template Toolkit has more advanced features, like plug-ins and dot notation. Here&amp;rsquo;s a simple example comparing the syntax:&lt;/p&gt;

&lt;p&gt;HTML::Template:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;TMPL_LOOP list&amp;gt;
      &amp;lt;a href=&amp;quot;&amp;lt;TMPL_VAR url&amp;gt;&amp;quot;&amp;gt;&amp;lt;b&amp;gt;&amp;lt;TMPL_VAR name&amp;gt;&amp;lt;/b&amp;gt;&amp;lt;/A&amp;gt;
  &amp;lt;/TMPL_LOOP&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Template Toolkit:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  [% FOREACH list %]
      &amp;lt;a href=&amp;quot;[% url %]&amp;quot;&amp;gt;&amp;lt;b&amp;gt;[% name %]&amp;lt;/a&amp;gt;&amp;lt;/a&amp;gt;
  [% END %]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now, a few honorable mentions:&lt;/p&gt;

&lt;h3 id=&#34;span-id-html-tree-html-tree-span&#34;&gt;&lt;span id=&#34;html_tree&#34;&gt;HTML_Tree&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://homepage.mac.com/pauljlucas/software/html_tree/&#34;&gt;http://homepage.mac.com/pauljlucas/software/html_tree/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;As mentioned earlier, HTML Tree uses a fairly unique method of templating: it loads in an HTML page, parses it to a DOM and then programmatically modifies the contents of nodes. This allows it to use genuine valid HTML documents as templates, something that none of these other modules can do. The learning curve is a little steeper than average, but this may be just the thing if you are concerned about keeping things simple for your HTML coders. Note that the name is ``HTML_Tree,&amp;rdquo; not ``HTML::Tree.&amp;rdquo;&lt;/p&gt;

&lt;h3 id=&#34;span-id-apache-xpp-apache-xpp-span&#34;&gt;&lt;span id=&#34;apache::xpp&#34;&gt;Apache::XPP&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://opensource.cnation.com/projects/XPP/&#34;&gt;http://opensource.cnation.com/projects/XPP/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;XPP is an in-line Perl system that compiles to bytecode. Although it is a perfectly good implementation, it has little to differentiate it except for an easy mechanism to define new HTML-like tags that can be used to replace in-line code in templates.&lt;/p&gt;

&lt;h3 id=&#34;span-id-eperl-eperl-span&#34;&gt;&lt;span id=&#34;eperl&#34;&gt;ePerl&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://metacpan.org/pod/Apache::ePerl&#34;&gt;Apache::ePerl&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Possibly the first module to embed Perl code in a text or HTML file, ePerl is still a viable option in the form of Apache::ePerl. It caches compiled bytecode in memory to achieve solid performance, and some people find it refreshingly simple to use.&lt;/p&gt;

&lt;h3 id=&#34;span-id-cgi-fasttemplate-cgi-fasttemplate-span&#34;&gt;&lt;span id=&#34;cgi::fasttemplate&#34;&gt;CGI::FastTemplate&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://metacpan.org/pod/CGI::FastTemplate&#34;&gt;CGI::FastTemplate&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This module takes a minimalistic approach to templating, which makes it unusually well-suited to use in CGI programs. It parses templates with a single regular expression and does not support anything in templates beyond simple variable interpolation. Loops are handled by including the output of other templates. Unfortunately, this leads to a Perl coding style that is more confusing than most, and a proliferation of template files. However, some people swear by this dirt-simple approach.&lt;/p&gt;

&lt;h2 id=&#34;span-id-performance-performance-span&#34;&gt;&lt;span id=&#34;performance&#34;&gt;Performance&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;People always seem to worry about the performance of templating systems. If you&amp;rsquo;ve ever built a large-scale application, you should have enough perspective on the relative costs of different actions to know that your templating system is not the first place to look for performance gains. All of the systems mentioned here have excellent performance characteristics in persistent execution environments like mod_perl. Compared to such glacially slow operations as fetching data from a database or file, the time added by the templating system is almost negligible.&lt;/p&gt;

&lt;p&gt;If you think your templating system is slowing you down, get the facts: pull out Devel::DProf and see. If one of the tools mentioned here is at the top of the list for wall clock time used, you should pat yourself on the back &amp;ndash; you&amp;rsquo;ve done a great job tuning your system and removing bottlenecks! Personally, I have only seen this happen when I had managed to successfully cache nearly every part of the work to handle a request except running a template.&lt;/p&gt;

&lt;p&gt;However, if you really are in a situation where you need to squeeze a few extra microseconds out of your page generation time, there are performance differences between systems. They&amp;rsquo;re pretty much what you would expect: systems that do the least run the fastest. Using in-line &lt;code&gt;print()&lt;/code&gt; statements is faster than using templates. Using simple substitution is faster than using in-line Perl code. Using in-line Perl code is faster than using a mini-language.&lt;/p&gt;

&lt;p&gt;The only templating benchmark available at this time is one developed by Joshua Chamas, author of Apache::ASP. It includes a ``hello world&amp;rdquo; test, which simply checks how fast each system can spit back those famous words, and a ``hello 2000&amp;rdquo; test, which exercises the basic functions used in most dynamic pages. It is available from the following URL:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.chamas.com/bench/hello.tar.gz&#34;&gt;http://www.chamas.com/bench/hello.tar.gz&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Results from this benchmark currently show SSI, Apache::ASP and HTML::Embperl having the best performance. Not all of the systems mentioned here are currently included in the test. If your favorite was missed, you might want to download the benchmark code and add it. As you can imagine, benchmarking people&amp;rsquo;s pet projects is largely a thankless task and Joshua deserves some recognition and support for this contribution to the community.&lt;/p&gt;

&lt;h3 id=&#34;span-id-cgi-performance-concerns-cgi-performance-concerns-span&#34;&gt;&lt;span id=&#34;cgi performance concerns&#34;&gt;CGI Performance Concerns&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;If you&amp;rsquo;re running under CGI, you have bigger fish to fry than worrying about the performance of your templating system. Nevertheless, some people are stuck with CGI but still want to use a templating system with reasonable performance. CGI is a tricky situation, since you have to worry about how much time it will take for Perl to compile the code for a large templating system on each request. CGI also breaks the in-memory caching of templates used by most of these systems, although the slower disk-based caching provided by Mason, HTML::Template and Template Toolkit will still work. (HTML::Template does provide a shared memory cache for templates, which may improve performance, although shared memory on my Linux system is usually slower than using the filesystem. Benchmarks and additional information are welcome.)&lt;/p&gt;

&lt;p&gt;Your best performance bet with CGI is to use one of the simpler tools, like CGI::FastTemplate or Text::Template. They are small and compile quickly, and CGI::FastTemplate gets an extra boost since it relies on simple regex parsing and doesn&amp;rsquo;t need to eval any in-line Perl code. Almost everything else mentioned here will add tenths of seconds to each page in compilation time alone.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;span-id-matrix-matrix-span&#34;&gt;&lt;span id=&#34;matrix&#34;&gt;Matrix&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;To help you choose a system, I&amp;rsquo;ll summarize the basic characteristics of the major systems along the decision points I&amp;rsquo;ve explained in the beginning of the article. Keep in mind that in many cases a system can be used in more than one way, and I&amp;rsquo;ve simply shown the dominant method as seen in the documentation and real world use. You should not eliminate options based on this chart without reading the more detailed explanations above.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Application Framework&lt;/th&gt;
&lt;th&gt;Pipeline or Callback&lt;/th&gt;
&lt;th&gt;Parsing Method&lt;/th&gt;
&lt;th&gt;Language&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;HTML::Mason&lt;/td&gt;
&lt;td&gt;Framework&lt;/td&gt;
&lt;td&gt;Callback&lt;/td&gt;
&lt;td&gt;Compiled&lt;/td&gt;
&lt;td&gt;Perl&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Template Toolkit&lt;/td&gt;
&lt;td&gt;Just Templates&lt;/td&gt;
&lt;td&gt;Pipeline&lt;/td&gt;
&lt;td&gt;Compiled&lt;/td&gt;
&lt;td&gt;Mini-Language&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Apache::ASP&lt;/td&gt;
&lt;td&gt;Framework&lt;/td&gt;
&lt;td&gt;Callback&lt;/td&gt;
&lt;td&gt;Compiled&lt;/td&gt;
&lt;td&gt;Perl and XSL&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;HTML::Embperl&lt;/td&gt;
&lt;td&gt;Framework&lt;/td&gt;
&lt;td&gt;Callback&lt;/td&gt;
&lt;td&gt;Compiled&lt;/td&gt;
&lt;td&gt;Perl&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SSI&lt;/td&gt;
&lt;td&gt;Just Templates&lt;/td&gt;
&lt;td&gt;Callback&lt;/td&gt;
&lt;td&gt;Repeated Parse&lt;/td&gt;
&lt;td&gt;Mini-Language&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AxKit&lt;/td&gt;
&lt;td&gt;Framework&lt;/td&gt;
&lt;td&gt;Pipeline&lt;/td&gt;
&lt;td&gt;Compiled or Cached Parse Tree&lt;/td&gt;
&lt;td&gt;Perl and XSL and Mini-Language(s)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;HTML::Template&lt;/td&gt;
&lt;td&gt;Just Templates&lt;/td&gt;
&lt;td&gt;Pipeline&lt;/td&gt;
&lt;td&gt;Cached Parse Tree&lt;/td&gt;
&lt;td&gt;Mini-Language&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Text::Template&lt;/td&gt;
&lt;td&gt;Just Templates&lt;/td&gt;
&lt;td&gt;Pipeline&lt;/td&gt;
&lt;td&gt;Compiled&lt;/td&gt;
&lt;td&gt;Perl&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;span-id-updates-updates-span&#34;&gt;&lt;span id=&#34;updates&#34;&gt;Updates&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;These modules are moving targets, and a document like this is bound to contain some mistakes. Send your corrections to &lt;a href=&#34;mailto:perrin@elem.com.&#34;&gt;perrin@elem.com.&lt;/a&gt; Future versions of this document will be announced on the mod_perl mailing list, and possibly other popular Perl locations.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

