<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Artur Bergman on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/authors/artur-bergman/</link>
    <description>Recent content in Artur Bergman on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 16 Jan 2003 00:00:00 -0800</lastBuildDate>
    <atom:link href="/authors/artur-bergman/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>What&#39;s new in Perl 5.8.0</title>
      <link>http://localhost:1313/pub/2003/01/16/whatsnew.html/</link>
      <pubDate>Thu, 16 Jan 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/01/16/whatsnew.html/</guid>
      <description>

&lt;p&gt;It&amp;rsquo;s been nearly six months since the release of Perl 5.8.0, but many people still haven&amp;rsquo;t upgraded to it. We&amp;rsquo;ll take a look at some of the new features it provides and describe why you should investigate them yourself.&lt;/p&gt;

&lt;h2 id=&#34;span-id-unicode-unicode-span&#34;&gt;&lt;span id=&#34;unicode&#34;&gt;Unicode&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;Perl 5.8 - at last! - properly supports Unicode. Handling Unicode data in Perl should now be much more reliable than in 5.6.0 and 5.6.1. In fact, quoting the most excellent &lt;a href=&#34;https://perldoc.perl.org/perluniintro.html&#34;&gt;perluniintro&lt;/a&gt;, which is suggested reading, &amp;lsquo;5.8 is the first recommended release for serious Unicode work.&amp;rsquo;&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;http://www.unicode.org/ucd/&#34;&gt;Unicode Character Database&lt;/a&gt;, which ships with Perl, has been upgraded to Unicode 3.2.0, 5.6.1 had 3.0.1. Most UCD files are included with some omissions for space considerations.&lt;/p&gt;

&lt;p&gt;Perl&amp;rsquo;s Unicode model is straightforward: Strings can be eight-bit native bytes or strings of Unicode characters. The principle is that Perl tries to keep its data as eight-bit bytes for as long as possible. When Unicodeness cannot be avoided, the data is transparently upgraded to Unicode. Native eight-bit bytes are whatever the platform users (for example Latin-1), Unicode is typically stored as UTF-8.&lt;/p&gt;

&lt;p&gt;Perl will do the right thing with regard to mixing Unicode and non-Unicode strings; all functions and operators will respect the UTF-8 flag. For example, it is now possible to use Unicode strings in hashes, and correctly use them in regular expressions and transliterations. This has fully changed from 5.6 where you controlled Unicode support with a lexically scoped &lt;a href=&#34;https://perldoc.perl.org/utf8.html&#34;&gt;utf8&lt;/a&gt; pragma.&lt;/p&gt;

&lt;p&gt;To fully use Unicode in Perl, we must now compile Perl with &lt;code&gt;perlio&lt;/code&gt; &amp;ndash; the new IO system written by Nick Ing-Simmons that we will cover later &amp;ndash; together with the new &lt;a href=&#34;https://metacpan.org/pod/Encode&#34;&gt;Encode module&lt;/a&gt; written by Dan Kogai. Together, these allow individual filehandles to be set to bytes, Unicode or legacy encodings. Encode also comes with &lt;code&gt;piconv&lt;/code&gt;, which is a Perl implementation of iconv and &lt;code&gt;enc2xs&lt;/code&gt;, which allows you to create your own encodings to Encode, either from Unicode Character Mapping files or from Tcl Encoding Files. From Sadahiro Tomoyuki comes &lt;a href=&#34;https://metacpan.org/pod/Unicode::Normalize&#34;&gt;Unicode::Normalize&lt;/a&gt; and &lt;a href=&#34;https://metacpan.org/pod/Unicode::Collate&#34;&gt;Unicode::Collate&lt;/a&gt;, surprisingly used for normalization and collating.&lt;/p&gt;

&lt;h2 id=&#34;perl-threads&#34;&gt;Perl Threads&lt;/h2&gt;

&lt;p&gt;Just like 5.8 is the first recommended release for Unicode work, it is also the first recommended release for threading work. Starting with 5.6, Perl had two modes of threading: one style called &lt;code&gt;5005threading&lt;/code&gt;, mainly because it was introduced with 5.005, and ithreads, which is short for interpreter threads. Gurusamy Sarathy introduced ithreads as a step forward from multiplicity to support the psuedofork implementation on Win32. However, in 5.6, there was no way to control these threads from Perl; this has now changed with the introduction of two new modules in 5.8.&lt;/p&gt;

&lt;p&gt;The basic rule for this thread model is that all data is cloned when a new thread is created, so no data is shared between threads. If one wants to share data, then there is a &lt;a href=&#34;https://metacpan.org/pod/threads::shared&#34;&gt;threads::shared module&lt;/a&gt; and the new &lt;code&gt;: shared&lt;/code&gt;; variable attribute. Controlling the new threads is done by using the &lt;a href=&#34;https://metacpan.org/pod/threads::shared&#34;&gt;threads&lt;/a&gt; module. More reading can be found in the respective modules and &lt;a href=&#34;https://perldoc.perl.org/perlthrtut.html&#34;&gt;the Perl Thread Tutorial page&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;h2 id=&#34;new-io&#34;&gt;New IO&lt;/h2&gt;

&lt;p&gt;Perl can now rely on its own bugs instead of the bugs of your underlying IO implementation! In Perl 5.8, we are now using the PerlIO library, which replaces both stdio and sfio. The new IO system allows filters to be pushed/popped from a filehandle for doing all kinds of nifty things. For example, the Encode module, as mentioned earlier in the Unicode discussion, uses PerlIO to do the magic character set conversions at the IO level.&lt;/p&gt;

&lt;p&gt;Interested parties that want to create their own layers should look at &lt;a href=&#34;https://perldoc.perl.org/perlapio.html&#34;&gt;the library API&lt;/a&gt;, &lt;a href=&#34;https://perldoc.perl.org/perliol.html&#34;&gt;the IO layer API&lt;/a&gt;, &lt;a href=&#34;https://metacpan.org/pod/PerlIO&#34;&gt;the PerlIO module&lt;/a&gt;, and &lt;a href=&#34;https://metacpan.org/pod/PerlIO::via&#34;&gt;the PerlIO::via manpage&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;safe-signals&#34;&gt;Safe Signals&lt;/h2&gt;

&lt;p&gt;No more random segfaults caused by signals! We now have a signal handler that just raises a flag and then dispatches the signal between opcodes so you are free to do anything you feel like in a signal handler (Since it isn&amp;rsquo;t run at async time, it isn&amp;rsquo;t really a signal handler). This has potential for conflicts if you are embedding Perl and relying on signals to do some particular behavior, but I suppose if you really like having the chance of a random segfault on receiving a signal, then you can always compile perl with PERL_OLD_SIGNALS. This will, however, not be threadsafe.&lt;/p&gt;

&lt;p&gt;New and Improved Modules&lt;/p&gt;

&lt;p&gt;Perl 5.8 comes with 54 new modules, many of them are included of CPAN for various reasons. One goal has been to make it easy for &lt;a href=&#34;https://metacpan.org/pod/CPAN&#34;&gt;CPAN.pm&lt;/a&gt; to be selfhosting; this has meant including libnet and a couple of other modules.&lt;/p&gt;

&lt;p&gt;We have been working on testing a lot so the &lt;a href=&#34;https://metacpan.org/pod/Test::More&#34;&gt;Test::More&lt;/a&gt; family of modules were natural to include. Then there was a push to make Perl more i18n friendly, so 5.8.0 includes several i18n and l10n modules as well as the previously covered Unicode modules. There many modules that provide access to internal functions like the PerlIO modules, threads module and sort, the new module that provides a interface to the sort implementation you are using. Finally, we also thought it was time to include &lt;a href=&#34;https://metacpan.org/pod/Storable&#34;&gt;Storable&lt;/a&gt; in the core.&lt;/p&gt;

&lt;p&gt;We also have a bunch of updated modules included: &lt;a href=&#34;https://metacpan.org/pod/Cwd&#34;&gt;Cwd&lt;/a&gt; is now implemented in XS, giving us a nice speed boost. &lt;a href=&#34;https://metacpan.org/pod/B::Deparse&#34;&gt;B::Deparse&lt;/a&gt; has been improved to the point that it is actually useful. Maintenance work on &lt;a href=&#34;https://metacpan.org/pod/ExtUtils::MakeMaker&#34;&gt; ExtUtils::MakeMaker&lt;/a&gt; has made it more stable. Storable supports Unicode hash keys and restricted hashes. &lt;a href=&#34;https://metacpan.org/pod/Math::BigInt&#34;&gt;Math::BigInt&lt;/a&gt; and &lt;a href=&#34;https://metacpan.org/pod/Math::BigFloat&#34;&gt;Math::BigFloat&lt;/a&gt; have been upgraded and bugfixed quite a lot, and they have been complemented by a &lt;a href=&#34;https://metacpan.org/pod/Math::BigRat&#34;&gt;Math::BigRat&lt;/a&gt; module, and the &lt;a href=&#34;https://metacpan.org/pod/bigrat&#34;&gt;bigrat&lt;/a&gt;, &lt;a href=&#34;https://metacpan.org/pod/bigint&#34;&gt;bigint&lt;/a&gt; and &lt;a href=&#34;https://metacpan.org/pod/bignum&#34;&gt;bignum&lt;/a&gt; pragmata for lexical control of transparent bignumber support.&lt;/p&gt;

&lt;h2 id=&#34;speed-improvements&#34;&gt;Speed Improvements&lt;/h2&gt;

&lt;p&gt;Even if this release includes a lot of new features, there are some optimizations in there as well! We have changed sort to use mergesort, which for me is rather surprising since I have been told since I was a toddler to use quicksort. However, the old behavior can be controlled using the &lt;a href=&#34;https://perldoc.perl.org/functions/sort.html&#34;&gt;sort&lt;/a&gt; module; we even have a mystery stable quicksort!&lt;/p&gt;

&lt;p&gt;Once again, we have changed the hashing algorithm to something called One-At-A-Time, so all of you who depend on the order of hashes, this is a good reason to fix your programs now!&lt;/p&gt;

&lt;p&gt;Finally, &lt;code&gt;map&lt;/code&gt; has been made faster, as has &lt;code&gt;unshift&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;testing&#34;&gt;Testing&lt;/h2&gt;

&lt;p&gt;We hope this should be the most stable release of Perl to date, as an extensive QA effort has been spearheaded by Michael Schwern that has led to several benefits. We now have six times the amount of test cases, testing a cleaner codebase with more documentation. The Perl Bug database has been switched to &lt;a href=&#34;https://bestpractical.com/&#34;&gt;Request Tracker&lt;/a&gt;; we should thank Richard Foley for his work on perlbugtron, which has now been retired. After several discussions on what a memory leak is, several memory leaks and naughty accesses have been fixed. Tools used have been third degree, purify, and the most excellent open-source alternative, &lt;a href=&#34;https://developer.kde.org/~sewardj/&#34;&gt;valgrind&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;more-numbers&#34;&gt;More Numbers&lt;/h2&gt;

&lt;p&gt;Nicholas Clark, Hugo van der Sanden and Tels have done some magic keeping integers as integers as long as possible, and when finding bugs in vendors number-to-string and string-to-number they have coded around these to increased precision. We should all be happy that 42 is now 42 and not 42.000000000000001 - imagine what the aliens would do if they found out!&lt;/p&gt;

&lt;h2 id=&#34;documentation&#34;&gt;Documentation&lt;/h2&gt;

&lt;p&gt;I have mentioned several documentations pages earlier, they are part of the 13 new POD files included in Perl; in addition to this, all README.os files have been translated into pod. Interestingly, there are several new tutorials, including &lt;a href=&#34;https://perldoc.perl.org/perlretut.html&#34;&gt;a regular expressions tutorial&lt;/a&gt;, &lt;a href=&#34;https://perldoc.perl.org/perlpacktut.html&#34;&gt;a tutorial on pack and unpack&lt;/a&gt;, &lt;a href=&#34;https://perldoc.perl.org/perldebtut.html&#34;&gt;a debugging tutorial&lt;/a&gt;, &lt;a href=&#34;https://perldoc.perl.org/perlnewmod.html&#34;&gt;a module creation tutorial&lt;/a&gt;, and &lt;a href=&#34;https://perldoc.perl.org/perlintro.html&#34;&gt;&amp;lsquo;a gentle introduction to perl&amp;rsquo;&lt;/a&gt;. There is also a new &lt;a href=&#34;https://perldoc.perl.org/perlpodspec.html&#34;&gt;POD format specification&lt;/a&gt; written by Sean M. Burke.&lt;/p&gt;

&lt;h2 id=&#34;deprecations&#34;&gt;Deprecations&lt;/h2&gt;

&lt;p&gt;Several deprecations have occurred in this release of Perl. In future versions of Perl, 5005threads will be gone and replaced by ithreads. Pseudo-hashes will be killed but the &lt;a href=&#34;https://metacpan.org/pod/fields&#34;&gt;fields&lt;/a&gt; pragma will work using restricted hashes; suidperl, which, despite everything, isn&amp;rsquo;t safe and the bare &lt;code&gt;package;&lt;/code&gt; directive, which had unclear semantics.&lt;/p&gt;

&lt;p&gt;A few things have been removed and forbidden: blessing a refence into another ref is one; self-tying of arrays and hashes led to some weird bugs and have been disabled, as they touched some rarely tested codepaths. The &lt;code&gt;[[.c.]]&lt;/code&gt; and &lt;code&gt;[[=c=]]&lt;/code&gt; character classes are also forbidden because they might be used for future extensions. Several scripts that were outdated have been removed and the upper case comparison operators have also got the ax.&lt;/p&gt;

&lt;h2 id=&#34;the-war-of-the-platforms&#34;&gt;The War of the Platforms&lt;/h2&gt;

&lt;p&gt;Perl 5.8 works on several new platforms and the EBDIC platforms were regained. However, sadly we lost Amiga; so any volunteers that want to make the Amiga port work again are very welcome.&lt;/p&gt;

&lt;h2 id=&#34;odd-and-ends&#34;&gt;Odd and Ends&lt;/h2&gt;

&lt;p&gt;There is a long list of new small changes in Perl 5.8, the biggest of these small changes are restricted hashes, which can be used from the new &lt;a href=&#34;https://metacpan.org/pod/Hash::Util&#34;&gt;Hash::Util&lt;/a&gt; module and allows you to lock down the keys in a specific hash; this will possibly be used as a replacement for pseudohashes for the &lt;em&gt;fields&lt;/em&gt; pragma.&lt;/p&gt;

&lt;p&gt;For the full and gory details, check out the whole &lt;a href=&#34;https://perldoc.perl.org/perldelta.html&#34;&gt;Perl delta documentation&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Where Wizards Fear To Tread</title>
      <link>http://localhost:1313/pub/2002/06/11/threads.html/</link>
      <pubDate>Tue, 11 Jun 2002 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2002/06/11/threads.html/</guid>
      <description>

&lt;p&gt;One of the big new features in perl 5.8 is that we now have real working threads available to us through the threads pragma.&lt;/p&gt;

&lt;p&gt;However, for us module authors who already have to support our modules on different versions of perl and different platforms, we now have to deal with another case: threads! This article will show you how threads relate to modules, how we can take old modules and make them thread-safe, and round off with a new module that alters perl&amp;rsquo;s behavior of the &amp;ldquo;current working directory&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;To run the examples I have shown here, you need perl 5.8 RC1 or later compiled with threads. On Unix, you can use &lt;code&gt;Configure -Duseithreads -Dusethreads&lt;/code&gt;; On Win32, the default build will always have threading enabled.&lt;/p&gt;

&lt;h3 id=&#34;span-id-how-do-threads-relate-to-modules-how-do-threads-relate-to-modules-span&#34;&gt;&lt;span id=&#34;how_do_threads_relate_to_modules&#34;&gt;How do threads relate to modules?&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Threading in Perl is based on the notion of explicit shared data. That is, only data that is explicitly requested to be shared will be shared between threads. This is controlled by the &lt;code&gt;threads::shared&lt;/code&gt; pragma and the &amp;ldquo;&lt;code&gt;: shared&lt;/code&gt;&amp;rdquo; attribute. Witness how it works:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     use threads;
     my $var = 1;
     threads-&amp;gt;create(sub { $var++ })-&amp;gt;join();
     print $var;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you are accustomed to threading in most other languages, (Java/C) you would expect $var to contain a 2 and the result of this script to be &amp;ldquo;2&amp;rdquo;. However since Perl does not share data between threads, $var is copied in the thread and only incremented in the thread. The original value in the main thread is not changed, so the output is &amp;ldquo;1&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;However if we add in &lt;code&gt;threads::shared&lt;/code&gt; and a &lt;code&gt;: shared&lt;/code&gt; attribute we get the desired result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     use threads;
     use threads::shared;
     my $var : shared = 1;
     threads-&amp;gt;create(sub { $var++ })-&amp;gt;join();
     print $var
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the result will be &amp;ldquo;2&amp;rdquo;, since we declared $var to be a shared variable. Perl will then act on the same variable and provide automatic locking to keep the variable out of trouble.&lt;/p&gt;

&lt;p&gt;This makes it quite a bit simpler for us module developers to make sure our modules are thread-safe. Essentially, all pure Perl modules are thread-safe because any global state data, which is usually what gives you thread-safety problems, is by default local to each thread.&lt;/p&gt;

&lt;h4 id=&#34;span-id-definition-of-threadsafe-levels-definition-of-thread-safe-levels-span&#34;&gt;&lt;span id=&#34;definition_of_threadsafe_levels&#34;&gt;Definition of thread-safe levels&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;To define what we mean by thread-safety, here are some terms adapted from the Solaris thread-safety levels.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_thread%2dsafe&#34;&gt;thread-safe&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This module can safely be used from multiple threads. The effect of calling into a safe module is that the results are valid even when called by multiple threads. However, thread-safe modules can still have global consequences; for example, sending or reading data from a socket affects all threads that are working with that socket. The application has the responsibility to act sane with regards to threads. If one thread creates a file with the name &lt;em&gt;file.tmp&lt;/em&gt; then another file which tries to create it will fail; this is not the fault of the module.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_thread%2dfriendly&#34;&gt;thread-friendly&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Thread-friendly modules are thread-safe modules that know about and provide special functions for working with threads or utilize threads by themselves. A typical example of this is the core &lt;code&gt;threads::queue&lt;/code&gt; module. One could also imagine a thread-friendly module with a cache to declare that cache to be shared between threads to make hits more likely and save memory.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;item_thread%2dunsafe&#34;&gt;thread-unsafe&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This module can not safely be used from different threads; it is up to the application to synchronize access to the library and make sure it works with it the way it is specified. Typical examples here are XS modules that utilize external unsafe libraries that might only allow one thread to execute them.&lt;/p&gt;

&lt;p&gt;Since Perl only shares when asked to, most pure Perl code probably falls into the thread-safe category, that doesn&amp;rsquo;t mean you should trust it until you have review the source code or they have been marked with thread-safe by the author. Typical problems include using alarm(), mucking around with signals, working with relative paths and depending on &lt;code&gt;%ENV&lt;/code&gt;. However remember that ALL XS modules that don&amp;rsquo;t state anything fall into the definitive thread-unsafe category.&lt;/p&gt;

&lt;h3 id=&#34;span-id-why-should-i-bother-making-my-module-threadsafe-or-threadfriendly-why-should-i-bother-making-my-module-thread-safe-or-thread-friendly-span&#34;&gt;&lt;span id=&#34;why_should_i_bother_making_my_module_threadsafe_or_threadfriendly&#34;&gt;Why should I bother making my module thread-safe or thread-friendly?&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Well, it usually isn&amp;rsquo;t much work and it will make the users of this modules that want to use it in a threaded environment very happy. What? Threaded Perl environments aren&amp;rsquo;t that common you say? Wait until Apache 2.0 and mod_perl 2.0 becomes available. One big change is that Apache 2.0 can run in threaded mode and then mod_perl will have to be run in threaded mode; this can be a huge performance gain on some operating systems. So if you want your modules to work with mod_perl 2.0, taking a look at thread-safety levels is a good thing to do.&lt;/p&gt;

&lt;h3 id=&#34;span-id-so-what-do-i-do-to-make-my-module-threadfriendly-so-what-do-i-do-to-make-my-module-thread-friendly-span&#34;&gt;&lt;span id=&#34;so_what_do_i_do_to_make_my_module_threadfriendly&#34;&gt;So what do I do to make my module thread-friendly?&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;A good example of a module that needed a little modification to work with threads is Michael Schwern&amp;rsquo;s most excellent &lt;code&gt;Test::Simple&lt;/code&gt; suite (&lt;code&gt;Test::Simple&lt;/code&gt;, &lt;code&gt;Test::More&lt;/code&gt; and &lt;code&gt;Test::Builder&lt;/code&gt;). Surprisingly, we had to change very little to fix it.&lt;/p&gt;

&lt;p&gt;The problem was simply that the test numbering was not shared between threads.&lt;/p&gt;

&lt;p&gt;For example&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     use threads;
     use Test::Simple tests =&amp;gt; 3;
     ok(1);
     threads-&amp;gt;create(sub { ok(1) })-&amp;gt;join();
     ok(1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that will return&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     1..3
     ok 1
     ok 2
     ok 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Does it look similar to the problem we had earlier? Indeed it does, seems like somewhere there is a variable that needs to shared.&lt;/p&gt;

&lt;p&gt;Now reading the documentation of &lt;code&gt;Test::Simple&lt;/code&gt; we find out that all magic is really done inside &lt;code&gt;Test::Builder&lt;/code&gt;, opening up &lt;em&gt;Builder.pm&lt;/em&gt; we quickly find the following lines of code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     my @Test_Results = ();
     my @Test_Details = ();
     my $Curr_Test = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we would be tempted to add &lt;code&gt;use threads::shared&lt;/code&gt; and &lt;code&gt;:shared&lt;/code&gt; attribute.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     use threads::shared;
     my @Test_Results : shared = ();
     my @Test_Details : shared = ();
     my $Curr_Test : shared = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However &lt;code&gt;Test::Builder&lt;/code&gt; needs to work back to Perl 5.4.4! Attributes were only added in 5.6.0 and the above code would be a syntax error in earlier Perls. And even if someone were using 5.6.0, &lt;code&gt;threads::shared&lt;/code&gt; would not be available for them.&lt;/p&gt;

&lt;p&gt;The solution is to use the runtime function &lt;code&gt;share()&lt;/code&gt; exported by &lt;code&gt;threads::shared&lt;/code&gt;, but we only want to do it for 5.8.0 and when threads have been enabled. So, let&amp;rsquo;s wrap it in a &lt;code&gt;BEGIN&lt;/code&gt; block and an &lt;code&gt;if&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     BEGIN{
         if($] &amp;gt;= 5.008 &amp;amp;&amp;amp; exists($INC{&#39;threads.pm&#39;})) {
             require threads::shared;
             import threads::shared qw(share);
             share($Curr_Test);
             share(@Test_Details)
             share(@Test_Results);
         }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, if 5.8.0 or higher and threads has been loaded, we do the runtime equivalent of &lt;code&gt;use threads::shared qw(share);&lt;/code&gt; and call &lt;code&gt;share()&lt;/code&gt; on the variables we want to be shared.&lt;/p&gt;

&lt;p&gt;Now lets find out some examples of where &lt;code&gt;$Curr_Test&lt;/code&gt; is used. We find &lt;code&gt;sub ok {}&lt;/code&gt; in &lt;code&gt;Test::Builder&lt;/code&gt;; I won&amp;rsquo;t include it here, but only a smaller version which contains:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     sub ok {
         my($self, $test, $name) = @_;
         $Curr_Test++;
         $Test_Results[$Curr_Test-1] = 1 unless($test);
     }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, this looks like it should work right? We have shared $Curr_Test and &lt;code&gt;@Test_Results&lt;/code&gt;. Of course, things aren&amp;rsquo;t that easy; they never are. Even if the variables are shared, two threads could enter &lt;code&gt;ok()&lt;/code&gt; at the same time. Remember that not even the statement &lt;code&gt;$CurrTest++&lt;/code&gt; is an atomic operation, it is just a shortcut for writing &lt;code&gt;$CurrTest = $CurrTest + 1&lt;/code&gt;. So let&amp;rsquo;s say two threads do that at the same time.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     Thread 1: add 1 + $Curr_Test
     Thread 2: add 1 + $Curr_Test
     Thread 2: Assign result to $Curr_Test
     Thread 1: Assign result to $Curr_Test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The effect would be that $Curr_Test would only be increased by one, not two! Remember that a switch between two threads could happen at &lt;strong&gt;ANY&lt;/strong&gt; time, and if you are on a multiple CPU machine they can run at exactly the same time! Never trust thread inertia.&lt;/p&gt;

&lt;p&gt;So how do we solve it? We use the &lt;code&gt;lock()&lt;/code&gt; keyword. &lt;code&gt;lock()&lt;/code&gt; takes a shared variable and locks it for the rest of the scope, but it is only an advisory lock so we need to find every place that $Curr_Test is used and modified and it is expected not to change. The &lt;code&gt;ok()&lt;/code&gt; becomes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     sub ok {
         my($self, $test, $name) = @_;
         lock($Curr_Test);
         $Curr_Test++;
         $Test_Results[$Curr_Test-1] = 1 unless($test);
     }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So are we ready? Well, &lt;code&gt;lock()&lt;/code&gt; was only added in Perl 5.5 so we need to add an else to the BEGIN clause to define a lock function if we aren&amp;rsquo;t running with threads. The end result would be.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     my @Test_Results = ();
     my @Test_Details = ();
     my $Curr_Test = 0;
     BEGIN{
         if($] &amp;gt;= 5.008 &amp;amp;&amp;amp; exists($INC{&#39;threads.pm&#39;})) {
             require threads::shared;
             import threads::shared qw(share);
             share($Curr_Test);
             share(@Test_Details)
             share(@Test_Results);
         } else {
             *lock = sub(*) {};
         }
     }
     sub ok {
         my($self, $test, $name) = @_;
         lock($Curr_Test);
         $Curr_Test++;
         $Test_Results[$Curr_Test-1] = 1 unless($test);
     }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, this is very like the code that has been added to &lt;code&gt;Test::Builder&lt;/code&gt; to make it work nice with threads. The only thing not correct is &lt;code&gt;ok()&lt;/code&gt; as I cut it down to what was relevant. There were roughly 5 places where &lt;code&gt;lock()&lt;/code&gt; had to be added. Now the test code would print&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     1..3
     ok 1
     ok 2
     ok 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which is exactly what the end user would expect. All in all this is a rather small change for this 1291 line module, we change roughly 15 lines in a non intrusive way, the documentation and testcase code makes up most of the patch. The full patch is at &lt;a href=&#34;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2002-06/msg00816.html&#34;&gt;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2002-06/msg00816.html&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-altering-perls-behavior-to-be-threadsafe-ex-threads-cwd-altering-perls-behavior-to-be-thread-safe-ex-threads-cwd-span&#34;&gt;&lt;span id=&#34;altering_perls_behavior_to_be_threadsafe,_ex::threads::cwd&#34;&gt;Altering Perls behavior to be thread-safe, ex::threads::cwd&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Somethings change when you use threads; some things that you or a module might do are not like what they used to be. Most of the changes will be due to the way your operating system treats processes that use threads. Each process has typically a set of attributes, which include the current working directory, the environment table, the signal subsystem and the pid. Since threads are multiple paths of execution inside a single process, the operating system treats it as a single process and you have a single set of these attributes.&lt;/p&gt;

&lt;p&gt;Yep. That&amp;rsquo;s right - if you change the current working directory in one thread, it will also change in all the other threads! Whoops, better start using absolute paths everywhere, and all the code that uses your module might use relative paths. Aaargh&amp;hellip;&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t worry, this is a solvable problem. In fact, it&amp;rsquo;s solvable by a module.&lt;/p&gt;

&lt;p&gt;Perl allows us to override functions using the &lt;code&gt;CORE::GLOBAL&lt;/code&gt; namespace. This will let us override the functions that deal with paths and set the &lt;code&gt;cwd&lt;/code&gt; correctly before issuing the command. So let&amp;rsquo;s start off&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     package ex::threads::safecwd;

     use 5.008;
     use strict;
     use warnings;
     use threads::shared;
     our $VERSION = &#39;0.01&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nothing weird here right? Now, when changing and dealing with the current working directory one often uses the &lt;code&gt;Cwd&lt;/code&gt; module, so let us make the cwd module safe first. How do we do that?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  1) use Cwd;
  2) our $cwd = cwd;  #our per thread cwd, init on startup from cwd
  3) our $cwd_mutex : shared; # the variable we use to sync
  4) our $Cwd_cwd = \&amp;amp;Cwd::cwd;
  5) *Cwd::cwd = *my_cwd;     
     sub my_cwd {
  6)     lock($cwd_mutex);
  7)     CORE::chdir($cwd);
  8)     $Cwd_cwd-&amp;gt;(@_);
     }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What&amp;rsquo;s going on here? Let&amp;rsquo;s analyze it line by line:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;We include &lt;code&gt;Cwd&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;We declare a variable and assign to it the cwd we start in. This variable will not be shared between threads and will contain the cwd of this thread.&lt;/li&gt;
&lt;li&gt;We declare a variable we will be using to lock for synchronizing work.&lt;/li&gt;
&lt;li&gt;Here we take a reference to the &lt;code&gt;&amp;amp;Cwd::cwd&lt;/code&gt; and store in &lt;code&gt;$Cwd_cwd&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Now we hijack &lt;code&gt;Cwd::cwd&lt;/code&gt; and assign to it our own &lt;code&gt;my_cwd&lt;/code&gt; so whenever someone calls &lt;code&gt;Cwd::cwd&lt;/code&gt;, it will call &lt;code&gt;my_cwd&lt;/code&gt; instead.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;my_cwd&lt;/code&gt; starts of by locking $cwd_mutex so no one else will muck. around with the cwd.&lt;/li&gt;
&lt;li&gt;After that we call &lt;code&gt;CORE::chdir()&lt;/code&gt; to actually set the cwd to what this thread is expecting it to be.&lt;/li&gt;
&lt;li&gt;And we round off by calling the original &lt;code&gt;Cwd::cwd&lt;/code&gt; that we stored in step 4 with any parameters that we were handed to us.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In effect we have hijacked &lt;code&gt;Cwd::cwd&lt;/code&gt; and wrapped it around with a lock and a &lt;code&gt;chdir&lt;/code&gt; so it will report the correct thing!&lt;/p&gt;

&lt;p&gt;Now that &lt;code&gt;cwd()&lt;/code&gt; is fixed, we need a way to actually change the directory. To do this, we install our own global &lt;code&gt;chdir&lt;/code&gt;, simply like this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     *CORE::GLOBAL::chdir = sub {
         lock($cwd_mutex);
         CORE::chdir($_[0]) || return undef;
         $cwd = $Cwd_cwd-&amp;gt;();
     };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, whenever someone calls &lt;code&gt;chdir()&lt;/code&gt; our &lt;code&gt;chdir&lt;/code&gt; will be called instead, and in it we start by locking the variable controlling access, then we try to chdir to the directory to see if it is possible, otherwise we do what the real chdir would do, return undef. If it succeeds, we assign the new value to our per thread &lt;code&gt;$cwd&lt;/code&gt; by calling the original &lt;code&gt;Cwd::cwd()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The above code is actually enough to allow the following to work:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     use threads
     use ex::threads::safecwd;
     use Cwd;
     chdir(&amp;quot;/tmp&amp;quot;);
     threads-&amp;gt;create(sub { chdir(&amp;quot;/usr&amp;quot;) } )-&amp;gt;join();
     print cwd() eq &#39;/tmp&#39; ? &amp;quot;ok&amp;quot; : &amp;quot;nok&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since the &lt;code&gt;chdir(&amp;quot;/usr&amp;quot;);&lt;/code&gt; inside the thread will not affect the other thread&amp;rsquo;s &lt;code&gt;$cwd&lt;/code&gt; variable, so when &lt;code&gt;cwd&lt;/code&gt; is called, we will lock down the thread, &lt;code&gt;chdir()&lt;/code&gt; to the location the thread &lt;code&gt;$cwd&lt;/code&gt; contains and perform a &lt;code&gt;cwd()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;While this is useful, we need to get along and provide some more functions to extend the functionality of this module.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     *CORE::GLOBAL::mkdir = sub {
         lock($cwd_mutex);
         CORE::chdir($cwd);
         if(@_ &amp;gt; 1) {
             CORE::mkdir($_[0], $_[1]);
         } else {
             CORE::mkdir($_[0]);
         }
     };

     *CORE::GLOBAL::rmdir = sub {
         lock($cwd_mutex);
         CORE::chdir($cwd);
         CORE::rmdir($_[0]);
     };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above snippet does essentially the same thing for both &lt;code&gt;mkdir&lt;/code&gt; and &lt;code&gt;rmdir&lt;/code&gt;. We lock the $cwd_mutex to synchronize access, then we &lt;code&gt;chdir&lt;/code&gt; to &lt;code&gt;$cwd&lt;/code&gt; and finally perform the action. Worth noticing here is the check we need to do for &lt;code&gt;mkdir&lt;/code&gt; to be sure the prototype behavior for it is correct.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s move on with &lt;code&gt;opendir&lt;/code&gt;, &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;readlink&lt;/code&gt;, &lt;code&gt;readpipe&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt;, &lt;code&gt;rmdir&lt;/code&gt;, &lt;code&gt;stat&lt;/code&gt;, &lt;code&gt;symlink&lt;/code&gt;, &lt;code&gt;system&lt;/code&gt; and &lt;code&gt;unlink&lt;/code&gt;. None of these are really any different from the above with the big exception of &lt;code&gt;open&lt;/code&gt;. &lt;code&gt;open&lt;/code&gt; has a weird bit of special case since it can take both a HANDLE and an empty scalar for autovification of an anonymous handle.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     *CORE::GLOBAL::open = sub (*;$@) {
         lock($cwd_mutex);
         CORE::chdir($cwd);
         if(defined($_[0])) {
             use Symbol qw();
             my $handle = Symbol::qualify($_[0],(caller)[0]);
             no strict &#39;refs&#39;;
             if(@_ == 1) {
                 return CORE::open($handle);
             } elsif(@_ == 2) {
               return CORE::open($handle, $_[1]);
             } else {
               return CORE::open($handle, $_[1], @_[2..$#_]);
             }
         }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Starting off with the usual lock and &lt;code&gt;chdir()&lt;/code&gt; we then need to check if the first value is defined. If it is, we have to qualify it to the callers namespace. This is what would happen if a user does &lt;code&gt;open FOO, &amp;quot;+&amp;gt;foo.txt&amp;quot;&lt;/code&gt;. If the user instead does &lt;code&gt;open main::FOO, &amp;quot;+&amp;gt;foo.txt&amp;quot;&lt;/code&gt;, then Symbol::qualify notices that the handle is already qualified and returns it unmodified. Now since &lt;code&gt;$_[0]&lt;/code&gt; is a readonly alias we cannot assign it over so we need to create a temporary variable and then proceed as usual.&lt;/p&gt;

&lt;p&gt;Now if the user used the new style &lt;code&gt;open my $foo, &amp;quot;+&amp;gt;foo.txt&amp;quot;&lt;/code&gt;, we need to treat it differently. The following code will do the trick and complete the function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     else {
             if(@_ == 1) {
                 return CORE::open($_[0]);
             } elsif(@_ == 2) {
                 return CORE::open($_[0], $_[1]);
             } else {
                 return CORE::open($_[0], $_[1], @_[2..$#_]);
             }
         }
     };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wonder why we couldn&amp;rsquo;t just assign &lt;code&gt;$_[0]&lt;/code&gt; to &lt;code&gt;$handle&lt;/code&gt; and unify the code path? You see, &lt;code&gt;$_[0]&lt;/code&gt; is an alias to the &lt;code&gt;$foo&lt;/code&gt; in &lt;code&gt;open my $foo, &amp;quot;+&amp;gt;foo.txt&amp;quot;&lt;/code&gt; so &lt;code&gt;CORE::open&lt;/code&gt; will correctly work.&lt;/p&gt;

&lt;p&gt;However, if we do &lt;code&gt;$handle = $_[0]&lt;/code&gt; we take a copy of the undefined variable and &lt;code&gt;CORE::open&lt;/code&gt; won&amp;rsquo;t do what I mean.&lt;/p&gt;

&lt;p&gt;So now we have a module that allows the you to safely use relative paths in most of the cases and vastly improves your ability to port code to a threaded environment. The price we pay for this is speed, since every time you do an operation involving a directory you are serializing your program. Typically, you never do those kinds of operations in a hot path anyway. You might do work on your file in a hot path, but as soon as we have gotten the filehandle no more locking is done.&lt;/p&gt;

&lt;p&gt;A couple of problems remain. Performance-wise, there is one big problem with &lt;code&gt;system()&lt;/code&gt;, since we don&amp;rsquo;t get control back until the &lt;code&gt;CORE::system()&lt;/code&gt; returns, so all path operations will hang waiting for that. To solve that we would need to revert to XS and do some magic with regard to the system call. We also haven&amp;rsquo;t been able to override the file test operators (&lt;code&gt;-x&lt;/code&gt; and friends), nor can we do anything about &lt;code&gt;qx {}&lt;/code&gt;. Solving that problem requires working up and down the optree using &lt;code&gt;B::Generate&lt;/code&gt; and &lt;code&gt;B::Utils&lt;/code&gt;. Perhaps a future version of the module will attempt that together with a custom op to do the locking.&lt;/p&gt;

&lt;h3 id=&#34;span-id-conclusion-conclusion-span&#34;&gt;&lt;span id=&#34;conclusion&#34;&gt;Conclusion&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Threads in Perl are simple and straight forward, as long as we stay in pure Perl land everything behaves just about how we would expect it to. Converting your modules should be a simple matter of programming without any big wizardly things to be done. The important thing to remember is to think about how your module could possibly take advantage of threads to make it easier to use for the programmer.&lt;/p&gt;

&lt;p&gt;Moving over to XS land is altogether different; stay put for the next article that will take us through the pitfalls of converting various kinds of XS modules to thread-safe and thread-friendly levels.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

