<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pete Sergeant on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/authors/pete-sergeant/</link>
    <description>Recent content in Pete Sergeant on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 13 Feb 2004 00:00:00 -0800</lastBuildDate>
    <atom:link href="/authors/pete-sergeant/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Mail to WAP Gateways</title>
      <link>http://localhost:1313/pub/2004/02/13/mbox2wap.html/</link>
      <pubDate>Fri, 13 Feb 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/02/13/mbox2wap.html/</guid>
      <description>

&lt;p&gt;It&amp;rsquo;s coming up to Valentine&amp;rsquo;s day again, and invariably my thoughts turn back to last year&amp;rsquo;s rather memorable weekend-break to Stockholm, in which I learned two things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Stockholm makes a great Valentine&amp;rsquo;s destination.&lt;/li&gt;
&lt;li&gt;My girlfriend of the time was not happy with me cracking out my iBook and checking my email halfway into the break.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The relationship, predictably, didn&amp;rsquo;t last much longer, but it did occur to me that a quick and easy way to check my email when away from my computer would be very useful. One of the items that travels everywhere with me, and has some limited Internet access is my phone &amp;ndash; although admittedly this has only WAP access. WAP access, it seemed, would have to do&amp;hellip;&lt;/p&gt;

&lt;p&gt;The tool I ended up building fills &lt;strong&gt;my&lt;/strong&gt; needs very well, but possibly won&amp;rsquo;t be such a great match for others. This article looks at considerations when rendering email for display online, especially when space is very limited.&lt;/p&gt;

&lt;h3 id=&#34;span-id-overview-of-messages-overview-of-messages-span&#34;&gt;&lt;span id=&#34;Overview_of_messages&#34;&gt;Overview of Messages&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The first challenge is reading the contents of our target mailbox. For this, we turn to the Perl Email Project&amp;rsquo;s &lt;a href=&#34;https://metacpan.org/pod/Email::Folder&#34;&gt;&lt;code&gt;Email::Folder&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; use Email::Folder;

 my $folder = Email::Folder-&amp;gt;new( &#39;/home/sheriff/mbox&#39; );

 for my $message ( $folder-&amp;gt;messages ) {

        ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://metacpan.org/pod/Email::Folder&#34;&gt;&lt;code&gt;Email::Folder&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s messages() function returns &lt;a href=&#34;https://metacpan.org/pod/Email::Simple&#34;&gt;&lt;code&gt;Email::Simple&lt;/code&gt;&lt;/a&gt; objects. For my folder-view, I chose to group messages by date, and use the sender&amp;rsquo;s &amp;ldquo;real name&amp;rdquo; as the subject. Something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 30 Jan 2004
    Michael Roberts
  * Paul Makepeace
    Uri Guttman
 29 Jan 2004
    Kate Pugh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Extracting header fields from &lt;a href=&#34;https://metacpan.org/pod/Email::Simple&#34;&gt;&lt;code&gt;Email::Simple&lt;/code&gt;&lt;/a&gt; objects couldn&amp;rsquo;t be simpler:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; my $from = $message-&amp;gt;header(&#39;from&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But people familiar with the various email RFCs will know that since email headers have to use only printable US-ASCII, they&amp;rsquo;re very often encoded: your header field might well look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  =?iso-8859-1?q?Pete=20Sergeant?= &amp;lt;pete@clueball.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will not look pretty if you use it literally. Thankfully, &lt;a href=&#34;https://metacpan.org/pod/MIME::WordDecoder&#34;&gt;&lt;code&gt;MIME::WordDecoder&lt;/code&gt;&lt;/a&gt; exports the function &lt;code&gt;unmime&lt;/code&gt; &amp;ndash; rendering the above as &amp;ldquo;Pete Sergeant &amp;lt;pete@clueball.com&amp;gt;.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Getting the date from an email is also somewhat nontrivial &amp;ndash; an example &amp;ldquo;Date&amp;rdquo; header looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; Fri, 30 Jan 2004 14:09:51 -0000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that&amp;rsquo;s if you&amp;rsquo;re lucky, and it&amp;rsquo;s well-formed, without starting to think about time zones. If we want to do anything useful with dates, we&amp;rsquo;re going to want the date as an epoch time. Luckily, &lt;a href=&#34;https://metacpan.org/pod/DateTime::Format::Mail&#34;&gt;&lt;code&gt;DateTime::Format::Mail&lt;/code&gt;&lt;/a&gt; steps in, and not only parses our date, but returns a highly useful &lt;a href=&#34;https://metacpan.org/pod/DateTime&#34;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; object, allowing us to do all kinds of fun date stuff. To simply reformat the date as Day/Month/Year:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; my $datetime = DateTime::Format::Mail-&amp;gt;new( loose =&amp;gt; 1 );
 my $time = $datetime-&amp;gt;parse_datetime( $message-&amp;gt;header(&#39;date&#39;) );
 my $day_month_year = $time-&amp;gt;dmy;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we&amp;rsquo;re going to want to know if an email is new or not. Luckily, most MUAs will set/edit an email&amp;rsquo;s status header. Rather than checking if an email is new, we check if it&amp;rsquo;s been read &amp;ndash; denoted by a &lt;code&gt;R&lt;/code&gt; in the status header:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $new_flag++ if $message-&amp;gt;header(&#39;Status&#39;) !~ m/R/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s put this all together to produce a listing of a folder. We&amp;rsquo;ll use the well-known Schwartzian transform to make the sorting efficient, but unlike the usual practice, we keep the array reference around, as we&amp;rsquo;ll be using the date as well.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; use Email::Folder;
 use MIME::WordDecoder qw( unmime );
 use DateTime::Format::Mail;

 my $folder = Email::Folder-&amp;gt;new( &#39;/home/sheriff/mbox&#39; );
 my @to_sort;
 my $prev_date = &amp;quot;&amp;quot;;
 for (sort { $a-&amp;gt;[1] cmp $b-&amp;gt;[1]    }
      map  { [$_, message2dmy($_) ] } 
      $folder-&amp;gt;messages) {
     my ($message, $date) = @$_;
     if ($date ne $prev_date) { print $date, &amp;quot;\n&amp;quot;; $prev_date = $date; }
     print $message-&amp;gt;header(&#39;Status&#39;) =~ m/R/ ? &amp;quot;   &amp;quot; : &amp;quot; * &amp;quot;;
     print unmime($message-&amp;gt;header(&#39;from&#39;)), &amp;quot;\n&amp;quot;;
 }

 sub message2dmy {
     my $message = shift;
     my $datetime = DateTime::Format::Mail-&amp;gt;new( loose =&amp;gt; 1 );
     my $time = $datetime-&amp;gt;parse_datetime( $message-&amp;gt;header(&#39;date&#39;) );
     my $day_month_year = $time-&amp;gt;dmy;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-displaying-individual-messages-displaying-individual-messages-span&#34;&gt;&lt;span id=&#34;Displaying_individual_messages&#34;&gt;Displaying Individual Messages&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Those are the main challenges of a folder-view. Viewing an individual message presents a different set of challenges.&lt;/p&gt;

&lt;p&gt;First and foremost is the appalling habit people have of sending each other HTML-&amp;ldquo;enriched&amp;rdquo; emails, with all sorts of attachments. If you&amp;rsquo;re trying to read the email on a cell phone over a slow connection, you don&amp;rsquo;t want to be battling with this &amp;ndash; you want a nice plain-text representation of the email. So, &lt;a href=&#34;https://metacpan.org/pod/Email::StripMIME&#34;&gt;&lt;code&gt;Email::StripMIME&lt;/code&gt;&lt;/a&gt; is your friend. Assuming we have an &lt;a href=&#34;https://metacpan.org/pod/Email::Simple&#34;&gt;&lt;code&gt;Email::Simple&lt;/code&gt;&lt;/a&gt; object, we can simply:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; my $string = $email_simple_object-&amp;gt;as_string();
 $string = Email::StripMIME::strip_mime( $string );
 $email_simple_object = Email::Simple-&amp;gt;new( $string );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, if we really wanted to cut down on the amount of content we&amp;rsquo;re receiving, and we&amp;rsquo;re only using this tool to get an overview of our messages, we can cut out quoted text, remnants of the email that the sender was replying to, and so on. &lt;a href=&#34;https://metacpan.org/pod/Text::Original&#34;&gt;&lt;code&gt;Text::Original&lt;/code&gt;&lt;/a&gt; does just this for us, as well as stripping out attribution lines:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; my $body = $email_simple_object-&amp;gt;body();
 $body = first_lines( $body, 20);
 $email_simple_object-&amp;gt;body( $body );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final problem is in creating actual real WML. Sadly, this is nontrivial, and in the past, I&amp;rsquo;ve tended to resort to outputting it by hand. But it doesn&amp;rsquo;t have to be that way &amp;ndash;; &lt;a href=&#34;https://metacpan.org/pod/CGI::WML&#34;&gt;&lt;code&gt;CGI::WML&lt;/code&gt;&lt;/a&gt; just about handles the task for us. &lt;a href=&#34;https://metacpan.org/pod/CGI::WML&#34;&gt;&lt;code&gt;CGI::WML&lt;/code&gt;&lt;/a&gt; is a subclass of &lt;a href=&#34;https://metacpan.org/pod/CGI&#34;&gt;&lt;code&gt;CGI&lt;/code&gt;&lt;/a&gt;, with methods specific to WAP.&lt;/p&gt;

&lt;h3 id=&#34;span-id-conclusion-conclusion-span&#34;&gt;&lt;span id=&#34;Conclusion&#34;&gt;Conclusion&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;There is no fully working demo at the end of this article. My personal tool works in a way that&amp;rsquo;s probably a little too specific for most people&amp;rsquo;s needs. Hopefully however, it&amp;rsquo;s introduced you to one or more modules you didn&amp;rsquo;t know existed, and given you some inspiration to tinker around with Perl and email-handling.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Reversing Regular Expressions</title>
      <link>http://localhost:1313/pub/2001/05/01/expressions.html/</link>
      <pubDate>Tue, 01 May 2001 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2001/05/01/expressions.html/</guid>
      <description>&lt;p&gt;Regular Expressions are arguably one of Perl&amp;rsquo;s most useful and powerful tools. The ability to match complex strings is one of the things that makes Perl the effective &amp;ldquo;Practical Extraction and Reporting Language&amp;rdquo; that it is. The regular expression engine is highly optimised and thus very fast, although in some situations people fail to use it in the most effective manner.&lt;/p&gt;

&lt;p&gt;For example, imagine a case where you have a collection of very long lines from a log file, that each have a four digit year (starting with 19) somewhere near the end.&lt;/p&gt;

&lt;p&gt;One would normally say something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Match any occurrence of 19xx that&#39;s not followed by another one
if ($string =~ /(19\d\d)(?!.*19\d\d)/) {$date = $1}

or, better:

if ($string =~ /.*(19\d\d)/) {$date = $1}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, in this situation, the regular expression engine has to go through all the string, remembering any matches it finds and discarding them any time it finds a new match, until it reaches the end of the string. If you have long log lines, this can be highly inefficient, and comparatively slow. But is there another way to do it? (Hint: With Perl, There&amp;rsquo;s Always More Than One Way To Do It)&lt;/p&gt;

&lt;p&gt;Unless you&amp;rsquo;re a regular on IRC or &lt;a href=&#34;http://www.perlmonks.com&#34;&gt;perlmonks.com&lt;/a&gt;, or attended &lt;a href=&#34;http://yapc.org/Europe/&#34;&gt;YAPC::Europe&lt;/a&gt;, it&amp;rsquo;s quite possible that you&amp;rsquo;ve never heard of (a) Jeff Pinyan (aka Japhy) and (b) his simple and elegant solution to getting around this problem. He dubbed these solutions reversed regular expressions, or sexeger.&lt;/p&gt;

&lt;p&gt;Instead of going through the whole string looking for the last match, wouldn&amp;rsquo;t it be a better idea to work from the back of the string and take the first match that is found? At the moment, Perl doesn&amp;rsquo;t provide a built in method for doing this, but it&amp;rsquo;s surprisingly easy to emulate one. To quote the lightning talk Mr Pinyan wrote for me to give at YAPC::E &amp;ldquo;Reverse the input! Reverse the regex! Reverse the match!&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;And so that&amp;rsquo;s exactly what we&amp;rsquo;ll do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub get_date {
    $_ = scalar reverse($_[0]); # Reverse whatever string we were passed
    /(\d\d91)/;                 # Look for the first occurrence of a xx91 (19xx reversed)
    return scalar reverse $1;   # Reverse back whatever we found and return it
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Obviously, we&amp;rsquo;re performing two more functions in this example, two calls of reverse. Reverse however appears to be very efficient, and in benchmarks that were run (details below), this seemed not to be a problem. To test if this really would be significantly faster, I used a 10,000 character string, and ran the regex 10000 times on it. Here&amp;rsquo;s the code used to test it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$la = [our 10000 character string]
...
use Benchmark;
$t = timeit(&amp;quot;10000&amp;quot;,  sub { $_ = $la; /.*(19\d\d)/; });
print &amp;quot;Greedy took:&amp;quot;,timestr($t), &amp;quot;\n&amp;quot;;
$t = timeit(&amp;quot;10000&amp;quot;,  sub { $_ = $la; /(19\d\d)(?!.*19\d\d)/;});
print &amp;quot;Lookahead took:&amp;quot;,timestr($t), &amp;quot;\n&amp;quot;;
$t = timeit(&amp;quot;10000&amp;quot;,  sub { $_ = reverse($la); /(\d\d91)/;  });
print &amp;quot;Sexeger took:&amp;quot;,timestr($t), &amp;quot;\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first example, with its look ahead assertion, took four hundred seconds, as the look ahead assertion is a major time sink. The second example took 1.5 seconds. The reversed method managed however to shave three quarters of a second off that, and become 0.75 seconds. To summarise:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;Time&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/(19\d\d)(?!.*19\d\d)/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;400&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/.*(19\d\d)/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;1.5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;sexeger&lt;/td&gt;
&lt;td&gt;0.75&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;However, performance gains are not the only good use for reversed regular expression, as one can also use them to solve a few other common problems that Perl doesn&amp;rsquo;t handle easily. If you&amp;rsquo;ve all read the Frequently Asked Questions included with Perl, which I&amp;rsquo;m &lt;strong&gt;sure&lt;/strong&gt; you have, then you&amp;rsquo;ll have seen a particularly good example in Section 5 (perldoc perlfaq5) by Andrew Johnson - &amp;ldquo;How can I output my numbers with commas added?&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub commify {
my $input = shift;
$input = reverse $input;
$input =~ s&amp;lt;(\d\d\d)(?=\d)(?!\d*\.)&amp;gt;&amp;lt;$1,&amp;gt;g;
return scalar reverse $input;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One of my personal favourite regex tools is zero-width look ahead assertions, as in the very first example (it&amp;rsquo;s worth noting that that&amp;rsquo;s a &lt;strong&gt;negative&lt;/strong&gt; zero-width look ahead assertion). For people who haven&amp;rsquo;t scoured &lt;em&gt;perldoc perlre&lt;/em&gt;, this allows you to state that a pattern has to exist in front of your position, without actually matching it. Perhaps an example would help illustrate: &lt;code&gt;/ab(?=.+e)cd/&lt;/code&gt; will match &lt;code&gt;&amp;quot;abcde&amp;quot;&lt;/code&gt; but not &lt;code&gt;&amp;quot;abecd&amp;quot;&lt;/code&gt; or &lt;code&gt;&amp;quot;abcd&amp;quot;&lt;/code&gt;. Sadly, it&amp;rsquo;s not possible to do variable length zero-width look behind assertions with the current Regular Expression Engine. However, if we apply sexeger principles to it, as suggested by Anthony Guselnikov, it suddenly becomes easy. If we want to match the string &lt;code&gt;&amp;quot;def&amp;quot;&lt;/code&gt;, as long as it was preceded by the letter &amp;lsquo;a&amp;rsquo;, we can say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub nlba {
$_ = scalar reverse $_[0];
print &amp;quot;Success\n&amp;quot; if /fed(?=.*a)/;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reversing Regular Expressions is a powerful and effective tool in any programmers arsenal. I hope that I&amp;rsquo;ve managed to illustrate the utility that this simple and elegant solution offers. Some overhead in programmer time, and in processing time is required to use them, and so I&amp;rsquo;d suggest that you evaluate using them on a case by case basis.&lt;/p&gt;

&lt;p&gt;For more information, visit the homepage at &lt;a href=&#34;http://www.pobox.com/~japhy/sexeger&#34;&gt;http://www.pobox.com/~japhy/sexeg er&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Designing a Search Engine</title>
      <link>http://localhost:1313/pub/2001/04/10/engine.html/</link>
      <pubDate>Tue, 10 Apr 2001 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2001/04/10/engine.html/</guid>
      <description>&lt;p&gt;A couple of months ago, I was approached by a company that I had done some work for previously, and was asked to build them a search engine to index about 200MB of HTML. However, some fairly strict rules were laid down about what I could and couldn&amp;rsquo;t do. First, the search engine had to be built from scratch, so that the rights to it were fully theirs. Second, I wasn&amp;rsquo;t allowed to use any non-standard modules. Third, the data had to be held in plain-text files. Fourth, I was assured that all DB* modules were not working, and couldn&amp;rsquo;t be made to work, which seemed somewhat surprising. And finally, one had to be able to perform Boolean searches, including the use of brackets.&lt;/p&gt;

&lt;p&gt;As you can imagine, this presented quite a challenge, so I accepted and got to work. I want to discuss the two most interesting parts of the project: how to store and retrieve the data efficiently, and how to parse search terms.&lt;/p&gt;

&lt;p&gt;Because of the ideas I had on parsing the search terms, which will be discussed later, I needed a system that could take a word and send back a list of all the files it appeared in and how many times it appeared in them. This had to be as fast as possible without using insane amounts of disk space. Second, I needed to be able to get information about the files indexed quickly without actually opening them - the files could be large, and could be held remotely.&lt;/p&gt;

&lt;p&gt;The first thing to do was to assign each indexed file a unique number - this would allow me to save space when referring to it, and would allow me to easily look up information on the file. Each word would have a list of these numbers listed under it, so I could take the word &amp;lsquo;camel&amp;rsquo; for example, and get a list of file numbers back.&lt;/p&gt;

&lt;p&gt;To me, the most obvious way of implementing this was to use a tied hash. However, my project rules stated I wasn&amp;rsquo;t allowed to do that. I tried to think of other ways to implement a tied-hash system without using any of the DB or DBI modules. My first idea was to piggy back off a similar feature used in almost all operating systems; or, to be more precise, every file system. By creating each word as a file I could easily &lt;code&gt;open (DATA, &amp;quot;camel&amp;quot;)&lt;/code&gt; to get my data.&lt;/p&gt;

&lt;p&gt;At this point, I had two types of indexes: one that listed summary information for each file by file number, and another that held information about each word.&lt;/p&gt;

&lt;p&gt;There were two problems, however, with using the file system as my hash. While with a small number of words it was quite fast, most operating systems use a linear search to locate files in a directory, so opening &amp;ldquo;zulu&amp;rdquo; in a 10,000 file directory quickly became quite slow. The other problem was minimum file sizes, especially under Windows. This is a huge problem when your minimum file size is 16kb - as it is on fat16 with a 1GB hard drive - as 100 files translates as 1.6MB. When the data you&amp;rsquo;re indexing is 20MB and you get about four times this much worth of index files, you&amp;rsquo;re doing something wrong.&lt;/p&gt;

&lt;p&gt;The solution for the file numbers was quite easy: I would spit out the file offsets of where information about each file was stored in my file index. Then, I&amp;rsquo;d read these offsets in at the start of each search, so that if I wanted information about file 15, I could get the offset by saying $file[15] and then seeking to that point.&lt;/p&gt;

&lt;p&gt;I was beginning to despair for an elegant solution to the word indexing until Simon Cozens pointed out the wonderful Search::Dict. Search::Dict is a standard module that searches for keys in dictionary files. Essentially, it allows you to give it a word and a file-handle, where the file-handle is tied to a bunch of lines in alphabetical order, and will then change the next read position of the file-handle to the line that starts with the word. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;look *INDEX, &amp;quot;camel&amp;quot;;
$line = &amp;lt;INDEX&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;would assign $line to the first line in the file handle beginning with camel. In addition, since it uses an effective binary search to achieve this, retrieval of data was fast. Problem solved.&lt;/p&gt;

&lt;p&gt;Parsing of the Boolean search terms was the most difficult part of the program. Users had to be able to enter terms such as cat and (dog not sheep) and get sane results. The only way I could deal with this, I decided, was to go along the search terms from left to right and keep an array of file numbers that were still applicable.&lt;/p&gt;

&lt;p&gt;To do this, I created three subroutines that I called &lt;code&gt;&amp;amp;array_and&lt;/code&gt;, &lt;code&gt;&amp;amp;array_not&lt;/code&gt;, and &lt;code&gt;&amp;amp;array_both&lt;/code&gt;. &lt;code&gt;&amp;amp;array_and&lt;/code&gt; would take our current results array and add the list of file numbers from a given word. &lt;code&gt;&amp;amp;array_not&lt;/code&gt; would &amp;lsquo;subtract&amp;rsquo; the file numbers from one word from our results array, and &lt;code&gt;&amp;amp;array_both&lt;/code&gt; would return shared elements between the results array and the file numbers from the search word.&lt;/p&gt;

&lt;p&gt;I ripped a lot of code from the Perl Cookbook to make these array functions. The code for these functions can be seen below:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub array_both {
 my $prev = &#39;nonesuch&#39;;
 my @total_first = (@{$_[0]}, @{$_[1]});
 @total_first = sort(@total_first);
 my $current;
 my @return_array;
 foreach $current (@total_first) {
  if ($prev eq $current) { push(@return_array, $prev);  }
  $prev = $current;
 }
 @return_array = @{&amp;amp;add_array(\@return_array, \@return_array)};
 return \@return_array;
}

sub array_and {
 my $prev = &#39;nonesuch&#39;;
 my @total_first = (@{$_[0]}, @{$_[1]});
 my %seen = (); # These next two lines are from the PCB
 my @return_array = grep { ! $seen{$_} ++ } @total_first ;
 return \@return_array;
}

sub array_not {

 # Again this is ripped straight from PCB

 my @a = @{$_[0]};
 my @b = @{$_[1]};
 my %hash = map {$_ =&amp;gt; 1} @a;
 my $current;
 foreach $current (@b) {
  delete $hash{$current};
 }
 @a = keys %hash;
 @a = sort(@a);
 return \@a;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only big problem left was dealing with brackets. The only solution I could come up with was to make the search term parsing code a subroutine that returned an array. This way when I came to some logic in brackets, I could send it back to the subroutine, from which I would get a list of words, exactly like if the logic had been a single word. The main problem that I envisaged with this would be getting Perl to deal with expressions such as &lt;code&gt;sheep and (dog not cat) and (camel not panther)&lt;/code&gt;. How did I get Perl to match just the first set of brackets, or, if nested brackets were present, to match all the logic? Damian Conway has written an excellent module called Text::Balanced, which I was just about to start using, before the project specifications changed(!) and I was told we no longer needed to allow nested-bracket searching.&lt;/p&gt;

&lt;p&gt;Yet again, Perl came into its own when writing the search engine. The availability of solutions to my problems in the form of modules saved me a lot of time, and saved the task from being inundated with my own, rather bad, code. The ability to use Perl to quickly extract titles from HTML documents and strip HTML tags in very few lines of code also made my life far easier.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

