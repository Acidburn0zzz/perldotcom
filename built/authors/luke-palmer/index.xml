<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Luke Palmer on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/authors/luke-palmer/</link>
    <description>Recent content in Luke Palmer on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 18 Mar 2004 00:00:00 -0800</lastBuildDate>
    <atom:link href="/authors/luke-palmer/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Synopsis 3</title>
      <link>http://localhost:1313/pub/2004/03/18/synopsis3.html/</link>
      <pubDate>Thu, 18 Mar 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/03/18/synopsis3.html/</guid>
      <description>

&lt;h3 id=&#34;span-id-operator-renaming-operator-renaming-span&#34;&gt;&lt;span id=&#34;Operator_renaming&#34;&gt;Operator Renaming&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Several operators have been given new names to increase clarity and better Huffman-code the language:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt; becomes &lt;code&gt;.&lt;/code&gt;, like the rest of the world uses.&lt;/li&gt;
&lt;li&gt;The string concatenation &lt;code&gt;.&lt;/code&gt; becomes &lt;code&gt;~&lt;/code&gt;. Think of it as &amp;ldquo;stitching&amp;rdquo; the two ends of its arguments together.&lt;/li&gt;
&lt;li&gt;Unary &lt;code&gt;~&lt;/code&gt; now imposes a string context on its argument, and &lt;code&gt;+&lt;/code&gt; imposes a numeric context (as opposed to being a no-op in Perl 5). Along the same lines, &lt;code&gt;?&lt;/code&gt; imposes a Boolean context.&lt;/li&gt;
&lt;li&gt;Bitwise operators get a data type prefix: &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, or &lt;code&gt;?&lt;/code&gt;. For example, &lt;code&gt;|&lt;/code&gt; becomes either &lt;code&gt;+|&lt;/code&gt; or &lt;code&gt;~|&lt;/code&gt; or &lt;code&gt;?|&lt;/code&gt;, depending on whether the operands are to be treated as numbers, strings, or Boolean values. Left shift &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; becomes &lt;code&gt;+&amp;lt;&lt;/code&gt;, and correspondingly with right shift. Unary &lt;code&gt;~&lt;/code&gt; becomes either &lt;code&gt;+^&lt;/code&gt; or &lt;code&gt;~^&lt;/code&gt; or &lt;code&gt;?^&lt;/code&gt;, since a bitwise NOT is like an exclusive-or against solid ones. Note that &lt;code&gt;?^&lt;/code&gt; is functionally identical to &lt;code&gt;!&lt;/code&gt;. &lt;code&gt;?|&lt;/code&gt; differs from &lt;code&gt;||&lt;/code&gt; in that &lt;code&gt;?|&lt;/code&gt; always returns a standard Boolean value (either 1 or 0), whereas &lt;code&gt;||&lt;/code&gt; returns the actual value of the first of its arguments that is true.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt; splits into two operators: &lt;code&gt;x&lt;/code&gt; (which concatenates repetitions of a string to produce a single string), and &lt;code&gt;xx&lt;/code&gt; (which creates a list of repetitions of a list or scalar).&lt;/li&gt;
&lt;li&gt;Trinary &lt;code&gt;? :&lt;/code&gt; becomes &lt;code&gt;?? ::&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;qw{ ... }&lt;/code&gt; gets a synonym: &lt;code&gt;« ... »&lt;/code&gt;. For those still living without the blessings of Unicode, that can also be written: &lt;code&gt;&amp;lt;&amp;lt; ... &amp;gt;&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The scalar comma &lt;code&gt;,&lt;/code&gt; now constructs a list reference of its operands. You have to use a [-1] subscript to get the last one.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;span-id-new-operators-new-operators-span&#34;&gt;&lt;span id=&#34;New_operators&#34;&gt;New Operators&lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Binary &lt;code&gt;//&lt;/code&gt; is just like &lt;code&gt;||&lt;/code&gt;, except that it tests its left side for definedness instead of truth. There is a low-precedence form, too: &lt;code&gt;err&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Binary &lt;code&gt;=&amp;gt;&lt;/code&gt; is no longer just a &amp;ldquo;fancy comma.&amp;rdquo; it now constructs a &lt;code&gt;Pair&lt;/code&gt; object that can, among other things, be used to pass named arguments to functions.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^^&lt;/code&gt; is the high-precedence version of &lt;code&gt;xor&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Unary &lt;code&gt;.&lt;/code&gt; calls its single argument (which must be a method, or an de-referencer for a hash or array) on $_.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;...&lt;/code&gt; is a unary postfix operator that constructs a semi-infinite (and lazily evaluated) list, starting at the value of its single argument.&lt;/li&gt;
&lt;li&gt;However, &lt;code&gt;...&lt;/code&gt; as a term is the &amp;ldquo;yada, yada, yada&amp;rdquo; operator, which is used as the body in function prototypes. It dies if it is ever executed.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(...)&lt;/code&gt; imposes a scalar context on whatever it encloses. Similarly, &lt;code&gt;@(...)&lt;/code&gt; and &lt;code&gt;%(...)&lt;/code&gt; impose a list and hash context, respectively. These can be interpolated into strings.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;span-id-hyperoperators-hyperoperators-span&#34;&gt;&lt;span id=&#34;Hyperoperators&#34;&gt;Hyperoperators&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The Unicode characters &lt;code&gt;»&lt;/code&gt; (&lt;code&gt;\x[BB]&lt;/code&gt;) and &lt;code&gt;«&lt;/code&gt; (&lt;code&gt;\x[AB]&lt;/code&gt;) and their ASCII digraphs &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; are used to denote &amp;ldquo;hyperoperations&amp;rdquo; – &amp;ldquo;list&amp;rdquo; or &amp;ldquo;vector&amp;rdquo; or &amp;ldquo;SIMD&amp;rdquo; operations that are applied pairwise between corresponding elements of two lists (or arrays) and which return a list (or array) of the results. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     (1,1,2,3,5) »+« (1,2,3,5,8);  # 
(2,3,5,8,13)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If one argument is insufficiently dimensioned, Perl &amp;ldquo;upgrades&amp;rdquo; it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     (3,8,2,9,3,8) &amp;gt;&amp;gt;-&amp;lt;&amp;lt; 1;          # 
(2,7,1,8,2,7)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This can even be done with method calls:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     (&amp;quot;f&amp;quot;,&amp;quot;oo&amp;quot;,&amp;quot;bar&amp;quot;)».«length; 
   # (1,2,3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When using a unary operator, only put it on the operand&amp;rsquo;s side:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     @negatives = -« @positives;

      @positions»++;            # Increment all positions

      @objects».run();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-junctive-operators-junctive-operators-span&#34;&gt;&lt;span id=&#34;Junctive_operators&#34;&gt;Junctive Operators&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;|&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, and &lt;code&gt;^&lt;/code&gt; are no longer bitwise operators (see &lt;a href=&#34;#Operator_Renaming&#34;&gt;Operator Renaming&lt;/a&gt;) but now serve a much higher cause: they are now the junction constructors.&lt;/p&gt;

&lt;p&gt;A junction is a single value that is equivalent to multiple values. They thread through operations, returning another junction representing the result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     1|2|3 + 4;                              # 5|6|7
     1|2 + 3&amp;amp;4;                              # (4|5) &amp;amp; (5|6)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note how when two junctions are applied through an operator, the result is a junction representing the operator applied to each combination of values.&lt;/p&gt;

&lt;p&gt;Junctions come with the functional variants &lt;code&gt;any&lt;/code&gt;, &lt;code&gt;all&lt;/code&gt;, &lt;code&gt;one&lt;/code&gt;, and &lt;code&gt;none&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This opens doors for constructions like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     unless $roll == any(1..6) { print &amp;quot;Invalid roll&amp;quot; }

     if $roll == 1|2|3 { print &amp;quot;Low roll&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-chained-comparisons-chained-comparisons-span&#34;&gt;&lt;span id=&#34;Chained_comparisons&#34;&gt;Chained Comparisons&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Perl 6 supports the natural extension to the comparison operators, allowing multiple operands.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     if 3 &amp;lt; $roll &amp;lt;= 6              { print &amp;quot;High roll&amp;quot; }

     if 1 &amp;lt;= $roll1 == $roll2 &amp;lt;= 6  { print &amp;quot;Doubles!&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-binding-binding-span&#34;&gt;&lt;span id=&#34;Binding&#34;&gt;Binding&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;A new form of assignment is present in Perl 6, called &amp;ldquo;binding,&amp;rdquo; used in place of typeglob assignment. It is performed with the &lt;code&gt;:=&lt;/code&gt; operator. Instead of replacing the value in a container like normal assignment, it replaces the container itself. For instance:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $x = &#39;Just Another&#39;;
    my $y := $x;
    $y = &#39;Perl Hacker&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After this, both &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; contain the string &amp;ldquo;Perl Hacker,&amp;rdquo; since they are really just two different names for the same variable.&lt;/p&gt;

&lt;p&gt;There is another variant, spelled &lt;code&gt;::=&lt;/code&gt;, that does the same thing at compile time.&lt;/p&gt;

&lt;p&gt;There is also an identity test, &lt;code&gt;=:=&lt;/code&gt;, which tests whether two names are bound to the same underlying variable. &lt;code&gt;$x =:= $y&lt;/code&gt; would return true in the above example.&lt;/p&gt;

&lt;h3 id=&#34;span-id-list-flattening-list-flattening-span&#34;&gt;&lt;span id=&#34;List_flattening&#34;&gt;List Flattening&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Since typeglobs are being removed, unary &lt;code&gt;*&lt;/code&gt; may now serve as a list-flattening operator. It is used to &amp;ldquo;flatten&amp;rdquo; an array into a list, usually to allow the array&amp;rsquo;s contents to be used as the arguments of a subroutine call. Note that those arguments still must comply with the subroutine&amp;rsquo;s signature, but the presence of &lt;code&gt;*&lt;/code&gt; defers that test until runtime.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @args = (\@foo, @bar);
    push *@args;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    push @foo, @bar;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-piping-operators-piping-operators-span&#34;&gt;&lt;span id=&#34;Piping_operators&#34;&gt;Piping Operators&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The new operators &lt;code&gt;==&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;==&lt;/code&gt; are akin to UNIX pipes, but work with functions that accept and return lists. For example,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     @result = map { floor($^x / 2) }
                 grep { /^ \d+ $/ }
                   @data;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Can also now be written:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     @data ==&amp;gt; grep { /^ \d+ $/ }
           ==&amp;gt; map { floor($^x / 2) }
           ==&amp;gt; @result;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     @result &amp;lt;== map { floor($^x / 2) }
             &amp;lt;== grep { /^ \d+ $/ }
             &amp;lt;== @data;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Either form more clearly indicates the flow of data. See &lt;a href=&#34;http://localhost:1313/pub/2003/04/09/synopsis.html&#34;&gt;Synopsis 6&lt;/a&gt; for more of the (less-than-obvious) details on these two operators.&lt;/p&gt;

&lt;h3 id=&#34;span-id-invocant-marker-invocant-marker-span&#34;&gt;&lt;span id=&#34;Invocant_marker&#34;&gt;Invocant Marker&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;An appended &lt;code&gt;:&lt;/code&gt; marks the invocant when using the indirect-object syntax for Perl 6 method calls. The following two statements are equivalent:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $hacker.feed(&#39;Pizza and cola&#39;);
    feed $hacker: &#39;Pizza and cola&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-zip-zip-span&#34;&gt;&lt;span id=&#34;zip&#34;&gt;&lt;code&gt;zip&lt;/code&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In order to support parallel iteration over multiple arrays, Perl 6 has a &lt;code&gt;zip&lt;/code&gt; function that interleaves the elements of two or more arrays.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for zip(@names, @codes) -&amp;gt; $name, $zip {
        print &amp;quot;Name: $name;   Zip code: $zip\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;zip&lt;/code&gt; has an infix synonym, the Unicode operator &lt;code&gt;¦&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-minimal-whitespace-dwimmery-minimal-whitespace-dwimmery-span&#34;&gt;&lt;span id=&#34;Minimal_whitespace_DWIMmery&#34;&gt;Minimal Whitespace DWIMmery&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Whitespace is no longer allowed before the opening bracket of an array or hash accessor. That is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %monsters{&#39;cookie&#39;} = Monster.new;  # Valid Perl 6
    %people  {&#39;john&#39;}   = Person.new;   # Not valid Perl 6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One of the several useful side-effects of this restriction is that parentheses are no longer required around the condition of control constructs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if $value eq $target {
        print &amp;quot;Bullseye!&amp;quot;;
    }
    while 0 &amp;lt; $i { $i++ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is, however, still possible to align accessors by explicitly using the &lt;code&gt;.&lt;/code&gt; operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     %monsters.{&#39;cookie&#39;} = Monster.new;
     %people  .{&#39;john&#39;}   = Person .new;
     %cats    .{&#39;fluffy&#39;} = Cat    .new;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>

