<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorials on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/categories/tutorials/</link>
    <description>Recent content in Tutorials on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 16 Aug 2018 07:28:49 +0000</lastBuildDate>
    <atom:link href="/categories/tutorials/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>How to write your first article for Perl.com</title>
      <link>http://localhost:1313/article/how-to-write-your-first-article-for-perl-com/</link>
      <pubDate>Thu, 16 Aug 2018 07:28:49 +0000</pubDate>
      
      <guid>http://localhost:1313/article/how-to-write-your-first-article-for-perl-com/</guid>
      <description>

&lt;p&gt;Welcome to part 2 in our contributing &lt;a href=&#34;http://localhost:1313/tags/contributing/&#34;&gt;series&lt;/a&gt;! The first &lt;a href=&#34;http://localhost:1313/article/how-to-find-a-programming-topic-to-write-about/&#34;&gt;article&lt;/a&gt; explained how to find a topic to write about. This article will show you how to submit your article to Perl.com for publication.&lt;/p&gt;

&lt;p&gt;Our source code is hosted on a &lt;a href=&#34;https://github.com/tpf/perldotcom&#34;&gt;public perldotcom GitHub repo&lt;/a&gt;, so the first thing you need to do is fork it so you have your own copy. Now clone your fork locally, and you should be ready to start making your changes.&lt;/p&gt;

&lt;h3 id=&#34;create-your-author-data&#34;&gt;Create your author data&lt;/h3&gt;

&lt;p&gt;Perl.com stores author profile data in the &lt;code&gt;data/author&lt;/code&gt; directory. As this is your first article, you&amp;rsquo;ll need to create an entry for yourself. Here&amp;rsquo;s mine (&lt;code&gt;data/author/david-farrell.json&lt;/code&gt;):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;{
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;David Farrell&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;key&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;david-farrell&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;bio&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;David is the editor of PerlTricks.com. An organizer of the [New York Perl Meetup](http://www.meetup.com/The-New-York-Perl-Meetup-Group/), he works for ZipRecruiter as a software developer.&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;image&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/images/author/david-farrell.jpg&amp;#34;&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;name&lt;/code&gt; - your author name that will be displayed in the article&lt;/li&gt;
&lt;li&gt;&lt;code&gt;key&lt;/code&gt; - a unique ascii-fied version of your name which should also match your author data filename (e.g. &amp;ldquo;david-farrell.json&amp;rdquo;). Use this later in the &lt;code&gt;authors&lt;/code&gt; array in your article frontmatter&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bio&lt;/code&gt; - your biography in markdown, so you can include links to your social media and other relevant sites&lt;/li&gt;
&lt;li&gt;&lt;code&gt;image&lt;/code&gt; - a square portrait/avatar jpeg image 500 pixels wide or smaller, ideally under 50kb in size. These go in the &lt;code&gt;static/images/author&lt;/code&gt; directory. If you don&amp;rsquo;t have an image or want to use one, use &lt;code&gt;/images/site/avatar.png&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you&amp;rsquo;ve setup everything correctly, later you should see a nicely formatted profile underneath your article body text:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/how-to-write-your-first-article-for-perl-com/profile.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;generate-an-empty-article-file&#34;&gt;Generate an empty article file&lt;/h3&gt;

&lt;p&gt;You can generate an empty article with the Perl script &lt;code&gt;bin/new-article&lt;/code&gt;. It requires &lt;code&gt;--title&lt;/code&gt;, &lt;code&gt;--category&lt;/code&gt;, &lt;code&gt;--description&lt;/code&gt; and &lt;code&gt;--author&lt;/code&gt; arguments. Use your &lt;code&gt;author&lt;/code&gt; key from your author data that you just created. It must be run from the root project directory, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ bin/new-article --title &#39;Some New Perl Article&#39; --author &#39;david-farrell&#39; --desc &#39;There is more than one way to do it&#39; \
  --category &#39;development&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the above command fails due to missing Perl dependencies, you can install them via &lt;code&gt;cpanm&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cpanm --installdeps .
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;refine-the-article-frontmatter&#34;&gt;Refine the article frontmatter&lt;/h3&gt;

&lt;p&gt;Every article is prefaced with &lt;a href=&#34;http://gohugo.io/content/front-matter/&#34;&gt;front matter&lt;/a&gt;, which will have been pre-populated by &lt;code&gt;bin/new-article&lt;/code&gt; script. Feel free to add tags to help classify the content of the article. We use lowercase, ascii-fied tag names (for examples see the &lt;a href=&#34;http://localhost:1313/tags/&#34;&gt;index&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Two other optional frontmatter properties are &lt;code&gt;thumbnail&lt;/code&gt; and &lt;code&gt;image&lt;/code&gt;. If you have an image you&amp;rsquo;d like to use as the cover image for your article, create a directory under &lt;code&gt;static/images&lt;/code&gt; with the same name as your article filename (without the file extension), and save the image there. The image should be landscape oriented, and smaller than 250kb. The script &lt;code&gt;bin/create-thumbnail&lt;/code&gt; can be used to generate a thumbnail for your article, it will update the article frontmatter too, so save your work before running it.&lt;/p&gt;

&lt;p&gt;You might be wondering why the &lt;code&gt;authors&lt;/code&gt; property is an array; this is so you can have multiple authors per article! If you&amp;rsquo;re collaborating with someone else, create their author data file and include their author key in the &lt;code&gt;authors&lt;/code&gt; property.&lt;/p&gt;

&lt;h3 id=&#34;write-the-article-content&#34;&gt;Write the article content&lt;/h3&gt;

&lt;p&gt;For writing guidance, our &lt;a href=&#34;https://github.com/tpf/perldotcom/blob/master/STYLE-GUIDE.md&#34;&gt;style guide&lt;/a&gt; describes the standards we aim for with Perl.com articles. It also has some tips to make your writing stand out. All articles are written in &lt;a href=&#34;https://guides.github.com/features/mastering-markdown/&#34;&gt;GitHub Flavored Markdown&lt;/a&gt;. There are a few conventions we use:&lt;/p&gt;

&lt;p&gt;For highlighted code syntax, use a fenced code block with the programming language name, e.g:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;```perl
  code
  code
  code
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Otherwise just use a code block (fenced or indented style) and it will be displayed in monospace on a dark background. This is used for showing data and terminal commands.&lt;/p&gt;

&lt;p&gt;Article subheadings are size &lt;code&gt;h2&lt;/code&gt;. So use the following construct:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Subtitle goes here
------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create links to CPAN modules with the &lt;code&gt;mcpan&lt;/code&gt; shortcode:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Business::ISBN](https://metacpan.org/pod/Business::ISBN)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create links to the official Perl documentation with either &lt;code&gt;perldoc&lt;/code&gt; or &lt;code&gt;perlfunc&lt;/code&gt; shortcodes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[perldelta](https://perldoc.perl.org/perldelta.html)
[sort](https://perldoc.perl.org/functions/sort.html)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Internal references to other articles can be created using &lt;a href=&#34;https://gohugo.io/extras/crossreferences/&#34;&gt;relref&lt;/a&gt;. So to link to the article &amp;ldquo;save space with bit arrays&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[save-space-with-bit-arrays](/article/save-space-with-bit-arrays/)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you&amp;rsquo;re not sure how to format something, grep the &lt;code&gt;content/article&lt;/code&gt; directory for examples and copy from them.&lt;/p&gt;

&lt;h3 id=&#34;view-your-article-locally&#34;&gt;View your article locally&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s all well and good drafting an article in Markdown, but it only comes to life when you can see how it looks in a browser. You can do that by running a local version of the site on your computer. You&amp;rsquo;ll need to install &lt;a href=&#34;http://gohugo.io&#34;&gt;Hugo&lt;/a&gt;. &lt;strong&gt;Warning&lt;/strong&gt; package managers&amp;rsquo; versions of hugo are often very out of date, you&amp;rsquo;re usually better off with a pre-compiled binary. The site has been tested with v0.59.0 and should build with the latest version of Hugo.&lt;/p&gt;

&lt;p&gt;From the root project directory, launch a local version of the site:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo server --buildDrafts --buildFuture
...
Web Server is available at http://localhost:1313/ (bind address 127.0.0.1)
Press Ctrl+C to stop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pay careful attention to the program output—if you see any errors, it probably means your draft article is not correctly formatted. Once those are fixed, navigate with a browser to the localhost address shown in the output, and you should see a version of Perl.com running on your computer with your draft article at the top of the homepage!&lt;/p&gt;

&lt;p&gt;If your page does not appear, check that Hugo sees it well:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo list drafts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo list future
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;refining-your-article&#34;&gt;Refining your article&lt;/h3&gt;

&lt;p&gt;Before your send us your article, check that your article:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Code examples work (test them!)&lt;/li&gt;
&lt;li&gt;Has no spelling errors&lt;/li&gt;
&lt;li&gt;Conforms to our &lt;a href=&#34;https://github.com/tpf/perldotcom/blob/master/STYLE-GUIDE.md&#34;&gt;style guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tip: when I&amp;rsquo;ve written my first draft, I find it helpful to review it the following morning. By looking at it afresh I often find improvements I can make.&lt;/p&gt;

&lt;h3 id=&#34;submit-a-pull-request&#34;&gt;Submit a pull request&lt;/h3&gt;

&lt;p&gt;Once the draft article looks good to you, it&amp;rsquo;s ready for a pull request. Commit your changes, push them to your repo and send us a pull request from GitHub. If the article looks suitable, we&amp;rsquo;ll merge the request and open a branch for editing. From their we&amp;rsquo;ll review it, edit it if necessary, and ask you to review our changes. If you&amp;rsquo;re happy with them, we&amp;rsquo;ll publish your article. Otherwise, we can continue the editing process: usually it doesn&amp;rsquo;t take more than a couple of cycles. Our goal is to preserve your voice whilst making sure the article meets our standards.&lt;/p&gt;

&lt;p&gt;Once the article is published we&amp;rsquo;ll let you know and promote it on social media. Congratulations, you&amp;rsquo;re a published Perl.com author now!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
Cover &lt;a href=&#34;https://www.flickr.com/photos/fidgetcircle/34743456922/in/photostream/&#34;&gt;image&lt;/a&gt; by &lt;a href=&#34;https://www.fidgetcircle.com&#34;&gt;www.fidgetcircle.com&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>XS utility routines that are good to know</title>
      <link>http://localhost:1313/article/xs-utility-routines-that-are-good-to-know/</link>
      <pubDate>Mon, 30 Apr 2018 20:34:45 +0000</pubDate>
      
      <guid>http://localhost:1313/article/xs-utility-routines-that-are-good-to-know/</guid>
      <description>

&lt;p&gt;In the previous &lt;a href=&#34;http://localhost:1313/article/writing-your-own-xs-functions/&#34;&gt;tutorial&lt;/a&gt;, we learned how to write our own functions in XS, how to process multiple arguments, and return different values, including &lt;code&gt;undef&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In this tutorial I&amp;rsquo;m going to cover some useful routines for common cases you&amp;rsquo;ll encounter when programming in XS. One that you&amp;rsquo;ve already seen is &lt;code&gt;SvOK&lt;/code&gt; which can tell you if a scalar is defined or not. Here are the new areas I&amp;rsquo;ll discuss:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Scheduling XS code to run at startup&lt;/li&gt;
&lt;li&gt;Handling tied variables&lt;/li&gt;
&lt;li&gt;Unicode tools&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When writing XS code, these are things you&amp;rsquo;ll often want to be aware of, and know how to handle.&lt;/p&gt;

&lt;h3 id=&#34;module-code&#34;&gt;Module Code&lt;/h3&gt;

&lt;p&gt;As before, we&amp;rsquo;ll define the module code to load our XS. This is all that&amp;rsquo;s required:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package XS::Tutorial::Three;
require XSLoader;

XSLoader::load();
1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That should be saved as &lt;code&gt;lib/XS/Tutorial/Three.pm&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;xs-code&#34;&gt;XS Code&lt;/h3&gt;

&lt;p&gt;The top of the XS file will look similar to the previous chapter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define PERL_NO_GET_CONTEXT // we&#39;ll define thread context if necessary (faster)
#include &amp;quot;EXTERN.h&amp;quot;         // globals/constant import locations
#include &amp;quot;perl.h&amp;quot;           // Perl symbols, structures and constants definition
#include &amp;quot;XSUB.h&amp;quot;           // xsubpp functions and macros

MODULE = XS::Tutorial::Three  PACKAGE = XS::Tutorial::Three
PROTOTYPES: ENABLE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remember to append any XS code after the &lt;code&gt;PROTOTYPES&lt;/code&gt; line. This should be saved as &lt;code&gt;lib/XS/Tutorial/Three.xs&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;scheduling-xs-code-to-run-at-startup&#34;&gt;Scheduling XS code to run at startup&lt;/h3&gt;

&lt;p&gt;Sometimes you&amp;rsquo;ll need to run some code before your XS functions can work. For example, &lt;a href=&#34;https://github.com/openvenues/libpostal&#34;&gt;libpostal&lt;/a&gt; has startup routines which populate data structures that must be called before the library can be used.&lt;/p&gt;

&lt;p&gt;You could code this in a &amp;ldquo;lazy&amp;rdquo; way, that is, inside the XS function, check to see if the init code has been run, and if not, run it before executing the rest of the function code.&lt;/p&gt;

&lt;p&gt;However XS offers another way to do it by using the &lt;code&gt;BOOT&lt;/code&gt; keyword. Any C code included below the keyword, will be executed during the startup process:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BOOT:
printf(&amp;quot;We&#39;re starting up!\n&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The boot section is terminated by the first empty line after the keyword.&lt;/p&gt;

&lt;h3 id=&#34;handling-tied-variables&#34;&gt;Handling tied variables&lt;/h3&gt;

&lt;p&gt;Tied variables are special variables that execute custom code when they are interacted with. But you never use them, so why worry about them? The
thing is if you&amp;rsquo;re writing code to be used by others, you can&amp;rsquo;t be sure that a caller won&amp;rsquo;t pass a tied variable to one of your XS functions. And unlike
regular Perl, XS does &lt;strong&gt;not&lt;/strong&gt; execute tied code automatically.&lt;/p&gt;

&lt;p&gt;XS does provide &lt;a href=&#34;https://perldoc.perl.org/perlapi.html#Magical-Functions&#34;&gt;functions&lt;/a&gt; for working with tied variables though. One you&amp;rsquo;ll see in a lot of XS code is &lt;code&gt;SvGETMAGIC&lt;/code&gt;. Imagine your function is passed a tied variable; it&amp;rsquo;s value will be undefined in XS, until you call &lt;code&gt;mg_get&lt;/code&gt; (&amp;ldquo;magic get&amp;rdquo;) on it, which calls &lt;code&gt;FETCH&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Unfortunately, &lt;code&gt;mg_get&lt;/code&gt; can only be called on tied scalars so you don&amp;rsquo;t want to call it on a regular scalar. That&amp;rsquo;s where &lt;code&gt;SvGETMAGIC&lt;/code&gt; comes in: if the scalar is
tied, it will call &lt;code&gt;mg_get&lt;/code&gt;, if not, nothing will happen.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s how you might use it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SV*
get_tied_value(SV *foo)

PPCODE:
  /* call FETCH() if it&#39;s a tied variable to populate the sv */
  SvGETMAGIC(foo);
  PUSHs(sv_2mortal(foo));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code declares an XS function called &lt;code&gt;get_tied_value&lt;/code&gt;, which accepts a scalar variable, and calls &lt;code&gt;SvGETMAGIC&lt;/code&gt; on it, returning the value, by pushing it onto the stack.&lt;/p&gt;

&lt;h4 id=&#34;magic&#34;&gt;Magic?&lt;/h4&gt;

&lt;p&gt;You might be wondering why functions dealing with tied variables are named &amp;ldquo;magic&amp;rdquo; or &amp;ldquo;mg&amp;rdquo;. The reason is that tied behavior for each variable is implemented via a pointer to a &lt;a href=&#34;https://perldoc.perl.org/perlguts.html#Magic-Virtual-Tables&#34;&gt;magic virtual table&lt;/a&gt; which is a structure containing function pointers to the tied behavior.&lt;/p&gt;

&lt;p&gt;Often the Perl C API will provide &lt;code&gt;mg&lt;/code&gt; (&amp;ldquo;magic&amp;rdquo;) and &lt;code&gt;nomg&lt;/code&gt; (&amp;ldquo;non magic&amp;rdquo;) variants of functions, so you can decide if you want to trigger the tied behavior.&lt;/p&gt;

&lt;h3 id=&#34;utf-8-tools&#34;&gt;UTF-8 tools&lt;/h3&gt;

&lt;p&gt;Perl has loads of tools for managing UTF-8 encoded text, but with XS you&amp;rsquo;re working in C, which does not. Start thinking about basic types like &lt;code&gt;char&lt;/code&gt;
and common assumptions in C code, and you&amp;rsquo;ll realize that multibyte characters can wreak havoc unless you handle them correctly.&lt;/p&gt;

&lt;p&gt;Fortunately, the Perl C API does provide &lt;a href=&#34;https://perldoc.perl.org/perlapi.html#Unicode-Support&#34;&gt;functions&lt;/a&gt; for managing UTF-8 data that
can help. Here are a couple of examples.&lt;/p&gt;

&lt;p&gt;Perl scalars have a UTF-8 flag, which is turned on when the scalar contains decoded UTF-8 data. We can detect it with &lt;code&gt;SvUTF8&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SV*
is_utf8(SV *foo)
PPCODE:
  /* if the UTF-8 flag is set return 1 &amp;quot;true&amp;quot; */
  if (SvUTF8(foo)) {
    PUSHs(sv_2mortal(newSViv(1)));
  }
  /* else return undef &amp;quot;false&amp;quot; */
  else {
    PUSHs(sv_newmortal());
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This declares an XS function called &lt;code&gt;is_utf8&lt;/code&gt; which accepts a scalar and returns true if the UTF-8 flag is set, or false if it isn&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;Imagine you have some C code that only works with ASCII text, that is, single byte characters. You can detect incoming scalars that have the UTF-8 flag turned on
with &lt;code&gt;SvUTF8&lt;/code&gt;, but what do you do about ones that have the flag?&lt;/p&gt;

&lt;p&gt;You could &lt;code&gt;croak&lt;/code&gt; immediately, throwing an exception. Or you could try to &lt;em&gt;downgrade&lt;/em&gt; the scalar to be non UTF-8 as the string may be marked as UTF-8 but only contain ASCII compatible characters (decimal values 0-127).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SV*
is_downgradeable(SV *foo)
PPCODE:
  /* if the UTF-8 flag is set and the scalar is not downgrade-able return
     undef */
  if (SvUTF8(foo) &amp;amp;&amp;amp; !sv_utf8_downgrade(foo, TRUE)) {
    PUSHs(sv_newmortal());
  }
  /* else return 1 */
  else {
    PUSHs(sv_2mortal(newSViv(1)));
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function returns false if the scalar contains data that is not downgrade-able to ASCII, otherwise it returns true. It does that by using the &lt;code&gt;sv_utf8_downgrade&lt;/code&gt; function, which accepts the scalar and a boolean value indicating if it&amp;rsquo;s ok to fail. As the second argument is &lt;code&gt;TRUE&lt;/code&gt;, the function simply returns false if the scalar is not downgrade-able (otherwise it would &lt;code&gt;croak&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Parts &lt;a href=&#34;http://localhost:1313/article/getting-started-with-xs/&#34;&gt;one&lt;/a&gt; and &lt;a href=&#34;http://localhost:1313/article/writing-your-own-xs-functions/&#34;&gt;two&lt;/a&gt; in this series contain the background information necessary to understand this one&lt;/li&gt;
&lt;li&gt;This series is also on CPAN (&lt;a href=&#34;https://metacpan.org/pod/XS::Tutorial&#34;&gt;XS::Tutorial&lt;/a&gt;) complete with all the code&lt;/li&gt;
&lt;li&gt;The &lt;a href=&#34;https://perldoc.perl.org/perlxs.html#The-BOOT%3a-Keyword&#34;&gt;BOOT&lt;/a&gt; keyword&lt;/li&gt;
&lt;li&gt;Tied variable &lt;a href=&#34;https://perldoc.perl.org/perlapi.html#Magical-Functions&#34;&gt;functions&lt;/a&gt; and the &lt;a href=&#34;https://perldoc.perl.org/perlguts.html#Magic-Virtual-Tables&#34;&gt;magic virtual table&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://perldoc.perl.org/perlapi.html#Unicode-Support&#34;&gt;Perl UTF-8 functions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
Cover image &amp;copy; &lt;a href=&#34;https://pixabay.com/en/plumbing-pipe-wrench-plumber-840835/&#34;&gt;Steve Buissinne&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to find a programming topic to write about</title>
      <link>http://localhost:1313/article/how-to-find-a-programming-topic-to-write-about/</link>
      <pubDate>Mon, 26 Mar 2018 21:40:37 +0000</pubDate>
      
      <guid>http://localhost:1313/article/how-to-find-a-programming-topic-to-write-about/</guid>
      <description>

&lt;p&gt;One thing I hear a lot when encouraging others to write about programming is &amp;ldquo;I don&amp;rsquo;t know what to write about&amp;rdquo;, and I agree it can hard to write anything when you&amp;rsquo;re not sure what to say. So before you open your text editor and stare at the blank screen hoping for inspiration, let me share with you some lines of investigation for picking a topic to write about.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;N.B.&lt;/strong&gt; we&amp;rsquo;ve recently created a desired articles &lt;a href=&#34;https://github.com/tpf/perldotcom/projects/1&#34;&gt;list&lt;/a&gt;, and we&amp;rsquo;re looking for writers. Have a look at the list of issues and if you see one you&amp;rsquo;d like to write, respond on the issue to volunteer to write the article.&lt;/p&gt;

&lt;h3 id=&#34;articles-as-stories&#34;&gt;Articles as stories&lt;/h3&gt;

&lt;p&gt;As humans &lt;a href=&#34;http://time.com/5043166/storytelling-evolution/&#34;&gt;stories resonate&lt;/a&gt; with us. So tell a story about some experience you had. It could be about a conference you visited, a module on CPAN that saved your bacon one time, or this weird bug you found (and submitted a patch for!). I often find inspiration for new topics at work.&lt;/p&gt;

&lt;p&gt;Another angle for this is to write about your company (perhaps they&amp;rsquo;re hiring Perl devs?): &amp;ldquo;here&amp;rsquo;s how we use Perl at Company X&amp;rdquo;.&lt;/p&gt;

&lt;h3 id=&#34;news-and-marketing&#34;&gt;News and Marketing&lt;/h3&gt;

&lt;p&gt;There are all kinds of new things happening in programming all the time; specifically in Perl there are conferences, Monger meetings, &lt;a href=&#34;https://metacpan.org/recent&#34;&gt;new CPAN releases&lt;/a&gt; and plus all kinds of &lt;a href=&#34;https://github.com/search?l=Perl&amp;amp;o=desc&amp;amp;q=perl&amp;amp;s=updated&amp;amp;type=Repositories&amp;amp;utf8=%E2%9C%93&#34;&gt;activity&lt;/a&gt; on GitHub.&lt;/p&gt;

&lt;p&gt;More broadly, popular sites like &lt;a href=&#34;https://news.ycombinator.com&#34;&gt;Hacker news&lt;/a&gt; and &lt;a href=&#34;arstechnica.com&#34;&gt;Ars Technica&lt;/a&gt; are a great source of interesting tech news that may inspire you to write. For example, when the Shellshock bug became big news, I wrote an &lt;a href=&#34;http://localhost:1313/article/118/2014/10/5/Neutralize-Shellshock-by-patching-Bash-with-Perl/&#34;&gt;article&lt;/a&gt; about patching it with Perl.&lt;/p&gt;

&lt;p&gt;Your writing doesn&amp;rsquo;t have to be entirely altruistic either: got a module / product / event to promote? Write about it.&lt;/p&gt;

&lt;h3 id=&#34;tutorials&#34;&gt;Tutorials&lt;/h3&gt;

&lt;p&gt;A great way to learn more about a topic is to write about it. Pick an aspect of Perl you&amp;rsquo;d like to know more about; or scour &lt;a href=&#34;http://perldoc.perl.org&#34;&gt;perldoc&lt;/a&gt; for something that catches your eye (e.g. do you know what the &lt;code&gt;link()&lt;/code&gt; function does?).&lt;/p&gt;

&lt;p&gt;Once you&amp;rsquo;ve picked something, read the documentation on it, play around with it, identify what you don&amp;rsquo;t understand about it, and hack on it until you do. Then google it to see what others have written about it, and figure out what you want to write.&lt;/p&gt;

&lt;p&gt;One thing I&amp;rsquo;d love to read more about is how certain features of Perl are coded in the source. The few times I&amp;rsquo;ve dumpster-dived into it to figure out an XS function, I&amp;rsquo;ve found myself drowning in C macros.&lt;/p&gt;

&lt;h3 id=&#34;the-bar-is-much-lower-than-you-think-it-is&#34;&gt;The bar is much lower than you think it is&lt;/h3&gt;

&lt;p&gt;Would-be writers often dismiss their own ideas as not being clever or original enough to be worth writing about. They imagine the bar for entry to be like this impenetrable cliff:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/e/ef/Eystfelli_a_cliff_on_Fugloy_Faroe_Islands.JPG/1024px-Eystfelli_a_cliff_on_Fugloy_Faroe_Islands.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;When really just out of shot there is a cafe with a nice hiking trail and cable car to take you to the top. With a programming language that has been around as long as Perl has, almost every topic has been touched upon at some point. That doesn&amp;rsquo;t mean the topic was written about well, or that it&amp;rsquo;s not time for a new perspective.&lt;/p&gt;

&lt;p&gt;People love reading new articles about their favorite programming language; just figure out what you want to write about, and start.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
Picture of Cliff by Eileen Sandá &lt;a href=&#34;https://creativecommons.org/licenses/by-sa/3.0&#34;&gt;CC BY-SA 3.0&lt;/a&gt; via &lt;a href=&#34;https://commons.wikimedia.org/wiki/File%3AEystfelli_a_cliff_on_Fugloy_Faroe_Islands.JPG&#34;&gt;Wikimedia Commons&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Cover image &lt;a href=&#34;https://pxhere.com/en/photo/928093&#34;&gt;pxphere.com&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Writing your own XS functions</title>
      <link>http://localhost:1313/article/writing-your-own-xs-functions/</link>
      <pubDate>Fri, 12 Jan 2018 08:28:40 +0000</pubDate>
      
      <guid>http://localhost:1313/article/writing-your-own-xs-functions/</guid>
      <description>

&lt;p&gt;In &lt;a href=&#34;http://localhost:1313/article/getting-started-with-xs/&#34;&gt;part one&lt;/a&gt;, we learned the basic components of XS, and integrated
two C functions into Perl. This chapter is going to show you how to define xsubs
that accept multiple parameters, and define your own logic, instead of using XS
as a Foreign Function Interface to a C library.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll need the files from &lt;a href=&#34;http://localhost:1313/article/getting-started-with-xs/&#34;&gt;part one&lt;/a&gt; to execute the code in this article.&lt;/p&gt;

&lt;h3 id=&#34;module-code&#34;&gt;Module Code&lt;/h3&gt;

&lt;p&gt;As before, we&amp;rsquo;ll define the module code to load our XS. This is all that&amp;rsquo;s
required:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;package&lt;/span&gt; XS::Tutorial::Two;
&lt;span style=&#34;color:#66d9ef&#34;&gt;require&lt;/span&gt; XSLoader;

XSLoader::load();
&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That should be saved as &lt;code&gt;lib/XS/Tutorial/Two.pm&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;xs-code&#34;&gt;XS Code&lt;/h3&gt;

&lt;p&gt;The top of the XS file will look similar to the previous chapter:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define PERL_NO_GET_CONTEXT &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// we&amp;#39;ll define thread context if necessary (faster)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;EXTERN.h&amp;#34;         // globals/constant import locations&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;perl.h&amp;#34;           // Perl symbols, structures and constants definition&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;XSUB.h&amp;#34;           // xsubpp functions and macros&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;stdint.h&amp;#34;         // portable integer types&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
MODULE &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; XS&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Tutorial&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Two  PACKAGE &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; XS&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Tutorial&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Two
PROTOTYPES: ENABLE&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Remember to append any XS code after the &lt;code&gt;PROTOTYPES&lt;/code&gt; line. This should be saved
as &lt;code&gt;lib/XS/Tutorial/Two.xs&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;adding-numbers&#34;&gt;Adding numbers&lt;/h3&gt;

&lt;p&gt;Here&amp;rsquo;s a simple declaration of an xsub that adds two integers:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;add_ints&lt;/span&gt; (addend1, addend2)
  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; addend1
  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; addend2
  CODE:
    RETVAL &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; addend1 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; addend2;
  OUTPUT:
    RETVAL&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This declares an xsub called &lt;code&gt;add_ints&lt;/code&gt; which accepts two integers and whose
return type is &lt;code&gt;int&lt;/code&gt;. Note the &lt;a href=&#34;https://stackoverflow.com/questions/1630631/alternative-kr-c-syntax-for-function-declaration-versus-prototypes&#34;&gt;K&amp;amp;R&lt;/a&gt; style of the function definition. This can also be written as:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;add_ints (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; addend1, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; addend2)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But you rarely see it done that way in the wild. I don&amp;rsquo;t know if that&amp;rsquo;s a cargo
cult thing or there are edge cases to the xsub compiler that I&amp;rsquo;m not aware of.
Just to be safe, I&amp;rsquo;ll keep doing it the way everyone else does (the cult
persists!).&lt;/p&gt;

&lt;p&gt;Whereas &lt;a href=&#34;http://localhost:1313/article/getting-started-with-xs/&#34;&gt;before&lt;/a&gt; we were essentially mapping C functions like &lt;code&gt;srand&lt;/code&gt; to Perl,
here we&amp;rsquo;re declaring our own logic: &lt;code&gt;add_ints&lt;/code&gt; isn&amp;rsquo;t imported from anywhere,
we&amp;rsquo;re declaring it as a new function.&lt;/p&gt;

&lt;p&gt;Since &lt;code&gt;add_ints&lt;/code&gt; is a new function, we need to define the logic of it, and
that&amp;rsquo;s where the &lt;code&gt;CODE&lt;/code&gt; section comes in. Here we can write C code which
forms the body of the function. In this example, I add the two subroutine
parameters together and assign the result to &lt;code&gt;RETVAL&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://perldoc.perl.org/perlxs.html#The-RETVAL-Variable&#34;&gt;RETVAL&lt;/a&gt; (&amp;ldquo;RETurn VALue&amp;rdquo;) is a special variable that is declared by the xsub processor
(xsubpp). The &lt;code&gt;OUTPUT&lt;/code&gt; section accepts the return variable for the xsub, placing
it on the stack, so that calling code will receive it.&lt;/p&gt;

&lt;h3 id=&#34;adding-more-than-two-numbers&#34;&gt;Adding more than two numbers&lt;/h3&gt;

&lt;p&gt;Adding two numbers is all well and good, but lists are the lingua franca of
Perl. Let&amp;rsquo;s update the &lt;code&gt;add_ints&lt;/code&gt; xsub to accept n values:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;int32_t
&lt;span style=&#34;color:#a6e22e&#34;&gt;add_ints&lt;/span&gt; (...)
  CODE:
    uint32_t i;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; items; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;SvOK(ST(i)) &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;SvIOK(ST(i)))
        croak(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;requires a list of integers&amp;#34;&lt;/span&gt;);

      RETVAL &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; SvIVX(ST(i));
    }
  OUTPUT:
    RETVAL&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;First off, notice I&amp;rsquo;ve updated the return value. One issue with using &lt;code&gt;int&lt;/code&gt; in
C is it may be a different size on different machine architectures. &lt;code&gt;int32_t&lt;/code&gt;
is from the &lt;code&gt;stdint.h&lt;/code&gt; library, and guaranteed to be a 32 bit signed integer.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve replaced the function parameters with &lt;code&gt;...&lt;/code&gt; which indicates the function
accepts a variable number of arguments, just like in C. In the &lt;code&gt;CODE&lt;/code&gt; section,
I declare a &lt;code&gt;uint32_t&lt;/code&gt; integer called &lt;code&gt;i&lt;/code&gt; (&lt;code&gt;uint32_t&lt;/code&gt; is a 32 bit unsigned
integer).&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;for&lt;/code&gt; loop uses the special variable &lt;code&gt;items&lt;/code&gt; (the number of arguments passed
to the function) to iterate over the arguments. The &lt;code&gt;if&lt;/code&gt; statement calls
the macro &lt;code&gt;ST&lt;/code&gt; to access the stack variable at position &lt;code&gt;i&lt;/code&gt;. This is used to
check that the scalar is defined (&lt;code&gt;SvOK&lt;/code&gt;) and that it is an integer (&lt;code&gt;SvIOK&lt;/code&gt;).
If either test fails, the code calls &lt;code&gt;croak&lt;/code&gt; to throw a fatal exception.&lt;/p&gt;

&lt;p&gt;Otherwise the integer value is extracted from the scalar (&lt;code&gt;SvIVX&lt;/code&gt;) and added
to &lt;code&gt;RETVAL&lt;/code&gt;. If all of these C macros look strange to you, don&amp;rsquo;t worry, they are
weird! They are part of the Perl C API, and they&amp;rsquo;re documented in &lt;a href=&#34;https://perldoc.perl.org/perlapi.html&#34;&gt;perlapi&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;edge-cases&#34;&gt;Edge cases&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s probably a good time to write some tests for this function, here&amp;rsquo;s a
start:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Test::More;

&lt;span style=&#34;color:#66d9ef&#34;&gt;BEGIN&lt;/span&gt; { use_ok &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;XS::Tutorial::Two&amp;#39;&lt;/span&gt; }

cmp_ok XS::Tutorial::Two::add_ints(&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;), &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;==&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
cmp_ok XS::Tutorial::Two::add_ints(&lt;span style=&#34;color:#ae81ff&#34;&gt;1500&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;21000&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;), &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;==&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;21500&lt;/span&gt;;

done_testing;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I saved that file as &lt;code&gt;t/two.t&lt;/code&gt;, and run it by building the distribution with
&lt;code&gt;make&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;perl Makefile.PL &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Do you know what the return value would be if &lt;code&gt;add_ints&lt;/code&gt; was called with no
arguments? Maybe &lt;code&gt;undef&lt;/code&gt;, since if there are no arguments, the for loop will
not have any iterations. Here&amp;rsquo;s a test for that condition:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;ok &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;defined XS::Tutorial::Two::add_ints(), &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;empty list returns undef&amp;#39;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Re-building and running the tests with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make clean &amp;amp;&amp;amp; perl Makefile.PL &amp;amp;&amp;amp;  make &amp;amp;&amp;amp; make test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That test fails, because the return value is zero! This is a quirk of C:
uninitialized integers can be zero. Let&amp;rsquo;s fix the xsub to return &lt;code&gt;undef&lt;/code&gt; when
it doesn&amp;rsquo;t receive any arguments:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;SV &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;add_ints&lt;/span&gt; (...)
  PPCODE:
    uint32_t i;
    int32_t total &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (items &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
      &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; items; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;SvOK(ST(i)) &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;SvIOK(ST(i)))
          croak(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;requires a list of integers&amp;#34;&lt;/span&gt;);

        total &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; SvIVX(ST(i));
      }
      PUSHs(sv_2mortal(newSViv(total)));
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
      PUSHs(sv_newmortal());
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Woah, quite a few changes! First I&amp;rsquo;ve changed the return type to &lt;code&gt;SV *&lt;/code&gt;, from
&lt;code&gt;int32_t&lt;/code&gt;. The reason for this will become clear in a moment.  The &lt;code&gt;CODE&lt;/code&gt; section
is now called &lt;code&gt;PPCODE&lt;/code&gt;, which tells xsubpp that we will be managing the return
value of xsub ourselves, hence the &lt;code&gt;OUTPUT&lt;/code&gt; section is gone.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve declared a new variable called &lt;code&gt;total&lt;/code&gt; to capture the running total of the
arguments as they&amp;rsquo;re added. If we received at least one argument, total is copied
into a new scalar integer value (&lt;code&gt;newSViv&lt;/code&gt;), its reference count is corrected
(&lt;code&gt;sv_2mortal&lt;/code&gt;) and it is pushed onto the stack pointer (&lt;code&gt;PUSHs&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Otherwise a new &lt;code&gt;undef&lt;/code&gt; scalar is declared with &lt;code&gt;sv_newmortal&lt;/code&gt; and that is pushed
onto the stack pointer instead. So in both cases we&amp;rsquo;re returning an &lt;code&gt;SV&lt;/code&gt;. And as
we&amp;rsquo;re returning a Perl type instead of a C type (&lt;code&gt;int32_t&lt;/code&gt;) there is no need for
xsubpp to cast our return value into a Perl scalar, we&amp;rsquo;re already doing it.&lt;/p&gt;

&lt;h3 id=&#34;wrap-up&#34;&gt;Wrap up&lt;/h3&gt;

&lt;p&gt;This tutorial has covered some critical skills for writing xsubs: how to accept
multiple parameters, how to write your own logic, and how to manage the stack
pointer. If you grok all of these, and the content of &lt;a href=&#34;http://localhost:1313/article/getting-started-with-xs/&#34;&gt;part one&lt;/a&gt;
you have enough to get started writing your own XS code.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;This documentation and code is on CPAN (&lt;a href=&#34;https://metacpan.org/pod/XS::Tutorial&#34;&gt;XS::Tutorial&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://perldoc.perl.org/perlxs.html&#34;&gt;perlxs&lt;/a&gt; defines the keywords recognized by &lt;a href=&#34;https://perldoc.perl.org/xsubpp.html&#34;&gt;xsubpp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://perldoc.perl.org/perlapi.html&#34;&gt;perlapi&lt;/a&gt; lists the C macros used to interact with Perl data structures (and the interpreter)&lt;/li&gt;
&lt;li&gt;The &lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdint.h.html&#34;&gt;stdint.h&lt;/a&gt; C library provides sets of portable integer types&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Getting started with XS</title>
      <link>http://localhost:1313/article/getting-started-with-xs/</link>
      <pubDate>Wed, 03 May 2017 20:47:51 +0000</pubDate>
      
      <guid>http://localhost:1313/article/getting-started-with-xs/</guid>
      <description>

&lt;p&gt;eXtendable Subroutines (XS) are subroutines written in C that are callable from
Perl code. There are two common reasons you&amp;rsquo;d want to use XS: there is a C
library you&amp;rsquo;d like to use with Perl, or you want to make a subroutine faster
by processing it in C instead of Perl.&lt;/p&gt;

&lt;p&gt;This tutorial will walk you through all the components needed to get up and
running with a basic XS example. There will be a lot of new terms and concepts:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you want to write XS, you have to learn it. Learning XS is very difficult&lt;/p&gt;

&lt;p&gt;Steven W. McDougall&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Try not to get discouraged if things don&amp;rsquo;t click right away: I promise you that
learning XS can be hugely rewarding: you&amp;rsquo;ll develop the power to write lightning
fast code; get a better understanding of how Perl internals work, and be able to
integrate any C library you choose and use it from Perl.&lt;/p&gt;

&lt;h3 id=&#34;components&#34;&gt;Components&lt;/h3&gt;

&lt;p&gt;There are a few basic components needed to write an xsub. The first is a Perl
module that will provide the namespace for any XS functions. This is all that&amp;rsquo;s
needed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package XS::Tutorial::One;
require XSLoader;

XSLoader::load();
1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This file should be saved as &lt;code&gt;lib/XS/Tutorial/One.pm&lt;/code&gt;. &lt;code&gt;XSLoader::load&lt;/code&gt; by
default searches for XS code that matches the package name it is called from*.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s create a main distribution module too:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package XS::Tutorial;
BEGIN { our $VERSION = 0.01 }
1;

=encoding utf8

=head1 NAME

XS::Tutorial - documentation with examples for learning Perl XS

=cut
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That file should be saved as &lt;code&gt;lib/XS/Tutorial.pm&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The next thing we need is a .xs file which defines the xsubs to be loaded by
&lt;code&gt;XS::Tutorial::One&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define PERL_NO_GET_CONTEXT // we&#39;ll define thread context if necessary (faster)
#include &amp;quot;EXTERN.h&amp;quot;         // globals/constant import locations
#include &amp;quot;perl.h&amp;quot;           // Perl symbols, structures and constants definition
#include &amp;quot;XSUB.h&amp;quot;           // xsubpp functions and macros
#include &amp;lt;stdlib.h&amp;gt;         // rand()

// additional c code goes here

MODULE = XS::Tutorial::One  PACKAGE = XS::Tutorial::One
PROTOTYPES: ENABLE

 # XS code goes here

 # XS comments begin with &amp;quot; #&amp;quot; to avoid them being interpreted as pre-processor
 # directives

unsigned int
rand()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This file should be saved as &lt;code&gt;lib/XS/Tutorial/One.xs&lt;/code&gt;. The top half of the file
is pure C code. The line beginning &lt;code&gt;MODULE = XS::Tutorial::One&lt;/code&gt; indicates the
start of the XS code. This section will be parsed and compiled into C code by
&lt;code&gt;xsubpp&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;MODULE&lt;/code&gt; and &lt;code&gt;PACKAGE&lt;/code&gt; directives define the Perl module and package which
will load any xsubs we define. The line &lt;code&gt;PROTOTYPES: ENABLE&lt;/code&gt; tells &lt;code&gt;xsubpp&lt;/code&gt;
to define subroutine prototypes for any xsubs we create. This is usually what
you want: prototypes can help Perl catch compile time errors.&lt;/p&gt;

&lt;p&gt;The last two lines of the file are an xsub:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unsigned int
rand()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first line defines the return type. The second line does two things: it
indicates the name of the C function to be called &lt;em&gt;and&lt;/em&gt; it defines the
signature of the xsub.&lt;/p&gt;

&lt;p&gt;In this case we&amp;rsquo;re calling &lt;code&gt;rand&lt;/code&gt; and accepting no parameters. This isn&amp;rsquo;t
Perl&amp;rsquo;s built-in rand function, &lt;em&gt;this&lt;/em&gt; rand comes from stdlib.h.&lt;/p&gt;

&lt;p&gt;The final thing we need is a &lt;code&gt;Makefile.PL&lt;/code&gt; script - as XS code is compiled, we
need a tool to build it before we can use it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use 5.008005;
use ExtUtils::MakeMaker 7.12; # for XSMULTI option

WriteMakefile(
  NAME           =&amp;gt; &#39;XS::Tutorial&#39;,
  VERSION_FROM   =&amp;gt; &#39;lib/XS/Tutorial.pm&#39;,
  PREREQ_PM      =&amp;gt; { &#39;ExtUtils::MakeMaker&#39; =&amp;gt; &#39;7.12&#39; },
  ABSTRACT_FROM  =&amp;gt; &#39;lib/XS/Tutorial.pm&#39;,
  AUTHOR         =&amp;gt; &#39;David Farrell&#39;,
  CCFLAGS        =&amp;gt; &#39;-Wall -std=c99&#39;,
  OPTIMIZE       =&amp;gt; &#39;-O3&#39;,
  LICENSE        =&amp;gt; &#39;freebsd&#39;,
  XSMULTI        =&amp;gt; 1,
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The ExtUtils::MakeMaker &lt;a href=&#34;https://metacpan.org/pod/ExtUtils::MakeMaker&#34;&gt;docs&lt;/a&gt; explain these options.&lt;/p&gt;

&lt;p&gt;But let&amp;rsquo;s talk about &lt;code&gt;XSMULTI&lt;/code&gt;. This is a relatively new feature which allows
you to have separate .xs files for modules. By default EUMM assumes the xs
file matches the distribution name. In this case that would mean having a single
Tutorial.xs file, with multiple xs &lt;code&gt;MODULE&lt;/code&gt; and &lt;code&gt;PACKAGE&lt;/code&gt; declarations in it.
By using &lt;code&gt;XSMULTI&lt;/code&gt;, we can have multiple XS files, one for each module in the
distribution instead.&lt;/p&gt;

&lt;p&gt;*Actually it searches for compiled C code but the effect is the same.&lt;/p&gt;

&lt;h3 id=&#34;building&#34;&gt;Building&lt;/h3&gt;

&lt;p&gt;Now we should have four files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lib/XS/Tutorial.pm
lib/XS/Tutorial/One.pm
lib/XS/Tutorial/One.xs
Makefile.PL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following commands will build the distribution:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl Makefile.PL
$ make
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-minor-essay-to-understand-xsubpp-generated-c&#34;&gt;A minor essay to understand xsubpp generated C&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;make&lt;/code&gt; creates a bunch of files, but take a look at &lt;code&gt;lib/XS/Tutorial/One.c&lt;/code&gt;.
This is the output of &lt;code&gt;xsubpp&lt;/code&gt;. If you look closely enough, you can find the
lines of C code from &lt;code&gt;lib/XS/Tutorial/One.xs&lt;/code&gt; in there. But checkout what
happened to our &lt;code&gt;rand&lt;/code&gt; xsub:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;XS_EUPXS(XS_XS__Tutorial__One_rand); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_XS__Tutorial__One_rand)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  &amp;quot;&amp;quot;);
    {
  unsigned int        RETVAL;
  dXSTARG;

  RETVAL = rand();
  XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;xsubpp&lt;/code&gt; has replaced our XS code with some rather ugly C macros! These macros
are part of the Perl interpreter&amp;rsquo;s C API. Many are documented in &lt;a href=&#34;https://perldoc.perl.org/perlapi.html&#34;&gt;perlapi&lt;/a&gt;
and they are usually defined in &lt;code&gt;XSUB.h&lt;/code&gt; or &lt;code&gt;perl.h&lt;/code&gt; in the Perl source code.&lt;/p&gt;

&lt;p&gt;So what are these macros doing? At a high level, &lt;code&gt;dVAR&lt;/code&gt; and &lt;code&gt;dXSARGS&lt;/code&gt; setup
the global pointer stack and some local variables. &lt;code&gt;items&lt;/code&gt; is a count of the
arguments supplied to the xsub. As &lt;code&gt;rand&lt;/code&gt; is a void function, if this isn&amp;rsquo;t
zero, it croaks. &lt;code&gt;croak_xs_usage&lt;/code&gt; takes a coderef and an args string. In this
context &lt;code&gt;cv&lt;/code&gt; is the xsub, and there are no args so the string is empty.&lt;/p&gt;

&lt;p&gt;Next the code declares &lt;code&gt;RETVAL&lt;/code&gt;, the return value of the xsub. &lt;code&gt;dXTARG&lt;/code&gt;
initializes the &lt;code&gt;TARG&lt;/code&gt; pointer. Next &lt;code&gt;rand()&lt;/code&gt; is called its return value
assigned to &lt;code&gt;RETVAL&lt;/code&gt;. &lt;code&gt;XSprePUSH&lt;/code&gt; moves the stack pointer back one,
and &lt;code&gt;PUSHu&lt;/code&gt; copies &lt;code&gt;RETVAL&lt;/code&gt; into &lt;code&gt;TARG&lt;/code&gt; and pushes it onto the global stack
pointer. &lt;code&gt;XSRETURN&lt;/code&gt; returns from the xsub, indicating how many arguments it
added to the stack, which in this case, is one.&lt;/p&gt;

&lt;p&gt;Writing XS, you usually don&amp;rsquo;t need to study the generated C code, but it&amp;rsquo;s
helpful to have an awareness of the process.&lt;/p&gt;

&lt;h3 id=&#34;installing&#34;&gt;Installing&lt;/h3&gt;

&lt;p&gt;Now the code is compiled, install it with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you&amp;rsquo;re using system Perl, you may need to use &lt;code&gt;sudo&lt;/code&gt; to install. Now we can
test the module using a one liner:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl -MXS::Tutorial::One -E &#39;say XS::Tutorial::One::rand()&#39;
1804289383
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It works! Did you try running it twice though?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl -MXS::Tutorial::One -E &#39;say XS::Tutorial::One::rand()&#39;
1804289383
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We get the same pseudorandom sequence each time&amp;hellip; We need to call &lt;code&gt;srand&lt;/code&gt; to
seed the sequence. That function is already provided by &lt;code&gt;stdlib.h&lt;/code&gt;, so all we
need to do is append the following text to &lt;code&gt;lib/XS/Tutorial/One.xs&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void
srand(seed)
  unsigned int seed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This xsub is different to the first one: its return type is &lt;code&gt;void&lt;/code&gt; which
means it returns nothing. It also includes a parameter called &lt;code&gt;seed&lt;/code&gt; in its
signature, and the last line defines it as an unsigned int.&lt;/p&gt;

&lt;p&gt;Rebuild and install the distribution:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can seed the pseudorandom sequence by calling &lt;code&gt;srand&lt;/code&gt; before &lt;code&gt;rand&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl -MXS::Tutorial::One -E &#39;XS::Tutorial::One::srand(777);\
say XS::Tutorial::One::rand()&#39;
947371799
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We used a lucky (777) seed number, and &lt;code&gt;rand&lt;/code&gt; emitted a different number, yay!&lt;/p&gt;

&lt;h3 id=&#34;did-we-beat-perl&#34;&gt;Did we beat Perl?&lt;/h3&gt;

&lt;p&gt;As you know by now, xsubs are often faster than pure Perl code. We&amp;rsquo;ve built two
xsubs for &lt;code&gt;rand&lt;/code&gt; and &lt;code&gt;srand&lt;/code&gt;, which are also available as built-in functions
in Perl. Do you think the xsubs are faster? Here&amp;rsquo;s a benchmark from my machine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;              Rate xs_rand bi_rand
xs_rand 15691577/s      --    -64%
bi_rand 43095739/s    175%      --
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oh no! Despite our &lt;code&gt;rand&lt;/code&gt; xsub directly calling the C &lt;code&gt;stdlib&lt;/code&gt; function, it&amp;rsquo;s
miles slower than Perl&amp;rsquo;s built-in &lt;code&gt;rand&lt;/code&gt;. This isn&amp;rsquo;t because xsubs are slow,
rather that Perl&amp;rsquo;s built-in functions are really fast. There is an overhead
associated with calling xsubs which built-in functions do not pay.&lt;/p&gt;

&lt;h3 id=&#34;tests&#34;&gt;Tests&lt;/h3&gt;

&lt;p&gt;Instead of running one liners to check our code works, we can write unit tests.
Here&amp;rsquo;s a basic script:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/perl
use Test::More;

BEGIN { use_ok &#39;XS::Tutorial::One&#39; }

ok my $rand = XS::Tutorial::One::rand(), &#39;rand()&#39;;
like $rand, qr/^\d+$/, &#39;rand() returns a number&#39;;

ok !defined XS::Tutorial::One::srand(5), &#39;srand()&#39;;
ok $rand ne XS::Tutorial::One::rand(), &#39;after srand, rand returns different number&#39;;
done_testing;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Save this file as &lt;code&gt;t/one.t&lt;/code&gt;. Assuming you built and installed the distribution
already, you can just do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl t/one.t
ok 1 - use XS::Tutorial::One;
ok 2 - rand()
ok 3 - rand() returns a number
ok 4 - srand()
ok 5 - after srand, rand returns different number
1..5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now when building the distribution in the future, you should do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl Makefile.PL &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will rebuild and test the distribution. Because XS code is compiled,
writing tests and using that one liner, you can quickly cycle through coding
and testing.&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t forget to add Test::More to the &lt;code&gt;PREREQ_PM&lt;/code&gt; entry in &lt;code&gt;Makefile.PL&lt;/code&gt;. When
you don&amp;rsquo;t have a specific minimum version, you can just use 0:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PREREQ_PM =&amp;gt; { &#39;Test::More&#39; =&amp;gt; 0, &#39;ExtUtils::MakeMaker&#39; =&amp;gt; &#39;7.12&#39; },
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;cleanup&#34;&gt;Cleanup&lt;/h3&gt;

&lt;p&gt;Building distributions generates a lot of temporary files. ExtUtils::MakeMaker
provides a realclean routine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ make realclean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will delete all the build files and reset the working directory to normal.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;This article and code are on CPAN as &lt;a href=&#34;https://metacpan.org/pod/XS::Tutorial::One&#34;&gt;XS::Tutorial::One&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;XS Mechanics by Steven W. McDougall is my second favorite :) XS &lt;a href=&#34;http://world.std.com/~swmcd/steven/perl/pm/xs/intro/&#34;&gt;tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://perldoc.perl.org/perlxs.html&#34;&gt;perlxs&lt;/a&gt; defines the keywords recognized by &lt;a href=&#34;https://perldoc.perl.org/xsubpp.html&#34;&gt;xsubpp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://perldoc.perl.org/perlapi.html&#34;&gt;perlapi&lt;/a&gt; : C macros used to interact with Perl data structures (and the interpreter)&lt;/li&gt;
&lt;li&gt;The &lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/9699919799/&#34;&gt;stdlib.h&lt;/a&gt; man page defines the C standard library functions and types&lt;/li&gt;
&lt;li&gt;For writing Makefile.PL files: ExtUtils::MakeMaker &lt;a href=&#34;https://metacpan.org/pod/ExtUtils::MakeMaker&#34;&gt;docs&lt;/a&gt; are invaluable&lt;/li&gt;
&lt;li&gt;Perl&amp;rsquo;s built-in &lt;a href=&#34;https://perldoc.perl.org/functions/rand.html&#34;&gt;rand&lt;/a&gt; and &lt;a href=&#34;https://perldoc.perl.org/functions/srand.html&#34;&gt;srand&lt;/a&gt; functions&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Beginner&#39;s Introduction to Perl 5.10, Part 2</title>
      <link>http://localhost:1313/pub/2008/05/07/beginners-introduction-to-perl-510-part-2.html/</link>
      <pubDate>Wed, 07 May 2008 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2008/05/07/beginners-introduction-to-perl-510-part-2.html/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/pub/2008/04/23/a-beginners-introduction-to-perl-510.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Perl 5.10&lt;/a&gt; talked about the core elements of Perl: variables (scalars, arrays, and hashes), math operators and some basic flow control (the &lt;code&gt;for&lt;/code&gt; statement). Now it&amp;rsquo;s time to interact with the world. (&lt;a href=&#34;http://news.oreilly.com/2008/06/a-beginners-introduction-to-pe.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Regular Expressions with Perl 5.10&lt;/a&gt; explores regular expressions, matching, and substitutions. &lt;a href=&#34;http://broadcast.oreilly.com/2008/09/a-beginners-introduction-to-pe.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Perl Web Programming&lt;/a&gt; demonstrates how to write web programs.)&lt;/p&gt;

&lt;p&gt;This installment discusses how to slice and dice strings, how to play with files and how to define your own functions. First, you need to understand one more core concept of the Perl language: conditions and comparisons.&lt;/p&gt;

&lt;h3 id=&#34;comparison-operators&#34;&gt;Comparison operators&lt;/h3&gt;

&lt;p&gt;Like all good programming languages, Perl allows you ask questions such as &amp;ldquo;Is this number greater than that number?&amp;rdquo; or &amp;ldquo;Are these two strings the same?&amp;rdquo; and do different things depending on the answer.&lt;/p&gt;

&lt;p&gt;When you&amp;rsquo;re dealing with numbers, Perl has four important operators: &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;. These are the &amp;ldquo;less than,&amp;rdquo; &amp;ldquo;greater than,&amp;rdquo; &amp;ldquo;equal to&amp;rdquo; and &amp;ldquo;not equal to&amp;rdquo; operators. (You can also use &lt;code&gt;&amp;lt;=&lt;/code&gt;, &amp;ldquo;less than or equal to,&amp;rdquo; and &lt;code&gt;&amp;gt;=&lt;/code&gt;, &amp;ldquo;greater than or equal to.)&lt;/p&gt;

&lt;p&gt;You can use these operators along with one of Perl&amp;rsquo;s &lt;em&gt;conditional&lt;/em&gt; keywords, such as &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;unless&lt;/code&gt;. Both of these keywords take a condition that Perl will test, and a block of code in curly brackets that Perl will run if the test works. These two words work just like their English equivalents &amp;ndash; an &lt;code&gt;if&lt;/code&gt; test succeeds if the condition turns out to be true, and an &lt;code&gt;unless&lt;/code&gt; test succeeds if the condition turns out to be false:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use 5.010;

if ($year_according_to_computer == 1900) {
    say &amp;quot;Y2K has doomed us all!  Everyone to the compound.&amp;quot;;
}

unless ($bank_account &amp;gt; 0) {
    say &amp;quot;I&#39;m broke!&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Be careful of the difference between &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt;! One equals sign means &amp;ldquo;assignment&amp;rdquo;, two means &amp;ldquo;comparison for equality&amp;rdquo;. This is a common, evil bug:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use 5.010;

if ($a = 5) {
    say &amp;quot;This works - but doesn&#39;t do what you want!&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may be asking what that extra line of code at the start does. Just like the &lt;code&gt;use feature :5.10;&lt;/code&gt; code from the previous article, this enables new features of Perl 5.10. (Why 5.010 and not 5.10? The version number is not a single decimal; there may eventually be a Perl 5.100, but probably not a Perl 5.1000. Just trust me on this for now.)&lt;/p&gt;

&lt;p&gt;Instead of testing whether &lt;code&gt;$a&lt;/code&gt; is equal to five, you&amp;rsquo;ve made &lt;code&gt;$a&lt;/code&gt; equal to five and clobbered its old value. (A future article will show how to avoid this bug in running code.)&lt;/p&gt;

&lt;p&gt;Both &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;unless&lt;/code&gt; can be followed by an &lt;code&gt;else&lt;/code&gt; statement and code block, which executes if your test failed. You can also use &lt;code&gt;elsif&lt;/code&gt; to chain together a bunch of &lt;code&gt;if&lt;/code&gt; statements:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use 5.010;

if ($a == 5) {
    say &amp;quot;It&#39;s five!&amp;quot;;
} elsif ($a == 6) {
    say &amp;quot;It&#39;s six!&amp;quot;;
} else {
    say &amp;quot;It&#39;s something else.&amp;quot;;
}

unless ($pie eq &#39;apple&#39;) {
    say &amp;quot;Ew, I don&#39;t like $pie flavored pie.&amp;quot;;
} else {
    say &amp;quot;Apple!  My favorite!&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You don&amp;rsquo;t always need an &lt;code&gt;else&lt;/code&gt; condition, and sometimes the code to execute fits on a single line. In that case, you can use &lt;em&gt;postfix conditional&lt;/em&gt; statements. The name may sound daunting, but you already understand them if you can read this sentence.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use 5.010;

say &amp;quot;I&#39;m leaving work early!&amp;quot; if $day eq &#39;Friday&#39;;

say &amp;quot;I&#39;m burning the 7 pm oil&amp;quot; unless $day eq &#39;Friday&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sometimes this can make your code clearer.&lt;/p&gt;

&lt;h3 id=&#34;while-and-until&#34;&gt;&lt;code&gt;while&lt;/code&gt; and &lt;code&gt;until&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Two slightly more complex keywords are &lt;code&gt;while&lt;/code&gt; and &lt;code&gt;until&lt;/code&gt;. They both take a condition and a block of code, just like &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;unless&lt;/code&gt;, but they act like loops similar to &lt;code&gt;for&lt;/code&gt;. Perl tests the condition, runs the block of code and runs it over and over again for as long as the condition is true (for a &lt;code&gt;while&lt;/code&gt; loop) or false (for a &lt;code&gt;until&lt;/code&gt; loop).&lt;/p&gt;

&lt;p&gt;Try to guess what this code will do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use 5.010;

my $count = 0;

while ($count != 3) {
   $count++;
   say &amp;quot;Counting up to $count...&amp;quot;;
}

until ($count == 0) {
   $count--;
   say &amp;quot;Counting down to $count...&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s what you see when you run this program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Counting up to 1...
Counting up to 2...
Counting up to 3...
Counting down to 2...
Counting down to 1...
Counting down to 0...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;string-comparisons&#34;&gt;String comparisons&lt;/h3&gt;

&lt;p&gt;That&amp;rsquo;s how you compare numbers. What about strings? The most common string comparison operator is &lt;code&gt;eq&lt;/code&gt;, which tests for &lt;em&gt;string equality&lt;/em&gt; &amp;ndash; that is, whether two strings have the same value.&lt;/p&gt;

&lt;p&gt;Remember the pain of mixing up &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt;? You can also mix up &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;eq&lt;/code&gt;. This is one of the few cases where it &lt;em&gt;does&lt;/em&gt; matter whether Perl treats a value as a string or a number. Try this code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use 5.010;

my $yes_no = &#39;no&#39;;
say &amp;quot;How positive!&amp;quot; if $yes_no == &#39;yes&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Why does this code think you said yes? Remember that Perl automatically converts strings to numbers whenever it&amp;rsquo;s necessary; the &lt;code&gt;==&lt;/code&gt; operator implies that you&amp;rsquo;re using numbers, so Perl converts the value of &lt;code&gt;$yes_no&lt;/code&gt; (&amp;ldquo;no&amp;rdquo;) to the number 0, and &amp;ldquo;yes&amp;rdquo; to the number 0 as well. Because this equality test works (0 is equal to 0), the condition is true. Change the condition to &lt;code&gt;$yes_no eq &#39;yes&#39;&lt;/code&gt;, and it&amp;rsquo;ll do what it should.&lt;/p&gt;

&lt;p&gt;Things can work the other way, too. The number five is &lt;em&gt;numerically&lt;/em&gt; equal to the string &lt;code&gt;&amp;quot; 5 &amp;quot;&lt;/code&gt;, so comparing them to &lt;code&gt;==&lt;/code&gt; works. When you compare five and &lt;code&gt;&amp;quot; 5 &amp;quot;&lt;/code&gt; with &lt;code&gt;eq&lt;/code&gt;, Perl will convert the number to the string &lt;code&gt;&amp;quot;5&amp;quot;&lt;/code&gt; first, and then ask whether the two strings have the same value. Because they don&amp;rsquo;t, the &lt;code&gt;eq&lt;/code&gt; comparison fails. This code fragment will print &lt;code&gt;Numeric equality!&lt;/code&gt;, but not &lt;code&gt;String equality!&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use 5.010;

my $five = 5;

say &amp;quot;Numeric equality!&amp;quot; if $five == &amp;quot; 5 &amp;quot;;
say &amp;quot;String equality!&amp;quot;  if $five eq &amp;quot; 5 &amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;more-fun-with-strings&#34;&gt;More fun with strings&lt;/h3&gt;

&lt;p&gt;You&amp;rsquo;ll often want to manipulate strings: Break them into smaller pieces, put them together and change their contents. Perl offers three functions that make string manipulation easy and fun: &lt;code&gt;substr()&lt;/code&gt;, &lt;code&gt;split()&lt;/code&gt;, and &lt;code&gt;join()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If you want to retrieve part of a string (say, the first four characters or a 10-character chunk from the middle), use the &lt;code&gt;substr()&lt;/code&gt; function. It takes either two or three parameters: the string you want to look at, the character position to start at (the first character is position 0) and the number of characters to retrieve. If you leave out the number of characters, you&amp;rsquo;ll retrieve everything up to the end of the string.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $greeting = &amp;quot;Welcome to Perl!\n&amp;quot;;

print substr($greeting, 0, 7);     # &amp;quot;Welcome&amp;quot;
print substr($greeting, 7);        # &amp;quot; to Perl!\n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A neat and often-overlooked thing about &lt;code&gt;substr()&lt;/code&gt; is that you can use a &lt;em&gt;negative&lt;/em&gt; character position. This will retrieve a substring that begins with many characters from the &lt;em&gt;end&lt;/em&gt; of the string.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $greeting = &amp;quot;Welcome to Perl!\n&amp;quot;;

print substr($greeting, -6, 4);      # &amp;quot;Perl&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Remember that inside double quotes, &lt;code&gt;\n&lt;/code&gt; represents the single new-line character.)&lt;/p&gt;

&lt;p&gt;You can also manipulate the string by using &lt;code&gt;substr()&lt;/code&gt; to assign a new value to part of it. One useful trick is using a length of zero to &lt;em&gt;insert&lt;/em&gt; characters into a string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $greeting = &amp;quot;Welcome to Java!\n&amp;quot;;

substr($greeting, 11, 4) = &#39;Perl&#39;;    # $greeting is now &amp;quot;Welcome to Perl!\n&amp;quot;;
substr($greeting, 7, 3)  = &#39;&#39;;        #       ... &amp;quot;Welcome Perl!\n&amp;quot;;
substr($greeting, 0, 0)  = &#39;Hello. &#39;; #       ... &amp;quot;Hello. Welcome Perl!\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;split()&lt;/code&gt; breaks apart a string and returns a list of the pieces. &lt;code&gt;split()&lt;/code&gt; generally takes two parameters: a &lt;em&gt;regular expression&lt;/em&gt; to split the string with and the string you want to split. (The next article will discuss regular expressions in more detail; for the moment, all you need to know is that this regular expression represents a single space character: &lt;code&gt;/ /&lt;/code&gt;.) The characters you split won&amp;rsquo;t show up in any of the list elements.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $greeting = &amp;quot;Hello. Welcome Perl!\n&amp;quot;;
my @words    = split(/ /, $greeting);   # Three items: &amp;quot;Hello.&amp;quot;, &amp;quot;Welcome&amp;quot;, &amp;quot;Perl!\n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also specify a third parameter: the maximum number of items to put in your list. The splitting will stop as soon as your list contains that many items:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $greeting = &amp;quot;Hello. Welcome Perl!\n&amp;quot;;
my @words    = split(/ /, $greeting, 2);   # Two items: &amp;quot;Hello.&amp;quot;, &amp;quot;Welcome Perl!\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, what you can split, you can also &lt;code&gt;join()&lt;/code&gt;. The &lt;code&gt;join()&lt;/code&gt; function takes a list of strings and attaches them together with a specified string between each element, which may be an empty string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my @words         = (&amp;quot;Hello.&amp;quot;, &amp;quot;Welcome&amp;quot;, &amp;quot;Perl!\n&amp;quot;);
my $greeting      = join(&#39; &#39;, @words);       # &amp;quot;Hello. Welcome Perl!\n&amp;quot;;
my $andy_greeting = join(&#39; and &#39;, @words);   # &amp;quot;Hello. and Welcome and Perl!\n&amp;quot;;
my $jam_greeting  = join(&#39;&#39;, @words);        # &amp;quot;Hello.WelcomePerl!\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;filehandles&#34;&gt;Filehandles&lt;/h3&gt;

&lt;p&gt;That&amp;rsquo;s enough about strings. It&amp;rsquo;s time to consider files &amp;ndash; after all, what good is string manipulation if you can&amp;rsquo;t do it where it counts?&lt;/p&gt;

&lt;p&gt;To read from or write to a file, you have to &lt;em&gt;open&lt;/em&gt; it. When you open a file, Perl asks the operating system if the file is accessible &amp;ndash; does the file exist if you&amp;rsquo;re trying to read it (or can it be created if you&amp;rsquo;re trying to create a new file), and do you have the necessary file permissions to do what you want? If you&amp;rsquo;re allowed to use the file, the operating system will prepare it for you, and Perl will give you a &lt;em&gt;filehandle&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ask Perl to create a filehandle for you by using the &lt;code&gt;open()&lt;/code&gt; function, which takes two or three arguments: the filehandle you want to create, the mode of the file, and the file you want to work with. First, we&amp;rsquo;ll concentrate on reading files. The following statement opens the file &lt;em&gt;log.txt&lt;/em&gt; using the filehandle &lt;code&gt;$logfile&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open my $logfile, &#39;log.txt&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Opening a file involves several behind-the-scenes tasks that Perl and the operating system undertake together, such as checking that the file you want to open actually exists (or creating it if you&amp;rsquo;re trying to create a new file) and making sure you&amp;rsquo;re allowed to manipulate the file (do you have the necessary file permissions, for instance). Perl will do all of this for you, so in general you don&amp;rsquo;t need to worry about it.&lt;/p&gt;

&lt;p&gt;Once you&amp;rsquo;ve opened a file to read, you can retrieve lines from it by using the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; construct, also known as &lt;code&gt;readline&lt;/code&gt;. Inside the angle brackets, place your filehandle. What you get from this depends on what you &lt;em&gt;want&lt;/em&gt; to get: in a scalar context (a more technical way of saying &amp;ldquo;if you&amp;rsquo;re assigning it to a scalar&amp;rdquo;), you retrieve the next line from the file, but if you&amp;rsquo;re looking for a list, you get a list of all the remaining lines in the file.&lt;/p&gt;

&lt;p&gt;You can, of course, &lt;code&gt;close&lt;/code&gt; a filehandle that you&amp;rsquo;ve opened. You don&amp;rsquo;t always have to do this, because Perl is clever enough to close a filehandle when your program ends, when you try to reuse an existing filehandle, or when the lexical variable containing the filehandle goes out of scope.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a simple program that will display the contents of the file &lt;em&gt;log.txt&lt;/em&gt;, and assumes that the first line of the file is its title:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open my $logfile, &#39;log.txt&#39; or die &amp;quot;I couldn&#39;t get at log.txt: $!&amp;quot;;

my $title = &amp;lt;$logfile&amp;gt;;
print &amp;quot;Report Title: $title&amp;quot;;

print while &amp;lt;$logfile&amp;gt;;
close $logfile;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That code may seem pretty dense, but it combines ideas you&amp;rsquo;ve seen before. The &lt;code&gt;while&lt;/code&gt; operator loops over every line of the file, one line at a time, putting each line into the Perl pronoun &lt;code&gt;$_&lt;/code&gt;. (A pronoun? Yes &amp;ndash; think of it as &lt;em&gt;it&lt;/em&gt;.) For each line read, Perl &lt;code&gt;prints&lt;/code&gt; the line. Now the pronoun should make sense. While you read it from the file, print it.&lt;/p&gt;

&lt;p&gt;Why not use &lt;code&gt;say&lt;/code&gt;? Each &lt;em&gt;line&lt;/em&gt; in the file ends with a newline &amp;ndash; that&amp;rsquo;s how Perl knows that it&amp;rsquo;s a line. There&amp;rsquo;s no need to add an additional newline, so &lt;code&gt;say&lt;/code&gt; would double-space the output.&lt;/p&gt;

&lt;h3 id=&#34;writing-files&#34;&gt;Writing files&lt;/h3&gt;

&lt;p&gt;You also use &lt;code&gt;open()&lt;/code&gt; when you are writing to a file. There are two ways to open a file for writing: &lt;em&gt;overwrite&lt;/em&gt; and &lt;em&gt;append&lt;/em&gt;. When you open a file in overwrite mode, you erase whatever it previously contained. In append mode, you attach your new data to the end of the existing file without erasing anything that was already there.&lt;/p&gt;

&lt;p&gt;To indicate that you want a filehandle for writing, use a single &lt;code&gt;&amp;gt;&lt;/code&gt; character as the mode passed to &lt;code&gt;open&lt;/code&gt;. This opens the file in overwrite mode. To open it in append mode, use two &lt;code&gt;&amp;gt;&lt;/code&gt; characters.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open my $overwrite, &#39;&amp;gt;&#39;, &#39;overwrite.txt&#39; or die &amp;quot;error trying to overwrite: $!&amp;quot;;
# Wave goodbye to the original contents.

open my $append, &#39;&amp;gt;&amp;gt;&#39;, &#39;append.txt&#39; or die &amp;quot;error trying to append: $!&amp;quot;;
# Original contents still there; add to the end of the file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once your filehandle is open, use the humble &lt;code&gt;print&lt;/code&gt; or &lt;code&gt;say&lt;/code&gt; operator to write to it. Specify the filehandle you want to write to and a list of values you want to write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use 5.010;

say $overwrite &#39;This is the new content&#39;;
print $append &amp;quot;We&#39;re adding to the end here.\n&amp;quot;, &amp;quot;And here too.\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;live-free-or-die&#34;&gt;Live free or die!&lt;/h3&gt;

&lt;p&gt;Most of these &lt;code&gt;open()&lt;/code&gt; statements include &lt;code&gt;or die &amp;quot;some sort of message&amp;quot;&lt;/code&gt;. This is because we live in an imperfect world, where programs don&amp;rsquo;t always behave exactly the way we want them to. It&amp;rsquo;s always possible for an &lt;code&gt;open()&lt;/code&gt; call to fail; maybe you&amp;rsquo;re trying to write to a file that you&amp;rsquo;re not allowed to write, or you&amp;rsquo;re trying to read from a file that doesn&amp;rsquo;t exist. In Perl, you can guard against these problems by using &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;and&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A series of statements separated by &lt;code&gt;or&lt;/code&gt; will continue until you hit one that works, or returns a true value. This line of code will either succeed at opening &lt;code&gt;$output&lt;/code&gt; in overwrite mode, or cause Perl to quit:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open my $output, &#39;&amp;gt;&#39;, $outfile or die &amp;quot;Can&#39;t write to &#39;$outfile&#39;: $!&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;die&lt;/code&gt; statement ends your program with an error message. The special variable &lt;code&gt;$!&lt;/code&gt; contains Perl&amp;rsquo;s explanation of the error. In this case, you might see something like this if you&amp;rsquo;re not allowed to write to the file. Note that you get both the actual error message (&amp;ldquo;Permission denied&amp;rdquo;) and the line where it happened:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Can&#39;t write to &#39;a2-die.txt&#39;: Permission denied at ./a2-die.pl line 1.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Defensive programming like this is useful for making your programs more error-resistant &amp;ndash; you don&amp;rsquo;t want to write to a file that you haven&amp;rsquo;t successfully opened! (Putting single-quotes around the filename may help you see any unexpected whitespace in the filename. You&amp;rsquo;ll slap your forehead when it happens to you.)&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an example: As part of your job, you write a program that records its results in a file called &lt;em&gt;vitalreport.txt&lt;/em&gt;. You use the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open my $vital, &#39;&amp;gt;&#39;, &#39;vitalreport.txt&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If this &lt;code&gt;open()&lt;/code&gt; call fails (for instance, &lt;em&gt;vitalreport.txt&lt;/em&gt; is owned by another user who hasn&amp;rsquo;t given you write permission), you&amp;rsquo;ll never know it until someone looks at the file afterward and wonders why the vital report wasn&amp;rsquo;t written. (Just imagine the joy if that &amp;ldquo;someone&amp;rdquo; is your boss, the day before your annual performance review.) When you use &lt;code&gt;or die&lt;/code&gt;, you avoid all this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open my $vital, &#39;&amp;gt;&#39;, &#39;vitalreport.txt&#39; or die &amp;quot;Can&#39;t write vital report: $!&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead of wondering whether your program wrote your vital report, you&amp;rsquo;ll immediately have an error message that both tells you what went wrong and on what line of your program the error occurred.&lt;/p&gt;

&lt;p&gt;You can use &lt;code&gt;or&lt;/code&gt; for more than just testing file operations:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use 5.010;
($pie eq &#39;apple&#39;) or ($pie eq &#39;cherry&#39;) or ($pie eq &#39;blueberry&#39;)
        or say &#39;But I wanted apple, cherry, or blueberry!&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this sequence, if you have an appropriate pie, Perl skips the rest of the chain. Once one statement works, the rest are ignored. The &lt;code&gt;and&lt;/code&gt; operator does the opposite: It evaluates your chain of statements, but stops when one of them &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; work.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open my $log, &#39;log.file&#39; and say &#39;Logfile is open!&#39;;
say &#39;Logfile is open!&#39; if open my $log, &#39;log.file&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This statement will only show you the words &lt;em&gt;Logfile is open!&lt;/em&gt; if the &lt;code&gt;open()&lt;/code&gt; succeeds &amp;ndash; do you see why?&lt;/p&gt;

&lt;p&gt;Again, just because there&amp;rsquo;s more than one way to execute code conditionally doesn&amp;rsquo;t mean you have to use every way in a single program or the most clever or creative way. You have plenty of options. Consider using the most readable one for the situation.&lt;/p&gt;

&lt;h3 id=&#34;subs&#34;&gt;Subs&lt;/h3&gt;

&lt;p&gt;So far, the example Perl programs have been a bunch of statements in series. This is okay if you&amp;rsquo;re writing very small programs, but as your needs grow, you&amp;rsquo;ll find it limiting. This is why most modern programming languages allow you to define your own functions; in Perl, we call them &lt;em&gt;subs&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;A sub, declared with the &lt;code&gt;sub&lt;/code&gt; keyword, adds a new function to your program&amp;rsquo;s capabilities. When you want to use this new function, you call it by name. For instance, here&amp;rsquo;s a short definition of a sub called &lt;code&gt;boo&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use 5.010;

sub boo {
    say &#39;Boo!&#39;;
}

boo();   # Eek!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Subs are useful because they allow you to break your program into small, reusable chunks. If you need to analyze a string in four different places in your program, it&amp;rsquo;s much easier to write one &lt;code&gt;analyze_string&lt;/code&gt; sub and call it four times. This way, when you make an improvement to your string-analysis routine, you&amp;rsquo;ll only need to do it in one place, instead of four.&lt;/p&gt;

&lt;p&gt;In the same way that Perl&amp;rsquo;s built-in functions can take parameters and can return values, your subs can, too. Whenever you call a sub, any parameters you pass to it appear in the special array &lt;code&gt;@_&lt;/code&gt;. You can also return a single value or a list by using the &lt;code&gt;return&lt;/code&gt; keyword.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use 5.010;

sub multiply {
    my (@ops) = @_;
    return $ops[0] * $ops[1];
}

for my $i (1 .. 10) {
     say &amp;quot;$i squared is &amp;quot;, multiply($i, $i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s an interesting benefit from using the the &lt;code&gt;my&lt;/code&gt; keyword in &lt;code&gt;multiply&lt;/code&gt;? It indicates that the variables are private to that sub, so that any existing value for the &lt;code&gt;@ops&lt;/code&gt; array used elsewhere in our program won&amp;rsquo;t get overwritten. This means that you&amp;rsquo;ll evade a whole class of hard-to-trace bugs in your programs. You don&amp;rsquo;t &lt;em&gt;have&lt;/em&gt; to use &lt;code&gt;my&lt;/code&gt;, but you also don&amp;rsquo;t &lt;em&gt;have&lt;/em&gt; to avoid smashing your thumb when you&amp;rsquo;re hammering nails into a board. They&amp;rsquo;re both just good ideas.&lt;/p&gt;

&lt;p&gt;You can also assign to multiple lexical variables (declared with &lt;code&gt;my&lt;/code&gt;) in a single statement. You can change the code within &lt;code&gt;multiply&lt;/code&gt; to something like this without having to modify any other code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub multiply {
    my ($left, $right) = @_;
    return $left * $right;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you don&amp;rsquo;t expressly use the &lt;code&gt;return&lt;/code&gt; statement, the sub returns the result of the last statement. This implicit return value can sometimes be useful, but it does reduce your program&amp;rsquo;s readability. Remember that you&amp;rsquo;ll read your code many more times than you write it!&lt;/p&gt;

&lt;h3 id=&#34;putting-it-all-together&#34;&gt;Putting it all together&lt;/h3&gt;

&lt;p&gt;The previous article demonstrated a simple interest calculator. You can make it more interesting by writing the interest table to a file instead of to the screen. Another change is to break the code into subs to make it easier to read and maintain.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2008_05_07_beginners-introduction-to-perl-510-part-2/compound_interest_file.pl&#34;&gt;[Download this program]&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#! perl

# compound_interest_file.pl - the miracle of compound interest, part 2

use 5.010;

use strict;
use warnings;

# First, we&#39;ll set up the variables we want to use.
my $outfile   = &#39;interest.txt&#39;;    # This is the filename of our report.
my $nest_egg  = 10000;             # $nest_egg is our starting amount
my $year      = 2008;              # This is the starting year for our table.
my $duration  = 10;                # How many years are we saving up?
my $apr       = 9.5;               # This is our annual percentage rate.

my $report_fh = open_report( $outfile );
print_headers(   $report_fh );
interest_report( $report_fh, $nest_egg, $year, $duration, $apr );
report_footer(   $report_fh, $nest_egg, $duration, $apr );

sub open_report {
    my ($outfile) = @_;
    open my $report, &#39;&amp;gt;&#39;, $outfile or die &amp;quot;Can&#39;t open &#39;$outfile&#39;: $!&amp;quot;;
    return $report;
}

sub print_headers {
    my ($report_fh) = @_;

    # Print the headers for our report.
    say $report_fh &amp;quot;Year\tBalance\tInterest\tNew balance&amp;quot;;
}

sub calculate_interest {
    # Given a nest egg and an APR, how much interest do we collect?
    my ( $nest_egg, $apr ) = @_;

    return int( ( $apr / 100 ) * $nest_egg * 100 ) / 100;
}

sub interest_report {
    # Get our parameters.  Note that these variables won&#39;t clobber the
    # global variables with the same name.
    my ( $report_fh, $nest_egg, $year, $duration, $apr ) = @_;

    # Calculate interest for each year.
    for my $i ( 1 .. $duration ) {
        my $interest = calculate_interest( $nest_egg, $apr );
        my $line     =
            join &amp;quot;\t&amp;quot;, $year + $i, $nest_egg, $interest, $nest_egg + $interest;

        say $report_fh $line;

        $nest_egg += $interest;
    }
}

sub report_footer {
    my ($report_fh, $nest_egg, $duration, $apr) = @_;

    say $report_fh &amp;quot;\n Our original assumptions:&amp;quot;;
    say $report_fh &amp;quot;   Nest egg: $nest_egg&amp;quot;;
    say $report_fh &amp;quot;   Number of years: $duration&amp;quot;;
    say $report_fh &amp;quot;   Interest rate: $apr&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice how much clearer the program logic becomes when you break it down into subs. One nice quality of a program written as small, well-named subs is that it almost becomes &lt;em&gt;self-documenting&lt;/em&gt;. Consider these four lines:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $report_fh = open_report( $outfile );
print_headers(   $report_fh );
interest_report( $report_fh, $nest_egg, $year, $duration, $apr );
report_footer(   $report_fh, $nest_egg, $duration, $apr );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Code like this is invaluable when you come back to it six months later and need to figure out what it does &amp;ndash; would you rather spend your time reading the entire program trying to figure it out or read four lines that tell you the program 1) opens a report file, 2) prints some headers, 3) generates an interest report, and 4) prints a report footer?&lt;/p&gt;

&lt;h3 id=&#34;play-around&#34;&gt;Play around!&lt;/h3&gt;

&lt;p&gt;This article has explored files (filehandles, &lt;code&gt;open()&lt;/code&gt;, &lt;code&gt;close()&lt;/code&gt;, and &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;), string manipulation (&lt;code&gt;substr()&lt;/code&gt;, &lt;code&gt;split()&lt;/code&gt; and &lt;code&gt;join()&lt;/code&gt;) and subs. Here&amp;rsquo;s a pair of exercises &amp;ndash; again, one simple and one complex:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;You have a file called &lt;em&gt;dictionary.txt&lt;/em&gt; that contains dictionary definitions, one per line, in the format &amp;ldquo;word &lt;code&gt;space&lt;/code&gt; definition&amp;rdquo;. (&lt;a href=&#34;http://localhost:1313/media/_pub_2008_05_07_beginners-introduction-to-perl-510-part-2/dictionary.txt&#34;&gt;Here&amp;rsquo;s a sample&lt;/a&gt;.) Write a program that will look up a word from the command line. (Hints: &lt;code&gt;@ARGV&lt;/code&gt; is a special array that contains your command line arguments and you&amp;rsquo;ll need to use the three-argument form of &lt;code&gt;split()&lt;/code&gt;.) Try to enhance it so that your dictionary can also contain words with multiple definitions in the format &amp;ldquo;word &lt;code&gt;space&lt;/code&gt; definition:alternate definition:alternate definition, etc&amp;hellip;&amp;ldquo;.&lt;/li&gt;
&lt;li&gt;Write an analyzer for your Apache logs. You can find a brief description of the common log format at &lt;a href=&#34;http://www.w3.org/Daemon/User/Config/Logging.html&#34;&gt;http://www.w3.org/Daemon/User/Config/Logging.html&lt;/a&gt;. Your analyzer should count the total number of requests for each URL, the total number of results for each status code and the total number of bytes output.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Happy programming!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A Beginner&#39;s Introduction to Perl 5.10</title>
      <link>http://localhost:1313/pub/2008/04/23/a-beginners-introduction-to-perl-510.html/</link>
      <pubDate>Wed, 23 Apr 2008 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2008/04/23/a-beginners-introduction-to-perl-510.html/</guid>
      <description>

&lt;h3 id=&#34;first-a-little-sales-pitch&#34;&gt;First, a Little Sales Pitch&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this series is based on &lt;a href=&#34;http://localhost:1313/authors/doug-sheppard&#34;&gt;Doug Sheppard&amp;rsquo;s&lt;/a&gt; &lt;a href=&#34;http://localhost:1313/pub/2000/10/begperl1.html&#34;&gt;Beginner&amp;rsquo;s Introduction to Perl&lt;/a&gt;&lt;/em&gt;. &lt;a href=&#34;http://localhost:1313/pub/2008/05/07/beginners-introduction-to-perl-510-part-2.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Files and Strings with Perl 5.10&lt;/a&gt; explains how to use files and strings, and &lt;a href=&#34;http://news.oreilly.com/2008/06/a-beginners-introduction-to-pe.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Regular Expressions with Perl 5.10&lt;/a&gt; explores regular expressions, matching, and substitutions. &lt;a href=&#34;http://broadcast.oreilly.com/2008/09/a-beginners-introduction-to-pe.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Perl Web Programming&lt;/a&gt; demonstrates how to write web programs.&lt;/p&gt;

&lt;p&gt;Welcome to Perl.&lt;/p&gt;

&lt;p&gt;Perl is the Swiss Army chainsaw of programming languages: powerful and adaptable. It was first developed by Larry Wall, a linguist working as a systems administrator for NASA in the late 1980s, as a way to make report processing easier. Since then, it has moved into a several other areas: automating system administration, acting as glue between different computer systems, web programming, bioinformatics, data munging, and even application development.&lt;/p&gt;

&lt;p&gt;Why did Perl become so popular when the Web came along? Two reasons: First, most of what is being done on the Web happens with text, and is best done with a language that&amp;rsquo;s designed for text processing. More importantly, Perl was appreciably better than the alternatives at the time when people needed something to use. C is complex and can produce security problems (especially with untrusted data), Tcl can be awkward, and Python didn&amp;rsquo;t really have a foothold.&lt;/p&gt;

&lt;p&gt;It also didn&amp;rsquo;t hurt that Perl is a friendly language. It plays well with your personal programming style. The Perl slogan is &amp;ldquo;There&amp;rsquo;s more than one way to do it,&amp;rdquo; and that lends itself well to large and small problems alike. Even more so, Perl is very portable and widespread &amp;ndash; it&amp;rsquo;s available pre-installed almost everywhere &amp;ndash; and of course there are thousands of freely-distributable libraries available from the &lt;a href=&#34;http://www.cpan.org/&#34;&gt;CPAN&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this first part of our series, you&amp;rsquo;ll learn a few basics about Perl and see a small sample program.&lt;/p&gt;

&lt;h3 id=&#34;a-word-about-operating-systems&#34;&gt;A Word About Operating Systems&lt;/h3&gt;

&lt;p&gt;This series assumes that you&amp;rsquo;re using a Unix or Unix-like operating system (Mac OS X and Cygwin qualify) and that you have the &lt;code&gt;perl&lt;/code&gt; binary available at &lt;em&gt;/usr/bin/perl&lt;/em&gt;. It&amp;rsquo;s OK if you&amp;rsquo;re running Windows through ActivePerl or Strawberry Perl; most Perl code is platform-independent.&lt;/p&gt;

&lt;h3 id=&#34;your-first-perl-program&#34;&gt;Your First Perl Program&lt;/h3&gt;

&lt;p&gt;Save this program as a file called &lt;em&gt;first.pl&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use feature &#39;:5.10&#39;;
say &amp;quot;Hi there!&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(The traditional first program says &lt;code&gt;Hello world!&lt;/code&gt;, but I&amp;rsquo;m an iconoclast.)&lt;/p&gt;

&lt;p&gt;Run the program. From a command line, go to the directory with this file and type &lt;code&gt;perl first.pl&lt;/code&gt;. You should see:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hi there!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Friendly, isn&amp;rsquo;t it?&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m sure you can guess what &lt;code&gt;say&lt;/code&gt; does. What about the &lt;code&gt;use feature &#39;:5.10&#39;;&lt;/code&gt; line? For now, all you need to know is that it allows you to use nice new features found in Perl 5.10. This is a very good thing.&lt;/p&gt;

&lt;h3 id=&#34;functions-and-statements&#34;&gt;Functions and Statements&lt;/h3&gt;

&lt;p&gt;Perl has a rich library of built-in &lt;em&gt;functions&lt;/em&gt;. They&amp;rsquo;re the verbs of Perl, the commands that the interpreter runs. You can see a list of all the built-in functions in the &lt;a href=&#34;https://perldoc.perl.org/index-functions.html&#34;&gt;perlfunc&lt;/a&gt; man page (&lt;code&gt;perldoc perlfunc&lt;/code&gt;, from the command line). Almost all functions can take a list of commma-separated &lt;em&gt;parameters&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;print&lt;/code&gt; function is one of the most frequently used parts of Perl. You use it to display things on the screen or to send information to a file. It takes a list of things to output as its parameters.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print &amp;quot;This is a single statement.&amp;quot;;
print &amp;quot;Look, &amp;quot;, &amp;quot;a &amp;quot;, &amp;quot;list!&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A Perl program consists of &lt;em&gt;statements&lt;/em&gt;, each of which ends with a semicolon. Statements don&amp;rsquo;t need to be on separate lines; there may be multiple statements on one line. You can also split a single statement across multiple lines.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print &amp;quot;This is &amp;quot;; print &amp;quot;two statements.\n&amp;quot;;
print &amp;quot;But this &amp;quot;, &amp;quot;is only one statement.\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wait a minute though. What&amp;rsquo;s the difference between &lt;code&gt;say&lt;/code&gt; and &lt;code&gt;print&lt;/code&gt;? What&amp;rsquo;s this &lt;code&gt;\n&lt;/code&gt; in the &lt;code&gt;print&lt;/code&gt; statements?&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;say&lt;/code&gt; function behaves just like the &lt;code&gt;print&lt;/code&gt; function, except that it appends a newline at the end of its arguments. It prints all of its arguments, and then a newline character. Always. No exceptions. &lt;code&gt;print&lt;/code&gt;, on the other hand, only prints what you see explicitly in these examples. If you want a newline, you have to add it yourself with the special character escape sequence &lt;code&gt;\n&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use feature &#39;:5.10&#39;;

say &amp;quot;This is a single statement.&amp;quot;;
say &amp;quot;Look, &amp;quot;, &amp;quot;a &amp;quot;, &amp;quot;list!&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Why do both exist? Why would you use one over the other? Usually, most &amp;ldquo;display something&amp;rdquo; statements need the newline. It&amp;rsquo;s common enough that &lt;code&gt;say&lt;/code&gt; is a good default choice. Occasionally you need a little bit more control over your output, so &lt;code&gt;print&lt;/code&gt; is the option.&lt;/p&gt;

&lt;p&gt;Note that &lt;code&gt;say&lt;/code&gt; is two characters shorter than &lt;code&gt;print&lt;/code&gt;. This is an important design principle for Perl &amp;ndash; common things should be easy and simple.&lt;/p&gt;

&lt;h3 id=&#34;numbers-strings-and-quotes&#34;&gt;Numbers, Strings, and Quotes&lt;/h3&gt;

&lt;p&gt;There are two basic data types in Perl: numbers and strings.&lt;/p&gt;

&lt;p&gt;Numbers are easy; we&amp;rsquo;ve all dealt with them. The only thing you need to know is that you never insert commas or spaces into numbers in Perl. Always write 10000, not 10,000 or 10 000.&lt;/p&gt;

&lt;p&gt;Strings are a bit more complex. A string is a collection of characters in either single or double quotes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;This is a test.&#39;
&amp;quot;Hi there!\n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The difference between single quotes and double quotes is that single quotes mean that their contents should be taken &lt;em&gt;literally&lt;/em&gt;, while double quotes mean that their contents should be &lt;em&gt;interpreted&lt;/em&gt;. Remember the character sequence &lt;code&gt;\n&lt;/code&gt;? It represents a newline character when it appears in a string with double quotes, but is literally the two characters backslash and &lt;code&gt;n&lt;/code&gt; when it appears in single quotes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use feature &#39;:5.10&#39;;
say &amp;quot;This string\nshows up on two lines.&amp;quot;;
say &#39;This string \n shows up on only one.&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Two other useful backslash sequences are &lt;code&gt;\t&lt;/code&gt; to insert a tab character, and &lt;code&gt;\\&lt;/code&gt; to insert a backslash into a double-quoted string.)&lt;/p&gt;

&lt;h3 id=&#34;variables&#34;&gt;Variables&lt;/h3&gt;

&lt;p&gt;If functions are Perl&amp;rsquo;s verbs, then variables are its nouns. Perl has three types of variables: &lt;em&gt;scalars&lt;/em&gt;, &lt;em&gt;arrays&lt;/em&gt;, and &lt;em&gt;hashes&lt;/em&gt;. Think of them as things, lists, and dictionaries respectively. In Perl, all variable names consist of a punctuation character, a letter or underscore, and one or more alphanumeric characters or underscores.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Scalars&lt;/em&gt; are single things. This might be a number or a string. The name of a scalar begins with a dollar sign, such as &lt;code&gt;$i&lt;/code&gt; or &lt;code&gt;$abacus&lt;/code&gt;. Assign a value to a scalar by telling Perl what it equals:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $i                = 5;
my $pie_flavor       = &#39;apple&#39;;
my $constitution1776 = &amp;quot;We the People, etc.&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You don&amp;rsquo;t need to specify whether a scalar is a number or a string. It doesn&amp;rsquo;t matter, because when Perl needs to treat a scalar as a string, it does; when it needs to treat it as a number, it does. The conversion happens automatically. (This is different from many other languages, where strings and numbers are two separate data types.)&lt;/p&gt;

&lt;p&gt;If you use a double-quoted string, Perl will insert the value of any scalar variables you name in the string. This is often useful to fill in strings on the fly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use feature &#39;:5.10&#39;;
my $apple_count  = 5;
my $count_report = &amp;quot;There are $apple_count apples.&amp;quot;;
say &amp;quot;The report is: $count_report&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final output from this code is &lt;code&gt;The report is: There are 5 apples.&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can manipulate numbers in Perl with the usual mathematical operations: addition, multiplication, division, and subtraction. (The multiplication and division operators in Perl use the &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt; symbols, by the way.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $a = 5;
my $b = $a + 10;       # $b is now equal to 15.
my $c = $b * 10;       # $c is now equal to 150.
$a    = $a - 1;        # $a is now 4, and algebra teachers are cringing.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s all well and good, but what&amp;rsquo;s this strange &lt;code&gt;my&lt;/code&gt;, and why does it appear with some assignments and not others? The &lt;code&gt;my&lt;/code&gt; operator tells Perl that you&amp;rsquo;re &lt;em&gt;declaring&lt;/em&gt; a new variable. That is, you promise Perl that you deliberately want to use a scalar, array, or hash of a specific name in your program. This is important for two reasons. First, it helps Perl help you protect against typos; it&amp;rsquo;s embarrassing to discover that you&amp;rsquo;ve accidentally mistyped a variable name and spent an hour looking for a bug. Second, it helps you write larger programs, where variables used in one part of the code don&amp;rsquo;t accidentally affect variables used elsewhere.&lt;/p&gt;

&lt;p&gt;You can also use special operators like &lt;code&gt;++&lt;/code&gt;, &lt;code&gt;--&lt;/code&gt;, &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt; and &lt;code&gt;*=&lt;/code&gt;. These manipulate a scalar&amp;rsquo;s value without needing two elements in an equation. Some people like them, some don&amp;rsquo;t. I like the fact that they can make code clearer.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $a = 5;
$a++;        # $a is now 6; we added 1 to it.
$a += 10;    # Now it&#39;s 16; we added 10.
$a /= 2;     # And divided it by 2, so it&#39;s 8.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Strings in Perl don&amp;rsquo;t have quite as much flexibility. About the only basic operator that you can use on strings is &lt;em&gt;concatenation&lt;/em&gt;, which is a ten dollar way of saying &amp;ldquo;put together.&amp;rdquo; The concatenation operator is the period. Concatenation and addition are two different things:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $a = &amp;quot;8&amp;quot;;    # Note the quotes.  $a is a string.
my $b = $a + &amp;quot;1&amp;quot;;   # &amp;quot;1&amp;quot; is a string too.
my $c = $a . &amp;quot;1&amp;quot;;   # But $b and $c have different values!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remember that Perl converts strings to numbers transparently whenever necessary, so to get the value of &lt;code&gt;$b&lt;/code&gt;, the Perl interpreter converted the two strings &lt;code&gt;&amp;quot;8&amp;quot;&lt;/code&gt; and &lt;code&gt;&amp;quot;1&amp;quot;&lt;/code&gt; to numbers, then added them. The value of &lt;code&gt;$b&lt;/code&gt; is the number 9. However, &lt;code&gt;$c&lt;/code&gt; used concatenation, so its value is the string &lt;code&gt;&amp;quot;81&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Remember, the plus sign &lt;em&gt;adds numbers&lt;/em&gt; and the period &lt;em&gt;puts strings together&lt;/em&gt;. If you add things that aren&amp;rsquo;t numbers, Perl will try its best to do what you&amp;rsquo;ve told it to do, and will convert those non-numbers to numbers with the best of its ability.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Arrays&lt;/em&gt; are lists of scalars. Array names begin with &lt;code&gt;@&lt;/code&gt;. You define arrays by listing their contents in parentheses, separated by commas:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my @lotto_numbers = (1, 2, 3, 4, 5, 6);  # Hey, it could happen.
my @months        = (&amp;quot;July&amp;quot;, &amp;quot;August&amp;quot;, &amp;quot;September&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You retrieve the contents of an array by an &lt;em&gt;index&lt;/em&gt;, sort of like &amp;ldquo;Hey, give me the first month of the year.&amp;rdquo; Indexes in Perl start from zero. (Why not 1? Because. It&amp;rsquo;s a computer thing.) To retrieve the elements of an array, you replace the &lt;code&gt;@&lt;/code&gt; sign with a &lt;code&gt;$&lt;/code&gt; sign, and follow that with the index position of the element you want. (It begins with a dollar sign because you&amp;rsquo;re getting a scalar value.) You can also modify it in place, just like any other scalar.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use feature &#39;:5.10&#39;;

my @months = (&amp;quot;July&amp;quot;, &amp;quot;August&amp;quot;, &amp;quot;September&amp;quot;);
say $months[0];         # This prints &amp;quot;July&amp;quot;.
$months[2] = &amp;quot;Smarch&amp;quot;;  # We just renamed September!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If an array value doesn&amp;rsquo;t exist, Perl will create it for you when you assign to it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my @winter_months = (&amp;quot;December&amp;quot;, &amp;quot;January&amp;quot;);
$winter_months[2] = &amp;quot;February&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Arrays always return their contents in the same order; if you go through &lt;code&gt;@months&lt;/code&gt; from beginning to end, no matter how many times you do it, you&amp;rsquo;ll get back &lt;code&gt;July&lt;/code&gt;, &lt;code&gt;August&lt;/code&gt;, and &lt;code&gt;September&lt;/code&gt; in that order. If you want to find the number of elements of an array, assign the array to a scalar.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use feature &#39;:5.10&#39;;
my @months      = (&amp;quot;July&amp;quot;, &amp;quot;August&amp;quot;, &amp;quot;September&amp;quot;);
my $month_count = @months;
say $month_count;  # This prints 3.

my @autumn_months; # no elements
my $autumn_count = @autumn_months;
say $autumn_count; # this prints 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Some programming languages call &lt;em&gt;hashes&lt;/em&gt; &amp;ldquo;dictionaries&amp;rdquo;. That&amp;rsquo;s what they are: a term and a definition. More precisely, they contain &lt;em&gt;keys&lt;/em&gt; and &lt;em&gt;values&lt;/em&gt;. Each key in a hash has one and only one corresponding value. The name of a hash begins with a percentage sign, like &lt;code&gt;%parents&lt;/code&gt;. You define hashes by comma-separated pairs of key and value, like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my %days_in_month = ( &amp;quot;July&amp;quot; =&amp;gt; 31, &amp;quot;August&amp;quot; =&amp;gt; 31, &amp;quot;September&amp;quot; =&amp;gt; 30 );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can fetch any value from a hash by referring to &lt;code&gt;$hashname{key}&lt;/code&gt;, or modify it in place just like any other scalar.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;say $days_in_month{September}; # 30, of course.
$days_in_month{February} = 29; # It&#39;s a leap year.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To see what keys are in a hash, use the &lt;code&gt;keys&lt;/code&gt; function with the name of the hash. This returns a list containing all of the keys in the hash. The list isn&amp;rsquo;t always in the same order, though; while you can count on &lt;code&gt;@months&lt;/code&gt; always to return &lt;code&gt;July&lt;/code&gt;, &lt;code&gt;August&lt;/code&gt;, &lt;code&gt;September&lt;/code&gt; in that order, &lt;code&gt;keys %days_in_month&lt;/code&gt; might return them in any order whatsoever.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my @month_list = keys %days_in_month;
# @month_list is now (&#39;July&#39;, &#39;September&#39;, &#39;August&#39;, &#39;February&#39;)!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The three types of variables have three separate &lt;em&gt;namespaces&lt;/em&gt;. That means that &lt;code&gt;$abacus&lt;/code&gt; and &lt;code&gt;@abacus&lt;/code&gt; are two different variables, and &lt;code&gt;$abacus[0]&lt;/code&gt; (the first element of &lt;code&gt;@abacus&lt;/code&gt;) is not the same as &lt;code&gt;$abacus{0}&lt;/code&gt; (the value in &lt;code&gt;%abacus&lt;/code&gt; that has the key &lt;code&gt;0&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&#34;comments&#34;&gt;Comments&lt;/h3&gt;

&lt;p&gt;Some of the code samples from the previous section contained code comments. These are useful for explaining what a particular piece of code does, and vital for any piece of code you plan to modify, enhance, fix, or just look at again. (That is to say, comments are important.)&lt;/p&gt;

&lt;p&gt;Anything in a line of Perl code that follows a &lt;code&gt;#&lt;/code&gt; sign is a comment, unless that &lt;code&gt;#&lt;/code&gt; sign appears in a string.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use feature &#39;:5.10&#39;;
say &amp;quot;Hello world!&amp;quot;;  # That&#39;s more like it.
# This entire line is a comment.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;loops&#34;&gt;Loops&lt;/h3&gt;

&lt;p&gt;Almost every program ever written uses a &lt;em&gt;loop&lt;/em&gt; of some kind. Loops allow you run a particular piece of code over and over again. This is part of a general concept in programming called &lt;em&gt;flow control&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Perl has several different functions that are useful for flow control, the most basic of which is &lt;code&gt;for&lt;/code&gt;. When you use the &lt;code&gt;for&lt;/code&gt; function, you specify a variable to use as the &lt;em&gt;loop index&lt;/em&gt;, and a list of values to loop over. Inside a pair of curly brackets, you put any code you want to run during the loop:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use feature &#39;:5.10&#39;;

for my $i (1, 2, 3, 4, 5) {
     say $i;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This loop prints the numbers 1 through 5, each on a separate line. (It&amp;rsquo;s not very useful; you&amp;rsquo;re might think &amp;ldquo;Why not just write &lt;code&gt;say 1, 2, 3, 4, 5;&lt;/code&gt;?&amp;ldquo;. This is because &lt;code&gt;say&lt;/code&gt; adds only one newline, at the end of its list of arguments.)&lt;/p&gt;

&lt;p&gt;A handy shortcut for defining loop values is the &lt;em&gt;range&lt;/em&gt; operator &lt;code&gt;..&lt;/code&gt;, which specifies a range of numbers. You can write &lt;code&gt;(1, 2, 3, 4, 5)&lt;/code&gt; as &lt;code&gt;(1 .. 5)&lt;/code&gt; instead. You can also use arrays and scalars in your loop list. Try this code and see what happens:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use feature &#39;:5.10&#39;;

my @one_to_ten = (1 .. 10);
my $top_limit  = 25;

for my $i (@one_to_ten, 15, 20 .. $top_limit) {
    say $i;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, again you could write &lt;code&gt;say @one_to_ten, 15, 20 .. $top_limit;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The items in your loop list don&amp;rsquo;t have to be numbers; you can use strings just as easily. If the hash &lt;code&gt;%month_has&lt;/code&gt; contains names of months and the number of days in each month, you can use the &lt;code&gt;keys&lt;/code&gt; function to step through them.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use feature &#39;:5.10&#39;;

for my $i (keys %month_has) {
    say &amp;quot;$i has $month_has{$i} days.&amp;quot;;
}

for my $marx (&#39;Groucho&#39;, &#39;Harpo&#39;, &#39;Zeppo&#39;, &#39;Karl&#39;) {
    say &amp;quot;$marx is my favorite Marx brother.&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;the-miracle-of-compound-interest&#34;&gt;The Miracle of Compound Interest&lt;/h3&gt;

&lt;p&gt;You now know enough about Perl &amp;ndash; variables, &lt;code&gt;print&lt;/code&gt;/&lt;code&gt;say&lt;/code&gt;, and &lt;code&gt;for()&lt;/code&gt; &amp;ndash; to write a small, useful program. Everyone loves money, so the first sample program is a compound-interest calculator. It will print a (somewhat) nicely formatted table showing the value of an investment over a number of years. (You can see the program at &lt;a href=&#34;http://localhost:1313/media/_pub_2008_04_23_a-beginners-introduction-to-perl-510/compound_interest.pl&#34;&gt;&lt;code&gt;compound_interest.pl&lt;/code&gt;&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;The single most complex line in the program is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $interest = int( ( $apr / 100 ) * $nest_egg * 100 ) / 100;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$apr / 100&lt;/code&gt; is the interest rate, and &lt;code&gt;($apr / 100) * $nest_egg&lt;/code&gt; is the amount of interest earned in one year. This line uses the &lt;code&gt;int()&lt;/code&gt; function, which returns the integer value of a scalar (its value after any stripping off any fractional part). We use &lt;code&gt;int()&lt;/code&gt; here because when you multiply, for example, 10925 by 9.25%, the result is 1010.5625, which we must round off to 1010.56. To do this, we multiply by 100, yielding 101056.25, use &lt;code&gt;int()&lt;/code&gt; to throw away the leftover fraction, yielding 101056, and then divide by 100 again, so that the final result is 1010.56. Try stepping through this statement yourself to see just how we end up with the correct result, rounded to cents.&lt;/p&gt;

&lt;h3 id=&#34;play-around&#34;&gt;Play Around!&lt;/h3&gt;

&lt;p&gt;At this point you have some basic knowledge of Perl syntax and a few simple toys to play with. Try writing some simple programs with them. Here are two suggestions, one simple and the other a little more complex:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A word frequency counter. How often does each word show up in an array of words? Print out a report. (Hint: Use a hash to count of the number of appearances of each word.)&lt;/li&gt;
&lt;li&gt;Given a month and the day of the week that&amp;rsquo;s the first of that month, print a calendar for the month.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>

