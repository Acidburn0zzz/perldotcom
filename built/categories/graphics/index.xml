<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Graphics on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/categories/graphics/</link>
    <description>Recent content in Graphics on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 24 Jan 2011 06:00:01 -0800</lastBuildDate>
    <atom:link href="/categories/graphics/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Visualizing Music with SDL and Perl</title>
      <link>http://localhost:1313/pub/2011/01/visualizing-music-with-sdl-and-perl.html/</link>
      <pubDate>Mon, 24 Jan 2011 06:00:01 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2011/01/visualizing-music-with-sdl-and-perl.html/</guid>
      <description>

&lt;h1 id=&#34;music-visualization-with-perl-and-sdl&#34;&gt;&lt;strong&gt;Music Visualization with Perl and SDL&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;Many users know SDL as a powerful cross-platform library for graphics programming and input, especially as the foundation of many open source games. Perl users know it as the technology behind the beloved &lt;a href=&#34;http://www.frozen-bubble.org/&#34;&gt;Frozen Bubble&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Perl and SDL can do far more than destroy an infinite onslaught of cartoon bubbles, however. The recently revitalized &lt;a href=&#34;http://sdlperl.ath.cx/projects/SDLPerl/&#34;&gt;SDL Perl&lt;/a&gt; project has taken up the challenge of demonstrating that everyone&amp;rsquo;s favorite system administration language is capable of producing powerful multimedia programs—including, but not limited to, games.&lt;/p&gt;

&lt;p&gt;In this edited excerpt from the &lt;a href=&#34;http://sdlperl.ath.cx/releases/SDL_Manual.html&#34;&gt;SDL Perl manual&lt;/a&gt;, lead developer Kartik Thakore walks through a non-game application of SDL and Perl, building a music player with visualizations in just a few lines of code.&lt;/p&gt;

&lt;h2 id=&#34;running-this-demo&#34;&gt;&lt;strong&gt;Running this Demo&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;To run this example software, you need:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Perl 5.10, with threading enabled&lt;/li&gt;
&lt;li&gt;A curent installation of CPAN&lt;/li&gt;
&lt;li&gt;The native libraries of libsdl, libsdl_mixer (with Ogg support), libsdl_gfx, and their development packages&lt;/li&gt;
&lt;li&gt;SDL perl version 5.526 or newer&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2011_01_visualizing-music-with-sdl-and-perl/music_visualizer.zip&#34;&gt;this article&amp;rsquo;s example files&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With all of that installed, extract the example file and run the visualizer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $ cd music_visualiser/
    $ perl visualiser.pl
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;music-visualizer&#34;&gt;&lt;strong&gt;Music Visualizer&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;The music visualizer example processes real-time sound data—data as it plays—and displays the wave form on the screen. It will look something like Figure 1.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2011_01_visualizing-music-with-sdl-and-perl/spectro-1.png&#34; alt=&#34;Simple Music Visualization&#34; /&gt;
&lt;em&gt;Figure 1. A simple music visualization.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;the-code-and-comments&#34;&gt;&lt;strong&gt;The Code and Comments&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;The program begins with the usual boilerplate of an SDL Perl application:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use strict;
    use warnings;

    use Cwd;
    use Carp;
    use File::Spec;

    use threads;
    use threads::shared;

    use SDL;
    use SDL::Event;
    use SDL::Events;

    use SDL::Audio;
    use SDL::Mixer;
    use SDL::Mixer::Music;
    use SDL::Mixer::Effects;

    use SDLx::App;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It then creates an application with both audio and video support:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $app = SDLx::App-&amp;gt;new(
        init   =&amp;gt; SDL_INIT_AUDIO | SDL_INIT_VIDEO,
        width  =&amp;gt; 800,
        height =&amp;gt; 600,
        depth  =&amp;gt; 32,
        title  =&amp;gt; &amp;quot;Sound Event Demo&amp;quot;,
        eoq    =&amp;gt; 1,
        dt     =&amp;gt; 0.2,
    );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The application must initialize the audio system with a format matching the expected audio input. &lt;code&gt;AUDIO_S16&lt;/code&gt; provides a 16-bit signed integer array for the stream data:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Initialize the Audio
    unless ( SDL::Mixer::open_audio( 44100, AUDIO_S16, 2, 1024 ) == 0 ) {
        Carp::croak &amp;quot;Cannot open audio: &amp;quot; . SDL::get_error();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The music player needs the music files from the &lt;em&gt;data/music/&lt;/em&gt; directory:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Load our music files
    my $data_dir = &#39;.&#39;;
    my @songs    = glob &#39;data/music/*.ogg&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A music effect reads the music data into a stream array, shared between threads:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @stream_data :shared;

    #  Music Effect to pull Stream Data
    sub music_data {
        my ( $channel, $samples, $position, @stream ) = @_;

        {
            lock(@stream_data);
            push @stream_data, @stream;
        }

        return @stream;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; and that effect gets registered as a callback with &lt;code&gt;SDL::Mixer::Effects&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $music_data_effect_id =
          SDL::Mixer::Effects::register( MIX_CHANNEL_POST, &amp;quot;main::music_data&amp;quot;,
            &amp;quot;main::done_music_data&amp;quot;, 0 );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The program&amp;rsquo;s single command-line option governs the number of lines to display in the visualizer. The default is 50.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $lines = $ARGV[0] || 50;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The drawing callback for the &lt;code&gt;SDLx::App&lt;/code&gt; runs while a song plays. It reads the stream data and displays it on the screen as a wave form. The math calculations produce a multi-colored bar graph representing slices of the music data. The remaining visualization code should be straightforward:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #  Music Playing Callbacks
    my $current_song = 0;
    my $lines        = $ARGV[0] || 50;

    my $current_music_callback = sub {
        my ( $delta, $app ) = @_;

        $app-&amp;gt;draw_rect( [ 0, 0, $app-&amp;gt;w(), $app-&amp;gt;h() ], 0x000000FF );
        $app-&amp;gt;draw_gfx_text(
            [ 5, $app-&amp;gt;h() - 10 ],
            [ 255, 0, 0, 255 ],
            &amp;quot;Playing Song: &amp;quot; . $songs[ $current_song - 1 ]
        );

        my @stream;
        {
            lock @stream_data;
            @stream      = @stream_data;
            @stream_data = ();
        }

        # To show the right amount of lines we choose a cut of the stream
        # this is purely for asthetic reasons.

        my $cut = @stream / $lines;

        # The width of each line is calculated to use.
        my $l_wdt = ( $app-&amp;gt;w() / $lines ) / 2;

        for ( my $i = 0 ; $i &amp;lt; $#stream ; $i += $cut ) {

            #  In stereo mode the stream is split between two alternating streams
            my $left  = $stream[$i];
            my $right = $stream[ $i + 1 ];

            #  For each bar we calculate a Y point and a X point
            my $point_y = ( ( ($left) ) * $app-&amp;gt;h() / 4 / 32000 ) + ( $app-&amp;gt;h / 2 );
            my $point_y_r =
              ( ( ($right) ) * $app-&amp;gt;h() / 4 / 32000 ) + ( $app-&amp;gt;h / 2 );
            my $point_x = ( $i / @stream ) * $app-&amp;gt;w;

            # Using the parameters
            #   Surface, box coordinates and color as RGBA
            SDL::GFX::Primitives::box_RGBA(
                $app,
                $point_x - $l_wdt,
                $app-&amp;gt;h() / 2,
                $point_x + $l_wdt,
                $point_y, 40, 0, 255, 128
            );
            SDL::GFX::Primitives::box_RGBA(
                $app,
                $point_x - $l_wdt,
                $app-&amp;gt;h() / 2,
                $point_x + $l_wdt,
                $point_y_r, 255, 0, 40, 128
            );

        }

      $app-&amp;gt;flip();
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whenever a song finishes, &lt;code&gt;SDL::Mixer::Music::playing_music&lt;/code&gt; returns &lt;code&gt;0&lt;/code&gt;. The program detects this state change and calls &lt;code&gt;music_finished_playing()&lt;/code&gt;, where the program attaches the &lt;code&gt;$play_next_song_callback&lt;/code&gt; callback to switch to the next song gracefully:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $cms_move_callback_id;
    my $pns_move_callback_id;
    my $play_next_song_callback;

    sub music_finished_playing {
        SDL::Mixer::Music::halt_music();
        $pns_move_callback_id = $app-&amp;gt;add_move_handler( $play_next_song_callback )
            if defined $play_next_song_callback;
    }

    $play_next_song_callback = sub {
        return $app-&amp;gt;stop() if $current_song &amp;gt;= @songs;

        my $song = SDL::Mixer::Music::load_MUS($songs[$current_song++]);

        SDL::Mixer::Music::hook_music_finished(&#39;main::music_finished_playing&#39;);
        SDL::Mixer::Music::play_music($song, 0 );

        $app-&amp;gt;remove_move_handler( $pns_move_callback_id )
            if defined $pns_move_callback_id;
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A move handler detects if music is playing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $app-&amp;gt;add_move_handler(
       sub {
           my $music_playing = SDL::Mixer::Music::playing_music();
           music_finished_playing() unless $music_playing;
       }
   );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first callback to trigger &lt;code&gt;$play_next_song_callback&lt;/code&gt; gets the first song:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $app-&amp;gt;add_show_handler($current_music_callback);
    $pns_move_callback_id = $app-&amp;gt;add_move_handler( $play_next_song_callback);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; and a keyboard event handler for a keypress allows the user to move through songs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $app-&amp;gt;add_event_handler(
        sub {
            my ($event, $app) = @_;

            if ($event-&amp;gt;type == SDL_KEYDOWN &amp;amp;&amp;amp; $event-&amp;gt;key_sym == SDLK_DOWN)
            {
                # Indicate that we are done playing the music_finished_playing
                music_finished_playing();
            }
        }
    );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From there, the application is ready to run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $app-&amp;gt;run();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; and the final code gracefully stops &lt;code&gt;SDL::Mixer&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    SDL::Mixer::Effects::unregister( MIX_CHANNEL_POST, $music_data_effect_id );
    SDL::Mixer::Music::hook_music_finished();
    SDL::Mixer::Music::halt_music();
    SDL::Mixer::close_audio();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The result? Several dozen lines of code glue together the SDL mixer and display a real-time visualization of the music.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Charting Data at the Bottom of the World</title>
      <link>http://localhost:1313/pub/2006/05/04/charting-data.html/</link>
      <pubDate>Thu, 04 May 2006 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2006/05/04/charting-data.html/</guid>
      <description>

&lt;p&gt;I have an odd job: I&amp;rsquo;m the only programmer for about 500 miles. I look after experiments on &lt;a href=&#34;http://www.bas.ac.uk/Living_and_Working/Stations/Halley/index.php&#34;&gt;a remote Antarctic research station&lt;/a&gt; and look after the data they produce. As well as the scientific stuff knocking about, we have between 20 and 70 people, most of them keen on the weather. Either because we can&amp;rsquo;t work if its windy, or can enjoy a spot of kite skiing if it&amp;rsquo;s just windy enough, everyone here wants to know what&amp;rsquo;s going on outside.&lt;/p&gt;

&lt;p&gt;Luckily we have a few climate science experiments running, including a weather station. For a few years now, data from the weather station has been available on people&amp;rsquo;s computers through a Perl Tk application and some slightly baroque shuttling of records between three different data servers and the network the office computers run on. All is well and good, and we leave it well alone, as it&amp;rsquo;s worked well. Recently, a new experiment installed on the station provides an up-to-the-minute profile of wind speeds over the first 30 meters of the air. It&amp;rsquo;s there to support research into interactions between snow and air in Antarctica, but it&amp;rsquo;s also crucial information if you want to head out and whiz about behind a kite.&lt;/p&gt;

&lt;p&gt;The data from this mast goes to a remote machine that allows users to VNC in to check its health, and logs this data to a binary format of its own making. People around the station have taken to logging in to this machine before heading out, which is probably not the best way keep the data rolling in without interruption. Rather than forbidding access to this useful source of local data, we decided to upgrade our weather display system to include the major parameters recorded by the mast.&lt;/p&gt;

&lt;p&gt;Alas, while fairly nice to use, Tk is a bit fiddly and not exactly my cup of tea. Adding new displays to an existing application can be time-consuming, as you must re-learn the relations among each different widget, pane, and button. Added to this programming burden, even if we could find every copy of the application scattered around our network, we&amp;rsquo;d have to do so every time we added some other source of data. We settled instead on a complete rewrite as a CGI script and some automatically generated graphs. A fancier man than me might call that a three-tier application, but then, he&amp;rsquo;d probably be selling you something at the same time.&lt;/p&gt;

&lt;h3 id=&#34;mountains-of-data&#34;&gt;Mountains of Data&lt;/h3&gt;

&lt;p&gt;Before you can see what the weather is doing (beyond looking out of the window), you need to get at the raw numbers somehow. Ours are provided by state-of-the-art scientific instruments in state-of-the-art data formats; that is to say, partly as lines of ASCII data in columns, and partly as fixed-length records in a binary file. No matter, though. Perl and some friends from CPAN make fast work of building meaning from tumbled piles of data.&lt;/p&gt;

&lt;p&gt;Before doing anything, I set up a couple of objects to hold some data values. Each set of observations has a class corresponding to the experiment that generated it. The classes also contain &lt;code&gt;read_file&lt;/code&gt; factory methods that read a file and produce a list of observations. To make things as quick (to write) as possible, I used &lt;a href=&#34;https://metacpan.org/pod/Class::Accessor&#34;&gt;&lt;code&gt;Class::Accessor&lt;/code&gt;&lt;/a&gt; to autogenerate &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; methods for my objects:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; # Current weather data
 package Z::Weather;
 use base qw(Class::Accessor);
 Z::Weather-&amp;gt;mk_accessors( qw(time temp pressure wind dir) );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This automatically creates a &lt;code&gt;new()&lt;/code&gt; method for &lt;code&gt;Z::Weather&lt;/code&gt;. Call it as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; my $weather = Z::Weather-&amp;gt;new({time =&amp;gt; $time,
                                temp =&amp;gt; $temp,
                                pressure =&amp;gt; $pres,
                                wind =&amp;gt; $wind,
                                dir
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It also generates &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; accessors for each field:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; # set
 $weather-&amp;gt;temp(30);

 # get
 my $temp = $weather-&amp;gt;temp();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(The &amp;ldquo;codename&amp;rdquo; used when shipping items to our station is &lt;code&gt;Z&lt;/code&gt;, so I&amp;rsquo;ve used that as my little local namespace, too.)&lt;/p&gt;

&lt;p&gt;From our mast, we have a number of observations taken at different heights, so I wanted a slightly more complicated representation, using a class to represent the mast and another to represent each level on the mast.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; package Z::Mast;
 use base qw(Class::Accessor);

 Z::Mast-&amp;gt;mk_accessors(qw(time values));

 package Z::Mast::Level;
 use base qw(Class::Accessor);
 Z::Mast::Level-&amp;gt;mk_accessors(qw(wind dir level));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remember that &lt;code&gt;Z::Mast::values&lt;/code&gt; will set and get a reference to an array of &lt;code&gt;::Level&lt;/code&gt; objects. If I wanted to enforce that, I could override the methods provided by &lt;code&gt;Class::Accessor&lt;/code&gt;, but that would create work that I can get away without doing for this simple case.&lt;/p&gt;

&lt;p&gt;Now that I know what the data will look like in Perl, I can wrench it from the covetous hands of our data loggers and turn it into something I can use.&lt;/p&gt;

&lt;p&gt;First, I decided to deal with the plain ASCII file. This contains single lines, with the time of observation first, then white-space-separated values for temperature, pressure, wind speed, direction, and a few others that I don&amp;rsquo;t care about. &lt;code&gt;Z::Weather&lt;/code&gt; needs to use a couple of modules and add a couple of methods:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; use IO::All;

 sub from_file {
     my $class = shift;
     my $io    = io(shift);
     my @recs  = ();

     while (my $line = $io-&amp;gt;readline()) {
         chomp($line);
         push @recs, $class-&amp;gt;_line($line);
     }
     return @recs;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I expect to call this as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; my @weather_records = Z::Weather-&amp;gt;fromfile(&amp;quot;weather.data&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using the &lt;a href=&#34;https://metacpan.org/pod/IO::All&#34;&gt;&lt;code&gt;IO::All&lt;/code&gt;&lt;/a&gt; module to access the files both makes it very easy to read the file and also allows &lt;em&gt;calling&lt;/em&gt; code to instead supply an &lt;code&gt;IO::All&lt;/code&gt; object of its own, or to call this method with a filehandle already opened to the data source. This will make it easy to obtain data from some other source; for instance, if the experiment changes to provide a socket from which to read the current values.&lt;/p&gt;

&lt;p&gt;Parsing the data is the responsibility of another method, &lt;code&gt;_line()&lt;/code&gt;, which expects lines like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 2006 02 06 01 25  -10.4  983.2  23.5 260.1

 use DateTime;
 sub _line {
     my ($class, $line) = @_;
     my @vals = split /\s+/, $line;

     # extract time fields and turn into DateTime object
     my($y, $m, $d, $h, $min)
        = $line =~ /^(\d{4}) (\d\d) (\d\d) (\d\d) (\d\d)/;

     my $t = DateTime-&amp;gt;new(year=&amp;gt;$y,month=&amp;gt;$m,day=&amp;gt;$d,hour=&amp;gt;$h,minute=&amp;gt;$min);

     # return a new Z::Weather record, using the magic new() method
     return $class-&amp;gt;new({time =&amp;gt; $t,
                         temp     =&amp;gt; $vals[5],
                         pressure =&amp;gt; $vals[6],
                         wind     =&amp;gt; $vals[7],
                         dir      =&amp;gt; $vals[8],  });
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;split&lt;/code&gt; and Perl&amp;rsquo;s magic make sense of the data points, and the &lt;a href=&#34;https://metacpan.org/pod/DateTime&#34;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; module take cares of the details of when the record was produced. I find it much easier to turn any time-related value into a &lt;code&gt;DateTime&lt;/code&gt; object at the soonest possible moment, so that the rest of my code can expect &lt;code&gt;DateTime&lt;/code&gt; objects. It becomes easier to reuse in other projects. If you find yourself writing code to handle leap years every other day, then make using &lt;code&gt;DateTime&lt;/code&gt; your number one new habit.&lt;/p&gt;

&lt;p&gt;I deal with the mast data in a similar way, except that the other format is fixed-length binary records. The time of the recording is stored in the first four bytes as the number of seconds into an arbitrary epoch. I correct this into Unix time when creating its &lt;code&gt;DateTime&lt;/code&gt; object. Values are stored as two-byte, network-endian unsigned shorts stored as hundredths of the recorded values. &lt;code&gt;unpack()&lt;/code&gt; comes to my aid here.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; sub from_file {
   my $class = shift;
   my $io    = io(shift);
   my ($rec, @recs);

   while ($io-&amp;gt;read($rec, 62) == 62) {
     push @recs, $class-&amp;gt;_record($rec);
   }
   return @recs;
 }

 # map height of reading to offsets in binary record
 our %heights = qw(1 24  2 28 4 32  8 36  15 40  30 44);
 use constant MAST_EPOCH =&amp;gt; 2082844800;

 sub _record {
   my ($class, $rec) = @_;

   # extract the time as a 4 byte network order integer, and correct epoch
   my $crazy_time = unpack(&amp;quot;N&amp;quot;, $rec);
   my $time       = DateTime-&amp;gt;from_epoch(epoch=&amp;gt;$crazy_time-MAST_EPOCH);

   # then a series of (speed, dir) 2 byte pairs further into the record
   my @vals;
   foreach my $offset (sort values %heights) {
     my ($speed, $dir) = unpack(&amp;quot;nn&amp;quot;, substr($rec, $offset));
     push @vals,
       Z::Mast::Level-&amp;gt;new({wind=&amp;gt;$speed*100,
                            dir =&amp;gt; $dir*100,
                            level=&amp;gt;$heights{$offset}});
   }
   return $class-&amp;gt;new({time =&amp;gt; $time,
                       values =&amp;gt; \@vals});
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, I can call this using any one of the types supported by &lt;code&gt;IO::All&lt;/code&gt;. Again, I wield &lt;code&gt;DateTime&lt;/code&gt; to my advantage to turn a time stored in an unusual epoch quickly into an object which anything or anyone else can understand. There are a few magic numbers here, but that&amp;rsquo;s what you end up with when you deal with other people&amp;rsquo;s crazy file formats. The key thing is to record magic numbers in one place, to allow other people to change them if they need to, both in your code and from their own code (hence the &lt;code&gt;our&lt;/code&gt; variable), and finally, to let values pass from undocumented darkness into visible, named objects as soon as possible.&lt;/p&gt;

&lt;h3 id=&#34;displaying-data&#34;&gt;Displaying Data&lt;/h3&gt;

&lt;p&gt;I now have hold of the weather data and have forced it into a form that I can follow. Now I get to show it to someone else. I did this in two different ways: as raw data through a web page and as a pre-generated chart embedded in the page.&lt;/p&gt;

&lt;p&gt;In each case, the code has to read in files to obtain the necessary data:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; my @weather_records = Z::Weather-&amp;gt;from_file(&#39;weather.data.dat&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then it needs to produce the web page:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; use Template;
 my $template = Template-&amp;gt;new();

 print &amp;quot;Content-type: text/html\n\n&amp;quot;;

 $template-&amp;gt;process(\*DATA, {
                       now =&amp;gt; $weather_records[-1],
                       records =&amp;gt; \@weather_records,
                             })
    || die &amp;quot;Could not process template: &amp;quot;.$template-&amp;gt;error().&amp;quot;\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This isn&amp;rsquo;t really all that interesting. In fact, it looks almost like this does nothing at all. I&amp;rsquo;ve pulled in the &lt;code&gt;Template&lt;/code&gt; module, told it to build and output a template defined after the &lt;code&gt;__END__&lt;/code&gt; of the script, and given it two template variables to play with. The template looks something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; __END__
 &amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;Weather&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;
 &amp;lt;body&amp;gt;
 &amp;lt;h2&amp;gt;Latest weather data at [% now.time %]&amp;lt;a name=&amp;quot;/h2&amp;quot;&amp;gt;

 &amp;lt;P&amp;gt;T: [% now.temp %] &amp;amp;deg;C
    P: [% now.pressure %] kPa
    W: [% now.wind %] kts
    D: [% now.dir %] &amp;amp;deg;&amp;lt;/p&amp;gt;

 &amp;lt;P&amp;gt;&amp;lt;img src=&amp;quot;/weather_chart.png&amp;quot;&amp;gt;&amp;lt;br&amp;gt;
    &amp;lt;img src=&amp;quot;/mast_chart.png&amp;quot;&amp;lt;/p&amp;gt;

 &amp;lt;table&amp;gt;
 &amp;lt;tr&amp;gt;&amp;lt;th&amp;gt; Time &amp;lt;/th&amp;gt;&amp;lt;th&amp;gt; Temp &amp;lt;/th&amp;gt;&amp;lt;th&amp;gt; Wind &amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;
 [% FOREACH rec IN records %]
 &amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;[% rec.time %]&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;[% rec.temp %]&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;[% rec.wind %]&amp;lt;/td&amp;gt;
 &amp;lt;/tr&amp;gt;
 [% END %]
 &amp;lt;/table&amp;gt;
 &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The template uses the syntax of the &lt;a href=&#34;http://www.template-toolkit.org/&#34;&gt;&lt;code&gt;Template-Toolkit&lt;/code&gt;&lt;/a&gt;, a general-purpose templating framework. It&amp;rsquo;s useful because it allows the separation of display and formatting of data from the code that generates it. There&amp;rsquo;s no Perl code in the template, and no HTML will appear in any of my Perl code. While the output generated now is ugly and basic, it will be easy to make it flashy later, once I have the program working, without having to change anything in the program itself to do so. As I&amp;rsquo;ve prepared our data carefully as objects with sensible methods, I can just hand a bunch of these over to the template and let it suck out whatever it wants to show.&lt;/p&gt;

&lt;h3 id=&#34;pretty-pictures&#34;&gt;Pretty Pictures&lt;/h3&gt;

&lt;p&gt;Producing the charts is, again, a simple business (by now, the theme of this article should be emerging). Gone are the days when you&amp;rsquo;d have to scratch your head figuring out how to draw lines and plot points; gone even are the days when you have to bang your head hard against the confused API of some long-forgotten module. Taking the mast values as an example, I first need to read in the data:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; my @mast_values = Z::Mast-&amp;gt;from_file(&#39;mast.data.dat&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because old weather is old news, I throw away any values older than three hours, using &lt;code&gt;DateTime&lt;/code&gt; and &lt;a href=&#34;https://metacpan.org/pod/DateTime::Duration&#34;&gt;&lt;code&gt;DateTime::Duration&lt;/code&gt;&lt;/a&gt; methods in a &lt;code&gt;grep&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; use DateTime;
 use DateTime::Duration;

 my $now = DateTime-&amp;gt;now();
 my $age = DateTime::Duration-&amp;gt;new(hours =&amp;gt; 3);

 @mast_values = grep { $_-&amp;gt;time + $age &amp;gt; $now } @mast_values;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is so, so much easier than fiddling around with epochs and &lt;code&gt;3*3600&lt;/code&gt; all over the place. If you find yourself writing 3600 anywhere in your code, you should be using &lt;code&gt;DateTime::Duration&lt;/code&gt; instead. Next, I feed the data points into the &lt;a href=&#34;https://metacpan.org/pod/Chart::Lines&#34;&gt;&lt;code&gt;Chart::Lines&lt;/code&gt;&lt;/a&gt; module, a part of the &lt;a href=&#34;https://metacpan.org/pod/Chart&#34;&gt;&lt;code&gt;Chart&lt;/code&gt;&lt;/a&gt; distribution. I use this in three phases. First, I create a new &lt;code&gt;Chart&lt;/code&gt; and specify how large the resulting graphic should be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; use Chart::Lines;
 my $chart = Chart::Lines-&amp;gt;new($x_size, $y_size);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then I set up a few options to tweak how the chart will display:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $chart-&amp;gt;set(
    legend          =&amp;gt; &#39;none&#39;,
    xy_plot         =&amp;gt; &#39;true&#39;,
    grey_background =&amp;gt; 0,
    y_label         =&amp;gt; &#39;Wind kts&#39;,
    x_label         =&amp;gt; &#39;Hours ago&#39;,
    colors          =&amp;gt; {
      y_label    =&amp;gt; [0xff, 0xee, 0xee],
      text       =&amp;gt; [0xff,0xee,0xff],
      dataset0   =&amp;gt; [0xff,0,0],
      dataset1   =&amp;gt; [0,0xff,0xff],
      dataset2   =&amp;gt; [0,0,0xff],
      background =&amp;gt; [0x55, 0x00, 0x55],
                },
    );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These are mostly self-explanatory; the &lt;code&gt;Chart&lt;/code&gt; documentation covers them in detail. I set &lt;code&gt;xy_plot&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; so that the module will use the first dataset as the &lt;code&gt;x&lt;/code&gt; values and all of the other datasets as the &lt;code&gt;y&lt;/code&gt; values for a line. I set a bunch of rather bright colors, to keep my avid customers cheerful, and set the text used to label the chart.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; my @labels = map {($now-&amp;gt;epoch - $_-&amp;gt;time-&amp;gt;epoch) / 60} @mast_values;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, I used a series of &lt;code&gt;map&lt;/code&gt; expressions to extract &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; values from the data. One turns the &lt;code&gt;DateTime&lt;/code&gt; times into a number of minutes ago. These values are the &lt;code&gt;x&lt;/code&gt; values. &lt;code&gt;y&lt;/code&gt; values are the appropriate parameters extracted from the nested &lt;code&gt;Z::Mast&lt;/code&gt; and &lt;code&gt;Z::Mast::Label&lt;/code&gt; objects. The rest of the code provides the data to the plotting method of the chart, directing it to write out a .png file (Figure 1).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $chart-&amp;gt;png(&amp;quot;mast.png&amp;quot;,
               [ \@labels,
                [map {$_-&amp;gt;values()-&amp;gt;[0]-&amp;gt;wind} @mast_values],
                [map {$_-&amp;gt;values()-&amp;gt;[1]-&amp;gt;wind} @mast_values],
                [map {$_-&amp;gt;values()-&amp;gt;[2]-&amp;gt;wind} @mast_values],
                  ]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_05_04_charting-data/mast.png&#34; alt=&#34;the resulting chart&#34; width=&#34;500&#34; height=&#34;260&#34; /&gt;
&lt;em&gt;Figure 1. The resulting chart&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;All I need now is a working HTTP server and a &lt;code&gt;crontab&lt;/code&gt; entry or two to run the graphic generation programs. It is possible to use the &lt;code&gt;Chart&lt;/code&gt; modules to generate CGI output directly using the &lt;code&gt;Chart::cgi&lt;/code&gt; method, but I found that this was too slow once lots of different clients accessed the weather data at the same time. It was a simple task to instead switch to a &lt;code&gt;crontab&lt;/code&gt;-based approach for the graphs, with a CGI script still providing real-time access to the current values.&lt;/p&gt;

&lt;h3 id=&#34;conclusions&#34;&gt;Conclusions&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;Chart&lt;/code&gt; family of modules provides more than just an &lt;code&gt;x&lt;/code&gt;-&lt;code&gt;y&lt;/code&gt; plot. Pie, bar, Pareto, and mountain charts, amongst others, are available through the same API as I discussed in this article. They are just as easy to whip into being to satisfy even the most demanding of data consumers.&lt;/p&gt;

&lt;p&gt;The Template Toolkit is used mainly for more complicated websites and content management systems, but it will simplify the production of simple sites and pages, allowing you to concentrate on the detail of the problem by separating data and its presentation. Even though a problem is simple and allows a fast solution, you can reach your goal faster still by pulling in big tools to do little jobs.&lt;/p&gt;

&lt;p&gt;As for the &lt;code&gt;DateTime&lt;/code&gt; module, I simply wouldn&amp;rsquo;t go anywhere without it. These days, I find myself automatically typing &lt;code&gt;use DateTime;&lt;/code&gt; along with &lt;code&gt;warnings&lt;/code&gt; and &lt;code&gt;strict&lt;/code&gt; at the head of every Perl program I write.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Class::Accessors&lt;/code&gt; makes the creation of data representation objects faster than typing in a C struct, provides some level of documentation about what the data you&amp;rsquo;re dealing with, and allows for reuse. You could just stick everything into layers of nested hashes and arrays, but this is a certain path to eventual confusion. &lt;code&gt;Class::Accessors&lt;/code&gt; will keep you sane and save your fingers at the same time.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;IO::All&lt;/code&gt; should be a part of your day-to-day toolkit; the new idioms it provides will soon see you using it everywhere, even in one-liners.&lt;/p&gt;

&lt;p&gt;One of the many joys of programming lies in the satisfaction we receive when we make someone&amp;rsquo;s life that little bit better. Perl makes it easy, fast, and fun for us to tread that path. Perl&amp;rsquo;s greatest strength, the rock upon which its greatness is founded, is the speed with which we can take a problem, or a cool idea, and structure our half-formed thoughts into a soundly built solution.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2006_05_04_charting-data/purple_code.pl&#34;&gt;Download the example code&lt;/a&gt; for this article.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Test-Driving X11 GUIs</title>
      <link>http://localhost:1313/pub/2006/02/02/x11_gui_testing.html/</link>
      <pubDate>Thu, 02 Feb 2006 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2006/02/02/x11_gui_testing.html/</guid>
      <description>

&lt;h3 id=&#34;driving-x11-guis-using-x11-guitest&#34;&gt;Driving X11 GUIs using X11::GUITest&lt;/h3&gt;

&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;Interfaces to GUI applications like &lt;a href=&#34;http://developer.kde.org/documentation/library/kdeqt/kde3arch/dcop.html&#34;&gt;DCOP&lt;/a&gt; or &lt;a href=&#34;http://www.freedesktop.org/Software/dbus&#34;&gt;D-BUS&lt;/a&gt; allow you to interact with GUI applications in order to get at their internal states or set some arbitrary states.&lt;/p&gt;

&lt;p&gt;Sometimes GUIs don&amp;rsquo;t allow for such interaction and you need to &amp;ldquo;click&amp;rdquo; them. If you&amp;rsquo;re writing such an application, you need some sort of regression tests for it to make sure your widget/windows are as accessible as they should be. If this is the case, there is a Perl module to help you: &lt;a href=&#34;https://metacpan.org/pod/X11::GUITest&#34;&gt;X11::GUITest&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Be aware that &lt;code&gt;X11::GUITest&lt;/code&gt; allows you to drive a GUI, but you can&amp;rsquo;t &amp;ldquo;read&amp;rdquo; data written in a widget, such as a button or an edit box. More on this in the Limitations section below.&lt;/p&gt;

&lt;p&gt;To install &lt;code&gt;X11::GUITest&lt;/code&gt;, run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl -MCPAN -e &#39;shell&#39;
install X11::GUITest
quit
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-simple-example&#34;&gt;A Simple Example&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;ve included two example programs. One is &lt;a href=&#34;http://localhost:1313/media/_pub_2006_02_02_x11_gui_testing/tested.pl&#34;&gt;&lt;em&gt;tested.pl&lt;/em&gt;&lt;/a&gt; and it serves as an example GUI. The other is &lt;a href=&#34;http://localhost:1313/media/_pub_2006_02_02_x11_gui_testing/tester.pl&#34;&gt;&lt;em&gt;tester.pl&lt;/em&gt;&lt;/a&gt; that starts and drives the tested program.&lt;/p&gt;

&lt;p&gt;You need Tk installed for the tested GUI. Tk comes as a package in most GNU/Linux distributions or other *NIX OSes. Download both files in the same folder, run &lt;em&gt;./tester.pl&lt;/em&gt;, and watch.&lt;/p&gt;

&lt;p&gt;What are they doing and how do they work?&lt;/p&gt;

&lt;h3 id=&#34;starting-a-gui&#34;&gt;Starting a GUI&lt;/h3&gt;

&lt;p&gt;First thing to do prior to driving a GUI is to start the driven program. While you can use &lt;code&gt;fork&lt;/code&gt; and &lt;code&gt;exec&lt;/code&gt; or any other means, &lt;code&gt;X11::GUITest&lt;/code&gt; comes with a routine of its own.&lt;/p&gt;

&lt;p&gt;Use &lt;code&gt;StartApp( $tested_application );&lt;/code&gt; to start a GUI, which results in starting the desired application in an asynchronous manner.&lt;/p&gt;

&lt;p&gt;If you want to start an application and wait for it to finish before going on, use &lt;code&gt;RunApp&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;finding-a-window&#34;&gt;Finding a Window&lt;/h3&gt;

&lt;p&gt;After having the GUI started, you need to search for it among the other open windows on your desktop. For this, use &lt;code&gt;FindWindowLike()&lt;/code&gt;, &lt;code&gt;WaitWindowLike()&lt;/code&gt;, or &lt;code&gt;WaitWindowViewable()&lt;/code&gt;, depending on what you need. Their names are pretty much self-explanatory.&lt;/p&gt;

&lt;p&gt;Usually you need to have only one instance of the tested application started:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@windows = FindWindowLike( $tested_app_title );
print &amp;quot;* Number of $tested_app_title windows found: &amp;quot;, scalar @windows, &amp;quot;\n&amp;quot;;

if ( @windows == 1 ) {
     print &amp;quot;* Only one instance found, going on ...\n&amp;quot;;
} else {
    print &amp;quot;* The number of $tested_app_title instances is different than 1\n&amp;quot;;
    print &amp;quot;exiting ...\n&amp;quot;;
    exit;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;FindWindowLike()&lt;/code&gt; returns a list of windows that match the search criteria, which is a regular expression to match against the window title. In case there is more than one window that matches the criteria, either you have the same window started multiple times, or the regular expression isn&amp;rsquo;t specific enough.&lt;/p&gt;

&lt;h3 id=&#34;sending-keyboard-events-to-an-application&#34;&gt;Sending Keyboard Events to an Application&lt;/h3&gt;

&lt;p&gt;Having found the window, (when you know that there is only one, you can access it as the first element of &lt;code&gt;@windows&lt;/code&gt;, namely &lt;code&gt;$windows[0]&lt;/code&gt;), you probably want to send it some keystrokes. Use &lt;code&gt;SendKeys()&lt;/code&gt; to do this.&lt;/p&gt;

&lt;p&gt;If you are having a busy X server, or just want your testing to be easy for the human eye to watch, set the delay between the keystrokes (in milliseconds) with &lt;code&gt;SetKeySendDelay()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SetKeySendDelay( $delay );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To send &lt;code&gt;Alt&lt;/code&gt;+&lt;code&gt;O&lt;/code&gt;, followed by a delay of &lt;code&gt;$delay&lt;/code&gt; milliseconds, then &lt;code&gt;e&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SendKeys( &#39;%(o)e&#39; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Besides sending plain text to an application, like sending the infamous &amp;ldquo;Hello World&amp;rdquo; to an editor window, you may have noticed that the previous example sent a combination of keys. Do so by using modifiers. The modifier keys are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt;, &lt;code&gt;Ctrl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%&lt;/code&gt;, &lt;code&gt;Alt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;Shift&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code&gt;X11::GUITest&lt;/code&gt; documentation has a complete list of special keys and their &amp;ldquo;encodings.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;You may also find it useful to use &lt;code&gt;QuoteStringForSendKeys()&lt;/code&gt; in the case of complicated strings.&lt;/p&gt;

&lt;h3 id=&#34;sending-mouse-events-to-an-application&#34;&gt;Sending Mouse Events to an Application&lt;/h3&gt;

&lt;p&gt;Sending keys may be not enough in some situations. Having an application that has keyboard shortcuts is nice, but not all of them support it. Sometimes you may need to send mouse events.&lt;/p&gt;

&lt;p&gt;To get the absolute position of the appropriate window on your desktop:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my ($x, $y, $width, $height) = GetWindowPos($edit_windows[0]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Suppose that you want to click right in the middle of it. First, compute the position of the middle of the window:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$x += $width  / 2;
$y += $height / 2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now move the mouse:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MoveMouseAbs( $x, $y );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then press the right mouse button:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PressMouseButton M_RIGHT;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Do something useful, and then release the mouse button. (Don&amp;rsquo;t forget to do that when you&amp;rsquo;re using &lt;code&gt;PressMouseButton&lt;/code&gt;; otherwise, you may experience &amp;ldquo;strange&amp;rdquo; desktop behavior when your testing application exits.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ReleaseMouseButton M_RIGHT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You could replace &lt;code&gt;PressMouseButton()&lt;/code&gt; and &lt;code&gt;ReleaseMouseButton()&lt;/code&gt; with &lt;code&gt;ClickMouseButton()&lt;/code&gt; if you don&amp;rsquo;t have anything to do between pressing and releasing the mouse button.&lt;/p&gt;

&lt;p&gt;In the example programs, there&amp;rsquo;s something to do&amp;ndash;navigating the context menu with keystrokes.&lt;/p&gt;

&lt;h3 id=&#34;moving-a-window&#34;&gt;Moving a Window&lt;/h3&gt;

&lt;p&gt;This is a neat and interesting feature: the ability to move windows. While it is useful to impress your friends with having their favorite mail program moving up and down, its utility lies in the fact that you can arrange the tested windows on the desktop so they are all visible.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MoveWindow( $window_id, $x, $y );
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;limitations&#34;&gt;Limitations&lt;/h3&gt;

&lt;p&gt;As you may have noticed reading the example code, there is almost no way of validating the fact that you are indeed interacting with the right widget or window. The functions you can use for this are &lt;code&gt;FindWindow*&lt;/code&gt; or &lt;code&gt;WaitWindow*&lt;/code&gt;, which return a list of windows whose titles match an arbitrary regexp, and the functions that deal with child windows, such as &lt;code&gt;IsChild()&lt;/code&gt; and &lt;code&gt;GetChildWindows()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;While you may pass the window ID to a testing program, using external means to validate the tested application (such as indicating the coordinates on the screen), the problem is that you can&amp;rsquo;t grab a widget&amp;rsquo;s contents.&lt;/p&gt;

&lt;p&gt;Also, while you might be tempted to parse the child tree of an application to get from the main window to one of its children, this doesn&amp;rsquo;t work every time. Plenty of GUIs spawn other windows at the top level, and the spawned windows have as root window the topmost window (which is the desktop).&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an example of the problem that uses Mozilla Firefox. Before running the test, you must meet some prerequisites:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Back up your preferences before running the tests.&lt;/li&gt;
&lt;li&gt;Go to Edit -&amp;gt; Preferences -&amp;gt; General -&amp;gt; Connection Settings and set it to &amp;ldquo;Direct connection to the Internet.&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Click OK, and then OK, and close the browser.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now run the &lt;em&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2006_02_02_x11_gui_testing/Firefox.pl&#34;&gt;Firefox.pl&lt;/a&gt;&lt;/em&gt; example code.&lt;/p&gt;

&lt;p&gt;The test program assumes that when the Preferences window pops up, the General menu is selected.&lt;/p&gt;

&lt;p&gt;Open Mozilla Firefox again, go to Preferences, select the Web Features menu, click OK, and exit the browser.&lt;/p&gt;

&lt;p&gt;Rerun the &lt;em&gt;Firefox.pl&lt;/em&gt; program, and watch it.&lt;/p&gt;

&lt;p&gt;It has no idea which menu is selected, because every menu component belongs to the same window, having the same title.&lt;/p&gt;

&lt;h3 id=&#34;writing-guis-for-testability&#34;&gt;Writing GUIs for Testability&lt;/h3&gt;

&lt;p&gt;Having in mind the strengths and weaknesses of &lt;code&gt;X11::GUITest&lt;/code&gt;, it&amp;rsquo;s critical to design graphical user interfaces that are easy to test. This way, you shorten your maintenance time, as you can have a tester program that can help check that the GUI hasn&amp;rsquo;t lost some of its windows in the development/maintenance process.&lt;/p&gt;

&lt;p&gt;Of course, when displaying a license text when your GUI starts, you don&amp;rsquo;t have the means to check that the contents are unchanged using &lt;code&gt;X11::GUITest&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;What you can do is to ensure that all child windows are &amp;ldquo;in place&amp;rdquo; and that a user can access them in the same way as he/she could in previous versions.&lt;/p&gt;

&lt;p&gt;If you define ways of navigating the GUI using keyboard shortcuts so that you can reach any &amp;ldquo;leaf&amp;rdquo; window starting from the top-level window, then it&amp;rsquo;s trivial for a test program to navigate the same way you do and ensure that all windows are reachable as they were in previous versions.&lt;/p&gt;

&lt;p&gt;Consider the following code based on the tested Tk program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$menu{&#39;OTHER&#39;} = $menu_bar-&amp;gt;cascade(
    -label   =&amp;gt; &#39;Other&#39;,
    -tearoff =&amp;gt; 0,
);

$menu{&#39;OTHER&#39;}-&amp;gt;command(
    -label   =&amp;gt; &#39;Editor&#39;,
    -command =&amp;gt; sub {
        edit_window();
    }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It defines a piece of menu from the overall menu of the application. As you may notice, there are no keyboard shortcuts that you can use to access the Editor window.&lt;/p&gt;

&lt;p&gt;Thinking of testability, you could go to some lengths to test this piece of code to ensure that the Editor window is reachable and that it indeed pops up. You could record the application&amp;rsquo;s position on the screen and then click the Other button, then move the mouse over the Editor button and click it. I&amp;rsquo;m sure you can spot some caveats here, among them:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;You need to make sure that the application is always on the screen at some known coordinates (use &lt;code&gt;GetWindowPos()&lt;/code&gt;) or maybe that the test always moves the window to the same place (use &lt;code&gt;MoveWindow()&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;You have to take into consideration font size changes, localization, and resolution changes so that you are sure you are clicking in the right place.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This kind of testing is fragile and error-prone. You can make things simpler and more robust: add keyboard shortcuts for each action. You gain two main benefits: you make some users (like me) happier and ease the testing process. You just need to define all the &amp;ldquo;paths&amp;rdquo; that you need to &amp;ldquo;walk&amp;rdquo; and define the child window titles so you know you&amp;rsquo;ve reached them.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a slight adjustment to the tested application so that it provides keyboard shortcuts:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$menu{&#39;OTHER&#39;} = $menu_bar-&amp;gt;cascade(
    -label   =&amp;gt; &#39;~Other&#39;,
    -tearoff =&amp;gt; 0,
);

$menu{&#39;OTHER&#39;}-&amp;gt;command(
    -label   =&amp;gt; &#39;~Editor&#39;,
    -command =&amp;gt; sub {
        edit_window();
    }
);

sub edit_window {
    # some initialization code here ...

    $edit_window = $main_window-&amp;gt;Toplevel();

    # Set the title of the Editor window
    $edit_window-&amp;gt;title(&amp;quot;This is an edit window&amp;quot;);

    # the rest of the code here ....

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This piece of code is easier to test. Navigate the application until you reach the Editor window:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SendKeys(&#39;%(o)e&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you should have the Editor window spawned. Grab a list of windows having the title matching the Editor window&amp;rsquo;s title:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@edit_windows = FindWindowLike( $edit_title );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check to see whether the Editor window is present. Also, there should be only one Editor window started:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ( @edit_windows == 1 ) {
    # code here
} else {
    # we have zero or more than one Editor window, so something is not quite
    # right
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This kind of code is easy to extend, as you can store the application window hierarchy in some external file outside of the program source (in some sort of markup language file, or anything that suits your needs). Having this external definition of the windows&amp;rsquo; hierarchy and their properties, the tester program can read the same file the tested application uses; thus, both know the same keyboard shortcuts and window titles.&lt;/p&gt;

&lt;p&gt;Program logic errors and/or bugs in underlying libraries used are easier to catch before you release the software.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;As you can see, there is no easy way to test an entire GUI application with &lt;code&gt;X11::GUITest&lt;/code&gt;, but you can test the important parts. Also, for some actions you can use a mixed approach, such as initiating an event using the application interface (connecting to a remote server protected with a user/password auth scheme) and picking the results from a log file.&lt;/p&gt;

&lt;p&gt;While the testing done in the previous paragraph is necessary, it is not sufficient. It would be great if there were someone willing to pick up the module and research whether it could be possible for &lt;code&gt;X11::GUITest&lt;/code&gt; to be able to fetch data from the widgets, making it possible to &amp;ldquo;read&amp;rdquo; the contents of a window (from a text widget, for example).&lt;/p&gt;

&lt;p&gt;This kind of testing is more complete than simply driving the GUI.&lt;/p&gt;

&lt;p&gt;Of course, you could also use &lt;code&gt;X11::GUITest&lt;/code&gt; to write a &amp;ldquo;record and playback&amp;rdquo; application. You might only need &lt;code&gt;GetMousePos()&lt;/code&gt;, &lt;code&gt;IsMouseButtonPressed()&lt;/code&gt;, and the other mouse functions. As I said earlier, in my opinion this kind of testing is too fragile.&lt;/p&gt;

&lt;p&gt;The problem is that you can&amp;rsquo;t validate the contents of the windows.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Making Menus with wxPerl</title>
      <link>http://localhost:1313/pub/2005/10/06/wxperl_menus.html/</link>
      <pubDate>Thu, 06 Oct 2005 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2005/10/06/wxperl_menus.html/</guid>
      <description>

&lt;p&gt;In a previous article about wxPerl published on Perl.com, Jouke Visser taught &lt;a href=&#34;http://localhost:1313/pub/2001/09/12/wxtutorial1.html&#34;&gt;the very basics of wxPerl programming&lt;/a&gt;. In this article, I will continue with Jouke&amp;rsquo;s work, explaining how to add menus in our wxPerl applications. I will cover the creation, editing, and erasure of menus with the &lt;a href=&#34;https://metacpan.org/pod/Wx::Menu&#34;&gt;Wx::Menu&lt;/a&gt; and Wx::MenuBar modules, and also will show examples of their use.&lt;/p&gt;

&lt;h3 id=&#34;conventions&#34;&gt;Conventions&lt;/h3&gt;

&lt;p&gt;I assume that you understand the wxPerl approach to GUI programming, so I won&amp;rsquo;t explain it here. The following code is the base for the examples in this article:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use strict;
use Wx;

package WxPerlComExample;

use base qw(Wx::App);

sub OnInit {
    my $self  = shift;
    my $frame = WxPerlComExampleFrame-&amp;gt;new(undef, -1, &amp;quot;WxPerl Example&amp;quot;);

    $frame-&amp;gt;Show(1);
    $self-&amp;gt;SetTopWindow($frame);

    return 1;
}

package WxPerlComExampleFrame;

use base qw(Wx::Frame);

use Wx qw( 
    wxDefaultPosition wxDefaultSize wxDefaultPosition wxDefaultSize wxID_EXIT
);

use Wx::Event qw(EVT_MENU);

our @id = (0 .. 100); # IDs array

sub new {
    my $class = shift;
    my $self  = $class-&amp;gt;SUPER::new( @_ );

    ### CODE GOES HERE ###

    return $self;
}

### PUT SUBROUTINES HERE ###

package main;

my($app) = WxPerlComExample-&amp;gt;new();

$app-&amp;gt;MainLoop();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;@id&lt;/code&gt; is an array of integer numbers to use as unique identifier numbers. In addition, the following definitions are important:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Menu bar&lt;/strong&gt;: The bar located at the top of the window where menus will appear. This is a particular instance of Wx::MenuBar.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Menu&lt;/strong&gt;: A particular instance of Wx::Menu.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Item&lt;/strong&gt;: An option inside of a (sub)menu.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;a-quick-example&#34;&gt;A Quick Example&lt;/h3&gt;

&lt;p&gt;Instead of wading through several pages of explanation before the first example, here is a short example that serves as a summary of this article. Note that I have divided it in two parts. Add this code to the base code in the &lt;code&gt;WxPerlComExampleFrame&lt;/code&gt; constructor:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Create menus
my $firstmenu = Wx::Menu-&amp;gt;new();
$firstmenu-&amp;gt;Append($id[0], &amp;quot;Normal Item&amp;quot;);
$firstmenu-&amp;gt;AppendCheckItem($id[1], &amp;quot;Check Item&amp;quot;);
$firstmenu-&amp;gt;AppendSeparator();
$firstmenu-&amp;gt;AppendRadioItem($id[2], &amp;quot;Radio Item&amp;quot;);

my $secmenu   = Wx::Menu-&amp;gt;new();
$secmenu-&amp;gt;Append(wxID_EXIT, &amp;quot;Exit\tCtrl+X&amp;quot;);

# Create menu bar
my $menubar   = Wx::MenuBar-&amp;gt;new();
$menubar-&amp;gt;Append($firstmenu, &amp;quot;First Menu&amp;quot;);
$menubar-&amp;gt;Append($secmenu, &amp;quot;Exit Menu&amp;quot;);

# Attach menubar to the window
$self-&amp;gt;SetMenuBar($menubar);
$self-&amp;gt;SetAutoLayout(1);

# Handle events only for Exit and Normal item
EVT_MENU( $self, $id[0], \&amp;amp;ShowDialog );
EVT_MENU( $self, wxID_EXIT, sub {$_[0]-&amp;gt;Close(1)} );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Insert the following code into the base code at the line &lt;code&gt;### PUT SUBROUTINES HERE ###&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Wx qw(wxOK wxCENTRE);

# The following subroutine will be called when you click in the normal item

sub ShowDialog {
  my($self, $event) = @_;
  Wx::MessageBox( &amp;quot;This is a dialog&amp;quot;, 
                  &amp;quot;Wx::MessageBox example&amp;quot;, 
                   wxOK|wxCENTRE, 
                   $self
               );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run this example to see something like Figures 1 and 2.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_10_06_wxperl_menus/qexample1.jpg&#34; alt=&#34;a menu with complex sub-items&#34; width=&#34;290&#34; height=&#34;224&#34; /&gt;
&lt;em&gt;Figure 1. A menu with complex sub-items&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_10_06_wxperl_menus/qexample2.jpg&#34; alt=&#34;a menu with a single sub-item&#34; width=&#34;290&#34; height=&#34;224&#34; /&gt;
&lt;em&gt;Figure 2. A menu with a single sub-item&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;programming-menus&#34;&gt;Programming Menus&lt;/h3&gt;

&lt;p&gt;To add a menu to your wxPerl application, you must know how to use two Perl modules that come with WxPerl: Wx::MenuBar and Wx::Menu. Wx::MenuBar creates and manages the bar that contains menus created with Wx::Menu. There is also a third module involved: Wx::MenuItem. This module, as its name implies, creates and manages menu items. You usually don&amp;rsquo;t need to use it, because almost all of the operations you need for a menu item are available through Wx::Menu methods.&lt;/p&gt;

&lt;h4 id=&#34;using-wx-menu&#34;&gt;Using Wx::Menu&lt;/h4&gt;

&lt;p&gt;Creating a menu with Wx::Menu is as easy as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $menu = Wx::Menu-&amp;gt;new();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now &lt;code&gt;$menu&lt;/code&gt; is a Wx::Menu object. WxPerl has five types of items. The first is the normal item, upon which you can click to get a response (a dialog or something else). The second is the check item, which has the Boolean property of being checked or not (independent of another check items). The third item is the radio item, which is an &amp;ldquo;exclusive check item;&amp;rdquo; if you check a particular radio item, other radio items in its radio group get unchecked instantly. The fourth type of item is the separator, which is just a straight line that acts as a barrier that separates groups of similar items inside of a menu. The fifth type is the submenu, an item that expands another menu when the mouse cursor is over it.&lt;/p&gt;

&lt;h5 id=&#34;setting-up-menu-items&#34;&gt;Setting Up Menu Items&lt;/h5&gt;

&lt;p&gt;To create a normal item for your menu, write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$menu-&amp;gt;Append($id, $label, $helpstr);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;code&gt;$id&lt;/code&gt; is an unique integer that identifies this item, &lt;code&gt;$label&lt;/code&gt; is the text to display on the menu, and &lt;code&gt;$helpstr&lt;/code&gt; is a string to display in the status bar. (This last argument is optional.) Note that every menu item must have an unique identifier number in order to be able to operate with this item during the rest of the program. (From now on, &lt;code&gt;$id&lt;/code&gt; will denote the unique identifier number of a menu item.)&lt;/p&gt;

&lt;p&gt;To create a check or radio item, the methods are analogous to &lt;code&gt;Append&lt;/code&gt;&amp;ndash;&lt;code&gt;AppendCheckItem&lt;/code&gt; and &lt;code&gt;AppendRadioItem&lt;/code&gt;, respectively. Add a separator with the &lt;code&gt;AppendSeparator&lt;/code&gt; method; it does not expect arguments. Create a submenu with the &lt;code&gt;AppendSubMenu&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$menu-&amp;gt;AppendSubMenu($id, $label, $submenu, $helpstr);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;code&gt;$submenu&lt;/code&gt; is an instance to another Wx::Menu object. (Don&amp;rsquo;t try to make that a submenu be a submenu of itself, because the Universe will crash or, in the best case, your program won&amp;rsquo;t execute at all.)&lt;/p&gt;

&lt;p&gt;While append methods add menu items in the last position of your menus, Wx::Menu gives you methods to add menu items at any position you want. For instance, to add a normal item at some position in a menu:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$menu-&amp;gt;Insert($pos, $id, $label, $helpstr);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;code&gt;$pos&lt;/code&gt; is the position of the item, starting at 0. To add a radio item, check item, or separator, use the &lt;code&gt;InsertRadioItem&lt;/code&gt;, &lt;code&gt;InsertCheckItem&lt;/code&gt;, or &lt;code&gt;InsertSeparator&lt;/code&gt; methods. As usual, the latter takes no arguments. To insert a submenu, use the &lt;code&gt;InsertSubMenu&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$menu-&amp;gt;InsertSubMenu($pos, $id, $label, $submenu, $helpstr);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also insert an item at the first position by using the &lt;code&gt;Prepend&lt;/code&gt; method:&lt;/p&gt;

&lt;p&gt;$menu-&amp;gt;Prepend($id, $label, $helpstr);&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PrependRadioItem&lt;/code&gt;, &lt;code&gt;PrependCheckItem&lt;/code&gt;, and &lt;code&gt;PrependSeparator&lt;/code&gt; methods are also available. As you might expect, there&amp;rsquo;s a &lt;code&gt;PrependSubMenu&lt;/code&gt; method that works like this:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$menu-&amp;gt;PrependSubMenu($id, $label, $submenu, $helpstr);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Sometimes, a menu grows to include too many menu items, and then it&amp;rsquo;s impractical to show them all. For this problem, Wx::Menu has the &lt;code&gt;Break&lt;/code&gt; method. When called, it causes Wx to place subsequently appended items into another column. Call this method like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$menu-&amp;gt;Break();
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;menu-item-methods&#34;&gt;Menu Item Methods&lt;/h5&gt;

&lt;p&gt;Once you have created your items, you need some way to operate on them, such as finding information about them through their identifier numbers, getting or setting their labels or help strings, enabling or disabling them, checking or unchecking them, or removing them. For example, you may want to retrieve some specific menu item in some point of your program. To do this, use the &lt;code&gt;FindItem&lt;/code&gt; method in either of two ways:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $menuitem_with_the_given_id = $menu-&amp;gt;FindItem($id);
my ($menuitem, $submenu)        = $menu-&amp;gt;FindItem($id);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;code&gt;$menuitem&lt;/code&gt; is the corresponding Wx::MenuItem object with the identifier &lt;code&gt;$id&lt;/code&gt;, and &lt;code&gt;$submenu&lt;/code&gt; is the (sub)menu to which &lt;code&gt;$menuitem&lt;/code&gt; belongs. You can also retrieve a menu item through the &lt;code&gt;FindItemByPosition&lt;/code&gt; method (but remember that positions start at 0):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $menuitem = $menu-&amp;gt;FindItemByPosition($pos);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wx::Menu provides methods to get or set properties of menu items. To set a property, there are two methods: &lt;code&gt;SetLabel&lt;/code&gt; and &lt;code&gt;SetHelpString&lt;/code&gt;. A &lt;code&gt;SetLabel&lt;/code&gt; call might be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$menu-&amp;gt;SetLabel($id, $newlabel);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;SetHelpString&lt;/code&gt; works similarly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$menu-&amp;gt;SetHelpString($id, $newhelpstr);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To retrieve the label or help string of a particular item, use the &lt;code&gt;GetLabel&lt;/code&gt; and &lt;code&gt;GetHelpString&lt;/code&gt; methods. Both methods expect the menu item identifier number as the sole argument.&lt;/p&gt;

&lt;p&gt;Every menu item has an &lt;em&gt;enabled&lt;/em&gt; property that makes an item available or unavailable. By default, all items are enabled. To enable or disable a particular menu item, use the &lt;code&gt;Enable&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$menu-&amp;gt;Enable($id, $boolean);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;code&gt;$boolean&lt;/code&gt; is 0 or 1, depending if you want to disable or enable it, respectively. Maybe your next question is how to check if a menu item is enabled; use the &lt;code&gt;IsEnabled&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$menu-&amp;gt;IsEnabled($id);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This returns &lt;code&gt;TRUE&lt;/code&gt; or &lt;code&gt;FALSE&lt;/code&gt;, depending on the status of the menu item.&lt;/p&gt;

&lt;p&gt;Radio items and check items have the &lt;em&gt;checked&lt;/em&gt; property that indicates the selection status of the item. By default, no check item is checked at the start of the execution of your program. For radio items, the first one created is checked at the start of execution. Use the &lt;code&gt;Check&lt;/code&gt; method to check or uncheck a radio or check item:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$menu-&amp;gt;Check($id, $boolean);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To determine if a menu item is checked, use &lt;code&gt;IsChecked&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$menu-&amp;gt;IsChecked($id);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This method, as does &lt;code&gt;IsEnabled&lt;/code&gt;, returns &lt;code&gt;TRUE&lt;/code&gt; or &lt;code&gt;FALSE&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s also possible to get the number of menu items your menu has. For this, use the &lt;code&gt;GetMenuItemCount&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$menu-&amp;gt;GetMenuItemCount();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;note that if &lt;code&gt;@args&lt;/code&gt; is the argument&amp;rsquo;s array, then &lt;code&gt;$menu-&amp;gt;Append(@args)&lt;/code&gt; and &lt;code&gt;$menu-&amp;gt;Insert($menu-&amp;gt;GetMenuItemCount(), @args)&lt;/code&gt; are the same.&lt;/p&gt;

&lt;p&gt;Finally, it&amp;rsquo;s important to know that there are three ways to remove an item from a menu (honoring Larry Wall&amp;rsquo;s phrase: &amp;ldquo;There&amp;rsquo;s more than one way to do it&amp;rdquo;). The first is the &lt;code&gt;Delete&lt;/code&gt; method, which just kills the menu item without compassion:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$menu-&amp;gt;Delete($id);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This method returns nothing. Be careful&amp;ndash;WxWidgets documentation says that the &lt;code&gt;Delete&lt;/code&gt; method doesn&amp;rsquo;t delete a menu item that&amp;rsquo;s a submenu. Instead, the documentation recommends that you use the &lt;code&gt;Destroy&lt;/code&gt; method to delete a submenu. In wxPerl, this isn&amp;rsquo;t true. &lt;code&gt;Delete&lt;/code&gt; is certainly capable of deleting a submenu, and is here equivalent to the &lt;code&gt;Destroy&lt;/code&gt; method. I don&amp;rsquo;t know the reason for this strange behavior.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Destroy&lt;/code&gt; method looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$menu-&amp;gt;Destroy($id);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to remove an item but not destroy it, then the &lt;code&gt;Remove&lt;/code&gt; method is for you. It allows you to store the menu item that you want to delete in a variable for later use, and at the same time delete it from its original menu. Use it like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $removed_item = $menu-&amp;gt;Remove($id);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you have your menu item with the identifier &lt;code&gt;$id&lt;/code&gt; in the &lt;code&gt;$removed_item&lt;/code&gt; variable (it now contains a Wx::MenuItem object). You can now use this variable to relocate the removed item into another menu with the append methods. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$other_menu-&amp;gt;Append($removed_item);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;does the same thing as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$other_menu-&amp;gt;Append($id_removed_item, $title_removed_item, 
    $helpstr_removed_item);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but in a shorter way.&lt;/p&gt;

&lt;p&gt;Finally, it&amp;rsquo;s useful to be able to remove a submenu&amp;rsquo;s menu item. You can&amp;rsquo;t use the &lt;code&gt;Destroy&lt;/code&gt;, &lt;code&gt;Delete&lt;/code&gt;, or &lt;code&gt;Remove&lt;/code&gt; methods, because they don&amp;rsquo;t work. Instead, you need to do something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my ($mitem, $submenu) = $menu-&amp;gt;FindItem($mitem_id);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;code&gt;$mitem_id&lt;/code&gt; is the identifier number of the submenu&amp;rsquo;s menu item you&amp;rsquo;re looking for. &lt;code&gt;$submenu&lt;/code&gt; is a Wx::Menu object, just as &lt;code&gt;$menu&lt;/code&gt; is, and hence you can use all the methods mentioned here, so the only thing you have to do to remove &lt;code&gt;$mitem&lt;/code&gt; from &lt;code&gt;$submenu&lt;/code&gt; is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$submenu-&amp;gt;Delete($mitem_id);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As the good reader that I am sure you are, you already have realized that this isn&amp;rsquo;t the only thing you can do with the &lt;code&gt;$submenu&lt;/code&gt; object. In fact, you can now add new menu items to your submenu, delete another menu item, and in general do everything mentioned already.&lt;/p&gt;

&lt;h4 id=&#34;using-wx-menubar&#34;&gt;Using Wx::MenuBar&lt;/h4&gt;

&lt;p&gt;You have created your menus and obviously want to use them. The last step to get the job done is to create the menu bar that will handle your menus. When you want to create a menu bar, the first step is to enable your code to handle menu events. This is the job of the Wx::Event module:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Wx::Event qw(EVT_MENU)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now create a Wx::MenuBar object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $menubar = Wx::MenuBar-&amp;gt;new();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This object will contain all of the menus that you want to show on your window. To associate a menu bar with a frame, call the &lt;code&gt;SetMenuBar&lt;/code&gt; method from Wx::Frame:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$self-&amp;gt;SetMenuBar($menubar);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;code&gt;$self&lt;/code&gt; is the Wx::Frame object inherited in &lt;code&gt;WxPerlComExampleFrame&lt;/code&gt;&amp;rsquo;s constructor. Note that if your application has MDI characteristics, or has many windows, then you have to take in account that Wx first sends menu events to the focused window. (I won&amp;rsquo;t cover this issue in this article, so for more information, review the WxWidgets documentation.) Finally, be sure to call the &lt;code&gt;EVT_MENU&lt;/code&gt; subroutine as many times as you have menu items that execute some action when clicked:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;EVT_MENU($self, $menu_item_id, \&amp;amp;subroutine);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;code&gt;$self&lt;/code&gt; is the object of your package&amp;rsquo;s &lt;code&gt;new&lt;/code&gt; method, &lt;code&gt;$menu_item_id&lt;/code&gt; is the unique identifier of the menu item involved, and &lt;code&gt;subroutine&lt;/code&gt; is the name of the subroutine that will handle the click event you want to catch.&lt;/p&gt;

&lt;h5 id=&#34;setting-up-menus&#34;&gt;Setting Up Menus&lt;/h5&gt;

&lt;p&gt;The first thing to do once you have created your menu bar is to attach your menus to the menu bar. There are two methods for this: &lt;code&gt;Append&lt;/code&gt; and &lt;code&gt;Insert&lt;/code&gt;. &lt;code&gt;Append&lt;/code&gt;, as you might expect, attaches a menu in the last position:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$menubar-&amp;gt;Append($menu, $label);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;code&gt;$menu&lt;/code&gt; is the menu created in the previous section and &lt;code&gt;$label&lt;/code&gt; is the name to display for this menu in the menu bar. To insert a menu in an arbitrary position, use the &lt;code&gt;Insert&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$menubar-&amp;gt;Insert($pos, $menu, $label);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;code&gt;$pos&lt;/code&gt; is the position of your menu, starting at 0.&lt;/p&gt;

&lt;h5 id=&#34;menu-methods&#34;&gt;Menu Methods&lt;/h5&gt;

&lt;p&gt;Wx::MenuBar provides some methods that are also present in Wx::Menu and work in the same way. This methods are &lt;code&gt;Check&lt;/code&gt;, &lt;code&gt;Enable&lt;/code&gt;, &lt;code&gt;FindItem&lt;/code&gt;, &lt;code&gt;GetLabel&lt;/code&gt;, &lt;code&gt;GetHelpString&lt;/code&gt;, &lt;code&gt;SetLabel&lt;/code&gt;, &lt;code&gt;SetHelpString&lt;/code&gt;, &lt;code&gt;IsChecked&lt;/code&gt;, and &lt;code&gt;IsEnabled&lt;/code&gt;. Besides these methods, Wx::MenuBar has its own set of methods to manage the properties of the menu bar. For example, as a menu item, a menu has its own &lt;em&gt;enabled&lt;/em&gt; property, which you toggle with the &lt;code&gt;EnableTop&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$menubar-&amp;gt;EnableTop($pos, $boolean);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;code&gt;$pos&lt;/code&gt; is the position of your menu (starting at 0) and &lt;code&gt;$boolean&lt;/code&gt; is &lt;code&gt;TRUE&lt;/code&gt; or &lt;code&gt;FALSE&lt;/code&gt;, depending on whether you want that menu enabled. Note that you can use this method only after you attach your menu bar to the window through the &lt;code&gt;SetMenuBar&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;Wx::MenuBar has methods to retrieve an entire menu or menu item given its title or (menu title, menu item label) pair, respectively. In the first case, use the code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$menu_with_the_given_title = $menubar-&amp;gt;FindMenu($title);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the second case:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$menu_item = $menubar-&amp;gt;FindMenuItem($menu_title, $menu_item_label);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In both cases, the returned variables are Wx::Menu objects. You can also retrieve a menu if you provide its position (starting at 0):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$menu_with_the_given_pos = $menubar-&amp;gt;GetMenu($pos);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As in the Wx::Menu case, Wx::MenuBar provides methods to set or get the label of a specific menu and to retrieve the number of menus in a menu bar. Those methods are &lt;code&gt;SetLabelTop&lt;/code&gt;, &lt;code&gt;GetLabelTop&lt;/code&gt;, and &lt;code&gt;GetMenuCount&lt;/code&gt; respectively. Use them like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$menu-&amp;gt;SetLabelTop($pos, $label);
my $menu_label = $menu-&amp;gt;GetLabelTop($pos);
my $num_menu   = $menu-&amp;gt;GetMenuCount();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;code&gt;$pos&lt;/code&gt; is the position of the menu and &lt;code&gt;$label&lt;/code&gt; is the new label that you want to put on your menu. Note that &lt;code&gt;GetLabelTop&lt;/code&gt;&amp;rsquo;s result doesn&amp;rsquo;t include accelerator characters inside the returned string.&lt;/p&gt;

&lt;p&gt;Finally, Wx::MenuBar gives two more choices to remove a menu. The first method is &lt;code&gt;Replace&lt;/code&gt;, which replaces it with another menu:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$menubar-&amp;gt;Replace($pos, $new_menu, $label);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where &lt;code&gt;$pos&lt;/code&gt; is the position of the menu to remove, &lt;code&gt;$new_menu&lt;/code&gt; is the new menu that will be in the &lt;code&gt;$pos&lt;/code&gt; position, and &lt;code&gt;$label&lt;/code&gt; is the label to display on the menu bar for &lt;code&gt;$new_menu&lt;/code&gt;. The second choice is to remove a menu, just by removing it with the &lt;code&gt;Remove&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $removed_menu = $menubar-&amp;gt;Remove($pos);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Remove&lt;/code&gt; returns the &lt;code&gt;$removed_menu&lt;/code&gt; object, so if you need it in the future, it&amp;rsquo;ll be still there waiting for you.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;With all of that explained, I can show a full, working example. As before, add this code to the base code in the blank spot in the &lt;code&gt;WxPerlComExampleFrame&lt;/code&gt; constructor.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Create menus
# Action&#39;s sub menu
my $submenu = Wx::Menu-&amp;gt;new();
$submenu-&amp;gt;Append($id[2], &amp;quot;New normal item&amp;quot;);
$submenu-&amp;gt;Append($id[3], &amp;quot;Delete normal item&amp;quot;);
$submenu-&amp;gt;AppendSeparator();
$submenu-&amp;gt;Append($id[4], &amp;quot;New check item&amp;quot;);
$submenu-&amp;gt;Append($id[5], &amp;quot;Delete check item&amp;quot;);
$submenu-&amp;gt;AppendSeparator();
$submenu-&amp;gt;Append($id[6], &amp;quot;New radio item&amp;quot;);
$submenu-&amp;gt;Append($id[7], &amp;quot;Delete radio item&amp;quot;);

# Disable items for this submenu
for(2..7) {
    $submenu-&amp;gt;Enable($id[$_], 0);
}

# Actions menu
my $actionmenu = Wx::Menu-&amp;gt;new();
$actionmenu-&amp;gt;Append($id[0], &amp;quot;Create Menu&amp;quot;); # Create new menu
$actionmenu-&amp;gt;Append($id[1], &amp;quot;Delete Menu&amp;quot;); # Delete New Menu
$actionmenu-&amp;gt;AppendSeparator();
$actionmenu-&amp;gt;AppendSubMenu($id[100], &amp;quot;New Item&amp;quot;, $submenu); # Create item submenu
$actionmenu-&amp;gt;AppendSeparator();
$actionmenu-&amp;gt;Append(wxID_EXIT, &amp;quot;Exit\tCtrl+X&amp;quot;); # Exit

# At first, disable the Delete Menu option
$actionmenu-&amp;gt;Enable($id[1], 0);

# Create menu bar
$self-&amp;gt;{MENU} = Wx::MenuBar-&amp;gt;new();
$self-&amp;gt;{MENU}-&amp;gt;Append($actionmenu, &amp;quot;Actions&amp;quot;);

# Attach menubar to the window
$self-&amp;gt;SetMenuBar($self-&amp;gt;{MENU});
$self-&amp;gt;SetAutoLayout(1);

# Handle events
EVT_MENU($self, $id[0], \&amp;amp;MakeActionMenu);
EVT_MENU($self, $id[1], \&amp;amp;MakeActionMenu);
EVT_MENU($self, $id[2], \&amp;amp;MakeActionNormal);
EVT_MENU($self, $id[3], \&amp;amp;MakeActionNormal);
EVT_MENU($self, $id[4], \&amp;amp;MakeActionCheck);
EVT_MENU($self, $id[5], \&amp;amp;MakeActionCheck);
EVT_MENU($self, $id[6], \&amp;amp;MakeActionRadio);
EVT_MENU($self, $id[7], \&amp;amp;MakeActionRadio);

EVT_MENU($self, wxID_EXIT, sub {$_[0]-&amp;gt;Close(1)});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code creates a menu called &lt;em&gt;Actions&lt;/em&gt; with the following options inside:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Create Menu&lt;/strong&gt;: When a user clicks this option, the program creates a new menu called &lt;em&gt;New Menu&lt;/em&gt; at the right side of the &lt;em&gt;Actions&lt;/em&gt; menu. The &lt;em&gt;Create Menu&lt;/em&gt; option is enabled by default, but creating the menu disables this option.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Delete Menu&lt;/strong&gt;: Deletes the menu created with &lt;em&gt;Create Menu&lt;/em&gt;. This option is disabled by default and is enabled when &lt;em&gt;New Menu&lt;/em&gt; exists.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;New normal item&lt;/strong&gt;: This option creates the &lt;em&gt;Normal item&lt;/em&gt; option on &lt;em&gt;New Menu&lt;/em&gt; when it exists. It is disabled by default.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Delete normal item&lt;/strong&gt;: Deletes &lt;em&gt;Normal item&lt;/em&gt; when it exists. It is disabled by default.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;New check item&lt;/strong&gt;: Creates the &lt;em&gt;Check item&lt;/em&gt; option on &lt;em&gt;New Menu&lt;/em&gt; when it exists. It is disabled by default. &lt;em&gt;Check item&lt;/em&gt; is unchecked by default.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Delete check item&lt;/strong&gt;: Deletes &lt;em&gt;Check item&lt;/em&gt; when it exists. It is disabled by default.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;New radio item&lt;/strong&gt;: Creates the &lt;em&gt;Radio item&lt;/em&gt; option on &lt;em&gt;New Menu&lt;/em&gt; when it exists. It is disabled by default. &lt;em&gt;Radio item&lt;/em&gt; is checked by default.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Delete radio item&lt;/strong&gt;: Deletes &lt;em&gt;Radio item&lt;/em&gt; when it exists. It is disabled by default.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Exit&lt;/strong&gt;: Exits the program.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once the code has created the menu, it attaches the menu to the menu bar saved on &lt;code&gt;$self-&amp;gt;{MENU}&lt;/code&gt;, then calls the &lt;code&gt;EVT_MENU&lt;/code&gt; subroutine eight times to handle all of the menu events from &lt;em&gt;Action&lt;/em&gt;&amp;rsquo;s menu items. Add the following code to the base code where it says &lt;code&gt;### PUT SUBROUTINES HERE ###&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Subroutine that handles menu creation/erasure
sub MakeActionMenu {
    my($self, $event) = @_;

    # Get Actions menu
    my $actionmenu    = $self-&amp;gt;{MENU}-&amp;gt;GetMenu(0);

    # Now check if we have to create or delete the New Menu
    if ($self-&amp;gt;{MENU}-&amp;gt;GetMenuCount() == 1) {
        # New Menu doesn&#39;t exist

        # Create menu
        my $newmenu = Wx::Menu-&amp;gt;new();
        $self-&amp;gt;{MENU}-&amp;gt;Append($newmenu, &amp;quot;New Menu&amp;quot;);       

        # Disable and Enable options
        $actionmenu-&amp;gt;Enable($id[0], 0); # New menu
        $actionmenu-&amp;gt;Enable($id[1], 1); # Delete menu
        $actionmenu-&amp;gt;Enable($id[2], 1); # New normal item
        $actionmenu-&amp;gt;Enable($id[3], 0); # Delete normal item
        $actionmenu-&amp;gt;Enable($id[4], 1); # New check item
        $actionmenu-&amp;gt;Enable($id[5], 0); # Delete check item
        $actionmenu-&amp;gt;Enable($id[6], 1); # New radio item
        $actionmenu-&amp;gt;Enable($id[7], 0); # Delete radio item
    } else {
        # New Menu exists

        # Remove menu
       $self-&amp;gt;{MENU}-&amp;gt;Remove(1);

        # Enable and disable options
        $actionmenu-&amp;gt;Enable($id[0], 1);

        for(1..7) {
               $actionmenu-&amp;gt;Enable($id[$_], 0);
        }
    }

    return 1;
}

# Subroutine that handles normal item creation/erasure
sub MakeActionNormal {
    my($self, $event) = @_;
    # Check if New Menu exists
    if($self-&amp;gt;{MENU}-&amp;gt;GetMenuCount() == 2) {
        # New menu exists

        # Get Action menu
        my $actionmenu = $self-&amp;gt;{MENU}-&amp;gt;GetMenu(0);
        my $newmenu    = $self-&amp;gt;{MENU}-&amp;gt;GetMenu(1);

        # Check if we have to create or delete a menu item
        if($actionmenu-&amp;gt;IsEnabled($id[2])) {
            # Create normal menu item
            $newmenu-&amp;gt;Append($id[50], &amp;quot;Normal item&amp;quot;);           

            # Disable and Enable options
            $actionmenu-&amp;gt;Enable($id[2], 0);
            $actionmenu-&amp;gt;Enable($id[3], 1);
        } else {
            # Delete menu item
               $newmenu-&amp;gt;Delete($id[50]);

            # Enable and disable options
            $actionmenu-&amp;gt;Enable($id[2], 1);
            $actionmenu-&amp;gt;Enable($id[3], 0);
        }
    }

    return 1;
}

# Subroutine that handles check item creation/erasure
sub MakeActionCheck {
    my($self, $event) = @_;

    # Check if New Menu exists
    if($self-&amp;gt;{MENU}-&amp;gt;GetMenuCount() == 2) {
        # New menu exists

        # Get Action menu
        my $actionmenu = $self-&amp;gt;{MENU}-&amp;gt;GetMenu(0);
        my $newmenu    = $self-&amp;gt;{MENU}-&amp;gt;GetMenu(1);

        # Check if we have to create or delete a menu item
        if($actionmenu-&amp;gt;IsEnabled($id[4])) {
            # Create check item
               $newmenu-&amp;gt;AppendCheckItem($id[51], &amp;quot;Check item&amp;quot;);

           # Disable and Enable options
           $actionmenu-&amp;gt;Enable($id[4], 0);
           $actionmenu-&amp;gt;Enable($id[5], 1);
        } else {
           # Delete menu item
           $newmenu-&amp;gt;Delete($id[51]);

              # Enable and disable options
              $actionmenu-&amp;gt;Enable($id[4], 1);
              $actionmenu-&amp;gt;Enable($id[5], 0);
        }
    }

    return 1;
}

# Subroutine that handles radio item creation/erasure

sub MakeActionRadio {
    my($self, $event) = @_;

    # Check if New Menu exists
    if($self-&amp;gt;{MENU}-&amp;gt;GetMenuCount() == 2) {
        # New menu exists

        # Get Action menu
        my $actionmenu = $self-&amp;gt;{MENU}-&amp;gt;GetMenu(0);
        my $newmenu    = $self-&amp;gt;{MENU}-&amp;gt;GetMenu(1);

        # Check if we have to create or delete a menu item
        if ($actionmenu-&amp;gt;IsEnabled($id[6])) {
               # Create radio item
              $newmenu-&amp;gt;AppendRadioItem($id[52], &amp;quot;Radio item&amp;quot;);

              # Disable and Enable options
              $actionmenu-&amp;gt;Enable($id[6], 0);
              $actionmenu-&amp;gt;Enable($id[7], 1);
        } else {
              # Delete menu item
              $newmenu-&amp;gt;Delete($id[52]);

              # Enable and disable options
              $actionmenu-&amp;gt;Enable($id[6], 1);
              $actionmenu-&amp;gt;Enable($id[7], 0);
        }
    }

    return 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;MakeActionMenu&lt;/code&gt; subroutine handles events for the &lt;em&gt;New Menu&lt;/em&gt; and &lt;em&gt;Delete Menu&lt;/em&gt; items. It first gets the &lt;em&gt;Actions&lt;/em&gt; menu and checks whether the &lt;em&gt;New Menu&lt;/em&gt; exists by retrieving the number of menus attached to the &lt;code&gt;$self-&amp;gt;{MENU}&lt;/code&gt; menu bar. If the new menu doesn&amp;rsquo;t exist, the number of menus in the menu bar is equal to 1, and the subroutine then creates &lt;em&gt;New Menu&lt;/em&gt;. If it exists, the subroutine deletes &lt;em&gt;New Menu&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;MakeActionNormal&lt;/code&gt;, &lt;code&gt;MakeActionCheck&lt;/code&gt;, and &lt;code&gt;MakeActionRadio&lt;/code&gt; subroutines are almost identical. They differ only in the involved identifier numbers. These subroutines handle events for &lt;em&gt;New normal item&lt;/em&gt;, &lt;em&gt;Delete normal item&lt;/em&gt;, &lt;em&gt;New check item&lt;/em&gt;, &lt;em&gt;Delete check item&lt;/em&gt;, &lt;em&gt;New radio item&lt;/em&gt;, and &lt;em&gt;Delete radio item&lt;/em&gt;, respectively. They first check if &lt;em&gt;New Menu&lt;/em&gt; exists (the number of menus attached to the menu bar is equal to 2). If so, they check if the options to create normal, check, or radio items are enabled, respectively. If the corresponding option is enabled, then the corresponding item doesn&amp;rsquo;t exist on &lt;em&gt;New Menu&lt;/em&gt;, and the subroutine creates it. If the option to create an item is disabled, then that item exists on &lt;em&gt;New Menu&lt;/em&gt; and hence it must be deleted. If &lt;em&gt;New Menu&lt;/em&gt; doesn&amp;rsquo;t exist, the subroutines do nothing. Figure 3 shows how there are no options available if &lt;em&gt;New Menu&lt;/em&gt; does not exist, and Figure 4 shows &lt;em&gt;New Menu&lt;/em&gt; with two options added.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_10_06_wxperl_menus/example1.jpg&#34; alt=&#34;no available options without New Menu&#34; width=&#34;289&#34; height=&#34;268&#34; /&gt;
&lt;em&gt;Figure 3. No available options without New Menu&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_10_06_wxperl_menus/example2.jpg&#34; alt=&#34;New Menu has menu options&#34; width=&#34;289&#34; height=&#34;268&#34; /&gt;
&lt;em&gt;Figure 4. New Menu has menu options&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;As this article has shown, menu programming with wxPerl is an extremely simple task. Wx::MenuBar and Wx::Menu&amp;rsquo;s methods are very easy to use and remember. If you understood this article, you can do anything possible with menus in your wxPerl programs.&lt;/p&gt;

&lt;p&gt;I have covered almost all of the available methods in Wx::Menu and Wx::MenuBar. I left out some methods related to pop-up menus, but I hope to cover these topics in future articles. WxPerl is a really great module, but its lack of adoption is due to its severe lack of documentation. This situation must be reversed, and this article is a small contribution to that cause.&lt;/p&gt;

&lt;h3 id=&#34;see-also&#34;&gt;See Also&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.wxwidgets.org/manuals/2.4.2/wx262.htm&#34;&gt;WxMenu tutorial&lt;/a&gt; and &lt;a href=&#34;http://www.wxwidgets.org/manuals/2.4.2/wx263.htm&#34;&gt;WxMenuBar tutorial&lt;/a&gt; by Julian Smart, Robert Roebling, Vadim Zeitlin, Robin Dunn, et al.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;&lt;a href=&#34;http://www.bzzt.net/~wxwidgets/icpp_wx2.html#menubar&#34;&gt;Adding a Menu Bar&lt;/a&gt;,&amp;rdquo; by David Beech.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;&lt;a href=&#34;http://localhost:1313/pub/2001/09/12/wxtutorial1.html&#34;&gt;wxPerl: Another GUI for Perl&lt;/a&gt;,&amp;rdquo; by Jouke Visser.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Data Munging with Sprog</title>
      <link>http://localhost:1313/pub/2005/06/23/sprog.html/</link>
      <pubDate>Thu, 23 Jun 2005 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2005/06/23/sprog.html/</guid>
      <description>

&lt;p&gt;We&amp;rsquo;ve all been there&amp;ndash;a data translation problem rears its head and you reach for your toolkit of Perl snippets. It might involve parsing a CSV file, extracting MIME attachments, generating bulk SQL insert statements, or scraping data from a web application. You know you have code lying around that&amp;rsquo;ll take you halfway there, if only you could find it. Then there&amp;rsquo;s the problem of pulling it all together.&lt;/p&gt;

&lt;p&gt;Wouldn&amp;rsquo;t it be great if there was a way to catalog your code snippets? How about a way to browse or search by keyword, a way to modularize your code for easy reuse, and a way to document it and easily access that documentation? Wouldn&amp;rsquo;t it be even better if you could pull the pieces together to assemble a solution without having to actually write code at all?&lt;/p&gt;

&lt;p&gt;Now there is. Now there&amp;rsquo;s Sprog.&lt;/p&gt;

&lt;h3 id=&#34;the-assignment&#34;&gt;The Assignment&lt;/h3&gt;

&lt;p&gt;Picture yourself as a sysadmin at Example Corp. Your boss calls you in to say he&amp;rsquo;s setting up an LDAP server and he needs you to whip up an Lightweight Directory Interchange Format (LDIF) file, containing every employee&amp;rsquo;s name, phone number, and email account information. Oh, and he needs it this afternoon, so you&amp;rsquo;d better get typing.&lt;/p&gt;

&lt;p&gt;You sit back down at your desk to contemplate your fate. Who ya gonna call? The answer hits you&amp;ndash;the company phone list on the intranet! It has all of the information you need (Figure 1); you just need to get it out.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_06_23_sprog/phonelist.gif&#34; alt=&#34;Phone List Web Page&#34; width=&#34;500&#34; height=&#34;367&#34; /&gt;
&lt;em&gt;Figure 1. The company phone list web page&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h3&gt;

&lt;p&gt;With a second flash of inspiration, you download the latest version of &lt;a href=&#34;http://sprog.sourceforge.net/&#34;&gt;Sprog&lt;/a&gt;. You install the Perl Gtk bindings and a few other modest prerequisites and before you know it, you&amp;rsquo;re looking at a clean green GUI (Figure 2).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_06_23_sprog/01_workbench.gif&#34; alt=&#34;The Sprog Workspace&#34; width=&#34;500&#34; height=&#34;367&#34; /&gt;
&lt;em&gt;Figure 2. The Sprog workspace&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A quick scan of the palette on the left reveals something labeled Retrieve URL, which sounds like a good start. Reading the instructions at the bottom of the window, you learn that the thing is a gear and that you can drag it across and drop it on the workspace.&lt;/p&gt;

&lt;p&gt;Having dragged the gear onto the workspace, you right-click on it and select Properties. Up pops a properties dialog (Figure 3), with a handy box where you paste in the URL of the phone list.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_06_23_sprog/02_properties.gif&#34; alt=&#34;A properties dialog&#34; width=&#34;500&#34; height=&#34;368&#34; /&gt;
&lt;em&gt;Figure 3. A properties dialog&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Next, you drag across the Text Window gear from the palette and drop it on top of the Retrieve URL gear. It snaps reassuringly into position so that the two gears&amp;rsquo; connectors fasten together securely (Figure 4).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_06_23_sprog/03_interlocked.gif&#34; alt=&#34;Two gears connected together&#34; width=&#34;250&#34; height=&#34;94&#34; /&gt;
&lt;em&gt;Figure 4. Two gears connected together&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://conferences.oreillynet.com/os2005/&#34;&gt;&lt;img src=&#34;http://conferences.oreillynet.com/images/os2005/banners/120x240.gif&#34; alt=&#34;O&amp;#39;Reilly Open Source Convention 2005.&#34; width=&#34;120&#34; height=&#34;240&#34; /&gt;&lt;/a&gt;
When you click the Run button on the toolbar, the machine leaps into life. The gears turn, it retrieves data, and a text window appears to display the HTML of the phone list page. Okay, great, you haven&amp;rsquo;t written a line of code and already you&amp;rsquo;ve replicated your browser&amp;rsquo;s View Source function.&lt;/p&gt;

&lt;p&gt;You save the machine to a file called &lt;em&gt;phonelist.sprog&lt;/em&gt; and then look for the next clue.&lt;/p&gt;

&lt;h3 id=&#34;making-connections&#34;&gt;Making Connections&lt;/h3&gt;

&lt;p&gt;Returning to the palette, you find a gear labelled Parse HTML Table. It looks promising, so you drag it onto the workbench. You pull apart the first two gears and attempt to add the new one in between them. Unfortunately, the new gear has a funny shaped output connector and the Text Window gear doesn&amp;rsquo;t seem to fit onto it.&lt;/p&gt;

&lt;p&gt;You right-click on the new gear and select Help. From the help page you learn that the output connector is a list connector. The gear takes a stream of HTML text and outputs rows of data, where each row is a list of values plucked from adjacent table cells.&lt;/p&gt;

&lt;p&gt;Once more, back at the palette, you discover a List To CSV gear, which has an input connector to match the table parser and an output connector to match the text window gear. You drag it over and snap them all together (Figure 5).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_06_23_sprog/04_to_csv.gif&#34; alt=&#34;Machine to produce CSV&#34; width=&#34;250&#34; height=&#34;152&#34; /&gt;
&lt;em&gt;Figure 5. A machine to produce CSV&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Now when you run the machine again, the text window fills with lovely CSV data. It&amp;rsquo;s not that you want CSV data, of course, but at least you can see that the machine has parsed the relevant data out from the HTML page. Or has it?&lt;/p&gt;

&lt;p&gt;On closer inspection, you realize that the machine has parsed the wrong table from the HTML. In true 1998 style, the page designer used nested tables to lay out the page. Even the list of navigation links is a table. Oh dear!&lt;/p&gt;

&lt;p&gt;The properties dialog for the Parse HTML Table gear allows you to specify which table you want to parse. The help page explains that you can enter just a number (such as 2 for the second table) or an XPath expression. There&amp;rsquo;s even an example XPath expression which you can cut and paste to select a table based on the contents of the first cell in the first row:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//table[./tr[1]/th[1 and contains(text(), &#39;First Name&#39;)]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As it happens, a bit of trial and error reveals that the phone list data is in the third table, so you set the selector to &lt;code&gt;3&lt;/code&gt;. Now when you run the machine, you see exactly the data you want in beautiful CSV format (not that you want CSV data, of course).&lt;/p&gt;

&lt;p&gt;Hang on! The data still isn&amp;rsquo;t quite right. The data values don&amp;rsquo;t contain any HTML tags, but they do seem to have lots of leading and trailing white space and embedded newlines. Racing back to the palette, you grab the Strip Whitespace gear, slot it into your machine and tweak its properties to specify exactly which white space you want stripped. Now when you run the machine again, you do get truly lovely CSV data (Figure 6).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_06_23_sprog/05_lovely_csv.gif&#34; alt=&#34;CSV output&#34; width=&#34;491&#34; height=&#34;266&#34; /&gt;
&lt;em&gt;Figure 6. CSV output&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Of course, there&amp;rsquo;s no getting away from the fact that you still don&amp;rsquo;t want CSV data.&lt;/p&gt;

&lt;h3 id=&#34;what-were-you-trying-to-do-again&#34;&gt;What Were You Trying To Do, Again?&lt;/h3&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;div class=&#34;secondary&#34;&gt;
&lt;p&gt;Did you know? Your email client can import LDIF files into your address book.&lt;/p&gt;
&lt;p&gt;To import an LDIF file into your Thunderbird address book:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Open your address book.&lt;/li&gt;
&lt;li&gt;Select Tools -&amp;gt; Import.&lt;/li&gt;
&lt;li&gt;Select Address Books and then Next.&lt;/li&gt;
&lt;li&gt;Select &amp;quot;Text file (LDIF ...)&amp;quot; and then Next.&lt;/li&gt;
&lt;li&gt;Select the LDIF file created from Sprog and then Open.&lt;/li&gt;
&lt;li&gt;Select Finish.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Remembering your original orders, you do a bit of reading about LDIF files. Your research shows that LDIF is a fairly simple text format. You need to generate a text file with an entry for each person separated by blank lines and formatted something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dn: uid=cat,ou=Staff,ou=People,dc=example,dc=com
objectClass: person
objectClass: inetOrgPerson
cn: Catherine Trenton
uid: cat 
sn: Trenton
givenName: Catherine
mail: cat@example.com
organizationName: Example Corp
telephoneNumber: 555-2349
mobileTelephoneNumber: 555-9623
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This looks like a job for a template, and sure enough, you find a gear entitled Apply Template (TT2) in the palette. The template gear&amp;rsquo;s input connector is unlike either the pipe or the list connectors you&amp;rsquo;ve encountered so far. The help page tells you it&amp;rsquo;s a record connector that passes data using Perl hashes rather than arrays.&lt;/p&gt;

&lt;p&gt;Back on the palette, you find a handy gear called &amp;ldquo;List to Record&amp;rdquo; that automagically converts lists to records by assuming the first row contains a column heading, which it uses for field names (hash keys). You remove the List To CSV gear and replace it with &amp;ldquo;List to Record,&amp;rdquo; followed by the Apply Template (TT2) gears. With a few clicks and drags, you reassemble your machine into its &amp;ldquo;almost final&amp;rdquo; shape (Figure 7).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_06_23_sprog/06_template_gear.gif&#34; alt=&#34;Machine including template gear&#34; width=&#34;250&#34; height=&#34;207&#34; /&gt;
&lt;em&gt;Figure 7. Machine including template gear&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;In the properties dialog for the template gear, you add a template:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dn: uid=[% email %],ou=Staff,ou=People,dc=example,dc=com
objectClass: person
objectClass: inetOrgPerson
cn: [% first_name %] [% surname %]
uid: [% email %]
sn: [% surname %]
givenName: [% first_name %]
mail: [% email %]
organizationName: Example Corp
telephoneNumber: [% phone %]
mobileTelephoneNumber: [% cell %]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The results are almost exactly what you want, except that there are a couple of places where you wanted a &lt;code&gt;uid&lt;/code&gt; field and the closest you had available was &lt;code&gt;email&lt;/code&gt;. You need to strip out the &lt;code&gt;@example.com&lt;/code&gt; from the &lt;code&gt;dn&lt;/code&gt; and &lt;code&gt;uid&lt;/code&gt; lines. You unplug the Text Window gear and insert a &amp;ldquo;Find and Replace&amp;rdquo; gear to fix the first occurrence (Figure 8):&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_06_23_sprog/07_fix_dn.gif&#34; alt=&#34;Find/replace to fix dn&#34; width=&#34;340&#34; height=&#34;199&#34; /&gt;
&lt;em&gt;Figure 8. Adding a &amp;ldquo;Find and Replace&amp;rdquo; gear&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;and another one to fix the second (Figure 9):&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_06_23_sprog/08_fix_uid.gif&#34; alt=&#34;Find/replace to fix uid&#34; width=&#34;340&#34; height=&#34;199&#34; /&gt;
&lt;em&gt;Figure 9. Adding another &amp;ldquo;Find and Replace&amp;rdquo; gear&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;and now the output is exactly like what you wanted (Figure 10).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_06_23_sprog/09_final_output.gif&#34; alt=&#34;Final output&#34; width=&#34;491&#34; height=&#34;330&#34; /&gt;
&lt;em&gt;Figure 10. Final output&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;You swap out the Text Window gear for a Write File gear, select a filename, and run the machine one last time (Figure 11).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_06_23_sprog/10_final_machine.gif&#34; alt=&#34;Final machine&#34; width=&#34;250&#34; height=&#34;264&#34; /&gt;
&lt;em&gt;Figure 11. The final machine&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ve finished the job and you never had to touch your semicolon key once.&lt;/p&gt;

&lt;h3 id=&#34;more-about-sprog&#34;&gt;More About Sprog&lt;/h3&gt;

&lt;p&gt;I hope this article has given you some idea of what&amp;rsquo;s possible with Sprog. It can be a useful addition to the toolbox of people who write scripts to transform data. Beyond that, though, I intend it to be a useful tool for people who don&amp;rsquo;t write scripts&amp;ndash;&lt;em&gt;scripting for the GUI guys&lt;/em&gt;, if you will. Anyone who&amp;rsquo;s smart enough to drive a spreadsheet is smart enough to drive Sprog. It&amp;rsquo;s just a different way of working with data. Even if the only thing those people use it for is getting data into a form their spreadsheets can handle, then that&amp;rsquo;s surely useful.&lt;/p&gt;

&lt;p&gt;Sprog is under active development, with the framework being extended and new gears added all the time. Writing your own gears is easier than you might imagine, and there is a mailing list to ask questions and share your ideas.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://sprog.sourceforge.net&#34;&gt;Sprog project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://lists.sourceforge.net/lists/listinfo/sprog-users&#34;&gt;Sprog mailing list&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2005_06_23_sprog/files.tar.gz&#34;&gt;Article example files&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Accessible Software</title>
      <link>http://localhost:1313/pub/2004/07/14/accessibility.html/</link>
      <pubDate>Thu, 15 Jul 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/07/14/accessibility.html/</guid>
      <description>

&lt;p&gt;Last year Perl.com published an &lt;a href=&#34;http://localhost:1313/pub/2003/08/28/pvoice.html&#34;&gt;article about pVoice&lt;/a&gt;. You learned what pVoice is, why it was built, and where it was supposed to go. Maybe you wanted to do something for disabled people yourself, by writing something like a mail client, a simple game like memory, or an instant-messaging client, but you didn&amp;rsquo;t implement it because you felt it was too much work. In that case there&amp;rsquo;s news for you.&lt;/p&gt;

&lt;p&gt;Part of pVoice was a set of modules that was actually the engine for the user interface. A few months ago I pulled those modules from the pVoice project and made them into a CPAN distribution. This distribution is called AAC::Pvoice. And no, they have nothing to do with Apple&amp;rsquo;s digital audio format. They&amp;rsquo;re all about Augmentative and Alternative Communication. Although, I like to think that the &amp;ldquo;C&amp;rdquo; stands for &amp;ldquo;Computing,&amp;rdquo; which makes it into a better description of what those modules are for.&lt;/p&gt;

&lt;p&gt;You can use the AAC::Pvoice modules to create GUI applications for people who have difficulty using conventional input devices like a mouse or a keyboard. Instead, those people can use your applications using only one or two keystrokes, mouse buttons, or switches on a wheelchair. You can also enhance the use of a conventional mouse or touch screen by highlighting objects on the screen as the mouse cursor hovers over them. AAC::Pvoice does not only handle the input for you, but it also provides an accessible graphical user interface.&lt;/p&gt;

&lt;p&gt;Think of the possibilities: there are so many modules on CPAN that in conjunction with AAC::Pvoice can result in simple, accessible applications. For example, a module like Games::Battleship allows you to create a battleship game, AAC::Pvoice allows you to create the GUI and takes care of the input for you, so with very little effort you can create a game accessible for people who can&amp;rsquo;t play regular games that need full control over a mouse and/or keyboard.&lt;/p&gt;

&lt;p&gt;This article will explain how to use the AAC::Pvoice modules step by step. It&amp;rsquo;s up to you what kind of functionality will go into the application you build.&lt;/p&gt;

&lt;p&gt;The API of the AAC::Pvoice modules is still subject to changes, but you can trust me when I tell you that the behavior of existing methods won&amp;rsquo;t change too much, because I don&amp;rsquo;t like to go over my own code over and over again to adjust it to a new version of an API.&lt;/p&gt;

&lt;h3 id=&#34;the-concept&#34;&gt;The Concept&lt;/h3&gt;

&lt;p&gt;The graphical user interface of AAC::Pvoice is based upon wxPerl classes, so it won&amp;rsquo;t hurt if you already know a bit about wxPerl. But since the modules handle most of the GUI for you, as you can see below, it&amp;rsquo;s much simpler to write AAC::Pvoice applications than using plain wxPerl.&lt;/p&gt;

&lt;p&gt;Basically an AAC::Pvoice-based application consists of three entities: a Panel, a Row and a Button. A panel is a subclass of a Wx::Panel, on which one or more rows, or in fact any other Wx::Window subclass, can be placed. A row is also a subclass of a Wx::Panel, but a row can contain multiple Wx::BitmapButton objects. Those Wx::BitmapButtons however are created from a data structure you feed to the row&amp;rsquo;s constructor. These buttons don&amp;rsquo;t respond to mouse clicks on them like you&amp;rsquo;re used to, but will be invoked when the user generates a &amp;lsquo;Select&amp;rsquo; event, unless of course you use a normal mouse to control the GUI. The &amp;lsquo;Select&amp;rsquo; event will be discussed later.&lt;/p&gt;

&lt;p&gt;There is a special class called AAC::Pvoice::Input. You normally won&amp;rsquo;t call any of this class&amp;rsquo; methods directly. Instead, it&amp;rsquo;s called from the AAC::Pvoice::Panel. The Input class checks for &amp;lsquo;normal&amp;rsquo; mouse, mouse buttons, keyboard or parallel port input (depending on the selected device) and calls whatever the Panel defined it to do when a &amp;lsquo;Next&amp;rsquo; or &amp;lsquo;Select&amp;rsquo; event occurs. If only one switch is used, that switch will only generate a &amp;lsquo;Select&amp;rsquo; event, and a &amp;lsquo;Next&amp;rsquo; event will automatically happen every n milliseconds, depending on your settings. To understand what those events are, you need to understand how the so called &amp;lsquo;row/column scanning&amp;rsquo; mechanism works. Since we&amp;rsquo;ve got multiple rows of buttons, and we have only two switches to indicate what we want to do, we can&amp;rsquo;t move the mouse cursor over the screen. Instead, we&amp;rsquo;ll use one switch to indicate &amp;lsquo;go to next row&amp;rsquo; and one to indicate &amp;lsquo;select this row&amp;rsquo;. When we&amp;rsquo;ve selected a row, again we need the same two switches to indicate &amp;lsquo;go to next button in this row&amp;rsquo; and &amp;lsquo;select this button&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;As you will see in the demo application below, you don&amp;rsquo;t have to worry about row/column scanning when you&amp;rsquo;re creating your application. The AAC::Pvoice::Panel takes care of that. You only have to define what your script will do when a certain button is invoked.&lt;/p&gt;

&lt;h3 id=&#34;creating-a-demo&#34;&gt;Creating a Demo&lt;/h3&gt;

&lt;p&gt;To demonstrate how you can use AAC::Pvoice to create your own pVoice-like applications, I&amp;rsquo;ll show you how to build a simple demo application. This application will use the Microsoft Agent (using the Win32::MSAgent module) to move the Merlin character over the screen and let it pronounce a phrase. It&amp;rsquo;s a very simple, silly example, but then again, it&amp;rsquo;s only to demonstrate how the AAC::Pvoice modules work. You&amp;rsquo;ll see how easy it is.&lt;/p&gt;

&lt;p&gt;First of all, because an AAC::Pvoice based application is actually a wxPerl-based application, we have to start with a standard wxPerl framework, where we define the application and the frame, and start a main loop. This can be something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use strict;
use warnings;

# Create a wxApp object and start the mainloop
my $obj = pMerlin-&amp;gt;new();
$obj-&amp;gt;MainLoop;

#----------------------------------------------------------------------
# the pMerlin package implements the Wx::App subclass
package pMerlin;
use Wx;
use base &#39;Wx::App&#39;;

sub OnInit
{
    my $self = shift;
    # Set an AppName and VendorName
    $self-&amp;gt;SetAppName(&#39;Fun With Merlin&#39;);
    $self-&amp;gt;SetVendorName(&amp;quot;pVoice Applications - Jouke Visser&amp;quot;);

    # Create a frame and show it
    my $frame = pMerlinFrame-&amp;gt;new( undef, -1, &#39;pMerlin&#39;);
    $frame-&amp;gt;Show(1);
}

#----------------------------------------------------------------------
# the pMerlinFrame package implements the Wx::Frame subclass
package pMerlinFrame;
use Wx qw(:everything);
use AAC::Pvoice;
use base &#39;Wx::Frame&#39;;

sub new
{
    my $class = shift;
    # Call the superclass&#39; constructor
    my $self = $class-&amp;gt;SUPER::new(@_);

    # Set the white background colour
    $self-&amp;gt;SetBackgroundColour(wxWHITE);

    return $self;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far, nothing special. I only used a few calls that aren&amp;rsquo;t really necessary for a default wxPerl script: I&amp;rsquo;m setting the AppName, VendorName, and I&amp;rsquo;m telling the frame to have a white background. The reason for setting the AppName and VendorName will be explained later.&lt;/p&gt;

&lt;h3 id=&#34;using-aac-pvoice&#34;&gt;Using AAC::Pvoice&lt;/h3&gt;

&lt;p&gt;Like I said, so far everything looks normal, if you&amp;rsquo;re used to wxPerl programming. But in fact this is where the actual work begins. We now need to add some code to the new() subroutine of pMerlinFrame. The first thing we need to do now is to maximize the pMerlinFrame we just defined and get the dimensions of that maximized state. We need to do this to pass the correct width and height of the frame to the AAC::Pvoice::Panel we want to create. We can define a margin around the AAC::Pvoice::Panel, which looks nicer, but it&amp;rsquo;s not necessary. In this example I&amp;rsquo;m using a margin of 50 pixels on each side of the panel.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Get the dimensions of the maximized window
$self-&amp;gt;Show(1);
$self-&amp;gt;Maximize(1);
my ($width, $height) = ($self-&amp;gt;GetClientSize-&amp;gt;GetWidth,
                        $self-&amp;gt;GetClientSize-&amp;gt;GetHeight);
$self-&amp;gt;Show(0);

# define the margin
my $margin = 50;

# define the itemspacing
my $itemspacing = 4;

# And create a pVoice panel
$self-&amp;gt;{panel} = AAC::Pvoice::Panel-&amp;gt;new(
                         $self,              # parent
                         -1,                 # id
                         [$margin, $margin], # position
                         [$width-2*$margin, $height-2*$margin],
                                             # size
                         wxNO_3D,            # style
                         1,                  # hide textrow
                         $itemspacing,       # spacing between items
                         3);                 # selectionborderwidth
# The grey background for the panel
my $panelbackground = Wx::Colour-&amp;gt;new(220,220,220);
$self-&amp;gt;{panel}-&amp;gt;BackgroundColour($panelbackground);

# A title at the top of the panel
$self-&amp;gt;{panel}-&amp;gt;AddTitle(&amp;quot;Fun with Merlin&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see I&amp;rsquo;ve also defined a background colour for the panel and a title on top of it. Let&amp;rsquo;s take a closer look at the parameters of the AAC::Pvoice::Panel constructor. The first parameters look exactly like those used for Wx::Panel. The AAC::Pvoice::Panel, however, needs three new parameters. The first indicates if we should hide the (default) text row (a Wx::TextCtrl) at the bottom of the panel. For an application like pVoice, where you create phrases, this text row is of course needed. For our demo we don&amp;rsquo;t need a text row. Furthermore, we need to define the spacing between items on the panel. Effectively this is the spacing between the rows, since those will be placed directly upon this panel. Finally we need to define the width of the border around a selected row or item. It&amp;rsquo;s a good idea to make this value lower than the item spacing, otherwise the border will not be fully visible.&lt;/p&gt;

&lt;p&gt;The next step is to create the bitmaps we want to display. For this purpose we can use AAC::Pvoice::Bitmap. This class provides an easy way to create a bitmap of a certain size, put a caption underneath it, and has some other useful features. Before we create the bitmaps, we calculate the maximum X and Y size they can use by dividing the useable X and Y size of the panel by the number of buttons per row and the number of rows respectively. I&amp;rsquo;ll also subtract twice the item spacing used in the application because otherwise the buttons will be a little bit too large.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# The maximum dimensions of a button
my $maxX = int(($self-&amp;gt;{panel}-&amp;gt;xsize)/4)-2*$itemspacing;
my $maxY = int(($self-&amp;gt;{panel}-&amp;gt;ysize)/3)-2*$itemspacing; 

# Define the bitmaps. 
# The parameters are the filename, maxX and maxY size and the caption
my $leftbutton     = AAC::Pvoice::Bitmap-&amp;gt;new(&#39;img/left.png&#39;,
                                              $maxX, $maxY, &#39;left&#39;);
my $rightbutton    = AAC::Pvoice::Bitmap-&amp;gt;new(&#39;img/right.png&#39;,
                                              $maxX, $maxY, &#39;right&#39;);
my $upbutton       = AAC::Pvoice::Bitmap-&amp;gt;new(&#39;img/up.png&#39;,
                                              $maxX, $maxY, &#39;up&#39;);
my $downbutton     = AAC::Pvoice::Bitmap-&amp;gt;new(&#39;img/down.png&#39;,
                                              $maxX, $maxY, &#39;down&#39;);
my $questionbutton = AAC::Pvoice::Bitmap-&amp;gt;new(&#39;img/question.png&#39;,
                                              $maxX, $maxY, &#39;question&#39;);
my $rowselbutton   = AAC::Pvoice::Bitmap-&amp;gt;new(&#39;img/rowsel.png&#39;,
                                              $maxX, $maxY, &#39;rowsel&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we&amp;rsquo;ve got those bitmaps, we can create the AAC::Pvoice::Rows that will use those bitmaps, and know what coderefs to invoke when the user selects one of the buttons. We don&amp;rsquo;t need to create individual Wx::BitmapButtons. The AAC::Pvoice::Row takes care of that, and attaches the correct actions to the BitmapButtons in such a way that they can be invoked using any of the available input methods.&lt;/p&gt;

&lt;p&gt;Before define the rows, we create a listref for every button, containing the button ID, the bitmap and the callback. These listrefs we put in another list of lists. That LoL defines the whole panel, and every list inside it defines the layout of each every row. Let&amp;rsquo;s see how we achieve this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Define the buttons on the pVoice rows
#               the id,      the bitmap,     the callback
my $left     = [Wx::NewId(), $leftbutton,    sub {$self-&amp;gt;MoveLeft}];
my $right    = [Wx::NewId(), $rightbutton,   sub {$self-&amp;gt;MoveRight}];
my $up       = [Wx::NewId(), $upbutton,      sub {$self-&amp;gt;MoveUp}];
my $down     = [Wx::NewId(), $downbutton,    sub {$self-&amp;gt;MoveDown}];
my $question = [Wx::NewId(), $questionbutton,sub {$self-&amp;gt;Speak}];
my $rowsel   = [Wx::NewId(), $rowselbutton,
                sub {$self-&amp;gt;{panel}-&amp;gt;ToRowSelection}];

# The definition of the screenlayout
my $content = [ [ $rowsel,    undef,    $up,       undef  ],
                [ $rowsel,    $left,    $question, $right ],
                [ $rowsel,    undef,    $down,     undef  ] ];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see that the callbacks actually invoke some methods of pMerlinFrame that I haven&amp;rsquo;t discussed yet. That&amp;rsquo;s because they have nothing to do with the AAC::Pvoice modules themselves. I&amp;rsquo;m trying to keep this demo as simple as possible. At the bottom of this article you&amp;rsquo;ll find a link to a zip file that contains the complete source and images used in this demo.&lt;/p&gt;

&lt;p&gt;The final step in creating the panel is creating the rows based upon our data structure, and then add those rows to the panel. After that there is a magic method called &amp;lsquo;Finalize&amp;rsquo; we need to call on the panel, and the panel is done. First the code, then an explanation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Add the buttons to the rows and the rows to the panel
foreach my $row (@$content)
{
  $self-&amp;gt;{panel}-&amp;gt;Append(AAC::Pvoice::Row-&amp;gt;new(
                                 $self-&amp;gt;{panel},     # parent
                                 scalar(@$row),      # max
                                 $row,               # items
                                 wxDefaultPosition,  # pos
                                 wxDefaultSize,      # size
                                 $maxX,              # X-size
                                 $maxY,              # Y-size
                                 $itemspacing,       # spacing
                                 $panelbackground)); # background
}
# Finish the panel
$self-&amp;gt;{panel}-&amp;gt;Finalize();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The constructor of a row has a few unusual parameters. The first parameter is the parent, like almost every wxPerl class needs to know the parent window. The second parameter however, is the maximum number of items in a row. The row will add empty Wx::BitmapButtons to the end of a row if the third parameter (the items we want to put on the row) contains less items than the defined maximum. This ensures an even sized row. In our case we have rows with 4 items each, including some undefined items, so passing scalar($@row) is enough here.&lt;/p&gt;

&lt;p&gt;The $row parameter contains the list of items we want to have in our row. We also have to pass the $maxX, $maxY and $itemspacing to this row, since it has to use the correct spacing between the buttons, and the empty buttons it needs to create (for the undef values in the row) need to have the correct size. The final parameter, $panelbackground, is the background color for this row, which we define to be the same as the panel background to let it look like there&amp;rsquo;s no difference between the rows and the panel.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2004_07_14_accessibility/pmerlin.jpg&#34; width=&#34;450&#34; height=&#34;393&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The final thing we have to do is to define how the user can use the application. Are we going to use keystrokes, mouse buttons, the Adremo wheelchair, or normal mouse input? We can define this by setting the registry-key Device to respectively keys, icon, adremo, or mouse. This needs to be set before the AAC::Pvoice::Panel is created. I usually set this in the OnInit method of my Wx::App subclass like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Set the device we use to &#39;icon&#39; (left and right mouse buttons)
# other possibilities are &#39;keys&#39; (keystrokes, where the space 
#                           and enter key are the default keys)
#                         &#39;adremo&#39; (electrical wheelchair) and
#                         &#39;mouse&#39; (normal mouse, touch screen, etc.)
my $config = Wx::ConfigBase::Get;
my $Device = $config-&amp;gt;Read(&#39;Device&#39;, &#39;icon&#39;);
$config-&amp;gt;Write(&#39;Device&#39;,   $Device);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we do this after we define the AppName and the VendorName, the key will appear under HKEY_CURRENT_USER\Software\&amp;lt;VendorName&amp;gt;\&amp;lt;AppName&amp;gt;\Device. There are more possible keys to define, like Buttons (either 1 or 2, defining the number of switches). You can find more information on this in the documentation of AAC::Pvoice::Input.&lt;/p&gt;

&lt;p&gt;This is all there is to it. We now have a simple demo of an application that almost everyone is able to use. The screenshot you see on this page is the result of these simple pieces of code. As you could see, the API is extremely simple, so you can concentrate on the actual functionality you want to put in your application.&lt;/p&gt;

&lt;h3 id=&#34;platform-issues&#34;&gt;Platform Issues&lt;/h3&gt;

&lt;p&gt;The AAC::Pvoice modules can be installed on Windows as well as on Linux. However, it doesn&amp;rsquo;t look too well on Linux. If someone is interested in making the modules work correctly on Linux: patches are welcome! I would also like to see someone trying to port everything to OS X. wxPerl runs on a lot of different platforms, but in the AAC::Pvoice modules I&amp;rsquo;ve used some Win32-specific options that may have some workarounds for other platforms. I just haven&amp;rsquo;t had the opportunity to make it work on those.&lt;/p&gt;

&lt;p&gt;Hopefully this short article inspires you to build something for people who can&amp;rsquo;t quite accomplish everything you can. After all, this is what programming should really be about &amp;ndash; making useful applications for people who can&amp;rsquo;t build it themselves.&lt;/p&gt;

&lt;p&gt;You can download the &lt;a href=&#34;http://localhost:1313/media/_pub_2004_07_14_accessibility/pmerlin.zip&#34;&gt;zipfile containing the complete script and images here&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Photo Galleries with Mason and Imager</title>
      <link>http://localhost:1313/pub/2004/04/01/masongal.html/</link>
      <pubDate>Thu, 01 Apr 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/04/01/masongal.html/</guid>
      <description>

&lt;p&gt;Creating a photo gallery is usually considered a daunting task. Lots of people have tried it, not many have succeeded. One of the reasons for so many similar projects is that they don&amp;rsquo;t often integrate well into an existing web site. In this article we&amp;rsquo;re going to build a photo gallery using two important components, Mason and Imager. Writing our gallery in Mason will make it much easier to integrate into an existing web site.&lt;/p&gt;

&lt;p&gt;Mason, also known as &lt;a href=&#34;https://metacpan.org/pod/HTML::Mason&#34;&gt;&lt;code&gt;HTML::Mason&lt;/code&gt;&lt;/a&gt;, is a web application framework written in Perl. Mason can run in any environment, but is tuned to work best with mod_perl. We will be using a number of Mason features in this article. If you&amp;rsquo;re not familiar with Mason I suggest you &lt;a href=&#34;http://www.oreilly.com/catalog/perlhtmlmason/&#34;&gt;get the book&lt;/a&gt; or &lt;a href=&#34;http://masonbook.com&#34;&gt;browse&lt;/a&gt; before you buy. This article is not meant to be an introduction to Mason, so some experience will definitely help when reading this. Mason idioms will be briefly reviewed when they come up.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://metacpan.org/pod/Imager&#34;&gt;&lt;code&gt;Imager&lt;/code&gt;&lt;/a&gt; is a Perl module for dealing with images. It has mechanisms to manipulate an image, and read and write various formats. It&amp;rsquo;s rather lightweight and has a clean interface in comparison to the alternative, &lt;a href=&#34;https://metacpan.org/pod/Image::Magick&#34;&gt;&lt;code&gt;Image::Magick&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Combining these two Perl modules, and adding a few others, allows us to write a feature-full photo gallery in just 200 lines. Let&amp;rsquo;s get started.&lt;/p&gt;

&lt;h3 id=&#34;span-id-apache-configuration-apache-configuration-span&#34;&gt;&lt;span id=&#34;Apache_Configuration&#34;&gt;Apache Configuration&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;re going to use Mason from mod_perl for our gallery. This requires an Apache built with mod_perl, and bit of web server configuration.&lt;/p&gt;

&lt;p&gt;First, Mason&amp;rsquo;s Apache handler must be pre-loaded.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  PerlModule HTML::Mason::ApacheHandler
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we need to tell Apache to let Mason handle any requests that it gets for resources within our gallery.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;Location /gallery&amp;gt;
    SetHandler perl-script
    PerlHandler HTML::Mason::ApacheHandler
  &amp;lt;/Location&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We want to keep special Mason files secret from the general public. If they&amp;rsquo;re requested, Apache should always return a &lt;code&gt;404&lt;/code&gt; HTTP status code, for &lt;em&gt;Not Found&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;LocationMatch &amp;quot;(dhandler|autohandler)$&amp;quot;&amp;gt;
    SetHandler perl-script
    PerlInitHandler Apache::Constants::NOT_FOUND
  &amp;lt;/LocationMatch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point, every file inside the gallery will be considered a Mason component. If you enjoy paying for lots of bandwidth and you want the full-size images to be viewable by the public, one last configuration step must occur. The raw images are not Mason components so Apache should handle those in the default way.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;Location /gallery/images&amp;gt;
    SetHandler default
  &amp;lt;/Location&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-directory-structure-directory-structure-span&#34;&gt;&lt;span id=&#34;Directory_Structure&#34;&gt;Directory Structure&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;For this article we&amp;rsquo;ll use the following directory structure, in a directory called &lt;em&gt;gallery&lt;/em&gt;, inside our site &lt;code&gt;DocumentRoot&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  .
  |-- autohandler
  |-- dhandler
  |-- images
  |   `-- dhandler
  |-- index.html
  `-- pictures
      `-- [lots of images and sub-directories]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, all the actual photos will be uploaded to the &lt;em&gt;gallery/pictures&lt;/em&gt; directory. Our code will recognize sub-galleries and allow for infinite nesting. We can keep our photos very neatly organized this way.&lt;/p&gt;

&lt;p&gt;As for the rest, it&amp;rsquo;s all code. &lt;em&gt;autohandler&lt;/em&gt; and &lt;em&gt;dhandler&lt;/em&gt; are special Mason files, and &lt;em&gt;index.html&lt;/em&gt; is just a wrapper around the top level &lt;em&gt;dhandler&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-autohandler-the-autohandler-span&#34;&gt;&lt;span id=&#34;The_autohandler&#34;&gt;The &lt;em&gt;autohandler&lt;/em&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;For this example, our &lt;em&gt;autohandler&lt;/em&gt; is extremely simple. I&amp;rsquo;m going to assume that you already have a Mason site running with your own &lt;em&gt;autohandler&lt;/em&gt; wrappers in place. If you don&amp;rsquo;t, you can use this one.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%method .title&amp;gt;My Website&amp;lt;/%method&amp;gt;

  &amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
      &amp;lt;title&amp;gt;&amp;lt;&amp;amp; SELF:.title &amp;amp;&amp;gt;&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
      &amp;lt;% $m-&amp;gt;call_next %&amp;gt;
    &amp;lt;/body&amp;gt;
  &amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first thing our &lt;em&gt;autohandler&lt;/em&gt; does is define a subcomponent called &lt;code&gt;.title&lt;/code&gt;. Mason subcomponents are wrapped in &lt;code&gt;&amp;lt;%method&amp;gt;&lt;/code&gt; blocks. They are templates just like files; the only difference is they live inside the files. This is analogous to Perl files and subroutines.&lt;/p&gt;

&lt;p&gt;Next we define the skeleton of the web page. The &lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; tag&amp;rsquo;s content is dynamically generated by the output of the &lt;code&gt;SELF:.title&lt;/code&gt; subcomponent. Any time you want to call a subcomponent, the call is wrapped in &lt;code&gt;&amp;lt;&amp;amp; &amp;amp;&amp;gt;&lt;/code&gt; delimiters.&lt;/p&gt;

&lt;p&gt;The body, or content, of our web page will be provided by whatever component is next in the call stack. Using the global variable to access Mason object, &lt;code&gt;$m&lt;/code&gt;, the &lt;code&gt;call_next()&lt;/code&gt; method is executed to do just that.&lt;/p&gt;

&lt;p&gt;In our gallery the next component in the call stack will be one of two files. If we&amp;rsquo;re at the topmost level, &lt;code&gt;http://example.com/gallery/&lt;/code&gt;, for example, &lt;em&gt;index.html&lt;/em&gt; will be called. Everywhere else &lt;em&gt;dhandler&lt;/em&gt; will be called. This is because no files exist for Mason to map to, and when that happens, Mason looks for a &lt;em&gt;dhandler&lt;/em&gt; to execute.&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-invisible-index-the-invisible-index-span&#34;&gt;&lt;span id=&#34;The_Invisible_Index&#34;&gt;The Invisible Index&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;dhandlers&lt;/code&gt; are default handlers for files inside a directory, and not that directory itself. Because of this we are required to provide an &lt;em&gt;index.html&lt;/em&gt; file or Apache will attempt to display a directory listing, or possibly return a &lt;em&gt;forbidden&lt;/em&gt; status code, if directory listings are not allowed. In reality, our &lt;em&gt;index.html&lt;/em&gt; doesn&amp;rsquo;t do anything at all.&lt;/p&gt;

&lt;p&gt;In its entirety, &lt;em&gt;index.html&lt;/em&gt; simply states that it inherits from &lt;em&gt;dhandler&lt;/em&gt;. Now &lt;em&gt;dhandler&lt;/em&gt; will be executed for all non-image access to our photo gallery.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%flags&amp;gt;
    inherit =&amp;gt; &#39;dhandler&#39;
  &amp;lt;/%flags&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This uncovers a portion of Mason&amp;rsquo;s object-like component inheritance. By default, all components inherit from &lt;em&gt;autohandler&lt;/em&gt;. For &lt;em&gt;index.html&lt;/em&gt; we&amp;rsquo;ve changed that. &lt;em&gt;dhandler&lt;/em&gt; still inherits from &lt;em&gt;autohandler&lt;/em&gt;, so anytime a request is sent to &lt;em&gt;index.html&lt;/em&gt;, &lt;em&gt;dhandler&lt;/em&gt; is first called, which calls &lt;em&gt;autohandler&lt;/em&gt; first. Then &lt;em&gt;autohandler&lt;/em&gt; does its thing and moves down the call stack to &lt;em&gt;dhandler&lt;/em&gt;. &lt;em&gt;dhandler&lt;/em&gt;, as we&amp;rsquo;ll see, is not configured to call down the stack to &lt;em&gt;index.html&lt;/em&gt;, because it doesn&amp;rsquo;t need to. Thus ends the very high-level overview of Mason inheritance.&lt;/p&gt;

&lt;h3 id=&#34;span-id-displaying-gallery-pages-displaying-gallery-pages-span&#34;&gt;&lt;span id=&#34;Displaying_Gallery_Pages&#34;&gt;Displaying Gallery Pages&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Moving on to the meat of our application, the top-level &lt;em&gt;dhandler&lt;/em&gt;. This file has the bulk of our code, roughly 150 lines. The code is neatly organized into subcomponents, so we&amp;rsquo;ll start by discussing the high-level code. And from that we&amp;rsquo;ll work in order of execution.&lt;/p&gt;

&lt;p&gt;Each page in our photo gallery has just one optional argument, a page number. By default we always start on page one (&lt;code&gt;1&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%args&amp;gt;
    $page =&amp;gt; 1
  &amp;lt;/%args&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, the &lt;code&gt;&amp;lt;%shared&amp;gt;&lt;/code&gt; block is executed. It does a lot, so we&amp;rsquo;ll look at it in great detail. We&amp;rsquo;re using a &lt;code&gt;&amp;lt;%shared&amp;gt;&lt;/code&gt; block instead of an &lt;code&gt;&amp;lt;%init&amp;gt;&lt;/code&gt; block because some of the variables defined here need to be used within multiple subcomponents. As the name suggests, &lt;code&gt;&amp;lt;%shared&amp;gt;&lt;/code&gt; blocks allow just that.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%shared&amp;gt;
    use List::Group qw[group];
    use HTML::Table;
    use File::Spec::Functions qw[:ALL];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first step is to load the Perl modules this component will be using. &lt;a href=&#34;https://metacpan.org/pod/List::Group&#34;&gt;&lt;code&gt;List::Group&lt;/code&gt;&lt;/a&gt; turns a flat list into a List-of-Lists (LoL) based on specific grouping options, &lt;a href=&#34;https://metacpan.org/pod/HTML::Table&#34;&gt;&lt;code&gt;HTML::Table&lt;/code&gt;&lt;/a&gt; turns such an LoL into an HTML table structure, and &lt;a href=&#34;https://metacpan.org/pod/File::Spec::Functions&#34;&gt;&lt;code&gt;File::Spec::Functions&lt;/code&gt;&lt;/a&gt; provides a number of portable file and directory operations.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $GALLERY_ROOT = $r-&amp;gt;document_root . &amp;quot;/gallery/pictures&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we define the first shared variable. &lt;code&gt;$GALLERY_ROOT&lt;/code&gt; is the absolute path to the location of the gallery pictures on the file system.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (my $path_from_uri = $m-&amp;gt;dhandler_arg) =~ s!(?:(?:/index)?\.html|/)$!!;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s time to determine the relative path to the resource being requested. Because we&amp;rsquo;re inside a &lt;em&gt;dhandler&lt;/em&gt;, Mason provides the &lt;code&gt;dhandler_arg()&lt;/code&gt; method, which is similar in purpose to Apache&amp;rsquo;s &lt;code&gt;uri()&lt;/code&gt; method. It returns the portion of a URI that is relative to the directory containing the &lt;em&gt;dhandler&lt;/em&gt;. If we request &lt;code&gt;/gallery/Family/IMG_0001.JPG.html&lt;/code&gt;, &lt;code&gt;$m-&amp;gt;dhandler_arg()&lt;/code&gt; will return &lt;code&gt;/Family/IMG_0001.JPG.html&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Because we&amp;rsquo;re looking for the path to an actual photo or gallery directory, there is some information to be removed from the end of our relative path. So our regex removes useless information such as index files, HTML extensions, and extra backslashes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $file = catdir $GALLERY_ROOT, $path_from_uri;
    $m-&amp;gt;clear_buffer and $m-&amp;gt;abort(404) unless -e $file;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From these two variables we can construct the absolute path to the file we&amp;rsquo;re interested in using &lt;code&gt;catdir()&lt;/code&gt;, from &lt;code&gt;File::Spec::Functions&lt;/code&gt;. If this file doesn&amp;rsquo;t exist, we don&amp;rsquo;t want to go any further, so Mason&amp;rsquo;s output buffer is cleared and the request is aborted immediately with a &lt;code&gt;404&lt;/code&gt; HTTP status code, meaning &lt;em&gt;Not Found&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;If a gallery is being requested, not a specific photo, we must get the contents of that gallery. If a photo is being requested, we must get the contents of the gallery that photo belongs to.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $dir = -d $file ? $file : (splitpath $file)[1];
    opendir DIR, $dir or die $!;
    my $dir_list = [ map &amp;quot;$dir/$_&amp;quot;, grep { ! /^\./ } readdir DIR ];
    closedir DIR;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using a file test operator, we can determine if the current request is for a file or a directory. If a directory we simply assign &lt;code&gt;$file&lt;/code&gt; to &lt;code&gt;$dir&lt;/code&gt;. If a file, we use &lt;code&gt;splitpath()&lt;/code&gt; from &lt;code&gt;File::Spec::Functions&lt;/code&gt;. &lt;code&gt;splitpath()&lt;/code&gt; returns three elements, the volume, directory tree, and filename. We&amp;rsquo;re after the directory tree, or second element.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;$dir_list&lt;/code&gt; array reference is populated with a list of absolute paths to each file in &lt;code&gt;$dir&lt;/code&gt;, excluding files that begin with a dot (&lt;code&gt;.&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Now it&amp;rsquo;s time to move on to building the breadcrumbs for navigation. This method of navigating &amp;ldquo;up&amp;rdquo; the photo gallery is important because we can have infinite levels of sub-galleries.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @bread_crumb = (&#39;Gallery&#39;, splitdir $path_from_uri);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First we define our plain-text list of crumbs in &lt;code&gt;@bread_crumb&lt;/code&gt;. The first element is the name of our photo gallery, which I imaginatively named &lt;em&gt;Gallery&lt;/em&gt;. The rest of our breadcrumbs come from &lt;code&gt;$path_from_uri&lt;/code&gt; by calling &lt;code&gt;splitpath()&lt;/code&gt; to get the list of elements.&lt;/p&gt;

&lt;p&gt;Our &lt;code&gt;@bread_crumb&lt;/code&gt; list is great for the title of the page, but it doesn&amp;rsquo;t contain any links for use inside the page for navigation. A new list of breadcrumbs will be created with correct linking.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @bread_crumb_href;
    push @bread_crumb_href, sprintf &#39;&amp;lt;a href=&amp;quot;/gallery/%s&amp;quot;&amp;gt;%s&amp;lt;/a&amp;gt;&#39;,
      join(&#39;/&#39;,@bread_crumb[1..$_]), $bread_crumb[$_]
        for 0 .. $#bread_crumb - 1;
    push @bread_crumb_href, $bread_crumb[-1];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For each breadcrumb except the very last, we create an HTML link. The reference location for each link, from left to right, needs to cumulatively add directories from the links before it. That&amp;rsquo;s what &lt;code&gt;join(&#39;/&#39;,@bread_crumb[1..$_])&lt;/code&gt; does. Finally we tack on the last element of the breadcrumb, unlinked, because it is the currently requested resource.&lt;/p&gt;

&lt;p&gt;To illustrate, if a request is made to &lt;code&gt;/gallery/Backgrounds/Nature%20Backgrounds/ICmiddleFalls1280x1024.jpg.html&lt;/code&gt;, the following list is in &lt;code&gt;@bread_crumb_href&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  (
   &#39;&amp;lt;a href=&amp;quot;/gallery/&amp;quot;&amp;gt;Gallery&amp;lt;/a&amp;gt;&#39;,
   &#39;&amp;lt;a href=&amp;quot;/gallery/Backgrounds&amp;quot;&amp;gt;Backgrounds&amp;lt;/a&amp;gt;&#39;,
   &#39;&amp;lt;a href=&amp;quot;/gallery/Backgrounds/Nature Backgrounds&amp;quot;&amp;gt;Nature Backgrounds&amp;lt;/a&amp;gt;&#39;,
   &#39;ICmiddleFalls1280x1024.jpg&#39;
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we construct two scalars to hold the contents of our breadcrumbs.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $bread_crumb      = join &#39; &amp;amp;middot; &#39;, @bread_crumb;
    my $bread_crumb_href = join &#39; &amp;amp;middot; &#39;, @bread_crumb_href;
  &amp;lt;/%shared&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point we can define the &lt;code&gt;.title&lt;/code&gt; subcomponent, using the &lt;code&gt;$bread_crumb&lt;/code&gt; shared variable.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%method .title&amp;gt;&amp;lt;&amp;amp; PARENT:.title &amp;amp;&amp;gt; &amp;amp;middot; &amp;lt;% $bread_crumb %&amp;gt;&amp;lt;/%method&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that there is a subcomponent call to &lt;code&gt;PARENT:.title&lt;/code&gt;. This is another illustration of Mason&amp;rsquo;s inheritance model. Because &lt;em&gt;dhandler&lt;/em&gt; &lt;strong&gt;inherits&lt;/strong&gt; from &lt;em&gt;autohandler&lt;/em&gt;, the &lt;code&gt;.title&lt;/code&gt; subcomponent in &lt;em&gt;dhandler&lt;/em&gt; is overriding the &lt;code&gt;.title&lt;/code&gt; method in &lt;em&gt;autohandler&lt;/em&gt;. That is to say, &lt;em&gt;dhandler&lt;/em&gt; is &lt;strong&gt;subclassing&lt;/strong&gt; &lt;em&gt;autohandler&lt;/em&gt;. For this reason, if we don&amp;rsquo;t want to clobber the &lt;code&gt;.title&lt;/code&gt; subcomponent declared in &lt;em&gt;autohandler&lt;/em&gt; we must be sure to call our parent. This is very similar to invoking a &lt;code&gt;SUPER::&lt;/code&gt; method in Perl.&lt;/p&gt;

&lt;p&gt;Now we can move on to the actual gallery display.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;h1&amp;gt;Photo Gallery&amp;lt;/h1&amp;gt;
  &amp;lt;h2&amp;gt;&amp;lt;% $bread_crumb_href %&amp;gt;&amp;lt;/h2&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using another shared variable, &lt;code&gt;$bread_crumb_href&lt;/code&gt;, we construct our backward navigation.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;table&amp;gt;
    &amp;lt;tr&amp;gt;
      &amp;lt;td valign=&amp;quot;top&amp;quot; width=&amp;quot;15%&amp;quot;&amp;gt;
        &amp;lt;&amp;amp; SELF:.sub_gal_list, dir_list =&amp;gt; $dir_list &amp;amp;&amp;gt;
      &amp;lt;/td&amp;gt;
      &amp;lt;td valign=&amp;quot;top&amp;quot; width=&amp;quot;35%&amp;quot;&amp;gt;
        &amp;lt;&amp;amp; SELF:.photo_list, dir_list =&amp;gt; $dir_list, page =&amp;gt; $page &amp;amp;&amp;gt;
      &amp;lt;/td&amp;gt;
      &amp;lt;td valign=&amp;quot;top&amp;quot; width=&amp;quot;50%&amp;quot;&amp;gt;
  % if ( -f $file ) {
        &amp;lt;&amp;amp; SELF:.photo_view, file =&amp;gt; $file &amp;amp;&amp;gt;
  % }
      &amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
  &amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have three columns of information to display at any one time &amp;ndash; an HTML table is a good way to do that. (Some standards purists and XHTML masochists will disagree with me on this point. I&amp;rsquo;m interested in keeping the examples simple, not pure.) Each of the table cells calls a subcomponent with the appropriate arguments. Those subcomponents are discussed in detail later in this article. Notice that before we call &lt;code&gt;SELF:.photo_view&lt;/code&gt; we check to see if the request is currently for a file. This can save us from calling that subcomponent if we currently don&amp;rsquo;t want to look at a photo.&lt;/p&gt;

&lt;p&gt;The first subcomponent called is &lt;code&gt;SELF:.sub_gal_list&lt;/code&gt;. As the name suggests, it will list sub-galleries.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%method .sub_gal_list&amp;gt;
    &amp;lt;%args&amp;gt;
      @dir_list
      $wrap =&amp;gt; 1
    &amp;lt;/%args&amp;gt;

    &amp;lt;h3&amp;gt;Sub &amp;lt;% @dir_list == 1 ? &amp;quot;Gallery&amp;quot; : &amp;quot;Galleries&amp;quot; %&amp;gt;&amp;lt;/h3&amp;gt;
    &amp;lt;% $table %&amp;gt;

    &amp;lt;%init&amp;gt;
      @dir_list = grep { -d $_ } @dir_list;
      return unless @dir_list;
      $_ = $m-&amp;gt;scomp(&#39;SELF:.sub_gal_view&#39;,dir =&amp;gt; $_) for @dir_list;
      my $table = HTML::Table-&amp;gt;new(-data =&amp;gt; [ group \@dir_list, cols =&amp;gt; $wrap ]);
    &amp;lt;/%init&amp;gt;
  &amp;lt;/%method&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.sub_gal_list&lt;/code&gt; accepts a directory listing argument. It also optionally accepts an argument detailing after how many entries in the list should be in each row.&lt;/p&gt;

&lt;p&gt;Jumping to the &lt;code&gt;&amp;lt;%init&amp;gt;&lt;/code&gt; block (remember the order of execution?), we filter the directory listing to exclude any entries that are not directories themselves. If that produces an empty list, there&amp;rsquo;s no need to continue processing this subcomponent, so just &lt;code&gt;return&lt;/code&gt;. Next, each of the entries are reformatted by passing them to the &lt;code&gt;SELF:.sub_gal_view&lt;/code&gt; method. This is where it gets fun.&lt;/p&gt;

&lt;p&gt;When a subcomponent is called, it&amp;rsquo;s really just syntactic sugar to call &lt;code&gt;$m-&amp;gt;comp()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;&amp;amp; SELF:.sub_gal_view, dir =&amp;gt; $_ &amp;amp;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The previous statement is exactly equivalent to the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  % $m-&amp;gt;comp( &#39;SELF:.sub_gal_view&#39;, dir =&amp;gt; $_ );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mason also defines the &lt;code&gt;scomp()&lt;/code&gt; method, which compiles a subcomponent but returns its output as a string, just like Perl&amp;rsquo;s &lt;code&gt;sprintf&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;After reformatting the entries, we group the flat list into a List-of-Lists containing just one column. That list is used as the value of the &lt;code&gt;-data&lt;/code&gt; parameter to &lt;code&gt;HTML::Table-&lt;/code&gt;new()&amp;gt;, which returns a table object.&lt;/p&gt;

&lt;p&gt;Now it&amp;rsquo;s time to process the template portion. First a heading is created. It&amp;rsquo;s only plural if we have more than one sub-gallery. After the heading the sub-gallery table is displayed. Because an &lt;code&gt;HTML::Table&lt;/code&gt; object overloads stringify, there&amp;rsquo;s no need to call a method on it to get the HTML output.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s quickly look at the &lt;code&gt;.sub_gal_view&lt;/code&gt; subcomponent used to reformat each directory listing.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%method .sub_gal_view&amp;gt;
    &amp;lt;%args&amp;gt;
      $dir
    &amp;lt;/%args&amp;gt;
    &amp;lt;a href=&amp;quot;/gallery/&amp;lt;% $rel_dir %&amp;gt;&amp;quot;&amp;gt;&amp;lt;% $label %&amp;gt;&amp;lt;/a&amp;gt;
    &amp;lt;%init&amp;gt;
      my $rel_dir = abs2rel $dir, $GALLERY_ROOT;
      my $label   = (splitpath $rel_dir)[-1];
    &amp;lt;/%init&amp;gt;
  &amp;lt;/%method&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This subcomponent is extremely straightforward. It accepts a directory. Inside &lt;code&gt;&amp;lt;%init&amp;gt;&lt;/code&gt;, &lt;code&gt;$rel_dir&lt;/code&gt; is set to the relative directory path in relation to the &lt;code&gt;$GALLERY_ROOT&lt;/code&gt;, which will give us a proper URL for the link. Finding the label for the link is simple, it is the real directory name, which is the last element of the list returned by &lt;code&gt;splitpath()&lt;/code&gt;, from &lt;code&gt;File::Spec::Functions&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This subcomponent finally generates the proper link for navigating to sub-galleries.&lt;/p&gt;

&lt;p&gt;The next subcomponent called by our top-level component is &lt;code&gt;.photo_list&lt;/code&gt;, which generates the thumbnail view of our images.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%method .photo_list&amp;gt;
    &amp;lt;%args&amp;gt;
      @dir_list
      $wrap =&amp;gt; 5
      $rows =&amp;gt; 7
      $page =&amp;gt; 1
    &amp;lt;/%args&amp;gt;

    &amp;lt;h3&amp;gt;&amp;lt;% @dir_list == 1 ? &amp;quot;Photo&amp;quot; : &amp;quot;Photos&amp;quot; %&amp;gt;
        &amp;lt;&amp;amp; SELF:.photo_pager, page =&amp;gt; $page, pages =&amp;gt; $pages &amp;amp;&amp;gt;&amp;lt;/h3&amp;gt;
    &amp;lt;% $table %&amp;gt;

    &amp;lt;%init&amp;gt;
      @dir_list = grep { -f $_ } @dir_list;
      return unless @dir_list;
      $_ = $m-&amp;gt;scomp(&#39;SELF:.thumb_view&#39;,file =&amp;gt; $_, page =&amp;gt; $page)
        for @dir_list;
      my @files = group \@dir_list, cols =&amp;gt; $wrap;

      my $pages  = int( @files / $rows );
         $pages += 1 if $pages &amp;lt; ( @files / $rows );
      @files = splice @files, $rows * ($page - 1), $rows;

      my $table = HTML::Table-&amp;gt;new(-data =&amp;gt; \@files);
    &amp;lt;/%init&amp;gt;
  &amp;lt;/%method&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just like &lt;code&gt;.sub_gal_list&lt;/code&gt;, the only required argument to this component is the directory listing. The other optional arguments correspond to how many images should be in each row (&lt;code&gt;$wrap&lt;/code&gt;), how many rows to show on a page (&lt;code&gt;$rows&lt;/code&gt;), and what page we&amp;rsquo;re currently on (&lt;code&gt;$page&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Once again we jump to the &lt;code&gt;&amp;lt;%init&amp;gt;&lt;/code&gt; block where the directory listing is filtered to only include files. If there are no files, there&amp;rsquo;s no reason to go any further, so just &lt;code&gt;return&lt;/code&gt; from this subcomponent. Just as we did with sub-gallery listings, we reformat the remaining list of files by calling a subcomponent and storing its output. Next, we group the list of files into a List-of-Lists (LoL), each row containing &lt;code&gt;$wrap&lt;/code&gt; entries.&lt;/p&gt;

&lt;p&gt;Photo galleries may contain any number of photos, so it&amp;rsquo;s essential to support paging for thumbnails. First we need to determine how many pages this gallery will have in total. To do that we divide the total number of rows by the number of rows we want on each page. That could return a fractional number that will be cut off to the nearest decimal by &lt;code&gt;int&lt;/code&gt;. If that&amp;rsquo;s the case then we want to increment the number of pages by one (&lt;code&gt;1&lt;/code&gt;). Next we can extract the rows for our current page from all the rows currently in &lt;code&gt;@files&lt;/code&gt; using a &lt;code&gt;splice&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Finally, a new &lt;code&gt;HTML::Table&lt;/code&gt; object is created, and populated with &lt;code&gt;@files&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In the template portion a header is output, again only using the plural if we have more than one photo. Our header also contains paging information, provided by the &lt;code&gt;.photo_pager&lt;/code&gt; subcomponent. Lastly, the HTML table full of thumbnails is displayed.&lt;/p&gt;

&lt;p&gt;Speaking of thumbnails, it&amp;rsquo;s time to look at the code in the &lt;code&gt;.thumb_view&lt;/code&gt; subcomponent.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%method .thumb_view&amp;gt;
    &amp;lt;%args&amp;gt;
      $file
      $page
    &amp;lt;/%args&amp;gt;
      &amp;lt;a href=&amp;quot;/gallery/&amp;lt;% $rel_img %&amp;gt;.html?page=&amp;lt;% $page %&amp;gt;&amp;quot;&amp;gt;
        &amp;lt;img src=&amp;quot;/gallery/images/&amp;lt;% $rel_img %&amp;gt;?xsize=50;ysize=40&amp;quot; border=&amp;quot;0&amp;quot; /&amp;gt;
      &amp;lt;/a&amp;gt;
    &amp;lt;%init&amp;gt;
      my $rel_img = abs2rel $file, $GALLERY_ROOT;
    &amp;lt;/%init&amp;gt;
  &amp;lt;/%method&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This component takes two arguments. &lt;code&gt;$file&lt;/code&gt; is the image to be turned into a thumbnail, and &lt;code&gt;$page&lt;/code&gt; is the current page of this gallery. The &lt;code&gt;&amp;lt;%init&amp;gt;&lt;/code&gt; block just finds the relative path of this image from the &lt;code&gt;$GALLERY_ROOT&lt;/code&gt;. In the template the thumbnail is linked to the HTML file that this image would be displayed on, and includes the current page information as a means of saving that state.&lt;/p&gt;

&lt;p&gt;The source of the image points to a file under &lt;em&gt;/gallery/images&lt;/em&gt;, and includes query parameters for maximum width (&lt;code&gt;xsize&lt;/code&gt;) and height (&lt;code&gt;ysize&lt;/code&gt;). This is interesting because the pictures don&amp;rsquo;t live there at all. If you recall, the only thing inside the &lt;em&gt;images&lt;/em&gt; directory was a &lt;em&gt;dhandler&lt;/em&gt;. More on that later.&lt;/p&gt;

&lt;p&gt;The other subcomponent that &lt;code&gt;.photo_list&lt;/code&gt; called was &lt;code&gt;.photo_pager&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%method .photo_pager&amp;gt;
    &amp;lt;%args&amp;gt;
      $page
      $pages
    &amp;lt;/%args&amp;gt;
    (
  % for ( 1 .. $pages ) {
  %   if ( $_ == $page ) {
        &amp;lt;strong&amp;gt;&amp;lt;% $page %&amp;gt;&amp;lt;/strong&amp;gt;
  %   } else {
        &amp;lt;a href=&amp;quot;?page=&amp;lt;% $_ %&amp;gt;&amp;quot;&amp;gt;&amp;lt;% $_ %&amp;gt;&amp;lt;/a&amp;gt;
  %   }
      &amp;lt;% $_ != $pages ? &amp;quot;&amp;amp;middot;&amp;quot; : &amp;quot;&amp;quot; %&amp;gt;
  % }
    )
    &amp;lt;%init&amp;gt;
      return if $pages == 1;
    &amp;lt;/%init&amp;gt;
  &amp;lt;/%method&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This subcomponent takes two arguments, the current page and the total number of pages. Before anything is output, the &lt;code&gt;&amp;lt;%init&amp;gt;&lt;/code&gt; block checks to make sure we have more than one page. If not, no sense in going on. Looping through all the page numbers, we link all the numbers except our current page. After every number except the last one, we output a stylish separator. This subcomponent is very simple, but big enough that it&amp;rsquo;s worth abstracting from the &lt;code&gt;.photo_list&lt;/code&gt; subcomponent.&lt;/p&gt;

&lt;p&gt;The final subcomponent in the top-level &lt;em&gt;dhandler&lt;/em&gt; is &lt;code&gt;.photo_view&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%method .photo_view&amp;gt;
    &amp;lt;%args&amp;gt;
      $file
    &amp;lt;/%args&amp;gt;
    &amp;lt;h3&amp;gt;Photo&amp;lt;/h3&amp;gt;
    &amp;lt;img src=&amp;quot;/gallery/images/&amp;lt;% $rel_image %&amp;gt;?xsize=400x;ysize=300&amp;quot; /&amp;gt;
    &amp;lt;%init&amp;gt;
      my $rel_image = abs2rel $file, $GALLERY_ROOT;
    &amp;lt;/%init&amp;gt;
  &amp;lt;/%method&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This component does things that we&amp;rsquo;ve already seen done in &lt;code&gt;.thumb_view&lt;/code&gt;, so there&amp;rsquo;s no need to expound upon it here.&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-images-dhandler-the-images-dhandler-span&#34;&gt;&lt;span id=&#34;The_Images_dhandler&#34;&gt;The Images &lt;em&gt;dhandler&lt;/em&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;You&amp;rsquo;ve probably guessed by now that we intend to use Mason to process images. Mason is well suited to outputting many forms of data, not just text, and we&amp;rsquo;ll be exploiting that fact for our image gallery.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%args&amp;gt;
    $xsize =&amp;gt; undef
    $ysize =&amp;gt; undef
  &amp;lt;/%args&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This component accepts two parameters that we&amp;rsquo;ve already described. &lt;code&gt;$xsize&lt;/code&gt; is the maximum width an image can be, and &lt;code&gt;$ysize&lt;/code&gt; is the maximum height an image can be.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%flags&amp;gt;
    inherit =&amp;gt; undef
  &amp;lt;/%flags&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the important part. Because components have inheritance, the &lt;em&gt;dhandler&lt;/em&gt; would normally inherit from the &lt;em&gt;autohandler&lt;/em&gt;. That&amp;rsquo;s bad news when the &lt;em&gt;autohandler&lt;/em&gt; is tuned to sending out HTML and our &lt;em&gt;dhandler&lt;/em&gt; is trying to send binary image data. Setting the &lt;code&gt;inherit&lt;/code&gt; flag to &lt;code&gt;undef&lt;/code&gt; tells Mason that the &lt;em&gt;dhandler&lt;/em&gt; doesn&amp;rsquo;t inherit anything, that it&amp;rsquo;s responsible for its own output.&lt;/p&gt;

&lt;p&gt;The only code remaining in this template resides in the &lt;code&gt;&amp;lt;%init&amp;gt;&lt;/code&gt; block, so let&amp;rsquo;s step through that now.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;%init&amp;gt;
    $m-&amp;gt;clear_buffer;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The very first thing we do is clear Mason&amp;rsquo;s output buffer. This clears any headers that have already been built up in the buffer.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Imager;
    use File::Type;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we use the modules that will help scale the images, &lt;code&gt;Imager&lt;/code&gt; and &lt;code&gt;File::Type&lt;/code&gt;. &lt;code&gt;Imager&lt;/code&gt; has already been discussed. &lt;code&gt;File::Type&lt;/code&gt; uses magic to discover the type of files, and does so in a very memory-sensitive way.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $send_img = sub {
      $r-&amp;gt;content_type( &amp;quot;image/$_[0]&amp;quot; );
      $r-&amp;gt;send_http_header;
      $m-&amp;gt;print($_[1]);
      $m-&amp;gt;abort(200);
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This anonymous subroutine just encapsulates code being executed twice, as a means to remove duplication. It sets the HTTP &lt;code&gt;Content-Type&lt;/code&gt; header to the image type passed as the first argument. Next it sends the HTTP header out. Then it sends the image data out, which is the second argument passed to this subroutine. Finally, it aborts execution with an HTTP &lt;code&gt;200&lt;/code&gt; status code, everything is &lt;em&gt;OK&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ( my $file = $r-&amp;gt;document_root . $r-&amp;gt;uri ) =~ s/images/pictures/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Discovering the proper file name for the image takes just a little work. After concatenating the &lt;code&gt;document_root()&lt;/code&gt; with the &lt;code&gt;uri()&lt;/code&gt;, we replace the &lt;em&gt;images&lt;/em&gt; portion of the file path with &lt;em&gt;pictures&lt;/em&gt;. Remember, none of the images are actually in the &lt;em&gt;images&lt;/em&gt; directory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my ($image, $type) = split /\//, File::Type-&amp;gt;checktype_filename($file);
    $type = &#39;png&#39; if $type eq &#39;x-png&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the knowledge of the proper file name, &lt;code&gt;File::Type&lt;/code&gt; can figure out what type of file we have. This is more foolproof than attempting a guess based on filename extensions. As a minor oddity, &lt;code&gt;File::Type&lt;/code&gt; returns a non-HTTP friendly &lt;code&gt;$type&lt;/code&gt; for PNG images, so we need to fix that problem if it exists.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $key = &amp;quot;$file|$xsize|$ysize&amp;quot;;
    if ( my $data = $m-&amp;gt;cache-&amp;gt;get( $key ) ) {
      $send_img-&amp;gt;($type, $data);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Generating scaled images from huge photos is a time-consuming function. It also has the potential to eat memory like a sieve. As a result, it&amp;rsquo;s imperative that we take advantage of Mason&amp;rsquo;s built-in caching functionality. The key for each entry in our cache must be unique for each file, and the dimensions we&amp;rsquo;re trying to scale it to. Those three pieces of data will make up our &lt;code&gt;$key&lt;/code&gt;. If data is returned from the cache using the &lt;code&gt;$key&lt;/code&gt;, then the image data is sent and the request is immediately aborted. This is a quick short-circuit that allows us to grab an image from the cache and return it at the earliest possible moment. Later in the article you&amp;rsquo;ll see how to set the data into the cache.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $m-&amp;gt;abort(500) if $image ne &#39;image&#39; || ! exists $Imager::formats{$type};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s possible that the file being requested isn&amp;rsquo;t an image. It&amp;rsquo;s also possible that our installation of &lt;code&gt;Imager&lt;/code&gt; doesn&amp;rsquo;t support this type of image. If either of these conditions are true, we should abort immediately with a &lt;code&gt;500&lt;/code&gt; HTTP status code, &lt;em&gt;Internal Server Error&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $img  = Imager-&amp;gt;new;
    if ( $img-&amp;gt;open(file =&amp;gt; $file, type =&amp;gt; $type) ) {
        if ( $xsize ) {
          $img = $img-&amp;gt;scale( xpixels =&amp;gt; $xsize )
            unless $img-&amp;gt;getwidth &amp;lt; $xsize;
        }
        if ( $ysize ) {
          $img = $img-&amp;gt;scale( ypixels =&amp;gt; $ysize )
            unless $img-&amp;gt;getheight &amp;lt; $ysize;
        }

        my $img_data;
        $img-&amp;gt;write(data =&amp;gt; \$img_data, type =&amp;gt; $type);
        $m-&amp;gt;cache-&amp;gt;set( $key =&amp;gt; $img_data );
        $send_img-&amp;gt;($type, $img_data);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the heart and soul of image manipulation. The first step is to create a new &lt;code&gt;Imager&lt;/code&gt; object. Next we try to open the image &lt;code&gt;$file&lt;/code&gt;. If that succeeds, we can proceed to scaling the image.&lt;/p&gt;

&lt;p&gt;When scaling, it&amp;rsquo;s more important (to me) that the height of the image is exactly how I want it, so width is scaled first. Before the image is scaled its size is tested against the size of the image to be created. No scaling should occur if the image is smaller than the preferred size.&lt;/p&gt;

&lt;p&gt;Once scaling has finished the image data can be extracted from the &lt;code&gt;Imager&lt;/code&gt; object. When calling &lt;code&gt;write()&lt;/code&gt; on the object we can pass a &lt;code&gt;data&lt;/code&gt; option to let &lt;code&gt;Imager&lt;/code&gt; write to a scalar reference. After the image data has been retrieved it is placed in the cache using the same &lt;code&gt;$key&lt;/code&gt; that we first used when attempting to get information out of the cache. Finally, the image is sent out and the request is aborted.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    warn &amp;quot;[$file] [$image/$type] &amp;quot; . $img-&amp;gt;errstr;
    $m-&amp;gt;abort(500);
  &amp;lt;/%init&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the event that &lt;code&gt;Imager&lt;/code&gt; wasn&amp;rsquo;t able to open the &lt;code&gt;$file&lt;/code&gt;, the request should be aborted with a &lt;code&gt;500&lt;/code&gt; HTTP status code, &lt;em&gt;Internal Server Error&lt;/em&gt;. Before abortion, however, it would be useful to get some information in the &lt;em&gt;error_log&lt;/em&gt;. The requested &lt;code&gt;$file&lt;/code&gt;, its type information, and the error produced by &lt;code&gt;Imager&lt;/code&gt; are all printed to &lt;code&gt;STDOUT&lt;/code&gt; via &lt;code&gt;warn&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-what-it-looks-like-what-it-looks-like-span&#34;&gt;&lt;span id=&#34;What_It_Looks_Like&#34;&gt;What It Looks Like&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;For the less adventurous, yet overly curious members of the audience, a screenshot of our photo gallery follows.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2004_04_01_masongal/figure_0.jpg&#34; alt=&#34;Photo Gallery Screenshot&#34; width=&#34;450&#34; height=&#34;285&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As an aside, that image was originally much larger, but I really wanted it to be just &lt;code&gt;450&lt;/code&gt; pixels wide. I don&amp;rsquo;t have any image manipulation tools to do that job, but I do have &lt;code&gt;Imager&lt;/code&gt;. Thanks to &lt;code&gt;Imager&lt;/code&gt;, it took me 30 seconds to whip up the following command line snippet.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  perl -MImager -le&#39;Imager-&amp;gt;new-&amp;gt;open(file=&amp;gt;shift,type=&amp;gt;&amp;quot;jpeg&amp;quot;)
    -&amp;gt;scale(xpixels=&amp;gt;450)
    -&amp;gt;write(file=&amp;gt;shift,type=&amp;gt;&amp;quot;jpeg&amp;quot;)&#39; figure_0.jpg figure_0_0.jpg
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-conclusion-conclusion-span&#34;&gt;&lt;span id=&#34;Conclusion&#34;&gt;Conclusion&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ve just created a photo gallery that takes all the hard work out of maintaining photo galleries. There&amp;rsquo;s no need to pre-generate HTML or thumbnails. There&amp;rsquo;s no web application interface so you don&amp;rsquo;t have to change ownership of your gallery directory to the same user that Apache runs as. Using Mason&amp;rsquo;s built-in caching, photo galleries are nearly as fast as accessing the data directly from the file system. Well, at least on the second request. Our galleries have paging and infinite sub-galleries. Most importantly, using Mason to its full potential has given us a fully customizable, very tiny web application that can be dropped into any existing web site or framework.&lt;/p&gt;

&lt;p&gt;In fact, this code is the majority of the &lt;em&gt;faceplant&lt;/em&gt; project. The source code can be downloaded from &lt;a href=&#34;https://metacpan.org/pod/faceplant&#34;&gt;faceplant on MetaCPAN&lt;/a&gt;. &lt;em&gt;faceplant&lt;/em&gt; implements a few more features and is a bit more customizable. As such, its code is an excellent follow-up to this article. Go forth, now, and plant thy face on the Internet!
&amp;ldquo; &amp;gt;}}&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Graphics Programming with Perl</title>
      <link>http://localhost:1313/pub/2002/07/23/review.html/</link>
      <pubDate>Tue, 23 Jul 2002 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2002/07/23/review.html/</guid>
      <description>&lt;p&gt;I recently received Martien Verbruggen&amp;rsquo;s long-awaited &amp;ldquo;Graphics Programming in Perl,&amp;rdquo; and I wasn&amp;rsquo;t quite sure what to make of it. As he notes himself, &amp;ldquo;I didn&amp;rsquo;t think there would be enough coherent material to write such a book, and I wasn&amp;rsquo;t entirely certain there would be much room for one.&amp;rdquo; Sure, you can write a chapter or so on business graphing &amp;ndash; something on GraphViz &amp;ndash; and a few chapters on GD, Imager and &lt;code&gt;Image::Magick&lt;/code&gt;. But an entire book?&lt;/p&gt;

&lt;p&gt;Like Martien, the more I look at this topic, the more there is to say, and the more comfortable I am with the way Martien says it. The book seems to concentrate primarily on &lt;code&gt;Image::Magick&lt;/code&gt;, with some examples of &lt;code&gt;GD&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;All technical books seem to begin with a certain amount of introductory waffle; in &amp;ldquo;Graphics Programming in Perl,&amp;rdquo; the waffle is at least to some degree relevant - there&amp;rsquo;s a fundamental introduction to such things as color spaces, including some relatively fearsome equations converting between the various color systems. The introduction is carried on through chapter 2, a review of graphics file formats. I can&amp;rsquo;t really categorize this as waffle, though, since a thorough understanding of these things are fundamental to graphics programming.&lt;/p&gt;

&lt;p&gt;The real Perl meat starts around the middle of chapter 2, with sections on finding the size of an image and converting between images. Unfortunately, there&amp;rsquo;s more introductory material again in chapter 3, with sections on the CPAN and descriptions on the modules that will be used in the rest of the book. Hence, I wouldn&amp;rsquo;t really say this was the fastest-starting book around, and most people will be able to happily skip the first 30 or 35 pages without much loss of continuity.&lt;/p&gt;

&lt;p&gt;Chapter 4 is where we actually start using Perl to draw things, the stated purpose of the book. We begin with drawing simple objects in GD, which is adequately explained, but unfortunately, there&amp;rsquo;s no mention of how to save the images yet, so we can&amp;rsquo;t check them or play with the examples and examine the results!&lt;/p&gt;

&lt;p&gt;Next, the same examples are implemented using &lt;code&gt;Image::Magick&lt;/code&gt;, a good comparison of the two modules; there&amp;rsquo;s also another good comparison in the middle of an ill-fitting chapter on module interface design. In the middle, there&amp;rsquo;s precisely the sort of thing you&amp;rsquo;d expect for a book of this nature: font handling, business graphs, 3D rendering, (although a little more detail on this topic would have been nice) and so on. The section on designing graphics for the Web is, if you&amp;rsquo;ll allow a slight exaggeration, flawless.&lt;/p&gt;

&lt;p&gt;I find the &amp;ldquo;bullet-point annotated code&amp;rdquo; style of explanation gets the important points across well, and Martien has achieved a nice balance of explanatory prose and demonstration code. The material occasionally seems to be let down by the odd bug or two in Image::Magick, but we can hardly blame the author for that.&lt;/p&gt;

&lt;p&gt;What really disappointed me about this book was the glaring and complete omission of the &lt;code&gt;Imager&lt;/code&gt; module; this is another module for doing programmatic graphics creation, and I personally favor it above &lt;code&gt;Image::Magick&lt;/code&gt; and &lt;code&gt;GD&lt;/code&gt;, which both require an intermediary external C library on top of the various libraries for handling graphics formats.&lt;/p&gt;

&lt;p&gt;Similarly, much more could have been made of the interaction between Perl and the Gimp - there were a few pages on creating animated GIFs, but nothing about using Gimp plug-ins and the like.&lt;/p&gt;

&lt;p&gt;Hence, in conclusion, I think if you take this book as being a complete reference to everything you can do with graphics and Perl, you&amp;rsquo;re going to be disappointed. However, if you have certain tasks in mind and need to know how to do them, or you&amp;rsquo;re particularly interested in what you can do with the &lt;code&gt;Image::Magick&lt;/code&gt; module, then this book is for you.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.manning.com/verbruggen/index.html&#34;&gt;Graphics Programming With Perl&lt;/a&gt; is available from &lt;a href=&#34;http://www.manning.com&#34;&gt;Manning&lt;/a&gt; and all good computer bookshops.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A Drag-and-Drop Primer for Perl/Tk</title>
      <link>http://localhost:1313/pub/2001/12/11/perltk.html/</link>
      <pubDate>Tue, 11 Dec 2001 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2001/12/11/perltk.html/</guid>
      <description>

&lt;p&gt;As it happens, no matter how much I write about Perl/Tk, there&amp;rsquo;s always something left unsaid. A case in point is the topic of drag and drop, which didn&amp;rsquo;t make it into our book, &lt;em&gt;Mastering Perl/Tk&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This article describes the Perl/Tk drag-and-drop mechanism, often referred to as DND. We&amp;rsquo;ll illustrate DND operations local to a single application, where we drag items from one Canvas to another.&lt;/p&gt;

&lt;p&gt;There are two basic types of DND operations, local (intra-application) and remote (inter-application). Local drops are fully supported, but there is no standard for remote drops. For this reason, this article describes only local DND operations. Note: Perl/Tk supports Sun, XDND, KDE, and Win32 remote DND protocols.&lt;/p&gt;

&lt;p&gt;To write DND code you should be comfortable with these concepts:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The drag source is the widget that we drag. In the case of a Canvas widget, we can arrange for an individual item to be the drag source.&lt;/li&gt;
&lt;li&gt;The drop destination is the widget upon which we drop the source widget.&lt;/li&gt;
&lt;li&gt;The DND token is a &lt;code&gt;Label&lt;/code&gt; widget that tracks the cursor as it moves from the drag source to the drop destination. We can configure the DND token with a text string or an image.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2001_12_11_perltk/drag.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This figure shows what we will end up with&amp;ndash;one Canvas populated by various types of objects, which we can drag around the application and drop onto another Canvas. Let&amp;rsquo;s now look at the code.&lt;/p&gt;

&lt;p&gt;Here we have a rather typical Perl/Tk prologue. &lt;code&gt;Tk::DragDrop&lt;/code&gt; is required if coding a program with a drag source, while &lt;code&gt;Tk::DropSite&lt;/code&gt; is required for programs declaring a drop destination.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Tk;
    use strict;
    use Tk::DragDrop;
    use Tk::DropSite;
    use subs qw/make_bindings move_bbox move_image/;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;global-variables&#34;&gt;Global variables&lt;/h3&gt;

&lt;p&gt;A drag begins with a &lt;code&gt;&amp;lt;ButtonPress-1&amp;gt;&lt;/code&gt; event, where we record the ID of the specified Canvas item in the variable &lt;code&gt;$drag_id&lt;/code&gt;. &lt;code&gt;$mw&lt;/code&gt; is, of course, a reference to the program&amp;rsquo;s MainWindow.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    our (
         $drag_id,              # Canvas item id of drag source
         $mw,                   # Perl/Tk MainWindow reference
    );

$mw = MainWindow-&amp;gt;new(-background =&amp;gt; &#39;green&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Define the drag source&amp;ndash;a Canvas full of items. Here we declare that a &lt;code&gt;&amp;lt;B1-Motion&amp;gt;&lt;/code&gt; event over the source Canvas signals the start of a local drag operation.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$drag_source&lt;/code&gt; is a &lt;code&gt;Tk::DragDrop&lt;/code&gt; object, sometimes called a DND token. It&amp;rsquo;s really a disguised &lt;code&gt;Label&lt;/code&gt; widget, which we can configure in the standard fashion. For our purposes, we set the &lt;code&gt;-text&lt;/code&gt; option to describe the &lt;code&gt;Canvas&lt;/code&gt; item we are dragging, rather than the default text of the source widget&amp;rsquo;s class name. But you can assign an image to the DND token if desired.&lt;/p&gt;

&lt;p&gt;When performing a DND operation, notice that the DND token has a flat relief over the source, and a sunken relief over the destination.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $c_src = $mw-&amp;gt;Canvas(qw/-background yellow/)-&amp;gt;pack;

    my $drag_source = $c_src-&amp;gt;DragDrop(
        -event     =&amp;gt; &#39;&amp;lt;B1-Motion&amp;gt;&#39;,
        -sitetypes =&amp;gt; [qw/Local/],
    );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Every &lt;code&gt;Canvas&lt;/code&gt; source item has a &lt;code&gt;&amp;lt;ButtonPress-1&amp;gt;&lt;/code&gt; binding associated with it. The callback bound to this event serves to record the item&amp;rsquo;s ID in the global variable &lt;code&gt;$drag_id&lt;/code&gt;, and to configure the drag &lt;code&gt;Label&lt;/code&gt;&amp;rsquo;s &lt;code&gt;-text&lt;/code&gt;/ option with the item&amp;rsquo;s ID and type.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $press = sub {
        my ($c_src, $c_src_id, $drag_source) = @_;
        $drag_id = $c_src_id;
        my $type = $c_src-&amp;gt;type($drag_id);
        $drag_source-&amp;gt;configure(-text =&amp;gt; $c_src_id . &amp;quot; = $type&amp;quot;);
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK, let&amp;rsquo;s populate the source Canvas with items of various types. For this demonstration, we limit the choices to ovals, rectangles, and all the GIF files in the current directory. As noted earlier, every item gets a &lt;code&gt;&amp;lt;ButtonPress-1&amp;gt;&lt;/code&gt; binding.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my ($x, $y) = (30, 30);
    foreach (&amp;lt;*.gif&amp;gt;) {

        my $id = $c_src-&amp;gt;createImage($x, $y,
            -image =&amp;gt; $mw-&amp;gt;Photo(-file =&amp;gt; $_));
        $x += 80;
        $c_src-&amp;gt;bind($id, &#39;&amp;lt;ButtonPress-1&amp;gt;&#39; =&amp;gt; [$press, $id, $drag_source]);

    } # forend

    $x = 30;
    $y = 80;

    foreach (qw/oval rectangle/) {

        my $method = &#39;create&#39; . ucfirst $_;
        my $id = $c_src-&amp;gt;$method($x, $y, $x + 40, $y + 40, -fill =&amp;gt; &#39;orange&#39;);
        $x += 80;
        $c_src-&amp;gt;bind($id, &#39;&amp;lt;ButtonPress-1&amp;gt;&#39; =&amp;gt; [$press, $id, $drag_source]);

    } # forend
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Define the drop-site destination&amp;ndash;another &lt;code&gt;Canvas&lt;/code&gt;. As a source &lt;code&gt;Canvas&lt;/code&gt; item is dropped here, create an identical item in the destination at the drop coordinates.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $c_dest = $mw-&amp;gt;Canvas(qw/-background cyan/)-&amp;gt;pack;
    $c_dest-&amp;gt;DropSite(
        -droptypes   =&amp;gt; [qw/Local/],
        -dropcommand =&amp;gt; [\&amp;amp;move_items, $c_src, $c_dest],
    );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Build the obligatory Quit Button, and enter the main event loop.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $quit = $mw-&amp;gt;Button(-text =&amp;gt; &#39;Quit&#39;, -command =&amp;gt; [$mw =&amp;gt; &#39;destroy&#39;]);
    $quit-&amp;gt;pack;

    MainLoop;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These subroutines are invoked when a &lt;code&gt;Canvas&lt;/code&gt; source item is dropped on the destination &lt;code&gt;Canvas&lt;/code&gt;. Callback &amp;ldquo;&lt;code&gt;move_items&lt;/code&gt;&amp;rdquo; is invoked first, with these arguments:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;$c_src  = source Canvas widget reference
$c_dest = destination Canvas widget reference
$sel    = selection type, here &amp;quot;XdndSelection&amp;quot;
$dest_x = Canvas drop site X coordinate
$dest_y = Canvas drop site Y coordinate
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;The first two arguments we supplied on the &lt;code&gt;-dropcommand&lt;/code&gt; option. The remaining arguments are implicitly supplied by Perl/Tk.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;&lt;code&gt;move_items&lt;/code&gt;&amp;rdquo; simply branches according to the item&amp;rsquo;s type, throwing an error for &lt;code&gt;Canvas&lt;/code&gt; items we are not prepared to handle. Each type handler receives the preceding arguments plus the item&amp;rsquo;s type.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub move_items {

        $_ = $_[0]-&amp;gt;type($drag_id);
        return unless defined $_;

      CASE: {

        /image/      and do {move_image $_, @_; last CASE};
        /oval/       and do {move_bbox  $_, @_; last CASE};
        /rectangle/  and do {move_bbox  $_, @_; last CASE};
        warn &amp;quot;Unknown Canvas item type &#39;$_&#39;.&amp;quot;;

      }# casend

    } # end move_items
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Subroutine &amp;ldquo;&lt;code&gt;move_bbox&lt;/code&gt;&amp;rdquo; handles all &lt;code&gt;Canvas&lt;/code&gt; item types described by a bounding box. (For this demonstration, we only propagate the &lt;code&gt;-fill&lt;/code&gt; attribute from the &lt;code&gt;Canvas&lt;/code&gt; source item to the new item.) It uses the subroutine &amp;ldquo;&lt;code&gt;make_bindings&lt;/code&gt;&amp;rdquo; given below to establish local bindings on the newly created destination item, so it can be dragged about the destination Canvas.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub move_bbox {

        my ($item_type, $c_src, $c_dest, $sel, $dest_x, $dest_y) = @_;

        my $fill = $c_src-&amp;gt;itemcget($drag_id, -fill);
        my $method = &#39;create&#39; . ucfirst $item_type;
        my $id = $c_dest-&amp;gt;$method($dest_x, $dest_y,
            $dest_x + 40, $dest_y + 40, -fill =&amp;gt; $fill,
        );

        make_bindings $c_dest, $id;

    } # end move_bbox
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Subroutine &amp;ldquo;&lt;code&gt;move_image&lt;/code&gt;&amp;rdquo; handles a &lt;code&gt;Canvas&lt;/code&gt; image item type. It uses the &amp;ldquo;&lt;code&gt;make_bindings&lt;/code&gt;&amp;rdquo; subroutine just described.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub move_image {

        my ($item_type, $c_src, $c_dest, $sel, $dest_x, $dest_y) = @_;

        my $image = $c_src-&amp;gt;itemcget($drag_id, -image);
        my $id = $c_dest-&amp;gt;createImage($dest_x, $dest_y, -image =&amp;gt; $image);

        make_bindings $c_dest, $id;

    } # end move_image
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;ldquo;&lt;code&gt;make_bindings&lt;/code&gt;&amp;rdquo; itself adds drag behavior to our newly dropped &lt;code&gt;Canvas&lt;/code&gt; items, but without using the DND mechanism. The basic idea is as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;On a &lt;code&gt;&amp;lt;ButtonPress-1&amp;gt;&lt;/code&gt; event, record the &lt;code&gt;Canvas&lt;/code&gt; item&amp;rsquo;s (x,y) coordinates in instance variables of the form &lt;code&gt;&amp;quot;x&amp;quot; . $id&lt;/code&gt; and &lt;code&gt;&amp;quot;y&amp;quot; . $id&lt;/code&gt;, where &lt;code&gt;$id&lt;/code&gt; is the item&amp;rsquo;s &lt;code&gt;Canvas&lt;/code&gt; ID. This ensures that each item&amp;rsquo;s position is uniquely maintained.&lt;/li&gt;
&lt;li&gt;On a &lt;code&gt;&amp;lt;ButtonRelease-1&amp;gt;&lt;/code&gt; event, compute an (x,y) delta from the item&amp;rsquo;s original position (stored in instance variables) and the new position, and use the &lt;code&gt;Canvas&lt;/code&gt; &amp;ldquo;&lt;code&gt;move&lt;/code&gt;&amp;rdquo; method to relocate it.&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- --&gt;

&lt;pre&gt;&lt;code&gt;    sub make_bindings {

        my ($c_dest, $id) = @_;

        $c_dest-&amp;gt;bind($id, &#39;&amp;lt;ButtonPress-1&amp;gt;&#39; =&amp;gt; [sub {
        my ($c, $id) = @_;
        ($c_dest-&amp;gt;{&#39;x&#39; . $id}, $c_dest-&amp;gt;{&#39;y&#39; . $id}) =
            ($Tk::event-&amp;gt;x, $Tk::event-&amp;gt;y);
        }, $id]);

        $c_dest-&amp;gt;bind($id, &#39;$lt;ButtonRelease-1&amp;gt;&#39; =&amp;gt; [sub {
        my ($c, $id) = @_;
        my($x, $y) = ($Tk::event-&amp;gt;x, $Tk::event-&amp;gt;y);
        $c-&amp;gt;move($id, $x - $c_dest-&amp;gt;{&#39;x&#39; . $id}, $y - $c_dest-&amp;gt;{&#39;y&#39; . $id});
        }, $id]);

    } # end make_bindings
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The entire source code to this program is available &lt;a href=&#34;http://localhost:1313/media/_pub_2001_12_11_perltk/drag.pl&#34;&gt;here&lt;/a&gt;, and for more information about Perl/Tk programming, check out &lt;a href=&#34;http://www.oreilly.com/catalog/mastperltk/&#34;&gt;Mastering Perl/Tk&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;O&amp;rsquo;Reilly &amp;amp; Associates will soon release (January 2002) &lt;a href=&#34;http://www.oreilly.com/catalog/mastperltk/&#34;&gt;Mastering Perl/Tk&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;You can also look at the &lt;a href=&#34;http://oreilly.com/catalog/mastperltk/desc.html&#34;&gt;Full Description&lt;/a&gt; of the book.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;For more information, or to order the book, &lt;a href=&#34;http://www.oreilly.com/catalog/mastperltk/&#34;&gt;click here&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Writing GUI Applications in Perl/Tk</title>
      <link>http://localhost:1313/pub/2001/03/gui.html/</link>
      <pubDate>Tue, 06 Mar 2001 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2001/03/gui.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;&amp;ldquo;This article originally appeared in Visual Developer Magazine&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Perl is officially known as the &amp;ldquo;Practical Extraction and Report Language,&amp;rdquo; in part because of its extremely robust text handling abilities. Perl&amp;rsquo;s author, Larry Wall, has a much more colorful name for the language: the &amp;ldquo;Pathologically Eclectic Rubbage Lister.&amp;rdquo; Many people are aware of Perl&amp;rsquo;s role in the Web, specifically as an easy-to-use text processing language for writing CGI scripts. What many people don&amp;rsquo;t realize, however, is that Perl is a powerful general purpose programming language that can be used to do general-purpose development&amp;ndash; including cross-platform GUI development with the Tk tool kit originally developed for the Tcl programming language under Unix. An important advantage of using the pTk (Perl/Tk) combination is that you can write truly portable cross-platform GUI applications&amp;ndash; applications that will work similarly across Win32, Macintosh, Linux, and even the AS/400!&lt;/p&gt;

&lt;p&gt;In this article, I will introduce the basics of installing the Perl interpreter for Win32 and writing a visual application using the Tk (toolkit) modules. This system is geared toward the Win32 and Linux developers; however, most of the information presented pertains to other operating systems as well.&lt;/p&gt;

&lt;h3 id=&#34;a-point-of-sale-terminal-in-ptk&#34;&gt;A Point-of-Sale Terminal in pTk&lt;/h3&gt;

&lt;p&gt;My expertise lies in electronic commerce. So when I decided to write this article, I naturally looked around to see what might be useful to others using the pTk system. One project I&amp;rsquo;ve worked on recently is integrating the PaymentNet credit-card processing client software into various applications. I decided that it would be great to have a system that could do all my credit-card processing from my local PC, for testing as well as for real e-commerce. So I created a pTk Point-of-Sale (POS) terminal program to do so. For many merchants, it is less expensive (and faster) to use the Internet to process their credit card (or check) transactions than to purchase additional software or terminals.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2001_03_gui/fig1.jpg&#34; alt=&#34;The terminal under Windows 95&#34; width=&#34;450&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Figure 1: The terminal under Windows 95.&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The example system uses a simulated credit-card authorization module that does nothing except verify that the transaction could be a valid one. Real transactions can be implemented quite easily; I&amp;rsquo;ll show you how at the end of the article. Of course, the code works with any pTk system. You can see it running under both Windows 95 (Figure 1) and Linux (Figure 2).&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2001_03_gui/fig2.jpg&#34; alt=&#34;Figure 2: The terminal under Linux.&#34; width=&#34;450&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Figure 2: The terminal under Linux.&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;We will cover a lot of ground very quickly in this article, and of necessity, will gloss over quite a few very important points. Perl comes with some of the best documentation available in the form of POD (plain old documentation) files, and a search/viewing program called perldoc. Whenever you get stuck, chances are the answer to your questions will be right on your local computer. For now, you can find more information by typing perldoc perldoc from the command line&amp;ndash; once Perl is installed, of course! I&amp;rsquo;ll remind you of this a couple of times.&lt;/p&gt;

&lt;p&gt;First, we&amp;rsquo;ll need to install both Perl and the Tk libraries. If you are using Linux, this will mean compiling the libraries as well, though that is not at all difficult. Then we&amp;rsquo;ll look at what it takes to make a pTk program: program flow, geometry management, event and variable bindings, and the event loop. I&amp;rsquo;ll then do a brief walk through the code, showing examples of various widget (object) use within the system. You should then be well on your way to being an expert pTk programmer!&lt;/p&gt;

&lt;h3 id=&#34;installing-activestate-perl-for-win32&#34;&gt;Installing ActiveState Perl for Win32&lt;/h3&gt;

&lt;p&gt;To install the latest version of Perl for Win32, go to the ActiveState download page (&lt;a href=&#34;http://www.activestate.com/Active-Perl/download.htm&#34;&gt;www.activestate.com/Active-Perl/download.htm&lt;/a&gt;). For Windows 98 and Windows NT, there are no special instructions; download the latest version (APi517e.exe as of this writing), and run the self-installer by double clicking on the file. For Windows95, however, you need to make sure that you have DCOM installed (it&amp;rsquo;s already installed on Win98 and NT machines). The DCOM files and installation instructions are available from the Microsoft&amp;rsquo;s Web site at &lt;a href=&#34;http://www.microsoft.com/com/dcom/dcom95/dcom1_3.asp&#34;&gt;www.microsoft.com/com/dcom/dcom95/dcom1_3.asp&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;installing-the-perl-tk-modules-with-perl-package-manager&#34;&gt;Installing the Perl/Tk Modules with Perl Package Manager&lt;/h3&gt;

&lt;p&gt;ActiveState extended the standard CPAN modules (Comprehensive Perl Archive, which we will discuss shortly) with its own Perl Package Manager (PPM). The package manager makes installing and configuring the modules extremely easy. Note that the primary difference (other than user interface) between Perl&amp;rsquo;s standard CPAN module and the PPM is that CPAN deals exclusively with source code, requiring that you compile and install both Perl and the relevant modules from a source code distribution. ActiveStates&amp;rsquo; package manager, on the other hand, deals with pre-compiled modules that install on the host platform without compiling.&lt;/p&gt;

&lt;p&gt;Assuming your Perl has been installed properly, you should now be able to go to the DOS command prompt and run the Perl Package Manager by typing PPM. You can get summary help information by typing &amp;ldquo;PPM -h&amp;rdquo;. To use the PPM, you must be connected to the Internet. More PPM documentation can be found at www.activestate.com/ppm. You can also (as always) type &amp;ldquo;perldoc PPM&amp;rdquo; to get the documentation that comes with the module distribution.&lt;/p&gt;

&lt;p&gt;To download and install a single package, just type &amp;ldquo;install tk&amp;rdquo; from the PPM prompt. Be aware that the Tk module, a complete GUI development environment for Perl, is pretty big. The zip file on which the package is based is over 2MB in size, so the download can take a while, especially over a standard modem. Go ahead and install Tk, as it is required for the rest of this project. Also, if you have an older ActiveState Perl distribution (Perl5.004 or earlier), I suggest upgrading to the latest install now. If you don&amp;rsquo;t, the example program may not run. Specifically, you will need Data::Dumper installed, which you can load by typing &amp;ldquo;install Data-Dumper&amp;rdquo; from the PPM prompt, if you don&amp;rsquo;t already have it.&lt;/p&gt;

&lt;h3 id=&#34;installing-perl-and-tk-under-linux&#34;&gt;Installing Perl and Tk Under Linux&lt;/h3&gt;

&lt;p&gt;One of Perl&amp;rsquo;s great strengths is that there are hundreds of individual modules available for the language. All current builds of Perl come with a module-manager to be used with the Comprehensive Perl Archive Network (CPAN). Currently, CPAN lists over 260MB of source code! Windows users can also use CPAN if they&amp;rsquo;ve taken the time to compile their own version of Perl, rather than using ActiveState&amp;rsquo;s binary distribution.&lt;/p&gt;

&lt;p&gt;For my Linux desktop, I use the K Desktop Environment (KDE) that comes with the Caldera Open Linux 2.2 distribution. To run the system, make sure that you have both Perl and the gcc development environment installed. The following minimal packages are needed to install and run the system:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Perl&lt;/li&gt;
&lt;li&gt;egcs&lt;/li&gt;
&lt;li&gt;glibc&lt;/li&gt;
&lt;li&gt;Xfree86-devel (For X-Windows header files)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To verify that the packages are installed (or to install them if they aren&amp;rsquo;t):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Make sure that the Open Linux CD is in the drive.&lt;/li&gt;
&lt;li&gt;Log in as &amp;ldquo;root&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Click on the icon that looks like a house, labeled &amp;ldquo;Caldera Open Administration System&amp;rdquo; (COAS).&lt;/li&gt;
&lt;li&gt;Select &amp;ldquo;Software&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;When the window comes up, select &amp;ldquo;Workstation | Administration | Software&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Make sure that &amp;ldquo;kpackage&amp;rdquo; is checked.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This will install the K package manager if it isn&amp;rsquo;t already installed. Now click &amp;ldquo;K | Utilities&amp;rdquo;, and then select &amp;ldquo;kpackage&amp;rdquo;. The kpackage tree structure is a little easier to use and provides more information than the COAS, though they both manage distribution packages. If you are missing one of the packages above, simply select new from within the kpackage tree, select the package you want to install, and then click &amp;ldquo;examine&amp;rdquo; in the bottom right panel. A new dialog will pop up, allowing you to install the selected package.&lt;/p&gt;

&lt;h3 id=&#34;installing-and-building-tk-using-cpan&#34;&gt;Installing and Building Tk Using CPAN&lt;/h3&gt;

&lt;p&gt;To install and build the Tk libraries and Perl interface, it is necessary to execute the CPAN module. Open a command window (while still logged in as root), and execute the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;perl -MCPAN -e shell;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perl will load the module CPAN (-MCPAN), and execute (-e) the shell subroutine contained in the module. If this is your first time executing the script, it will ask you configuration questions. If you are unsure of the answers, just hit Enter. In most cases, the defaults are appropriate for your system. Eventually, you will be dropped into a &amp;ldquo;cpan&amp;gt;&amp;rdquo; prompt. At this point, you can type &amp;ldquo;h&amp;rdquo; for help, or go directly to the next step. To finish configuration, there are a few optional modules you should install just to make things a little easier. (If you are on a slow connection, you might want to skip installing the optional modules steps.)&lt;/p&gt;

&lt;p&gt;Install Internet communications modules (optional):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cpan&amp;gt; install Bundle::libnet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Upgrade CPAN (optional):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;install Bundle::CPAN
reload CPAN
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, build and install Tk:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;install Tk
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This should download, build, and install the Tk packages from the Internet. It&amp;rsquo;s not really any more difficult from using the PPM; however, CPAN does require that a C compiler be installed, which isn&amp;rsquo;t the norm for Windows users.&lt;/p&gt;

&lt;p&gt;Now that both Perl and Tk have been installed in your development environment, spend some time exploring the system. The toolkit comes with a few extremely useful example programs. A simple text editor called ptked is available, as well as ptksh (a GUI shell where you can experiment creating forms and other controls directly within the pTK environment, which is reminiscent of the BASIC command line interface). The widget program is a comprehensive demonstration and testing shell for&amp;ndash; you guessed it&amp;ndash; widget exploration. It&amp;rsquo;s a really fun tool to play with, one that can get you into programming with pTk very quickly. These utilities are available on all systems with pTk installed.&lt;/p&gt;

&lt;h3 id=&#34;ptk-core-concepts&#34;&gt;pTk Core Concepts&lt;/h3&gt;

&lt;p&gt;To understand a pTk program, we need to explore a few core concepts regarding the system design. In particular, you need to be familiar with the structure of the program, the way objects (widgets) are laid out on the screen (geometry management), the way communication is handled (variable and event binding), and the pTk event loop.&lt;/p&gt;

&lt;p&gt;All pTk programs are assembled in pretty much the same way:&lt;/p&gt;

&lt;p&gt;Create a main window, which is also known as the top-level window. Build a group of widgets (Unix-speak for controls), and arrange them inside the main window. In Perl, a widget is simply an object that contains data and methods to create some visible element of the user interface. Start the event loop. Events are then fired, and handled by the widgets and associated code.&lt;/p&gt;

&lt;h3 id=&#34;geometry-management&#34;&gt;Geometry Management&lt;/h3&gt;

&lt;p&gt;In a fashion similar to Java, Tk has a notion of &amp;ldquo;geometry management,&amp;rdquo; which is a fancy way of saying that the software wants to decide where to put your controls for you. Basically, you define the widget, and then tell the system about where you&amp;rsquo;d like it to go (top, bottom, etc.), and it takes care of sizing and placing the widget for you. We will use the &amp;ldquo;packer&amp;rdquo; and &amp;ldquo;grid&amp;rdquo; exclusively; however, others are available for different layouts. Since each frame can have its own geometry manager, extremely sophisticated placement schemes can be created using this system.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve used the grid() manager to divide the example application into four frames: $filemenu (at the top), $left, $right, and $bottom. The grid manager works like HTML tables: you can specify the row and column for each widget, as well as a columnspan and rowspan, if necessary. The &amp;ldquo;sticky&amp;rdquo; option tells the manager where to &amp;ldquo;attach&amp;rdquo; the widget, the options being north, south, east, west in any combination. Specifying all four will center your widget within its frame.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $left  = 
 $mainwindow-&amp;gt;Frame-&amp;gt;grid(-row =&amp;gt; 0, -col =&amp;gt; 0, -sticky =&amp;gt; &#39;nw&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Keep in mind that a widget won&amp;rsquo;t be displayed until its geometry manager is called. This can be useful to keep controls hidden until you&amp;rsquo;re ready to use them; however, it can also be a source of errors. If you have created a widget but can&amp;rsquo;t see it on the screen, chances are you&amp;rsquo;ve forgotten to set its manager.&lt;/p&gt;

&lt;h3 id=&#34;binding-variables&#34;&gt;Binding Variables&lt;/h3&gt;

&lt;p&gt;Variable binding is one of the most frequently used data input/output mechanisms available to pTk programs. The concept is relatively simple: a variable is bound to a control, and when the state of that control changes, the variable is updated to reflect the new state. The reverse is true as well: changing the state of the variables within the program automagically updates the associated controls. You can see examples of this throughout the source code. Note how saveConfig just dumps the state of the $config hash, and loadConfig does the opposite; the NoteBook control is updated to reflect the state changes without additional work. This is usually accomplished by passing the -variable or -textvariable option to the widget, as well as a reference to the scalar variable you want bound:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$left-&amp;gt;Optionmenu (-options =&amp;gt; \@trxtype, 
   -variable =&amp;gt; \$trans-&amp;gt;{TRXTYPE} )-&amp;gt;pack();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This statement binds the variable $trans-&amp;gt;{TRXTYPE} to a select box. Whenever you update the transaction type on the program, the variable changes to reflect the change. Note that the geometry manager (pack() in this case), is called to place the widget on its associated frame and to make it visible. This is a pattern that you will use quite a bit throughout pTk programming, and is central to the event model.&lt;/p&gt;

&lt;h3 id=&#34;binding-events&#34;&gt;Binding Events&lt;/h3&gt;

&lt;p&gt;Most action widgets have an optional parameter, &amp;ldquo;command,&amp;rdquo; that allows you to specify the function that should be called whenever this widget is acted upon in some way. This is a reference to a callback function that will be called when the widget receives an action event-button click, scrollbar release, etc.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$bottom-&amp;gt;Button(-text =&amp;gt; &#39;Process Transaction&#39;, 
        -command =&amp;gt; \&amp;amp;processTransaction )
        -&amp;gt;grid(qw/-row 2 -column 0 -sticky nesw/);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, the processTransaction function is called whenever the button is pressed. For most standard programs, this is the extent of the event management required, when combined with tied variables described in the previous section.&lt;/p&gt;

&lt;p&gt;It is also possible to bind additional events to subroutines by using the bind() call. The general format for doing so is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$widget-&amp;gt;bind(event, subroutine);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When an event related to your widget fires, the subroutine that has been bound to the command is called. Possible bound events include key clicks and releases, mouse motion, and window resizing. More information can be found using perldoc Tk:bind.&lt;/p&gt;

&lt;h3 id=&#34;the-event-loop&#34;&gt;The Event Loop&lt;/h3&gt;

&lt;p&gt;Once everything is set up, the only thing left to do is call MainLoop() from within the program. This goes into an endless loop, dispatching events from the underlying operating system to your applications and updating appropriate bound variables.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MainLoop();  # never returns
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just as in the pre-Win32 days when we used the cooperative multitasking of Windows 3.1 and text-based frameworks like Turbo Vision and other non-multitasking systems, you must break up any CPU-intensive tasks into manageable chunks by using the after() or repeat() method of most widgets, which are timers used to schedule events. Other methods may work equally well.&lt;/p&gt;

&lt;p&gt;This time-slicing problem crops up when doing a real transaction over the Internet. The system seems to &amp;ldquo;freeze&amp;rdquo; for a few seconds while processing the data, as the call to do so blocks until the data has been received. Unfortunately, this is normal behavior as the current release version of Perl is not yet threaded. However, the newest development version of Perl does incorporate a threaded architecture, so you can expect this limitation to be removed shortly. I noticed that the Perl shipped with the Caldera Open Linux 2.2 distribution has been compiled multi-threaded, though I haven&amp;rsquo;t tried using the new threading features yet.&lt;/p&gt;

&lt;h3 id=&#34;creating-the-application&#34;&gt;Creating the Application&lt;/h3&gt;

&lt;p&gt;Dozens of widgets are available for use in your programs. For our application, I only used a few: filemenu, Optionmenu (a drop-down select box), LabEntry (a text box with related label), and NoteBook, for the configuration control.&lt;/p&gt;

&lt;p&gt;If you look through the source code, you will see the general outline of the way things are done in most pTk applications. First, I declare all the global structures that I will use. This is important, as they will need to be within the scope of the callback routines used. (See &lt;a href=&#34;http://localhost:1313/media/_pub_2001_03_gui/listing1.txt&#34;&gt;Listing 1&lt;/a&gt;.) I then declare a MAIN block for the program. (See &lt;a href=&#34;http://localhost:1313/media/_pub_2001_03_gui/listing2.txt&#34;&gt;Listing 2&lt;/a&gt;.) Within the main program, we first create the main window ($mainwindow). Every widget will attach (at some level) to this window:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$mainwindow = MainWindow-&amp;gt;new();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nothing fancy here. It&amp;rsquo;s best to keep your handle in a global variable, as most of the program will need access to it.&lt;/p&gt;

&lt;h3 id=&#34;creating-the-menubar&#34;&gt;Creating the MenuBar&lt;/h3&gt;

&lt;p&gt;We then create a frame for the menu bar. A frame keeps parts of the program together logically, and for geometry management, lays out your controls on the screen. If you&amp;rsquo;ve used Java, the concept will be familiar. Before a widget can be seen on the screen, you must call a manager to lay it out for you. Each frame can only have one type of manager for its widgets; however, each frame can have multiple frames, making possible quite complex schemes.&lt;/p&gt;

&lt;p&gt;The $menubar consists of a single menu button, $filemenu. Of course, more are possible in larger applications. Attached to $filemenu are the commands you will see in the drop-downs, each specifying the label and a command (that is, a bound subroutine.) Additional options within the menu bar widget allow you to attach colors, checkboxes, and hotkeys to the menu items, as well.&lt;/p&gt;

&lt;p&gt;Menus under pTk are lists of actions with associated commands, usually contained within a frame. First, you need to create the menu bar frame:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$menubar = 
 $mainwindow-&amp;gt;Frame()-&amp;gt;pack(-side =&amp;gt; &#39;top&#39;, -fill =&amp;gt; &#39;x&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After creating the frame, we&amp;rsquo;ll add one button to it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $filemenu = $menubar-&amp;gt;Menubutton(-text =&amp;gt; &#39;File&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Multiple top-level items would be added the same way. Now we need to add a few commands to the menu:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$filemenu-&amp;gt;command( -label  =&amp;gt; &#39;Open Config&#39;,
                 -command =&amp;gt; \&amp;amp;loadConfig );
$filemenu-&amp;gt;command( -label  =&amp;gt; &#39;Save Config&#39;,
                 -command =&amp;gt; \&amp;amp;saveConfig );
$filemenu-&amp;gt;separator();
$filemenu-&amp;gt;command(-label  =&amp;gt; &#39;Configuration...&#39;,
                 -command =&amp;gt; \&amp;amp;doConfig );
$filemenu-&amp;gt;separator();
$filemenu-&amp;gt;command(-label =&amp;gt; &#39;Exit&#39;, -command =&amp;gt; sub {exit;} );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note the way commands are bound to the widgets. Whenever a user selects an item, the bound command is executed.&lt;/p&gt;

&lt;h3 id=&#34;building-the-main-window&#34;&gt;Building the Main Window&lt;/h3&gt;

&lt;p&gt;Within the main window, I&amp;rsquo;ve added three additional frames in addition to the menu bar: one on the left, for data input; one on the right, for data output; and the third on the bottom for status lines and the &amp;ldquo;Process Transaction&amp;rdquo; buttons.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $left  = $mainwindow-&amp;gt;Frame-&amp;gt;grid(-row =&amp;gt; 1,
                    -col =&amp;gt; 0,
                    -sticky =&amp;gt; &#39;nw&#39;);
my $right = $mainwindow-&amp;gt;Frame-&amp;gt;grid(-row =&amp;gt; 1,
                    -col =&amp;gt; 1,
                    -sticky =&amp;gt; &#39;nw&#39;);
my $bottom = $mainwindow-&amp;gt;Frame-&amp;gt;grid(-row =&amp;gt; 2,
                    -col =&amp;gt; 0,
                    -columnspan =&amp;gt; 3,
                    -sticky =&amp;gt; &#39;nw&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The left frame is first populated with a drop-down list (called an Optionmenu), with the various transaction types available:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$left-&amp;gt;Optionmenu(
        -options =&amp;gt; \@trxtype,
        -variable =&amp;gt; \$trans-&amp;gt;{TRXTYPE},
        )-&amp;gt;pack(-side =&amp;gt; &amp;quot;top&amp;quot;, -anchor =&amp;gt; &amp;quot;nw&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The -options parameter is a reference to an array (defined globally; refer to &lt;a href=&#34;http://localhost:1313/media/_pub_2001_03_gui/listing1.txt&#34;&gt;Listing 1&lt;/a&gt;) of accepted transaction types. We&amp;rsquo;ve seen this before when talking about bound variables. Remember that the variable $trans-&amp;gt;{TRXTYPE} will always reflect the state of the Optionmenu, and we can change the current selected item programmatically by simply reassigning a value to the bound variable. We also create an Optionmenu for the card-type; however, it isn&amp;rsquo;t used in the current implementation. The card type can be determined from the actual card number, so isn&amp;rsquo;t really required except that users are used to having it available.&lt;/p&gt;

&lt;p&gt;We then populate the rest of the frame with LabEntry widgets. These little gizmos are fantastic, housing commonly used labels, entry fields, and bound variables in one convenient widget.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$left-&amp;gt;LabEntry(-label =&amp;gt; &amp;quot;Name&amp;quot;,
   -labelPack =&amp;gt; [-side =&amp;gt; &amp;quot;right&amp;quot;, -anchor =&amp;gt; &amp;quot;w&amp;quot;],
   -width =&amp;gt; 20,
   -textvariable =&amp;gt; \$trans-&amp;gt;{_NAME})-&amp;gt;pack(-side =&amp;gt; &amp;quot;top&amp;quot;, 
   -anchor =&amp;gt; &#39;nw&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Like every other widget, you must call the geometry manager to make it visible. It is also pretty obvious that the LabEntry widget is calling its own geometry manager behind the scenes for us.&lt;/p&gt;

&lt;p&gt;The right-hand frame is populated with a series of Label widgets for displaying the output of the transaction. Note the grid manager used to place the labels in a column. I&amp;rsquo;ve also made sure to bind the second Label in each row to a variable, to be used for updating the state of the transaction later.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$right-&amp;gt;Label(-text =&amp;gt; &#39;PNRef&#39;)-&amp;gt;
        grid(-row =&amp;gt; 0, -column =&amp;gt; 0,-sticky =&amp;gt; &#39;nw&#39;);
$right-&amp;gt;Label(-textvariable =&amp;gt; \$results-&amp;gt;{PNREF})-&amp;gt;
        grid(-row =&amp;gt; 0, -column =&amp;gt; 1,-sticky =&amp;gt; &#39;nw&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The bottom frame is no more complicated, and consists of only three widgets: two LabEntry widgets for showing the state of the transaction (both sent and received) and a button to actually perform the processing.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$bottom-&amp;gt;Button(-text =&amp;gt; &#39;Process Transaction&#39;,
         -command =&amp;gt; \&amp;amp;processTransaction )-&amp;gt;
         grid(qw/-row 2 -column 0 -sticky nesw/);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The button is bound to the processTransaction routine, which is straightforward. (See &lt;a href=&#34;http://localhost:1313/media/_pub_2001_03_gui/listing3.txt&#34;&gt;Listing 3&lt;/a&gt;.) The only thing left to do is to start the event processing, which should look familiar by this time:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MainLoop();  # Start the event processing
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;saving-and-loading-the-configuration&#34;&gt;Saving and Loading the Configuration&lt;/h3&gt;

&lt;p&gt;The system binds &amp;ldquo;File | Open Config&amp;rdquo; and &amp;ldquo;File | Save Config&amp;rdquo; to the loadConfig() and saveConfig() subroutines, respectively. To configure the file dialog boxes, each routine needs a list of the file types to accept:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my @types = ([&amp;quot;Config Files&amp;quot;, &#39;.pcg&#39;, &#39;TEXT&#39;],
       [&amp;quot;All Files&amp;quot;, &amp;quot;*&amp;quot;] );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This creates the standard &amp;ldquo;Save As&amp;rdquo; dialog box. (See Figure 1.) You can add as many file types as you&amp;rsquo;d like. To actually execute the dialog, simply call getSaveFile:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $file = $mainwindow-&amp;gt;getSaveFile(-filetypes =&amp;gt; \@types,
      -initialfile=&amp;gt; &#39;Default&#39;,
      -defaultextension =&amp;gt; &#39;.pcg&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2001_03_gui/fig3.jpg&#34; alt=&#34;Figure 3: The Save As dialog.&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Figure 3: The Save As dialog.&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;You can specify the initial file name for the dialog, as shown above. The name of the file the user selected is returned, or an undef value if the &amp;ldquo;cancel&amp;rdquo; button was pressed. If the file exists, a second confirmation dialog (&amp;ldquo;Are you sure you want to overwrite?&amp;rdquo;) is executed. Only if the user answers affirmatively will the filename be returned. Using the Open dialog is similar, just call getOpenFile instead of getSaveFile.&lt;/p&gt;

&lt;p&gt;Once we have the filename, we can then save and load the configuration. We are using an extremely simple file format, basically a mini-Perl program, thanks to the Data::Dumper module. This is where the interpreted nature of Perl shines. To write out the file, we open it, print the text provided by Dumper, and then close it. Reading it back in is simple as well. Slurp up the file, and then use the eval function to interpret the file. Be aware that this format stores all configuration information in plain text on the user&amp;rsquo;s drive, so it may not be suitable for use in an open environment.&lt;/p&gt;

&lt;h3 id=&#34;the-configuration-dialog&#34;&gt;The Configuration Dialog&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2001_03_gui/fig4.jpg&#34; alt=&#34;Figure 4: The Configuration dialog&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Figure 4: The Configuration dialog&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;One really cool widget in the pTk system is the NoteBook (see Figure 4). I&amp;rsquo;ve used it to implement the simple configuration dialog bound to the &amp;ldquo;File | Configuration&amp;rdquo; menu item. The doConfig() callback subroutine actually implements the system. The strategy is to create a structure ($config) to hold all the relevant information. Within doConfig, we first copy this structure to a local structure, so that changes won&amp;rsquo;t be saved if the user selects &amp;ldquo;Cancel&amp;rdquo; when editing the fields. To create the actual dialog, we ask $mainwindow to do it for us:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$f = $mainwindow-&amp;gt;DialogBox(-title =&amp;gt; &amp;quot;Configuration&amp;quot;, 
              -buttons =&amp;gt; [&amp;quot;OK&amp;quot;, &amp;quot;Cancel&amp;quot;]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To add the NoteBook widget to the DialogBox (which is really just a fancy Frame), use:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$n = $f-&amp;gt;add(&#39;NoteBook&#39;, -ipadx=&amp;gt;6, -ipady =&amp;gt; 6) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The -ipad options tell the system how much internal padding to leave around the widgets contained within the box. To actually use the NoteBook, you must now add pages to it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $vendor_p = $n-&amp;gt;add(&amp;quot;vendor&amp;quot;, 
         -label =&amp;gt; &amp;quot;Vendor ID&amp;quot;, -underline =&amp;gt; 0);
my $host_p  = $n-&amp;gt;add(&amp;quot;host&amp;quot;, 
         -label =&amp;gt; &amp;quot;Host&amp;quot;, -underline =&amp;gt; 0); 
my $proxy_p = $n-&amp;gt;add(&amp;quot;proxy&amp;quot;, 
         -label =&amp;gt; &amp;quot;Proxy&amp;quot;, -underline =&amp;gt; 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This adds our three pages, named &amp;ldquo;vendor,&amp;rdquo; &amp;ldquo;host,&amp;rdquo; and &amp;ldquo;proxy.&amp;rdquo; You can treat each page as a regular frame within your dialog. The rest of the method&amp;rsquo;s code sets up the entry boxes we need:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$host_p-&amp;gt;LabEntry(-label =&amp;gt; &amp;quot;Port:       &amp;quot;, 
         -labelPack =&amp;gt; [-side =&amp;gt; &amp;quot;left&amp;quot;, 
         -anchor =&amp;gt; &amp;quot;w&amp;quot;], 
         -width =&amp;gt; 20, 
         -textvariable =&amp;gt; 
         \$localconfig-&amp;gt;{PORT})-&amp;gt;pack(-side =&amp;gt; &amp;quot;top&amp;quot;,
         -anchor =&amp;gt; &amp;quot;nw&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, we use the LabEntry widget to make a labeled text-entry box. To execute the dialog, once it&amp;rsquo;s set up, is a one liner:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$return = $f-&amp;gt;show;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The return value is the text of the button that the user pressed to end the dialog. If the result matches, we can then copy our temporary variables back to the $config array, effectively updating our configuration.&lt;/p&gt;

&lt;h3 id=&#34;using-the-system&#34;&gt;Using the System&lt;/h3&gt;

&lt;p&gt;That just about covers the example program, which is available electronically in the listings archive for this issue. To run the program under Windows, double-click on the file name (&lt;a href=&#34;http://localhost:1313/media/_pub_2001_03_gui/ptkpos.pl.txt&#34;&gt;ptkpos.pl&lt;/a&gt;) from Windows Explorer. The ActiveState installation program for Windows associates the .pl extension to Perl by default and runs the Perl interpreter when you double click on a .pl file. Under Linux, you first need to make the program executable.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chmod +x ptkpos.pl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can then use the K file manager and click on the program, or execute it from the command line directly.&lt;/p&gt;

&lt;h3 id=&#34;live-online-credit-card-authorizations&#34;&gt;Live Online Credit Card Authorizations&lt;/h3&gt;

&lt;p&gt;The virtual terminal presented here is using a &amp;ldquo;stub&amp;rdquo; simulation module to do credit-card authorizations. This module simulates the transaction process by providing data that you could expect to receive if you were to send the data to a real validation system. The simulator is very basic: It does no checking on vendor ID / password, card expiration date or even ensuring that all required information is available. It does, however, check to see if the credit card could be a valid card: if so, it returns an authorization code, otherwise it will be declined. Any simulator declines any transaction type other than an &amp;ldquo;authorization&amp;rdquo; or a &amp;ldquo;sale.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;To use the application for real transactions, you must replace the stub with an active link to a real online gateway system. The program will automatically detect a file named call_pfpro.pl, re-evaluate it to replace the simulator, and transactions will then go to a real gateway.&lt;/p&gt;

&lt;p&gt;To configure the system, select File | Configuration from the menu bar. Fill in the User and Password fields as provided by PaymentNet, or leave it blank to use the simulator. For testing, leave test.paymentnet.com in the Host entry. Port 443 is the default and should never need to be changed. If you are processing transactions from behind a firewall (always a good idea when doing electronic commerce) you need to set the Proxy settings. Consult the PaymentNet documentation for full details on how to do this.&lt;/p&gt;

&lt;p&gt;The application supports only a limited subset of the PaymentNet system. In particular, PaymentNet supports various forms of check processing. It should be possible to support other payment gateways relatively easily, though doing so is not currently planned.&lt;/p&gt;

&lt;p&gt;You can find more information (as well as the payment-transaction module) on how to do so at the Commerce-Store.com Web site, &lt;a href=&#34;http://www.commercestore.com/developers/VDM&#34;&gt;www.commercestore.com/developers/VDM&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;further-exploration&#34;&gt;Further Exploration&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ve looked at the pTk event model, a couple of the more common widgets, and as well as a slice of Internet-enabled electronic commerce. As Internet access becomes more common, tools that access the Net from a desktop can inexpensively replace more traditional systems, like leased-line or dial up credit-card terminals, as we&amp;rsquo;ve done here.&lt;/p&gt;

&lt;p&gt;There are quite a few exploration tools available for both Perl and pTk. I encourage you to take a look at some of the Web sites presented here, as well as the example programs that come with the distribution.&lt;/p&gt;

&lt;p&gt;Nick Temple is an entrepreneur who has recently relocated to Silicon Valley to pursue the startup dream. The founder of The Temple Group, Ltd. and CommerceStore.com, he welcomes open discussion directed to &lt;a href=&#34;mailto:ntemple@commercestore.com&#34;&gt;ntemple@commercestore.com&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;additional-information-not-part-of-original-article&#34;&gt;Additional information not part of original article:&lt;/h3&gt;

&lt;p&gt;Since the article was written, a number of things have changed in the online payments world. PaymentNet has changed their name to Signio, and then purchased by Verisign. You may know them now as &lt;a href=&#34;http://www.verisign.com/payments&#34;&gt;Verisign Payment Services&lt;/a&gt;. Here are instructions for &amp;ldquo;upgrading&amp;rdquo; the pTkPOS system presented in the article to handle live Internet transactions. Here are the steps that you will need to follow:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2001_03_gui/files.zip&#34;&gt;Download and install the source code to the article&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.verisign.com/products/payflow/trial.html&#34;&gt;Click here&lt;/a&gt; to register with Signio for a test account. It is free, and can be converted to a live account at a later date, if you so choose. This may take up to an hour to activate. &amp;lt;plug&amp;gt; Note that CommerceStore.com (my company) is a reseller for Verisign Payment Services, so if you wish to purchase the service I&amp;rsquo;d appreciate the business. &amp;lt;/plug&amp;gt;&lt;/li&gt;
&lt;li&gt;Download the latest version 2of the VPS client. You must log into your VPS manager at &lt;a href=&#34;https://manager.signio.com&#34;&gt;https://manager.signio.com&lt;/a&gt;. You will need to install pfpro.exe (for NT) or pfpro (for Linux) into the same directory as the article source code.&lt;/li&gt;
&lt;li&gt;Copy &amp;amp; paste the call_pfpro.pl code below into a file named call_pfpro.pl, in the same directory that you&amp;rsquo;ve installed the articles source code. Modify line 7 by changing it to the full path name of your pfpro binary.&lt;/li&gt;
&lt;li&gt;Follow the instructions in the article to install &amp;amp; configure Perl and the application. If you don&amp;rsquo;t have a copy of the magazine, it can be found at your favorite magazine retailer. The complete text will be made available online late January, 2000. If you cannot find the magazine at your local retailer, please e-mail support@commercestore.com so that we can set you up with one.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Perl/Tk Tutorial</title>
      <link>http://localhost:1313/pub/1999/10/perltk/index.html/</link>
      <pubDate>Fri, 15 Oct 1999 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/1999/10/perltk/index.html/</guid>
      <description>&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Table of Contents&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;• &lt;a href=&#34;http://localhost:1313/media/_pub_1999_10_perltk_index/sld001.htm&#34;&gt;Essential Perl/Tk Programming&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/media/_pub_1999_10_perltk_index/sld002.htm&#34;&gt;A Graphic Authorizing Example&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/media/_pub_1999_10_perltk_index/sld003.htm&#34;&gt;TK Overview&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/media/_pub_1999_10_perltk_index/sld004.htm&#34;&gt;A Pay Calculator Example&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/media/_pub_1999_10_perltk_index/sld005.htm&#34;&gt;Creating A Window&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/media/_pub_1999_10_perltk_index/sld006.htm&#34;&gt;Adding A Menubar&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/media/_pub_1999_10_perltk_index/sld007.htm&#34;&gt;Adding Choices To A Menubar&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/media/_pub_1999_10_perltk_index/sld008.htm&#34;&gt;More Menubar Choices&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/media/_pub_1999_10_perltk_index/sld009.htm&#34;&gt;Adding Frames To A Window&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/media/_pub_1999_10_perltk_index/sld010.htm&#34;&gt;Adding Labels To A Frame&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/media/_pub_1999_10_perltk_index/sld011.htm&#34;&gt;Labels For Display Purposes&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/media/_pub_1999_10_perltk_index/sld012.htm&#34;&gt;More Display Labels&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/media/_pub_1999_10_perltk_index/sld013.htm&#34;&gt;One More Set&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/media/_pub_1999_10_perltk_index/sld014.htm&#34;&gt;Adding A Widget Separator&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/media/_pub_1999_10_perltk_index/sld015.htm&#34;&gt;Add Descriptive Labels&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/media/_pub_1999_10_perltk_index/sld016.htm&#34;&gt;Adding Text Entry Boxes&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/media/_pub_1999_10_perltk_index/sld017.htm&#34;&gt;Adding Functional Buttons&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/media/_pub_1999_10_perltk_index/sld018.htm&#34;&gt;Adding A Checkbox&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/media/_pub_1999_10_perltk_index/sld019.htm&#34;&gt;Initial Window Placement&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/media/_pub_1999_10_perltk_index/sld020.htm&#34;&gt;Radiobutton Example&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/media/_pub_1999_10_perltk_index/sld021.htm&#34;&gt;Creating A Window&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/media/_pub_1999_10_perltk_index/sld022.htm&#34;&gt;Adding Frames To A Window&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/media/_pub_1999_10_perltk_index/sld023.htm&#34;&gt;Adding A Status Display Area&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/media/_pub_1999_10_perltk_index/sld024.htm&#34;&gt;Adding Radiobuttons&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/media/_pub_1999_10_perltk_index/sld025.htm&#34;&gt;Adding An EXIT Button&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/media/_pub_1999_10_perltk_index/sld026.htm&#34;&gt;Radiobutton Graphic Examples&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/media/_pub_1999_10_perltk_index/sld027.htm&#34;&gt;Increment &amp;amp; Decrement: A Date Example&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/media/_pub_1999_10_perltk_index/sld028.htm&#34;&gt;Adding A Window And Frame&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/media/_pub_1999_10_perltk_index/sld029.htm&#34;&gt;Adding Buttons And Text Label&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/media/_pub_1999_10_perltk_index/sld030.htm&#34;&gt;Displaying Current Date&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/media/_pub_1999_10_perltk_index/sld031.htm&#34;&gt;Date Changing Graphic Examples&lt;/a&gt;&lt;br /&gt;
&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;This presentation was created for a meeting of AZSage (see &lt;a href=&#34;http://www.azsage.org&#34;&gt;http://www.azsage.org&lt;/a&gt;). &amp;ldquo;I had been attending monthly AZSage meetings for over a year,&amp;rdquo; said Brett Berry, &amp;ldquo;and finally I had something worth presenting. The presentation was aimed at the Perl/Tk novice, and there was a whole lot of ad-lib comedy to keep the mood light, and the people awake!&amp;rdquo;&lt;/p&gt;

&lt;p&gt;On Perl.com, we are presenting this as part of what we hope will be an ongoing series of articles, titled &amp;ldquo;Source Illustrated.&amp;rdquo; The presentation by Lee and Brett is a wonderfully concise example of showing annotated code and its result. There&amp;rsquo;s no running narrative; just a code-walkthrough that is a very interesting way to learn how these examples work.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_1999_10_perltk_index/sld001.htm&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_10_perltk_index/illustration.gif&#34; alt=&#34;click to load illustration&#34; width=&#34;100&#34; height=&#34;50&#34; /&gt;&lt;/a&gt;
&lt;em&gt;Lee Minniear and Brett Berry are in business together, offering the world Business Card CDs and such. Visit them at &lt;a href=&#34;http://www.SculptedCD.com&#34;&gt;SculptedCD.com&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

