<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Testing on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/categories/testing/</link>
    <description>Recent content in Testing on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 12 Jun 2018 15:26:40 +0000</lastBuildDate>
    <atom:link href="/categories/testing/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Writing new testing tools with Test2</title>
      <link>http://localhost:1313/article/writing-new-testing-tools-with-test2/</link>
      <pubDate>Tue, 12 Jun 2018 15:26:40 +0000</pubDate>
      
      <guid>http://localhost:1313/article/writing-new-testing-tools-with-test2/</guid>
      <description>

&lt;p&gt;Perl has had great testing tools for a long time, but &lt;a href=&#34;https://metacpan.org/pod/Test2&#34;&gt;Test2&lt;/a&gt; is the single biggest improvement to Perl testing in years. One of my favorite Test2 features is how easy it is to extend it with new tools, and today I&amp;rsquo;ll show you how I wrote my first tool.&lt;/p&gt;

&lt;h3 id=&#34;dealing-with-known-test-failures&#34;&gt;Dealing with known test failures&lt;/h3&gt;

&lt;p&gt;Ideally when your tests fail, it means that something needs to be fixed, and that thing is fixable. However in the Real Worldâ„¢ things aren&amp;rsquo;t always that simple. For example you might investigate a failure, figure out the root cause, but the person to fix it is on vacation. Or perhaps there&amp;rsquo;s a datetime bug in the code, and it will resolve itself in a few days. The key here is that the failure is understood and not serious but also impractical to fix in the short term.&lt;/p&gt;

&lt;p&gt;I found myself in exactly this situation a few months ago. I didn&amp;rsquo;t want to skip the failing test, as I thought it might be forgotten, but I also wanted the build to complete in the meantime. In large distributed development teams, you want successful builds to be &amp;ldquo;the norm&amp;rdquo;, so when a build fails, developers take notice.&lt;/p&gt;

&lt;p&gt;I decided what I needed was a &lt;code&gt;skip_until&lt;/code&gt; function that would skip the test until a date was reached, at which point it would start failing again. Not finding anything on CPAN, I figured it was time for a new testing tool.&lt;/p&gt;

&lt;h3 id=&#34;test2-terminology-plugins-vs-tools&#34;&gt;Test2 terminology: plugins vs tools&lt;/h3&gt;

&lt;p&gt;In Test2, a &amp;ldquo;plugin&amp;rdquo; is a package which overrides the behavior of existing Test2 features, whereas a &amp;ldquo;tool&amp;rdquo; is a package which provides new functions. In this case I was creating a new testing function which didn&amp;rsquo;t already exist, so I needed to write a &lt;a href=&#34;https://metacpan.org/pod/Test2::Tools&#34;&gt;Test2::Tools&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;test2-api-context&#34;&gt;Test2::API context&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://metacpan.org/pod/Test2::API&#34;&gt;Test2::API&lt;/a&gt; provides the &lt;code&gt;context&lt;/code&gt; function to access the test context during runtime. The context object provides common test methods like &lt;code&gt;pass&lt;/code&gt;, &lt;code&gt;fail&lt;/code&gt; and &lt;code&gt;skip&lt;/code&gt; etc, which let&amp;rsquo;s you add custom test behavior. Here&amp;rsquo;s how I use it to skip tests:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;package&lt;/span&gt; Test2::Tools::SkipUntil;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Test2::API &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;context&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Exporter &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;import&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;our&lt;/span&gt; @EXPORT_OK &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;skip_until&amp;#39;&lt;/span&gt;);

&lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;skip_until&lt;/span&gt; {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; ($reason, $count, $date) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; @_;

  &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;

  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ($should_skip) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $ctx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; context();
    $ctx&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;skip(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;skipped test&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;$reason skip until $date&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;$count);
    $ctx&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;release;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;no&lt;/span&gt; warnings &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;exiting&amp;#39;&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;last&lt;/span&gt; SKIP;
  }
}
&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I declare a new function called &lt;code&gt;skip_until&lt;/code&gt; which accepts a text reason to skip, a count of tests to skip and a date. This signature is the same as &lt;a href=&#34;Test2::Tools::Basic::skip&#34;&gt;skip&lt;/a&gt;, with the extra date parameter (I don&amp;rsquo;t love the parameter order but I figure it&amp;rsquo;s better to remain similar to prior art).&lt;/p&gt;

&lt;p&gt;For the sake of brevity I&amp;rsquo;ve omitted the argument checking code and the date time logic to decide whether &lt;code&gt;$should_skip&lt;/code&gt; is true or not. If it is, the main &lt;code&gt;if&lt;/code&gt; block obtains the test context, and calls &lt;code&gt;skip&lt;/code&gt; for the count of tests to skip. Next it calls &lt;code&gt;release&lt;/code&gt; to free the test context (&lt;a href=&#34;https://metacpan.org/pod/Test2::API::Context#CRITICAL-DETAILS&#34;&gt;important!&lt;/a&gt;). Finally it calls &lt;code&gt;last&lt;/code&gt; to exit the SKIP block that &lt;code&gt;skip_until&lt;/code&gt; would be called from.&lt;/p&gt;

&lt;p&gt;Careful readers might notice that the use of &lt;code&gt;SKIP&lt;/code&gt; means &lt;code&gt;$count&lt;/code&gt; can be 1, and all tests within the skip block will still be skipped. This is the same as the Test2 behavior, in fact that code is almost identical to the Test2::Tools::Basic &lt;a href=&#34;https://metacpan.org/source/EXODIST/Test2-Suite-0.000114/lib/Test2/Tools/Basic.pm#L67&#34;&gt;source&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;using-the-new-tool&#34;&gt;Using the new tool&lt;/h3&gt;

&lt;p&gt;Now if I import &lt;code&gt;Test2::Tools::SkipUntil&lt;/code&gt; in my tests I  can use it like any other module:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#!/usr/bin/perl&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Test2::Tools::Basic;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Test2::Tools::SkipUntil &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;skip_until&amp;#39;&lt;/span&gt;;

SKIP:{
  skip_until &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;This should be fixed next month, see ticket #529&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2018-06-30&amp;#39;&lt;/span&gt;;

  ok foo();
  &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
}

done_testing;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And the tests will be skipped until the date is reached. Test2 makes writing new testing tools easy, if you have a good idea for a new testing function, consider using Test2.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Test2::Tools&#34;&gt;Test2::Tools&lt;/a&gt; is the Test2 documentation for Test2 tools&lt;/li&gt;
&lt;li&gt;For plugins see &lt;a href=&#34;https://metacpan.org/pod/Test2::Plugin&#34;&gt;Test2::Plugin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Test2::API&#34;&gt;Test2::API&lt;/a&gt; is used to get the test context object, see the context &lt;a href=&#34;https://metacpan.org/pod/Test2::API::Context#CRITICAL-DETAILS&#34;&gt;cardinal rules&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Test2::Tools::SkipUntil&#34;&gt;Test2::Tools::SkipUntil&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
Cover image via &lt;a href=&#34;https://pixabay.com/p-762486/&#34;&gt;pixabay&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Save time with compile tests</title>
      <link>http://localhost:1313/article/208/2016/1/5/Save-time-with-compile-tests/</link>
      <pubDate>Tue, 05 Jan 2016 14:32:45 +0000</pubDate>
      
      <guid>http://localhost:1313/article/208/2016/1/5/Save-time-with-compile-tests/</guid>
      <description>

&lt;p&gt;Over the past year I&amp;rsquo;ve been working on several large Perl projects, sometimes as part of a team and sometimes alone. As the codebase grows, testing becomes increasingly important and one test in particular that pays dividends is the compile test. That is, before running any other tests, simply check if that every module in the codebase compiles.&lt;/p&gt;

&lt;h3 id=&#34;the-basics&#34;&gt;The basics&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s look at a simple compile test, I&amp;rsquo;ve adapted this example from &lt;a href=&#34;https://github.com/dnmfarrell/Perly-Bot&#34;&gt;Perly-Bot&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#!/usr/bin/env perl&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Test::More;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; lib &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;lib&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @modules &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;qw(
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  Perly::Bot
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  Perly::Bot::Feed
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  Perly::Bot::Feed::Post
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  Perly::Bot::Cache
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  Perly::Bot::Media
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  Perly::Bot::Media::Twitter
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  Perly::Bot::Media::Reddit
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;)&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $module ( @modules )
{
  BAIL_OUT( &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;$module does not compile&amp;#34;&lt;/span&gt; ) &lt;span style=&#34;color:#66d9ef&#34;&gt;unless&lt;/span&gt; require_ok( $module );
}
done_testing();&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The code is simple enough; it adds the local &lt;code&gt;lib&lt;/code&gt; directory to the list of directories for Perl to search for modules. Then it declares an array of module names called &lt;code&gt;@modules&lt;/code&gt;. Finally it loops through each module name and tries to import it, bailing out if any module fails to load. Because tests are usually run in alphabetical order, this file is called &lt;code&gt;00-compile.t&lt;/code&gt; so that it is run first. I can run this test at the terminal:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;./&lt;/span&gt;t&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;compile&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;t
perl t&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;00&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;compile&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;t
ok &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Perly::Bot;
ok &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Perly::Bot::Feed;
ok &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Perly::Bot::Feed::Post;
ok &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Perly::Bot::Cache;
ok &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Perly::Bot::Media;
ok &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Perly::Bot::Media::Twitter;
ok &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Perly::Bot::Media::Reddit;
&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;write-once-compile-tests&#34;&gt;Write-once compile tests&lt;/h3&gt;

&lt;p&gt;The basic compile test example has an obvious flaw: it requires the programmer to list all the module names to be tested. This means that every time a new module is added to the codebase or a module is renamed, this test needs to be updated. This also introduces the risk of error - a failing module could exist in the codebase and never be tested. Instead of a static list of modules, I can tell Perl to search the &lt;code&gt;lib&lt;/code&gt; directory and try to import any module it finds:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#!/usr/bin/env perl&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Test::More;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; lib &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;lib&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Path::Tiny;

&lt;span style=&#34;color:#75715e&#34;&gt;# try to import every .pm file in /lib&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $dir &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; path(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;lib/&amp;#39;&lt;/span&gt;);
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $iter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; $dir&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;iterator({
            recurse         &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,
            follow_symlinks &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,
           });
&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $path &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; $iter&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;())
{
  &lt;span style=&#34;color:#66d9ef&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; $path&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;is_dir &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; $path &lt;span style=&#34;color:#f92672&#34;&gt;!~&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;/\.pm$/&lt;/span&gt;;
  BAIL_OUT( &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;$path does not compile&amp;#34;&lt;/span&gt; ) &lt;span style=&#34;color:#66d9ef&#34;&gt;unless&lt;/span&gt; require_ok( $path );
}
done_testing;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here I use &lt;a href=&#34;https://metacpan.org/pod/Path::Tiny&#34;&gt;Path::Tiny&lt;/a&gt; to iterate through the files in &lt;code&gt;lib&lt;/code&gt;. Instead of passing module names, I pass the filepath to &lt;code&gt;require_ok&lt;/code&gt;. Now this compile test is dynamic, it will always pick up any new modules added or removed from the codebase. Nice!&lt;/p&gt;

&lt;h3 id=&#34;require-warnings&#34;&gt;Require warnings&lt;/h3&gt;

&lt;p&gt;One problem with using &lt;a href=&#34;https://perldoc.perl.org/functions/require.html&#34;&gt;require&lt;/a&gt; to load filepaths instead of module names is that it can generate &amp;ldquo;subroutine redefined&amp;rdquo; warnings if the same module is loaded twice by different files. Imagine this code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;require&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;lib/Game.pm&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;require&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;lib/Game/Asset/Player.pm&amp;#39;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If &lt;code&gt;Game.pm&lt;/code&gt; loads &lt;code&gt;Game::Asset::Player&lt;/code&gt;, Perl will emit the subroutine redefined warning when the second &lt;code&gt;require&lt;/code&gt; statement is executed. I can deal with this in a couple of ways: I could suppress the warning by adding &lt;code&gt;no warnings &#39;redefine&#39;;&lt;/code&gt; to my compile test file. But this would mask genuine warnings that could be helpful, like if I have circular dependencies in my codebase. Or I can convert the filepath into a module name, and then &lt;code&gt;require&lt;/code&gt; won&amp;rsquo;t complain, for example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;require&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Game&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;require&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Game::Asset::Player&amp;#39;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For the compile tests, I can use substitute regexes to convert the filepath into a module name. When the compile tests run they won&amp;rsquo;t generate spurious &amp;ldquo;subroutine redefined&amp;rdquo; warnings.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#!/usr/bin/env perl&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Test::More;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; lib &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;lib&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Path::Tiny;

&lt;span style=&#34;color:#75715e&#34;&gt;# try to import every .pm file in /lib&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $dir &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; path(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;lib/&amp;#39;&lt;/span&gt;);
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $iter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; $dir&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;iterator({
            recurse         &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,
            follow_symlinks &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,
           });
&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $path &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; $iter&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;())
{
  &lt;span style=&#34;color:#66d9ef&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; $path&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;is_dir &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; $path &lt;span style=&#34;color:#f92672&#34;&gt;!~&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;/\.pm$/&lt;/span&gt;;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $module &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; $path&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;relative;
  $module &lt;span style=&#34;color:#f92672&#34;&gt;=~&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;s/(?:^lib\/|\.pm$)//g&lt;/span&gt;;
  $module &lt;span style=&#34;color:#f92672&#34;&gt;=~&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;s/\//::/g&lt;/span&gt;;
  BAIL_OUT( &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;$module does not compile&amp;#34;&lt;/span&gt; ) &lt;span style=&#34;color:#66d9ef&#34;&gt;unless&lt;/span&gt; require_ok( $module );
}
done_testing;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;additional-thoughts&#34;&gt;Additional thoughts&lt;/h3&gt;

&lt;p&gt;Another way to write compile tests is using &lt;a href=&#34;https://metacpan.org/pod/Class::Load&#34;&gt;Class::Load&lt;/a&gt; to do the module importing. It has a several useful functions for dynamically loading modules.&lt;/p&gt;

&lt;p&gt;Compile tests are an interesting class of test. They&amp;rsquo;re an implementation of the axiom: &amp;ldquo;the codebase should always compile&amp;rdquo;. Depending on the application, there are other axioms you can test for. For example with a web application, every admin URL should only be accessible to authenticated and authorized users. So you could write a dynamic test that enumerates every admin URL and attempts to fetch it unauthorized (the test fails if any request is successful). For testing Catalyst web applications, you might find my module &lt;a href=&#34;https://metacpan.org/pod/Catalyst::Plugin::ActionPaths&#34;&gt;Catalyst::Plugin::ActionPaths&lt;/a&gt; useful. Testing axioms usually has a high reward for little or no maintenance cost. Seek them out!&lt;/p&gt;

&lt;p&gt;If you ever need to suppress a particular warning, in newer versions of Perl the warnings pragma &lt;a href=&#34;https://perldoc.perl.org/warnings.html&#34;&gt;documentation&lt;/a&gt; lists all of the types of warnings it recognizes. This is especially useful when using experimental features like &lt;a href=&#34;http://perltricks.com/article/72/2014/2/24/Perl-levels-up-with-native-subroutine-signatures&#34;&gt;subroutine signatures&lt;/a&gt;. You can read it for your version of Perl at the command line with:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ perldoc warnings&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Check your DuckDuckGo cheatsheets with Perl</title>
      <link>http://localhost:1313/article/190/2015/8/28/Check-your-DuckDuckGo-cheatsheets-with-Perl/</link>
      <pubDate>Fri, 28 Aug 2015 02:10:48 +0000</pubDate>
      
      <guid>http://localhost:1313/article/190/2015/8/28/Check-your-DuckDuckGo-cheatsheets-with-Perl/</guid>
      <description>

&lt;p&gt;With DuckDuckGo&amp;rsquo;s global &lt;a href=&#34;https://duck.co/blog&#34;&gt;Quack &amp;amp; Hack&lt;/a&gt; just around the corner, I&amp;rsquo;ve pulled together a &lt;a href=&#34;https://github.com/dnmfarrell/DDG-cheatsheet-check&#34;&gt;script&lt;/a&gt; for checking &lt;a href=&#34;http://perltricks.com/article/189/2015/8/22/Writing-DuckDuckGo-plugins-just-got-easier&#34;&gt;cheatsheets&lt;/a&gt;. The script checks the cheatsheet is valid JSON and has the required entries and values.&lt;/p&gt;

&lt;h3 id=&#34;setup&#34;&gt;Setup&lt;/h3&gt;

&lt;p&gt;To run the script, download it from &lt;a href=&#34;https://github.com/dnmfarrell/DDG-cheatsheet-check/blob/master/cheatsheet_check&#34;&gt;Github&lt;/a&gt;. It requires the &lt;a href=&#34;https://metacpan.org/pod/JSON&#34;&gt;JSON&lt;/a&gt; and &lt;a href=&#34;https://metacpan.org/pod/HTTP::Tiny&#34;&gt;HTTP::Tiny&lt;/a&gt; Perl modules which you can install with &lt;code&gt;cpan&lt;/code&gt; at the terminal:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ cpan JSON HTTP::Tiny&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Be sure to give execute permissions to the script too:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ chmod &lt;span style=&#34;color:#ae81ff&#34;&gt;744&lt;/span&gt; cheatsheet_check&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;usage&#34;&gt;Usage&lt;/h3&gt;

&lt;p&gt;Once you have a cheatsheet in JSON that you want to check, just pass the filepath to &lt;code&gt;cheatsheet_check&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;./&lt;/span&gt;cheatsheet_check &lt;span style=&#34;color:#e6db74&#34;&gt;/path/&lt;/span&gt;to&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;cheatsheet&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;json&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Example output for the &lt;code&gt;perldoc&lt;/code&gt; cheatsheet:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Subtest: file
    ok 1 - file exists
    ok 2 - filename is appropriate
    ok 3 - file content can be read
    ok 4 - content is valid JSON
    1..4
ok 1 - file
    # Subtest: headers
    ok 1 - has id
    ok 2 - has name
    ok 3 - has description
    1..3
ok 2 - headers
    # Subtest: metadata
    ok 1 - has metadata
    ok 2 - has metadata sourceName
    ok 3 - has metadata sourceUrl
    ok 4 - sourceUrl is not undef
    ok 5 - fetch sourceUrl
    1..5
ok 3 - metadata
    # Subtest: sections
    ok 1 - has section_order
    ok 2 - section_order is an array of section names
    ok 3 - has sections
    ok 4 - sections is a hash of section key/pairs
    ok 5 - &#39;Usage&#39; exists in sections
    ok 6 - &#39;Module Options&#39; exists in sections
    ok 7 - &#39;Search Options&#39; exists in sections
    ok 8 - &#39;Common Options&#39; exists in sections
    ok 9 - &#39;Search Options&#39; exists in section_order
    ok 10 - &#39;Search Options&#39; is an array
    ok 11 - &#39;Search Options&#39; entry: 0 has a key
    ok 12 - &#39;Search Options&#39; entry: 0 has a val
    ok 13 - &#39;Search Options&#39; entry: 1 has a key
    ok 14 - &#39;Search Options&#39; entry: 1 has a val
    ok 15 - &#39;Search Options&#39; entry: 2 has a key
    ok 16 - &#39;Search Options&#39; entry: 2 has a val
    ok 17 - &#39;Common Options&#39; exists in section_order
    ok 18 - &#39;Common Options&#39; is an array
    ok 19 - &#39;Common Options&#39; entry: 0 has a key
    ok 20 - &#39;Common Options&#39; entry: 0 has a val
    ok 21 - &#39;Common Options&#39; entry: 1 has a key
    ok 22 - &#39;Common Options&#39; entry: 1 has a val
    ok 23 - &#39;Common Options&#39; entry: 2 has a key
    ok 24 - &#39;Common Options&#39; entry: 2 has a val
    ok 25 - &#39;Common Options&#39; entry: 3 has a key
    ok 26 - &#39;Common Options&#39; entry: 3 has a val
    ok 27 - &#39;Common Options&#39; entry: 4 has a key
    ok 28 - &#39;Common Options&#39; entry: 4 has a val
    ok 29 - &#39;Module Options&#39; exists in section_order
    ok 30 - &#39;Module Options&#39; is an array
    ok 31 - &#39;Module Options&#39; entry: 0 has a key
    ok 32 - &#39;Module Options&#39; entry: 0 has a val
    ok 33 - &#39;Module Options&#39; entry: 1 has a key
    ok 34 - &#39;Module Options&#39; entry: 1 has a val
    ok 35 - &#39;Module Options&#39; entry: 2 has a key
    ok 36 - &#39;Module Options&#39; entry: 2 has a val
    ok 37 - &#39;Module Options&#39; entry: 3 has a key
    ok 38 - &#39;Module Options&#39; entry: 3 has a val
    ok 39 - &#39;Usage&#39; exists in section_order
    ok 40 - &#39;Usage&#39; is an array
    ok 41 - &#39;Usage&#39; entry: 0 has a key
    ok 42 - &#39;Usage&#39; entry: 0 has a val
    ok 43 - &#39;Usage&#39; entry: 1 has a key
    ok 44 - &#39;Usage&#39; entry: 1 has a val
    1..44
ok 4 - sections
1..4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will run over 20 different tests against the cheatsheet. The script checks that the JSON is valid, that the required headers are present (e.g. id, name and description). It checks that the metadata is valid and points to a live URL. Finally it checks that the sections are valid and correctly mapped.&lt;/p&gt;

&lt;h3 id=&#34;wrap-up&#34;&gt;Wrap up&lt;/h3&gt;

&lt;p&gt;Remember, even if the cheatsheet passes all the tests, you still need to check it looks right in the browser. &lt;a href=&#34;https://metacpan.org/pod/App::DuckPAN&#34;&gt;App::DuckPAN&lt;/a&gt; can help with that. This Saturday I&amp;rsquo;ll be hanging out at the NYC Quack &amp;amp; Hack at &lt;a href=&#34;http://www.meetup.com/Quack-Hack-New-York-City/events/224567174/&#34;&gt;Orbital&lt;/a&gt;. I look forward to seeing everyone there!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; added HTTP::Tiny dependency. 2015-08-28&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Separate data and behavior with table-driven testing</title>
      <link>http://localhost:1313/article/178/2015/6/17/Separate-data-and-behavior-with-table-driven-testing/</link>
      <pubDate>Wed, 17 Jun 2015 13:09:04 +0000</pubDate>
      
      <guid>http://localhost:1313/article/178/2015/6/17/Separate-data-and-behavior-with-table-driven-testing/</guid>
      <description>&lt;p&gt;How can I easily run the same tests on different data without duplicating a lot of code? If I follow my usual pattern, I start off with a couple of tests where I write some code then cut-and-paste that a couple of times. I add a few more tests before I realize I have a mess. If I had the foresight to know that I would make a mess (again), I would have started with a table of data and a little bit of code that went through it.&lt;/p&gt;

&lt;p&gt;Consider a silly and small example of testing &lt;code&gt;sprintf&lt;/code&gt;-like behavior of &lt;a href=&#34;https://metacpan.org/pod/String::Sprintf&#34;&gt;String::Sprintf&lt;/a&gt;. I can use this module to create my own format specifiers, such as one to commify a number. I stole this mostly from its documentation, although I threw in the &lt;a href=&#34;http://www.effectiveperlprogramming.com/2015/04/use-v5-20-subroutine-signatures/&#34;&gt;v5.20 signatures feature&lt;/a&gt; and the &lt;a href=&#34;http://www.effectiveperlprogramming.com/2010/09/use-the-r-substitution-flag-to-work-on-a-copy/&#34;&gt;v5.14 non-destructive substitution operator&lt;/a&gt; because I love those features:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; v5&lt;span style=&#34;color:#ae81ff&#34;&gt;.20&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; feature &lt;span style=&#34;color:#e6db74&#34;&gt;qw(signatures)&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;no&lt;/span&gt; warnings &lt;span style=&#34;color:#e6db74&#34;&gt;qw(experimental::signatures)&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; String::Sprintf;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $f &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; String::Sprintf&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;formatter(
  N &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt;($width, $value, $values, $letter) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; @_;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; commify(sprintf &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%${width}f&amp;#34;&lt;/span&gt;, $value);
  });

say &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Numbers are: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt; 
  $f&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;sprintf(
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;%10.2N, %10.2N&amp;#39;&lt;/span&gt;, 
    &lt;span style=&#34;color:#ae81ff&#34;&gt;12345678.901&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;87654.321&lt;/span&gt;
  );

&lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;commify&lt;/span&gt; ( $n ) {
  $n &lt;span style=&#34;color:#f92672&#34;&gt;=~&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;s/(\.\d+)|(?&amp;lt;=\d)(?=(?:\d\d\d)+\b)/$1 || &amp;#39;,&amp;#39;/&lt;/span&gt;rge;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Numbers are: 12,345,678.90,   87,654.32
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The mess I might make to test this starts with a single input and output with the &lt;a href=&#34;https://metacpan.org/pod/Test::More&#34;&gt;Test::More&lt;/a&gt; function &lt;code&gt;is&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; v5&lt;span style=&#34;color:#ae81ff&#34;&gt;.20&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; feature &lt;span style=&#34;color:#e6db74&#34;&gt;qw(signatures)&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;no&lt;/span&gt; warnings &lt;span style=&#34;color:#e6db74&#34;&gt;qw(experimental::signatures)&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Test::More;
    
&lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;commify&lt;/span&gt; ( $n ) {
  $n &lt;span style=&#34;color:#f92672&#34;&gt;=~&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;s/(\.\d+)|(?&amp;lt;=\d)(?=(?:\d\d\d)+\b)/$1 || &amp;#39;,&amp;#39;/&lt;/span&gt;rge;
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $class &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;String::Sprintf&amp;#39;&lt;/span&gt;;  
use_ok( $class );
    
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $f &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; String::Sprintf&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;formatter(
  N &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt;($width, $value, $values, $letter) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; @_;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; commify(sprintf &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%${width}f&amp;#34;&lt;/span&gt;, $value);
  });
    
isa_ok(  $f, $class );
can_ok( $f, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;sprintf&amp;#39;&lt;/span&gt; );

is(  $f&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;sprintf( &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;%.2N&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;1234.56&amp;#39;&lt;/span&gt; ), &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;1,234.56&amp;#39;&lt;/span&gt; );

done_testing();&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I decide to test another value, and I think the easiest thing to do is to duplicate that line with &lt;code&gt;is&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;is(  $f&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;sprintf( &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;%.2N&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;1234.56&amp;#39;&lt;/span&gt; ), &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;1,234.56&amp;#39;&lt;/span&gt; );
is(  $f&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;sprintf( &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;%.2N&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;1234&amp;#39;&lt;/span&gt; ),    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;1,234.00&amp;#39;&lt;/span&gt; );&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The particular thing to test isn&amp;rsquo;t the point of this article. It&amp;rsquo;s all the stuff around it that I want to highlight. Or, more correctly, I want to de-emphasize all this stuff around it. I had to duplicate the test although most of the structure is the same.&lt;/p&gt;

&lt;p&gt;I can convert those tests to a structure to hold the data and another structure for the behavior:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (
    [ ( &lt;span style=&#34;color:#ae81ff&#34;&gt;1234.56&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;1,234.56&amp;#39;&lt;/span&gt; ) ],
    [ ( &lt;span style=&#34;color:#ae81ff&#34;&gt;1234&lt;/span&gt;,    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;1,234.00&amp;#39;&lt;/span&gt; ) ],
);

&lt;span style=&#34;color:#66d9ef&#34;&gt;foreach&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $row ( @data ) {
  is(  $f&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;sprintf( &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;%.2N&amp;#39;&lt;/span&gt;, $row&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] ), $row&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] );
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I can add many more rows to &lt;code&gt;@data&lt;/code&gt; but the meat of the code, that &lt;code&gt;foreach&lt;/code&gt; loop, doesn&amp;rsquo;t change.&lt;/p&gt;

&lt;p&gt;I can improve this though. So far I only test that one &lt;code&gt;sprintf&lt;/code&gt; template. I can add that to &lt;code&gt;@data&lt;/code&gt; too, and use that to make a label for the test:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $ndot2_f &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;%.2N&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (
    [ $ndot2_f,( &lt;span style=&#34;color:#ae81ff&#34;&gt;1234.56&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;1,234.56&amp;#39;&lt;/span&gt; ) ],
    [ $ndot2_f, ( &lt;span style=&#34;color:#ae81ff&#34;&gt;1234&lt;/span&gt;,    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;1,234.00&amp;#39;&lt;/span&gt; ) ],
);

&lt;span style=&#34;color:#66d9ef&#34;&gt;foreach&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $row ( @data ) {
  is( $f&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;sprintf( $row&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;], $row&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] ), $row&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;],
       &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;$row-&amp;gt;[1] with format $row-&amp;gt;[0] returns $row-&amp;gt;[2]&amp;#34;&lt;/span&gt;
   );
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I can add another test with a different format. If I had kept going the way I started, this would look like a new test because the format changed. Now the format is just part of the input:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $ndot2_f &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;%.2N&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (
    [ $ndot2_f, ( &lt;span style=&#34;color:#ae81ff&#34;&gt;1234.56&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;1,234.56&amp;#39;&lt;/span&gt; ) ],
    [ $ndot2_f, ( &lt;span style=&#34;color:#ae81ff&#34;&gt;1234&lt;/span&gt;,    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;1,234.00&amp;#39;&lt;/span&gt; ) ],
    [ &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;%.0N&amp;#39;&lt;/span&gt;  , ( &lt;span style=&#34;color:#ae81ff&#34;&gt;1234.49&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;1,234&amp;#39;&lt;/span&gt;    ) ],
);

&lt;span style=&#34;color:#66d9ef&#34;&gt;foreach&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $row ( @data ) {
  is( $f&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;sprintf( $row&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;], $row&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] ), $row&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;],
       &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;$row-&amp;gt;[1] with format $row-&amp;gt;[0] returns $row-&amp;gt;[2]&amp;#34;&lt;/span&gt;
  );
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As I go on things get more complicated. If a test fails, I want some extra information about which one failed. I&amp;rsquo;ll change up how I go through the table. In this case, I&amp;rsquo;ll use the &lt;a href=&#34;http://www.effectiveperlprogramming.com/2010/05/perl-5-12-lets-you-use-each-on-an-array/&#34;&gt;v5.12 feature&lt;/a&gt; that allows &lt;code&gt;each&lt;/code&gt; on an array so I get back the index and the value:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;( &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt;( $index, $row ) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; each @data ) {
  is( $f&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;sprintf( $row&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;], $row&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] ), $row&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;],
       &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;$index: $row-&amp;gt;[1] with format $row-&amp;gt;[0] returns $row-&amp;gt;[2]&amp;#34;&lt;/span&gt;
  );
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;My code for the test behavior changed but I didn&amp;rsquo;t have to mess with the input data at all. The particular code in this case doesn&amp;rsquo;t matter. This table-driven testing separates the inputs and the tests; that&amp;rsquo;s what you should pay attention to.&lt;/p&gt;

&lt;p&gt;It can get even better. So far, I&amp;rsquo;ve put all the input data in the test file itself, but now that it&amp;rsquo;s separate from the test code, I can grab the input from somewhere else. That might be a tab-separated values file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%.2N   1234.56 1,234.56 
%.2N    1234    1,234.00
%.0N    1234.49 1,234
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I create &lt;code&gt;@data&lt;/code&gt; in the test file by reading and parsing the external file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;open &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $test_data_fh, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;lt;&amp;#39;&lt;/span&gt;, $test_file_name &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; die &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; @data;
&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;( &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;lt;$test_data_fh&amp;gt;&lt;/span&gt; ) {
  chomp;
  push @data, split &lt;span style=&#34;color:#e6db74&#34;&gt;/\t/&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now none of the data are in the test file. And, there&amp;rsquo;s nothing special about a simple text file. I could do a little bit more work to take the data from an Excel file (perhaps the most useful wizard skill in business) or even a database:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; DBI;
    
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $dbh &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; DBI&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;connect( &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt; );
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $sth &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; $dbh&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;prepare( &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;SELECT * FROM tests&amp;#39;&lt;/span&gt; );
    
$sth&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;execute();
    
&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;( &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $row &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; $sth&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;fetchrow_arrayref ) {
  state $index &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;

  is( $f&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;sprintf( $row&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;], $row&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] ), $row&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;],
       $index&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;: $row-&amp;gt;[1] with format $row-&amp;gt;[0] returns $row-&amp;gt;[2]&amp;#34;&lt;/span&gt;
  );
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That&amp;rsquo;s the idea. I separate the data and the tests to give myself some flexibility. How I access the data and how I test depend on my particular problems.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Get to grips with Prove, Perl&#39;s test workhorse</title>
      <link>http://localhost:1313/article/177/2015/6/9/Get-to-grips-with-Prove--Perl-s-test-workhorse/</link>
      <pubDate>Tue, 09 Jun 2015 12:59:02 +0000</pubDate>
      
      <guid>http://localhost:1313/article/177/2015/6/9/Get-to-grips-with-Prove--Perl-s-test-workhorse/</guid>
      <description>

&lt;p&gt;Prove is a test running tool that ships with Perl. It has a ton of options, which can make it confusing for a beginner to use. If you have never used prove, or are not confident using it, do not despair! This article will get you up to speed with prove and it&amp;rsquo;s most common options.&lt;/p&gt;

&lt;h3 id=&#34;basics&#34;&gt;Basics&lt;/h3&gt;

&lt;p&gt;If you have Perl installed, you should already have Prove installed as well. To demo the features of Prove, I&amp;rsquo;m going to clone the Mojolicious repo using Git. I like demoing Prove with Mojolicious as it has a large test suite. At the command line:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ git clone https:&lt;span style=&#34;color:#e6db74&#34;&gt;//gi&lt;/span&gt;thub&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;com&lt;span style=&#34;color:#e6db74&#34;&gt;/kraih/mo&lt;/span&gt;jo
$ cd mojo&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So I&amp;rsquo;ve cloned the Mojolicious repo and changed into the project directory. Now I&amp;rsquo;m ready to run some tests with Prove!&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ prove &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;l t&lt;span style=&#34;color:#e6db74&#34;&gt;/mojo/&lt;/span&gt;asset&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;t&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I executed Prove using the &lt;code&gt;prove&lt;/code&gt; command. I included the &lt;code&gt;-l&lt;/code&gt; option so that Prove would load the Mojolicious code beneath the &lt;code&gt;lib&lt;/code&gt; directory. If I didn&amp;rsquo;t do this, Perl would not find the Mojolicious code referenced in &lt;code&gt;t/mojo/asset.t&lt;/code&gt; and raise an error, or perhaps worse, it might run the tests against an older version of Mojolicious I already had installed on my system.&lt;/p&gt;

&lt;p&gt;Sometimes the code to include is not directly in the &lt;code&gt;lib&lt;/code&gt; directory. For these cases Prove has the &lt;code&gt;-I&lt;/code&gt; option for &amp;ldquo;include&amp;rdquo;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;prove &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;I&lt;span style=&#34;color:#e6db74&#34;&gt;/path/&lt;/span&gt;to&lt;span style=&#34;color:#e6db74&#34;&gt;/lib /&lt;/span&gt;path&lt;span style=&#34;color:#e6db74&#34;&gt;/to/&lt;/span&gt;test_file&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Prove can run a single test file, or if given a directory containing multiple test files, with will execute them all:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ prove &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;l t&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;mojo&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This runs all the test files in &lt;code&gt;t/mojo&lt;/code&gt; directory.&lt;/p&gt;

&lt;h3 id=&#34;recursively-execute-test-files-with-r&#34;&gt;Recursively execute test files with &amp;ldquo;r&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;The Mojolicious project has test files in several different directories beneath the &lt;code&gt;t&lt;/code&gt; directory. It would be tiresome to locate all of these directory paths and give them to Prove. Instead, Prove provides the &lt;code&gt;-r&lt;/code&gt; option to recursively search for test files.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ prove &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;lr&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This option executed every test file under the &lt;code&gt;t&lt;/code&gt; directory, about 10,000 tests across 85 different files. Pretty convenient huh? Note that I didn&amp;rsquo;t provide the &lt;code&gt;t&lt;/code&gt; directory as an argument, because Prove searches the &lt;code&gt;t&lt;/code&gt; directory by default. Now that&amp;rsquo;s convenience!&lt;/p&gt;

&lt;h3 id=&#34;run-tests-in-parallel-using-j&#34;&gt;Run tests in parallel using &amp;ldquo;j&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;The ability to run lots of test files is useful, but it can take a long time to run all of the tests. On my machine, executing the Mojolicious test suite takes 32 seconds. To speed things up, Prove can run test files in parallel, to share the work across multiple processes. To do this I just add the &lt;code&gt;-j&lt;/code&gt; option plus the number of processes I want to use. I have a quad core machine, so I&amp;rsquo;m going to use 4 different processes:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ prove &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;lr &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;j &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This time, prove executed all the tests in 12 seconds. That&amp;rsquo;s a 266% speed-up, not bad!&lt;/p&gt;

&lt;h3 id=&#34;get-more-detail-with-v-for-verbose&#34;&gt;Get more detail with &amp;ldquo;v&amp;rdquo; for verbose&lt;/h3&gt;

&lt;p&gt;To minimize line noise, by default Prove provides summary-level statistics and low-level detail for test failures. Sometimes it&amp;rsquo;s useful to see the output for each test. I can see this detail by adding the &lt;code&gt;-v&lt;/code&gt; option for &amp;ldquo;verbose&amp;rdquo;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ prove &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;lrv&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;running-perl-6-tests&#34;&gt;Running Perl 6 tests&lt;/h3&gt;

&lt;p&gt;Prove can run tests for other languages, as long as the tests follow the Test Anything Protocol. Perl 6 unit tests follow TAP, so we can use Prove to run Perl 6 tests too! I can demo this on my Perl 6 module, &lt;a href=&#34;https://github.com/dnmfarrell/URI-Encode&#34;&gt;URI::Encode&lt;/a&gt;. To follow along, just clone the repo with Git:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ git clone https:&lt;span style=&#34;color:#e6db74&#34;&gt;//gi&lt;/span&gt;thub&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;com&lt;span style=&#34;color:#e6db74&#34;&gt;/dnmfarrell/&lt;/span&gt;URI&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;Encode
$ cd URI&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;Encode&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To run non Perl tests with Prove, we need to pass the &lt;code&gt;--exec&lt;/code&gt; option, with a program name. That tells Prove which program to execute the tests with. Like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ prove &lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;exec perl6&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that I didn&amp;rsquo;t have to pass the filepath of which tests to run. It&amp;rsquo;s just lucky that by convention Perl6 modules have their tests in the &lt;code&gt;t&lt;/code&gt; directory, usually with a &lt;code&gt;.t&lt;/code&gt; extension. For other languages, you&amp;rsquo;ll need to specify the test filepath:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ prove &lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;exec some_program &lt;span style=&#34;color:#e6db74&#34;&gt;/path/&lt;/span&gt;to&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;testfile&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;documentation&#34;&gt;Documentation&lt;/h3&gt;

&lt;p&gt;You can get a summary of the options Prove accepts by using the &lt;code&gt;-h&lt;/code&gt; option for help:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ prove &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;h&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For more detailed documentation, use &lt;code&gt;perldoc&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ perldoc prove&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Perldoc is another useful Perl tool, if you&amp;rsquo;d like to know more about it, have a look at our introductory &lt;a href=&#34;http://perltricks.com/article/155/2015/2/26/Hello-perldoc--productivity-booster&#34;&gt;article&lt;/a&gt;. Prove also has a man page entry (if you&amp;rsquo;re on Unix/BSD based systems).&lt;/p&gt;

&lt;h3 id=&#34;prove-cheat-sheet&#34;&gt;Prove Cheat sheet&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;prove [options] [filepath]

Options
-------
l       Include the &amp;quot;lib&amp;quot; dir
I       Include a dir: -I/path/to/lib
r       Recursively search and run test files
j       Parallel, specify # procs: -j 4
v       Verbose test output
h       Help, summary of options
exec    Exec tests in another program: --exec perl6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Unit test your code on an in-memory database</title>
      <link>http://localhost:1313/article/167/2015/4/15/Unit-test-your-code-on-an-in-memory-database/</link>
      <pubDate>Wed, 15 Apr 2015 03:05:00 +0000</pubDate>
      
      <guid>http://localhost:1313/article/167/2015/4/15/Unit-test-your-code-on-an-in-memory-database/</guid>
      <description>

&lt;p&gt;Unit test scripts should be independent, stateless and free from side-effects. These ideals are not always achievable but by using tools like mock objects we can often get close. Some functionality is harder to test than others though; for example how do you test database interface code? Databases have state - even if you reset the data after you&amp;rsquo;ve tested it, there&amp;rsquo;s no guarantee the data is the same, or that other code hasn&amp;rsquo;t accessed the database during the test execution.&lt;/p&gt;

&lt;p&gt;One way to deal with this is to create an in-memory database, visible only to the unit testing process and automatically deleted once the tests have completed. Fortunately it&amp;rsquo;s really easy to do this with SQLite3 and Perl.&lt;/p&gt;

&lt;h3 id=&#34;dbi&#34;&gt;DBI&lt;/h3&gt;

&lt;p&gt;The Perl &lt;a href=&#34;https://metacpan.org/pod/DBI&#34;&gt;DBI&lt;/a&gt; module is the de-facto way of accessing relational databases in Perl. To create an in-memory database, I can use call &lt;code&gt;connect&lt;/code&gt; specifying the SQLite driver, and the database name as &amp;ldquo;:memory:&amp;ldquo;. This returns a database handle to a new, in memory SQLite3 database.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Test::More;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; DBI;

&lt;span style=&#34;color:#75715e&#34;&gt;# load in-memory db&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $dbh &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; DBI&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;connect(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;dbi:SQLite:dbname=:memory:&amp;#39;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;);

&lt;span style=&#34;color:#75715e&#34;&gt;# create tables&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $create_table_script &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;do&lt;/span&gt; {  local $/; 
        open &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $SQL, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;lt;&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;create_tables.sql&amp;#39;&lt;/span&gt;;
        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;lt;$SQL&amp;gt;&lt;/span&gt;;
     };  

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $sth &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 
  $dbh&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;prepare($create_table_script) &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; BAIL_OUT ($dbh&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;errstr);
$sth&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;execute &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; BAIL_OUT($sth&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;errstr);

&lt;span style=&#34;color:#75715e&#34;&gt;# add unit tests here ...&lt;/span&gt;

done_testing;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From here I slurp a SQL script for creating the tables into a string and use the database handle to execute it. The &lt;code&gt;BAIL_OUT&lt;/code&gt; function is called if any of the database steps fail, ending the testing prematurely. At this point I have a brand new database with fresh tables, ready for testing.&lt;/p&gt;

&lt;h3 id=&#34;dbix-class&#34;&gt;DBIx::Class&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://metacpan.org/pod/DBIx::Class&#34;&gt;DBIx::Class&lt;/a&gt;, the Perl ORM uses the same underlying technology as DBI, but because it creates Perl classes representing each table, I can leverage that code to make the database setup even easier than with vanilla DBI:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Test::More;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; SomeApp::Schema;

&lt;span style=&#34;color:#75715e&#34;&gt;# load an in-memory database and deploy the required tables&lt;/span&gt;
SomeApp::Schema&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;connection(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;dbi:SQLite:dbname=:memory:&amp;#39;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;);
SomeApp::Schema&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;load_namespaces;
SomeApp::Schema&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;deploy;

&lt;span style=&#34;color:#75715e&#34;&gt;# add unit tests here ...&lt;/span&gt;

done_testing;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I&amp;rsquo;m using an example app, called &lt;code&gt;SomeApp&lt;/code&gt; to demonstrate. First the &lt;code&gt;connection&lt;/code&gt; is set to the same database connection string as with the DBI example. The &lt;code&gt;load_namespaces&lt;/code&gt; method loads all of the result and resultset DBIx::Class modules in the application and &lt;code&gt;deploy&lt;/code&gt; creates them on the in-memory database. Obviously this approach requires that you&amp;rsquo;ve already created the DBIx::Class files. If you haven&amp;rsquo;t done that yet, but you have an application database with the tables in it, you can use the &lt;code&gt;dbicdump&lt;/code&gt; command from &lt;a href=&#34;https://metacpan.org/pod/DBIx::Class::Schema::Loader&#34;&gt;DBIx::Class::Schema::Loader&lt;/a&gt; to auto generate them for you.&lt;/p&gt;

&lt;h3 id=&#34;not-just-for-testing&#34;&gt;Not just for testing&lt;/h3&gt;

&lt;p&gt;The in-memory feature of SQLite is provided by &lt;a href=&#34;https://metacpan.org/pod/DBD::SQLite&#34;&gt;DBD::SQLite&lt;/a&gt;, the DBI driver. It&amp;rsquo;s a cool feature, and could be used for more than just unit testing. Anytime you have a need for a temporary relational datastore, consider this; it&amp;rsquo;s fast, is portable and automatically cleans itself up when the program ends.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Quickly Debug your Perl code at the command line</title>
      <link>http://localhost:1313/article/160/2015/3/13/Quickly-Debug-your-Perl-code-at-the-command-line/</link>
      <pubDate>Fri, 13 Mar 2015 13:34:06 +0000</pubDate>
      
      <guid>http://localhost:1313/article/160/2015/3/13/Quickly-Debug-your-Perl-code-at-the-command-line/</guid>
      <description>

&lt;p&gt;I remember when I first started programming in Perl, whenever something wasn&amp;rsquo;t working as I expected it to, I would write a quick script to isolate the problem and test it. I didn&amp;rsquo;t give the scripts good names; they were throwaway, and soon I had hundreds of useless Perl scripts littered all over my hard drive.&lt;/p&gt;

&lt;p&gt;I rarely write scripts like that anymore. If I&amp;rsquo;m developing a module, I&amp;rsquo;ll write a unit test to bottom-out whatever problem I&amp;rsquo;m investigating - that way I&amp;rsquo;m making an investment instead of throwing code away. Most of the time however, I just write a one liner, which is a single line of Perl code typed directly into the terminal. One liners are fast to type and they hang around in your terminal history for quick iterations. So if you find yourself needing to test a particular function is doing what you think it does, or are unsure if you&amp;rsquo;re carefully-crafted regex works, write a one liner.&lt;/p&gt;

&lt;h3 id=&#34;one-liner-basics&#34;&gt;One liner basics&lt;/h3&gt;

&lt;p&gt;Perl has a ton of command line switches (see &lt;code&gt;perldoc perlrun&lt;/code&gt;), but I&amp;rsquo;m just going to cover the ones you&amp;rsquo;ll commonly need to debug code. The most important switch is &lt;code&gt;-e&lt;/code&gt;, for execute (or maybe &amp;ldquo;engage&amp;rdquo; :) ). The &lt;code&gt;-e&lt;/code&gt; switch takes a quoted string of Perl code and executes it. For example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ perl &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;e &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;print &amp;#34;Hello, World!\n&amp;#34;&amp;#39;&lt;/span&gt;
Hello, World&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It&amp;rsquo;s important that you use single-quotes to quote the code for &lt;code&gt;-e&lt;/code&gt;. This usually means you can&amp;rsquo;t use single-quotes within the one liner code. If you&amp;rsquo;re using Windows cmd.exe or PowerShell, you must use double-quotes instead.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m always forgetting what Perl&amp;rsquo;s predefined special variables do, and often test them at the command line with a one liner to see what they contain. For instance do you remember what &lt;code&gt;$^O&lt;/code&gt; is?&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ perl &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;e &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;print &amp;#34;$^O\n&amp;#34;&amp;#39;&lt;/span&gt;
linux&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It&amp;rsquo;s the operating system name. With that cleared up, let&amp;rsquo;s see what else we can do. If you&amp;rsquo;re using a relatively new Perl (5.10.0 or higher) you can use the &lt;code&gt;-E&lt;/code&gt; switch instead of &lt;code&gt;-e&lt;/code&gt;. This turns on some of Perl&amp;rsquo;s newer features, like &lt;code&gt;say&lt;/code&gt;, which prints a string and appends a newline to it. This saves typing and makes the code cleaner:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ perl &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;E &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;say &amp;#34;$^O&amp;#34;&amp;#39;&lt;/span&gt;
linux&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Pretty handy! &lt;code&gt;say&lt;/code&gt; is a nifty feature that you&amp;rsquo;ll use again and again.&lt;/p&gt;

&lt;h3 id=&#34;v-is-for-version&#34;&gt;V is for version&lt;/h3&gt;

&lt;p&gt;If you ever need to check which version of Perl is installed on your system, use the &lt;code&gt;-v&lt;/code&gt; switch:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ perl &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;v

This is perl &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, version &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;, subversion &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; (v5&lt;span style=&#34;color:#ae81ff&#34;&gt;.20.2&lt;/span&gt;) built &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x86_64&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;linux
(with &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; registered patch, see perl &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;V &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; more detail)

Copyright &lt;span style=&#34;color:#ae81ff&#34;&gt;1987&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2015&lt;/span&gt;, Larry Wall
&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Quick tip: if you need detailed information about the installed Perl version, use a capital: &lt;code&gt;-V&lt;/code&gt; instead.&lt;/p&gt;

&lt;h3 id=&#34;load-modules-with-m&#34;&gt;Load modules with M&lt;/h3&gt;

&lt;p&gt;Modules can be loaded at the command line too. For instance to download and print the PerlTricks.com homepage, I can use &lt;a href=&#34;https://metacpan.org/pod/HTTP::Tiny&#34;&gt;HTTP::Tiny&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ perl &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;MHTTP::Tiny &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;E &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;say HTTP::Tiny-&amp;gt;new-&amp;gt;get(&amp;#34;http://perltricks.com&amp;#34;)-&amp;gt;{content}&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;!&lt;/span&gt;DOCTYPE html&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;html lang&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;en&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;PerlTricks&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;com &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; Perl programming news, code &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; culture&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;meta charset&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;utf-8&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
   ,,,&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you need to import functions from a module, use an equals sign followed by a comma separated list of function names. I can check if an XML file is valid XML with &lt;a href=&#34;https://metacpan.org/pod/XML::Simple&#34;&gt;XML::Simple&lt;/a&gt; and it&amp;rsquo;s &lt;code&gt;XMLin&lt;/code&gt; function just by loading the XML file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ perl &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;MXML::Simple&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;XMLin &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;e &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;XMLin(&amp;#34;data.xml&amp;#34;)&amp;#39;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If &lt;code&gt;XMLin&lt;/code&gt; doesn&amp;rsquo;t emit any warnings or exceptions, the data is probably correctly formatted.&lt;/p&gt;

&lt;h3 id=&#34;turn-on-warnings-with-w&#34;&gt;Turn on warnings with w&lt;/h3&gt;

&lt;p&gt;This one is pretty simple: use &lt;code&gt;-w&lt;/code&gt; to turn on warnings. This can be incredibly helpful when code is not behaving the way you think it should. Warnings can help you identify issues that would otherwise be hard to spot:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ perl &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;E &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;$counter = 2; $countor = 3; say $counter&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Hmm &lt;code&gt;$counter&lt;/code&gt; should be 3 shouldn&amp;rsquo;t it? Turning on warnings quickly identifies the issue:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ perl &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;wE &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;$counter = 2; $countor = 3; say $counter&amp;#39;&lt;/span&gt;
Name &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;main::countor&amp;#34;&lt;/span&gt; used only once: possible typo at &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;e line &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;
&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There are plenty of more subtle bugs that warnings won&amp;rsquo;t identify directly, but the fact that Perl issues a warning puts you onto the fact that something is wrong. Take this example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ perl &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;MTry::Tiny &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;wE &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;$pass; try { $pass = &amp;#34;true&amp;#34; } catch { say $_ } return $pass if $pass or die&amp;#39;&lt;/span&gt;
Useless &lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; of a variable in void context at &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;e line &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;
Died at &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;e line &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Can you see what&amp;rsquo;s wrong here? The &lt;code&gt;catch&lt;/code&gt; block is missing a trailing semicolon. With warnings turned on, you can see that &lt;em&gt;something&lt;/em&gt; is up, but it&amp;rsquo;s not obvious what&amp;rsquo;s wrong.&lt;/p&gt;

&lt;h3 id=&#34;use-i-to-include-directories&#34;&gt;Use I to include directories&lt;/h3&gt;

&lt;p&gt;Sometimes you&amp;rsquo;ll be working with modules that are not installed in Perl&amp;rsquo;s standard locations. This often happens when you&amp;rsquo;re debugging an application but it&amp;rsquo;s not installed via CPAN. To demonstrate this, I&amp;rsquo;ll download my &lt;a href=&#34;https://metacpan.org/pod/WWW::curlmyip&#34;&gt;WWW::curlmyip&lt;/a&gt; module:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ cpan &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;g WWW::curlmyip
$~ tar xzf WWW&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;curlmyip&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.02&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;tar&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;gz 
$ cd WWW&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;curlmyip&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.02&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;WWW::curlmyip exports a function called &lt;code&gt;get_ip&lt;/code&gt; which returns your external IP address. I can use it in a one liner:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ perl &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;MWWW::curlmyip &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;E &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;say get_ip&amp;#39;&lt;/span&gt;
Can&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;#39;&lt;/span&gt;t locate WWW&lt;span style=&#34;color:#e6db74&#34;&gt;/curlmyip.pm in @INC (you may need to install the WWW::curlmyip module) (@INC contains: /&lt;/span&gt;home&lt;span style=&#34;color:#e6db74&#34;&gt;/dfarrell/&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;plenv&lt;span style=&#34;color:#e6db74&#34;&gt;/versions/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5.20.2&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;/lib/&lt;/span&gt;perl5&lt;span style=&#34;color:#e6db74&#34;&gt;/site_perl/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5.20.2&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;/x86_64-linux /&lt;/span&gt;home&lt;span style=&#34;color:#e6db74&#34;&gt;/dfarrell/&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;plenv&lt;span style=&#34;color:#e6db74&#34;&gt;/versions/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5.20.2&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;/lib/&lt;/span&gt;perl5&lt;span style=&#34;color:#e6db74&#34;&gt;/site_perl/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5.20.2&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;/home/&lt;/span&gt;dfarrell&lt;span style=&#34;color:#e6db74&#34;&gt;/.plenv/&lt;/span&gt;versions&lt;span style=&#34;color:#e6db74&#34;&gt;/5.20.2/&lt;/span&gt;lib&lt;span style=&#34;color:#e6db74&#34;&gt;/perl5/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5.20.2&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;/x86_64-linux /&lt;/span&gt;home&lt;span style=&#34;color:#e6db74&#34;&gt;/dfarrell/&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;plenv&lt;span style=&#34;color:#e6db74&#34;&gt;/versions/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5.20.2&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;/lib/&lt;/span&gt;perl5&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5.20.2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;BEGIN&lt;/span&gt; failed&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;compilation aborted&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That didn&amp;rsquo;t work. Perl is complaining that it can&amp;rsquo;t find WWW::curlmyip. To fix this, I can include the distribution &lt;code&gt;lib&lt;/code&gt; directory that contains the module using &lt;code&gt;-I&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ perl &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;Ilib &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;MWWW::curlmyip &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;E &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;say get_ip&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#ae81ff&#34;&gt;100.241.20.7&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And the &lt;code&gt;get_ip&lt;/code&gt; function now works.&lt;/p&gt;

&lt;h3 id=&#34;wrap-up&#34;&gt;Wrap-up&lt;/h3&gt;

&lt;p&gt;If you ever need to check the one liner syntax, just run &lt;code&gt;perl -h&lt;/code&gt; to get a summary of the available options. Another good resource is the official documentation, which you can read at the terminal with &lt;code&gt;perldoc perlrun&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This article has covered the most common command line switches used for debugging code but a whole book could be written about Perl one liners. In fact, one has: &lt;a href=&#34;http://www.catonmat.net/blog/perl-one-liners-no-starch-press/&#34;&gt;Perl One-Liners&lt;/a&gt; by Peteris Krummins. In the book Peteris describes the various command line switches with example programs. It also has an excellent &amp;ldquo;how to&amp;rdquo; for running one liners on Windows.&lt;/p&gt;

&lt;p&gt;Finally, Perl 6 also has excellent one liner support and the switches are mostly the same as Perl 5. If you&amp;rsquo;re interested, check out our article &lt;a href=&#34;http://perltricks.com/article/136/2014/11/20/Get-started-with-Perl-6-one-liners&#34;&gt;Get started with Perl 6 one liners&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to test for exceptions in Perl</title>
      <link>http://localhost:1313/article/157/2015/3/5/How-to-test-for-exceptions-in-Perl/</link>
      <pubDate>Thu, 05 Mar 2015 13:27:17 +0000</pubDate>
      
      <guid>http://localhost:1313/article/157/2015/3/5/How-to-test-for-exceptions-in-Perl/</guid>
      <description>

&lt;p&gt;Most Perl programmers are familiar with &lt;a href=&#34;https://metacpan.org/pod/Test::More&#34;&gt;Test::More&lt;/a&gt;; it&amp;rsquo;s the go-to library for writing unit tests in Perl. But Test::More doesn&amp;rsquo;t provide functions for testing exceptions. For that you&amp;rsquo;ll need &lt;a href=&#34;https://metacpan.org/pod/Test::Exception&#34;&gt;Test::Exception&lt;/a&gt;. And good code throws exceptions - Paul Fenwick &lt;a href=&#34;http://perltraining.com.au/tips/2008-08-20.html&#34;&gt;once&lt;/a&gt; summed this approach nicely:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bIlujDI&#39; yIchegh()Qo&#39;; yIHegh()!

It is better to die() than to return() in failure.

    -- Klingon programming proverb.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The simplest way to throw an exception is with Perl&amp;rsquo;s built-in &lt;code&gt;die&lt;/code&gt; function. Just like Test::More makes it easy to test that subroutines return the right values, Test::Exception makes it easy to check the code is &lt;em&gt;dying&lt;/em&gt; in the right way (and &lt;a href=&#34;https://metacpan.org/pod/Test::Fatal&#34;&gt;Test::Fatal&lt;/a&gt; is a good alternative).&lt;/p&gt;

&lt;h3 id=&#34;did-my-code-die-ok&#34;&gt;Did my code die ok?&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s say we&amp;rsquo;re writing unit tests for the following package which exports the &lt;code&gt;double_integer&lt;/code&gt; subroutine:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;package&lt;/span&gt; Double;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Exporter;
@ISA &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Exporter&amp;#39;&lt;/span&gt;;
@EXPORT &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;double_integer&lt;/span&gt;
{
  &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; ($number) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; @_;
  die &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer() requires a positive integer as an argument&amp;#39;&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;unless&lt;/span&gt; defined $number &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; $number &lt;span style=&#34;color:#f92672&#34;&gt;=~&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;/^\d+$/&lt;/span&gt;;

  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; $number &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
}

&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This code will &lt;code&gt;die&lt;/code&gt; unless the double_integer subroutine is called with a positive integer. I&amp;rsquo;ll save this package as &lt;code&gt;Double.pm&lt;/code&gt;. Let&amp;rsquo;s write a test script for this package. Test::Exception exports the &lt;code&gt;dies_ok&lt;/code&gt; function that checks the code dies as expected:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Test::Exception tests &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Double;

dies_ok { double_integer() } &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer() dies with no number&amp;#39;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;dies_ok&lt;/code&gt; is clever, it won&amp;rsquo;t actually let your code die and the program exit, as that would interrupt testing! Instead it catches any thrown exceptions so testing can continue. My program should also die if &lt;code&gt;double_integer&lt;/code&gt; is called with a non-number as an argument. I can add more tests for some common scenarios:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Test::Exception test &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Double;

dies_ok { double_integer() } &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer() dies with no number&amp;#39;&lt;/span&gt;;
dies_ok { double_integer(undef) } &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer() dies with undef&amp;#39;&lt;/span&gt;;
dies_ok { double_integer(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;abc&amp;#39;&lt;/span&gt;) } &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer() dies with text&amp;#39;&lt;/span&gt;;
dies_ok { double_integer(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;1 two&amp;#39;&lt;/span&gt;) } &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer() dies with mixed&amp;#39;&lt;/span&gt;;
dies_ok { double_integer(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;-7&amp;#39;&lt;/span&gt;) } &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer() dies with a negative&amp;#39;&lt;/span&gt;;
dies_ok { double_integer(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2.5&amp;#39;&lt;/span&gt;) } &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer() dies with a decimal&amp;#39;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I can also check the code throws the right exception with &lt;code&gt;throws_ok&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Test::Exception tests &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Double;

throws_ok { double_integer() } &lt;span style=&#34;color:#e6db74&#34;&gt;qr/requires a positive integer/&lt;/span&gt;, 
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer() requires a positive integer&amp;#39;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;throws_ok&lt;/code&gt; function checks that the code throws an exception, but also that the exception message matches a regex. This is useful if you have several different conditions that may throw different types of exceptions: imagine with a web application, you&amp;rsquo;d want to throw a different exception code if the user requested a page they didn&amp;rsquo;t have permission to access (403) versus requesting a non-existent page (404).&lt;/p&gt;

&lt;p&gt;Test::Exception is fully compatible with Test::More so you can combine functions from both libraries in the same file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Test::More;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Test::Exception;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Double;

&lt;span style=&#34;color:#75715e&#34;&gt;# test arg validation works&lt;/span&gt;
dies_ok { double_integer() } &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer() dies with no number&amp;#39;&lt;/span&gt;;
dies_ok { double_integer(undef) } &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer() dies with undef&amp;#39;&lt;/span&gt;;
dies_ok { double_integer(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;abc&amp;#39;&lt;/span&gt;) } &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer() dies with text&amp;#39;&lt;/span&gt;;
dies_ok { double_integer(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;1 two&amp;#39;&lt;/span&gt;) } &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer() dies with mixed&amp;#39;&lt;/span&gt;;
dies_ok { double_integer(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;-7&amp;#39;&lt;/span&gt;) } &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer() dies with a negative&amp;#39;&lt;/span&gt;;
dies_ok { double_integer(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2.5&amp;#39;&lt;/span&gt;) } &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer() dies with a decimal&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#75715e&#34;&gt;# test exception message&lt;/span&gt;
throws_ok { double_integer() } &lt;span style=&#34;color:#e6db74&#34;&gt;qr/requires a positive integer/&lt;/span&gt;, 
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;double_integer() requires a positive integer&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#75715e&#34;&gt;# test double_integer works&lt;/span&gt;
lives_ok { double_integer(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) } &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;calling double() with a number lives&amp;#39;&lt;/span&gt;;
is double_integer(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;), &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;zero doubled is zero&amp;#39;&lt;/span&gt;;
is double_integer(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;), &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;two doubled is four&amp;#39;&lt;/span&gt;;
is double_integer(&lt;span style=&#34;color:#ae81ff&#34;&gt;999&lt;/span&gt;), &lt;span style=&#34;color:#ae81ff&#34;&gt;1998&lt;/span&gt;, 
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;nine nine nine doubled is one nine nine eight&amp;#39;&lt;/span&gt;;

done_testing();&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now the test script checks both that the function throws the appropriate exception when the argument is wrong, and it returns the argument doubled when the argument is valid. If I save this test file as &lt;code&gt;Double.t&lt;/code&gt; I can run the tests at the terminal:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ perl Double&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;t
ok &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; double_integer() dies with &lt;span style=&#34;color:#66d9ef&#34;&gt;no&lt;/span&gt; number
ok &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; double_integer() dies with undef
ok &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; double_integer() dies with text
ok &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; double_integer() dies with mixed
ok &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; double_integer() dies with a negative
ok &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; double_integer() dies with a decimal
ok &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; double_integer() requires a positive integer
ok &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; calling double() with a number lives
ok &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; zero doubled is zero
ok &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; two doubled is four
ok &lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; nine nine nine doubled is one nine nine eight
&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;All the tests pass. &lt;a href=&#34;https://metacpan.org/pod/Test::Exception&#34;&gt;Test::Exception&lt;/a&gt; has great documentation and is easy to use, so add exception testing to your code today!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Updated:&lt;/strong&gt; &lt;em&gt;Added Test::Fatal reference 2015-03-10&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Boost your Perl productivity with auto-compile checking</title>
      <link>http://localhost:1313/article/133/2014/11/10/Boost-your-Perl-productivity-with-auto-compile-checking/</link>
      <pubDate>Mon, 10 Nov 2014 14:01:51 +0000</pubDate>
      
      <guid>http://localhost:1313/article/133/2014/11/10/Boost-your-Perl-productivity-with-auto-compile-checking/</guid>
      <description>

&lt;p&gt;The Perl command line option &lt;code&gt;-c&lt;/code&gt; causes Perl to check the syntax of the program, but not execute it (apart from code in BEGIN, CHECK and UNITCHECK blocks - watch out for those). For example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ perl &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;c lib&lt;span style=&#34;color:#e6db74&#34;&gt;/Devel/&lt;/span&gt;DidYouMean&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pm
lib&lt;span style=&#34;color:#e6db74&#34;&gt;/Devel/&lt;/span&gt;DidYouMean&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pm syntax OK&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is useful but it&amp;rsquo;s kind of clunky to type it every time you want to check the syntax of a program or file.&lt;/p&gt;

&lt;h3 id=&#34;continuous-syntax-checking&#34;&gt;Continuous syntax checking&lt;/h3&gt;

&lt;p&gt;One of my favourite &lt;a href=&#34;https://metacpan.org/pod/Catalyst::Manual::Tutorial::02_CatalystBasics#The-Simplest-Way&#34;&gt;features&lt;/a&gt; when developing Catalyst web apps is using the test server to automatically check the syntax of the web app as I develop it. This saves me time as I know immediately if the web app compiles or not and don&amp;rsquo;t waste time opening up a browser only to get an error. if you&amp;rsquo;re working on a Unix-based operating system you can achieve a similar effect for any Perl program (not just web apps). The &lt;code&gt;watch&lt;/code&gt; program can automatically run the check command. Just start a new terminal, and enter:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ watch &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;perl -c lib/Devel/DidYouMean.pm&amp;#39;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Giving this output:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;Every &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;s perl &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;c lib&lt;span style=&#34;color:#e6db74&#34;&gt;/Devel/&lt;/span&gt;DidYouMean&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pm           Sat Nov  &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2014&lt;/span&gt;

lib&lt;span style=&#34;color:#e6db74&#34;&gt;/Devel/&lt;/span&gt;DidYouMean&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pm syntax OK&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this case I&amp;rsquo;m watching the file &lt;code&gt;lib/Devel/DidYouMean.pm&lt;/code&gt; but you can provide any path to a Perl file that you want to check for syntax errors. By default &lt;code&gt;watch&lt;/code&gt; will run the command every 2 seconds. So if I save a bad update to the file, the watching terminal window will show the error:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;Every &lt;span style=&#34;color:#ae81ff&#34;&gt;2.0&lt;/span&gt;s: perl &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;c lib&lt;span style=&#34;color:#e6db74&#34;&gt;/Devel/&lt;/span&gt;DidYouMean&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pm           Sat Nov  &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2014&lt;/span&gt;

syntax error at lib&lt;span style=&#34;color:#e6db74&#34;&gt;/Devel/&lt;/span&gt;DidYouMean&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pm line &lt;span style=&#34;color:#ae81ff&#34;&gt;122&lt;/span&gt;, near &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;} keys&amp;#34;&lt;/span&gt;

lib&lt;span style=&#34;color:#e6db74&#34;&gt;/Devel/&lt;/span&gt;DidYouMean&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pm had compilation errors&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This enables me to catch the error before running the program, saving time.&lt;/p&gt;

&lt;h3 id=&#34;checking-syntax-in-a-text-editor&#34;&gt;Checking syntax in a text-editor&lt;/h3&gt;

&lt;p&gt;Using &lt;code&gt;watch&lt;/code&gt; is useful, but I find it can be annoying to have to check a separate terminal window to know if my program compiles or not. Another way to do this is to run the command from within your text-editor. I&amp;rsquo;ll show how you how to do this in vim, but it should be possible to do this in any text-editor that has save events which you can hook in to (e.g. examples for &lt;a href=&#34;http://www.klaascuvelier.be/2013/06/sublime-command-on-save/&#34;&gt;Sublime Text&lt;/a&gt; and &lt;a href=&#34;http://flycheck.readthedocs.org/en/latest/&#34;&gt;Emacs&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Add the following line to your .vimrc file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;autocmd BufWritePost &lt;span style=&#34;color:#f92672&#34;&gt;*.&lt;/span&gt;pm,&lt;span style=&#34;color:#f92672&#34;&gt;*.&lt;/span&gt;t,&lt;span style=&#34;color:#f92672&#34;&gt;*.&lt;/span&gt;pl echom system(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;perl -Ilib -c &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#34;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt; expand(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%:p&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#34;&amp;#39;&lt;/span&gt; )&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What this command does is every time a file ending in .pm, .t, or.pl is saved, vim will run the check syntax command on the file, echoing the results to the current window. Reload your .vimrc with this vim command: &lt;code&gt;:so $MYVIMRC&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now you don&amp;rsquo;t have to bother setting up a separate terminal window and watching the file; vim will notify you immediately if any Perl file is saved with compilation errors. Much more convenient!&lt;/p&gt;

&lt;h3 id=&#34;alternative-methods-in-vim&#34;&gt;Alternative Methods in Vim&lt;/h3&gt;

&lt;p&gt;Several readers got in touch to recommend the Syntastic &lt;a href=&#34;https://github.com/scrooloose/syntastic&#34;&gt;plugin&lt;/a&gt; for Vim (&lt;a href=&#34;https://github.com/scrooloose/syntastic&#34;&gt;manual&lt;/a&gt;). One nice thing about Syntastic is you can chain compile checks: first run &lt;code&gt;perl -c&lt;/code&gt;, if it passes, then run &lt;a href=&#34;https://metacpan.org/pod/Perl::Critic&#34;&gt;Perl::Critic&lt;/a&gt; and so on. Syntastic also integrates syntax checkers for many other languages, so if Vim is your editor of choice, you might want to check it out.&lt;/p&gt;

&lt;p&gt;A simpler alternative to Syntastic is to use Vim&amp;rsquo;s built-in compiler support. With a Perl file in the current buffer, type:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;:compiler perl
:make
:cope&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This will run Perl&amp;rsquo;s syntax checks checks on the current buffer. Vim reads the output into an error list, which the &lt;code&gt;:cope&lt;/code&gt; command displays. You can jump to the line referenced by a specific error by pressing the enter key (&lt;a href=&#34;http://vimdoc.sourceforge.net/htmldoc/quickfix.html#quickfix-window&#34;&gt;manual&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Updates:&lt;/strong&gt; &lt;em&gt;BEGIN, CHECK, UNITCHECK blocks caution added. Emacs link and addition Vim methods added. 2014-11-10&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Vim autocmd example updated to handle filepaths containing spaces. Thanks to Henry An for the suggestion. 2015-01-22&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Cover image &lt;a href=&#34;https://creativecommons.org/licenses/by/4.0/&#34;&gt;Â©&lt;/a&gt; &lt;a href=&#34;https://www.flickr.com/photos/runneralan/10092757714/in/photolist--88qSeT-88u7R1-dqTSLE-atoyrp-bD3QaN-93yNyq-8QYfKX-diG9h4-bD3NV9-88u847-gnS2f3-55QWyu-dqTHcF-9AJTkV-88qSdr-7h39AP-7nPgCT-88qSfv-5MyRfE-bRXxYv-bD3PXU-88u7pC-imjBX2-8xz38b-32eo27-a8YVvZ-8WJgFA-93ySDG-57KLMs-oYUnQ1-88qRL4-fturhH-88qRMx-cUx3nS-4GMFL2-88qSrv-5RhqjZ-ftuqAr-ehAoHf-ftJLsq-88u7fU-5R22Pk-5CNDM-bv2wve-9vnwcd-6dyA62-ejP2nf-329MpH-88u7ds&#34;&gt;Alan Kotok&lt;/a&gt; image has been digitally altered&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Check your module POD using perldoc</title>
      <link>http://localhost:1313/article/9/2013/4/1/Check-your-module-POD-using-perldoc/</link>
      <pubDate>Mon, 01 Apr 2013 22:45:35 +0000</pubDate>
      
      <guid>http://localhost:1313/article/9/2013/4/1/Check-your-module-POD-using-perldoc/</guid>
      <description>&lt;p&gt;Perl ships with a command-line program called perldoc that makes it easier to search and read Perl&amp;rsquo;s vast documentation in the POD markup language. If perldoc is called with the -F flag, it will display the POD markup of an input file - this can be useful when your are developing a new Perl distribution and want to check the appearance of the POD in your module before it appears on CPAN for all to see.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Pass a local file to perldoc&lt;/span&gt;

perldoc &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;F ProxyManager&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pm&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This will then display the POD markup:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;ProxyManager(&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;)                                            

NAME
       Net::OpenVPN::ProxyManager &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; connect to proxy servers using OpenVPN&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;

SYNOPSIS
       &lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Net::OpenVPN::ProxyManager;
       &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $pm &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Net::OpenVPN::ProxyManager&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;;

       &lt;span style=&#34;color:#75715e&#34;&gt;# Create a config object to capture proxy server details&lt;/span&gt;
       &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $config_object &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; $pm&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;create_config({remote &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;100.120.3.34 53&amp;#39;&lt;/span&gt;, proto &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;udp&amp;#39;&lt;/span&gt;});

       &lt;span style=&#34;color:#75715e&#34;&gt;# Launch OpenVPN and connect to the proxy&lt;/span&gt;
       $pm&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;connect($config_object);
       &lt;span style=&#34;color:#75715e&#34;&gt;# do some stuff&lt;/span&gt;

       &lt;span style=&#34;color:#75715e&#34;&gt;# Disconnect from the proxy server&lt;/span&gt;
       $pm&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;disconnect();

DESCRIPTION
       Net::OpenVPN::ProxyManager is an object oriented module that provides methods to simplify the management of proxy connections that support OpenVPN&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;

This is a base generic class, see Net::OpenVPN::ProxyManager::HMA &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; additional methods to interact with hidemyass&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;com proxy servers&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;

METHODS
   &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;
       The constructor accepts an anonymous hash &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; two optional parameters: config_path &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; warning_flag&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt; config_path is the path that ProxyManager&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pm will &lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; to create the config file when the create_config method is called&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt; By default config_path is set to &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/tmp/openvpn-config.conf&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Perl Code Kata: Mocking Objects</title>
      <link>http://localhost:1313/pub/2005/04/07/mockobject_kata.html/</link>
      <pubDate>Thu, 07 Apr 2005 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2005/04/07/mockobject_kata.html/</guid>
      <description>

&lt;p&gt;The last Perl Code Kata was on &lt;a href=&#34;https://metacpan.org/pod/DBD::Mock&#34;&gt;DBD::Mock&lt;/a&gt;, a mock DBI driver which is useful for &lt;a href=&#34;http://localhost:1313/pub/2005/02/10/database_kata.html&#34;&gt;testing Perl DBI applications&lt;/a&gt;. This Kata delves once again into the world of mock objects, this time using the more general &lt;a href=&#34;https://metacpan.org/pod/Test::MockObject&#34;&gt;Test::MockObject&lt;/a&gt; module.&lt;/p&gt;

&lt;h3 id=&#34;what-are-mock-objects&#34;&gt;What are Mock Objects?&lt;/h3&gt;

&lt;p&gt;Mock objects are exactly what they sound like: &amp;ldquo;mocked&amp;rdquo; or &amp;ldquo;fake&amp;rdquo; objects. Through the power of polymorphism, it&amp;rsquo;s easy to swap one object for another object which implements the same interface. Mock objects take advantage of this fact, allowing you to substitute the &lt;em&gt;most minimally mocked implementation of an object possible&lt;/em&gt; for the real one during testing. This allows a greater degree of isolation within your tests, which is just an all around good thing.&lt;/p&gt;

&lt;h3 id=&#34;what-are-mock-objects-good-for&#34;&gt;What are Mock Objects Good For?&lt;/h3&gt;

&lt;p&gt;Mock objects are primarily useful when writing unit tests. They share a certain similarity with the Null Object pattern in that they are purposefully &lt;em&gt;not&lt;/em&gt; meant to work. Mock objects take things one step further and allow you to mock certain actions or reactions that your mock object should have, so they are especially useful in scenarios usually considered &lt;em&gt;hard to test&lt;/em&gt;. Here is a short list of some scenarios in which mock objects make hard things easy.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Tests which depend on outside resources such as networks, databases, etc.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;If your code properly encapsulates any outside resources, then it should be possible to substitute a mocked object in its place during testing. This is especially useful when you have little control over the execution environment of your module. The previous Test Code Kata illustrated this by mocking the database itself. You need not stop with databases; you can mock any sufficiently encapsulated resource such as network connections, files, or miscellaneous external devices.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;Tests for which dependencies require a lot of setup.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Sometimes your object will have a dependency which requires a large amount of set-up code. The more non-test code in your tests, the higher the possibility that it will contain a bug which can then corrupt your test results. Many times your code uses only a small portion of this hard-to-setup dependency as well. Mock objects can help simplify things by allowing you to create the most minimally mocked implementation of an object and its dependencies possible, thus removing the burden of the set-up code and reducing the possibility of bugs in your non-test code.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;Tests for failures; in particular, failure edge cases.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Testing for failures can sometimes be very difficult to do, especially when the failure is not immediate, but triggered by a more subtle set of interactions. Using mock objects, it is possible to achieve exacting control over when, where, and why your object will fail. Mock objects often make this kind of testing trivial.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;Tests with optional dependencies.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Good code should be flexible code. Many times this means that your code needs to adapt to many different situations and many different environments based on the resources available at runtime. Requiring the presence of these situations and/or environments in order to test your code can be very difficult to set up or to tear down. Just as with testing failures, it is possible to use mock objects to achieve a high degree of control over your environment and mock the situations you need to test.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;the-problem&#34;&gt;The Problem&lt;/h3&gt;

&lt;p&gt;The example code for this kata illustrates as many points as possible about which mock objects are good at testing. Here is the code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package Site::Member;

use strict;
our $VERSION = &#39;0.01&#39;;

sub new { bless { ip_address =&amp;gt; &#39;&#39; }, shift }

sub ip_address { 
    my ($self, $ip_address) = @_;
    $self-&amp;gt;{ip_address} = $ip_address if $ip_address;
    return $self-&amp;gt;{ip_address};
}

# ...

sub city {
    my ($self) = @_;
    eval &amp;quot;use Geo::IP&amp;quot;;
    if ($@) {
        warn &amp;quot;You must have Geo::IP installed for this feature&amp;quot;;
        return;
    }
    my $geo = Geo::IP-&amp;gt;open(
                &amp;quot;/usr/local/share/GeoIP/GeoIPCity.dat&amp;quot;, 
                Geo::IP-&amp;gt;GEOIP_STANDARD
            ) || die &amp;quot;Could not create a Geo::IP object with City data&amp;quot;;
    my $record = $geo-&amp;gt;record_by_addr($self-&amp;gt;ip_address());
    return $record-&amp;gt;city();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example code comes from a fictional online community software package. Many such sites offer user homepages which can display all sorts of user information. As an optional feature, the software can use the member&amp;rsquo;s IP address along with the &lt;a href=&#34;https://metacpan.org/pod/Geo::IP&#34;&gt;Geo::IP&lt;/a&gt; module to determine the user&amp;rsquo;s city. The reason this feature is optional is that while &lt;code&gt;Geo::IP&lt;/code&gt; and the C library it uses are both free, the city data is not.&lt;/p&gt;

&lt;p&gt;The use cases suggest testing for the following scenarios:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;User does not have &lt;code&gt;Geo::IP&lt;/code&gt; installed.&lt;/li&gt;
&lt;li&gt;User has &lt;code&gt;Geo::IP&lt;/code&gt; installed but does not have the city data.&lt;/li&gt;
&lt;li&gt;User has &lt;code&gt;Geo::IP&lt;/code&gt; and city data installed correctly.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Using &lt;code&gt;Test::MockObject&lt;/code&gt;, take thirty to forty minutes and see if you can write tests which cover all these use cases.&lt;/p&gt;

&lt;h3 id=&#34;tips-tricks-and-suggestions&#34;&gt;Tips, Tricks, and Suggestions&lt;/h3&gt;

&lt;p&gt;Some of the real strengths of &lt;code&gt;Test::MockObject&lt;/code&gt; lie in its adaptability and how simply it adapts. All &lt;code&gt;Test::MockObject&lt;/code&gt; sessions begin with creating an instance.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $mock = Test::MockObject-&amp;gt;new();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Even just this much can be useful because a &lt;code&gt;Test::MockObject&lt;/code&gt; instance warns about all un-mocked methods called on it. I have used this &amp;ldquo;feature&amp;rdquo; to help trace calls while writing complex tests.&lt;/p&gt;

&lt;p&gt;The next step is to mock some methods. The simplest approach is to use the &lt;code&gt;mock&lt;/code&gt; method. It takes a method name and a subroutine reference. Every time something calls that method on the object, your &lt;code&gt;$mock&lt;/code&gt; instance will run that sub.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$mock-&amp;gt;mock(&#39;greetings&#39; =&amp;gt; sub {
    my ($mock, $name) = @_;
    return &amp;quot;Hello $name&amp;quot;;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How much simpler could it be?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Test::MockObject&lt;/code&gt; also offers several pre-built mock method builders, such as &lt;code&gt;set_true&lt;/code&gt;, &lt;code&gt;set_false&lt;/code&gt;, and &lt;code&gt;set_always&lt;/code&gt;. These methods pretty much DWIM.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$mock-&amp;gt;set_true(&#39;foo&#39;); # the foo() method will return true
$mock-&amp;gt;set_false(&#39;bar&#39;); # the bar() method will return false
$mock-&amp;gt;set_always(&#39;baz&#39; =&amp;gt; 100); # the bar() method will always return 100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s even possible for the object to mock not only the methods, but its class as well. The simplest approach is to use the &lt;code&gt;set_isa&lt;/code&gt; method to tell the &lt;code&gt;$mock&lt;/code&gt; object to pretend that it belongs to another class.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$mock-&amp;gt;set_isa(&#39;Foo::Bar&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, any code that calls this mock object&amp;rsquo;s &lt;code&gt;isa()&lt;/code&gt; method will believe that the &lt;code&gt;$mock&lt;/code&gt; is a &lt;code&gt;Foo::Bar&lt;/code&gt; object.&lt;/p&gt;

&lt;p&gt;In many cases, it is enough to substitute a &lt;code&gt;$mock&lt;/code&gt; instance for a real one and let polymorphism do the rest. Other times it is necessary to inject control into the code much earlier than this. This is where the &lt;code&gt;fake_module&lt;/code&gt; method comes in.&lt;/p&gt;

&lt;p&gt;With the &lt;code&gt;fake_module&lt;/code&gt; method, &lt;code&gt;Test::MockObject&lt;/code&gt; can subvert control of an entire package such that it will intercept any calls to that package. The following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $mock = Test::MockObject-&amp;gt;new();
$mock-&amp;gt;fake_module(&#39;Foo::Bar&#39; =&amp;gt; (
    &#39;import&#39; =&amp;gt; sub { die &amp;quot;Foo::Bar could not be loaded&amp;quot; }
));
use_ok(&#39;Foo::Bar&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;actually gives the illusion that the &lt;code&gt;Foo::Bar&lt;/code&gt; module failed to load regardless of whether the user has it installed. These kinds of edge cases can be very difficult to test, but &lt;code&gt;Test::MockObject&lt;/code&gt; simplifies them greatly.&lt;/p&gt;

&lt;p&gt;But wait, that&amp;rsquo;s not all.&lt;/p&gt;

&lt;p&gt;After your tests have run using your mock objects, it is possible to inspect the methods called on them and query the order of their calls. You can even inspect the arguments passed into these methods. There several methods for this, so I refer you to the POD documentation of &lt;code&gt;Test::MockObject&lt;/code&gt; for details.&lt;/p&gt;

&lt;h3 id=&#34;the-solution&#34;&gt;The Solution&lt;/h3&gt;

&lt;p&gt;I designed each use case to illustrate a different capability of &lt;code&gt;Test::MockObject&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;User does not have Geo::IP installed.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Test::More tests =&amp;gt; 4;
use Test::MockObject;

my $mock = Test::MockObject-&amp;gt;new();
$mock-&amp;gt;fake_module(&#39;Geo::IP&#39; =&amp;gt; (
    &#39;import&#39; =&amp;gt; sub { die &amp;quot;Could not load Geo::IP&amp;quot; },
));

use_ok(&#39;Site::Member&#39;);

my $u = Site::Member-&amp;gt;new();
isa_ok($u, &#39;Site::Member&#39;);

my $warning;
local $SIG{__WARN__} = sub { $warning = shift };

ok(!defined($u-&amp;gt;city()), &#39;... this should return undef&#39;);
like($warning, 
        qr/^You must have Geo\:\:IP installed for this feature/, 
        &#39;... and we should have our warning&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This use case illustrates the use of &lt;code&gt;Test::MockObject&lt;/code&gt; to mock the failure of the loading of an optional resource, which in this case is the &lt;code&gt;Geo::IP&lt;/code&gt; module.&lt;/p&gt;

&lt;p&gt;The sample code attempts to load &lt;code&gt;Geo::IP&lt;/code&gt; by calling &lt;code&gt;eval &amp;quot;use Geo::IP&amp;quot;&lt;/code&gt;. Because &lt;code&gt;use&lt;/code&gt; always calls a module&amp;rsquo;s &lt;code&gt;import&lt;/code&gt; method, it is possible to exploit this and mock a &lt;code&gt;Geo::IP&lt;/code&gt; load failure. This is easy to accomplish by using the &lt;code&gt;fake_module&lt;/code&gt; method and making the &lt;code&gt;import&lt;/code&gt; method die. This then triggers the warning code in the &lt;code&gt;city&lt;/code&gt; method, which the &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; handler captures into &lt;code&gt;$warning&lt;/code&gt; for a later test.&lt;/p&gt;

&lt;p&gt;This is an example of a failure edge case which would be difficult to test without &lt;code&gt;Test::MockObject&lt;/code&gt; because it requires control of the Perl libraries installed. Testing this without &lt;code&gt;Test::MockObject&lt;/code&gt; would require altering the &lt;code&gt;@INC&lt;/code&gt; in subtle ways or mocking a &lt;code&gt;Geo::IP&lt;/code&gt; package of your own. &lt;code&gt;Test::MockObject&lt;/code&gt; does that for you, so why bother to re-invent a wheel if you don&amp;rsquo;t need to?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;User has &lt;code&gt;Geo::IP&lt;/code&gt; installed but does not have the city data.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Test::More tests =&amp;gt; 3;
use Test::Exception;
use Test::MockObject;

my $mock = Test::MockObject-&amp;gt;new();
$mock-&amp;gt;fake_module(&#39;Geo::IP&#39; =&amp;gt; (
    &#39;open&#39;           =&amp;gt; sub { undef },
    &#39;GEOIP_STANDARD&#39; =&amp;gt; sub { 0 }
));

use_ok(&#39;Site::Member&#39;);

my $u = Site::Member-&amp;gt;new();
isa_ok($u, &#39;Site::Member&#39;);

$u-&amp;gt;ip_address(&#39;64.40.146.219&#39;);

throws_ok {
    $u-&amp;gt;city()
} qr/Could not create a Geo\:\:IP object/, &#39;... got the error we expected&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This next use case illustrates the use of &lt;code&gt;Test::MockObject&lt;/code&gt; to mock a dependency relationship, in particular the failure case where &lt;code&gt;Geo::IP&lt;/code&gt; cannot find the specified database file.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Geo::IP&lt;/code&gt; follows the common Perl idiom of returning &lt;code&gt;undef&lt;/code&gt; if the object constructor fails. The example code tests for this case and throws an exception if it comes up. Testing for this failure uses the &lt;code&gt;fake_module&lt;/code&gt; method again to hijack &lt;code&gt;Geo::IP&lt;/code&gt; and install a mocked version of its &lt;code&gt;open&lt;/code&gt; method (the code also fakes the &lt;code&gt;GEOIP_STANDARD&lt;/code&gt; constant here). The mocked &lt;code&gt;open&lt;/code&gt; simply returns &lt;code&gt;undef&lt;/code&gt; which will create the proper conditions to trigger the exception in the example code. The exception is then caught using the &lt;code&gt;throws_ok&lt;/code&gt; method of the &lt;a href=&#34;https://metacpan.org/pod/Test::Exception&#34;&gt;Test::Exception&lt;/a&gt; module.&lt;/p&gt;

&lt;p&gt;This example illustrates that it is still possible to mock objects even if your code is not in the position to pass in a mocked instance itself. Again, to test this without using &lt;code&gt;Test::MockObject&lt;/code&gt; would require control of the outside environment (the &lt;code&gt;Geo::IP database&lt;/code&gt; file), or in some way having control over where &lt;code&gt;Geo::IP&lt;/code&gt; looks for the database file. While well-written and well-architected code would probably allow you to alter the database file path and therefore test this without using mock objects, the mock object version makes no such assumptions and therefore works the same in either case.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;User has &lt;code&gt;Geo::IP&lt;/code&gt; and the Geo-IP city data installed correctly.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Test::More tests =&amp;gt; 7;
use Test::MockObject;

my $mock = Test::MockObject-&amp;gt;new();
$mock-&amp;gt;fake_module(&#39;Geo::IP&#39; =&amp;gt; (
    &#39;open&#39;           =&amp;gt; sub { $mock },
    &#39;GEOIP_STANDARD&#39; =&amp;gt; sub { 0 }
));

my $mock_record = Test::MockObject-&amp;gt;new();
$mock_record-&amp;gt;set_always(&#39;city&#39;, &#39;New York City&#39;);

$mock-&amp;gt;set_always(&#39;record_by_addr&#39;, $mock_record);

use_ok(&#39;Site::Member&#39;);

my $u = Site::Member-&amp;gt;new();
isa_ok($u, &#39;Site::Member&#39;);

$u-&amp;gt;ip_address(&#39;64.40.146.219&#39;);

is($u-&amp;gt;city(), &#39;New York City&#39;, &#39;... got the right city&#39;);

cmp_ok($mock-&amp;gt;call_pos(&#39;record_by_addr&#39;), &#39;==&#39;, 0,
        &#39;... our mock object was called&#39;);
is_deeply(
        [ $mock-&amp;gt;call_args(0) ],
        [ $mock, &#39;64.40.146.219&#39; ],
        &#39;... our mock was called with the right args&#39;);

cmp_ok($mock_record-&amp;gt;call_pos(&#39;city&#39;), &#39;==&#39;, 0,
        &#39;... our mock record object was called&#39;);
is_deeply(
        [ $mock_record-&amp;gt;call_args(0) ],
        [ $mock_record ],
        &#39;... our mock record was called with the right args&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This next case illustrates a success case, where &lt;code&gt;Geo::IP&lt;/code&gt; finds the database file it wants and returns the expected results.&lt;/p&gt;

&lt;p&gt;Once again, the &lt;code&gt;fake_module&lt;/code&gt; method of &lt;code&gt;Test::MockObject&lt;/code&gt; mocks &lt;code&gt;Geo::IP&lt;/code&gt;&amp;rsquo;s &lt;code&gt;open&lt;/code&gt; method, this time returning the &lt;code&gt;$mock&lt;/code&gt; instance itself. The code creates another mock object, this time for the &lt;code&gt;Geo::IP::Record&lt;/code&gt; instance which &lt;code&gt;Geo::IP&lt;/code&gt;&amp;rsquo;s &lt;code&gt;record_by_addr&lt;/code&gt; returns. &lt;code&gt;Test::MockObject&lt;/code&gt;&amp;rsquo;s &lt;code&gt;set_always&lt;/code&gt; method mocks the &lt;code&gt;city&lt;/code&gt; method for the &lt;code&gt;$mock_record&lt;/code&gt; instance. After this, &lt;code&gt;Geo::IP&lt;/code&gt;&amp;rsquo;s &lt;code&gt;record_by_addr&lt;/code&gt; is mocked to return the &lt;code&gt;$mock_record&lt;/code&gt; instance. With all of these mocks in place, the tests then run. After that, inspecting the mock objects ensures that the code called the correct methods on the mocked objects in the correct order and with the correct arguments.&lt;/p&gt;

&lt;p&gt;This example illustrates testing success without needing to worry about the existence of an outside dependency. &lt;code&gt;Test::MockObject&lt;/code&gt; supports taking this test one step further and providing methods for inspecting the details of the interaction between the example code and that of the mocked &lt;code&gt;Geo::IP&lt;/code&gt; module. Accomplishing this test without &lt;code&gt;Test::MockObject&lt;/code&gt; would be almost impossible given the lack of control over the &lt;code&gt;Geo::IP&lt;/code&gt; module and its internals.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Mock objects can seem complex and overly abstract at first, but once grasped they can be a simple, clean way to make hard things easy. I hope to have shown how creating simple and minimal mock object with &lt;code&gt;Test::MockObject&lt;/code&gt; can help in testing cases which might be difficult using more traditional means.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Perl Code Kata: Testing Imports</title>
      <link>http://localhost:1313/pub/2004/12/16/import_kata.html/</link>
      <pubDate>Thu, 16 Dec 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/12/16/import_kata.html/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/10/21/taint_testing_kata.html&#34;&gt;Perl Taint Test Kata&lt;/a&gt; introduced the idea of Perl Test Kata, small exercises designed to improve your understanding of Perl and your ability to write test-driven code. This article is the second in the series.&lt;/p&gt;

&lt;h3 id=&#34;import-testing-kata&#34;&gt;Import Testing Kata&lt;/h3&gt;

&lt;p&gt;Perl 5 added the ideas of namespaces and modules, making code reusable and easier to maintain. To allow convenience, it also added an importing mechanism to put code from a module into the current namespace.&lt;/p&gt;

&lt;p&gt;Behind the scenes, when you &lt;code&gt;use&lt;/code&gt; a module, Perl loads it from disk and, if successful, calls the special method &lt;code&gt;import()&lt;/code&gt;. By convention, this generally imports functions. Much of the time, &lt;code&gt;import()&lt;/code&gt; mundanely installs subroutines into the current namespace. That&amp;rsquo;s why so many modules use Exporter to provide a default &lt;code&gt;import()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;However, it&amp;rsquo;s also a general module-loading hook that can perform many different types of manipulations. For example, &lt;a href=&#34;https://metacpan.org/pod/Filter::Simple&#34;&gt;Filter::Simple&lt;/a&gt; allows the use of source filters to transform code that looks entirely unlike Perl into valid code in the using module. Other modules change their behavior depending on any arguments passed to &lt;code&gt;import()&lt;/code&gt;. This includes &lt;a href=&#34;https://metacpan.org/pod/Test::More&#34;&gt;Test::More&lt;/a&gt; and &lt;a href=&#34;https://metacpan.org/pod/Test::Simple&#34;&gt;Test::Simple&lt;/a&gt;, which interpret their arguments as information about how many tests to run.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Test::More &#39;no_plan&#39;;

# or

use Test::More tests =&amp;gt; 100;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This feature is both powerful and important. Because of its importance, it needs good tests. Because of its power and flexibility, it may seem difficult to test an &lt;code&gt;import()&lt;/code&gt; well. Here are three sample implementations for you to practice testing.&lt;/p&gt;

&lt;h4 id=&#34;basic-exporting&#34;&gt;Basic Exporting&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package Basic::Exports;

use strict;

use base &#39;Exporter&#39;;
use vars &#39;@EXPORT&#39;;

@EXPORT = qw( foo bar );

sub foo { &#39;foo&#39; }
sub bar { &#39;bar&#39; }

1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The tests should check that using Basic::Exports exports &lt;code&gt;foo()&lt;/code&gt; and &lt;code&gt;bar()&lt;/code&gt; to the appropriate namespace and that they return the appropriate values. Another test is that the code &lt;code&gt;use Basic::Exports ();&lt;/code&gt; exports &lt;em&gt;neither&lt;/em&gt; function.&lt;/p&gt;

&lt;h4 id=&#34;optional-exports&#34;&gt;Optional Exports&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;package Optional::Exports;

use strict;

use base &#39;Exporter&#39;;
use vars &#39;@EXPORT_OK&#39;;

@EXPORT_OK = qw( foo bar baz );

sub foo { &#39;foo&#39; }
sub bar { &#39;bar&#39; }
sub baz { &#39;baz&#39; }

1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The tests should check that Optional::Exports exports nothing by default and only those functions named, if there are any.&lt;/p&gt;

&lt;h4 id=&#34;load-time-behavior&#34;&gt;Load-time Behavior&lt;/h4&gt;

&lt;p&gt;A few modules have curious behavior. My Pod::ToDemo behaves differently when invoked from the command line versus when used within a module. This makes it substantially more difficult to test. Rather than make you reinvent the tests there, here&amp;rsquo;s a simpler custom &lt;code&gt;import()&lt;/code&gt; that does different things based on its invocation. If invoked from the command line, it prints a message to standard output. If used from a module, it exports the same &lt;code&gt;foo()&lt;/code&gt; subroutine as before.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package Export::Weird;

use strict;

sub import
{
    my ($package, undef, $line) = caller();

    if ( $line == 0 )
    {
        print &amp;quot;Invoked from command-line\n&amp;quot;;
    }
    else
    {
        no strict &#39;refs&#39;;
        *{ $package . &#39;::foo&#39; } = sub { &#39;foo&#39; };
    }
}

1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only really tricky test here must exercise the behavior of the module when invoked from the command line. Assume that the documentation of the module suggests invoking it via:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl -MExport::Weird -e 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next page explains some techniques for testing these examples. For best results, spend between 30 and 45 minutes working through the kata on your own before looking at the hints. For more information on how modules, &lt;code&gt;use&lt;/code&gt;, and &lt;code&gt;require&lt;/code&gt; work, see &lt;code&gt;perldoc perlmod&lt;/code&gt; and &lt;code&gt;perldoc perlfunc&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;tips-tricks-and-suggestions&#34;&gt;Tips, Tricks, and Suggestions&lt;/h3&gt;

&lt;p&gt;If you&amp;rsquo;ve worked your way through writing tests for the three examples, here are the approaches I would take. They&amp;rsquo;re not the only ways to test these examples, but they do work. First, here is some background information on what&amp;rsquo;s happening.&lt;/p&gt;

&lt;h4 id=&#34;reloading&#34;&gt;Reloading&lt;/h4&gt;

&lt;p&gt;To test &lt;code&gt;import()&lt;/code&gt; properly, you must understand its implications. When Perl encounters a &lt;code&gt;use module;&lt;/code&gt; statement, it executes a two-step process &lt;em&gt;immediately&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BEGIN
{
    require module;
    module-&amp;gt;import();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can subvert both of these processes. To force Perl to reload a module, you can delete its entry from &lt;code&gt;%INC&lt;/code&gt;. Note that all of the keys of this special hash represent pathnames in Unix format. For example, even if you use Windows or VMS or Mac OS 9 or earlier, loading Filter::Simple successfully should result in &lt;code&gt;%INC&lt;/code&gt; containing a true value for the key of &lt;code&gt;Filter/Simple.pm&lt;/code&gt;. (You may also want to use the &lt;code&gt;delete_package()&lt;/code&gt; function of the Symbol module to clear out the namespace, though beware of the caveats there.) Now you can &lt;code&gt;require&lt;/code&gt; the module again.&lt;/p&gt;

&lt;h4 id=&#34;re-importing&#34;&gt;Re-importing&lt;/h4&gt;

&lt;p&gt;Next, you&amp;rsquo;ll have to call &lt;code&gt;import()&lt;/code&gt; manually. It&amp;rsquo;s a normal class method call, however, so you can provide all of the arguments as you would to a function or method call.&lt;/p&gt;

&lt;p&gt;You can also switch packages, though make sure that you qualify any calls to Test::* module functions appropriately:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package Some::Other::Package;

module-&amp;gt;import( @args );

main::ok( 1, &#39;some test label&#39; );

# or 

::ok( 1, &#39;some test label&#39; );
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;testing-exports&#34;&gt;Testing Exports&lt;/h4&gt;

&lt;p&gt;There are at least two techniques for checking the import of functions. One is the use of the &lt;code&gt;defined&lt;/code&gt; keyword and the other is through the &lt;code&gt;can()&lt;/code&gt; class method. For example, tests for Example #1 might be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use_ok( &#39;Basic::Exports&#39; );
ok( defined &amp;amp;foo,              &#39;module should export foo()&#39; )
ok( __PACKAGE__-&amp;gt;can( &#39;bar&#39; ), &#39;... and should export bar()&#39; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To test that these are the right functions, call them as normal and check their return values.&lt;/p&gt;

&lt;p&gt;By the way, the presence of the &lt;code&gt;__PACKAGE__&lt;/code&gt; symbol there allows this test to take place in other namespaces. If you haven&amp;rsquo;t imported the &lt;code&gt;ok()&lt;/code&gt; test function into this namespace, remember to qualify it, import it manually, or alias it so that the test program will itself run. (It may fail, which is fine, but errors in your tests are difficult and embarrassing to fix.)&lt;/p&gt;

&lt;h4 id=&#34;testing-non-exports&#34;&gt;Testing Non-Exports&lt;/h4&gt;

&lt;p&gt;It&amp;rsquo;s difficult to prove a negative conclusively, but if you reverse the condition of a test, you can have good confidence that the module hasn&amp;rsquo;t provided anything unwanted.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use_ok( &#39;Optional::Exports&#39; );
ok( ! __PACKAGE__-&amp;gt;can( &#39;foo&#39; ),
    &#39;module should not export foo() by default&#39; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only tricky part of the tests here is in trying to import functions again. Call &lt;code&gt;import()&lt;/code&gt; explicitly as a class method of the module. Switching packages within the test can make this easier; you don&amp;rsquo;t have to unload the module if you do this.&lt;/p&gt;

&lt;h4 id=&#34;testing-weird-exports&#34;&gt;Testing Weird Exports&lt;/h4&gt;

&lt;p&gt;The easist way to test an &lt;code&gt;import()&lt;/code&gt; function that relies on command-line invocation or produces weird side effects that you may not want to handle in your current program is to launch it as a separate program. There are plenty of options for this, from &lt;code&gt;system&lt;/code&gt; to &lt;code&gt;fork&lt;/code&gt; and &lt;code&gt;exec&lt;/code&gt; to tricks with pipes and shell redirection. &lt;a href=&#34;https://metacpan.org/pod/IPC::Open3&#34;&gt;IPC::Open3&lt;/a&gt; is one good approach, if you want to use it in your test suite:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#! perl

use strict;
use warnings;

use blib;
use IPC::Open3;

use Test::More tests =&amp;gt; 3;

use_ok( &#39;Export::Weird&#39; );

my $pid = open3(
    undef, my $reader, undef,
    $^X, &#39;-Mblib&#39;, &#39;-MExport::Weird&#39;, &#39;-e&#39;, &#39;1&#39;
);

my @out = &amp;lt;$reader&amp;gt;;
is( @out,                                1,
    &#39;cli invocation should print one line&#39; );
is( $out[0], &amp;quot;Invoked from command-line\n&amp;quot;,
    &#39;... with the right message&#39; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$^X&lt;/code&gt; represents the path to the Perl binary currently executing this program. The &lt;code&gt;-Mblib&lt;/code&gt; switch loads the &lt;code&gt;blib&lt;/code&gt; module to set &lt;code&gt;@INC&lt;/code&gt; in the program appropriately. Depending on how you&amp;rsquo;ve set up your directories and invoke this program, you may have to change this. The other commands follow the invocation scheme given in Example #3.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;You should now have several ideas on how to test &lt;code&gt;import()&lt;/code&gt; methods of various kinds. For more details, read the tests of &lt;a href=&#34;https://metacpan.org/pod/Pod::ToDemo&#34;&gt;Pod::ToDemo&lt;/a&gt; or &lt;a href=&#34;https://metacpan.org/pod/Test::Builder&#34;&gt;Test::Builder&lt;/a&gt;, which play strange games to achieve good test coverage.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;ve found a differently workable approach, I&amp;rsquo;d like to hear from you. Also, if you have suggestions for another kata (or would like to write one), please let me know.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;chromatic is the author of &lt;a href=&#34;http://onyxneon.com/books/modern_perl/&#34;&gt;Modern Perl&lt;/a&gt;. In his spare time, he has been working on &lt;a href=&#34;https://trendshare.org/how-to-invest/&#34;&gt;helping novices understand stocks and investing&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Perl Code Kata: Testing Taint</title>
      <link>http://localhost:1313/pub/2004/10/21/taint_testing_kata.html/</link>
      <pubDate>Thu, 21 Oct 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/10/21/taint_testing_kata.html/</guid>
      <description>

&lt;p&gt;To be a better programmer, practice programming.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s not enough to practice, though. You must practice well and persistently. You need to explore branches and ideas and combinations as they come to your attention. Set aside some time to experiment with a new idea to see what you can learn and what you can use in your normal programming.&lt;/p&gt;

&lt;p&gt;How do you find new ideas? One way is through &lt;a href=&#34;https://pragprog.com/pragdave/Practices/CodeKata.rdoc&#34;&gt;code katas&lt;/a&gt;, short pieces of code that start your learning.&lt;/p&gt;

&lt;p&gt;This article is the first in a series of code kata for Perl programmers. All of these exercises take place in the context of writing tests for Perl programs.&lt;/p&gt;

&lt;p&gt;Why give examples in the context of testing? First, to promote the idea of writing tests. One of the best techniques of writing good, simple, and effective software is to practice test-driven development. Second, because writing tests well is challenging. It often pushes programmers to find creative solutions to difficult problems.&lt;/p&gt;

&lt;h3 id=&#34;taint-testing-kata-1&#34;&gt;Taint Testing Kata #1&lt;/h3&gt;

&lt;p&gt;One of Perl&amp;rsquo;s most useful features is the idea of tainting. If you enable taint mode, Perl will mark every piece of data that comes from an insecure source, such as insecure input, with a taint flag. If you want to use a piece of tainted data in a potentially dangerous way, you must untaint the data by verifying it.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://metacpan.org/pod/CGI::Untaint&#34;&gt;CGI::Untaint&lt;/a&gt; module family makes this process much easier for web programs â€” which often need the most taint protection. There are modules to untaint dates, email addresses, and credit card numbers.&lt;/p&gt;

&lt;p&gt;Recently, I wrote &lt;a href=&#34;https://metacpan.org/pod/CGI::Untaint::boolean&#34;&gt;CGI::Untaint::boolean&lt;/a&gt; to untaint data that comes from checkboxes in web forms. It&amp;rsquo;s a simple module, taking fewer than 20 lines of sparse code that untaints any incoming data and translates a form value of &lt;code&gt;on&lt;/code&gt; into a true value and anything else (including a non-existent parameter) into false.&lt;/p&gt;

&lt;p&gt;Writing the tests proved to be slightly more difficult. How could I make sure that the incoming parameter provided to the module was tainted properly? How could I make sure that the module untaints it properly?&lt;/p&gt;

&lt;p&gt;Given the code for CGI::Untaint::boolean, how would you write the tests?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package CGI::Untaint::boolean;

use strict;

use base &#39;CGI::Untaint::object&#39;;

sub _untaint_re { qr/^(on)$/ }

sub is_valid
{
    my $self  = shift;
    my $value = $self-&amp;gt;value();

    return unless $value and $value =~ $self-&amp;gt;_untaint_re();

    $self-&amp;gt;value( $value eq &#39;on&#39; ? 1 : 0 );
    return 1;
}

1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Your code should check that it passes in a tainted value and that it receives an untainted value. You should also verify that the resulting value, when extracted from the handler, is not tainted, no matter its previous status.&lt;/p&gt;

&lt;p&gt;Write using one of Perl&amp;rsquo;s core test modules. I prefer &lt;a href=&#34;https://metacpan.org/pod/Test::Simple&#34;&gt;Test::Simple&lt;/a&gt; and &lt;a href=&#34;https://metacpan.org/pod/CGI::Untaint::boolean&#34;&gt;Test::More&lt;/a&gt;, but if you must use &lt;a href=&#34;https://metacpan.org/pod/Test&#34;&gt;Test&lt;/a&gt;, go ahead. Assume that &lt;a href=&#34;https://metacpan.org/pod/Test::Harness&#34;&gt;Test::Harness&lt;/a&gt; will honor the &lt;code&gt;-T&lt;/code&gt; flag passed on the command line.&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t read the tests that come with CGI::Untaint::boolean unless you&amp;rsquo;re really stuck. The next section has a further explanation of that technique. For best results, spend at least 30 minutes working through the kata on your own before looking at the hints.&lt;/p&gt;

&lt;h3 id=&#34;tips-tricks-suggestions-and-one-solution&#34;&gt;Tips, Tricks, Suggestions, and One Solution&lt;/h3&gt;

&lt;p&gt;To test tainting properly, you must understand its effects. When Perl sees the &lt;code&gt;-T&lt;/code&gt; or &lt;code&gt;-t&lt;/code&gt; flags, it immediately marks some of its data and environment as tainted. This includes the &lt;code&gt;PATH&lt;/code&gt; environment variable.&lt;/p&gt;

&lt;p&gt;Also, taint is sticky. If you use a piece of tainted data in an expression, it will taint the results of that expression.&lt;/p&gt;

&lt;p&gt;Both of those facts make it easy to find a source of taint. CGI::Untaint::boolean&amp;rsquo;s do the following to make tainted data:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $tainted_on = substr( &#39;off&#39; . $ENV{PATH}, 0, 3 );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Concatenating the clean string &lt;code&gt;off&lt;/code&gt; with the tainted value of the &lt;code&gt;PATH&lt;/code&gt; environment variable produces a tainted string. The &lt;code&gt;substr()&lt;/code&gt; expression then returns the equivalent of original string with tainting added.&lt;/p&gt;

&lt;p&gt;How can you tell if a variable holds a tainted value? The Perl FAQ gives one solution that attempts to perform an unsafe operation with tainted data, but I prefer the &lt;a href=&#34;https://metacpan.org/pod/Scalar::Util&#34;&gt;Scalar::Util&lt;/a&gt; module&amp;rsquo;s &lt;code&gt;tainted()&lt;/code&gt; function. It&amp;rsquo;s effectively the same thing, but I don&amp;rsquo;t have to remember any abnormal details.&lt;/p&gt;

&lt;p&gt;This technique does rely on Test::Harness launching the test program with the &lt;code&gt;-T&lt;/code&gt; flag. If that&amp;rsquo;s not an option, the test program itself could launch other programs with that flag, using the &lt;code&gt;$^X&lt;/code&gt; variable to find the path of the currently executing Perl. It may be worthwhile to check that the &lt;code&gt;-T&lt;/code&gt; flag is in effect before skipping the rest of the tests or launching a new process and reporting its results.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;prove&lt;/code&gt; utility included with recent versions of Test::Harness may come in handy; launch the test with &lt;code&gt;prove -T testfile.t&lt;/code&gt; to run under taint mode. See &lt;code&gt;perldoc prove&lt;/code&gt; for more information.&lt;/p&gt;

&lt;p&gt;You could also use this approach to launch programs designed to abort if the untainting fails, checking for exit codes automatically. It seems much easier to use Scalar::Util though.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;This should give you everything you need to solve the problem. Check your code against the tests for CGI::Untaint::boolean.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;ve found a differently workable approach, I&amp;rsquo;d like to hear from you. Also, if you have suggestions for another kata (or would like to write one), please let me know.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;chromatic is the author of &lt;a href=&#34;http://onyxneon.com/books/modern_perl/&#34;&gt;Modern Perl&lt;/a&gt;. In his spare time, he has been working on &lt;a href=&#34;https://trendshare.org/how-to-invest/&#34;&gt;helping novices understand stocks and investing&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building Testing Libraries</title>
      <link>http://localhost:1313/pub/2004/05/07/testing.html/</link>
      <pubDate>Fri, 07 May 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/05/07/testing.html/</guid>
      <description>

&lt;p&gt;Testing is an important step in developing any important body of work. In today&amp;rsquo;s pragmatic culture, we&amp;rsquo;re taught to test first, test often, and design with tests. The expectation is that chanting &amp;ldquo;test test test&amp;rdquo; forgives all sins. To a large extent, this is true. Testing helps us produce quality software at all scales.&lt;/p&gt;

&lt;p&gt;The extreme code produced by this extreme lifestyle hides in the test suite itself. Often the ugliest code we write resides in files with a .t extension. Riddled with redundant, ghastly expressions, the test suite is the collateral damage on our road to beautiful production code.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s review some common pitfalls made when testing. Many of these testing procedures may be new to you. Serious headway has been made in recent history with the testing libraries on the CPAN.&lt;/p&gt;

&lt;h3 id=&#34;span-id-a-test-file-is-just-a-program-a-test-file-is-just-a-program-span&#34;&gt;&lt;span id=&#34;A_Test_File_is_Just_a_Program&#34;&gt;A Test File is Just a Program&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Each test file is a program, just as important as any other program you&amp;rsquo;d write that uses software being tested. It must be treated with the same care. If you plan to use &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;warnings&lt;/code&gt; in a program related to the code you&amp;rsquo;re testing, be sure to do the same in your tests.&lt;/p&gt;

&lt;p&gt;Each test file should start with these three lines.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #!/path/to/perl
  use strict;
  use warnings;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you plan to run your software in a taint-checked environment, which is considered a good idea, then supply the &lt;code&gt;-T&lt;/code&gt; command-line option to the &lt;code&gt;#!&lt;/code&gt; line.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #!/path/to/perl -T
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will ensure that you won&amp;rsquo;t make syntactic mistakes in your test files. It will also require your software to work correctly in a restricted environment.&lt;/p&gt;

&lt;h3 id=&#34;span-id-be-compatible-with-test-harness-be-compatible-with-test-harness-span&#34;&gt;&lt;span id=&#34;Be_Compatible_with_Test::Harness&#34;&gt;Be Compatible with &lt;code&gt;Test::Harness&lt;/code&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Test::Harness&lt;/code&gt; is a very useful Perl module for running test suites. If you are building a Perl module yourself, and using &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; or &lt;code&gt;Module::Build&lt;/code&gt; for the build process, you&amp;rsquo;re using &lt;code&gt;Test::Harness&lt;/code&gt;. If you aren&amp;rsquo;t using any of these mechanisms, do try to be compatible with it. This will help other users and developers of your software who are used to dealing with &lt;code&gt;Test::Harness&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Compatibility comes in the form of the test file&amp;rsquo;s output. &lt;code&gt;Test::Harness&lt;/code&gt; will run your program and record its output to &lt;code&gt;STDOUT&lt;/code&gt;. Anything sent to &lt;code&gt;STDERR&lt;/code&gt; is ignored, silently passed on to the user. There are particulars about testing under the harness that should be observed. The basics are simple.&lt;/p&gt;

&lt;p&gt;When a test passes, it outputs a line containing &lt;code&gt;ok $N&lt;/code&gt;, where &lt;code&gt;$N&lt;/code&gt; is the test number. When a test fails, the line contains &lt;code&gt;not ok $N&lt;/code&gt;. Test numbers are optional but recommended. Tests may be named. Anything after the number, &lt;code&gt;$N&lt;/code&gt;, is considered the test name, up to a hash (&lt;code&gt;#&lt;/code&gt;). Anything following the hash is a comment.&lt;/p&gt;

&lt;p&gt;Furthermore, you are encouraged to supply a header. The header tells &lt;code&gt;Test::Harness&lt;/code&gt; how many tests you expect to run and should be the first thing you output. If you&amp;rsquo;re unsure of the number of tests, the header may be the very last thing output. Its format is also simple: &lt;code&gt;1..$M&lt;/code&gt;, where &lt;code&gt;$M&lt;/code&gt; is the total number of tests to run. The header helps the harness figure out how well your tests did.&lt;/p&gt;

&lt;p&gt;Any other output should be commented on lines beginning with a hash (&lt;code&gt;#&lt;/code&gt;). Here is an example of prototypical output understood by &lt;code&gt;Test::Harness&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  1..4
  ok 1 - use Software::Module
  ok 2 - object isa Software::Module
  not ok 3 - $object-&amp;gt;true() should return true
  #     Failed test (test.t)
  #          got: undef
  #     expected: 1
  ok 4 # skip Net::DNS required for this test
  # Looks like you failed 1 tests of 4.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-use-a-testing-module-use-a-testing-module-span&#34;&gt;&lt;span id=&#34;Use_a_Testing_Module&#34;&gt;Use a Testing Module&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;A simple way to achieve &lt;code&gt;Test::Harness&lt;/code&gt; compatibility is to use a testing module from the CPAN. Many test suites over the years have reinvented the &lt;code&gt;ok()&lt;/code&gt; function, for example.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  {
    my $N = 1;
    sub ok($;$) {
        my ($test, $name) = @_;
        print &amp;quot;not &amp;quot; unless $test;
        print &amp;quot;ok $N - $name\n&amp;quot;;
        $N++;
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is no need to do this, however. The standard Perl distribution comes with testing modules. Two great options are &lt;code&gt;Test::Simple&lt;/code&gt; and &lt;code&gt;Test::More&lt;/code&gt;. &lt;code&gt;Test::Simple&lt;/code&gt; is a great way to get your feet wet; it implements only the &lt;code&gt;ok()&lt;/code&gt; function. &lt;code&gt;Test::More&lt;/code&gt; has more features and is recommended when you write your test suites.&lt;/p&gt;

&lt;p&gt;Using &lt;code&gt;Test::More&lt;/code&gt; is very simple; many have written on the subject. This is how you would achieve the output described in the previous section.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #!/usr/bin/perl -T
  use strict;
  use warnings;
  use Test::More tests =&amp;gt; 4;

  use_ok &#39;Software::Module&#39;;
  my $object = Software::Module-&amp;gt;new;
  isa_ok $object, &#39;Software::Module&#39;, &#39;object&#39;;
  cmp_ok $object-&amp;gt;true, 1, &#39;$object-&amp;gt;true() should return true&#39;;

  SKIP: {
      skip 1, &amp;quot;Net::DNS required for this test&amp;quot;
        unless eval &#39;require Net::DNS&#39;;

      ok $object-&amp;gt;network(), &amp;quot;run over network&amp;quot;;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-don-t-iterate-compare-don-t-iterate-compare-span&#34;&gt;&lt;span id=&#34;Don&#39;t_Iterate,_Compare&#34;&gt;Don&amp;rsquo;t Iterate, Compare&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;ve often seen tests that loop over a list and check each item to be sure the list is correct. While this approach makes you feel good, artificially adding to the number of tests you&amp;rsquo;ve written, it can be sloppy and long-winded. Here is an example.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my @fruits = qw[apples oranges grapes];
  my @result = get_fruits();
  foreach my $n ( 0 .. $#fruits ) {
      is $result[$n], $fruits[$n], &amp;quot;$fruits[$n] in slot $n&amp;quot;;
  }
  is scalar(@result), scalar(@fruits), &amp;quot;fruits the same size&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It looks like four tests were written; the reality is that one test was written poorly. &lt;code&gt;Test::More&lt;/code&gt; has several utility functions to get the job done. In this test, &lt;code&gt;@fruits&lt;/code&gt; represents a set of non-repeatable &lt;code&gt;fruits&lt;/code&gt; I expect to get back from &lt;code&gt;get_fruits()&lt;/code&gt;. As such, I can use &lt;code&gt;eq_set()&lt;/code&gt; to test this function in one quick try.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my @fruits = qw[apples oranges grapes];
  my @result = get_fruits();
  ok eq_set(\@result, \@fruits), &amp;quot;got [@fruits]&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That was easy and short. But what happens when you have a deep data structure that you&amp;rsquo;re dying to test? That&amp;rsquo;s where &lt;code&gt;Test::Deep&lt;/code&gt; comes in. Downloadable from the CPAN, this module provides the &lt;code&gt;cmp_deeply()&lt;/code&gt; function. Here is a simple example.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use Test::Deep;
  my $people = [
    {
      name     =&amp;gt; &amp;quot;Casey West&amp;quot;,
      employer =&amp;gt; &amp;quot;pair Networks&amp;quot;,
    },
    {
      name     =&amp;gt; &amp;quot;Larry Wall&amp;quot;,
      employer =&amp;gt; &amp;quot;The Perl Foundation&amp;quot;,
    },
  ];

  my $result = $dude-&amp;gt;contacts-&amp;gt;retrieve_all;

  cmp_deeply $result, $people, &#39;contacts match&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example scratched the surface of what &lt;code&gt;Test::Deep&lt;/code&gt; is capable of. When you&amp;rsquo;ve got to test a complex data structure, especially in a complex way, use this module. Here is a more difficult example made testable by this module. In this example, &lt;code&gt;$dude-&amp;gt;contacts-&amp;gt;retrieve_all&lt;/code&gt; returns an unordered list of contacts with various bits of information associated with each of them.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use Test::Deep;
  my $person = {
    name     =&amp;gt; re(&amp;quot;^[\w\s]+$&amp;quot;),
    employer =&amp;gt; ignore(),
    age      =&amp;gt; code(sub { shift &amp;gt; 18 }),
  };
  my $people = array_each($person);
  my $result = $dude-&amp;gt;contacts-&amp;gt;retrieve_all;

  cmp_deeply $result, $people, &#39;contacts match&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code, using only functions exported by &lt;code&gt;Test::Deep&lt;/code&gt;, does a lot of work. Each person has a definition that should match &lt;code&gt;$person&lt;/code&gt;. Every person in the &lt;code&gt;$result&lt;/code&gt; list is a hash reference containing three elements. &lt;code&gt;name&lt;/code&gt; must match the regular expression &lt;code&gt;/^[\w\s]+$/&lt;/code&gt;, &lt;code&gt;employer&lt;/code&gt; must exist and its value is ignored, and &lt;code&gt;age&lt;/code&gt; should be over &lt;code&gt;18&lt;/code&gt; or it will fail. &lt;code&gt;array_each()&lt;/code&gt; returns an object that instructs &lt;code&gt;cmp_deeply&lt;/code&gt; that every value in a list must match the definition provided.&lt;/p&gt;

&lt;p&gt;This small amount of code accomplishes quite a lot. &lt;code&gt;Test::Deep&lt;/code&gt; has saved us from wasting time and working hard to solve a difficult problem. It has made the hard things possible.&lt;/p&gt;

&lt;h3 id=&#34;span-id-don-t-let-pod-go-unchecked-don-t-let-pod-go-unchecked-span&#34;&gt;&lt;span id=&#34;Don&#39;t_Let_POD_go_Unchecked&#34;&gt;Don&amp;rsquo;t Let POD go Unchecked&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Documentation is just as important as code, or tests. There are several ways to care for POD in your test suite. First, it&amp;rsquo;s important to keep it well-formed. For this, we turn to &lt;code&gt;Test::Pod&lt;/code&gt;. This Perl module takes all the work out of testing POD with a useful function &lt;code&gt;all_pod_files_ok()&lt;/code&gt;. Simply create a new test program with the following contents.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use Test::More;
  plan skip_all =&amp;gt; &amp;quot;Test::Pod 1.00 required for testing POD&amp;quot;
    unless eval &amp;quot;use Test::Pod 1.00&amp;quot;;
  all_pod_files_ok();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yes, it really is that simple. When you run this program, it will test all the POD it finds in your &lt;em&gt;blib&lt;/em&gt; directory.&lt;/p&gt;

&lt;p&gt;Another simple test we can run on the documentation is coverage analysis. What good is documentation if it doesn&amp;rsquo;t document completely? &lt;code&gt;Test::Pod::Coverage&lt;/code&gt; is the right module for the job, yet another gem that hides all the hard work from us with a simple function, &lt;code&gt;all_pod_coverage_ok()&lt;/code&gt;. Again, we&amp;rsquo;ll create a new test program.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use Test::More;
  plan skip_all =&amp;gt; &amp;quot;Test::Pod::Coverage 1.08 required for testing POD coverage&amp;quot;
    unless eval &amp;quot;use Test::Pod::Coverage 1.08&amp;quot;;
  all_pod_coverage_ok();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Coverage is only half of the battle. Remember, &lt;code&gt;Test::Pod::Coverage&lt;/code&gt; can&amp;rsquo;t tell you if your documentation is actually correct and thorough.&lt;/p&gt;

&lt;p&gt;In both of these examples, we use the &lt;code&gt;plan&lt;/code&gt; function exported from &lt;code&gt;Test::More&lt;/code&gt; to allow us to &amp;ldquo;bail out&amp;rdquo; of our tests if the appropriate Perl module isn&amp;rsquo;t installed. This makes our POD tests optional. If you don&amp;rsquo;t want them to be optional, remove that line and be sure to list them as prerequisites for building and installing your software.&lt;/p&gt;

&lt;h3 id=&#34;span-id-know-what-you-re-testing-know-what-you-re-testing-span&#34;&gt;&lt;span id=&#34;Know_What_You&#39;re_Testing&#34;&gt;Know What You&amp;rsquo;re Testing&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;One of the biggest testing mistakes is to assume that you know what you&amp;rsquo;re testing. Tests are designed to exercise your software. Let your test exercise the good and bad portions of your software. Make it succeed and, most importantly, make it fail. Superior test coverage digs deep into every line of code you&amp;rsquo;ve written. How do you know if your tests are amazing? Coverage analysis.&lt;/p&gt;

&lt;p&gt;Code coverage isn&amp;rsquo;t something you can guess; you need good tools. Perl has a good tool: &lt;code&gt;Devel::Cover&lt;/code&gt;. This module creates a database that maps actual execution to your source code. It analyzes statements, branches, conditions, subroutines, and even POD and execution time. It then provides a total for all of these areas, as well as a total for each Perl module. It&amp;rsquo;s very simple to use, adding just a little to your &lt;code&gt;make test&lt;/code&gt; process.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;gt; cover -delete
  &amp;gt; HARNESS_PERL_SWITCHES=-MDevel::Cover make test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first command deletes any existing coverage database. On the second line we set an environment variable for &lt;code&gt;Test::Harness&lt;/code&gt;, &lt;code&gt;HARNESS_PERL_SWITCHES&lt;/code&gt; to a Perl command-line switch that imports &lt;code&gt;Devel::Caller&lt;/code&gt;. This is all that&amp;rsquo;s required of you. Each of your test programs will now run with &lt;code&gt;Devel::Caller&lt;/code&gt; loaded and analyzing execution in the background.&lt;/p&gt;

&lt;p&gt;To see your coverage database on the command line, issue one command.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;gt; cover
  ---------------------------- ------ ------ ------ ------ ------ ------ ------
  File                           stmt branch   cond    sub    pod   time  total
  ---------------------------- ------ ------ ------ ------ ------ ------ ------
  blib/lib/List/Group.pm         94.7   66.7   33.3  100.0  100.0  100.0   81.6
  Total                          94.7   66.7   33.3  100.0  100.0  100.0   81.6
  ---------------------------- ------ ------ ------ ------ ------ ------ ------

  Writing HTML output to ~/cvs/perl/modules/List-Group/cover_db/coverage.html ...
  done.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, I could&amp;rsquo;ve done better. But what did I fail to test? Notice that &lt;code&gt;cover&lt;/code&gt; wrote some HTML output. That is the diamond in the rough; the HTML output details everything. Each module has its own series of web pages detailing each of the coverage groups. I did particularly poorly on the conditional coverage &amp;ndash; let&amp;rsquo;s see how.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2004_05_07_testing/figure1.jpg&#34; width=&#34;405&#34; height=&#34;290&#34; /&gt;
Now it&amp;rsquo;s become clear. My tests never allow either of the two statements in this condition to succeed. All of my tests make the first statement fail; the second is never executed. I need to update my tests with at least two more for &lt;code&gt;100.0&lt;/code&gt; conditional coverage. The first test will supply a non-number for the &lt;code&gt;$number&lt;/code&gt; variable. The second will supply a value for the &lt;code&gt;$group_by&lt;/code&gt; variable that doesn&amp;rsquo;t exist in the list for which &lt;code&gt;grep&lt;/code&gt; is looking.&lt;/p&gt;

&lt;p&gt;Testing for coverage is a noble goal. I find this method very useful when writing tests for existing software. There are many situations you may think you&amp;rsquo;re testing well. Don&amp;rsquo;t guess; know. Coverage analysis is equally useful for new development. If you&amp;rsquo;ve adopted the &amp;ldquo;test first&amp;rdquo; method and your coverage isn&amp;rsquo;t 100 percent, something is wrong. Either your tests need help, or you&amp;rsquo;ve written more code than originally required.&lt;/p&gt;

&lt;h3 id=&#34;span-id-keep-test-files-organized-keep-test-files-organized-span&#34;&gt;&lt;span id=&#34;Keep_Test_Files_Organized&#34;&gt;Keep Test Files Organized&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Perl software distributions follow several widely adopted guidelines concerning tests. The rules are simple: test files should reside in a &lt;em&gt;t/&lt;/em&gt; directory, and each test file ends in a .t extension. &lt;code&gt;Test::Harness&lt;/code&gt; understands these rules and &lt;code&gt;make test&lt;/code&gt; will run every file that abides by them.&lt;/p&gt;

&lt;p&gt;The filename can be anything you like. It&amp;rsquo;s a good idea to use descriptive filenames instead of just digits or numerical words. Good examples are &lt;em&gt;pod-coverage.t&lt;/em&gt;, &lt;em&gt;software-class-api.t&lt;/em&gt;, and &lt;em&gt;compile.t&lt;/em&gt;. Sometimes it&amp;rsquo;s desirable to determine the order in which your test files will be run. In these cases, prefix the filename with a number. If you want compilation tests to run first and POD tests last, name them accordingly as &lt;em&gt;00-compile.t&lt;/em&gt; and &lt;em&gt;99-pod-coverage.t&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-looking-ahead-looking-ahead-span&#34;&gt;&lt;span id=&#34;Looking_Ahead&#34;&gt;Looking Ahead&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Testing can be a tedious, difficult job. By this point, you have a number of helpful tools to make the task easier. There are many more testing modules on the CPAN that could have been covered here; I encourage you to explore them all.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>An Introduction to Testing</title>
      <link>http://localhost:1313/pub/2001/12/04/testing.html/</link>
      <pubDate>Tue, 04 Dec 2001 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2001/12/04/testing.html/</guid>
      <description>

&lt;p&gt;Someday, you&amp;rsquo;ll be dubiously blessed with the job of maintenance programming. You might need to add new features or to fix long-standing bugs. The code may be your own or the apparently disturbed mutterings of a long-disappeared agent of chaos. If you haven&amp;rsquo;t yet been this fortunate, then download a Perl CGI script circa 1996 and try to make it operate under &lt;code&gt;use strict&lt;/code&gt;, warnings and taint mode.&lt;/p&gt;

&lt;p&gt;Maintenance is rarely pretty, mixing forensics, psychology and playing-card house construction. Complicating the matter are concerns such as backward compatibility, portability and interoperability. You&amp;rsquo;ll probably hate the learning experience, but don&amp;rsquo;t miss the chance to learn some important lessons:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;span id=&#34;item_Software_spends_more_time_being_maintained_than_be&#34;&gt;Software spends more time being maintained than being developed.&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span id=&#34;item_Things_that_were_obvious_in_development_are_easily&#34;&gt;Things that were obvious in development are easily obscured.&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span id=&#34;item_Fixing_bugs_is_easier_than_finding_them_and_making&#34;&gt;Fixing bugs is easier than finding them and making sure nothing else breaks.&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span id=&#34;item_The_real_cost_of_software_is_programmer_time_and_e&#34;&gt;The real cost of software is programmer time and effort, not length of code, licenses or required hardware.&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These rules have been well-established since the early days (think Grace Hopper) of software engineering. Good practices remain the same: Write good comments, document your assumptions and logic, test your code to death, test it again.&lt;/p&gt;

&lt;p&gt;Every serious software engineering methodology promotes testing. It is essential to newer approaches, like Extreme Programming. A comprehensive test suite helps to verify that the code performs as expected, helps to minimize the scope of future modifications, and frees developers to improve the structure and design of code without changing its behavior. Yes, this can actually work.&lt;/p&gt;

&lt;h3 id=&#34;span-id-caveats-caveats-span&#34;&gt;&lt;span id=&#34;caveats&#34;&gt;Caveats&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Experienced readers (especially those with strong math backgrounds) rightly note that testing &lt;strong&gt;cannot&lt;/strong&gt; prove the absence of bugs. If it&amp;rsquo;s theoretically impossible to write a non-trivial program with zero defects, it&amp;rsquo;s impossible to write enough tests to prove that the program works completely. Programmers try to write bug-free code anyway, so why not test anything and everything possible? A tested program may have unknown bugs, but an untested program will.&lt;/p&gt;

&lt;p&gt;Of course, some things are truly untestable. This category includes the ``black boxes,&amp;rdquo; such as other processes and machines, and system libraries. More things are testable than not, though. Perl allows good programmers to perform scary black magic, including system table and run-time manipulations. It&amp;rsquo;s possible to create your own fake little world just to satisfy a testable interface. A little megalomania can be handy.&lt;/p&gt;

&lt;p&gt;Testing can be difficult. A wad of code with minimal documentation &amp;ndash; a design from the Perl 4 days &amp;ndash; and business logic that relies on prayer, global variables and animal sacrifice may push you to new heights of productivity, or teach you how to manage programmers. If you don&amp;rsquo;t fix it now, then when do you fix it? Extreme Programming recommends revising untestable code to make it easier to maintain and to test. Sometimes, you must write simple tests, rework the code slightly, and iterate until it&amp;rsquo;s palatable.&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t let the enormity of the task get you down. If you can write Perl code worth testing, then you can write tests.&lt;/p&gt;

&lt;h3 id=&#34;span-id-how-perl-module-testing-works-how-perl-module-testing-works-span&#34;&gt;&lt;span id=&#34;how perl module testing works&#34;&gt;How Perl Module Testing Works&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;This section assumes you&amp;rsquo;re already familiar with &lt;em&gt;perlmodinstall&lt;/em&gt;, having installed a module manually. After the &lt;code&gt;perl Makefile.PL&lt;/code&gt; and &lt;code&gt;make&lt;/code&gt; stages, &lt;code&gt;make test&lt;/code&gt; runs any tests shipped with the module, either &lt;em&gt;test.pl&lt;/em&gt; or all files in the &lt;em&gt;t/&lt;/em&gt; directory that end in ``.t.&amp;rdquo; The &lt;em&gt;blib/&lt;/em&gt; directories are added to &lt;code&gt;@INC&lt;/code&gt;, and &lt;em&gt;Test::Harness&lt;/em&gt; runs the test files, captures their output and provides a short summary of the results, including success and failure.&lt;/p&gt;

&lt;p&gt;At its heart, a test either prints ``ok&amp;rdquo; or ``not ok.&amp;rdquo; That&amp;rsquo;s it. Any test program or testing framework that prints results to standard output can use Test::Harness. If you&amp;rsquo;re feeling epistemological (a good trait to cultivate for writing tests), you could ask ``What is truth?&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        print &amp;quot;1..1\n&amp;quot;;

        if (1) {
                print &amp;quot;ok\n&amp;quot;;
        } else {
                print &amp;quot;not ok\n&amp;quot;;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basic? Yes. Bogus? Not really. This is a variant of an actual Perl core test. If you understood that code, then you can write tests. Ignoring the first line for now, simply stick it in a file (&lt;em&gt;truth.t&lt;/em&gt;) and run either the command line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        perl -MTest::Harness -e &amp;quot;runtests &#39;truth.t&#39;&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or the program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        #!/usr/bin/perl -w

        use strict;
        use Test::Harness;

        runtests &#39;truth.t&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This should produce a message saying that all tests succeeded. If not, then something is broken, and many people would be interested in fixing it.&lt;/p&gt;

&lt;p&gt;The first line of the test corresponds to Test::Harness&amp;rsquo; handy test-numbering feature. The harness needs to know how many tests to expect, and each individual test within a group can have its own number. This is for your benefit. If one test in a 100 mysteriously fails, then it&amp;rsquo;s much easier to track down number 93 than it is to run through the debugger, comment out large swaths of the test suite or rely on intuitively placed print statements.&lt;/p&gt;

&lt;p&gt;Knowing truth is good, and so is discerning falsehood. Let&amp;rsquo;s extend &lt;em&gt;truth.t&lt;/em&gt; slightly. Note the addition of test numbers to each potential printable line. This is both a boon and a bane.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        print &amp;quot;1..2\n&amp;quot;;

        if (1) {
                print &amp;quot;ok 1\n&amp;quot;;
        } else {
                print &amp;quot;not ok 1\n&amp;quot;;
        }

        if (0) {
                print &amp;quot;not ok 2\n&amp;quot;;
        } else {
                print &amp;quot;ok 2\n&amp;quot;;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Besides the increasingly duplicate code, keeping test numbers synchronized is painful. False laziness is painful &amp;ndash; Test::Harness emits warnings if the number of actual tests run does not meet its expectations. Test writers may not mind, but spurious warnings will confuse end users and healthily lazy developers. As a rule, the simpler the output, the more people will believe that things succeeded. The stuffed, smiling Pikachu (hey, it was a birthday present from an attractive female Web designer) perched atop my monitor makes me think that a giant yellow smiley face would be even better than a simple ``ok&amp;rdquo; message. ASCII artists, fire up your editors!&lt;/p&gt;

&lt;p&gt;Unfortunately, the truth test is repetitive and fragile. Adding a third test between the first two (the progression from ``truth&amp;rdquo; to ``hidden truth&amp;rdquo; to ``falsehood&amp;rdquo; makes sense) means duplicating the if/else block and renumbering the previously second test. There&amp;rsquo;s also room for a subtle bug:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        print &amp;quot;1..2\n&amp;quot;;

        if (1) {
                print &amp;quot;ok 1\n&amp;quot;;
        } else {
                print &amp;quot;not ok 1\n&amp;quot;;
        }

        if (&#39;0 but true&#39;) {
                print &amp;quot;ok 2\n&amp;quot;;
        } else {
                print &amp;quot;not ok 2\n&amp;quot;;
        }

        if (0) {
                print &amp;quot;not ok 3\n&amp;quot;;
        } else {
                print &amp;quot;ok 3\n&amp;quot;;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Forgetting to update the first line is common. Two tests were expected; three tests ran. The confused Test::Harness will report strange things, like negative failure percentages. Baby Pikachu may cry. Smarter programmers eventually apply good programming style, writing their own &lt;code&gt;ok()&lt;/code&gt; functions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        print &amp;quot;1..3\n&amp;quot;;

        my $testnum = 1;
        sub ok {
                my $condition = shift;
                print $condition ? &amp;quot;ok $testnum\n&amp;quot; : &amp;quot;not ok $testnum\n&amp;quot;;
                $testnum++;
        }

        ok( 1 );
        ok( &#39;0 but true&#39; );
        ok( ! 0 );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The lowest levels of the Perl core test suite use this approach. It&amp;rsquo;s simpler to write and handles numbering almost automatically. It lacks some features, though, and is little easier to debug.&lt;/p&gt;

&lt;h3 id=&#34;span-id-enter-test-more-enter-test-more-span&#34;&gt;&lt;span id=&#34;enter test::more&#34;&gt;Enter Test::More&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Several modules exist to make testing easier and almost enjoyable. &lt;em&gt;Test&lt;/em&gt; ships with modern Perl distributions and plays well with Test::Harness. The &lt;a href=&#34;http://perlunit.sourceforge.net&#34;&gt;Perl-Unit&lt;/a&gt; suite reimplements the popular &lt;a href=&#34;http://www.junit.com&#34;&gt;JUnit&lt;/a&gt; framework in Perl. The rather new &lt;a href=&#34;https://metacpan.org/pod/Test::Simple&#34;&gt;Test::More&lt;/a&gt; module adds several features beyond those of &lt;em&gt;Test&lt;/em&gt;. (I admit a particular bias toward the latter, though these and other modules are fine choices.)&lt;/p&gt;

&lt;p&gt;Test::More has its own &lt;code&gt;ok()&lt;/code&gt; function, but it is rarely used in favor of more specific functions. &lt;code&gt;is()&lt;/code&gt; compares two expressions. For example, testing an addition function is as simple as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        is( add(2, 2), 4 );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This handles strings and numbers equally well. Since version 0.36, it also distinguishes between &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;&#39;&#39;&lt;/code&gt; (the empty string), and &lt;code&gt;undef&lt;/code&gt; &amp;ndash; we hope.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;like()&lt;/code&gt; applies a regular expression to a scalar. This is also useful for trapping fatal errors:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        $self-&amp;gt;eat(&#39;garden salad&#39;):

        eval { $self-&amp;gt;write_article() };
        like( $@, qr/not enough sugar/ );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second argument can be either a regular expression compiled with the &lt;code&gt;qr//&lt;/code&gt; operator (introduced in Perl 5.005), or a string that resembles a regular expression. Modifiers are allowed. If you absolutely must rewrite the previous example to run on Perl 5.004 and to use StudlyCaps, then you can:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        eval { $self-&amp;gt;write_article() };
        like( $@, &#39;/NoT eNoUgH sUgAr/i&#39; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s too cute/hideous for a real test, but the regex form is completely valid.&lt;/p&gt;

&lt;h3 id=&#34;span-id-test-more-makes-debugging-nicer-test-more-makes-debugging-nicer-span&#34;&gt;&lt;span id=&#34;test::more makes debugging nicer&#34;&gt;Test::More Makes Debugging Nicer&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;That&amp;rsquo;s useful enough already, but there&amp;rsquo;s more to Test::More.&lt;/p&gt;

&lt;p&gt;Test::More supports test numbering just as Test::Harness does, and automatically provides the numbers. This is a big win in two cases: where the test suite may accidentally fail (from a &lt;code&gt;die()&lt;/code&gt; call, a segmentation fault, or spontaneous combustion), or if the tests can accidentally repeat (due to an improper &lt;code&gt;chdir()&lt;/code&gt;, unexpected input in a loop condition, or a time warp). Test::Harness is happy to warn whether the number of tests actually run do not match its expectations. You just have to tell it how many should run. This is usually done when using Test::More:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        use Test::More tests =&amp;gt; 50;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When writing new tests, you may not know how many there will be. Use the &lt;code&gt;no_plan&lt;/code&gt; option:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        use Test::More &#39;no_plan&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Extreme Programming recommends this game-like approach: add a test, run it, write code to pass the test, repeat. When you&amp;rsquo;ve finished, update the &lt;code&gt;use&lt;/code&gt; line to reflect the actual number of tests.&lt;/p&gt;

&lt;p&gt;Test::More also handles failures gracefully. Given the following file with a final, doomed test:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        use Test::More tests =&amp;gt; 4;

        is( 1, 1 );
        is( !0, 1 );
        is( 0, 0 );
        is( undef, 1 );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test::More run on its own, not through Test::Harness, produces:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        1..4
        ok 1
        ok 2
        ok 3
        not ok 4
        #     Failed test (numbers.t at line 6)
        #          got: undef
        #     expected: &#39;1&#39;
        # Looks like you failed 1 tests of 1.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The error message provides the name of the file containing the tests, the number of the failed test, the line number containing the failed test, and expected and received data. This makes for easier debugging. Count tests to find an error just once, and you&amp;rsquo;ll prefer this approach.&lt;/p&gt;

&lt;p&gt;Test::Harness also supports optional test comments attached to test messages. That is, it allows raw tests to say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        print &amp;quot;ok 1 # the most basic test possible\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nearly all Test::More functions support this as an optional parameter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        ok( 1, &#39;the number 1 should evaluate to true&#39; );
        is( 2 + &amp;quot;2&amp;quot;, 4, &#39;numeric strings should numerify in addition&#39; );
        like( &#39;abc&#39;, qr/z*/, &#39;* quantifier should match zero elements&#39; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These names are required by nothing except social convention. Think of them as little test comments. If the test is wrong, or exposes a fixed bug that should never reoccur, then a descriptive name makes it clear what the test should be testing. Test::Harness silently eats the names, but they&amp;rsquo;re present when run manually:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        ok 1 - the number 1 should evaluate to true
        ok 2 - numeric strings should numerify in addition
        ok 3 - * quantifier should match zero elements
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Manual test runs make for improved bug reports. Ignore these convenient tools at your own peril.&lt;/p&gt;

&lt;h3 id=&#34;span-id-intermediate-test-more-features-intermediate-test-more-features-span&#34;&gt;&lt;span id=&#34;intermediate test::more features&#34;&gt;Intermediate Test::More Features&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;If the previous features weren&amp;rsquo;t enough, Test::More supports still more! One such is the notion of skippable tests. Occasionally, the presence or absence of certain criteria obviate the need to test a feature. Consider the &lt;code&gt;qr//&lt;/code&gt; operator explained earlier. A module that needs to be backward compatible to Perl 5.004 can gradefully degrade its test suite with skippable tests:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        SKIP: {
                skip( &#39;qr// not supported in this version&#39;, 2 ) unless $] &amp;gt;= 5.005;

                my $foo = qr/i have a cat/;
                ok( &#39;i have a caterpillar&#39; =~ $foo,
                        &#39;compiled regex should match similar string&#39; );

                ok( &#39;i have a cold&#39; !~ $foo,
                        &#39;compiled regex should not match dissimilar string&#39; );
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s a lot to digest. First, the skippable tests are contained in a labelled block. The label must be &lt;em&gt;SKIP&lt;/em&gt;. (Don&amp;rsquo;t worry: you can have several of these within a file.) Next, there should be a condition that governs whether to skip the tests. This example checks the special variable &lt;em&gt;perlvar&lt;/em&gt; to find the current Perl version. &lt;code&gt;skip()&lt;/code&gt; will only be called when run with an older version.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;skip()&lt;/code&gt; function always confuses me with its unique parameter order. The first argument is the name to display for each skipped test. The second argument is the number of tests to skip. This must match the number of tests within the block, at the risk of certain confusion. Run on Perl 5.004, the above test produces:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        ok 1 # skip qr// not supported in this version
        ok 2 # skip qr// not supported in this version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Though the message says &lt;em&gt;ok&lt;/em&gt;, Test::Harness will see skip and report the tests as skipped, not passed. This should only be used for tests that absolutely will not run due to platform or version differences. For tests you just can&amp;rsquo;t figure out &lt;strong&gt;yet&lt;/strong&gt;, use &lt;code&gt;todo()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Though everything is built on &lt;code&gt;Test::Builder::ok()&lt;/code&gt;, other functions offer helpful shortcuts. &lt;code&gt;use_ok()&lt;/code&gt; and &lt;code&gt;require_ok&lt;/code&gt; load and optionally import the named file, reporting the success or error. These verify that a module can be found and compiled, and are often used for the first test in a suite. The &lt;code&gt;can_ok()&lt;/code&gt; function attempts to resolve a class or an object method. &lt;code&gt;isa_ok()&lt;/code&gt; checks inheritance:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        use_ok( &#39;My::Module&#39; );
        require_ok( &#39;My::Module::Sequel&#39; );

        my $foo = My::Module-&amp;gt;new();
        can_ok( $foo-&amp;gt;boo() );
        isa_ok( $foo, &#39;My::Module&#39; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;They produce their own test names:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        ok 1 - use My::Module;
        ok 2 - require My::Module::Sequel;
        ok 3 - My::Module-&amp;gt;can(boo)
        ok 4 - object-&amp;gt;isa(&#39;My::Module&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Other functions and features are documented in the Test::More documentation. As well, &lt;a href=&#34;https://metacpan.org/pod/Test::Tutorial&#34;&gt;Test::Tutorial&lt;/a&gt; explains similar things with a different wit.&lt;/p&gt;

&lt;p&gt;Finally, do not forget good programming practices. Test functions are simply standard subroutines. Tests are just Perl code. Use loops, variables, helper subs, &lt;code&gt;map()&lt;/code&gt;, and anything else, when they make things easier. For example, basic inherited interface testing can be made easier with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        # see if IceCreamBar inherits these methods from Popsicle
        my $icb = IceCreamBar-&amp;gt;new();

        foreach my $method (qw( fall_off_stick freeze_tongue drip_on_carpet )) {
                can_ok( $icb, $method, &amp;quot;IceCreamBar should be able to $method()&amp;quot; );
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That beats writing several individual &lt;code&gt;can_ok()&lt;/code&gt; tests. Interpolating things into the test name is also handy.&lt;/p&gt;

&lt;h3 id=&#34;span-id-conclusion-conclusion-span&#34;&gt;&lt;span id=&#34;conclusion&#34;&gt;Conclusion&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Testing is unfortunately often neglected, especially among free software projects. Think of it as getting plenty of sleep, eating vegetables, and working out regularly. It may cramp your style at first, but will improve things immensely if you do it consistently. (Results may vary if you&amp;rsquo;re adding tests to a huge system that doesn&amp;rsquo;t have them, like, say, Perl itself.)&lt;/p&gt;

&lt;p&gt;One goal of Perl is to make your life easier. Perl 5.8 will include &lt;a href=&#34;https://metacpan.org/pod/Test::More&#34;&gt;Test::More&lt;/a&gt; and its hearty brethren, &lt;a href=&#34;https://metacpan.org/pod/Test::Simple&#34;&gt;Test::Simple&lt;/a&gt; and &lt;a href=&#34;https://metacpan.org/pod/Test::Builder&#34;&gt;Test::Builder&lt;/a&gt;. They exist to make writing tests less of a hassle, and even more pleasant. Consider them.&lt;/p&gt;

&lt;p&gt;The easier it is to write and maintain tests, the more likely people will do it. More and better tests improve software portability, maintainability, and reliability. You may currently compare testing to broccoli, brussel sprouts, and wind sprints. Try Test::More or another framework, and you may grow to see them as oranges, sweet potatoes with marshmallows, and a trip to the sauna. It really is good for you.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;chromatic is the author of &lt;a href=&#34;http://onyxneon.com/books/modern_perl/&#34;&gt;Modern Perl&lt;/a&gt;. In his spare time, he has been working on &lt;a href=&#34;http://trendshare.org/how-to-invest/&#34;&gt;helping novices understand stocks and investing&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

