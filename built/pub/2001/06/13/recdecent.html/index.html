<!DOCTYPE html>
<html lang="en-us">
  <head>
  <title> Parse::RecDescent Tutorial </title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content=" The Basics Parse::RecDescent is a combination compiler and interpreter. The language it uses can be thought of roughly as a macro language like CPP&#39;s, but the macros take no parameters. This may seem limiting, but the technique is very..."/>
  <meta name="robots" content="index, follow">
  <meta name="google-site-verification" content="TZowffo_LX2mmsw2DbeNNbukCMnIOA8T-6CMJPiYllI" />

<meta property="twitter:card" content="summary">
<meta property="twitter:site" content="@PerlFoundation">
<meta property="og:url" content="http://localhost:1313/pub/2001/06/13/recdecent.html/" />
<meta property="og:title" content="Parse::RecDescent Tutorial" />
<meta property="og:description" content=" The Basics Parse::RecDescent is a combination compiler and interpreter. The language it uses can be thought of roughly as a macro language like CPP&#39;s, but the macros take no parameters. This may seem limiting, but the technique is very...">
<meta property="og:site_name" content="Perl.com" />

<meta property="og:type" content="article" />
<meta property="og:article:published_time" content="2001-06-06T06:06:06Z" />
<meta property="og:image" content="http://localhost:1313/images/_pub_2001_06_13_recdecent/111-perl-parse.jpg" />


  <link rel="icon" href="/favicon.ico">
  <link href="/article/index.xml" rel="alternate" type="application/rss+xml" title="Perl.com - programming news, code and culture" />
  <link href="/article/index.xml" rel="feed" type="application/rss+xml" title="Perl.com - programming news, code and culture" />
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" type="text/css" href="/css/perldotcom.css"/>


<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-50555-22', 'auto');
ga('create', 'UA-85734801-2', 'auto', 'editor');
ga('send', 'pageview');
ga('editor.send', 'pageview');
</script>

</head>
<body>

<div class="container-fluid full-wdith antonio">
 <div class="row">
  <div class="navbar-inverse" style="border-radius:none !important" role="navigation">
    <div class="container-fluid">
      <ul class="nav navbar-nav pull-right follow">
          <li>MORE:</li>
          <li><a href="https://perl.org">
              <img src="/images/site/perl-onion_20.png" alt="Perl Onion"></a><li>
          <li><a href="https://twitter.com/intent/follow?screen_name=perlfoundation">
              <img src="/images/site/twitter_20.png" alt="twitter"></a><li>
          <li><a href="/article/index.xml" />
              <img src="/images/site/rss_20.png" alt="rss"></a></li>
          <li><a href="https://github.com/tpf/perldotcom" />
              <img src="/images/site/github_light_20.png" alt="GitHub logo"></a></li>
      </ul>
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
          <a class="navbar-nav" href="/">
            <div class="header-logo">Perl.com</div>
          </a>
      </div>
      <div class="navbar-collapse collapse">
        <ul class="nav navbar-nav">
          <li><a href="/about">
              <div class="circle">
                <img src="/images/site/perl-camel.png" alt="" />
              </div>
                  &nbsp;&nbsp;ABOUT</a>
          </li>
          <li><a href="/authors">
              <div class="circle">
                  <span class="glyphicon glyphicon-user txt-blue-major" aria-hidden="true"></span>
              </div>
                  &nbsp;&nbsp;AUTHORS</a>
          </li>
          <li><a href="/categories">
              <div class="circle">
                  <span class="glyphicon glyphicon-folder-open txt-blue-major" aria-hidden="true"></span>
              </div>
                  &nbsp;&nbsp;CATEGORIES</a>
          </li>
          <li><a href="/tags">
              <div class="circle">
                <span class="txt-blue-major" aria-hidden="true"><strong>#</strong></span>
              </div>
                  &nbsp;&nbsp;TAGS</a>
          </li>
          <li>
            <form class="search" name="ddg" action="https://duckduckgo.com/" method="get">
              <input type="text" name ="q" placeholder="SEARCH" />
              <input type="hidden" value="perl.com" name="sites" />
            </form>
          </li>
        </ul>
      </div>
    </div>
  </div>
 </div>
</div>


  <section id="content" role="main">
    <section class="entry-content">
      <div class="container">
        <div class="row">
          <div class="col-md-9">
            <div class="row">
              <article class="fulltext">
              <h1 class="blog-post-title">Parse::RecDescent Tutorial</h1>
              <p class="blog-post-meta">Jun 13, 2001 by
              
              
                
                
                <a href="#author-bio-jeffrey-goff">Jeffrey Goff</a>
              
              </p>
              <img alt="" src=""/>
                

<h3 id="the-basics">The Basics</h3>

<p>Parse::RecDescent is a combination compiler and interpreter. The language it uses can be thought of roughly as a macro language like CPP&rsquo;s, but the macros take no parameters. This may seem limiting, but the technique is very powerful nonetheless. Our macro language looks like this:</p>

<pre><code>  macro_name : macro_body
</code></pre>

<p>A colon separates the macro&rsquo;s name and body, and the body can have any combination of explicit strings (&ldquo;string, with optional spaces&rdquo;), a regular expression (<code>/typical (?=perl) expression/</code>), or another macro that&rsquo;s defined somewhere in the source file. It can also have alternations. So, a sample source file could look like:</p>

<pre><code>  startrule : day  month /\d+/ # Match strings of the form &quot;Sat Jun 15&quot;


  day : &quot;Sat&quot; | &quot;Sun&quot; | &quot;Mon&quot; | &quot;Tue&quot; | &quot;Wed&quot; | &quot;Thu&quot; | &quot;Fri&quot;


  month : &quot;Jan&quot; | &quot;Feb&quot; | &quot;Mar&quot; | &quot;Apr&quot; | &quot;May&quot; | &quot;Jun&quot; |
          &quot;Jul&quot; | &quot;Aug&quot; | &quot;Sep&quot; | &quot;Oct&quot; | &quot;Nov&quot; | &quot;Dec&quot;
</code></pre>

<p>Three macros make up this source file: <code>startrule</code>, <code>dayrule</code> and <code>monthrule</code>. The compiler will turn these rules into its internal representation and pass it along to the interpreter. The interpreter then takes a data file and attempts to expand the macros in <code>startrule</code> to match the contents of the data file.</p>

<p>The interpreter takes a string like &ldquo;Sat Jun 15&rdquo; and attempts to expand the <code>startrule</code> macro to match it. If it matches, the interpreter returns a true value. Otherwise, it returns <code>undef</code>;. Some sample source may be welcome at this point:</p>

<pre><code>  #!/usr/bin/perl


  use Parse::RecDescent;


  # Create and compile the source file
  $parser = Parse::RecDescent-&gt;new(q(
    startrule : day  month /\d+/


    day : &quot;Sat&quot; | &quot;Sun&quot; | &quot;Mon&quot; | &quot;Tue&quot; | &quot;Wed&quot; | &quot;Thu&quot; | &quot;Fri&quot;


    month : &quot;Jan&quot; | &quot;Feb&quot; | &quot;Mar&quot; | &quot;Apr&quot; | &quot;May&quot; | &quot;Jun&quot; |
            &quot;Jul&quot; | &quot;Aug&quot; | &quot;Sep&quot; | &quot;Oct&quot; | &quot;Nov&quot; | &quot;Dec&quot;
  ));


  # Test it on sample data
  print &quot;Valid date\n&quot; if $parser-&gt;startrule(&quot;Thu Mar 31&quot;);
  print &quot;Invalid date\n&quot; unless $parser-&gt;startrule(&quot;Jun 31 2000&quot;);
</code></pre>

<p>Creating a new Parse::RecDescent instance is done just like any other OO module. The only parameter is a string containing the source file, or <em>grammar</em>. Once the compiler has done its work, the interpreter can run as many times as necessary. The sample source tests the interpreter on valid and invalid data.</p>

<p>By the way, just because the parser knows that the string &ldquo;Sat Jun 15&rdquo; is valid, it has no way of knowing if the 15th of June was indeed a Saturday. In fact, the sample grammar would also match &ldquo;Sat Feb 135&rdquo;. The grammar describes form, not content.</p>

<h3 id="span-id-getting-data-getting-data-span"><span id="getting data">Getting Data</span></h3>

<p>Now, this is quite a bit of work to go to simply to match a string. However, much, much more can be done. One element missing from this picture is capturing data. So far the sample grammar can tell if a string matches a regular expression, but it can&rsquo;t tell us what the data it&rsquo;s parsed is. Well, these macros can be told to run perl code when encountered.</p>

<p>Perl code goes after the end of a rule, enclosed in braces. When the interpreter recognizes a macro such as <code>startrule</code>, the text matched is saved and passed to the perl code embedded in the grammar.</p>

<p>Each word or <em>term</em> of the macro (&lsquo;day&rsquo;, &lsquo;month&rsquo;&hellip;) is saved by the interpreter. <code>dayrule</code> gets saved into the <code>$item{day}</code> hash entry, as does <code>monthrule</code>. The <code>/\d+/</code> term doesn&rsquo;t have a corresponding name, so its data comes from the <code>@item</code> array. <code>$item[0]</code> is always the rule name, so <code>/\d+/</code> gets saved into <code>$item[3]</code>. So, code to print the parsed output from our sample <code>startrule</code> rule looks like this:</p>

<pre><code>  startrule : day month /\d+/
            { print &quot;Day: $item{day} Month: $item{month} Date: $item[3]\n&quot;; }
</code></pre>

<p>Everything in the parser is run as if it was in the Parse::RecDescent package, so when calling subroutines outside Parse::RecDescent, either qualify them as <code>Package::Name-&gt;my_sub()</code> or subclass Parse::RecDescent.</p>

<h3 id="span-id-a-minilanguage-a-mini-language-span"><span id="a minilanguage">A Mini-Language</span></h3>

<p>All of the pieces are now in place to create a miniature language, compile, and run code in it. To make matters simple, the language will only have two types of instruction: Assign and Print. A sample &lsquo;Assign&rsquo; instruction could look like <code>foo = 3 + a</code>. The &lsquo;Print&rsquo; statement will look like <code>print foo / 2</code>. Add the fact that <code>3 + a</code> can be arbitrarily long (<code>temp = 3+a/2*4</code>), and now you&rsquo;ve got a non-trivial parsing problem.</p>

<p>The easiest instruction to implement is the &lsquo;Print&rsquo; instruction. Assuming for the moment that the right-hand side of the statement (the <code>foo / 2</code> part of <code>print foo / 2</code>) already has a rule associated with it (called &lsquo;expression&rsquo;), the &lsquo;Print&rsquo; instruction is very simple:</p>

<pre><code>  print_instruction : /print/i expression
                    { print $item{expression}.&quot;\n&quot; }
</code></pre>

<p>The &lsquo;Assign&rsquo; instruction is a little harder to do, because we need to implement variables. We&rsquo;ll do this in a straightforward fashion, storing variable names in a hash. This will live in the main package, and for the sake of exposition we&rsquo;ll call it <code>%VARIABLE</code>. One caveat to remember is that the perl code runs inside the Parse::RecDescent package, so we&rsquo;ll explicitly specify the <code>main</code> package when writing the code.</p>

<p>More complex than the &lsquo;Print&rsquo; instruction, the &lsquo;Assign&rsquo; instruction has three parts: the variable to assign to, an &ldquo;=&rdquo; sign, and the expression that gets assigned to the variable. So, the instruction looks roughly like this:</p>

<pre><code>  assign_instruction : VARIABLE &quot;=&quot; expression
                     { $main::VARIABLE{$item{VARIABLE}} = $item{expression} }
</code></pre>

<p>Much like we did with the <code>dayrule</code> rule in the last section, we&rsquo;ll combine the <code>print_instruction</code> and <code>assign_instruction</code> into one <code>instruction</code> rule. The syntax for this should be fairly simple to remember, as it&rsquo;s the same as a Perl regular expression.</p>

<pre><code>  instruction : print_instruction
              | assign_instruction
</code></pre>

<p>In order to make the <code>startrule</code> expand to the <code>instruction</code> rule, we&rsquo;d ordinarily use a rule like <code>startrule : instruction</code>. However, most languages let you enter more than one instruction in a source file. One way to do this would be to create a recursive rule that would look like this:</p>

<pre><code>  instructions : instruction &quot;;&quot; instructions
               | instruction
  startrule : instructions
</code></pre>

<p>[[JMG: I&rsquo;m sorely tempted to rewrite this chunk, if only &lsquo;cause there&rsquo;s a lot of info here in just one paragraph]]</p>

<p>Input text like &ldquo;print 32&rdquo; expands as follows: <code>startrule</code> expands to <code>instructions</code>. <code>instructions</code> expands to <code>instruction</code>, which expands to <code>print_instruction</code>. Longer input text like &ldquo;a = 5; b = a + 5; print a&rdquo; expands like so: <code>startrule</code> expands to <code>instructions</code>. The interpreter looks ahead and chooses the alternative with the semicolon, and parses &ldquo;a = 5&rdquo; into its first instruction. &ldquo;b = a + 5; print a&rdquo; is left in <code>instructions</code>. This process gets repeated twice until each bit has been parsed into a separate <code>instruction</code>.</p>

<p>If the above seemed complex, Parse::RecDescent has a shortcut available. The above <code>instructions</code> rule can be collapsed into <code>startrule : instruction(s)</code>. The <code>(s)</code> part can simply be interpreted as &ldquo;One or more <code>instruction</code>s&rdquo;. By itself this assumes only whitespace exists between the different instructionrule;s, but here again, Parse::RecDescent comes to the rescue, by allowing the user to specify a separator regular expression, like <code>(s /;/)</code>. So, the <code>startrule</code> actually will use the <code>(s /;/)</code> syntax.</p>

<pre><code>  startrule : instruction(s /;/)
</code></pre>

<h3 id="span-id-the-expression-rule-the-expression-rule-span"><span id="the expression rule">The Expression Rule</span></h3>

<p>Expressions can be anything from &lsquo;0&rsquo; all the way through &lsquo;a+bar*foo/300-75&rsquo;. Ths range may seem intimidating, but we&rsquo;ll try to break it down into easy-to-digest pieces. Starting simply, an expression can be as simple as a single variable or integer. This would look like:</p>

<pre><code>  expression : INTEGER
             | VARIABLE
             { return $main::VARIABLE{$item{VARIABLE}} }
</code></pre>

<p>The <code>VARIABLE</code> rule has one minor quirk. In order to compute the value of the expression, variables have to be given a value. In order to modify the text parsed, simply have the code return the modified text. In this case, the perl code looks up the variable in <code>%main::VARIABLE</code> and returns the value of the variable rather than the text.</p>

<p>Those two lines take care of the case of an expression with a single term. Multiple-term expressions (such as <code>7+5</code> and <code>foo+bar/2</code>) are a little harder to deal with. The rules for a single expression like <code>a+7</code> would look roughly like:</p>

<pre><code>  expression : INTEGER OP INTEGER
             | VARIABLE OP INTEGER
             | INTEGER OP VARIABLE
             | VARIABLE OP VARIABLE
  OP : /[-+*/%]/
</code></pre>

<p>This introduces one new term, <code>OP</code>. This rule simply contains the binary operators <code>/[-+*/%]/</code>. The above approach works for two terms, and can be extended to three terms or more, but is terribly unwieldy. If you&rsquo;ll remember, the <code>expression</code> rule already is defined as <code>INTEGER | VARIABLE</code>, so we can replace the right-hand term with <code>expression</code>. Replacing the right-hand term with <code>expression</code> and getting rid of redundant lines results in this:</p>

<pre><code>  expression : INTEGER OP expression
             | VARIABLE OP expression
</code></pre>

<p>We&rsquo;ll hand off the final evaluation to a function outside the Parse::RecDescent package. This function will simply take the <code>@item</code> list from the interpreter and evaluate the expression. Since the array will look like <code>(3,'+',5)</code>. we can&rsquo;t simply say <code>$item[1] $item[2] $item[3]</code>, since <code>$item[2]</code> is a scalar variable, not an operator. Instead we&rsquo;ll take the string <code>&quot;$item[1] $item[2] $item[3]&quot;</code> and evaluate that. This will evaluate the string and return the result. This then gets passed back, and becomes the value of the <code>expression</code>.</p>

<pre><code>  expression : INTEGER OP expression
             { return main::expression(@item) }
             | VARIABLE OP expression
             { return main::expression(@item) }


  sub expression {
    shift;
    my ($lhs,$op,$rhs) = @_;
    return eval &quot;$lhs $op $rhs&quot;;
  }
</code></pre>

<p>That completes our grammar. Testing is fairly simple. Write some code in the new language, like &ldquo;a = 3 + 5; b = a + 2; print a; print b&rdquo;, and pass it to the <code>$parser-&gt;startrule()</code> method to interpret the string.</p>

<p>The file included with this article comes with several test samples. The grammar in the tutorial is very simple, so plenty of room to experiment remains. One simple modification is to change the <code>INTEGER</code> rule to account for floating point numbers. Unary operators (single-term such as <code>sin()</code>) can be added to the <code>expression</code> rule, and statements other than &lsquo;print&rsquo; and &lsquo;assign&rsquo; can be added easily.</p>

<p>Other modifications might include adding strings (some experimental extensions such as &lsquo;&lt;perl_quotelike&gt;&rsquo; may help). Changing the grammar to include parentheses and proper precedence are other possible projects.</p>

<h3 id="span-id-closing-closing-span"><span id="closing">Closing</span></h3>

<p>Parse::RecDescent is a powerful but difficult-to-undertstand module. Most of this is because parsing a language can be difficult to understand. However, as long as the language has a fairly consistent grammar (or one can be written), it&rsquo;s generally possible to translate it into a grammar that Parse::RecDescent can handle.</p>

<p>Many languages have their grammars available on the Internet. Grammars can usually be found in search engines under the keyword &lsquo;BNF&rsquo;, standing for &lsquo;Backus-Naur Form&rsquo;. These grammars aren&rsquo;t quite in the form Parse::RecDescent prefers, but can usually be modified to suit.</p>

<p>When writing your own grammars for Parse::RecDescent, one important rule to keep in mind is that a rule can never have itself as the first term. This makes rules such as <code>statement : statement &quot;;&quot; statements</code> illegal. This sort of grammar is called &ldquo;left-recursive&rdquo; because a rule in the grammar expands to its left side.</p>

<p>Left-recursive grammars can usually be rewritten to right-recursive, which will parse cleanly under Parse::RecDescent, but there are classes of grammars thatcant be rewritten to be right-recursive. If a grammar can&rsquo;t be done in Parse::RecDescent, then something like <code>Parse::Yapp</code> may be more appropriate. It&rsquo;s also possible to coerce <code>yacc</code> into generating a perl skeleton, supposedly.</p>

<p>Hopefully some of the shroud of mystery over Parse::RecDescent has been lifted, and more people will use this incredibly powerful module.</p>

<pre><code> #!/usr/bin/perl -w


 use strict;
 use Parse::RecDescent;
 use Data::Dumper;


 use vars qw(%VARIABLE);


 # Enable warnings within the Parse::RecDescent module.


 $::RD_ERRORS = 1; # Make sure the parser dies when it encounters an error
 $::RD_WARN   = 1; # Enable warnings. This will warn on unused rules &amp;c.
 $::RD_HINT   = 1; # Give out hints to help fix problems.


 my $grammar = &lt;&lt;'_EOGRAMMAR_';


   # Terminals (macros that can't expand further)
   #


   OP       : m([-+*/%])      # Mathematical operators
   INTEGER  : /[-+]?\d+/      # Signed integers
   VARIABLE : /\w[a-z0-9_]*/i # Variable


   expression : INTEGER OP expression
              { return main::expression(@item) }
              | VARIABLE OP expression
              { return main::expression(@item) }
              | INTEGER
              | VARIABLE
              { return $main::VARIABLE{$item{VARIABLE}} }


   print_instruction  : /print/i expression
                      { print $item{expression}.&quot;\n&quot; }
   assign_instruction : VARIABLE &quot;=&quot; expression
                      { $main::VARIABLE{$item{VARIABLE}} = $item{expression} }


   instruction : print_instruction
               | assign_instruction


   startrule: instruction(s /;/)


 _EOGRAMMAR_


 sub expression {
   shift;
   my ($lhs,$op,$rhs) = @_;
   $lhs = $VARIABLE{$lhs} if $lhs=~/[^-+0-9]/;
   return eval &quot;$lhs $op $rhs&quot;;
 }


 my $parser = Parse::RecDescent-&gt;new($grammar);


 print &quot;a=2\n&quot;;             $parser-&gt;startrule(&quot;a=2&quot;);
 print &quot;a=1+3\n&quot;;           $parser-&gt;startrule(&quot;a=1+3&quot;);
 print &quot;print 5*7\n&quot;;       $parser-&gt;startrule(&quot;print 5*7&quot;);
 print &quot;print 2/4\n&quot;;       $parser-&gt;startrule(&quot;print 2/4&quot;);
 print &quot;print 2+2/4\n&quot;;     $parser-&gt;startrule(&quot;print 2+2/4&quot;);
 print &quot;print 2+-2/4\n&quot;;    $parser-&gt;startrule(&quot;print 2+-2/4&quot;);
 print &quot;a = 5 ; print a\n&quot;; $parser-&gt;startrule(&quot;a = 5 ; print a&quot;);
</code></pre>

              </article>
              <p><strong>Tags</strong></p>
              <div class="tags">
                <div class="category"><a href="/categories/programming-languages">programming-languages</a></div>
                
              </div>
            </div>
            
              
                
<div class="row" id="author-bio-jeffrey-goff">
  <div class="col-sm-2">
    
    <a href="/authors/jeffrey-goff/"><div class="circle-avatar" style="background-image:url(/images/site/avatar.png)"></div></a>
  </div>
  <div class="col-sm-10">
    <a href="/authors/jeffrey-goff/"><h3>Jeffrey Goff</h3></a>
    <p></p>
    <h5><a href="/authors/jeffrey-goff/">Browse their articles</a></h5>
  </div>
</div>

            
            <div class="row">
              <h3>Feedback</h3>
              <p>Something wrong with this article? Help us out by opening an issue or pull request on <a href="https://github.com/tpf/perldotcom/blob/master/content/legacy/_pub_2001_06_13_recdecent.md">GitHub</a></p>
            </div>
          </div>
          <div class="col-md-3">
            <div class="latest-sidebar">

  <div class="row">
    <div class="col-sm-12 centering">
      <span style="font-size:1.8em" class="antonio txt-blue-major">OUR LATEST ARTICLES</span>
    </div>
  </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/the-perl-admbassador-curtis-poe/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/the-perl-ambassador-curtis-poe/curtis-poe.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>The Perl Ambassador: Curtis &#39;Ovid&#39; Poe</h6>
          <p style="line-height:1"><small>The person behind the news of Perl</small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/a-tour-with-net-ftp/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/a-tour-with-net-ftp/thumb_kidyes.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>A tour with Net::FTP</h6>
          <p style="line-height:1"><small>How to write an FTP client in Perl</small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/shortcode_test/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/author/brian-d-foy.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>shortcode_test</h6>
          <p style="line-height:1"><small></small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/listen-to-larry-wall-s-state-of-the-onion-2000-on-youtube/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/listen-to-larry-wall-s-state-of-the-onion-2000-on-youtube/thumb_larry-wall.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>Listen to Larry Wall&#39;s State of the Onion 2000 on YouTube</h6>
          <p style="line-height:1"><small></small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/announcing-perl-7/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/announcing-perl-7/thumb_seven_on_blue_wall.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>Announcing Perl 7</h6>
          <p style="line-height:1"><small>Perl 5 with modern defaults</small></p>
      </div>
        </a>
    </div>
  
</div>
<div class="row" style="margin-top:20px">
  <div class="col-sm-12 centering">
  <script async src="/widget/toplinks/toplinks.js" type="text/javascript"></script>
    <div id="toplinks"></div>
  </div>
</div>

<div class="row" style="margin-top:20px">
  <div class="col-sm-12 centering">
    <a class="twitter-timeline" data-height="640" data-dnt="true" data-theme="dark" href="https://twitter.com/perlfoundation?ref_src=twsrc%5Etfw">Tweets by perlfoundation</a> <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
  </div>
</div>

<div class="row" style="margin-top:20px">
  <div class="col-sm-12 centering">
    <script src="https://www.reddit.com/r/perl/hot/.embed?limit=10&t=all" type="text/javascript"></script>
  </div>
</div>



          </div>
        </div>
      </div>
    </section>
  </section>
<script>
 
var tables, i;
tables = document.getElementsByTagName('table');
for (i=0;i<tables.length;i++) {
  tables[i].className = 'table table-striped';
}
</script>
<div class="push"></div>
<div class="footer">
  <div class="container">
    <div class="row">
      <div class="col-md-1">
        <h5>Site Map</h5>
        <ul>
        <li><a href="/">Home</a></li>
        <hr>
        <li><a href="/about">About</a></li>
        <hr>
        <li><a href="/authors">Authors</a></li>
        <hr>
        <li><a href="/categories">Categories</a></li>
        <hr>
        <li><a href="/tags">Tags</a></li>
        <hr>
        </ul>
      </div>
      <div class="col-md-3">
        <h5>Contact Us</h5>
        <p>To get in touch, send an email to: perl.com-editor@perl.org</p>
        <p><a href="https://perl.org">
              <img src="/images/site/perl-onion_20.png" alt="Perl Onion"></a>
          <a href="https://twitter.com/intent/follow?screen_name=perlfoundation">
              <img src="/images/site/twitter_20.png" alt="twitter"></a>
          <a href="/index.xml" /><img src="/images/site/rss_20.png" alt="rss"></a>
          <a href="https://github.com/tpf/perldotcom">
              <img src="/images/site/github_light_20.png" alt="GitHub logo"></a></p>
      </div>
      <div class="col-md-2">
          <h5>License</h5>
          <p>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc/3.0/">Creative Commons Attribution-NonCommercial 3.0 Unported License</a>.</p>
          <p><a rel="license" href="https://creativecommons.org/licenses/by-nc/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/3.0/88x31.png" /></a></p>
      </div>
      <div class="col-md-5">
          <h5>Legal</h5>
          <p>Perl.com and the authors make no representations with respect to the accuracy or completeness of the contents of all work on this website and specifically disclaim all warranties, including without limitation warranties of fitness for a particular purpose. The information published on this website may not be suitable for every situation. All work on this website is provided with the understanding that Perl.com and the authors are not engaged in rendering professional services. Neither Perl.com nor the authors shall be liable for damages arising herefrom.</p>
      </div>
    </div>
  </div>
</div>
<script src="/javascript/jquery.min.js"></script>
<script src="/javascript/bootstrap.min.js"></script>
<script data-no-instant>document.write('<script src="/livereload.js?port=1313&mindelay=10"></' + 'script>')</script></body>
</html>

