<!DOCTYPE html>
<html lang="en-us">
  <head>
  <title> Going Up? </title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content=" Perl 5.8.0 is the first version of Perl with a stable threading implementation. Threading has the potential to change the way we program in Perl, and even the way we think about programming. This article explores Perl&#39;s new threading..."/>
  <meta name="robots" content="index, follow">
  <meta name="google-site-verification" content="TZowffo_LX2mmsw2DbeNNbukCMnIOA8T-6CMJPiYllI" />

<meta property="twitter:card" content="summary">
<meta property="twitter:site" content="@PerlFoundation">
<meta property="og:url" content="http://localhost:1313/pub/2002/09/04/threads.html/" />
<meta property="og:title" content="Going Up?" />
<meta property="og:description" content=" Perl 5.8.0 is the first version of Perl with a stable threading implementation. Threading has the potential to change the way we program in Perl, and even the way we think about programming. This article explores Perl&#39;s new threading...">
<meta property="og:site_name" content="Perl.com" />

<meta property="og:type" content="article" />
<meta property="og:article:published_time" content="2002-09-09T09:09:09Z" />
<meta property="og:image" content="http://localhost:1313/images/_pub_2002_09_04_threads/111-oracleperl.gif" />
<meta property="og:article:tag" content="elevator-threading-threads-simulation" />


  <link rel="icon" href="/favicon.ico">
  <link href="/article/index.xml" rel="alternate" type="application/rss+xml" title="Perl.com - programming news, code and culture" />
  <link href="/article/index.xml" rel="feed" type="application/rss+xml" title="Perl.com - programming news, code and culture" />
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" type="text/css" href="/css/perldotcom.css"/>


<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-50555-22', 'auto');
ga('create', 'UA-85734801-2', 'auto', 'editor');
ga('send', 'pageview');
ga('editor.send', 'pageview');
</script>

</head>
<body>

<div class="container-fluid full-wdith antonio">
 <div class="row">
  <div class="navbar-inverse" style="border-radius:none !important" role="navigation">
    <div class="container-fluid">
      <ul class="nav navbar-nav pull-right follow">
          <li>MORE:</li>
          <li><a href="https://perl.org">
              <img src="/images/site/perl-onion_20.png" alt="Perl Onion"></a><li>
          <li><a href="https://twitter.com/intent/follow?screen_name=perlfoundation">
              <img src="/images/site/twitter_20.png" alt="twitter"></a><li>
          <li><a href="/article/index.xml" />
              <img src="/images/site/rss_20.png" alt="rss"></a></li>
          <li><a href="https://github.com/tpf/perldotcom" />
              <img src="/images/site/github_light_20.png" alt="GitHub logo"></a></li>
      </ul>
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
          <a class="navbar-nav" href="/">
            <div class="header-logo">Perl.com</div>
          </a>
      </div>
      <div class="navbar-collapse collapse">
        <ul class="nav navbar-nav">
          <li><a href="/about">
              <div class="circle">
                <img src="/images/site/perl-camel.png" alt="" />
              </div>
                  &nbsp;&nbsp;ABOUT</a>
          </li>
          <li><a href="/authors">
              <div class="circle">
                  <span class="glyphicon glyphicon-user txt-blue-major" aria-hidden="true"></span>
              </div>
                  &nbsp;&nbsp;AUTHORS</a>
          </li>
          <li><a href="/categories">
              <div class="circle">
                  <span class="glyphicon glyphicon-folder-open txt-blue-major" aria-hidden="true"></span>
              </div>
                  &nbsp;&nbsp;CATEGORIES</a>
          </li>
          <li><a href="/tags">
              <div class="circle">
                <span class="txt-blue-major" aria-hidden="true"><strong>#</strong></span>
              </div>
                  &nbsp;&nbsp;TAGS</a>
          </li>
          <li>
            <form class="search" name="ddg" action="https://duckduckgo.com/" method="get">
              <input type="text" name ="q" placeholder="SEARCH" />
              <input type="hidden" value="perl.com" name="sites" />
            </form>
          </li>
        </ul>
      </div>
    </div>
  </div>
 </div>
</div>


  <section id="content" role="main">
    <section class="entry-content">
      <div class="container">
        <div class="row">
          <div class="col-md-9">
            <div class="row">
              <article class="fulltext">
              <h1 class="blog-post-title">Going Up?</h1>
              <p class="blog-post-meta">Sep 4, 2002 by
              
              
                
                
                <a href="#author-bio-sam-tregar">Sam Tregar</a>
              
              </p>
              <img alt="" src=""/>
                

<p>Perl 5.8.0 is the first version of Perl with a stable threading implementation. Threading has the potential to change the way we program in Perl, and even the way we think about programming. This article explores Perl&rsquo;s new threading support through a simple toy application - an elevator simulator.</p>

<p>Until now, Perl programmers have had a single mechanism for parallel processing - the venerable <code>fork()</code>. When a program forks, an entirely new process is created. It runs the same code as the parent process, but exists in its own memory space with no access to the parent process&rsquo; memory. Communication between forked processes is possible but it&rsquo;s not at all convenient, requiring pipes, sockets, shared memory or other clumsy mechanisms.</p>

<p>In contrast, multiple threads exist inside a single process, in the same memory space as the creating thread. This allows threads to communicate much more easily than separate processes. The potential exists for threads to work together in ways that are virtually impossible for normal processes.</p>

<p><img src="/images/_pub_2002_09_04_threads/figure1.gif" alt="figure1" />
Additionally, threads are faster to create and use less memory than full processes (to what degree depends on your operating system). Perl&rsquo;s current threading implementation doesn&rsquo;t do a good job of realizing these gains, but improvements are expected. If you learn to thread now, then you&rsquo;ll be ready to take advantage of the extra speed when it arrives. But even if it never gets here, thread programming is still a lot of fun!</p>

<h2 id="span-id-building-a-threading-perl-building-a-threading-perl-span"><span id="building a threading perl">Building a Threading Perl</span></h2>

<p>To get started with threads you&rsquo;ll need to compile Perl 5.8.0 (<a href="http://cpan.org/src/stable.tar.gz">http://cpan.org/src/stable.tar.gz</a>) with threads enabled. You can do that with this command in the unpacked source directory:</p>

<pre><code>  sh Configure -Dusethreads
</code></pre>

<p>Also, it&rsquo;s a good idea to install your thread-capable Perl someplace different than your default install as enabling threading will slow down even nonthreaded programs. To do that, use the <code>-Dprefix</code> argument to configure. You&rsquo;ll also need to tell Configure not to link this new Perl as <code>/usr/bin/perl</code> with <code>-Uinstallusrbinperl</code>. Thus, a good Configure line for configuring a threaded Perl might be:</p>

<pre><code>  sh Configure -Dusethreads -Dprefix=~/myperl -Uinstallusrbinperl
</code></pre>

<p>Now you can <code>make</code> and <code>make install</code>. The resulting Perl binary will be ready to run the simulator in Listing 1, so go ahead and give it a try. When you get back, I&rsquo;ll explain how it works.</p>

<h2 id="span-id-an-elevator-simulator-an-elevator-simulator-span"><span id="an elevator simulator">An Elevator Simulator</span></h2>

<p>The elevator simulator&rsquo;s design was inspired by an assignment from Professor Robert Dewar&rsquo;s class in programming languages at New York University. The objective of that assignment was to learn how to use the threading features of Ada. The requirements are simple:</p>

<ul>
<li>Each elevator and each person must be implemented as a separate thread.</li>
<li>People choose a random floor and ride up to it from the ground floor. They wait there for a set period of time and then ride back down to the ground floor.</li>
<li>At the end of the simulation, the user receives a report showing the efficiency of the elevator algorithm based on the waiting and riding time of the passengers.</li>
<li>Basic laws of physics must be respected. No teleporting people allowed!</li>
</ul>

<p>The class assignment also required students to code a choice of elevator algorithms, but I&rsquo;ve left that part as an exercise for the reader. (See how lazy I can get without a grade hanging over my head?)</p>

<p>When you run the simulator you&rsquo;ll see output like:</p>

<pre><code>  $ ./elevator.pl
  Elevator 0 stopped at floor 0.
  Elevator 1 stopped at floor 0.
  Elevator 2 stopped at floor 0.
  Person 0 waiting on floor 0 for elevator to floor 11.
  Person 0 riding elevator 0 to floor 11.
  Elevator 0 going up to floor 11.
  Person 1 waiting on floor 0 for elevator to floor 1.
  Person 2 waiting on floor 0 for elevator to floor 14.
  Person 2 riding elevator 1 to floor 14.
  Person 1 riding elevator 1 to floor 1.
  Elevator 1 going up to floor 1.
</code></pre>

<p>And when the simulation finishes, you&rsquo;ll get some statistics:</p>

<pre><code>  Average Wait Time:   1.62s
  Average Ride Time:   4.43s

  Longest Wait Time:   3.95s
  Longest Ride Time:  10.09s
</code></pre>

<h2 id="span-id-perl-s-threading-flavor-perl-s-threading-flavor-span"><span id="perl's threading flavor">Perl&rsquo;s Threading Flavor</span></h2>

<p>Before jumping headlong into the simulator code I would like to introduce you to Perl&rsquo;s particular threading flavor. There are a wide variety of threading models living in the world today - POSIX threads, Java threads, Linux threads, Windows threads, and many more. Perl&rsquo;s threads are none of these; they are of an entirely new variety. This means that you may have to set aside some of your assumptions about how threads work before you can truly grok Perl threads.</p>

<blockquote>
<p>Note that Perl&rsquo;s threads are not 5.005 threads. In Perl 5.005 an experimental threading model was created. Now known as 5.005 threads, this system is deprecated and should not be used by new code.</p>
</blockquote>

<p>In Perl&rsquo;s threading model, variables are <em>not</em> shared by default unless explicitly marked to be shared. This is important, and also different from most other threading models, so allow me to repeat myself. Unless you mark a variable as shared it will be treated as a private thread-local variable. The downside of this approach is that Perl has to clone all of the nonshared variables each time a new thread is created. This takes memory and time. The upside is that most nonthreaded Perl code will ``just work&rdquo; with threads. Since nonthreaded code doesn&rsquo;t declare any shared variables there&rsquo;s no need for locking and little possibility for problems.</p>

<p>Perl&rsquo;s threading model can be described as low-level, particularly compared to the threading models of Java and Ada. Perl offers you the ability to create threads, join them and yield processor time to other threads. For communication between threads you can mark variables as shared, lock shared variables, wait for signals on shared variables, and send signals on shared variables. That&rsquo;s it!</p>

<p>Most higher-level features, like Ada&rsquo;s entries or Java&rsquo;s synchronized methods, can be built on top of these basic features. I expect to see plenty of development happening on CPAN in this direction as more Perl programmers get into threads.</p>

<h2 id="span-id-preamble-preamble-span"><span id="preamble">Preamble</span></h2>

<p>Enough abstraction, let&rsquo;s see this stuff work! The elevator simulator in Listing 1 starts with a section of POD documentation describing how to use the program. After that comes a block of <code>use</code> declarations:</p>

<pre><code>  use 5.008;             # 5.8 required for stable threading
  use strict;            # Amen
  use warnings;          # Hallelujah
  use threads;           # pull in threading routines
  use threads::shared;   # and variable sharing routines
</code></pre>

<p>The first line makes sure that Perl version 5.8.0 or later is used to run the script. It isn&rsquo;t written <code>use 5.8.0</code> because that&rsquo;s a syntax error with older Perls and the whole point is to produce a friendly message telling the user to upgrade. The next lines are the obligatory <code>strict</code> and <code>warnings</code> lines that will catch many of the errors to which my fingers are prone.</p>

<p>Next comes the <code>use threads</code> call that tells Perl I&rsquo;ll be using multiple threads. This must come as early as possible in your programs and always before the next line, <code>use threads::shared</code>. The <code>threads::shared</code> module allows variables to be shared between threads, making communication between threads possible.</p>

<p>Finally, GetOpt::Long is used to load parameters from the command line. Once extracted, the parameter values are stored in global variables with names in all caps (<code>$NUM_ELEVATORS</code>, <code>$PEOPLE_FREQ</code>, and so on).</p>

<h2 id="span-id-building-state-building-state-span"><span id="building state">Building State</span></h2>

<p>The building is represented in the simulation with three shared variables, <code>%DOOR</code>, <code>@BUTTON</code> and <code>%PANEL</code>. These variables are declared as shared using the <code>shared</code> attribute:</p>

<pre><code>  # Building State
  our %DOOR   : shared; # a door for each elevator on each floor
  our @BUTTON : shared; # a button for each floor to call the elevators
  our %PANEL  : shared; # a panel of buttons in each elevator for each floor
</code></pre>

<p>When a variable is marked as shared its state will be synchronized between threads. If one thread makes a change to a shared variable then all the other threads will see that change. This means that threads will need to lock the variable in order to access it safely, as I&rsquo;ll demonstrate below.</p>

<p>The building state is initialized in the <code>init_building()</code> function.</p>

<pre><code>  # initialize building state
  sub init_building {
      # set all indicators to 0 to start the simulation
      for my $floor (0 .. $NUM_FLOORS - 1) {
          $BUTTON[$floor] = 0;
          for my $elevator (0 .. $NUM_ELEVATORS - 1) {
              $PANEL{&quot;$elevator.$floor&quot;} = 0;
              $DOOR{&quot;$elevator.$floor&quot;}  = 0;
          }
      }
  }
</code></pre>

<p>The buttons on each floor are set to 0 to indicate that they are ``off.&rdquo; When a person wants to summon the elevator to a floor they will set the button for that floor to 1 (<code>$BUTTON[$floor] = 1</code>).For each elevator there are a set of panel buttons and a set of doors, one for each floor. These are all cleared to 0 at the start of the simulation. When an elevator reaches a floor it will open the door by setting the appropriate item in <code>%DOOR</code> to 1 (<code>$DOOR{&quot;$elevator.$floor&quot;} = 1</code>). Similarly, people tell the elevators where to go by setting entries in <code>%PANEL</code> to 1 (<code>$PANEL{&quot;$elevator.$floor&quot;} = 1</code>).</p>

<p>Figure 2 shows a single-elevator building with four floors and three people. Don&rsquo;t worry if this doesn&rsquo;t make much sense yet, you&rsquo;ll see it in action later.</p>

<p><img src="/images/_pub_2002_09_04_threads/figure2.gif" alt="figure2" /></p>

<h2 id="span-id-thread-creation-thread-creation-span"><span id="thread creation">Thread Creation</span></h2>

<p>After calling <code>init_building()</code> to initialize the shared building state variables, the program creates the elevator threads inside <code>init_elevator()</code>:</p>

<pre><code>  # create elevator threads
  sub init_elevator {
      our @elevators;
      for (0 .. $NUM_ELEVATORS - 1) {
          # pass each elevator thread a unique elevator id
          push @elevators, threads-&gt;new(\&amp;Elevator::run,
                                        id =&gt; $_);
      }
  }
</code></pre>

<p>Threads are created by calling <code>threads-&gt;new()</code>. The first argument to <code>threads-&gt;new()</code> is a subroutine reference where the new thread will begin execution. In this case, it is the <code>Elevator::run()</code> subroutine declared later in the program. Anything after the first argument is passed as an argument to this subroutine. In this case each elevator is given a unique ID starting at 0.</p>

<p>The return value from <code>threads-&gt;new()</code> is an object representing the created thread. This is saved in a global variable, <code>@elevators</code>, for use later in shutting down the simulation.</p>

<p>After the elevators are created the simulation is ready to send in people with the <code>init_people()</code> routine:</p>

<pre><code>  # create people threads
  sub init_people {
      our @people;
      for (0 .. $NUM_PEOPLE - 1) {
          # pass each person thread a unique person id and a random
          # destination
          push @people, threads-&gt;new(\&amp;Person::run,
                                     id   =&gt; $_,
                                     dest =&gt; int(rand($NUM_FLOORS - 2)) + 1);

          # pause if we've launched enough people this second
          sleep 1 unless $_ % $PEOPLE_FREQ;
      }
  }
</code></pre>

<p>This routine creates <code>$PEOPLE_FREQ</code> people and then sleeps for one second before continuing. If this wasn&rsquo;t done, then all the people would arrive at the building at the same time and the simulation would be rather boring. Notice that while the main thread sleeps the simulation is proceeding in the elevator and people threads.</p>

<p>The people threads start at <code>Person::run()</code>, which will be described later. <code>Person::run()</code> receives two parameters - a unique ID and a randomly chosen destination floor. Each person will board an elevator at the ground floor, ride to this floor, wait there for a set period of time and then ride an elevator back down.</p>

<h2 id="span-id-the-elevator-class-the-elevator-class-span"><span id="the elevator class">The Elevator Class</span></h2>

<p>Each elevator thread contains an object of the Elevator class. The <code>Elevator::run()</code> routine creates this object as its first activity:</p>

<pre><code>  # run an Elevator thread, takes a numeric id as an argument and
  # creates a new Elevator object
  sub run {
      my $self = Elevator-&gt;new(@_);
</code></pre>

<p>Notice that since <code>$self</code> is <em>not</em> marked shared it is a thread-local variable. Thus, each elevator has its own private <code>$self</code> object. The <code>new()</code> method just sets up a hash with some useful state variables and returns a blessed object:</p>

<pre><code>  # create a new Elevator object
  sub new {
      my $pkg = shift;
      my $self = { state =&gt; STARTING,
                   floor =&gt; 0,
                   dest  =&gt; 0,
                   @_,
                 };
      return bless($self, $pkg);
  }
</code></pre>

<p>All elevators start at the ground floor (floor 0) with no destination. The <code>state</code> attribute is set to <code>STARTING</code> which comes from this set of constants used to represent the state of the elevator:</p>

<pre><code>  # state enumeration
  use constant STARTING   =&gt; 0;
  use constant STOPPED    =&gt; 1;
  use constant GOING_UP   =&gt; 2;
  use constant GOING_DOWN =&gt; 3;
</code></pre>

<p>After setting up the object, the elevator thread enters an infinite loop looking for button presses that will cause it to travel to a floor. At the top of the loop <code>$self-&gt;next_dest()</code> is called to determine where to go:</p>

<pre><code>    # run until simulation is finished
    while (1) {
        # get next destination
        $self-&gt;{dest} = $self-&gt;next_dest;
</code></pre>

<p>The <code>next_dest()</code> method examines the shared array <code>@BUTTON</code> to determine if any people are waiting for an elevator. It also looks at <code>%PANEL</code> to see if there are people inside the elevator heading to a particular floor. Since <code>next_dest()</code> accesses shared variables it starts with a call to <code>lock()</code> for each shared variable:</p>

<pre><code>  # choose the next destination floor by looking at BUTTONs and PANELs
  sub next_dest {
      my $self = shift;
      my ($id, $state, $floor) = @{$self}{('id', 'state', 'floor')};
      lock @BUTTON;
      lock %PANEL;
</code></pre>

<p>Perl&rsquo;s <code>lock()</code> is an advisory locking mechanism, much like <code>flock()</code>. When a thread locks a variable it will wait for any other threads to release their locks before proceeding. The lock obtained by <code>lock()</code> is lexical - that is, it lasts until the enclosing scope is exited. There is no <code>unlock()</code> call, so it&rsquo;s important to carefully scope your calls to <code>lock()</code>. In this case the locks on <code>@BUTTON</code> and <code>%PANEL</code> last until <code>next_dest()</code> returns.</p>

<p><code>next_dest()</code>&rsquo;s logic is simple, and largely uninteresting for the purpose of learning about thread programming. It does a simple scan across <code>@BUTTON</code> and <code>%PANEL</code> looking for <code>1</code>s and takes the first one it finds.</p>

<p>Once <code>next_dest()</code> returns the elevator has its marching orders. By comparing the current floor (<code>$self-&gt;{floor}</code>) to the destination the elevator now knows whether it should stop, or travel up or down. First, let&rsquo;s look at what happens when the elevator decides to stop:</p>

<pre><code>   # stopped?
   if ($self-&gt;{dest} == $self-&gt;{floor}) {
        # state transition to STOPPED?
        if ($self-&gt;{state} != STOPPED) {
            print &quot;Elevator $id stopped at floor $self-&gt;{dest}.\n&quot;;
            $self-&gt;{state} = STOPPED;
        }

        # wait for passengers
        $self-&gt;open_door;
        sleep $ELEVATOR_WAIT;
</code></pre>

<p>The code starts by printing a message and changing the state attribute if the elevator was previously moving. Then it calls the <code>open_door()</code> method and sleeps for <code>$ELEVATOR_WAIT</code> seconds.</p>

<p>The <code>open_door()</code> method opens the elevator door. This allows waiting people to board to elevator.</p>

<pre><code>  # open the elevator doors
  sub open_door {
      my $self = shift;
      lock %DOOR;
      $DOOR{&quot;$self-&gt;{id}.$self-&gt;{floor}&quot;} = 1;
      cond_broadcast(%DOOR);
  }
</code></pre>

<p>Like <code>next_dest()</code>, <code>open_door()</code> manipulates a shared variable so it starts with a call to <code>lock()</code>. It then sets the elevator door for the elevator on this floor to open by assigning <code>1</code> to the appropriate entry in <code>%DOOR</code>. Then it wakes up all waiting person threads by calling <code>cond_broadcast()</code> on <code>%DOOR</code>. I&rsquo;ll go into more detail about <code>cond_broadcast()</code> when I show you the Person class later on. For now suffice it to say that the people threads wait on the <code>%DOOR</code> variable and will be woken up by this call.</p>

<p>The other states, for going up and going down, are handled similarly:</p>

<pre><code>  } elsif ($self-&gt;{dest} &gt; $self-&gt;{floor}) {
      # state transition to GOING UP?
      if ($self-&gt;{state} != GOING_UP) {
          print &quot;Elevator $id going up to floor $self-&gt;{dest}.\n&quot;;
          $self-&gt;{state} = GOING_UP;
          $self-&gt;close_door;
      }

      # travel to next floor up
      sleep $ELEVATOR_SPEED;
      $self-&gt;{floor}++;

  } else {
      # state transition to GOING DOWN?
      if ($self-&gt;{state} != GOING_DOWN) {
          print &quot;Elevator $id going down to floor $self-&gt;{dest}.\n&quot;;
          $self-&gt;{state} = GOING_DOWN;
          $self-&gt;close_door;
      }

      # travel to next floor down
      sleep $ELEVATOR_SPEED;
      $self-&gt;{floor}--;
  }
</code></pre>

<p>The elevator looks at the last value for <code>$self-&gt;{state}</code> to determine whether it was already heading up or down. If not, then it prints a message and calls <code>$self-&gt;close_door()</code>. Then it sleeps for <code>$ELEVATOR_SPEED</code> seconds as it travels between floors and adjusts its current floor accordingly.</p>

<p>The <code>close_door()</code> method simply does the inverse of <code>open_door()</code>, but without the call to <code>cond_broadcast()</code> since there&rsquo;s no point waking people up if they can&rsquo;t get on the elevator:</p>

<pre><code>  # close the elevator doors
  sub close_door {
      my $self = shift;
      lock %DOOR;
      $DOOR{&quot;$self-&gt;{id}.$self-&gt;{floor}&quot;} = 0;
  }
</code></pre>

<p>Finally, at the bottom of the elevator loop there is a check on the shared variable <code>$FINISHED</code>:</p>

<pre><code>  # simulation over?
  { lock $FINISHED; return if $FINISHED; }
</code></pre>

<p>Since the elevator threads are in an infinite loop the main thread needs a way to tell them when the simulation is over. It uses the shared variable <code>$FINISHED</code> for this purpose. I&rsquo;ll go into more detail about why this is necessary later.</p>

<p>That&rsquo;s all there is to the Elevator class code. Elevators simply travel from floor to floor opening and closing doors in response to buttons being pushed by people.</p>

<h2 id="span-id-the-person-class-the-person-class-span"><span id="the person class">The Person Class</span></h2>

<p>Now that we&rsquo;ve looked at the machinery, let&rsquo;s turn our attention to the inhabitants of this building, the people. Each person thread is created with a goal - ride an elevator up to the assigned floor, wait a bit and then ride an elevator back down. Person threads are also responsible for keeping track of how long they wait for the elevator and how long they ride. When they finish they report this information back to the main thread where it is output for your edification.</p>

<p><code>Person::run()</code> starts the same way as <code>Elevator::run()</code>, by creating a new object:</p>

<pre><code>  # run a Person thread, takes an id and a destination floor as
  # arguments.  Creates a Person object.
  sub run {
      my $self = Person-&gt;new(@_);
</code></pre>

<p>Inside <code>Person::new()</code> two attributes are setup to keep track of the person&rsquo;s progress, floor and elevator:</p>

<pre><code>  # create a new Person object
  sub new {
      my $pkg = shift;
      my $self = { @_,
                   floor    =&gt; 0,
                   elevator =&gt; 0 };
      return bless($self, $pkg);
  }
</code></pre>

<p>Back in <code>Person::run()</code> the person thread begins waiting for the elevator by calling <code>$self-&gt;wait()</code>. The calls to <code>time()</code> will be used later to report on how long the person waited.</p>

<pre><code>  # wait for elevator going up
  my $wait_start1 = time;
  $self-&gt;wait;
  my $wait1 = time - $wait_start1;
</code></pre>

<p>The <code>wait()</code> method is responsible for waiting until an elevator arrives and opens its doors on this floor:</p>

<pre><code>  # wait for an elevator
  sub wait {
      my $self = shift;

      print &quot;Person $self-&gt;{id} waiting on floor 1 for elevator &quot;,
        &quot;to floor $self-&gt;{dest}.\n&quot;;

      while(1) {
          $self-&gt;press_button();
          lock(%DOOR);
          cond_wait(%DOOR);
          for (0 .. $NUM_ELEVATORS - 1) {
              if ($DOOR{&quot;$_.$self-&gt;{floor}&quot;}) {
                  $self-&gt;{elevator} = $_;
                  return;
              }
          }
      }
  }

  # signal an elevator to come to this floor
  sub press_button {
      my $self = shift;
      lock @BUTTON;
      $BUTTON[$self-&gt;{floor}] = 1;
  }
</code></pre>

<p>After printing out a message, the code enters an infinite loop waiting for the elevator. At the top of the loop, the <code>press_button()</code> method is called. <code>press_button()</code> locks <code>@BUTTON</code> and sets <code>$BUTTON[$self-&gt;{floor}]</code> to <code>1</code>. This will tell the elevators that a person is waiting on the ground floor.</p>

<p>The code then locks <code>%DOOR</code> and calls <code>cond_wait(%DOOR)</code>. This has the effect of releasing the lock on <code>%DOOR</code> and putting the thread to sleep until another thread does a <code>cond_broadcast(%DOOR)</code> (or <code>cond_signal(%DOOR)</code>, a variant of <code>cond_broadcast()</code> that just wakes a single thread). When the thread wakes up again it re-acquires the lock on <code>%DOOR</code> and then checks to see if the door that just opened is on this floor. If it is the person notes the elevator and returns from <code>wait()</code>.</p>

<p>If there&rsquo;s no elevator on the floor where the person is waiting, the loop is run again. The person presses the button again and then goes back to sleep waiting for the elevator. You might be wondering why the call to <code>press_button()</code> is inside the loop instead of outside. The reason is that it is possible for the person to wake up from <code>cond_wait()</code> but have to wait so long to re-acquire the lock on <code>%DOOR</code> that the elevator is already gone.</p>

<p>Once the elevator arrives, control returns to <code>run()</code> and the person boards the elevator:</p>

<pre><code>    # board the elevator, wait for arrival at destination floor and get off
    my $ride_start1 = time;
    $self-&gt;board;
    $self-&gt;ride;
    $self-&gt;disembark;
    my $ride1 = time - $ride_start1;
</code></pre>

<p>The <code>board()</code> method is simple enough. It just turns off the <code>@BUTTON</code> entry used to summon the elevator and presses the appropriate button inside the elevator&rsquo;s <code>%PANEL</code>:</p>

<pre><code>  # get on an elevator
  sub board {
      my $self = shift;
      lock @BUTTON;
      lock %PANEL;
      $BUTTON[$self-&gt;{floor}] = 0;
      $PANEL{&quot;$self-&gt;{elevator}.$self-&gt;{dest}&quot;} = 1;
  }
</code></pre>

<p>Next, the <code>run()</code> code calls <code>ride()</code> which does another <code>cond_wait()</code> on <code>%DOOR</code>, this time waiting for the door in the elevator to open on the destination floor:</p>

<pre><code>  # ride to the destination
  sub ride {
      my $self = shift;

      print &quot;Person $self-&gt;{id} riding elevator $self-&gt;{elevator} &quot;,
        &quot;to floor $self-&gt;{dest}.\n&quot;;

      lock %DOOR;
      cond_wait(%DOOR) until $DOOR{&quot;$self-&gt;{elevator}.$self-&gt;{dest}&quot;};
  }
</code></pre>

<p>When the elevator arrives, <code>ride()</code> will return and the person thread calls <code>disembark()</code>, which clears the entry in <code>%PANEL</code> for this floor and sets the current floor in <code>$self-&gt;{floor}</code>.</p>

<pre><code>  # get off the elevator
  sub disembark {
      my $self = shift;


      print &quot;Person $self-&gt;{id} getting off elevator $self-&gt;{elevator} &quot;,
        &quot;at floor $self-&gt;{dest}.\n&quot;;


      lock %PANEL;
      $PANEL{&quot;$self-&gt;{elevator}.$self-&gt;{dest}&quot;} = 0;
      $self-&gt;{floor} = $self-&gt;{dest};
  }
</code></pre>

<p>After reaching the destination floor, the person thread waits for <code>$PEOPLE_WAIT</code> seconds and then heads back down by repeating the steps again with <code>$self-&gt;{dest}</code> set to 0:</p>

<pre><code>    # spend some time on the destination floor and then head back
    sleep $PEOPLE_WAIT;
    $self-&gt;{dest} = 0;
</code></pre>

<p>When this is complete the person has arrived at the ground floor. The thread ends by returning the recorded timing data with <code>return</code>:</p>

<pre><code>    # return wait and ride times
    return ($wait1, $wait2, $ride1, $ride2);
</code></pre>

<h2 id="span-id-the-grand-finale-the-grand-finale-span"><span id="the grand finale">The Grand Finale</span></h2>

<p>While the simulation is running the main thread is sitting in <code>init_people()</code> creating person threads periodically. Once this task is complete the <code>finish()</code> routine is called.</p>

<p>The first task of <code>finish()</code> is to collect statistics from the people threads as they complete:</p>

<pre><code>  # finish the simulation - join all threads and collect statistics
  sub finish {
      our (@people, @elevators);


      # join the people threads and collect statistics
      my ($total_wait, $total_ride, $max_wait, $max_ride) = (0,0,0,0);
      foreach my $person (@people) {
          my ($wait1, $wait2, $ride1, $ride2) = $person-&gt;join;
          $total_wait += $wait1 + $wait2;
          $total_ride += $ride1 + $ride2;
          $max_wait    = $wait1 if $wait1 &gt; $max_wait;
          $max_wait    = $wait2 if $wait2 &gt; $max_wait;
          $max_ride    = $ride1 if $ride1 &gt; $max_ride;
          $max_ride    = $ride2 if $ride2 &gt; $max_ride;
      }
</code></pre>

<p>To extract return values from a finished thread the <code>join()</code> method must be called on the thread object. This method will wait for the thread to end, which means that this loop won&rsquo;t finish until the last person reaches the ground floor.</p>

<p>Once all the people are processed, the simulation is over. To tell the elevators to shutdown the shared variable <code>$FINISHED</code> is set to 1 and the elevators are joined:</p>

<pre><code>  # tell the elevators to shut down
  { lock $FINISHED; $FINISHED = 1; }
  $_-&gt;join for @elevators;
</code></pre>

<p>If this code were omitted the simulation would still end but Perl would print a warning because the main thread exited with other threads still running.</p>

<p>Finally, <code>finish()</code> prints out the statistics collected from the person threads:</p>

<pre><code>  # print out statistics
  print &quot;\n&quot;, &quot;-&quot; x 72, &quot;\n\nSimulation Complete\n\n&quot;, &quot;-&quot; x 72, &quot;\n\n&quot;;
  printf &quot;Average Wait Time: %6.2fs\n&quot;,   ($total_wait / ($NUM_PEOPLE * 2));
  printf &quot;Average Ride Time: %6.2fs\n\n&quot;, ($total_ride / ($NUM_PEOPLE * 2));
  printf &quot;Longest Wait Time: %6.2fs\n&quot;,   $max_wait;
  printf &quot;Longest Ride Time: %6.2fs\n\n&quot;, $max_ride;
</code></pre>

<p>The end!</p>

<h2 id="span-id-a-few-wrinkles-a-few-wrinkles-span"><span id="a few wrinkles">A Few Wrinkles</span></h2>

<p>Overall, the simulator was a fun project with few major stumbling blocks. However, there were a few problems or near problems that you would do well to avoid.</p>

<p><strong>Deadlock</strong></p>

<p>All parallel programs are susceptible to deadlock, but, by virtue of higher levels of inter-activity, threads suffer it more frequently. Deadlock occurs when independent threads (or processes) each need a resource the other has.</p>

<p>In the elevator simulator I avoided deadlock by always performing multiple locks in the same order. For example, <code>Elevator::next_dest()</code> begins with:</p>

<pre><code>  lock @BUTTON;
  lock %PANEL;
</code></pre>

<p>And in <code>Person::board()</code> the same sequence is repeated:</p>

<pre><code>  lock @BUTTON;
  lock %PANEL;
</code></pre>

<p>If the lock calls in <code>Person::board()</code> were reversed then the following could occur:</p>

<ol>
<li>Elevator 2 locks <code>@BUTTON</code>.</li>
<li>Person 3 locks <code>%PANEL</code>.</li>
<li>Elevator 2 tries to lock <code>%PANEL</code> and blocks waiting for Person 3&rsquo;s lock.</li>
<li>Person 3 tries to lock <code>@BUTTON</code> and blocks waiting for Elevator 2&rsquo;s lock.</li>
<li><em>Deadlock!</em> Neither thread can proceed and the simulation will never end.</li>
</ol>

<p><strong>Modules</strong></p>

<p>In general, unless a module has been specifically vetted as thread safe it cannot be used in a threaded program. Most pure Perl modules should be thread safe but most XS modules are not. This goes for core modules too!</p>

<p>An earlier version of the elevator simulator used Time::HiRes to allow for fractional <code>sleep()</code> times. This really helped speed up the simulation since it meant that elevators could traverse more than one floor per second. However, on further investigation (and advice from Nick Ing-Simmons) I realized that Time::HiRes is not necessarily thread safe. Although it seemed to work fine on my machine there&rsquo;s no reason to believe that would be the case elsewhere, or even that it wouldn&rsquo;t blow up at some random point in the future. The problem with thread safety is that it&rsquo;s virtually impossible to test for; either you can prove you have it or you must assume you don&rsquo;t!</p>

<p><strong>Synchronized <code>rand()</code></strong></p>

<p>The first version of the simulator I wrote had the people threads calling <code>rand()</code> inside <code>Person::run()</code> to choose the destination floor. I also had a call to <code>srand()</code> in the main thread, not realizing that Perl now calls <code>srand()</code> with a good seed automatically. The combination resulted in every person choosing the same destination floor. Yikes!</p>

<p>The reason for this is that by calling <code>srand()</code> in the main thread I set the random seed. Then when the threads were created that seed was copied into each thread. The call to <code>rand()</code> then generated the same first value in each thread.</p>

<h2 id="span-id-resources-resources-span"><span id="resources">Resources</span></h2>

<p>Perl comes with copious threading documentation. You can read these docs by following the links below or by using the <code>perldoc</code> program that comes with Perl.</p>

<ul>
<li><a href="/media/_pub_2002_09_04_threads/elevator.pl">elevator.pl</a> - Sample code from this article.</li>
<li><a href="https://perldoc.perl.org/perlthrtut.html">perlthrtut</a> - a threading tutorial</li>
<li><a href="https://metacpan.org/pod/threads">threads</a> - the reference for the threads module</li>
<li><a href="https://metacpan.org/pod/threads::shared">threads::shared</a> -the reference for the threads::shared module</li>
</ul>

              </article>
              <p><strong>Tags</strong></p>
              <div class="tags">
                <div class="category"><a href="/categories/development">development</a></div>
                
                  <div class="tag"><a href="/tags/elevator-threading-threads-simulation">elevator-threading-threads-simulation</a></div>
                
              </div>
            </div>
            
              
                
<div class="row" id="author-bio-sam-tregar">
  <div class="col-sm-2">
    
    <a href="/authors/sam-tregar/"><div class="circle-avatar" style="background-image:url(/images/site/avatar.png)"></div></a>
  </div>
  <div class="col-sm-10">
    <a href="/authors/sam-tregar/"><h3>Sam Tregar</h3></a>
    <p></p>
    <h5><a href="/authors/sam-tregar/">Browse their articles</a></h5>
  </div>
</div>

            
            <div class="row">
              <h3>Feedback</h3>
              <p>Something wrong with this article? Help us out by opening an issue or pull request on <a href="https://github.com/tpf/perldotcom/blob/master/content/legacy/_pub_2002_09_04_threads.md">GitHub</a></p>
            </div>
          </div>
          <div class="col-md-3">
            <div class="latest-sidebar">

  <div class="row">
    <div class="col-sm-12 centering">
      <span style="font-size:1.8em" class="antonio txt-blue-major">OUR LATEST ARTICLES</span>
    </div>
  </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/the-perl-admbassador-curtis-poe/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/the-perl-ambassador-curtis-poe/curtis-poe.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>The Perl Ambassador: Curtis &#39;Ovid&#39; Poe</h6>
          <p style="line-height:1"><small>The person behind the news of Perl</small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/a-tour-with-net-ftp/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/a-tour-with-net-ftp/thumb_kidyes.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>A tour with Net::FTP</h6>
          <p style="line-height:1"><small>How to write an FTP client in Perl</small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/shortcode_test/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/author/brian-d-foy.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>shortcode_test</h6>
          <p style="line-height:1"><small></small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/listen-to-larry-wall-s-state-of-the-onion-2000-on-youtube/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/listen-to-larry-wall-s-state-of-the-onion-2000-on-youtube/thumb_larry-wall.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>Listen to Larry Wall&#39;s State of the Onion 2000 on YouTube</h6>
          <p style="line-height:1"><small></small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/announcing-perl-7/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/announcing-perl-7/thumb_seven_on_blue_wall.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>Announcing Perl 7</h6>
          <p style="line-height:1"><small>Perl 5 with modern defaults</small></p>
      </div>
        </a>
    </div>
  
</div>
<div class="row" style="margin-top:20px">
  <div class="col-sm-12 centering">
  <script async src="/widget/toplinks/toplinks.js" type="text/javascript"></script>
    <div id="toplinks"></div>
  </div>
</div>

<div class="row" style="margin-top:20px">
  <div class="col-sm-12 centering">
    <a class="twitter-timeline" data-height="640" data-dnt="true" data-theme="dark" href="https://twitter.com/perlfoundation?ref_src=twsrc%5Etfw">Tweets by perlfoundation</a> <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
  </div>
</div>

<div class="row" style="margin-top:20px">
  <div class="col-sm-12 centering">
    <script src="https://www.reddit.com/r/perl/hot/.embed?limit=10&t=all" type="text/javascript"></script>
  </div>
</div>



          </div>
        </div>
      </div>
    </section>
  </section>
<script>
 
var tables, i;
tables = document.getElementsByTagName('table');
for (i=0;i<tables.length;i++) {
  tables[i].className = 'table table-striped';
}
</script>
<div class="push"></div>
<div class="footer">
  <div class="container">
    <div class="row">
      <div class="col-md-1">
        <h5>Site Map</h5>
        <ul>
        <li><a href="/">Home</a></li>
        <hr>
        <li><a href="/about">About</a></li>
        <hr>
        <li><a href="/authors">Authors</a></li>
        <hr>
        <li><a href="/categories">Categories</a></li>
        <hr>
        <li><a href="/tags">Tags</a></li>
        <hr>
        </ul>
      </div>
      <div class="col-md-3">
        <h5>Contact Us</h5>
        <p>To get in touch, send an email to: perl.com-editor@perl.org</p>
        <p><a href="https://perl.org">
              <img src="/images/site/perl-onion_20.png" alt="Perl Onion"></a>
          <a href="https://twitter.com/intent/follow?screen_name=perlfoundation">
              <img src="/images/site/twitter_20.png" alt="twitter"></a>
          <a href="/index.xml" /><img src="/images/site/rss_20.png" alt="rss"></a>
          <a href="https://github.com/tpf/perldotcom">
              <img src="/images/site/github_light_20.png" alt="GitHub logo"></a></p>
      </div>
      <div class="col-md-2">
          <h5>License</h5>
          <p>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc/3.0/">Creative Commons Attribution-NonCommercial 3.0 Unported License</a>.</p>
          <p><a rel="license" href="https://creativecommons.org/licenses/by-nc/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/3.0/88x31.png" /></a></p>
      </div>
      <div class="col-md-5">
          <h5>Legal</h5>
          <p>Perl.com and the authors make no representations with respect to the accuracy or completeness of the contents of all work on this website and specifically disclaim all warranties, including without limitation warranties of fitness for a particular purpose. The information published on this website may not be suitable for every situation. All work on this website is provided with the understanding that Perl.com and the authors are not engaged in rendering professional services. Neither Perl.com nor the authors shall be liable for damages arising herefrom.</p>
      </div>
    </div>
  </div>
</div>
<script src="/javascript/jquery.min.js"></script>
<script src="/javascript/bootstrap.min.js"></script>
<script data-no-instant>document.write('<script src="/livereload.js?port=1313&mindelay=10"></' + 'script>')</script></body>
</html>

