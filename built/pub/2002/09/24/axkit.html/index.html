<!DOCTYPE html>
<html lang="en-us">
  <head>
  <title> An AxKit Image Gallery </title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content=" AxKit is not limited to working with pure XML data. Starting with this article, we&#39;ll work with and around non-XML data by developing an image browser that works with two types of non-XML data: a directory listing built from..."/>
  <meta name="robots" content="index, follow">
  <meta name="google-site-verification" content="TZowffo_LX2mmsw2DbeNNbukCMnIOA8T-6CMJPiYllI" />

<meta property="twitter:card" content="summary">
<meta property="twitter:site" content="@PerlFoundation">
<meta property="og:url" content="http://localhost:1313/pub/2002/09/24/axkit.html/" />
<meta property="og:title" content="An AxKit Image Gallery" />
<meta property="og:description" content=" AxKit is not limited to working with pure XML data. Starting with this article, we&#39;ll work with and around non-XML data by developing an image browser that works with two types of non-XML data: a directory listing built from...">
<meta property="og:site_name" content="Perl.com" />

<meta property="og:type" content="article" />
<meta property="og:article:published_time" content="2002-09-09T09:09:09Z" />
<meta property="og:image" content="http://localhost:1313/images/_pub_2002_09_24_axkit/111-komodo2.gif" />


  <link rel="icon" href="/favicon.ico">
  <link href="/article/index.xml" rel="alternate" type="application/rss+xml" title="Perl.com - programming news, code and culture" />
  <link href="/article/index.xml" rel="feed" type="application/rss+xml" title="Perl.com - programming news, code and culture" />
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" type="text/css" href="/css/perldotcom.css"/>


<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-50555-22', 'auto');
ga('create', 'UA-85734801-2', 'auto', 'editor');
ga('send', 'pageview');
ga('editor.send', 'pageview');
</script>

</head>
<body>

<div class="container-fluid full-wdith antonio">
 <div class="row">
  <div class="navbar-inverse" style="border-radius:none !important" role="navigation">
    <div class="container-fluid">
      <ul class="nav navbar-nav pull-right follow">
          <li>MORE:</li>
          <li><a href="https://perl.org">
              <img src="/images/site/perl-onion_20.png" alt="Perl Onion"></a><li>
          <li><a href="https://twitter.com/intent/follow?screen_name=perlfoundation">
              <img src="/images/site/twitter_20.png" alt="twitter"></a><li>
          <li><a href="/article/index.xml" />
              <img src="/images/site/rss_20.png" alt="rss"></a></li>
          <li><a href="https://github.com/tpf/perldotcom" />
              <img src="/images/site/github_light_20.png" alt="GitHub logo"></a></li>
      </ul>
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
          <a class="navbar-nav" href="/">
            <div class="header-logo">Perl.com</div>
          </a>
      </div>
      <div class="navbar-collapse collapse">
        <ul class="nav navbar-nav">
          <li><a href="/about">
              <div class="circle">
                <img src="/images/site/perl-camel.png" alt="" />
              </div>
                  &nbsp;&nbsp;ABOUT</a>
          </li>
          <li><a href="/authors">
              <div class="circle">
                  <span class="glyphicon glyphicon-user txt-blue-major" aria-hidden="true"></span>
              </div>
                  &nbsp;&nbsp;AUTHORS</a>
          </li>
          <li><a href="/categories">
              <div class="circle">
                  <span class="glyphicon glyphicon-folder-open txt-blue-major" aria-hidden="true"></span>
              </div>
                  &nbsp;&nbsp;CATEGORIES</a>
          </li>
          <li><a href="/tags">
              <div class="circle">
                <span class="txt-blue-major" aria-hidden="true"><strong>#</strong></span>
              </div>
                  &nbsp;&nbsp;TAGS</a>
          </li>
          <li>
            <form class="search" name="ddg" action="https://duckduckgo.com/" method="get">
              <input type="text" name ="q" placeholder="SEARCH" />
              <input type="hidden" value="perl.com" name="sites" />
            </form>
          </li>
        </ul>
      </div>
    </div>
  </div>
 </div>
</div>


  <section id="content" role="main">
    <section class="entry-content">
      <div class="container">
        <div class="row">
          <div class="col-md-9">
            <div class="row">
              <article class="fulltext">
              <h1 class="blog-post-title">An AxKit Image Gallery</h1>
              <p class="blog-post-meta">Sep 24, 2002 by
              
              
                
                
                <a href="#author-bio-barrie-slaymaker">Barrie Slaymaker</a>
              
              </p>
              <img alt="" src=""/>
                

<p>AxKit is not limited to working with pure XML data. Starting with this article, we&rsquo;ll work with and around non-XML data by developing an image browser that works with two types of non-XML data: a directory listing built from operating system calls (file names and statistics) and image files. Furthermore, it will be built from small modules that you can adapt to your needs or use elsewhere, like the <a href="/pub/2002/09/24/axkit.html?page=4#My::Thumbnailer">thumbnail generator</a> or the <a href="/pub/2002/09/24/axkit.html?page=3#XML::Filter::TableWrapper">HTML table wrapper</a>.</p>

<p>By the time we&rsquo;re done, several articles from now, we&rsquo;d like an application that:</p>

<ul>
<li>provides navigation around a tree of directories containing images,</li>
<li>displays <a href="/pub/2002/09/24/axkit.html?page=1#proofsheet.png">image galleries with thumbnails</a>,</li>
<li>ignores nonimage files,</li>
<li>allows you to define and present a custom set of information (&ldquo;meta data&rdquo;) about each image,</li>
<li>allows you to view the complete images with and without metadata,</li>
<li>uses a non-AxKit mod_perl handler to generate thumbnail images on the fly, and</li>
<li>allows you to edit the metadata information in-browser</li>
</ul>

<p>That feature list should allow us to build a &ldquo;real world&rdquo; application (rather than the weather examples we&rsquo;ve discussed so far), and hopefully a useful one as well. Here&rsquo;s a screenshot of the page created by this article and the next:</p>

<p><span id="proofsheet.png"></span><img src="/images/_pub_2002_09_24_axkit/proofsheet.png" alt="Example page." width="472" height="661" /></p>

<p>That page has four sections:</p>

<ol>
<li><strong>Heading</strong>: Tells you where you are and offers navigation up the directory tree.</li>
<li><strong>Folders</strong>: links to the parent directory and any sub folders (Jim and Mary).</li>
<li><strong>Images</strong>: offers a thumbnail and caption area for each image. Clicking on an image or image title takes you to the full-size variant.</li>
<li><strong>Footer</strong>: A breadcrumbs display for getting back up the directory tree after scrolling down through a large page of images.</li>
</ol>

<p>We&rsquo;ll implement the (most challenging) third section in this article and the other section in the next article.</p>

<p>If you want to review the basics of AxKit and Apache configuration, then here are the previous articles in this series:</p>

<ul>
<li><a href="/pub/2002/03/12/axkit.html">Introducing AxKit</a></li>
<li><a href="/pub/2002/04/16/axkit.html">XSP, Taglibs and Pipelines</a></li>
<li><a href="/pub/2002/07/02/axkit.html">Taglib TMTOWTDI</a></li>
</ul>

<p><span id="WorkingWithNonXMLDataAsXML"></span></p>

<h3 id="working-with-non-xml-data-as-xml">Working with non-XML data as XML</h3>

<p>The easiest way to actually work with non-XML data in AxKit is to turn it in to XML often and feed it to AxKit. AxKit itself takes this approach in its new directory handling feature &ndash; thanks to Matt Sergeant and JÃ¶rg Walters AxKit can now scan the directory and build an XML document with all of the data. This is a lot like what native Apache does when it serves up an HTML directory listing, but it allows you to filter it. The main part of this article is about filtering this directory listing in order to create a gallery, or proofsheet, of thumbnail images.</p>

<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td><p><strong>In This Series</strong></p>
<p><strong><a href="/pub/2002/03/16/axkit.html">Introducing AxKit</a></strong><br />
The first in a series of articles by Barrie Slaymaker on setting up and running AxKit. AxKit is a mod_perl application for dynamically transforming XML. In this first article, we focus on getting started with AxKit.</p>
<p><strong><a href="/pub/2002/04/16/axkit.html">XSP, Taglibs and Pipelines</a></strong><br />
Barrie explains what a &quot;taglib&quot; is, and how to use them to create dynamic pages inside of AxKit.</p>
<p><strong><a href="/pub/2002/07/02/axkit.html">Taglib TMTOWTDI</a></strong><br />
Continuing our look at AxKit tag libraries, Barrie explains the use of SimpleTaglib and LogicSheets.</p></td>
</tr>
</tbody>
</table>

<p>In this case, we&rsquo;ll be using a relatively recent addition to AxKit&rsquo;s standard toolkit, SAX Machines, integrated in to AxKit thanks to Kip Hampton. (disclaimer: <a href="https://metacpan.org/pod/XML::SAX::Machines">XML::SAX::Machines</a> is a module I wrote.) The SAX machine we&rsquo;ll create will be a straight pipeline with a few filters, a lot like the pipelines that AxKit uses. This pipeline will dissect directory listings and generate a list of images segmented into rows for easy display purposes. We don&rsquo;t get in to the details of SAX or SAX machines except to bolt together three building blocks; all of the gory details are handled for us by other modules. If you are interested in the gory details, then see <a href="https://www.xml.com/pub/a/2002/02/13/sax-machines.html">Part One</a> and <a href="https://www.xml.com/pub/a/2002/03/20/machines.html">Part Two</a> of Kip&rsquo;s article &ldquo;Introducing XML::SAX::Machines&rdquo; on <a href="https://www.xml.com/">XML.com</a>.</p>

<p>After the SAX machine builds our list of images, XSLT will be used to merge in metadata (like image titles and comments) from independant XML files and format the result for the browser. The resulting pages look like:</p>

<p><span id="ManagingNonXMLData"></span></p>

<h3 id="managing-non-xml-data-the-images">Managing non-XML data (the images)</h3>

<p>On the other hand, it doesn&rsquo;t make sense to XMLify raw image data (though things like <a href="http://www.w3.org/TR/SVG/">SVG</a>&ndash;covered in <a href="http://www.xml.com/pub/at/22">XML.com&rsquo;s Sacre SVG articles</a>&ndash;and <a href="https://wiki.gnome.org/Apps/Dia/">dia</a> files are a natural fit), so we&rsquo;ll take advantage of AxKit&rsquo;s integration with Apache and mod_perl to delegate image handlng to these more suitable tools.</p>

<p>This is done by using a distinctive URL for thumbnail image files and a custom mod_perl handler, <a href="/pub/2002/09/24/axkit.html?page=4#My::Thumbnailer">My::Thumbnailer</a> to convert full-size images to thumbnails. Neither AxKit nor mod_perl code will be used to serve the images, that will be left to Apache.</p>

<p>Thumbnails will be autogenerated in files with the same name as the main image file with a leading period (&ldquo;.&rdquo;) stuck on the front. In Unix land, this indicates a hidden file, and we don&rsquo;t want thumbnails (or other dotfiles) showing up in our gallery pages.</p>

<p>My::Thumbnailer uses the relatively new <a href="https://metacpan.org/pod/Imager">Imager</a> module by Arnar M. Hrafnkelsson and Tony Cook. This is a best-of-breed module that competes with the likes of the venerable <a href="https://metacpan.org/pod/GD">GD</a>, the juggernaut <a href="https://metacpan.org/pod/Image::Magick">Image::Magick</a>, and <a href="https://metacpan.org/pod/Graphics::Libplot">Graphics::Libplot</a>). Imager is gaining a reputation for speed, quality and a full-featured API.</p>

<p><span id="TheMetaFile"></span></p>

<h3 id="the-meta-file">The <code>.meta</code> file</h3>

<p>Before we delve in to the implementation, let&rsquo;s look at one of the more subtle points of this design. Our previous examples have all been of straight pipelines that successively process a source document into an HTML page. In this application, however, we&rsquo;ll be funneling data from the source document and a collection of related files we&rsquo;ll call meta files.</p>

<p>This subtlety is not apparent from the <a href="/pub/2002/09/24/axkit.html?page=1#proofsheet.png">screenshot</a>, but if you look closely you can see that the caption for the first image (&ldquo;A baby picture&rdquo;) contains more information than the captions for the other eight. This is because the first image has a meta file that contains a title and a comment to be displayed while the others don&rsquo;t (though they could).</p>

<p>The first image (&ldquo;A baby picture&rdquo;) is from a file named <code>a-look.jpeg</code>, for which there is a meta file named <code>a-look.meta</code> in the same directory that looks like (<strong>bold</strong> shows the data that ends up getting sent to the browser):</p>

<p><span id="a-look.meta"></span>
        <meta>
          <title>A baby picture</title>
          <comment>
            <b>ME!</b>.  Well, not really.  Actually, it&rsquo;s some
            random image from the &lsquo;net.
          </comment>
        </meta></p>

<p>An important feature of this file is that its contents and how they are presented within the caption area are completely unspecified by the core image gallery code. This makes our image gallery highly customizable: the site designer can determine what meta information needs to be associated with each image and how that information gets presented. Data can be presented in the thumbnail caption, in the expanded view, or used for nondisplay purposes.</p>

<p>Here&rsquo;s what&rsquo;s in each caption area:</p>

<ol>
<li><strong>The title</strong>. If a .meta file is found for an image and it has a nonempty <code>&lt;title&gt;</code> element, then it is used as the name, otherwise the image&rsquo;s filename is stripped of extensions and used.</li>
<li><strong>The last modified time of the image file</strong> (in server-local time, unfortunately).</li>
<li><strong>A comment</strong> (optional): if a .meta file has a <code>&lt;comment&gt;</code> element, including XHTML markup, it is displayed.</li>
</ol>

<p>Why a .meta file per image instead of one huge file? It will hopefully allow admins to manage images and meta files together and to allow us to access an image&rsquo;s meta information in a single file, a natural thing to do in AxKit. By having a pair of files for each image, you can use simple filesystem manipulations to move them around, or use filesystem links to make an image appear in multiple directories, perhaps with the same meta file, perhaps with different ones. This way we don&rsquo;t need to develop a lot of complex features to get a lot of mileage out of our image gallery (though we could if need be).</p>

<p><span id="ThePipeline"></span></p>

<h3 id="the-pipeline">The Pipeline</h3>

<p>No AxKit implementation documentation would be complete without detailing the pipeline. Here is the pipeline for the image proofsheet page shown above (click on any of the boxes to take you to the discussion about that portion of the pipeline, click on any of the miniature versions of this diagram to come to this one):</p>

<p><span id="pipeline.png"></span>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td><p><img src="/images/_pub_2002_09_24_axkit/pipeline.png" alt="The AxKit pipeline for the image gallery application, take 1" width="450" height="385" /><br />
The blue documents are content: the directory listing, the meta files and the generated HTML. This does not show the image processing, see <a href="/pub/2002/09/24/axkit.html?page=4#My::Thumbnailer">My::Thumbnailer</a> for that.</p></td>
</tr>
</tbody>
</table></p>

<p>In this case, unlike our previous pipelines, data does not flow in a purely linear fashion: The directory listing from AxKit (<a href="/pub/2002/09/24/axkit.html?page=2#filelist">&lt;filelist&gt;</a>) feeds the pipeline and is massaged by three SAX filters and then by four XSLT filters. There are so many filters because this application is built to be customizable by tweaking specific filters or by adding other filters to the pipeline. It also uses several SAX filters available on CPAN to make life much easier for us.</p>

<p>In actual use, you may want to add more filters for things like branding, distinguishing groups of images by giving directory heirarchies different backgrounds or titles, adding ad banners, etc.</p>

<p>Here&rsquo;s a brief description of what each filter does, and why each is an independant filter:</p>

<ul>
<li><a href="/pub/2002/09/24/axkit.html?page=2#My::ProofSheetMachine">My::ProofSheetMachine</a> is a short module that builds a <a href="https://metacpan.org/pod/XML::SAX::Machines">SAX Machine Pipeline</a>. SAX filters are used in this application to handle tasks that are more suited to Perl than to XSLT or XSP:

<ul>
<li><a href="/pub/2002/09/24/axkit.html?page=2#My::Filelist2Data">My::FileList2Data</a> is another short module that uses the <a href="https://metacpan.org/pod/XML::Simple">XML::Simple</a> module from CPAN to convert the <code>&lt;filelist&gt;</code> in to a Perl data structure that is passed on. This is its own filter because we want to customize XML::Simple and the resulting data structure a bit before passing it on.</li>
<li><a href="/pub/2002/09/24/axkit.html?page=3#My::ProofSheet">My::ProofSheet</a> is the heart of the gallery page generation. It builds a list of images from the filelist data structure and adds information about the thumbnail images and meta files.</li>
<li><a href="/pub/2002/09/24/axkit.html?page=3#XML::Filter::TableWrapper">XML::Filter::TableWrapper</a> is a module from CPAN that is used to wrap a possibly lengthy list of images into rows of no more than five images each.</li>
</ul></li>
<li><a href="/pub/2002/09/24/axkit.html?page=3#rowsplitter.xsl">rowsplitter.xsl</a> takes each row of images and makes it into two table rows: one for the images and one for the captions. This is easier to do in XSLT than in SAX, so here is where we shift from SAX processing to XSLT processing.</li>
<li><a href="/pub/2002/09/24/axkit.html?page=3#metamerger.xsl">metamerger.xsl</a> examines each caption to see if My::ProofSheet put the URL for a meta file in it. If so, it opens the meta file and inserts it in the caption. This is a separate filter because the site admin may prefer to write a custom filter here to integrate meta information from some other source, like a single master file or a centralized database.</li>
<li><a href="/pub/2002/09/24/axkit.html?page=4#captionstyler.xsl">captionstyler.xsl</a> looks at each caption and rewrites it to be XHTML. This is a separate filter for two reasons: it allows the look and feel of the captions to be altered without having to mess with the other filters and, because it is the only filter that cares about the contents of the meta file, the site admin can alter the schema of the meta files and then alter this filter to match.</li>
<li><a href="/pub/2002/09/24/axkit.html?page=4#pagestyler.xsl">pagestyler.xsl</a> converts everything outside of the caption elements in to HTML. It is separate so that the page look and feel can be altered per-site or per-directory without affecting the caption content, etc.</li>
</ul>

<p>There are several key things to note about this design. The first is that the separation of the process into multiple filters offers the administrator the ability to modify the site&rsquo;s content and styling. Second, because AxKit is built on Apache&rsquo;s configuration engine, which filters are used for a particular directory request can be selected based on URL, directory path, query string parameters, browser types, etc. The third point to note is the use of SAX processors to handle tasks that are easier (far easier in some cases) to implement in Perl, while XSLT is used when it is more (programmer and/or processor) efficient.</p>

<p><span id="httpd.conf"></span><span id="TheConfiguration"></span></p>

<h3 id="the-configuration">The Configuration</h3>

<p>Here&rsquo;s how we configure AxKit to do all of this:</p>

<pre><code>    ##
    ## Init the httpd to use our &quot;private install&quot; libraries
    ##
    PerlRequire startup.pl

    ##
    ## AxKit Configuration
    ##
    PerlModule AxKit

    &lt;Directory &quot;/home/me/htdocs&quot;&gt;
        Options -All +Indexes +FollowSymLinks

        # Tell mod_dir to translate / to /index.xml or /index.xsp
        DirectoryIndex index.xml index.xsp
        AddHandler axkit .xml .xsp

        AxDebugLevel 10

        AxTraceIntermediate /home/me/axtrace

        AxGzipOutput Off

        AxAddXSPTaglib AxKit::XSP::Util
        AxAddXSPTaglib AxKit::XSP::Param

        AxAddStyleMap text/xsl \
                      Apache::AxKit::Language::LibXSLT

        AxAddStyleMap application/x-saxmachines \
                      Apache::AxKit::Language::SAXMachines

    &lt;/Directory&gt;


    &lt;Directory &quot;/home/me/htdocs/04&quot;&gt;
        # Enable XML directory listings (see Generating File Lists)
        AxHandleDirs On

        #######################
        # Begin pipeline config
        AxAddRootProcessor application/x-saxmachines . \
            {http://axkit.org/2002/filelist}filelist
        PerlSetVar AxSAXMachineClass &quot;My::ProofSheetMachine&quot;

        # The absolute stylesheet URLs are because
        # I prefer to keep stylesheets out of the
        # htdocs for security reasons.
        AxAddRootProcessor text/xsl file:///home/me/04/rowsplitter.xsl \
            {http://axkit.org/2002/filelist}filelist

        AxAddRootProcessor text/xsl file:///home/me/04/metamerger.xsl \
            {http://axkit.org/2002/filelist}filelist

        AxAddRootProcessor text/xsl file:///home/me/04/captionstyler.xsl \
            {http://axkit.org/2002/filelist}filelist

        AxAddRootProcessor text/xsl file:///home/me/04/pagestyler.xsl \
            {http://axkit.org/2002/filelist}filelist
        # End pipeline config
        #####################

        # This is read by My::ProofSheetMachine
        PerlSetVar MyColumns 5

        # This is read by My::ProofSheet
        PerlSetVar MyMaxX 100

        # Send thumbnail image requests to our
        # thumbnail generator
        &lt;FilesMatch &quot;^\.&quot;&gt;
            SetHandler  perl-script
            PerlHandler My::Thumbnailer
            PerlSetVar  MyMaxX 100
            PerlSetVar  MyMaxY 100
        &lt;/FilesMatch&gt;

    &lt;/Directory&gt;
</code></pre>

<p>The first <code>&lt;Directory&gt;</code> section contains the AxKit directives we introduced in <a href="/pub/2002/07/02/axkit.html?page=2#MixingAndMatching">article 1</a> and a new stylesheet mapping for <code>application/x-saxmachines</code> that allows us to use a SAX machine in the pipeline. Otherwise, all of the configuration directives key to this example are in the <code>&lt;Directory &quot;/home/me/htdocs/04&quot;&gt;</code> section.</p>

<blockquote>
<p>We saw basic examples of how AxKit works with the Apache configuration engine in <a href="/pub/2002/07/02/axkit.html?page=2#MixingAndMatching">article 1</a> and <a href="/pub/2002/04/16/axkit.html#httpd.conf">article 2</a> in this series. We&rsquo;ll use this photo gallery application to demonstrate many of the more powerful mechanisms in a future article.</p>
</blockquote>

<p>By setting <code>AxHandleDirs On</code>, we tell AxKit to generate the &lt;filelist&gt; document (<a href="/pub/2002/09/24/axkit.html?page=2#GeneratingFileLists">described in the section Generating File Lists</a>) in the 04 directory and below.</p>

<p>Then it&rsquo;s off to configure the pipeline for the 04 directory hierarchy. To do this, we take advantage of the fact that AxKit places all elements in the filelist document in to the namespace <code>http://axkit.org/2002/filelist</code>. The <code>AxAddRootProcessor</code>&rsquo;s third parameter causes AxKit to look at all documents it serves from the 04 directory tree and check to see whether the root element matches the namespace and element name.</p>

<blockquote>
<p>This is specified in the notation used by James Clark in his <a href="http://www.jclark.com/xml/xmlns.htm">introduction to XML namespaces</a>.</p>
</blockquote>

<p>If the document matches, and all AxKit-generated filelists will, then the MIME type and the stylesheet specified in the first two parameters are added to the pipeline. The four <code>AxAddRootProcessor</code> directives add the SAX machine and the four XSLT filters we described in <a href="/pub/2002/09/24/axkit.html#ThePipeline">the section &ldquo;The Pipeline&rdquo;</a>.</p>

<p>When loading a SAX machine into the pipeline, you can give it a simple list of SAX filters (<a href="https://metacpan.org/search?q=XML%3A%3AFilter">there are many available on CPAN</a>) and it will build a pipeline of them. This is done with a (not shown) <code>PerlSetVar AxSAXMachineFilters &quot;...&quot;</code> directive. The limitation with this directive is that you cannot pass in any initialization values to the filters and we want to.</p>

<p>So, instead, we use the <code>PerlSetVar AxSAXMachineClass &quot;My::ProofSheetMachine&quot;</code> to tell the Apache::AxKit::Language::SAXMachines module to load the class <a href="/pub/2002/09/24/axkit.html?page=2#My::ProofSheetMachine">My::ProofSheetMachine</a> and let that class construct the SAX machine.</p>

<p>The final part of the configuration uses a <code>&lt;Files&gt;</code> section to forward all requests for thumbnail images to the mod_perl handler in <a href="/pub/2002/09/24/axkit.html?page=4#My::Thumbnailer">My::Thumbnailer</a>.</p>

<p><span id="WalkingThePipeline"></span></p>

<h3 id="walking-the-pipeline">Walking the Pipeline</h3>

<p>Now that we have our filters in place, let&rsquo;s walk the pipeline and take a look at each filter and what it emits.</p>

<p><span id="filelist"></span><span id="GeneratingFileLists"></span></p>

<h4 id="generating-file-lists">Generating File Lists</h4>

<p><a href="/pub/2002/09/24/axkit.html#pipeline.png" id="pipeline_filelist.png"><img src="/images/_pub_2002_09_24_axkit/pipeline_filelist.png" alt="&lt;filelist&gt; document&#39;s position in the processing pipeline" width="110" height="84" /></a></p>

<p>First, here&rsquo;s a look at the <code>&lt;filelist&gt;</code> document that feeds the chain. This is created by AxKit when it serves a directory request in much the same way that Apache creates HTML directory listings. AxKit only generates these pages when <code>AxHandleDirs On</code> directive. This causes AxKit to scan the directory for the above screenshot and emit XML like (whitespace added, repetitive stuff elided):</p>

<pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;!DOCTYPE filelist PUBLIC
      &quot;-//AXKIT/FileList XML V1.0//EN&quot;
      &quot;file:///dev/null&quot;
    &gt;
    &lt;filelist xmlns=&quot;http://axkit.org/2002/filelist&quot;&gt;
      &lt;directory
        atime=&quot;1032276941&quot;
        mtime=&quot;1032276939&quot;
        ctime=&quot;1032276939&quot;
        readable=&quot;1&quot;
        writable=&quot;1&quot;
        executable=&quot;1&quot;
        size=&quot;4096&quot; &gt;.&lt;/directory&gt;
      &lt;directory ...&gt;..&lt;/directory&gt;
      &lt;directory ...&gt;Mary&lt;/directory&gt;
      &lt;directory ...&gt;Jim&lt;/directory&gt;
      &lt;file mtime=&quot;1031160766&quot; ...&gt;a-look.jpeg&lt;/file&gt;
      &lt;file mtime=&quot;1031160787&quot; ...&gt;a-lotery.jpeg&lt;/file&gt;
      &lt;file mtime=&quot;1031160771&quot; ...&gt;a-lucky.jpeg&lt;/file&gt;
      &lt;file mtime=&quot;1032197214&quot; ...&gt;a-look.meta&lt;/file&gt;
      &lt;file mtime=&quot;1035239142&quot; ...&gt;foo.html&lt;/file&gt;
      ...
    &lt;/filelist&gt;
</code></pre>

<p>The emboldened bits are the pieces of data we want to display: some filenames and their modification times. Some things to notice:</p>

<ul>
<li>All of the elements &ndash; most importantly the root element as we&rsquo;ll see in a bit &ndash; are in a special namespace, <code>http://axkit.org/2002/filelist</code>, using the <code>xmlns=</code> attribute (see <a href="http://www.jclark.com/xml/xmlns.htm">James Clark&rsquo;s introduction</a> for details).</li>
<li>The entries are in unsorted order. We might want to allow the user to sort by different attributes someday, but this means that we at least need to sort the results somehow.</li>
<li>They contain the complete output from the <code>stat()</code> system call as attributes, so we can use the <code>mtime</code> attribute to derive a modification time.</li>
<li>There are files in there (<code>a-look.meta</code> and <code>foo.html</code>) that we clearly should not be displayed as images.</li>
<li>The filename for <code>a-look.jpeg</code> is not emboldened: We&rsquo;ll use the <code>&lt;title&gt;</code> element from the <code>a-look.meta</code> file instead.</li>
</ul>

<!-- -->

<pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;!DOCTYPE filelist PUBLIC
      &quot;-//AXKIT/FileList XML V1.0//EN&quot;
      &quot;file:///dev/null&quot;
    &gt;
    &lt;filelist xmlns=&quot;http://axkit.org/2002/filelist&quot;&gt;
      &lt;directory
        atime=&quot;1032276941&quot;
        mtime=&quot;1032276939&quot;
        ctime=&quot;1032276939&quot;
        readable=&quot;1&quot;
        writable=&quot;1&quot;
        executable=&quot;1&quot;
        size=&quot;4096&quot; &gt;.&lt;/directory&gt;
      &lt;directory ...&gt;..&lt;/directory&gt;
      &lt;directory ...&gt;Mary&lt;/directory&gt;
      &lt;directory ...&gt;Jim&lt;/directory&gt;
      &lt;file mtime=&quot;1031160766&quot; ...&gt;a-look.jpeg&lt;/file&gt;
      &lt;file mtime=&quot;1031160787&quot; ...&gt;a-lotery.jpeg&lt;/file&gt;
      &lt;file mtime=&quot;1031160771&quot; ...&gt;a-lucky.jpeg&lt;/file&gt;
      &lt;file mtime=&quot;1032197214&quot; ...&gt;a-look.meta&lt;/file&gt;
      &lt;file mtime=&quot;1035239142&quot; ...&gt;foo.html&lt;/file&gt;
      ...
    &lt;/filelist&gt;
</code></pre>

<p><span id="My::ProofSheetMachine"></span></p>

<h4 id="my-proofsheetmachine">My::ProofSheetMachine</h4>

<p><a href="/pub/2002/09/24/axkit.html#pipeline.png" id="pipeline_proofsheetmachine_pm.png"></a> <img src="/images/_pub_2002_09_24_axkit/pipeline_proofsheetmachine_pm.png" alt="My::ProofSheetMachine&#39;s position in the processing pipeline." width="110" height="84" /></p>

<p>The processing pipeline is kicked off with a set of three SAX filters built by the My::ProofSheetMachine module:</p>

<pre><code>    package My::ProofSheetMachine;

    use strict;

    use XML::SAX::Machines qw( Pipeline );
    use My::ProofSheet;
    use XML::Filter::TableWrapper;

    sub new {
        my $proto = shift;
        return bless {}, ref $proto || $proto;
    }

    sub get_machine {
        my $self = shift;
        my ( $r ) = @_;

        my $m = Pipeline(
            My::Filelist2Data
            =&gt; My::ProofSheet-&gt;new( Request =&gt; $r ),
            =&gt; XML::Filter::TableWrapper-&gt;new(
                ListTags =&gt; &quot;{}images&quot;,
                Columns  =&gt; $r-&gt;dir_config( &quot;MyColumns&quot; ) || 3,
            ),
        );

        return $m;
    }

    1;
</code></pre>

<p>This module provides a minimal constructor, <code>new()</code> so it can be instantiated (this is an Apache::AxKit::Language::SAXMachines requirement, we don&rsquo;t need that for our sake). AxKit will call the <code>get_machine()</code> method once each request to obtain the SAX machine is used. SAX machines are not reused from request to request.</p>

<p><code>$r</code> is a reference to the <a href="https://metacpan.org/pod/Apache::Request">Apache request</a> object (well, actually, to an AxKit subclass of it). This is passed into <a href="/pub/2002/09/24/axkit.html?page=3#My::ProofSheet">My::ProofSheet</a>, which uses to interact query some <a href="/pub/2002/09/24/axkit.html?page=2#httpd.conf">httpd.conf</a> settings, to control AxKit&rsquo;s cache, and to probe the filesystem through Apache.</p>

<p><code>$r</code> is also queried in this module to see whether there is a <code>MyColumns</code> setting for this request, with a default in case, it&rsquo;s not. The <code>ListTags</code> setting tells <a href="/pub/2002/09/24/axkit.html?page=3#XML::Filter::TableWrapper">XML::Filter::TableWrapper</a> to segment the image list produced by the first two filters into rows of images (preparing it to be an HTML table, in other words).</p>

<p>The need to pass parameters like this to the SAX filters is the sole reason we&rsquo;re using a SAX machine factory class like this. This class is specified by using <code>PerlSetVar AxSAXMachineClass</code>; if we didn&rsquo;t need to initialize the filters like this, then we could have listed them in a <code>PerlSetVar AxSAXMachineFilters</code> directive. For more details on how SAX machines are integrated with AxKit, see <a href="https://metacpan.org/pod/Apache::AxKit::Language::SAXMachines">the man page</a></p>

<p>Currently, only one SAX machine is allowed in an AxKit pipeline at a time (though different pipelines can have different machines in them). This is a limitation of the configuration system more than anything and may well change if need be. However, if we need to add SAX processors to the end of the machine, then the <code>PerlSetVar AxSAXMachineFilters</code> can be used to insert site-specific filters after the main machine (and before the XSLT processors).</p>

<p><span id="My::Filelist2Data"></span></p>

<h4 id="my-filelist2data">My::Filelist2Data</h4>

<p><a href="/pub/2002/09/24/axkit.html#pipeline.png" id="pipeline_filelist.png2"></a>
<img src="/images/_pub_2002_09_24_axkit/pipeline_filelist2data_pm.png" alt="My::Filelist2Data&#39;s position in the processing pipeline." width="110" height="84" /></p>

<p>Converting the <code>&lt;filelist&gt;</code> into a proofsheet takes a bit of detailed data munging. This is quite easy in Perl, so the first step in our pipeline is to convert the XML file listing into data. <a href="https://metacpan.org/pod/XML::Simple">XML::Simple</a> provides this functionality for us, and we overload it so we can grab the resulting data structure and pass it on:</p>

<pre><code>    package My::Filelist2Data;

    use XML::Simple;
    @ISA = qw( XML::Simple );

    use strict;

    sub new {
        my $proto = shift;
        my %opts = @_;

        # The Handler value is passed in by the Pipeline()
        # call in My::ProofSheetMachine.
        my $h = delete $opts{Handler};

        # Even if there's only one file element present,
        # make XML::Simple put it in an ARRAY so that
        # the downstream filter can depend on finding an
        # array of elements and not a single element.
        # This is an XML::Simple option that is almost
        # always set in practice.
        $opts{forcearray} = [qw( file )];

        # Each &lt;file&gt; and &lt;directory&gt; element contains
        # the file name as simple text content.  This
        # option tells XML::Simple to store it in the
        # data member &quot;filename&quot;.
        $opts{contentkey} = &quot;filename&quot;;

        # This subroutine gets called when XML::Simple
        # has converted the entire document with the
        # $data from the document.
        $opts{DataHandler} = sub {
            shift;
            my ( $data ) = @_;

            # If no files are found, place an array
            # reference in the right spot.  This is to
            # to simplify downstream filter code.
            $data-&gt;{file}      ||= [];

            # Pass the data structure to the next filter.
            $h-&gt;generate( $data );
        } if $h;

        # Call XML::Simple's constructor.
        return $proto-&gt;SUPER::new( %opts );;
    }

    1;
</code></pre>

<p>Sending a data structure like this between SAX machines using a non-SAX event is known as &ldquo;cheating.&rdquo; But this is Perl, and allowing you to cheat responsibly and judiciously is one of Perl&rsquo;s great strengths. This works and should work for the foreseeable future. If you&rsquo;re planning on doing something like this for a general purpose filter, then it behooves you to also provide <code>set_handler</code> and <code>get_handler</code> methods so your filter can be repositioned after instantiation (something XML::SAX::Machines do if need be), but we don&rsquo;t need to clutter this single-purpose example.</p>

<p>The <code>&lt;filelist&gt;</code> document gets converted to a Perl data structure where each element is a data member in a HASH or an array, like (data elided and rearranged to relate well to the source XML):</p>

<pre><code>    {
      xmlns =&gt; 'http://axkit.org/2002/filelist',
      directory =&gt; [
        {
          atime      =&gt; '1032276941'
          mtime      =&gt; '1032276939',
          ctime      =&gt; '1032276939',
          readable   =&gt; '1',
          writable   =&gt; '1',
          executable =&gt; '1',
          size       =&gt; '4096',
          content    =&gt; '.',
        },
        {
          ...
          content    =&gt; '..',
        },
        {
          ...
          content    =&gt; 'Mary',
        },
        {
          ...
          content    =&gt; 'Jim',
        }
      ]
      file =&gt; [
        {
          mtime      =&gt; '1031160766',
          ...
          content    =&gt; 'a-look.jpeg',
        },
        {
          mtime      =&gt; '1031160787',
          ...
          content    =&gt; 'a-lotery.jpeg',
        },
        {
          mtime      =&gt; '1031160771',
          ...
          content    =&gt; 'a-lucky.jpeg',
        },
        {
          mtime      =&gt; '035239142',
          ...
          content    =&gt; 'foo.html',
        },
        ...
      ],
    }
</code></pre>

<p><span id="My::ProofSheet"></span></p>

<h4 id="my-proofsheet">My::ProofSheet</h4>

<p><a href="/pub/2002/09/24/axkit.html#pipeline.png" id="pipeline_proofsheet_pm.png"><img src="/images/_pub_2002_09_24_axkit/pipeline_proofsheet_pm.png" alt="My::ProofSheet&#39;s position in the processing pipeline." width="110" height="84" /></a></p>

<p>Once the data is in Perl data structure, it&rsquo;s easy to tweak it (making <code>mtime</code> fields into something readable, for instance) and extend it (adding information about thumbnail images and .meta files, for instance). This is what My::ProofSheet does:</p>

<pre><code>    package My::ProofSheet;

    use XML::SAX::Base;
    @ISA = qw( XML::SAX::Base );

    # We need to access the Apache request object to
    # get the URI of the directory we're presenting,
    # its physical location on disk, and to probe
    # the files in it to see if they are images.
    use Apache;

    # My::Thumbnailer is an Apache/mod_perl module that
    # creates thumbnail images on the fly.  See below.
    use My::Thumbnailer qw( image_size thumb_limits );

    # XML::Generator::PerlData lets us take a Perl data
    # structure and emit it to the next filter serialized
    # as XML.
    use XML::Generator::PerlData;

    use strict;

    sub generate {
        my $self = shift;
        my ( $data ) = @_;

        # Get the AxKit request object so we can
        # ask it for the URI and use it to test
        # whether files are images or not.
        my $r = $self-&gt;{Request};

        my $dirname = $r-&gt;uri;      # &quot;/04/Baby_Pictures/Other/&quot;
        my $dirpath = $r-&gt;filename; # &quot;/home/me/htdocs/...Other/&quot;


        my @images = map $self-&gt;file2image( $_, $dirpath ),
            sort {
                $a-&gt;{filename} cmp $b-&gt;{filename}
            } @{$data-&gt;{file}};

        # Use a handy SAX module to generate XML from our Perl
        # data structures.  The XML will look basically like:
        # Write XML that looks like
        #
        # &lt;proofsheet&gt;
        #   &lt;images&gt;
        #     &lt;image&gt;...&lt;/image&gt;
        #     &lt;image&gt;...&lt;/image&gt;
        #     ...
        #   &lt;/images&gt;
        #   &lt;title&gt;/04/BabyePictures/Others&lt;/title&gt;
        # &lt;/proofsheet&gt;
        #
        XML::Generator::PerlData-&gt;new(
            rootname =&gt; &quot;proofsheet&quot;,
            Handler =&gt; $self,
        )-&gt;parse( {
            title       =&gt; $dirname,
            images      =&gt; { image =&gt; \@images },
        } );
    }


    sub file2image {
        my $self = shift;
        my ( $file, $dirpath ) = @_;

        # Remove the filename from the fields so it won't
        # show up in the &lt;image&gt; structure.
        my $fn = $file-&gt;{filename};

        # Ignore hidden files (first char is a &quot;.&quot;).
        # Thumbnail images are cached as hidden files.
        return () if 0 == index $fn, &quot;.&quot;;

        # Ignore files Apache knows aren't images
        my $type = $self-&gt;{Request}-&gt;lookup_file( $fn )-&gt;content_type;
        return () unless
            defined $type
            &amp;&amp; substr( $type, 0, 6 ) eq &quot;image/&quot;;

        # Strip the extension(s) off.
        ( my $name = $fn ) =~ s/\..*//;

        # A meta filename is the image filename with a &quot;.meta&quot;
        # extension instead of whatever extension it has.
        my $meta_fn   = &quot;$name.meta&quot;;
        my $meta_path = &quot;$dirpath/$meta_fn&quot;;

        # The thumbnail file is stored as a hidden file
        # named after the image file, but with a leading
        # '.' to hide it.
        my $thumb_fn   = &quot;.$fn&quot;;
        my $thumb_path = &quot;$dirpath/$thumb_fn&quot;;

        my $last_modified = localtime $file-&gt;{mtime};

        my $image = {
            %$file,                  # Copy all fields
            type           =&gt; $type, # and add a few
            name           =&gt; $name,
            thumb_uri      =&gt; $thumb_fn,
            path           =&gt; &quot;$dirpath/$fn&quot;,
            last_modified  =&gt; $last_modified,
        };

        if ( -e $meta_path ) {
            # Only add a URI to the meta info, metamerger.xsl will
            # slurp it up if and only if &lt;meta_uri&gt; is present.
            $image-&gt;{meta_filename} = $meta_fn;
            $image-&gt;{meta_uri}      = &quot;file://$meta_path&quot;;
        }

        # If the thumbnail exists, grab its width and height
        # so later stages can populate the &lt;img&gt; tag with them.
        # The eval {} is in case the image doesn't exist or
        # the library can't cope with the image format.
        # Disable caching AxKit's output if a failure occurs.
        eval {
            ( $image-&gt;{thumb_width}, $image-&gt;{thumb_height} )
                = image_size $thumb_path;
        } or $self-&gt;{Request}-&gt;no_cache( 1 );

        return $image;
    }


    1;
</code></pre>

<p>When My::Filelist2Data calls <code>generate()</code>, <code>generate()</code> sorts and scans the list of files by filename, converts each to an image and sends a page title and the resulting list of images to the next filter (<a href="/pub/2002/09/24/axkit.html?page=3#XML::Filter::TableWrapper">XML::Filter::TableWrapper</a>). Kip Hampton&rsquo;s <a href="https://metacpan.org/pod/XML::Generator::PerlData">XML::Generator::PerlData</a> is a Perl data -&gt; XML serialization module. It&rsquo;s not meant for generating generic XML; it focuses purely on building an XML representation of a Perl data structure. In this case, that&rsquo;s ideal, because we will be generating the output document with XSLT templates and we don&rsquo;t care about the exact order of the elements in each <code>&lt;image&gt;</code> element, each <code>&lt;image&gt;</code> element is just a hash of key/value pairs. We do control the order of the <code>&lt;image&gt;</code> elements, however, by passing an ordered list of them in to XML::Generator::PerlData as an array.</p>

<p>Sorting by filename may not be the preferred thing to do for all applications, because users may prefer to sort by the caption title for the image, but then again they may not, and this allows the site administrator to control sort order by naming the files appropriately. We can add always add sorting later.</p>

<p>Another peculiarity of this code is that it doesn&rsquo;t guarantee that there will be <code>thumb_width</code> and <code>thumb_height</code> values available. If you just drop the source images in a directory, then the first time the server generates this page, there will be no thumbnails available. In this case, the call to <code>no_cache(1)</code> prevents AxKit from caching the output page so that suboptimal HTML does not get stuck in the cache. This will give the server another chance at generating it with proper tags, hoping of course that by the next time this page is requested, the requisite thumbnails will be available to measure.</p>

<p>This approach gets the HTML to the browser fast, so the user&rsquo;s browser window will clear quickly and start filling with the top of ths page, so the user will see some activity and be less likely to get impatient. The thumbnails will be generated when the browser sees all the <code>&lt;img&gt;</code> tags. The alternative approach would be to thumbnail the images inline, which would result in a significant delay on large listings before the first HTML hits the browser, or prethumbnailing.</p>

<p>One thing to note about this approach is that many browsers will request images several at a time, which will cause several server processes to be thumbnailing several different images at once. This should result in lower lag on low-load servers because processes can interleave CPU time and disk I/O waits, and can take advantage of multiple processors, if present. On heavily loaded servers, of course, this might be a bad thing; pregenerating thumbnails there would be a good idea.</p>

<p>The output from this filter looks like:</p>

<pre><code>    &lt;?xml version=&quot;1.0&quot;?&gt;
    &lt;proofsheet&gt;
      &lt;images&gt;
        &lt;image&gt;
          &lt;path&gt;
            /home/barries/src/mball/AxKit/www/htdocs/04/Baby_Pictures/Others/a-look.jpeg
          &lt;/path&gt;
          &lt;writable&gt;1&lt;/writable&gt;
          &lt;filename&gt;a-look.jpeg&lt;/filename&gt;
          &lt;thumb_uri&gt;.a-look.jpeg&lt;/thumb_uri&gt;
          &lt;meta_filename&gt;a-look.meta&lt;/meta_filename&gt;
          &lt;name&gt;a-look&lt;/name&gt;
          &lt;last_modified&gt;Wed Sep  4 13:32:46 2002&lt;/last_modified&gt;
          &lt;ctime&gt;1032552249&lt;/ctime&gt;
          &lt;meta_uri&gt;
            file:///home/barries/src/mball/AxKit/www/htdocs/04/Baby_Pictures/Others/a-look.meta
          &lt;/meta_uri&gt;
          &lt;mtime&gt;1031160766&lt;/mtime&gt;
          &lt;size&gt;8522&lt;/size&gt;
          &lt;readable&gt;1&lt;/readable&gt;
          &lt;type&gt;image/jpeg&lt;/type&gt;
          &lt;atime&gt;1032553327&lt;/atime&gt;
        &lt;/image&gt;
        &lt;image&gt;
          &lt;path&gt;
            /home/barries/src/mball/AxKit/www/htdocs/04/Baby_Pictures/Others/a-lotery.jpeg
          &lt;/path&gt;
          &lt;writable&gt;1&lt;/writable&gt;
          &lt;filename&gt;a-lotery.jpeg&lt;/filename&gt;
          &lt;thumb_uri&gt;.a-lotery.jpeg&lt;/thumb_uri&gt;
          &lt;name&gt;a-lotery&lt;/name&gt;
          &lt;last_modified&gt;Wed Sep  4 13:33:07 2002&lt;/last_modified&gt;
          &lt;ctime&gt;1032552249&lt;/ctime&gt;
          &lt;mtime&gt;1031160787&lt;/mtime&gt;
          &lt;size&gt;10113&lt;/size&gt;
          &lt;readable&gt;1&lt;/readable&gt;
          &lt;type&gt;image/jpeg&lt;/type&gt;
          &lt;atime&gt;1032553327&lt;/atime&gt;
        &lt;/image&gt;
      &lt;/images&gt;
      ...
      &lt;title&gt;/04/Baby_Pictures/Others&lt;/title&gt;
    &lt;/proofsheet&gt;
</code></pre>

<p>All the data from the original <code>&lt;file&gt;</code> elements are in each <code>&lt;image&gt;</code> element along with the new fields. Note that the first <code>&lt;image&gt;</code> contains the <code>&lt;meta_uri&gt;</code> (pointing to <a href="/pub/2002/09/24/axkit.html#TheMetaFile">a-look.meta</a>) while the second doesn&rsquo;t because there is no <code>a-lotery.meta</code>. As expected both have the <code>&lt;thumb_uri&gt;</code> tags. The parts in <strong>bold</strong> face are the bits that our presentation happens to want; yours might want more or different bits.</p>

<p>While there is a lot of extra information in this structure, it&rsquo;s really just the output from one system call (<code>stat()</code>) and some possibly useful byproducts of the My::ProofSheet machinations, so it&rsquo;s very cheap information that some front end somewhere might want. It&rsquo;s also easier to leave it all in than to emit just what our example frontend might want and will enable any future upstream filters or extentions to AxKit&rsquo;s directory scanning to shine through.</p>

<p>No <code>&lt;thumb_width&gt;</code> or <code>&lt;thumb_height&gt;</code> tags are present because I copied this file from the axtrace directory (see the <code>AxTraceIntermediate</code> directive in <a href="/pub/2002/09/24/axkit.html?page=2#httpd.conf">our httpd.conf file</a>) after viewing a newly added directory. Here&rsquo;s what the first <code>&lt;image&gt;</code> element looks like when viewing after my browser had requested all thumbnails:</p>

<pre><code>    &lt;?xml version=&quot;1.0&quot;?&gt;
    &lt;proofsheet&gt;
      &lt;images&gt;
        &lt;image&gt;
          &lt;thumb_width&gt;72&lt;/thumb_width&gt;
          &lt;path&gt;
            /home/barries/src/mball/AxKit/www/htdocs/04/Baby_Pictures/Others/a-look.jpeg
          &lt;/path&gt;
          &lt;writable&gt;1&lt;/writable&gt;
          &lt;filename&gt;a-look.jpeg&lt;/filename&gt;
          &lt;thumb_height&gt;100&lt;/thumb_height&gt;
          &lt;thumb_uri&gt;.a-look.jpeg&lt;/thumb_uri&gt;
          &lt;meta_filename&gt;a-look.meta&lt;/meta_filename&gt;
          &lt;name&gt;a-look&lt;/name&gt;
          &lt;last_modified&gt;Wed Sep  4 13:32:46 2002&lt;/last_modified&gt;
          &lt;ctime&gt;1032552249&lt;/ctime&gt;
          &lt;meta_uri&gt;
            file:///home/barries/src/mball/AxKit/www/htdocs/04/Baby_Pictures/Others/a-look.meta
          &lt;/meta_uri&gt;
          &lt;mtime&gt;1031160766&lt;/mtime&gt;
          &lt;size&gt;8522&lt;/size&gt;
          &lt;readable&gt;1&lt;/readable&gt;
          &lt;type&gt;image/jpeg&lt;/type&gt;
          &lt;atime&gt;1032784360&lt;/atime&gt;
        &lt;/image&gt;
        ...
      &lt;/images&gt;
      &lt;title&gt;/04/Baby_Pictures/Others&lt;/title&gt;
    &lt;/proofsheet&gt;
</code></pre>

<p><span id="XML::Filter::TableWrapper"></span></p>

<h4 id="xml-filter-tablewrapper">XML::Filter::TableWrapper</h4>

<p><a href="/pub/2002/09/24/axkit.html#pipeline.png" id="pipeline_tablewrapper_pm.png"><img src="/images/_pub_2002_09_24_axkit/pipeline_tablewrapper_pm.png" alt="My::TableWrapper&#39;s position in the processing pipeline" width="110" height="84" /></a></p>

<p><a href="https://metacpan.org/pod/XML::Filter::TableWrapper">XML::Filter::TableWrapper</a> is a CPAN module is used to take the <code>&lt;images&gt;</code> list and segmenting it by insert <code>&lt;tr&gt;...&lt;/tr&gt;</code> tags around every (it&rsquo;s configurable) <code>&lt;image&gt;</code> elements. This configuration is done by the <a href="/pub/2002/09/24/axkit.html?page=2#My::ProofSheetMachine">My::ProofSheetMachine</a> module we showed earlier:</p>

<pre><code>    XML::Filter::TableWrapper-&gt;new(
        ListTags =&gt; &quot;{}images&quot;,
        Columns  =&gt; $r-&gt;dir_config( &quot;MyColumns&quot; ) || 3,
    ),
</code></pre>

<p>The output, for our list of 9 images, looks like:</p>

<pre><code>    &lt;?xml version=&quot;1.0&quot;?&gt;
    &lt;proofsheet&gt;
      &lt;images&gt;
        &lt;tr&gt;
          &lt;image&gt;
            ...
          &lt;/image&gt;
          ... 4 more image elements...
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;image&gt;
            ...
          &lt;/image&gt;
          ... 3 more image elements...
        &lt;/tr&gt;
      &lt;/images&gt;
      &lt;title&gt;/04/Baby_Pictures/Others&lt;/title&gt;
    &lt;/proofsheet&gt;
</code></pre>

<p>Now all the presentation stylesheet (<a href="/pub/2002/09/24/axkit.html?page=4#pagestyler.xsl">pagestuler.xsl</a>) can key off the <code>&lt;tr&gt;</code> tags to build an HTML <code>&lt;table&gt;</code> or ignore them (and not pass them through) if it wants to display in a list format.</p>

<p>While I&rsquo;m sure this is possible in XSLT, I have no idea how to do it easily.</p>

<p><span id="rowsplitter.xsl"></span></p>

<h4 id="rowsplitter-xsl">rowsplitter.xsl</h4>

<p><a href="/pub/2002/09/24/axkit.html#pipeline.png" id="pipeline_rowsplitter_xsl.png"><img src="/images/_pub_2002_09_24_axkit/pipeline_rowsplitter_xsl.png" alt="rowsplitter.xsl&#39;s position in the processing pipeline." width="110" height="84" /></a></p>

<p>Experimentation with an early version of this application showed that presenting captions in the same table cell as the thumbnails when the thumbnails are of differing heights caused the captions to be showed at varying heights. This made it hard to scan the captions and added a lot of visual clutter to the page.</p>

<p>One solution is to add an XSLT filter that splits each table row of image data in to two rows, one for the thumbnail and another for the caption:</p>

<pre><code>    &lt;xsl:stylesheet
      version=&quot;1.0&quot;
      xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;
    &gt;

    &lt;xsl:template match=&quot;image&quot; mode=&quot;caption&quot;&gt;
      &lt;caption&gt;
        &lt;xsl:copy-of select=&quot;@*|*|node()&quot; /&gt;
      &lt;/caption&gt;
    &lt;/xsl:template&gt;

    &lt;xsl:template match=&quot;images/tr&quot;&gt;
      &lt;xsl:copy-of select=&quot;.&quot; /&gt;
      &lt;tr&gt;&lt;xsl:apply-templates select=&quot;image&quot; mode=&quot;caption&quot; /&gt;&lt;/tr&gt;
    &lt;/xsl:template&gt;

    &lt;xsl:template match=&quot;@*|node()&quot;&gt;
      &lt;xsl:copy&gt;
        &lt;xsl:apply-templates select=&quot;@*|node()&quot;/&gt;
      &lt;/xsl:copy&gt;
    &lt;/xsl:template&gt;

    &lt;/xsl:stylesheet&gt;
</code></pre>

<p>The second template in this stylesheet matches each row (<code>&lt;tr&gt;</code> element) in the <code>&lt;images&gt;</code> element and copies it verbatim and then emits a second <code>&lt;tr&gt;</code> element right after it with a list of <code>&lt;caption&gt;</code> elements with copies of the content of each of the <code>&lt;image&gt;</code> tags in the original row. The first template is applied only to the <code>&lt;image&gt;</code> tags when creating this second row due to the <code>mode=&quot;caption&quot;</code> attributes.</p>

<p>The third template is a standard piece of XSLT boilerplate that passes through all the XML that is not matched by the first two templates. This XML would otherwise be mangled (stripped of elements, to be specific) by the wacky default XSLT rules.</p>

<p>Now, I know several ways to do this in Perl in the AxKit environment and none are so easy for me as using XSLT. <a href="https://dictionary.cambridge.org/us/dictionary/english/ymmv">YMMV</a>.</p>

<p>The output from that stage looks like:</p>

<pre><code>    &lt;?xml version=&quot;1.0&quot;?&gt;
    &lt;proofsheet&gt;
      &lt;images&gt;

        &lt;tr&gt;&lt;image&gt;...  &lt;/image&gt;   ...total of 5... &lt;/tr&gt;
        &lt;tr&gt;&lt;caption&gt;...&lt;/caption&gt; ...total of 5... &lt;/tr&gt;

        &lt;tr&gt;&lt;image&gt;...  &lt;/image&gt;   ...total of 4... &lt;/tr&gt;
        &lt;tr&gt;&lt;caption&gt;...&lt;/caption&gt; ...total of 4... &lt;/tr&gt;

      &lt;/images&gt;
      &lt;title&gt;/04/Baby_Pictures/Others&lt;/title&gt;
    &lt;/proofsheet&gt;
</code></pre>

<p>The content of each <code>&lt;image&gt;</code> tag and each <code>&lt;caption&gt;</code> tag is identical. It&rsquo;s easier to do the transform this way and allows the frontend stylesheets the flexibility of doing things like putting the image filename or modification time in the same cell as the thumbnail.</p>

<p><span id="metamerger.xsl"></span></p>

<h4 id="metamerger-xsl">metamerger.xsl</h4>

<p><a href="/pub/2002/09/24/axkit.html#pipeline.png" id="pipeline_metamerger_xsl.png"><img src="/images/_pub_2002_09_24_axkit/pipeline_metamerger_xsl.png" alt="metamerger.xsl&#39;s position in the processing pipeline" /></a></p>

<p>As with the row splitter, expressing the metamerger in XSLT is an expedient way of merging in external XML documents, for several reasons. The first is for efficiency&rsquo;s sake: We&rsquo;re already using XSLT before and after this filter, and AxKit optimizes XSLT-&gt;XSLT handoffs to avoid reparsing. Another is that the underlying implementation of AxKit&rsquo;s XSLT engine is the speedy C of libxslt. A third is that we&rsquo;re not altering the incoming file at all in this stage, so the XSLT does not get out of hand (I do not consider XSLT to be a very readable programming language; its XML syntax makes for very opaque source code).</p>

<p>Another approach would be to go back and tweak <a href="/pub/2002/09/24/axkit.html?page=3#My::ProofSheet">My::ProofSheet</a> to inherit from <a href="https://metacpan.org/pod/XML::SAX::Machines">XML::Filter::Merger</a> and insert it using a SAX parser. That would be a bit slower, I suspect, because SAX parsing in general tends to be slower than XSLT&rsquo;s internal parsing. It would rob the application of the configurability that having merging as a separate step engenders. By factoring this functionality in to the metamerger.xsl stylesheet, we offer the site designer the ability to pull data from other sources, or even to fly without any metadata at all.</p>

<p>Here&rsquo;s what metamerger.xsl looks like:</p>

<pre><code>    &lt;xsl:stylesheet
      version=&quot;1.0&quot;
      xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;
    &gt;

    &lt;xsl:template match=&quot;caption&quot;&gt;
      &lt;caption&gt;
        &lt;xsl:copy-of select=&quot;*|@*|node()&quot; /&gt;
        &lt;xsl:copy-of select=&quot;document( meta_uri )&quot; /&gt;
      &lt;/caption&gt;
    &lt;/xsl:template&gt;

    &lt;xsl:template match=&quot;*|@*&quot;&gt;
      &lt;xsl:copy&gt;
        &lt;xsl:apply-templates select=&quot;*|@*|node()&quot; /&gt;
      &lt;/xsl:copy&gt;
    &lt;/xsl:template&gt;

    &lt;/xsl:stylesheet&gt;
</code></pre>

<p>The first template does all the work of matching each <code>&lt;caption&gt;</code> element and copying its content, then parsing and inserting the document indicated by the <code>&lt;meta_uri&gt;</code> element, if present. The <code>document()</code> function turns into a noop if <code>&lt;meta_uri&gt;</code> is not present. The second template is that same piece of boilerplate we saw in <a href="/pub/2002/09/24/axkit.html?page=3#rowsplitter.xsl">rowsplitter.xsl</a> to copy through everything we don&rsquo;t explicitly match.</p>

<p>And here&rsquo;s what the <code>&lt;caption&gt;</code> for <code>a-look.jpeg</code> now looks like (all the other <code>&lt;caption&gt;</code> elements were left untouched because there are no other .meta files in this directory):</p>

<pre><code>    &lt;caption&gt;
      &lt;thumb_width&gt;72&lt;/thumb_width&gt;
      &lt;path&gt;/home/barries/src/mball/AxKit/www/htdocs/04/Baby_Pictures/Others/a-look.jpeg&lt;/path&gt;
      &lt;writable&gt;1&lt;/writable&gt;
      &lt;filename&gt;a-look.jpeg&lt;/filename&gt;
      &lt;thumb_height&gt;100&lt;/thumb_height&gt;
      &lt;thumb_uri&gt;.a-look.jpeg&lt;/thumb_uri&gt;
      &lt;meta_filename&gt;a-look.meta&lt;/meta_filename&gt;
      &lt;name&gt;a-look&lt;/name&gt;
      &lt;last_modified&gt;Wed Sep  4 13:32:46 2002&lt;/last_modified&gt;
      &lt;ctime&gt;1032552249&lt;/ctime&gt;
      &lt;meta_uri&gt;file:///home/barries/src/mball/AxKit/www/htdocs/04/Baby_Pictures/Others/a-look.meta&lt;/meta_uri&gt;
      &lt;mtime&gt;1031160766&lt;/mtime&gt;
      &lt;size&gt;8522&lt;/size&gt;
      &lt;readable&gt;1&lt;/readable&gt;
      &lt;type&gt;image/jpeg&lt;/type&gt;
      &lt;atime&gt;1032784360&lt;/atime&gt;
      &lt;meta&gt;
        &lt;title&gt;A baby picture&lt;/title&gt;
        &lt;comment&gt;&lt;b&gt;ME!&lt;/b&gt;.  Well, not really.  Actually, it's some random image from the 'net.
&lt;/comment&gt;
      &lt;/meta&gt;
    &lt;/caption&gt;
</code></pre>

<p>As mentioned before, this stylesheet does not care what you put in the meta file, it just inserts anything in that file from the root element on down. So you are free to put any meta information your application requires in the meta file and adjust the presentation filters to style it as you will.</p>

<p>The .meta information is not inserted in to the <code>&lt;image&gt;</code> tags because we know that none of our presentation will not need any of it there.</p>

<p><span id="captionstyler.xsl"></span></p>

<h4 id="captionstyler-xsl">captionstyler.xsl</h4>

<p><a href="/pub/2002/09/24/axkit.html#pipeline.png" id="pipeline_captionstyler_xsl.png"><img src="/images/_pub_2002_09_24_axkit/pipeline_captionstyler_xsl.png" alt="captionstyler.xsl&#39;s position in the processing pipeline" width="110" height="84" /></a></p>

<p>The last two stages of our pipeline turn the data assembled so far into HTML. This is done in two stages in order to separate general layout and presentation from the presentation of the caption because the these portions of the presentation might need to vary independently between one collection of images and another.</p>

<p>The caption stylesheet for this example is:</p>

<pre><code>    &lt;xsl:stylesheet
      version=&quot;1.0&quot;
      xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;
    &gt;

    &lt;xsl:template match=&quot;caption&quot;&gt;
      &lt;caption width=&quot;100&quot; align=&quot;left&quot; valign=&quot;top&quot;&gt;

        &lt;a href=&quot;{filename}&quot;&gt;
          &lt;xsl:choose&gt;
            &lt;xsl:when test=&quot;meta/title and string-length( meta/title )&quot;&gt;
              &lt;xsl:copy-of select=&quot;meta/title/node()&quot; /&gt;
            &lt;/xsl:when&gt;
            &lt;xsl:otherwise&gt;
              &lt;xsl:value-of select=&quot;name&quot; /&gt;
            &lt;/xsl:otherwise&gt;
          &lt;/xsl:choose&gt;
        &lt;/a&gt;&lt;br /&gt;

        &lt;font size=&quot;-1&quot; color=&quot;#808080&quot;&gt;
          &lt;xsl:copy-of select=&quot;last_modified/node()&quot; /&gt;
          &lt;br /&gt;
        &lt;/font&gt;

        &lt;xsl:copy-of select=&quot;meta/comment/node()&quot; /&gt;

      &lt;/caption&gt;
    &lt;/xsl:template&gt;

    &lt;xsl:template match=&quot;*|@*|node()&quot;&gt;
      &lt;xsl:copy&gt;
        &lt;xsl:apply-templates /&gt;
      &lt;/xsl:copy&gt;
    &lt;/xsl:template&gt;

    &lt;/xsl:stylesheet&gt;
</code></pre>

<p>The first template replaces all <code>&lt;caption&gt;</code> elements with new <code>&lt;caption&gt;</code> cells with a default width and alignment, and then fills these with the name of the image, which is also a link to the underling image file, and the <code>&lt;last_modified</code> time string formatted by <a href="/pub/2002/09/24/axkit.html?page=3#My::ProofSheet">My::ProofSheet</a> and any <code>&lt;comment&gt;</code> that might be present in the meta file.</p>

<p>The <code>&lt;xsl:choose&gt;</code> element is what selects the title to display for the image. The first <code>&lt;xsl:when&gt;</code>looks to see if there is a <code>&lt;title&gt;</code> element in the meta file and uses it if present. The <code>&lt;xsl:otherwise&gt;</code> defaults the name to the <code>&lt;name&gt;</code> set by My::ProofSheet.</p>

<p>The captions output by this stage look like:</p>

<pre><code>    &lt;caption width=&quot;100&quot; align=&quot;left&quot; valign=&quot;top&quot;&gt;
      &lt;a href=&quot;a-look.jpeg&quot;&gt;A baby picture&lt;/a&gt;
      &lt;br/&gt;
      &lt;font size=&quot;-1&quot; color=&quot;#808080&quot;&gt;Wed Sep
        4 13:32:46 2002&lt;br/&gt;
      &lt;/font&gt;
      &lt;b&gt;ME!&lt;/b&gt;.  Well, not really.  Actually, it's
        some random image from the 'net.
    &lt;/caption&gt;
    &lt;caption width=&quot;100&quot; align=&quot;left&quot; valign=&quot;top&quot;&gt;
      &lt;a href=&quot;a-lotery.jpeg&quot;&gt;a-lotery&lt;/a&gt;
      &lt;br/&gt;
      &lt;font size=&quot;-1&quot; color=&quot;#808080&quot;&gt;Wed Sep
        4 13:33:07 2002&lt;br/&gt;&lt;/font&gt;
    &lt;/caption&gt;
</code></pre>

<p>The former is what comes out when a .meta file is found, the latter when it is not.</p>

<p><span id="pagestyler.xsl"></span></p>

<h4 id="pagestyler-xsl">pagestyler.xsl</h4>

<p>And now, the final stage. If you&rsquo;ve made it this far, congratulations; this is the start of a real application and not just a toy, so it&rsquo;s taken quite some time to get here.</p>

<p><a href="/pub/2002/09/24/axkit.html#pipeline.png" id="pipeline_pagestyler_xsl.png"><img src="/images/_pub_2002_09_24_axkit/pipeline_pagestyler_xsl.png" alt="pagestyler.xsl&#39;s position in the processing pipeline" width="110" height="84" /></a></p>

<p>The final stage of the processing pipeline generates an HTML page from the raw data, except for the attributes and content of <code>&lt;caption&gt;</code> tags, which it passes through as-is:</p>

<pre><code>    &lt;xsl:stylesheet
      version=&quot;1.0&quot;
      xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;
    &gt;

    &lt;xsl:template match=&quot;/*&quot;&gt;
      &lt;html&gt;
        &lt;head&gt;
          &lt;title&gt;Images in &lt;xsl:value-of select=&quot;title&quot; /&gt;&lt;/title&gt;
        &lt;/head&gt;
        &lt;body bgcolor=&quot;#ffffff&quot;&gt;
          &lt;xsl:apply-templates select=&quot;images&quot; /&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    &lt;/xsl:template&gt;


    &lt;xsl:template match=&quot;images&quot;&gt;
      &lt;table&gt;
        &lt;xsl:apply-templates /&gt;
      &lt;/table&gt;
    &lt;/xsl:template&gt;

    &lt;xsl:template match=&quot;tr&quot;&gt;
      &lt;xsl:copy&gt;
        &lt;xsl:apply-templates select=&quot;*&quot; /&gt;
      &lt;/xsl:copy&gt;
    &lt;/xsl:template&gt;

    &lt;xsl:template match=&quot;image&quot;&gt;
      &lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;
        &lt;a href=&quot;{filename}&quot;&gt;
          &lt;img border=&quot;0&quot; src=&quot;{thumb_uri}&quot;&gt;
            &lt;xsl:if test=&quot;thumb_width&quot;&gt;
              &lt;xsl:attribute name=&quot;width&quot;&gt;
                &lt;xsl:value-of select=&quot;thumb_width&quot; /&gt;
              &lt;/xsl:attribute&gt;
            &lt;/xsl:if&gt;
            &lt;xsl:if test=&quot;thumb_height&quot;&gt;
              &lt;xsl:attribute name=&quot;height&quot;&gt;
                &lt;xsl:value-of select=&quot;thumb_height&quot; /&gt;
              &lt;/xsl:attribute&gt;
            &lt;/xsl:if&gt;
          &lt;/img&gt;
        &lt;/a&gt;
      &lt;/td&gt;
    &lt;/xsl:template&gt;

    &lt;xsl:template match=&quot;@*|node()&quot; mode=&quot;caption&quot;&gt;
      &lt;xsl:copy&gt;
        &lt;xsl:apply-templates select=&quot;@*|node()&quot; mode=&quot;caption&quot; /&gt;
      &lt;/xsl:copy&gt;
    &lt;/xsl:template&gt;

    &lt;xsl:template match=&quot;caption&quot;&gt;
      &lt;td&gt;
        &lt;xsl:apply-templates select=&quot;@*|node()&quot; mode=&quot;caption&quot; /&gt;
      &lt;/td&gt;
    &lt;/xsl:template&gt;

    &lt;/xsl:stylesheet&gt;
</code></pre>

<p>The first template generates the skeleton of the HTML page, the second one grabs the <code>&lt;images&gt;</code> list from the source document, emits a <code>&lt;table&gt;</code>, the third copies the <code>&lt;tr&gt;</code> tags, the fourth replaces all <code>&lt;image&gt;</code> tags with <code>&lt;td&gt;</code> tags containing the thumbnail image as a link to the underlying image (similar to what <a href="/pub/2002/09/24/axkit.html?page=4#captionstyler.xsl">captionstyler.xsl</a> did with the picture name). The only subtlety here is that the optional <code>&lt;thumb_width&gt;</code> and <code>&lt;thumb_height&gt;</code> elements are used, if present, to inform the browser of the size of the thumbnail in order to speed up the layout process (as mentioned before, pages that don&rsquo;t contain this information are not cached so that when the thumbnails are generated, new HTML will be generated with it).</p>

<p>The fourth template converts the <code>&lt;caption&gt;</code> elements to <code>&lt;td&gt;</code> elements and copies all their content through, since <a href="/pub/2002/09/24/axkit.html?page=4#captionstyler.xsl">captionstyler.xsl</a> already did the presentation for them.</p>

<p>Tweaking this stylesheet or replacing it controls the entire page layout other than thumbnail sizing (which is set by the optional <code>MyMaxX</code> and <code>MyMaxY</code> <code>PerlSetVar</code> settings in <a href="/pub/2002/09/24/axkit.html?page=2#httpd.conf">httpd.conf</a>). A different stylesheet in this point in the chain could choose to ignore the <code>&lt;tr&gt;</code> tags and present a list style output. A later stylesheet could be added to add branding or advertising to the site, etc., etc.</p>

<p><span id="My::Thumbnailer"></span></p>

<h4 id="my-thumbnailer">My::ThumbNailer</h4>

<p>Here&rsquo;s the apache module that generates thumbnails. The key thing to remember is that, unlike all the other code and XML shown in this article, this is called once per thumbnail image, not once per directory. When a browser requests a directory listing, it gets HTML from the pipeline above with lots of URIs for thumbnail images. It will then usually request each of those in turn. The <a href="/pub/2002/09/24/axkit.html?page=2#httpd.conf">httpd.conf</a> file directs all requests for dotfiles to this module:</p>

<pre><code>    package My::Thumbnailer;

    # Allow other modules like My::ProofSheet to use some
    # of our utility routines.
    use Exporter;
    @ISA = qw( Exporter );
    @EXPORT_OK = qw( image_size thumb_limits );

    use strict;

    use Apache::Constants qw( DECLINED );
    use Apache::Request;
    use File::Copy;
    use Imager;


    sub image_size {
        my $img = shift;

        if ( ! ref $img ) {
            my $fn = $img;
            $img = Imager-&gt;new;
            $img-&gt;open( file =&gt; $fn )
                or die $img-&gt;errstr(), &quot;: $fn&quot;;
        }

        ( $img-&gt;getwidth, $img-&gt;getheight );
    }


    sub thumb_limits {
        my $r = shift;

        # See if the site admin has placed MyMaxX and/or
        # MyMaxY in the httpd.conf.
        my ( $max_w, $max_h ) = map
            $r-&gt;dir_config( $_ ),
            qw( MyMaxX MyMaxY );

        return ( $max_w, $max_h )
            if $max_w || $max_h;

        # Default to scaling down to fit in a 100 x 100
        # pixel area (aspect ration will be maintained).
        return ( 100, 100 );
    }


    # Apache/mod_perl is configured to call
    # this handler for every dotfile
    # requested.  All thumbnail images are dotfiles,
    # some dotfiles may not be thumbnails.
    sub handler {
        my $r = Apache::Request-&gt;new( shift );

        # We only want to handle images.
        # Let Apache handle non-images.
        goto EXIT
            unless substr( $r-&gt;content_type, 0, 6 ) eq &quot;image/&quot;;

        # The actual image filename is the thumbnail
        # filename without the leading &quot;.&quot;.  There's
        ( my $orig_fn = $r-&gt;filename ) =~ s{/\.([^/]+)\z}{/$1}
            or die &quot;Can't parse &quot;, $r-&gt;filename;

        # Let Apache serve the thumbnail if it already
        # exists and is newer than the original file.
        {
            my $thumb_age = -M $r-&gt;finfo;
            my $orig_age  = -M $orig_fn;
            goto EXIT
                if $thumb_age &amp;&amp; $thumb_age &lt;= $orig_age;
        }

        # Read in the original file
        my $orig = Imager-&gt;new;
        unless ( $orig-&gt;open( file =&gt; $orig_fn ) ) {
            # Imager can't hack the format, fall back
            # to the original image.  This can happen
            # if you forget to install libgif
            # (as I have done).
            goto FALLBACK
                if $orig-&gt;errstr =~ /format not supported/;

            # Other errors are probably more serious.
            die $orig-&gt;errstr, &quot;: $orig_fn\n&quot;;
        }

        my ( $w, $h ) = image_size( $orig );

        die &quot;!\$w for &quot;, $r-&gt;filename, &quot;\n&quot; unless $w;
        die &quot;!\$h for &quot;, $r-&gt;filename, &quot;\n&quot; unless $h;

        my ( $max_w, $max_h ) = thumb_limits( $r );

        # Scale down only,  If the image is smaller than
        # the thumbnail limits, let Apache serve it as-is.
        # thumb_limits() guarantees that either $max_w
        # or $max_h will be true.
        goto FALLBACK
            if ( ! $max_w || $w &lt; $max_w )
            &amp;&amp; ( ! $max_h || $h &lt; $max_h );

        # Scale down to the maximum dimension to the
        # requested size.  This can mess up for images
        # that are meant to be scaled on each axis
        # independantly, like graphic bars for HTML
        # page seperators, but that's a very small
        # demographic.
        my $thumb = $orig-&gt;scale(
            $w &gt; $h
                ? ( xpixels =&gt; $max_w )
                : ( ypixels =&gt; $max_h )
        );
        $thumb-&gt;write( file =&gt; $r-&gt;filename,)
            or die $thumb-&gt;errstr, &quot;: &quot;, $r-&gt;filename;

        goto BONK;

    FALLBACK:
        # If we can't or don't want to build the thumbnail,
        # just copy the original and let Apache figure it out.
        warn &quot;Falling back to &quot;, $orig_fn, &quot;\n&quot;;
        copy( $orig_fn, $r-&gt;filename );

    BONK:
        # Bump apache on the head just hard enough to make it
        # forget the thumbnail file's old stat() and
        # mime type since we've most likely changed all
        # that now.  This is important for the headers
        # that control downstream caching, for instance,
        # or in case Imager changed mime types on us
        # (unlikely, but hey...)
        $r-&gt;filename( $r-&gt;filename );

    EXIT:
        # We never serve the image data, Apache is perfectly
        # good at doing this without our help.  Returning
        # DECLINED causes Apache to use the next handler in
        # its list of handlers.  Normally this is the default
        # Apache file handler.
        return DECLINED;
    }

    1;
</code></pre>

<p>There should be enough inline commentary to explain that lot. The only thing I&rsquo;ll say is that, to head off the gotophobes, I think the use of <code>goto</code> makes this routine a lot clearer than the alternatives; the early versions did not use it and were less readable/maintainable. This is because the three normal exit routes happen to stack nicely up from the bottom so the fallthrough from one labeled chunk to the next happens nicely.</p>

<p>The most glaring mistake here is that there is no file locking. We&rsquo;ll add that in next time.</p>

<p><span id="Summary"></span></p>

<h3 id="summary">Summary</h3>

<p>The final result of the code in this article is to build the image proofsheet section of <a href="/pub/2002/09/24/axkit.html?page=1#proofsheet.png">the page we showed at the beginning of the article</a>. The next article will complete that page, and then we&rsquo;ll build the image presentation page and a metadata editor in future articles.</p>

<p><span id="help"></span></p>

<h3 id="help-and-thanks">Help and thanks</h3>

<p>In case of trouble, have a look at some of the <a href="/pub/2002/03/12/axkit.html?page=3#help">helpful resources we listed in the first article</a>.</p>

              </article>
              <p><strong>Tags</strong></p>
              <div class="tags">
                <div class="category"><a href="/categories/data">data</a></div>
                
              </div>
            </div>
            
              
                
<div class="row" id="author-bio-barrie-slaymaker">
  <div class="col-sm-2">
    
    <a href="/authors/barrie-slaymaker/"><div class="circle-avatar" style="background-image:url(/images/site/avatar.png)"></div></a>
  </div>
  <div class="col-sm-10">
    <a href="/authors/barrie-slaymaker/"><h3>Barrie Slaymaker</h3></a>
    <p></p>
    <h5><a href="/authors/barrie-slaymaker/">Browse their articles</a></h5>
  </div>
</div>

            
            <div class="row">
              <h3>Feedback</h3>
              <p>Something wrong with this article? Help us out by opening an issue or pull request on <a href="https://github.com/tpf/perldotcom/blob/master/content/legacy/_pub_2002_09_24_axkit.md">GitHub</a></p>
            </div>
          </div>
          <div class="col-md-3">
            <div class="latest-sidebar">

  <div class="row">
    <div class="col-sm-12 centering">
      <span style="font-size:1.8em" class="antonio txt-blue-major">OUR LATEST ARTICLES</span>
    </div>
  </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/the-perl-admbassador-curtis-poe/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/the-perl-ambassador-curtis-poe/curtis-poe.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>The Perl Ambassador: Curtis &#39;Ovid&#39; Poe</h6>
          <p style="line-height:1"><small>The person behind the news of Perl</small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/a-tour-with-net-ftp/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/a-tour-with-net-ftp/thumb_kidyes.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>A tour with Net::FTP</h6>
          <p style="line-height:1"><small>How to write an FTP client in Perl</small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/shortcode_test/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/author/brian-d-foy.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>shortcode_test</h6>
          <p style="line-height:1"><small></small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/listen-to-larry-wall-s-state-of-the-onion-2000-on-youtube/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/listen-to-larry-wall-s-state-of-the-onion-2000-on-youtube/thumb_larry-wall.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>Listen to Larry Wall&#39;s State of the Onion 2000 on YouTube</h6>
          <p style="line-height:1"><small></small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/announcing-perl-7/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/announcing-perl-7/thumb_seven_on_blue_wall.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>Announcing Perl 7</h6>
          <p style="line-height:1"><small>Perl 5 with modern defaults</small></p>
      </div>
        </a>
    </div>
  
</div>
<div class="row" style="margin-top:20px">
  <div class="col-sm-12 centering">
  <script async src="/widget/toplinks/toplinks.js" type="text/javascript"></script>
    <div id="toplinks"></div>
  </div>
</div>

<div class="row" style="margin-top:20px">
  <div class="col-sm-12 centering">
    <a class="twitter-timeline" data-height="640" data-dnt="true" data-theme="dark" href="https://twitter.com/perlfoundation?ref_src=twsrc%5Etfw">Tweets by perlfoundation</a> <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
  </div>
</div>

<div class="row" style="margin-top:20px">
  <div class="col-sm-12 centering">
    <script src="https://www.reddit.com/r/perl/hot/.embed?limit=10&t=all" type="text/javascript"></script>
  </div>
</div>



          </div>
        </div>
      </div>
    </section>
  </section>
<script>
 
var tables, i;
tables = document.getElementsByTagName('table');
for (i=0;i<tables.length;i++) {
  tables[i].className = 'table table-striped';
}
</script>
<div class="push"></div>
<div class="footer">
  <div class="container">
    <div class="row">
      <div class="col-md-1">
        <h5>Site Map</h5>
        <ul>
        <li><a href="/">Home</a></li>
        <hr>
        <li><a href="/about">About</a></li>
        <hr>
        <li><a href="/authors">Authors</a></li>
        <hr>
        <li><a href="/categories">Categories</a></li>
        <hr>
        <li><a href="/tags">Tags</a></li>
        <hr>
        </ul>
      </div>
      <div class="col-md-3">
        <h5>Contact Us</h5>
        <p>To get in touch, send an email to: perl.com-editor@perl.org</p>
        <p><a href="https://perl.org">
              <img src="/images/site/perl-onion_20.png" alt="Perl Onion"></a>
          <a href="https://twitter.com/intent/follow?screen_name=perlfoundation">
              <img src="/images/site/twitter_20.png" alt="twitter"></a>
          <a href="/index.xml" /><img src="/images/site/rss_20.png" alt="rss"></a>
          <a href="https://github.com/tpf/perldotcom">
              <img src="/images/site/github_light_20.png" alt="GitHub logo"></a></p>
      </div>
      <div class="col-md-2">
          <h5>License</h5>
          <p>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc/3.0/">Creative Commons Attribution-NonCommercial 3.0 Unported License</a>.</p>
          <p><a rel="license" href="https://creativecommons.org/licenses/by-nc/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/3.0/88x31.png" /></a></p>
      </div>
      <div class="col-md-5">
          <h5>Legal</h5>
          <p>Perl.com and the authors make no representations with respect to the accuracy or completeness of the contents of all work on this website and specifically disclaim all warranties, including without limitation warranties of fitness for a particular purpose. The information published on this website may not be suitable for every situation. All work on this website is provided with the understanding that Perl.com and the authors are not engaged in rendering professional services. Neither Perl.com nor the authors shall be liable for damages arising herefrom.</p>
      </div>
    </div>
  </div>
</div>
<script src="/javascript/jquery.min.js"></script>
<script src="/javascript/bootstrap.min.js"></script>
<script data-no-instant>document.write('<script src="/livereload.js?port=1313&mindelay=10"></' + 'script>')</script></body>
</html>

