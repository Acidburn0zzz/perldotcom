<!DOCTYPE html>
<html lang="en-us">
  <head>
  <title> Exegesis 5 </title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content=" Editor&#39;s note: this document is out of date and remains here for historic interest. See Synopsis 5 for the current design information. Exegesis 5 What&#39;s the diff? Starting gently Lay it out for me Interpolate ye not ... The..."/>
  <meta name="robots" content="index, follow">
  <meta name="google-site-verification" content="TZowffo_LX2mmsw2DbeNNbukCMnIOA8T-6CMJPiYllI" />

<meta property="twitter:card" content="summary">
<meta property="twitter:site" content="@PerlFoundation">
<meta property="og:url" content="http://localhost:1313/pub/2002/08/22/exegesis5.html/" />
<meta property="og:title" content="Exegesis 5" />
<meta property="og:description" content=" Editor&#39;s note: this document is out of date and remains here for historic interest. See Synopsis 5 for the current design information. Exegesis 5 What&#39;s the diff? Starting gently Lay it out for me Interpolate ye not ... The...">
<meta property="og:site_name" content="Perl.com" />

<meta property="og:type" content="article" />
<meta property="og:article:published_time" content="2002-08-08T08:08:08Z" />
<meta property="og:image" content="http://localhost:1313/images/_pub_2002_08_22_exegesis5/111-exegesis5.gif" />
<meta property="og:article:tag" content="apocalypse-exegesis-regular-expressions" />


  <link rel="icon" href="/favicon.ico">
  <link href="/article/index.xml" rel="alternate" type="application/rss+xml" title="Perl.com - programming news, code and culture" />
  <link href="/article/index.xml" rel="feed" type="application/rss+xml" title="Perl.com - programming news, code and culture" />
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" type="text/css" href="/css/perldotcom.css"/>


<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-50555-22', 'auto');
ga('create', 'UA-85734801-2', 'auto', 'editor');
ga('send', 'pageview');
ga('editor.send', 'pageview');
</script>

</head>
<body>

<div class="container-fluid full-wdith antonio">
 <div class="row">
  <div class="navbar-inverse" style="border-radius:none !important" role="navigation">
    <div class="container-fluid">
      <ul class="nav navbar-nav pull-right follow">
          <li>MORE:</li>
          <li><a href="https://perl.org">
              <img src="/images/site/perl-onion_20.png" alt="Perl Onion"></a><li>
          <li><a href="https://twitter.com/intent/follow?screen_name=perlfoundation">
              <img src="/images/site/twitter_20.png" alt="twitter"></a><li>
          <li><a href="/article/index.xml" />
              <img src="/images/site/rss_20.png" alt="rss"></a></li>
          <li><a href="https://github.com/tpf/perldotcom" />
              <img src="/images/site/github_light_20.png" alt="GitHub logo"></a></li>
      </ul>
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
          <a class="navbar-nav" href="/">
            <div class="header-logo">Perl.com</div>
          </a>
      </div>
      <div class="navbar-collapse collapse">
        <ul class="nav navbar-nav">
          <li><a href="/about">
              <div class="circle">
                <img src="/images/site/perl-camel.png" alt="" />
              </div>
                  &nbsp;&nbsp;ABOUT</a>
          </li>
          <li><a href="/authors">
              <div class="circle">
                  <span class="glyphicon glyphicon-user txt-blue-major" aria-hidden="true"></span>
              </div>
                  &nbsp;&nbsp;AUTHORS</a>
          </li>
          <li><a href="/categories">
              <div class="circle">
                  <span class="glyphicon glyphicon-folder-open txt-blue-major" aria-hidden="true"></span>
              </div>
                  &nbsp;&nbsp;CATEGORIES</a>
          </li>
          <li><a href="/tags">
              <div class="circle">
                <span class="txt-blue-major" aria-hidden="true"><strong>#</strong></span>
              </div>
                  &nbsp;&nbsp;TAGS</a>
          </li>
          <li>
            <form class="search" name="ddg" action="https://duckduckgo.com/" method="get">
              <input type="text" name ="q" placeholder="SEARCH" />
              <input type="hidden" value="perl.com" name="sites" />
            </form>
          </li>
        </ul>
      </div>
    </div>
  </div>
 </div>
</div>


  <section id="content" role="main">
    <section class="entry-content">
      <div class="container">
        <div class="row">
          <div class="col-md-9">
            <div class="row">
              <article class="fulltext">
              <h1 class="blog-post-title">Exegesis 5</h1>
              <p class="blog-post-meta">Aug 22, 2002 by
              
              
                
                
                <a href="#author-bio-damian-conway">Damian Conway</a>
              
              </p>
              <img alt="" src=""/>
                

<p><em>Editor&rsquo;s note: this document is out of date and remains here for historic interest. See <a href="http://dev.perl.org/perl6/doc/design/syn/S05.html">Synopsis 5</a> for the current design information.</em></p>

<ul>
<li><a href="#exegesis_5">Exegesis 5</a></li>
<li><a href="#whats_the_diff">What&rsquo;s the diff?</a></li>
<li><a href="#starting_gently">Starting gently</a></li>
<li><a href="#lay_it_out_for_me">Lay it out for me</a></li>
<li><a href="#interpolate_ye_not">Interpolate ye not &hellip;</a></li>
<li><a href="#the_incredible_hunk">The incredible <code>$hunk</code></a></li>
<li><a href="#modified_modifiers">Modified modifiers</a></li>
<li><a href="#take_no_prisoners">Take no prisoners</a></li>
<li><a href="#meanwhile_back_at_the_hunk">Meanwhile, back at the <code>$hunk</code> &hellip;</a></li>
<li><a href="#this_or_nothing">This or nothing</a></li>
<li><a href="#failing_with_style">Failing with style</a></li>
<li><a href="#home_home_on_the_line_range">Home, home on the (line) range</a></li>
<li><a href="#whats_my_line">What&rsquo;s my line?</a></li>
<li><a href="#the_final_frontier">The final frontier</a></li>
<li><a href="#matchmaker_matchmaker">Match-maker, match-maker &hellip;</a></li>
<li><a href="#a_cleaner_approach">A cleaner approach</a></li>
<li><a href="#whats_in_a-name">What&rsquo;s in a name?</a></li>
<li><a href="#bad_line_no_match">Bad line! No match!</a></li>
<li><a href="#thinking_ahead">Thinking ahead</a></li>
<li><a href="#what_you_match_is_what_you_get">What you match is what you get</a></li>
<li><a href="#a_hypothetical_solution_to_a_very_real_problem">A hypothetical solution to a very real problem</a></li>
<li><a href="#the_nesting_instinct">The nesting instinct</a></li>
<li><a href="#extracting_the_insertions">Extracting the insertions</a></li>
<li><a href="#dont_just_match_there_do_something!">Don&rsquo;t just match there; do something!</a></li>
<li><a href="#smarter_alternatives">Smarter alternatives</a></li>
<li><a href="#rearranging_the_deckchairs">Rearranging the deck chairs</a></li>
<li><a href="#deriving_a_benefit">Deriving a benefit</a></li>
<li><a href="#different_diffs">Different diffs</a></li>
<li><a href="#lets_get_cooking">Let&rsquo;s get cooking</a></li>
</ul>

<hr />

<h3 id="span-id-exegesis-5-exegesis-5-span"><span id="exegesis_5">Exegesis 5</span></h3>

<p><strong><span id="item_Come_gather_round_Mongers%2C_whatever_you_code"><em>Come gather round Mongers, whatever you code</em></span></strong>
<strong><span id="item_And_admit_that_your_forehead%27s_about_to_explode"><em>And admit that your forehead&rsquo;s about to explode</em></span></strong>
<strong><span id="item_%27Cos_Perl_patterns_induce_complete_brain_overloa"><em>&lsquo;Cos Perl patterns induce complete brain overload</em></span></strong>
<strong><span id="item_If_there%27s_source_code_you_should_be_maintainin%"><em>If there&rsquo;s source code, you should be maintainin&rsquo;</em></span></strong>
<strong><span id="item_Then_you_better_start_learnin%27_Perl_6_patterns_s"><em>Then you better start learnin&rsquo; Perl 6 patterns soon</em></span></strong>
<strong><span id="item_For_the_regexes%2C_they_are_a%2Dchangin%27"><em>For the regexes, they are a-changin&rsquo;</em></span></strong></p>

<p>Apocalypse 5 marks a significant departure in the ongoing design of Perl 6.</p>

<p>Previous Apocalypses took an evolutionary approach to changing Perl&rsquo;s general syntax, data structures, control mechanisms and operators. New features were added, old features removed, and existing features were enhanced, extended and simplified. But the changes described were remedial, not radical.</p>

<p>Larry could have taken the same approach with regular expressions. He could have tweaked some of the syntax, added new <code>(?...)</code> constructs, cleaned up the rougher edges, and moved on.</p>

<p>Fortunately, however, he&rsquo;s taking a much broader view of Perl&rsquo;s future than that. And he saw that the problem with regular expressions was <em>not</em> that they lacked a <code>(?$var:...)</code> extension to do named captures, or that they needed a <code>\R</code> metatoken to denote a recursive subpattern, or that there was a <code>[:YourNamedCharClassHere:]</code> mechanism missing.</p>

<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td><p>Related articles:</p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p></td>
</tr>
</tbody>
</table>

<p>He saw that those features, laudable as they were individually, would just compound the real problem, which was that Perl 5 regular expressions were already groaning under the accumulated weight of their own metasyntax. And that a decade of accretion had left the once-clean notation arcane, baroque, inconsistent and obscure.</p>

<p>It was time to throw away the prototype.</p>

<p>Even more importantly, as powerful as Perl 5 regexes are, they are not nearly powerful enough. Modern text manipulation is predominantly about processing structured, hierarchical text. And that&rsquo;s just plain painful with regular expressions. The advent of modules like Parse::Yapp and Parse::RecDescent reflects the community&rsquo;s widespread need for more sophisticated parsing mechanisms. Mechanisms that should be native to Perl.</p>

<p>As Piers Cawley has so eloquently misquoted: <em>“It is a truth universally acknowledged that any language in possession of a rich syntax must be in want of a rewrite.”</em> Perl regexes are such a language. And Apocalypse 5 is precisely that rewrite.</p>

<hr />

<h3 id="span-id-whats-the-diff-what-s-the-diff-span"><span id="#whats_the_diff">What&rsquo;s the diff?</span></h3>

<p>So let&rsquo;s take a look at some of those new features. To do that, we&rsquo;ll consider a series of examples structured around a common theme: recognizing and manipulating data in the Unix <em><a href="http://www.gnu.org/manual/diffutils-2.8.1/html_node/Detailed-Normal.html">diff</a></em></p>

<p>A classic diff consists of zero-or-more text transformations, each of which is known as a “hunk”. A hunk consists of a modification specifier, followed by one or more lines of context. Each hunk is either an append, a delete, or a change, and the type of hunk is specified by a single letter (<code>'a'</code>, <code>'d'</code>, or <code>'c'</code>). Each of these single-letter specifiers is prefixed by the line numbers of the lines in the original document it affects, and followed by the equivalent line numbers in the transformed file. The context information consists of the lines of the original file (each preceded by a <code>'&lt;'</code> character), then the lines of the transformed file (each preceded by a <code>'&gt;'</code>). Deletes omit the transformed context, appends omit the original context. If both contexts appear, then they are separated by a line consisting of three hyphens.</p>

<p>Phew! You can see why natural language isn&rsquo;t the preferred way of specifying data formats.</p>

<p>The preferred way is, of course, to specify such formats as patterns. And, indeed, we could easily throw together a few Perl 6 patterns that collectively would match any data conforming to that format:</p>

<pre><code>    $file = rx/ ^  &lt;$hunk&gt;*  $ /;

    $hunk = rx :i { 
        [ &lt;$linenum&gt; a :: &lt;$linerange&gt; \n
          &lt;$appendline&gt;+ 
        |
          &lt;$linerange&gt; d :: &lt;$linenum&gt; \n
          &lt;$deleteline&gt;+
        |
          &lt;$linerange&gt; c :: &lt;$linerange&gt; \n
          &lt;$deleteline&gt;+
          --- \n
          &lt;$appendline&gt;+
        ]
      |
        (\N*) ::: { fail &quot;Invalid diff hunk: $1&quot; }
    };

    $linerange = rx/ &lt;$linenum&gt; , &lt;$linenum&gt;
                   | &lt;$linenum&gt;
                   /;

    $linenum = rx/ \d+ /;

    $deleteline = rx/^^ \&lt; &lt;sp&gt; (\N* \n) /;
    $appendline = rx/^^ \&gt; &lt;sp&gt; (\N* \n) /;

    # and later...

    my $text is from($*ARGS);

    print &quot;Valid diff&quot; 
        if $text =~ /&lt;$file&gt;/;
</code></pre>

<hr />

<h3 id="span-id-starting-gently-starting-gently-span"><span id="starting_gently">Starting gently</span></h3>

<p>There&rsquo;s a lot of new syntax there, so let&rsquo;s step through it slowly, starting with:</p>

<pre><code>    $file = rx/ ^  &lt;$hunk&gt;*  $ /;
</code></pre>

<p>This statement creates a pattern object. Or, as it&rsquo;s known in Perl 6, a “rule”. People will probably still call them “regular expressions” or “regexes” too (and the keyword <code>rx</code> reflects that), but Perl patterns long ago ceased being anything like “regular”, so we&rsquo;ll try and avoid those terms.</p>

<p>In any case, the <code>rx</code> constructor builds a new rule, which is then stored in the <code>$file</code> variable. The Perl 5 equivalent would be:</p>

<pre><code>    # Perl 5
    my $file = qr/ ^  (??{$hunk})*  $ /x;
</code></pre>

<p>This illustrates quite nicely why the entire syntax needed to change.</p>

<p>The name of the rule constructor has changed from <code>qr</code> to <code>rx</code>, because in Perl 6 rule constructors <em>aren&rsquo;t</em> quotelike contexts. In particular, variables don&rsquo;t interpolate into <code>rx</code> constructors in the way they do for a <code>qq</code> or a <code>qx</code>. That&rsquo;s why we can embed the <code>$hunk</code> variable before it&rsquo;s actually initialized.</p>

<p>In Perl 6, an embedded variable becomes part of the rule&rsquo;s implementation rather than part of its “source code”. As we&rsquo;ll see shortly, the pattern itself can determine how the variable is treated (i.e., whether to interpolate it literally, treat it as a subpattern or use it as a container).</p>

<hr />

<p><em>Editor&rsquo;s note: this document is out of date and remains here for historic interest. See <a href="http://dev.perl.org/perl6/doc/design/syn/S05.html">Synopsis 5</a> for the current design information.</em></p>

<h3 id="span-id-lay-it-out-for-me-lay-it-out-for-me-span"><span id="lay_it_out_for_me">Lay it out for me</span></h3>

<p>In Perl 6, each rule implicitly has the equivalent of the Perl 5 <code>/x</code> modifier turned on, so we could lay out (and annotate) that first pattern like this:</p>

<pre><code>    $file = rx/ ^               # Must be at start of string
                &lt;$hunk&gt;         # Match what the rule in $hunk would match...
                        *       #          ...zero-or-more times
                $               # Must be at end of string (no newline allowed)
              /;
</code></pre>

<p>Because <code>/x</code> is the default, the whitespace in the pattern is ignored, which allows us to lay out the rule more readably. Comments are also honored, which enables us to document the rule sensibly. You can even use the closing delimiter in a comment safely:</p>

<pre><code>    $caveat = rx/ Make \s+ sure \s+ to \s+ ask
                  \s+ (mum|mom)                 # handle UK/US spelling
                  \s+ (and|or)                  # handle and/or
                  \s+ dad \s+ first
                /;
</code></pre>

<p>Of course, the examples in this Exegesis <em>don&rsquo;t</em> represent good comments in general, since they document what is happening, rather than why.</p>

<p>The meanings of the <code>^</code> and <code>*</code> metacharacters are unchanged from Perl 5. However, the meaning of the <code>$</code> metacharacter <em>has</em> changed slightly: it no longer allows an optional newline before the end of the string. If you want that behavior, then you need to specify it explicitly. For example, to match a line ending in digits: <code>/ \d+ \n? $/</code></p>

<p>The compensation is that, in Perl 6, a <code>\n</code> in a pattern matches a <em>logical</em> newline (that is any of: <code>&quot;\015\012&quot;</code> or <code>&quot;\012&quot;</code> or <code>&quot;\015&quot;</code> or <code>&quot;\x85&quot;</code> or <code>&quot;\x2028&quot;</code>), rather than just a <em>physical</em> ASCII newline (i.e. just <code>&quot;\012&quot;</code>). And a <code>\n</code> will always try to match any kind of physical newline marker (not just the current system&rsquo;s favorite), so it correctly matches against strings that have been aggregated from multiple systems.</p>

<hr />

<h3 id="span-id-interpolate-ye-not-interpolate-ye-not-span"><span id="interpolate_ye_not">Interpolate ye not &hellip;</span></h3>

<p>The really new bit in the <code>$file</code> rule is the <code>&lt;$hunk&gt;</code> element. It&rsquo;s a directive to grab whatever&rsquo;s in the <code>$hunk</code> variable (presumably another pattern) and attempt to match it at that point in the rule. The important point is that the contents of <code>$hunk</code> are only grabbed when the pattern matching mechanism actually needs to match against them, <em>not</em> when the rule is being constructed. So it&rsquo;s like the mysterious <code>(??{...})</code> construct in Perl 5 regexes.</p>

<p>The angle brackets themselves are a much more general mechanism in Perl 6 rules. They are the “metasyntactic markers” and replace the Perl 5 <code>(?...)</code> syntax. They are used to specify numerous other features of Perl 6 rules, many of which we will explore below.</p>

<p>Note that if we <em>hadn&rsquo;t</em> put the variable in angle-brackets, and had just written:</p>

<pre><code>    rx/ ^  $hunk*  $ /;
</code></pre>

<p>then the contents of <code>$hunk</code> would <em>still</em> not be interpolated when the pattern was parsed. Once again, the pattern would grab the contents of the variable when it reached that point in its match. But, this time, without the angle brackets around <code>$hunk</code>, the pattern would try to match the contents of the variable as an atomic literal string (rather than as a subpattern). “Atomic” means that the <code>*</code> repetition quantifier applies to everything that&rsquo;s in <code>$hunk</code>, <em>not</em> just to the last character (as it does in Perl 5).</p>

<p>In other words, a raw variable in a Perl 6 pattern is matched as if it was a Perl 5 regex in which the interpolation had been <code>quotemeta</code>&rsquo;d and then placed in a pair of noncapturing parentheses. That&rsquo;s really handy in something like:</p>

<pre><code>    # Perl 6
    my $target = &lt;&gt;;                  # Get literal string to search for
    $text =~ m/ $target* /;           # Search for them as literals
</code></pre>

<p>which in Perl 5 we&rsquo;d have to write as:</p>

<pre><code>    # Perl 5
    my $target = &lt;&gt;;                  # Get literal string to search for
    chomp $target;                    # No autochomping in Perl 5 
    $text =~ m/ (?:\Q$target\E)* /x;  # Search for it, quoting metas
</code></pre>

<p>Raw arrays and hashes interpolate as literals, too. For example, if we use an array in a Perl 6 pattern, then the matcher will attempt to match any of its elements (each as a literal). So:</p>

<pre><code>    # Perl 6
    @cmd = ('get','put','try','find','copy','fold','spindle','mutilate');

    $str =~ / @cmd \( .*? \) /;     # Match a cmd, followed by stuff in parens
</code></pre>

<p>is the same as:</p>

<pre><code>    # Perl 5 
    @cmd = ('get','put','try','find','copy','fold','spindle','mutilate');
    $cmd = join '|', map { quotemeta $_ } @cmd;

    $str =~ / (?:$cmd) \( .*? \) /;
</code></pre>

<p>By the way, putting the array into angle brackets would cause the matcher to try and match each of the array elements as a pattern, rather than as a literal.</p>

<hr />

<h3 id="span-id-the-incredible-hunk-the-incredible-hunk-span"><span id="the_incredible_hunk">The incredible <code>$hunk</code></span></h3>

<p>The rule that <code>&lt;$hunk&gt;</code> tries to match against is the next one defined in the program. Here&rsquo;s the annotated version of it:</p>

<pre><code>    $hunk = rx :i {                             # Case-insensitively...
        [                                       #   Start a non-capturing group
            &lt;$linenum&gt;                          #     Match the subrule in $linenum
            a                                   #     Match a literal 'a'
            ::                                  #     Commit to this alternative
            &lt;$linerange&gt;                        #     Match the subrule in $linerange
            \n                                  #     Match a newline
            &lt;$appendline&gt;                       #     Match the subrule in $appendline...
                          +                     #         ...one-or-more times
        |                                       #   Or...
          &lt;$linerange&gt; d :: &lt;$linenum&gt; \n       #     Match $linerange, 'd', $linenum, newline
          &lt;$deleteline&gt;+                        #     Then match $deleteline once-or-more
        |                                       #   Or...
          &lt;$linerange&gt; c :: &lt;$linerange&gt; \n     #     Match $linerange, 'c', $linerange, newline
          &lt;$deleteline&gt;+                        #     Then match $deleteline once-or-more
          --- \n                                #     Then match three '-' and a newline
          &lt;$appendline&gt;+                        #     Then match $appendline once-or-more
        ]                                       #   End of non-capturing group
      |                                         # Or...
        (                                       #   Start a capturing group
            \N*                                 #     Match zero-or-more non-newlines
        )                                       #     End of capturing group
        :::                                     #     Emphatically commit to this alternative
        { fail &quot;Invalid diff hunk: $1&quot; }        #     Then fail with an error msg
    };
</code></pre>

<p>The first thing to note is that, like a Perl 5 <code>qr</code>, a Perl 6 <code>rx</code> can take (almost) any delimiters we choose. The <code>$hunk</code> pattern uses <code>{...}</code>, but we could have used:</p>

<pre><code>    rx/pattern/     # Standard
    rx[pattern]     # Alternative bracket-delimiter style
    rx&lt;pattern&gt;     # Alternative bracket-delimiter style
    rx«forme»       # Délimiteurs très chic
    rx&gt;pattern&lt;     # Inverted bracketing is allowed too (!)
    rx»Muster«      # Begrenzungen im korrekten Auftrag
    rx!pattern!     # Excited
    rx=pattern=     # Unusual
    rx?pattern?     # No special meaning in Perl 6
    rx#pattern#     # Careful with these: they disable internal comments
</code></pre>

<hr />

<h3 id="span-id-modified-modifiers-modified-modifiers-span"><span id="modified_modifiers">Modified modifiers</span></h3>

<p>In fact, the only characters not permitted as <code>rx</code> delimiters are <code>':'</code> and <code>'('</code>. That&rsquo;s because <code>':'</code> is the character used to introduce pattern modifiers in Perl 6, and <code>'('</code> is the character used to delimit any arguments that might be passed to those pattern modifiers.</p>

<p>In Perl 6, pattern modifiers are placed <em>before</em> the pattern, rather than after it. That makes life easier for the parser, since it doesn&rsquo;t have to go back and reinterpret the contents of a rule when it reaches the end and discovers a <code>/s</code> or <code>/m</code> or <code>/i</code> or <code>/x</code>. And it makes life easier for anyone reading the code &ndash; for precisely the same reason.</p>

<p>The only modifier used in the <code>$hunk</code> rule is the <code>:i</code> (case-insensitivity) modifier, which works exactly as it does in Perl 5.</p>

<p>The other rule modifiers available in Perl 6 are:</p>

<p><strong><span id="item_%3Ae_or_%3Aeach"><code>:e</code> or <code>:each</code></span></strong></p>

<p>This is the replacement for Perl 5&rsquo;s <code>/g</code> modifier. It causes a match (or substitution) to be attempted as many times as possible. The name was changed because “each” is shorter and clearer in intent than “globally”. And because the <code>:each</code> modifier can be combined with other modifiers (see below) in such a way that it&rsquo;s no longer “global” in its effect.</p>

<p><strong><span id="item_x"><code>:x($count)</code></span></strong></p>

<p>This modifier is like <code>:e</code>, in that it causes the match or substitution to be attempted repeatedly. However, unlike <code>:e</code>, it specifies exactly how many times the match must succeed. For example:</p>

<pre><code>    &quot;fee fi &quot;       =~ m:x(3)/ (f\w+) /;  # fails
    &quot;fee fi fo&quot;     =~ m:x(3)/ (f\w+) /;  # succeeds (matches &quot;fee&quot;,&quot;fi&quot;,&quot;fo&quot;)
    &quot;fee fi fo fum&quot; =~ m:x(3)/ (f\w+) /;  # succeeds (matches &quot;fee&quot;,&quot;fi&quot;,&quot;fo&quot;)
</code></pre>

<p>Note that the repetition count doesn&rsquo;t have to be a constant:</p>

<pre><code>    m:x($repetitions)/ pattern /
</code></pre>

<p>There is also a series of tidy abbreviations for all the constant cases:</p>

<pre><code>    m:1x/ pattern /         # same as: m:x(1)/ pattern /
    m:2x/ pattern /         # same as: m:x(2)/ pattern /
    m:3x/ pattern /         # same as: m:x(3)/ pattern /
    # etc.
</code></pre>

<p><strong><span id="item_nth"><code>:nth($count)</code></span></strong></p>

<p>This modifier causes a match or substitution to be attempted repeatedly, but to ignore the first <code>$count-1</code> successful matches. For example:</p>

<pre><code>    my $foo = &quot;fee fi fo fum&quot;;

    $foo =~ m:nth(1)/ (f\w+) /;        # succeeds (matches &quot;fee&quot;)
    $foo =~ m:nth(2)/ (f\w+) /;        # succeeds (matches &quot;fi&quot;)
    $foo =~ m:nth(3)/ (f\w+) /;        # succeeds (matches &quot;fo&quot;)
    $foo =~ m:nth(4)/ (f\w+) /;        # succeeds (matches &quot;fum&quot;)
    $foo =~ m:nth(5)/ (f\w+) /;        # fails
    $foo =~ m:nth($n)/ (f\w+) /;       # depends on the numeric value of $n

    $foo =~ s:nth(3)/ (f\w+) /bar/;    # $foo now contains: &quot;fee fi bar fum&quot;
</code></pre>

<p>Again, there is also a series of abbreviations:</p>

<pre><code>    $foo =~ m:1st/ (f\w+) /;           # succeeds (matches &quot;fee&quot;)
    $foo =~ m:2nd/ (f\w+) /;           # succeeds (matches &quot;fi&quot;)
    $foo =~ m:3rd/ (f\w+) /;           # succeeds (matches &quot;fo&quot;)
    $foo =~ m:4th/ (f\w+) /;           # succeeds (matches &quot;fum&quot;)
    $foo =~ m:5th/ (f\w+) /;           # fails

    $foo =~ s:3rd/ (f\w+) /bar/;       # $foo now contains: &quot;fee fi bar fum&quot;
</code></pre>

<p>By the way, Perl isn&rsquo;t going to be pedantic about these “ordinal” versions of repetition specifiers. If you&rsquo;re not a native English speaker, and you find <code>:1th</code>, <code>:2th</code>, <code>:3th</code>, <code>:4th</code>, etc., easier to remember, then that&rsquo;s perfectly OK.</p>

<p>The various types of repetition modifiers can also be combined by separating them with additional colons:</p>

<pre><code>    my $foo = &quot;fee fi fo feh far foo fum &quot;;

    $foo =~ m:2nd:2x/ (f\w+) /;        # succeeds (matches &quot;fi&quot;, &quot;feh&quot;)
    $foo =~ m:each:2nd/ (f\w+) /;      # succeeds (matches &quot;fi&quot;, &quot;feh&quot;, &quot;foo&quot;)
    $foo =~ m:x(2):nth(3)/ (f\w+) /;   # succeeds (matches &quot;fo&quot;, &quot;foo&quot;)
    $foo =~ m:each:3rd/ (f\w+) /;      # succeeds (matches &quot;fo&quot;, &quot;foo&quot;)
    $foo =~ m:2x:4th/ (f\w+) /;        # fails (not enough matches to satisfy :2x)
    $foo =~ m:4th:each/ (f\w+) /;      # succeeds (matches &quot;feh&quot;)

    $foo =~ s:each:2nd/ (f\w+) /bar/;  # $foo now &quot;fee bar fo bar far bar fum &quot;;
</code></pre>

<p>Note that the order in which the two modifiers are specified doesn&rsquo;t matter.</p>

<p><strong><span id="item_%3Ap5_or_%3Aperl5"><code>:p5</code> or <code>:perl5</code></span></strong></p>

<p>This modifier causes Perl 6 to interpret the contents of a rule as a regular expression in Perl 5 syntax. This is mainly provided as a transitional aid for porting Perl 5 code. And to mollify the curmudgeonly.</p>

<p><strong><span id="item_%3Aw_or_%3Aword"><code>:w</code> or <code>:word</code></span></strong></p>

<p>This modifier causes whitespace appearing in the pattern to match optional whitespace in the string being matched. For example, instead of having to cope with optional whitespace explicitly:</p>

<pre><code>    $cmd =~ m/ \s* &lt;keyword&gt; \s* \( [\s* &lt;arg&gt; \s* ,?]* \s* \)/;
</code></pre>

<p>we can just write:</p>

<pre><code>    $cmd =~ m:w/ &lt;keyword&gt; \( [ &lt;arg&gt; ,?]* \)/;
</code></pre>

<p>The <code>:w</code> modifier is also smart enough to detect those cases where the whitespace should actually be mandatory. For example:</p>

<pre><code>    $str =~ m:w/a symmetric ally/
</code></pre>

<p>is the same as:</p>

<pre><code>    $str =~ m/a \s+ symmetric \s+ ally/
</code></pre>

<p>rather than:</p>

<pre><code>    $str =~ m/a \s* symmetric \s* ally/
</code></pre>

<p>So it won&rsquo;t accidentally match strings like <code>&quot;asymmetric ally&quot;</code> or <code>&quot;asymmetrically&quot;</code>.</p>

<p><strong><span id="item_%3Aany"><code>:any</code></span></strong></p>

<p>This modifier causes the rule to match a given string in every possible way, simultaneously, and then return all the possible matches. For example:</p>

<pre><code>    my $str = &quot;ahhh&quot;;

    @matches =  $str =~ m/ah*/;         # returns &quot;ahhh&quot;
    @matches =  $str =~ m:any/ah*/;     # returns &quot;ahhh&quot;, &quot;ahh&quot;, &quot;ah&quot;, &quot;a&quot;
</code></pre>

<p><strong><span id="item_%3Au0%2C_%3Au1%2C_%3Au2%2C_%3Au3"><code>:u0</code>, <code>:u1</code>, <code>:u2</code>, <code>:u3</code></span></strong></p>

<p>These modifiers specify how the rule matches the dot (<code>.</code>) metacharacter against Unicode data. If <code>:u0</code> is specified, then dot matches a single byte; if <code>:u1</code> is specified, then dot matches a single codepoint (i.e. one or more bytes representing a single Unicode “character”). If <code>:u2</code> is specified, then dot matches a single grapheme (i.e. a base codepoint followed by zero or more modifier codepoints, such as accents). If <code>:u3</code> is specified, then dot matches an appropriate “something” in a language-dependent manner.</p>

<p>It&rsquo;s OK to ignore this modifier if you&rsquo;re not using Unicode (and maybe even if you are). As usual, Perl will try to do the right thing. To that end, the default behavior of rules is <code>:u2</code>, unless an overriding pragma (e.g. <code>use bytes</code>) is in effect.</p>

<p>Note that the <code>/s</code>, <code>/m</code>, and <code>/e</code> modifiers are no longer available. This is because they&rsquo;re no longer needed. The <code>/s</code> isn&rsquo;t needed because the <code>.</code> (dot) metacharacter now matches newlines as well. When we want to match “anything except a newline”, we now use the new <code>\N</code> metatoken (i.e. “opposite of <code>\n</code>”).</p>

<p>The <code>/m</code> modifier isn&rsquo;t required, because <code>^</code> and <code>$</code> always mean start and end of string, respectively. To match the start and end of a line, we use the new <code>^^</code> and <code>$$</code> metatokens instead.</p>

<p>The <code>/e</code> modifier is no longer needed, because Perl 6 provides the <code>$(...)</code> string interpolator (as described in Apocalypse 2). So a substitution such as:</p>

<pre><code>    # Perl 5
    s/(\w+)/ get_val_for($1) /e;
</code></pre>

<p>becomes just:</p>

<pre><code>    # Perl 6
    s/(\w+)/$( get_val_for($1) )/;
</code></pre>

<hr />

<p><em>Editor&rsquo;s note: this document is out of date and remains here for historic interest. See <a href="http://dev.perl.org/perl6/doc/design/syn/S05.html">Synopsis 5</a> for the current design information.</em></p>

<h3 id="span-id-take-no-prisoners-take-no-prisoners-span"><span id="take_no_prisoners">Take no prisoners</span></h3>

<p>The first character of the <code>$hunk</code> rule is an opening square bracket. In Perl 5, that denoted the start of a character class, but not in Perl 6. In Perl 6, square brackets mark the boundaries of a noncapturing group. That is, a pair of square brackets in Perl 6 are the same as a <code>(?:...)</code> in Perl 5, but less line-noisy.</p>

<p>By the way, to get a character class in Perl 6, we need to put the square brackets inside a pair of metasyntactic angle brackets. So the Perl 5:</p>

<pre><code>    # Perl 5
    / [A-Za-z] [0-9]+ /x          # An A-Z or a-z, followed by digits
</code></pre>

<p>would become in Perl 6:</p>

<pre><code>    # Perl 6
    / &lt;[A-Za-z]&gt; &lt;[0-9]&gt;+ /       # An A-Z or a-z, followed by digits
</code></pre>

<p>The Perl 5 complemented character class:</p>

<pre><code>    # Perl 5
    / [^A-Za-z]+ /x               # One-or-more chars-that-aren't-A-Z-or-a-z
</code></pre>

<p>becomes in Perl 6:</p>

<pre><code>    # Perl 6
    / &lt;-[A-Za-z]&gt;+ /              #  One-or-more chars-that-aren't-A-Z-or-a-z
</code></pre>

<p>The external minus sign is used (instead of an internal caret), because Perl 6 allows proper set operations on character classes, and the minus sign is the “difference” operator. So we could also create:</p>

<pre><code>    # Perl 6
    / &lt; &lt;alpha&gt; - [A-Za-z] &gt;+ /   # All alphabetics except A-Z or a-z
                                  # (i.e. the accented alphabetics)
</code></pre>

<p>Explicit character classes were deliberately made a little less convenient in Perl 6, because they&rsquo;re generally a bad idea in a Unicode world. For example, the <code>[A-Za-z]</code> character class in the above examples won&rsquo;t even match standard alphabetic Latin-1 characters like <code>'Ã'</code>, <code>'é'</code>, <code>'ø'</code>, let alone alphabetic characters from code-sets such as Cyrillic, Hiragana, Ogham, Cherokee, or Klingon.</p>

<hr />

<h3 id="span-id-meanwhile-back-at-the-hunk-meanwhile-back-at-the-hunk-span"><span id="meanwhile_back_at_the_hunk">Meanwhile, back at the <code>$hunk</code> &hellip;</span></h3>

<p>The noncapturing group of the <code>$hunk</code> pattern groups together three alternatives, separated by <code>|</code> metacharacters (as in Perl 5). The first alternative:</p>

<pre><code>    &lt;$linenum&gt; a :: &lt;$linerange&gt;
    \n                         
    &lt;$appendline&gt;+
</code></pre>

<p>grabs whatever is in the <code>$linenum</code> variable, treats it as a subpattern, and attempts to match against it. It then matches a literal letter <code>'a'</code> (or an <code>'A'</code>, because of the <code>:i</code> modifier on the rule). Then whatever the contents of the <code>$linerange</code> variable match. Then a newline. Then it tries to match whatever the pattern in <code>$appendline</code> would match, one or more times.</p>

<p>But what about that double-colon after the <code>a</code>? Shouldn&rsquo;t the pattern have tried to match two colons at that point?</p>

<hr />

<h3 id="span-id-this-or-nothing-this-or-nothing-span"><span id="this_or_nothing">This or nothing</span></h3>

<p>Actually, no. The double-colon is a new Perl 6 pattern-control structure. It has no effect (and is ignored) when the pattern is successfully matching, but if the pattern match should fail, and consequently back-track over the double-colon &ndash; for example, to try and rematch an earlier repetition one fewer times &ndash; the double-colon causes the entire surrounding group (i.e. the surrounding <code>[...]</code> in this case) to fail as well.</p>

<p>That&rsquo;s a useful optimization in this case because, if we match a line number followed by an <code>'a'</code> but subsequently fail, then there&rsquo;s no point even trying either of the other two alternatives in the same group. Because we found an <code>'a'</code>, there&rsquo;s no chance we could match a <code>'d'</code> or a <code>'c'</code> instead.</p>

<p>So, in general, a double-colon means: “At this point I&rsquo;m committed to this alternative within the current group &ndash; don&rsquo;t bother with the others if this one fails after this point”.</p>

<p>There are other control directives like this, too. A single colon means: “Don&rsquo;t bother backtracking into the previous element”. That&rsquo;s useful in a pattern like:</p>

<pre><code>    rx:w/ $keyword [-full|-quick|-keep]+ : end /
</code></pre>

<p>Suppose we successfully match the keyword (as a literal, by the way) and one or more of the three options, but then fail to match <code>'end'</code>. In that case, there&rsquo;s no point backtracking and trying to match one fewer option, and <em>still</em> failing to find an <code>'end'</code>. And then backtracking <em>another</em> option, and failing again, etc. By using the colon after the repetition, we tell the matcher to give up after the first attempt.</p>

<p>However, the single colon isn&rsquo;t just a “Greed is Good” operator. It&rsquo;s much more like a “Resistance is Futile” operator. That is, if the preceding repetition had been non-greedy instead:</p>

<pre><code>    rx:w/ $keyword [-full|-quick|-keep]+? : end /
</code></pre>

<p>then backtracking over the colon would prevent the <code>+?</code> from attempting to match <em>more</em> options. Note that this means that <code>x+?:</code> is just a baroque way of matching exactly one repetition of <code>x</code>, since the non-greedy repetition initially tries to match the minimal number of times (i.e. once) and the trailing colon then prevents it from backtracking and trying longer matches. Likewise, <code>x*?:</code> and <code>x??:</code> are arcane ways of matching exactly zero repetitions of <code>x</code>.</p>

<p>Generally, though, a single colon tells the pattern matcher that there&rsquo;s no point trying any other match on the preceding repetition, because retrying (whether more or fewer repetitions) would just waste time and would still fail.</p>

<p>There&rsquo;s also a three-colon directive. Three colons means: “If we have to backtrack past here, cause the entire rule to fail” (i.e. not just this group). If the double-colon in <code>$hunk</code> had been triple:</p>

<pre><code>    &lt;$linenum&gt; a ::: &lt;$linerange&gt;
    \n                         
    &lt;$appendline&gt;+
</code></pre>

<p>then matching a line number and an <code>'a'</code> and subsequently failing would cause the entire <code>$hunk</code> rule to fail immediately (though the <code>$file</code> rule that invoked it might still match successfully in some other way).</p>

<p>So, in general, a triple-colon specifies: “At this point I&rsquo;m committed to this way of matching the current rule &ndash; give up on the rule completely if the matching process fails at this point”.</p>

<p>Four colons &hellip; would just be silly. So, instead, there&rsquo;s a special named directive: <code>&lt;commit&gt;</code>. Backtracking through a <code>&lt;commit&gt;</code> causes the entire match to immediately fail. And if the current rule is being matched as part of a larger rule, that larger rule will fail as well. In other words, it&rsquo;s the “Blow up this Entire Planet and Possibly One or Two Others We Noticed on our Way Out Here” operator.</p>

<p>If the double-colon in <code>$hunk</code> had been a <code>&lt;commit&gt;</code> instead:</p>

<pre><code>    &lt;$linenum&gt; a &lt;commit&gt; &lt;$linerange&gt;
    \n                         
    &lt;$appendline&gt;+
</code></pre>

<p>then matching a line number and an <code>'a'</code> and subsequently failing would cause the entire <code>$hunk</code> rule to fail immediately, <em>and</em> would also cause the <code>$file</code> rule that invoked it to fail immediately.</p>

<p>So, in general, a <code>&lt;commit&gt;</code> means: “At this point I&rsquo;m committed to this way of completing the current match &ndash; give up all attempts at matching anything if the matching process fails at this point”.</p>

<hr />

<h3 id="span-id-failing-with-style-failing-with-style-span"><span id="failing_with_style">Failing with style</span></h3>

<p>The other two alternatives:</p>

<pre><code>    | &lt;$linerange&gt; d :: &lt;$linenum&gt; \n
      &lt;$deleteline&gt;+                 
    | &lt;$linerange&gt; c :: &lt;$linerange&gt; \n
      &lt;$deleteline&gt;+  --- \n  &lt;$appendline&gt;+
</code></pre>

<p>are just variants on the first.</p>

<p>If none of the three alternatives in the square brackets matches, then the alternative outside the brackets is tried:</p>

<pre><code>    |  (\N*) ::: { fail &quot;Invalid diff hunk: $1&quot; }
</code></pre>

<p>This captures a sequence of non-newline characters (<code>\N</code> means “not <code>\n</code>”, in the same way <code>\S</code> means “not <code>\s</code>” or <code>\W</code> means “not <code>\w</code>”). Then it invokes a block of Perl code inside the pattern. The call to <code>fail</code> causes the match to fail at that point, and sets an associated error message that would subsequently appear in the <code>$!</code> error variable (and which would also be accessible as part of <code>$0</code>).</p>

<p>Note the use of the triple colon after the repetition. It&rsquo;s needed because the <code>fail</code> in the block will cause the pattern match to backtrack, but there&rsquo;s no point backing up one character and trying again, since the original failure was precisely what we wanted. The presence of the triple-colon causes the entire rule to fail as soon as the backtracking reaches that point the first time.</p>

<p>The overall effect of the <code>$hunk</code> rule is therefore either to match one hunk of the diff, or else fail with a relevant error message.</p>

<hr />

<h3 id="span-id-home-home-on-the-line-range-home-home-on-the-line-range-span"><span id="home_home_on_the_line_range">Home, home on the (line)range</span></h3>

<p>The third and fourth rules:</p>

<pre><code>    $linerange = rx/ &lt;$linenum&gt; , &lt;$linenum&gt;
                   | &lt;$linenum&gt; 
                   /;

    $linenum = rx/ \d+ /;
</code></pre>

<p>specify that a line number consists of a series of digits, and that a line range consists of either two line numbers with a comma between them or a single line number. The <code>$linerange</code> rule could also have been written:</p>

<pre><code>    $linerange = rx/ &lt;$linenum&gt; [ , &lt;$linenum&gt; ]? /;
</code></pre>

<p>which might be marginally more efficient, since it doesn&rsquo;t have to backtrack and rematch the first <code>$linenum</code> in the second alternative. It&rsquo;s likely, however, that the rule optimizer will detect such cases and automatically hoist the common prefix out anyway, so it&rsquo;s probably not worth the decrease in readability to do that manually.</p>

<hr />

<h3 id="span-id-whats-my-line-what-s-my-line-span"><span id="whats_my_line">What&rsquo;s my line?</span></h3>

<p>The final two rules specify the structure of individual context lines in the diff (i.e. the lines that say what text is being added or removed by the hunk):</p>

<pre><code>    $deleteline = rx/^^ \&lt; &lt;sp&gt; (\N* \n) /
    $appendline = rx/^^ \&gt; &lt;sp&gt; (\N* \n) /
</code></pre>

<p>The <code>^^</code> markers ensure that each rule starts at the beginning of an entire line.</p>

<p>The first character on that line must be either a <code>'&lt;'</code> or a <code>'&gt;'</code>. Note that we have to escape these characters since angle brackets are metacharacters in Perl 6. An alternative would be to use the “literal string” metasyntax:</p>

<pre><code>    $deleteline = rx/^^ &lt;'&lt;'&gt; &lt;sp&gt; (\N* \n) /
    $appendline = rx/^^ &lt;'&gt;'&gt; &lt;sp&gt; (\N* \n) /
</code></pre>

<p>That is, angle brackets with a single-quoted string inside them match the string&rsquo;s sequence of characters as literals (including whitespace and other metatokens).</p>

<p>Or we could have used the quotemeta metasyntax (<code>\Q[...]</code>):</p>

<pre><code>    $deleteline = rx/^^ \Q[&lt;] &lt;sp&gt; (\N* \n) /
    $appendline = rx/^^ \Q[&gt;] &lt;sp&gt; (\N* \n) /
</code></pre>

<p>Note that Perl 5&rsquo;s <code>\Q...\E</code> construct is replaced in Perl 6 by just the <code>\Q</code> marker, which now takes a group after it.</p>

<p>We could also have used a single-letter character class:</p>

<pre><code>    $deleteline = rx/^^ &lt;[&lt;]&gt; &lt;sp&gt; (\N* \n) /
    $appendline = rx/^^ &lt;[&gt;]&gt; &lt;sp&gt; (\N* \n) /
</code></pre>

<p>or even a named character (<code>\c[CHAR NAME HERE]</code>):</p>

<pre><code>    $deleteline = rx/^^ \c[LEFT ANGLE BRACKET] &lt;sp&gt; (\N* \n) /
    $appendline = rx/^^ \c[RIGHT ANGLE BRACKET] &lt;sp&gt; (\N* \n) /
</code></pre>

<p>Whether any of those MTOWTDI is better than just escaping the angle bracket is, of course, a matter of personal taste.</p>

<hr />

<h3 id="span-id-the-final-frontier-the-final-frontier-span"><span id="the_final_frontier">The final frontier</span></h3>

<p>After the leading angle, a single literal space is expected. Again, we could have specified that by escapology (<code>\ </code>) or literalness (<code>&lt;' '&gt;</code>) or quotemetaphysics (<code>\Q[ ]</code>) or character classification (<code>&lt;[ ]&gt;</code>), or deterministic nomimalism (<code>\c[SPACE]</code>), but Perl 6 also gives us a simple <em>name</em> for the space character: <code>&lt;sp&gt;</code>. This is the preferred option, since it reduces line-noise and makes the significant space much harder to miss.</p>

<p>Perl 6 provides predefined names for other useful subpatterns as well, including:</p>

<p><strong><span id="item_%3Cdot%3E"><code>&lt;dot&gt;</code></span></strong></p>

<p>which matches a literal dot (<code>'.'</code>) character (i.e. it&rsquo;s a more elegant synonym for <code>\.</code>);</p>

<p><strong><span id="item_%3Clt%3E_and_%3Cgt%3E"><code>&lt;lt&gt;</code> and <code>&lt;gt&gt;</code></span></strong></p>

<p>which match a literal <code>'&lt;'</code> and <code>'&gt;'</code> respectively. These give us yet another way of writing:</p>

<pre><code>    $deleteline = rx/^^ &lt;lt&gt; &lt;sp&gt; (\N* \n) /
    $appendline = rx/^^ &lt;gt&gt; &lt;sp&gt; (\N* \n) /
</code></pre>

<p><strong><span id="item_%3Cws%3E"><code>&lt;ws&gt;</code></span></strong></p>

<p>which matches any sequence of whitespace (i.e. it&rsquo;s a more elegant synonym for <code>\s+</code>). Optional whitespace is, therefore, specified as <code>&lt;ws&gt;?</code> or <code>&lt;ws&gt;*</code> (Perl 6 will accept either);</p>

<p><strong><span id="item_%3Calpha%3E"><code>&lt;alpha&gt;</code></span></strong></p>

<p>which matches a single alphabetic character (i.e. it&rsquo;s like the character class <code>&lt;[A-Za-z]&gt;</code> but it handles accented characters and alphabetic characters from non-Roman scripts as well);</p>

<p><strong><span id="item_%3Cident%3E"><code>&lt;ident&gt;</code></span></strong></p>

<p>which is a short-hand for <code>[ [&lt;alpha&gt;|_] \w* ]</code> (i.e. a standard identifier in many languages, including Perl)</p>

<p>Using named subpatterns like these makes rules clearer in intent, easier to read, and more self-documenting. And, as we&rsquo;ll see <a href="#what's%20in%20a%20name">shortly</a>, they&rsquo;re fully generalizable&hellip;we can create our own.</p>

<hr />

<h3 id="span-id-matchmaker-matchmaker-match-maker-match-maker-span"><span id="matchmaker_matchmaker">Match-maker, match-maker&hellip;</span></h3>

<p>Finally, we&rsquo;re ready to actually read in and match a diff file. In Perl 5, we&rsquo;d do that like so:</p>

<pre><code>    # Perl 5

    local $/;          # Disable input record separator (enable slurp mode)
    my $text = &lt;&gt;;     # Slurp up input stream into $text

    print &quot;Valid diff&quot; 
        if $text =~ /$file/;
</code></pre>

<p>We could do the same thing in Perl 6 (though the syntax would differ slightly) and in this case that would be fine. But, in general, it&rsquo;s clunky to have to slurp up the entire input before we start matching. The input might be huge, and we might fail early. Or we might want to match input interactively (and issue an error message as soon as the input fails to match). Or we might be matching a series of different formats. Or we might want to be able to leave the input stream in its original state if the match fails.</p>

<p>The inability to do pattern matches immediately on an input stream is one of Perl 5&rsquo;s few weaknesses when it comes to text processing. Sure, we can read line-by-line and apply pattern matching to each line, but trying to match a construct that may be laid out across an unknown number of lines is just painful.</p>

<p>Not in Perl 6 though. In Perl 6, we can bind an input stream to a scalar variable (i.e. like a Perl 5 tied variable) and then just match on the characters in that stream as if they were already in memory:</p>

<pre><code>    my $text is from($*ARGS);       # Bind scalar to input stream

    print &quot;Valid diff&quot; 
        if $text =~ /&lt;$file&gt;/;      # Match against input stream
</code></pre>

<p>The important point is that, after the match, only those characters that the pattern actually matched will have been removed from the input stream.</p>

<p>It may also be possible to skip the variable entirely and just write:</p>

<pre><code>    print &quot;Valid diff&quot; 
        if $*ARGS =~ /&lt;$file&gt;/;     # Match against input stream
</code></pre>

<p>or:</p>

<pre><code>    print &quot;Valid diff&quot; 
        if &lt;&gt; =~ /&lt;$file&gt;/;         # Match against input stream
</code></pre>

<p>but that&rsquo;s yet to be decided.</p>

<hr />

<h3 id="span-id-a-cleaner-approach-a-cleaner-approach-span"><span id="a_cleaner_approach">A cleaner approach</span></h3>

<p>The previous example solves the problem of recognizing a valid diff file quite nicely (and with only six rules!), but it does so by cluttering up the program with a series of variables storing those precompiled patterns.</p>

<p>It&rsquo;s as if we were to write a collection of subroutines like this:</p>

<pre><code>    my $print_name = sub ($data) { print $data{name}, &quot;\n&quot;; };
    my $print_age  = sub ($data) { print $data{age}, &quot;\n&quot;; };
    my $print_addr = sub ($data) { print $data{addr}, &quot;\n&quot;; };

    my $print_info = sub ($data) {
        $print_name($data);
        $print_age($data);
        $print_addr($data);
    };

    # and later...

    $print_info($info);
</code></pre>

<p>You <em>could</em> do it that way, but it&rsquo;s not the right way to do it. The right way to do it is as a collection of named subroutines or methods, often collected together in the namespace of a class or module:</p>

<pre><code>    module Info {

        sub print_name ($data) { print $data{name}, &quot;\n&quot;; }
        sub print_age ($data)  { print $data{age}, &quot;\n&quot;; }
        sub print_addr ($data) { print $data{addr}, &quot;\n&quot;; }

        sub print_info ($data) {
            print_name($data);
            print_age($data);
            print_addr($data);
        }
    }

    Info::print_info($info);
</code></pre>

<p>So it is with Perl 6 patterns. You <em>can</em> write them as a series of pattern objects created at run-time, but they&rsquo;re much better specified as a collection of named patterns, collected together at compile-time in the namespace of a grammar.</p>

<p>Here&rsquo;s the previous diff-parsing example rewritten that way (and with a few extra bells-and-whistles added in):</p>

<pre><code>    grammar Diff {
        rule file { ^  &lt;hunk&gt;*  $ }

        rule hunk :i { 
            [ &lt;linenum&gt; a :: &lt;linerange&gt; \n
              &lt;appendline&gt;+ 
            |
              &lt;linerange&gt; d :: &lt;linenum&gt; \n
              &lt;deleteline&gt;+
            |
              &lt;linerange&gt; c :: &lt;linerange&gt; \n
              &lt;deleteline&gt;+
              --- \n
              &lt;appendline&gt;+
            ]
          |
            &lt;badline(&quot;Invalid diff hunk&quot;)&gt;
        }

        rule badline ($errmsg) { (\N*) ::: { fail &quot;$errmsg: $1&quot; }

        rule linerange { &lt;linenum&gt; , &lt;linenum&gt;
                       | &lt;linenum&gt;
                       }

        rule linenum { \d+ }

        rule deleteline { ^^ &lt;out_marker&gt; (\N* \n) }
        rule appendline { ^^ &lt;in_marker&gt;  (\N* \n) }

        rule out_marker { \&lt;  &lt;sp&gt; }
        rule in_marker  { \&gt;  &lt;sp&gt; }
    }

    # and later...

    my $text is from($*ARGS);

    print &quot;Valid diff&quot; 
        if $text =~ /&lt;Diff.file&gt;/;
</code></pre>

<hr />

<h3 id="span-id-whats-in-a-name-what-s-in-a-name-span"><span id="whats_in_a_name">What&rsquo;s in a name?</span></h3>

<p>The <code>grammar</code> declaration creates a new namespace for rules (in the same way a <code>class</code> or <code>module</code> declaration creates a new namespace for methods or subroutines). If a block is specified after the grammar&rsquo;s name:</p>

<pre><code>    grammar HTML {

        rule file :iw { \Q[&lt;HTML&gt;]  &lt;head&gt;  &lt;body&gt;  \Q[&lt;/HTML&gt;] }

        rule head :iw { \Q[&lt;HEAD&gt;]  &lt;head_tag&gt;+  \Q[&lt;HEAD&gt;] }

        # etc.

    } # Explicit end of HTML grammar
</code></pre>

<p>then that new namespace is confined to that block. Otherwise the namespace continues until the end of the source section of the current file:</p>

<pre><code>    grammar HTML;

    rule file :iw { \Q[&lt;HTML&gt;]  &lt;head&gt;  &lt;body&gt;  \Q[&lt;/HTML&gt;] }

    rule head :iw { \Q[&lt;HEAD&gt;]  &lt;head_tag&gt;+  \Q[&lt;HEAD&gt;] }

    # etc.

    # Implicit end of HTML grammar
    __END__
</code></pre>

<p>Note that, as with the blockless variants on <code>class</code> and <code>module</code>, this form of the syntax is designed to simplify one-namespace-per-file situations. It&rsquo;s a compile-time error to put two or more blockless grammars, classes or modules in a single file.</p>

<p>Within the namespace, named rules are defined using the <code>rule</code> declarator. It&rsquo;s analogous to the <code>sub</code> declarator within a module, or the <code>method</code> declarator within a class. Just like a class method, a named rule has to be invoked through its grammar if we refer to it outside its own namespace. That&rsquo;s why the actual match became:</p>

<pre><code>    $text =~ /&lt;Diff.file&gt;/;         # Invoke through grammar
</code></pre>

<p>If we want to match a named rule, we put the name in angle brackets. Indeed, many of the constructs we&rsquo;ve already seen &ndash; <code>&lt;sp&gt;</code>, <code>&lt;ws&gt;</code>, <code>&lt;ident&gt;</code>, <code>&lt;alpha&gt;</code>, <code>&lt;commit&gt;</code> &ndash; are really just predefined named rules that come standard with Perl 6.</p>

<p>Like subroutines and methods, within their own namespace, rules don&rsquo;t have to be qualified. Which is why we can write things like:</p>

<pre><code>    rule linerange { &lt;linenum&gt; , &lt;linenum&gt;
                   | &lt;linenum&gt;
                   }
</code></pre>

<p>instead of:</p>

<pre><code>    rule linerange { &lt;Diff.linenum&gt; , &lt;Diff.linenum&gt;
                   | &lt;Diff.linenum&gt;
                   }
</code></pre>

<p>Using named rules has several significant advantages, apart from making the patterns look cleaner. For one thing, the compiler may be able to optimize the embedded named rules better. For example, it could inline the attempts to match <code>&lt;linenum&gt;</code> within the <code>linerange</code> rule. In the <code>rx</code> version:</p>

<pre><code>    $linerange = rx{ &lt;$linenum&gt; , &lt;$linenum&gt;
                   | &lt;$linenum&gt;
                   };
</code></pre>

<p>that&rsquo;s not possible, since the pattern matching mechanism won&rsquo;t know what&rsquo;s in <code>$linenum</code> until it actually tries to perform the match.</p>

<p>By the way, we <em>can</em> still use interpolated <code>&lt;$subrule&gt;</code>-ish subpatterns in a named rule, and we can use named subpatterns in an <code>rx</code>-ish rule. The difference between <code>rule</code> and <code>rx</code> is just that a <code>rule</code> can have a name and must use <code>{...}</code> as its delimiters, whereas an <code>rx</code> doesn&rsquo;t have a name and can use any allowed delimiters.</p>

<hr />

<h3 id="span-id-bad-line-no-match-bad-line-no-match-span"><span id="bad_line_no_match">Bad line! No match!</span></h3>

<p>This version of the diff parser has an additional rule, named <code>badline</code>. This rule illustrates another similarity between rules and subroutines/methods: rules can take arguments. The <code>badline</code> rule factors out the error message creation at the end of the <code>hunk</code> rule. Previously that rule ended with:</p>

<pre><code>    |  (\N*) ::: { fail &quot;Invalid diff hunk: $1&quot; }
</code></pre>

<p>but in this version it ends with:</p>

<pre><code>    |  &lt;badline(&quot;Invalid diff hunk&quot;)&gt;
</code></pre>

<p>That&rsquo;s a much better abstraction of the error condition. It&rsquo;s easier to understand and easier to maintain, but it does require us to be able to pass an argument (the error message) to the new <code>badline</code> subrule. To do that, we simply declare it to have a parameter list:</p>

<pre><code>    rule badline($errmsg) { (\N*) ::: { fail &quot;$errmsg: $1&quot; }
</code></pre>

<p>Note the strong syntactic parallel with a subroutine definition:</p>

<pre><code>    sub  subname($param)  { ... }
</code></pre>

<p>The argument is passed to a subrule by placing it in parentheses after the rule name within the angle brackets:</p>

<pre><code>    |  &lt;badline(&quot;Invalid diff hunk&quot;)&gt;
</code></pre>

<p>The argument can also be passed without the parentheses, but then it is interpreted as if it were the body of a separate rule:</p>

<pre><code>    rule list_of ($pattern) { 
            &lt;$pattern&gt; [ , &lt;$pattern&gt; ]*
    }

    # and later...

    $str =~ m:w/  \[                  # Literal opening square bracket
                  &lt;list_of \w\d+&gt;     # Call list_of subrule passing rule rx/\w\d+/
                  \]                  # Literal closing square bracket
               /;
</code></pre>

<p>A rule can take as many arguments as it needs to:</p>

<pre><code>    rule seplist($elem, $sep) {
            &lt;$elem&gt;  [ &lt;$sep&gt; &lt;$elem&gt; ]*
    }
</code></pre>

<p>and those arguments can also be passed by name, using the standard Perl 6 pair-based mechanism (as described in Apocalypse 3).</p>

<pre><code>    $str =~ m:w/
                \[                                      # literal left square bracket
                &lt;seplist(sep=&gt;&quot;:&quot;, elem=&gt;rx/&lt;ident&gt;/)&gt;  # colon-separated list of identifiers
                \]                                      # literal right square bracket
               /;
</code></pre>

<p>Note that the list&rsquo;s element specifier is itself an anonymous rule, which the <code>seplist</code> rule will subsequently interpolate as a pattern (because the <code>$elem</code> parameter appears in angle brackets within <code>seplist</code>).</p>

<hr />

<p><em>Editor&rsquo;s note: this document is out of date and remains here for historic interest. See <a href="http://dev.perl.org/perl6/doc/design/syn/S05.html">Synopsis 5</a> for the current design information.</em></p>

<h3 id="span-id-thinking-ahead-thinking-ahead-span"><span id="thinking_ahead">Thinking ahead</span></h3>

<p>The only other change in the grammar version of the diff parser is that the matching of the <code>'&lt;'</code> and <code>'&gt;'</code> at the start of the context lines has been factored out. Whereas before we had:</p>

<pre><code>    $deleteline = rx/^^ \&lt; &lt;sp&gt; (\N* \n) /
    $appendline = rx/^^ \&gt; &lt;sp&gt; (\N* \n) /
</code></pre>

<p>now we have:</p>

<pre><code>    rule deleteline { ^^ &lt;out_marker&gt; (\N* \n) }
    rule appendline { ^^ &lt;in_marker&gt;  (\N* \n) }

    rule out_marker { \&lt;  &lt;sp&gt; }
    rule in_marker  { \&gt;  &lt;sp&gt; }
</code></pre>

<p>That seems like a step backwards, since it complicated the grammar for no obvious benefit, but the benefit will be reaped <a href="#different%20diffs">later</a> when we discover another type of diff file that uses different markers for incoming and outgoing lines.</p>

<hr />

<h3 id="span-id-what-you-match-is-what-you-get-what-you-match-is-what-you-get-span"><span id="what_you_match_is_what_you_get">What you match is what you get</span></h3>

<p>Both the variable-based and grammatical versions of the code above do a great job of <em>recognizing</em> a diff, but that&rsquo;s all they do. If we only want syntax checking, that&rsquo;s fine. But, generally, if we&rsquo;re parsing data what we really want is to do something useful with it: transform it into some other syntax, make changes to its contents, or perhaps convert it to a Perl internal data structure for our program to manipulate.</p>

<p>Suppose we did want to build a hierarchical Perl data structure representing the diff that the above examples match. What extra code would we need?</p>

<p>None.</p>

<p>That&rsquo;s right. Whenever Perl 6 matches a pattern, it <em>automatically</em> builds a “result object” representing the various components of the match.</p>

<p>That result object is named <code>$0</code> (the program&rsquo;s name is now <code>$*PROG</code>) and it&rsquo;s lexical to the scope in which the match occurs. The result object stores (amongst other things) the complete string matched by the pattern, and it evaluates to that string when used in a string context. For example:</p>

<pre><code>    if ($text =~ /&lt;Diff.file&gt;/) {
        $difftext = $0;
    }
</code></pre>

<p>That&rsquo;s handy, but not really useful for extracting data structures. However, in addition, any components within a match that were captured using parentheses become elements of the object&rsquo;s array attribute, and are accessible through its array index operator. So, for example, when a pattern such as:</p>

<pre><code>    rule linenum_plus_comma { (\d+) (,?) };
</code></pre>

<p>matches successfully, the array element 1 of the result object (i.e. <code>$0[1]</code>) is assigned the result of the first parenthesized capture (i.e. the digits), whilst the array element 2 (<code>$0[2]</code>) receives the comma. Note that array element zero of any result object is assigned the complete string that the pattern matched.</p>

<p>There are also abbreviations for each of the array elements of <code>$0</code>. <code>$0[1]</code> can also be referred to as&hellip;surprise, surprise&hellip;<code>$1</code>, <code>$0[2]</code> can also be referred to as <code>$2</code>, <code>$0[3]</code> as <code>$3</code>, etc. Like <code>$0</code>, each of these numeric variables is also lexical to the scope in which the pattern match occurred.</p>

<p>The parts of a matched string that were matched by a named subrule become entries in the result object&rsquo;s hash attribute, and are subsequently accessible through its hash lookup operator. So, for example, when the pattern:</p>

<pre><code>    rule deleteline { ^^ &lt;out_marker&gt; (\N* \n) }
</code></pre>

<p>matches, the result object&rsquo;s hash entry for the key <code>'out_marker'</code> (i.e. <code>$0{out_marker}</code>) will contain the result object returned by the successful nested match of the <code>out_marker</code> subrule.</p>

<hr />

<h3 id="span-id-a-hypothetical-solution-to-a-very-real-problem-a-hypothetical-solution-to-a-very-real-problem-span"><span id="a_hypothetical_solution_to_a_very_real_problem">A hypothetical solution to a very real problem</span></h3>

<p>Named capturing into a hash is very convenient, but it doesn&rsquo;t work so well for a rule like:</p>

<pre><code>    rule linerange {
          &lt;linenum&gt; , &lt;linenum&gt;
        | &lt;linenum&gt;
    }
</code></pre>

<p>The problem is that the hash attribute of the rule&rsquo;s <code>$0</code> can only store one entry with the key <code>'linenum'</code>. So if the <code>&lt;linenum&gt; , &lt;linenum&gt;</code> alternative matches, then the result object from the second match of <code>&lt;linenum&gt;</code> will overwrite the entry for the first <code>&lt;linenum&gt;</code> match.</p>

<p>The solution to this is a new Perl 6 pattern matching feature known as “hypothetical variables”. A hypothetical variable is a variable that is declared and bound within a pattern match (i.e. inside a closure within a rule). The variable is declared, not with a <code>my</code>, <code>our</code>, or <code>temp</code>, but with the new keyword <code>let</code>, which was chosen because it&rsquo;s what mathematicians and other philosophers use to indicate a hypothetical assumption.</p>

<p>Once declared, a hypothetical variable is then bound using the normal binding operator. For example:</p>

<pre><code>    rule checked_integer {
            (\d+)                   # Match and capture one-or-more digits
            { let $digits := $1 }   # Bind to hypothetical var $digits
            -                       # Match a hyphen
            (\d)                    # Match and capture one digit
            { let $check := $2 }    # Bind to hypothetical var $check
    }
</code></pre>

<p>In this example, if a sequence of digits is found, then the <code>$digits</code> variable is bound to that substring. Then, if the dash and check-digit are matched, the digit is bound to <code>$check</code>. However, if the dash or digit is not matched, the match will fail and backtrack through the closure. This backtracking causes the <code>$digits</code> hypothetical variable to be automatically <em>un-bound</em>. Thus, if a rule fails to match, the hypothetical variables within it are not associated with any value.</p>

<p>Each hypothetical variable is really just another name for the corresponding entry in the result object&rsquo;s hash attribute. So binding a hypothetical variable like <code>$digits</code> within a rule actually sets the <code>$0{digits}</code> element of the rule&rsquo;s result object.</p>

<p>So, for example, to distinguish the two line numbers within a line range:</p>

<pre><code>    rule linerange {
          &lt;linenum&gt; , &lt;linenum&gt;
        | &lt;linenum&gt;
    }
</code></pre>

<p>we could bind them to two separate hypothetical variables &ndash; say, <code>$from</code> and <code>$to</code> &ndash; like so:</p>

<pre><code>    rule linerange {
          (&lt;linenum&gt;)               # Match linenum and capture result as $1
          { let $from := $1 }       # Save result as hypothetical variable
          ,                         # Match comma
          (&lt;linenum&gt;)               # Match linenum and capture result as $2
          { let $to := $2 }         # Save result as hypothetical variable
        |
          (&lt;linenum&gt;)               # Match linenum and capture result as $3
          { let $from := $3 }       # Save result as hypothetical variable
    }
</code></pre>

<p>Now our result object has a hash entry <code>$0{from}</code> and (maybe) one for <code>$0{to}</code> (if the first alternative was the one that matched). In fact, we could <em>ensure</em> that the result always has a <code>$0{to}</code>, by setting the corresponding hypothetical variable in the second alternative as well:</p>

<pre><code>    rule linerange {
          (&lt;linenum&gt;)
          { let $from := $1 }
          ,         
          (&lt;linenum&gt;)
          { let $to := $2 }
        |
          (&lt;linenum&gt;)
          { let $from := $3; let $to := $from }
    }
</code></pre>

<p>Problem solved.</p>

<p>But only by introducing a new problem. All that hypothesizing made our rule ugly and complex. So Perl 6 provides a much prettier short-hand:</p>

<pre><code>    rule linerange {
          $from := &lt;linenum&gt;          # Match linenum rule, bind result to $from
          ,                           # Match comma
          $to := &lt;linenum&gt;            # Match linenum rule, bind result to $to
        |                             # Or...
          $from := $to := &lt;linenum&gt;   # Match linenum rule,
    }                                 #   bind result to both $from and $to
</code></pre>

<p>or, more compactly:</p>

<pre><code>    rule linerange {
          $from:=&lt;linenum&gt; , $to:=&lt;linenum&gt;
        | $from:=$to:=&lt;linenum&gt;
    }
</code></pre>

<p>If a Perl 6 rule contains a variable that is immediately followed by the binding operator (<code>:=</code>), that variable is never interpolated. Instead, it is treated as a hypothetical variable, and bound to the result of the next component of the rule (in the above examples, to the result of the <code>&lt;linenum&gt;</code> subrule match).</p>

<p>You can also use hypothetical arrays and hashes, binding them to a component that captures repeatedly. For example, we might choose to name our set of hunks:</p>

<pre><code>    rule file { ^  @adonises := &lt;hunk&gt;*  $ }
</code></pre>

<p>collecting all the <code>&lt;hunk&gt;</code> matches into a single array (which would then be available after the match as <code>$0{'@adonises'}</code>. Note that the sigil is included in the key in this case).</p>

<p>Or we might choose to bind a hypothetical hash:</p>

<pre><code>    rule config {
        %init :=            # Hypothetically, bind %init to...
            [               # Start of group
                (&lt;ident&gt;)   # Match and capture an identifier
                \h*=\h*     # Match an equals sign with optional horizontal whitespace
                (\N*)       # Match and capture the rest of the line
                \n          # Match the newline
            ]*
    }
</code></pre>

<p>where each repetition of the <code>[...]*</code> grouping captures two substrings on each repetition and converts them to a key/value pair, which is then added to the hash. The first captured substring in each repetition becomes the key, and the second captured substring becomes its associated value. The hypothetical <code>%init</code> hash is also available through the rule&rsquo;s result object, as <code>$0{'%init'}</code> (again, with the sigil as part of the key).</p>

<hr />

<h3 id="span-id-the-nesting-instinct-the-nesting-instinct-span"><span id="the_nesting_instinct">The nesting instinct</span></h3>

<p>Of course, those line number submatches in:</p>

<pre><code>    rule linerange {
          $from:=&lt;linenum&gt; , $to:=&lt;linenum&gt;
        | $from:=$to:=&lt;linenum&gt;
    }
</code></pre>

<p>will have returned their own result objects. And it&rsquo;s a reference to those nested result objects that actually gets stored in <code>linerange</code>&rsquo;s <code>$0{from}</code> and <code>$0{to}</code>.</p>

<p>Likewise, in the next higher rule:</p>

<pre><code>    rule hunk :i { 
        [ &lt;linenum&gt; a :: &lt;linerange&gt; \n
          &lt;appendline&gt;+ 
        |
          &lt;linerange&gt; d :: &lt;linenum&gt; \n
          &lt;deleteline&gt;+
        |
          &lt;linerange&gt; c :: &lt;linerange&gt; \n
          &lt;deleteline&gt;+
          --- \n
          &lt;appendline&gt;+
        ]
    };
</code></pre>

<p>the match on <code>&lt;linerange&gt;</code> will return <em>its</em> <code>$0</code> object. So, within the <code>hunk</code> rule, we could access the “from” digits of the line range of the hunk as: <code>$0{linerange}{from}</code>.</p>

<p>Likewise, at the highest level:</p>

<pre><code>    rule file { ^  &lt;hunk&gt;*  $ }
</code></pre>

<p>we are matching a series of hunks, so the hypothetical <code>$hunk</code> variable (and hence <code>$0{hunk}</code>) will contain a result object whose array attribute contains the series of result objects returned by each individual <code>&lt;hunk&gt;</code> match.</p>

<p>So, for example, we could access the “from” digits of the line range of the third hunk as: <code>$0{hunk}[2]{linerange}{from}</code>.</p>

<hr />

<h3 id="span-id-extracting-the-insertions-extracting-the-insertions-span"><span id="extracting_the_insertions">Extracting the insertions</span></h3>

<p>More usefully, we could locate and print every line in the diff that was being inserted, regardless of whether it was inserted by an “append” or a “change” hunk. Like so:</p>

<pre><code>    my $text is from($*ARGS);

    if $text =~ /&lt;Diff.file&gt;/ {
        for @{ $0{file}{hunk} } -&gt; $hunk
             print @{$hunk{appendline}}
                 if $hunk{appendline};
        }
    }
</code></pre>

<p>Here, the <code>if</code> statement attempts to match the text against the pattern for a diff file. If it succeeds, the <code>for</code> loop grabs the <code>&lt;hunk&gt;*</code> result object, treats it as an array, and then iterates each hunk match object in turn into <code>$hunk</code>. The array of append lines for each hunk match is then printed (if there is in fact a reference to that array in the hunk).</p>

<hr />

<h3 id="span-id-dont-just-match-there-do-something-don-t-just-match-there-do-something-span"><span id="dont_just_match_there_do_something">Don&rsquo;t just match there; do something!</span></h3>

<p>Because Perl 6 patterns can have arbitrary code blocks inside them, it&rsquo;s easy to have a pattern actually perform syntax transformations whilst it&rsquo;s parsing. That&rsquo;s often a useful technique because it allows us to manipulate the various parts of a hierarchical representation locally (within the rules that recognize them).</p>

<p>For example, suppose we wanted to “reverse” the diff file. That is, suppose we had a diff that specified the changes required to transform file A to file B, but we needed the back-transformation instead: from file B to file A. That&rsquo;s relatively easy to create. We just turn every “append” into a “delete”, every “delete” into an “append”, and reverse every “change”.</p>

<p>The following code does exactly that:</p>

<pre><code>    grammar ReverseDiff {
        rule file { ^  &lt;hunk&gt;*  $ }

        rule hunk :i { 
            [ &lt;linenum&gt; a :: &lt;linerange&gt; \n
              &lt;appendline&gt;+ 
              { @$appendline =~ s/&lt;in_marker&gt;/&lt; /;
                let $0 := &quot;${linerange}d${linenum}\n&quot;
                        _ join &quot;&quot;, @$appendline;
              }
            |
              &lt;linerange&gt; d :: &lt;linenum&gt; \n
              &lt;deleteline&gt;+
              { @$deleteline =~ s/&lt;out_marker&gt;/&gt; /;
                let $0 := &quot;${linenum}a${linerange}\n&quot;
                        _ join &quot;&quot;, @$deleteline;
              }
            |
              $from:=&lt;linerange&gt; c :: $to:=&lt;linerange&gt; \n
              &lt;deleteline&gt;+
              --- \n
              &lt;appendline&gt;+
              { @$appendline =~ s/&lt;in_marker&gt;/&lt;/;
                @$deleteline =~ s/&lt;out_marker&gt;/&gt;/;
                let $0 := &quot;${to}c${from}\n&quot;
                        _ join(&quot;&quot;, @$appendline)
                        _ &quot;---\n&quot;
                        _ join(&quot;&quot;, @$deleteline);
              }
            ]
          |
            &lt;badline(&quot;Invalid diff hunk&quot;)&gt;
        }

    rule badline ($errmsg) { (\N*) ::: { fail &quot;$errmsg: $1&quot; } }

    rule linerange { $from:=&lt;linenum&gt; , $to:=&lt;linenum&gt;
                       | $from:=$to:=&lt;linenum&gt;
                       }

    rule linenum { (\d+) }

    rule deleteline { ^^ &lt;out_marker&gt; (\N* \n) }
        rule appendline { ^^ &lt;in_marker&gt;  (\N* \n) }

    rule out_marker { \&lt;  &lt;sp&gt; }
        rule in_marker  { \&gt;  &lt;sp&gt; }
    }

    # and later...

    my $text is from($*ARGS);

    print @{ $0{file}{hunk} }
        if $text =~ /&lt;Diff.file&gt;/;
</code></pre>

<p>The rule definitions for <code>file</code>, <code>badline</code>, <code>linerange</code>, <code>linenum</code>, <code>appendline</code>, <code>deleteline</code>, <code>in_marker</code> and <code>out_marker</code> are exactly the same as before.</p>

<p>All the work of reversing the diff is performed in the <code>hunk</code> rule. To do that work, we have to extend each of the three main alternatives of that rule, adding to each a closure that changes the result object it returns.</p>

<hr />

<h3 id="span-id-smarter-alternatives-smarter-alternatives-span"><span id="smarter_alternatives">Smarter alternatives</span></h3>

<p>In the first alternative (which matches “append” hunks), we match as before:</p>

<pre><code>    &lt;linenum&gt; a :: &lt;linerange&gt; \n
    &lt;appendline&gt;+
</code></pre>

<p>But then we execute an embedded closure:</p>

<pre><code>    { @$appendline =~ s/&lt;in_marker&gt;/&lt;/;
      let $0 := &quot;${linerange}d${linenum}\n&quot;
              _ join &quot;&quot;, @$appendline;
    }
</code></pre>

<p>The first line reverses the “marker” arrows on each line of data that was previously being appended, using the smart-match operator to apply the transformation to each line. Note too, that we reuse the <code>in_marker</code> rule within the substitution.</p>

<p>Then we bind the result object (i.e. the hypothetical variable <code>$0</code>) to a string representing the “reversed” append hunk. That is, we reverse the order of the line range and line number components, put a <code>'d'</code> (for “delete”) between them, and then follow that with all the reversed data:</p>

<pre><code>    let $0 := &quot;${linerange}d${linenum}\n&quot;
            _ join &quot;&quot;, @$appendline;
</code></pre>

<p>The changes to the “delete” alternative are exactly symmetrical. Capture the components as before, reverse the marker arrows, reverse the <code>$linerange</code> and <code>$linenum</code>, change the <code>'d'</code> to an <code>'a'</code>, and append the reversed data lines.</p>

<p>In the third alternative:</p>

<pre><code>    $from:=&lt;linerange&gt; c :: $to:=&lt;linerange&gt; \n
    &lt;deleteline&gt;+   
    --- \n
    &lt;appendline&gt;+
    { @$appendline =~ s/&lt;in_marker&gt;/&lt;/;
      @$deleteline =~ s/&lt;out_marker&gt;/&gt;/;
      let $0 := &quot;${to}c${from}\n&quot;
              _ join(&quot;&quot;, @$appendline)
              _ &quot;---\n&quot;
              _ join(&quot;&quot;, @$deleteline);
    }
</code></pre>

<p>there are line ranges on both sides of the <code>'c'</code>. So we need to give them distinct names, by binding them to extra hypothetical variables: <code>$from</code> and <code>$to</code>. We then reverse the order of two line ranges, but leave the <code>'c'</code> as it was (because we&rsquo;re simply changing something back to how it was previously). The markers on both the append and delete lines are reversed, and then the order of the two sets of lines is also reversed.</p>

<p>Once those transformations has been performed on each hunk (i.e. as it&rsquo;s being matched!), the result of successfully matching any <code>&lt;hunk&gt;</code> subrule will be a string in which the matched hunk has already been reversed.</p>

<p>All that remains is to match the text against the grammar, and print out the (modified) hunks:</p>

<pre><code>    print @{ $0{file}{hunk} }
        if $text =~ /&lt;ReverseDiff.file&gt;/;
</code></pre>

<p>And, since the <code>file</code> rule is now in the ReverseDiff grammar&rsquo;s namespace, we need to call the rule through that grammar. Note the way the syntax for doing that continues the parallel with methods and classes.</p>

<hr />

<p><em>Editor&rsquo;s note: this document is out of date and remains here for historic interest. See <a href="http://dev.perl.org/perl6/doc/design/syn/S05.html">Synopsis 5</a> for the current design information.</em></p>

<h3 id="span-id-rearranging-the-deckchairs-rearranging-the-deck-chairs-span"><span id="rearranging_the_deckchairs">Rearranging the deck-chairs</span></h3>

<p>It might have come as a surprise that we were allowed to bind the pattern&rsquo;s <code>$0</code> result object directly, but there&rsquo;s nothing magical about it. <code>$0</code> turns out to be just another hypothetical variable&hellip;the one that happens to be returned when the match is complete.</p>

<p>Likewise, <code>$1</code>, <code>$2</code>, <code>$3</code>, etc. are all hypotheticals, and can also be explicitly bound in a rule. That&rsquo;s very handy for ensuring that the right substring always turns up in the right numbered variable. For example, consider a Perl 6 rule to match simple Perl 5 method calls (matching <em>all</em> Perl 5 method calls would, of course, require a much more sophisticated rule):</p>

<pre><code>    rule method_call :w {
        # Match direct syntax:   $var-&gt;meth(...)
        \$  (&lt;ident&gt;)  -\&gt;  (&lt;ident&gt;)  \(  (&lt;arglist&gt;)  \)

      | # Match indirect syntax: meth $var (...)
        (&lt;ident&gt;)  \$  (&lt;ident&gt;)  [ \( (&lt;arglist&gt;) \) | (&lt;arglist&gt;) ]
    }

    my ($varname, methodname, $arglist);

    if ($source_code =~ / $0 := &lt;method_call&gt; /) {
        $varname    = $1 // $5;
        $methodname = $2 // $4;
        $arglist    = $3 // $6 // $7;
    }
</code></pre>

<p>By binding the match&rsquo;s <code>$0</code> to the result of the <code>&lt;method_call&gt;</code> subrule, we bind its <code>$0[1]</code>, <code>$0[2]</code>, <code>$0[3]</code>, etc. to those array elements in <code>&lt;method_call&gt;</code>&rsquo;s result object. And thereby bind <code>$1</code>, <code>$2</code>, <code>$3</code>, etc. as well. Then it&rsquo;s just a matter of sorting out which numeric variable ended up with which bit of the method call.</p>

<p>That&rsquo;s okay, but it would be much better if we could guarantee that the variable name was always in <code>$1</code>, the method name in <code>$2</code>, and the argument list in <code>$3</code>. Then we could replace the last six lines above with just:</p>

<pre><code>    my ($varname, methodname, $arglist) =
            $source_code =~ / $0 := &lt;method_call&gt; /;
</code></pre>

<p>In Perl 5 there was no way to do that, but in Perl 6 it&rsquo;s relatively easy. We just modify the <code>method_call</code> rule like so:</p>

<pre><code>    rule method_call :w {
        \$  $1:=&lt;ident&gt;  -\&gt;  $2:=&lt;ident&gt;  \( $3:=&lt;arglist&gt; \)
      | $2:=&lt;ident&gt;  \$  $1:=&lt;ident&gt;  [ \( $3:=&lt;arglist&gt; \) | $3:=&lt;arglist&gt; ]
    }
</code></pre>

<p>Or, annotated:</p>

<pre><code>    rule method_call :w {
        \$                          #   Match a literal $
        $1:=&lt;ident&gt;                 #   Match the varname, bind it to $1
        -\&gt;                         #   Match a literal -&gt;
        $2:=&lt;ident&gt;                 #   Match the method name, bind it to $2
        \(                          #   Match an opening paren
        $3:=&lt;arglist&gt;               #   Match the arg list, bind it to $3
        \)                          #   Match a closing paren
      |                             # Or
        $2:=&lt;ident&gt;                 #   Match the method name, bind it to $2
        \$                          #   Match a literal $
        $1:=&lt;ident&gt;                 #   Match the varname, bind it to $1
        [                           #   Either...
          \( $3:=&lt;arglist&gt; \)       #     Match arg list in parens, bind it to $3
        |                           #   Or...
             $3:=&lt;arglist&gt;          #     Just match arg list, bind it to $3
        ]
    }
</code></pre>

<p>Now the rule&rsquo;s <code>$1</code> is bound to the variable name, regardless of which alternative matches. Likewise <code>$2</code> is bound to the method name in either branch of the <code>|</code>, and <code>$3</code> is associated with the argument list, no matter which of the <em>three</em> possible ways it was matched.</p>

<p>Of course, that&rsquo;s still rather ugly (especially if we have to write all those comments just so others can understand how clever we were).</p>

<p>So an even better solution is just to use proper named rules (with their handy auto-capturing behaviour) for everything. And then slice the required information out of the result object&rsquo;s hash attribute:</p>

<pre><code>    rule varname    { &lt;ident&gt; }
    rule methodname { &lt;ident&gt; }

    rule method_call :w {
        \$  &lt;varname&gt;  -\&gt;  &lt;methodname&gt;  \( &lt;arglist&gt; \)
      | &lt;methodname&gt;  \$  &lt;varname&gt;  [ \( &lt;arglist&gt; \) | &lt;arglist&gt; ]
    }

    $source_code =~ / &lt;method_call&gt; /;

    my ($varname, $methodname, $arglist) =
            $0{method_call}{&quot;varname&quot;,&quot;methodname&quot;,&quot;arglist&quot;}
</code></pre>

<hr />

<h3 id="span-id-deriving-a-benefit-deriving-a-benefit-span"><span id="deriving_a_benefit">Deriving a benefit</span></h3>

<p>As the above examples illustrate, using named rules in grammars provides a cleaner syntax and a reduction in the number of variables required in a parsing program. But, beyond those advantages, and the obvious benefits of moving rule construction from run-time to compile-time, there&rsquo;s yet another significant way to gain from placing named rules inside a grammar: we can <em>inherit</em> from them.</p>

<p>For example, the ReverseDiff grammar is almost the same as the normal Diff grammar. The only difference is in the <code>hunk</code> rule. So there&rsquo;s no reason why we shouldn&rsquo;t just have ReverseDiff inherit all that sameness, and simply redefine its notion of <code>hunk</code>-iness. That would look like this:</p>

<pre><code>    grammar ReverseDiff is Diff {

        rule hunk :i { 
            [ &lt;linenum&gt; a :: &lt;linerange&gt; \n
              &lt;appendline&gt;+ 
              { $appendline =~ s/ &lt;in_marker&gt; /&lt;/;
                let $0 := &quot;${linerange}d${linenum}\n&quot;
                        _ join &quot;&quot;, @$appendline;
              }
            |
              &lt;linerange&gt; d :: &lt;linenum&gt; \n
              &lt;deleteline&gt;+
              { $deleteline =~ s/ &lt;out_marker&gt; /&gt;/;
                let $0 := &quot;${linenum}a${linerange}\n&quot;
                        _ join &quot;&quot;, @$deleteline;
              }
            |
              $from:=&lt;linerange&gt; c :: $to:=&lt;linerange&gt; \n
              &lt;deleteline&gt;+
              --- \n
              &lt;appendline&gt;+
              { $appendline =~ s/ &lt;in_marker&gt; /&lt;/;
                $deleteline =~ s/ &lt;out_marker&gt; /&gt;/;
                let $0 := &quot;${to}c${from}\n&quot;
                        _ join(&quot;&quot;, @$appendline)
                        _ &quot;---\n&quot;
                        _ join(&quot;&quot;, @$deleteline);
              }
            ]
          |
            &lt;badline(&quot;Invalid diff hunk&quot;)&gt;
        }
    }
</code></pre>

<p>The <code>ReverseDiff is Diff</code> syntax is the standard Perl 6 way of inheriting behaviour. Classes will use the same notation:</p>

<pre><code>    class Hacker is Programmer {...}
    class JAPH is Hacker {...}
    # etc.
</code></pre>

<p>Likewise, in the above example Diff is specified as the base grammar from which the new ReverseDiff grammar is derived. As a result of that inheritance relationship, ReverseDiff immediately inherits all of the Diff grammar&rsquo;s rules. We then simple redefine ReverseDiff&rsquo;s version of the <code>hunk</code> rule, and the job&rsquo;s done.</p>

<hr />

<h3 id="span-id-different-diffs-different-diffs-span"><span id="different_diffs">Different diffs</span></h3>

<p>Grammatical inheritance isn&rsquo;t only useful for tweaking the behaviour of a grammar&rsquo;s rules. It&rsquo;s also handy when two or more related grammars share some characteristics, but differ in some particulars. For example, suppose we wanted to support the “unified” diff format, as well as the “classic”.</p>

<p>A unified diff consists of two lines of header information, followed by a series of hunks. The header information indicates the name and modification date of the old file (prefixing the line with three minus signs), and then the name and modification date of the new file (prefixing that line with three plus signs). Each hunk consists of an offset line, followed by one or more lines representing either shared context, or a line to be inserted, or a line to be deleted. Offset lines start with two “at” signs, then consist of a minus sign followed by the old line offset and line-count, and then a plus sign followed by the nes line offset and line-count, and then two more “at” signs. Context lines are prefixed with two spaces. Insertion lines are prefixed with a plus sign and a space. Deletion lines are prefixed with a minus sign and a space.</p>

<p>But that&rsquo;s not important right now.</p>

<p>What <em>is</em> important is that we could write another complete grammar for that, like so:</p>

<pre><code>    grammar Diff::Unified {

        rule file { ^  &lt;fileinfo&gt;  &lt;hunk&gt;*  $ }

        rule fileinfo {
            &lt;out_marker&gt;&lt;3&gt; $oldfile:=(\S+) $olddate:=[\h* (\N+?) \h*?] \n
            &lt;in_marker&gt;&lt;3&gt;  $newfile:=(\S+) $newdate:=[\h* (\N+?) \h*?] \n
        }

        rule hunk { 
            &lt;header&gt;
            @spec := ( &lt;contextline&gt;
                     | &lt;appendline&gt;
                     | &lt;deleteline&gt;
                     | &lt;badline(&quot;Invalid line for unified diff&quot;)&gt;
                     )*
        }

        rule header {
            \@\@ &lt;out_marker&gt; &lt;linenum&gt; , &lt;linecount&gt; \h+
                 &lt;in_marker&gt;  &lt;linenum&gt; , &lt;linecount&gt; \h+
            \@\@ \h* \n
        }

        rule badline ($errmsg) { (\N*) ::: { fail &quot;$errmsg: $1&quot; } }

        rule linenum   { (\d+) }
        rule linecount { (\d+) }

        rule deleteline  { ^^ &lt;out_marker&gt; (\N* \n) }
        rule appendline  { ^^ &lt;in_marker&gt;  (\N* \n) }
        rule contextline { ^^ &lt;sp&gt; &lt;sp&gt;    (\N* \n) }

        rule out_marker { \+ &lt;sp&gt; }
        rule in_marker  {  - &lt;sp&gt; }
    }
</code></pre>

<p>That represents (and can parse) the new diff format correctly, but it&rsquo;s a needless duplication of effort and code. Many the rules of this grammar are identical to those of the original diff parser. Which suggests we could just grab them straight from the original &ndash; by inheriting them:</p>

<pre><code>    grammar Diff::Unified is Diff  {

        rule file { ^  &lt;fileinfo&gt;  &lt;hunk&gt;*  $ }

        rule fileinfo {
            &lt;out_marker&gt;&lt;3&gt; $newfile:=(\S+) $olddate:=[\h* (\N+?) \h*?] \n
            &lt;in_marker&gt;&lt;3&gt;  $newfile:=(\S+) $newdate:=[\h* (\N+?) \h*?] \n
        }

        rule hunk { 
            &lt;header&gt;
            @spec := ( &lt;contextline&gt;
                     | &lt;appendline&gt;
                     | &lt;deleteline&gt;
                     | &lt;badline(&quot;Invalid line for unified diff&quot;)&gt;
                     )*
        }

        rule header {
            \@\@ &lt;out_marker&gt; &lt;linenum&gt; , &lt;linecount&gt; \h+
                 &lt;in_marker&gt;  &lt;linenum&gt; , &lt;linecount&gt; \h+
            \@\@ \h* \n
        }

        rule linecount { (\d+) }

        rule contextline { ^^ &lt;sp&gt; &lt;sp&gt;  (\N* \n) }

        rule out_marker { \+ &lt;sp&gt; }
        rule in_marker  {  - &lt;sp&gt; }
    }
</code></pre>

<p>Note that in this version we don&rsquo;t need to specify the rules for <code>appendline</code>, <code>deleteline</code>, <code>linenum</code>, etc. They&rsquo;re provided automagically by inheriting from the <code>Diff</code> grammar. So we only have to specify the parts of the new grammar that differ from the original.</p>

<p>In particular, this is where we finally reap the reward for factoring out the <code>in_marker</code> and <code>out_marker</code> rules. Because we did that earlier, we can now just change the rules for matching those two markers directly in the new grammar. As a result, the inherited <code>appendline</code> and <code>deleteline</code> rules (which use <code>in_marker</code> and <code>out_marker</code> as subrules) will now attempt to match the new versions of <code>in_marker</code> and <code>out_marker</code> rules instead.</p>

<p>And if you&rsquo;re thinking that looks suspiciously like polymorphism, you&rsquo;re absolutely right. The parallels between pattern matching and OO run <em>very</em> deep in Perl 6.</p>

<hr />

<h3 id="span-id-lets-get-cooking-let-s-get-cooking-span"><span id="lets_get_cooking">Let&rsquo;s get cooking</span></h3>

<p>To sum up: Perl 6 patterns and grammars extend Perl&rsquo;s text matching capacities enormously. But you don&rsquo;t have to start using all that extra power right away. You can ignore grammars and embedded closures and assertions and the other sophisticated bits until you actually need them.</p>

<p>The new rule syntax also cleans up much of the “line-noise” of Perl 5 regexes. But the fundamentals don&rsquo;t change that much. Many Perl 5 patterns will translate very simply and naturally to Perl 6.</p>

<p>To demonstrate that, and to round out this exploration of Perl 6 patterns, here are a few common Perl 5 regexes &ndash; some borrowed from the <em>Perl Cookbook</em>, and others from the Regexp::Common module &ndash; all ported to equivalent Perl 6 rules:</p>

<p><strong><span id="item_Match_a_C_comment%3A">Match a C comment:</span></strong></p>

<pre><code># Perl 5
$str =~ m{ /\* .*? \*/ }xs;

# Perl 6
$str =~ m{ /\* .*? \*/ };
</code></pre>

<p><strong><span id="item_Remove_leading_qualifiers_from_a_Perl_identifier">Remove leading qualifiers from a Perl identifier</span></strong></p>

<pre><code># Perl 5
$ident =~ s/^(?:\w*::)*//;

# Perl 6
$ident =~ s/^[\w*\:\:]*//;
</code></pre>

<p><strong><span id="item_Warn_of_text_with_lines_greater_than_80_characters">Warn of text with lines greater than 80 characters</span></strong></p>

<pre><code># Perl 5
warn &quot;Thar she blows!: $&amp;&quot;
        if $str =~ m/.{81,}/;

# Perl 6
warn &quot;Thar she blows!: $0&quot;
        if $str =~ m/\N&lt;81,&gt;/;
</code></pre>

<p><strong><span id="item_Match_a_Roman_numeral">Match a Roman numeral</span></strong></p>

<pre><code># Perl 5
$str =~ m/ ^ m* (?:d?c{0,3}|c[dm]) (?:l?x{0,3}|x[lc]) (?:v?i{0,3}|i[vx]) $ /ix;

# Perl 6
$str =~ m:i/ ^ m* [d?c&lt;0,3&gt;|c&lt;[dm]&gt;] [l?x&lt;0,3&gt;|x&lt;[lc]&gt;] [v?i&lt;0,3&gt;|i&lt;[vx]&gt;] $ /;
</code></pre>

<p><strong><span id="item_Extract_lines_regardless_of_line_terminator">Extract lines regardless of line terminator</span></strong></p>

<pre><code># Perl 5
push @lines, $1
        while $str =~ m/\G([^\012\015]*)(?:\012\015?|\015\012?)/gc;

# Perl 6
push @lines, $1
        while $str =~ m:c/ (\N*) \n /;
</code></pre>

<p><strong><span id="item_string">Match a quote-delimited string (Friedl-style), capturing contents:</span></strong></p>

<pre><code># Perl 5
$str =~ m/ &quot; ( [^\\&quot;]* (?: \\. [^\\&quot;]* )* ) &quot; /x;

# Perl 6
$str =~ m/ &quot; ( &lt;-[\\&quot;]&gt;* [ \\. &lt;-[\\&quot;]&gt;* ]* ) &quot; /;
</code></pre>

<p><strong><span id="item_Match_a_decimal_IPv4_address%3A">Match a decimal IPv4 address:</span></strong></p>

<pre><code># Perl 5
my $quad = qr/(?: 25[0-5] | 2[0-4]\d | [0-1]??\d{1,2} )/x;

$str =~ m/ $quad \. $quad \. $quad \. $quad /x;

# Perl 6
rule quad {  (\d&lt;1,3&gt;) :: { fail unless $1 &lt; 256 }  }

$str =~ m/ &lt;quad&gt; &lt;dot&gt; &lt;quad&gt; &lt;dot&gt; &lt;quad&gt; &lt;dot&gt; &lt;quad&gt; /x;

# Perl 6 (same great approach, now less syntax)
rule quad {  (\d&lt;1,3&gt;) :: &lt;($1 &lt; 256)&gt;  }

$str =~ m/ &lt;quad&gt; &lt;dot&gt; &lt;quad&gt; &lt;dot&gt; &lt;quad&gt; &lt;dot&gt; &lt;quad&gt; /x;
</code></pre>

<p><strong><span id="item_Match_a_floating%2Dpoint_number%2C_returning_compo">Match a floating-point number, returning components:</span></strong></p>

<pre><code># Perl 5
($sign, $mantissa, $exponent) =
        $str =~ m/([+-]?)([0-9]+\.?[0-9]*|\.[0-9]+)(?:e([+-]?[0-9]+))?/;

# Perl 6
($sign, $mantissa, $exponent) =
        $str =~ m/(&lt;[+-]&gt;?)(&lt;[0-9]&gt;+\.?&lt;[0-9]&gt;*|\.&lt;[0-9]&gt;+)[e(&lt;[+-]&gt;?&lt;[0-9]&gt;+)]?/;
</code></pre>

<p><strong><span id="item_Match_a_floating%2Dpoint_number_maintainably%2C_re">Match a floating-point number <em>maintainably</em>, returning components:</span></strong></p>

<pre><code># Perl 5
my $digit    = qr/[0-9]/;
my $sign_pat = qr/(?: [+-]? )/x;
my $mant_pat = qr/(?: $digit+ \.? $digit* | \. digit+ )/x;
my $expo_pat = qr/(?: $signpat $digit+ )? /x;

($sign, $mantissa, $exponent) =
        $str =~ m/ ($sign_pat) ($mant_pat) (?: e ($expo_pat) )? /x;

# Perl 6
rule sign     { &lt;[+-]&gt;? }
rule mantissa { &lt;digit&gt;+ [\. &lt;digit&gt;*] | \. &lt;digit&gt;+ }
rule exponent { [ &lt;sign&gt; &lt;digit&gt;+ ]? }

($sign, $mantissa, $exponent) = 
        $str =~ m/ (&lt;sign&gt;) (&lt;mantissa&gt;) [e (&lt;exponent&gt;)]? /;
</code></pre>

<p><strong><span id="item_Match_nested_parentheses%3A">Match nested parentheses:</span></strong></p>

<pre><code># Perl 5
our $parens = qr/ \(  (?: (?&gt;[^()]+) | (??{$parens}) )*  \) /x;
$str =~ m/$parens/;

# Perl 6
$str =~ m/ \(  [ &lt;-[()]&gt; + : | &lt;self&gt; ]*  \) /;
</code></pre>

<p><strong><span id="item_Match_nested_parentheses_maintainably%3A">Match nested parentheses <em>maintainably</em>:</span></strong></p>

<pre><code># Perl 5
our $parens = qr/
           \(                   # Match a literal '('
           (?:                  # Start a non-capturing group
               (?&gt;              #     Never backtrack through...
                   [^()] +      #         Match a non-paren (repeatedly)
               )                #     End of non-backtracking region
           |                    # Or
               (??{$parens})    #    Recursively match entire pattern
           )*                   # Close group and match repeatedly
           \)                   # Match a literal ')'
         /x;

$str =~ m/$parens/;

# Perl 6
$str =~ m/ &lt;'('&gt;                # Match a literal '('
           [                    # Start a non-capturing group
                &lt;-[()]&gt; +       #    Match a non-paren (repeatedly)
                :               #    ...and never backtrack that match
           |                    # Or
                &lt;self&gt;          #    Recursively match entire pattern
           ]*                   # Close group and match repeatedly
           &lt;')'&gt;                # Match a literal ')'
         /;
</code></pre>

<hr />

<p>Return to the <a href="/">Perl.com</a>.</p>

              </article>
              <p><strong>Tags</strong></p>
              <div class="tags">
                <div class="category"><a href="/categories/perl-6">perl-6</a></div>
                
                  <div class="tag"><a href="/tags/apocalypse-exegesis-regular-expressions">apocalypse-exegesis-regular-expressions</a></div>
                
              </div>
            </div>
            
              
                
<div class="row" id="author-bio-damian-conway">
  <div class="col-sm-2">
    
    <a href="/authors/damian-conway/"><div class="circle-avatar" style="background-image:url(/images/author/damian-conway.jpg)"></div></a>
  </div>
  <div class="col-sm-10">
    <a href="/authors/damian-conway/"><h3>Damian Conway</h3></a>
    <p></p>
    <h5><a href="/authors/damian-conway/">Browse their articles</a></h5>
  </div>
</div>

            
            <div class="row">
              <h3>Feedback</h3>
              <p>Something wrong with this article? Help us out by opening an issue or pull request on <a href="https://github.com/tpf/perldotcom/blob/master/content/legacy/_pub_2002_08_22_exegesis5.md">GitHub</a></p>
            </div>
          </div>
          <div class="col-md-3">
            <div class="latest-sidebar">

  <div class="row">
    <div class="col-sm-12 centering">
      <span style="font-size:1.8em" class="antonio txt-blue-major">OUR LATEST ARTICLES</span>
    </div>
  </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/the-perl-admbassador-curtis-poe/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/the-perl-ambassador-curtis-poe/curtis-poe.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>The Perl Ambassador: Curtis &#39;Ovid&#39; Poe</h6>
          <p style="line-height:1"><small>The person behind the news of Perl</small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/a-tour-with-net-ftp/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/a-tour-with-net-ftp/thumb_kidyes.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>A tour with Net::FTP</h6>
          <p style="line-height:1"><small>How to write an FTP client in Perl</small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/shortcode_test/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/author/brian-d-foy.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>shortcode_test</h6>
          <p style="line-height:1"><small></small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/listen-to-larry-wall-s-state-of-the-onion-2000-on-youtube/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/listen-to-larry-wall-s-state-of-the-onion-2000-on-youtube/thumb_larry-wall.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>Listen to Larry Wall&#39;s State of the Onion 2000 on YouTube</h6>
          <p style="line-height:1"><small></small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/announcing-perl-7/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/announcing-perl-7/thumb_seven_on_blue_wall.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>Announcing Perl 7</h6>
          <p style="line-height:1"><small>Perl 5 with modern defaults</small></p>
      </div>
        </a>
    </div>
  
</div>
<div class="row" style="margin-top:20px">
  <div class="col-sm-12 centering">
  <script async src="/widget/toplinks/toplinks.js" type="text/javascript"></script>
    <div id="toplinks"></div>
  </div>
</div>

<div class="row" style="margin-top:20px">
  <div class="col-sm-12 centering">
    <a class="twitter-timeline" data-height="640" data-dnt="true" data-theme="dark" href="https://twitter.com/perlfoundation?ref_src=twsrc%5Etfw">Tweets by perlfoundation</a> <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
  </div>
</div>

<div class="row" style="margin-top:20px">
  <div class="col-sm-12 centering">
    <script src="https://www.reddit.com/r/perl/hot/.embed?limit=10&t=all" type="text/javascript"></script>
  </div>
</div>



          </div>
        </div>
      </div>
    </section>
  </section>
<script>
 
var tables, i;
tables = document.getElementsByTagName('table');
for (i=0;i<tables.length;i++) {
  tables[i].className = 'table table-striped';
}
</script>
<div class="push"></div>
<div class="footer">
  <div class="container">
    <div class="row">
      <div class="col-md-1">
        <h5>Site Map</h5>
        <ul>
        <li><a href="/">Home</a></li>
        <hr>
        <li><a href="/about">About</a></li>
        <hr>
        <li><a href="/authors">Authors</a></li>
        <hr>
        <li><a href="/categories">Categories</a></li>
        <hr>
        <li><a href="/tags">Tags</a></li>
        <hr>
        </ul>
      </div>
      <div class="col-md-3">
        <h5>Contact Us</h5>
        <p>To get in touch, send an email to: perl.com-editor@perl.org</p>
        <p><a href="https://perl.org">
              <img src="/images/site/perl-onion_20.png" alt="Perl Onion"></a>
          <a href="https://twitter.com/intent/follow?screen_name=perlfoundation">
              <img src="/images/site/twitter_20.png" alt="twitter"></a>
          <a href="/index.xml" /><img src="/images/site/rss_20.png" alt="rss"></a>
          <a href="https://github.com/tpf/perldotcom">
              <img src="/images/site/github_light_20.png" alt="GitHub logo"></a></p>
      </div>
      <div class="col-md-2">
          <h5>License</h5>
          <p>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc/3.0/">Creative Commons Attribution-NonCommercial 3.0 Unported License</a>.</p>
          <p><a rel="license" href="https://creativecommons.org/licenses/by-nc/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/3.0/88x31.png" /></a></p>
      </div>
      <div class="col-md-5">
          <h5>Legal</h5>
          <p>Perl.com and the authors make no representations with respect to the accuracy or completeness of the contents of all work on this website and specifically disclaim all warranties, including without limitation warranties of fitness for a particular purpose. The information published on this website may not be suitable for every situation. All work on this website is provided with the understanding that Perl.com and the authors are not engaged in rendering professional services. Neither Perl.com nor the authors shall be liable for damages arising herefrom.</p>
      </div>
    </div>
  </div>
</div>
<script src="/javascript/jquery.min.js"></script>
<script src="/javascript/bootstrap.min.js"></script>
<script data-no-instant>document.write('<script src="/livereload.js?port=1313&mindelay=10"></' + 'script>')</script></body>
</html>

