<!DOCTYPE html>
<html lang="en-us">
  <head>
  <title> Building a 3D Engine in Perl, Part 3 </title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content=" This article is the third in a series aimed at building a full 3D engine in Perl. The first article started with basic program structure and worked up to displaying a simple depth-buffered scene in an OpenGL window. The..."/>
  <meta name="robots" content="index, follow">
  <meta name="google-site-verification" content="TZowffo_LX2mmsw2DbeNNbukCMnIOA8T-6CMJPiYllI" />

<meta property="twitter:card" content="summary">
<meta property="twitter:site" content="@PerlFoundation">
<meta property="og:url" content="http://localhost:1313/pub/2005/02/17/3d_engine.html/" />
<meta property="og:title" content="Building a 3D Engine in Perl, Part 3" />
<meta property="og:description" content=" This article is the third in a series aimed at building a full 3D engine in Perl. The first article started with basic program structure and worked up to displaying a simple depth-buffered scene in an OpenGL window. The...">
<meta property="og:site_name" content="Perl.com" />

<meta property="og:type" content="article" />
<meta property="og:article:published_time" content="2005-02-02T02:02:02Z" />
<meta property="og:image" content="http://localhost:1313/images/site/avatar.png" />
<meta property="og:article:tag" content="opengl-lighting" />
<meta property="og:article:tag" content="opengl-tutorial" />
<meta property="og:article:tag" content="opengl-viewpoint" />
<meta property="og:article:tag" content="perl-3d" />
<meta property="og:article:tag" content="perl-game-programming" />
<meta property="og:article:tag" content="perl-graphics" />
<meta property="og:article:tag" content="perl-opengl" />
<meta property="og:article:tag" content="perl-sdl" />


  <link rel="icon" href="/favicon.ico">
  <link href="/article/index.xml" rel="alternate" type="application/rss+xml" title="Perl.com - programming news, code and culture" />
  <link href="/article/index.xml" rel="feed" type="application/rss+xml" title="Perl.com - programming news, code and culture" />
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" type="text/css" href="/css/perldotcom.css"/>


<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-50555-22', 'auto');
ga('create', 'UA-85734801-2', 'auto', 'editor');
ga('send', 'pageview');
ga('editor.send', 'pageview');
</script>

</head>
<body>

<div class="container-fluid full-wdith antonio">
 <div class="row">
  <div class="navbar-inverse" style="border-radius:none !important" role="navigation">
    <div class="container-fluid">
      <ul class="nav navbar-nav pull-right follow">
          <li>MORE:</li>
          <li><a href="https://perl.org">
              <img src="/images/site/perl-onion_20.png" alt="Perl Onion"></a><li>
          <li><a href="https://twitter.com/intent/follow?screen_name=perlfoundation">
              <img src="/images/site/twitter_20.png" alt="twitter"></a><li>
          <li><a href="/article/index.xml" />
              <img src="/images/site/rss_20.png" alt="rss"></a></li>
          <li><a href="https://github.com/tpf/perldotcom" />
              <img src="/images/site/github_light_20.png" alt="GitHub logo"></a></li>
      </ul>
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
          <a class="navbar-nav" href="/">
            <div class="header-logo">Perl.com</div>
          </a>
      </div>
      <div class="navbar-collapse collapse">
        <ul class="nav navbar-nav">
          <li><a href="/about">
              <div class="circle">
                <img src="/images/site/perl-camel.png" alt="" />
              </div>
                  &nbsp;&nbsp;ABOUT</a>
          </li>
          <li><a href="/authors">
              <div class="circle">
                  <span class="glyphicon glyphicon-user txt-blue-major" aria-hidden="true"></span>
              </div>
                  &nbsp;&nbsp;AUTHORS</a>
          </li>
          <li><a href="/categories">
              <div class="circle">
                  <span class="glyphicon glyphicon-folder-open txt-blue-major" aria-hidden="true"></span>
              </div>
                  &nbsp;&nbsp;CATEGORIES</a>
          </li>
          <li><a href="/tags">
              <div class="circle">
                <span class="txt-blue-major" aria-hidden="true"><strong>#</strong></span>
              </div>
                  &nbsp;&nbsp;TAGS</a>
          </li>
          <li>
            <form class="search" name="ddg" action="https://duckduckgo.com/" method="get">
              <input type="text" name ="q" placeholder="SEARCH" />
              <input type="hidden" value="perl.com" name="sites" />
            </form>
          </li>
        </ul>
      </div>
    </div>
  </div>
 </div>
</div>


  <section id="content" role="main">
    <section class="entry-content">
      <div class="container">
        <div class="row">
          <div class="col-md-9">
            <div class="row">
              <article class="fulltext">
              <h1 class="blog-post-title">Building a 3D Engine in Perl, Part 3</h1>
              <p class="blog-post-meta">Feb 17, 2005 by
              
              
                
                
                <a href="#author-bio-geoff-broadwell">Geoff Broadwell</a>
              
              </p>
              <img alt="" src=""/>
                

<p>This article is the third in a series aimed at <a href="/authors/geoff-broadwell">building a full 3D engine in Perl</a>. The <a href="/pub/2004/12/01/3d_engine.html">first article</a> started with basic program structure and worked up to displaying a simple depth-buffered scene in an OpenGL window. The <a href="/pub/2004/12/29/3d_engine.html">second article</a> followed with a discussion of time, view animation, SDL events, keyboard handling, and a nice chunk of refactoring.</p>

<p><em>Editor&rsquo;s note: see also the next article in the series, <a href="/pub/2005/08/04/3d_engine.html">profiling your application</a>.</em></p>

<p>Later in this article, I&rsquo;ll discuss movement of the view position, continue the refactoring work by cleaning up <code>draw_view</code>, and begin to improve the look of our scene using OpenGL lighting and materials. Before I cover that, your feedback to the previous articles has included a couple of common requests: screenshots and help with porting issues. If you&rsquo;re having problems running SDL_Perl and the <a href="/media/_pub_2005_02_17_3d_engine/perl_opengl_3_examples.tar.gz">sample code</a> from these articles on your system, or might be able to help the Mac OS X and Win32 readers, take a look at the next section. Otherwise, skip down to the <a href="#Screenshots">Screenshots</a> section, where the main article begins.</p>

<h3 id="known-porting-issues">Known Porting Issues</h3>

<h4 id="general">General</h4>

<p>Some versions of SDL_Perl require that the program load SDL::Constants to recognize <code>SDL_QUIT</code> and other constants. As this change should be transparent to other users, I have merged that into the latest version of the sample code, retroactive to the first use of an SDL constant.</p>

<h4 id="freebsd">FreeBSD</h4>

<p>See the suggestions at the beginning of the <a href="/pub/2004/12/29/3d_engine.html">second article</a>.</p>

<h4 id="mac-os-x">Mac OS X</h4>

<p>I spent some time research the porting issues on Mac OS X but am as yet unable to figure out a simple procedure for building SDL_Perl from scratch. Recent emails on the <em>sdl-devel</em> mailing list seem to indicate that Mac OS X builds for recent SDL_Perl sources are problematic right now, but older releases seem to be even worse. There have been some packaging attempts in the past, but none that I have found so far install a fully configured set of SDL_Perl libraries into the system <code>perl</code>. I&rsquo;m no Mac porting expert, so I appreciate any help on this; please post a comment in this month&rsquo;s article discussion if you have a suggestion or solution.</p>

<h4 id="slackware">Slackware</h4>

<p>According to comments by Federico (<code>ironfede</code>) in last month&rsquo;s <a href="/pub/2004/12/29/3d_engine.html?page=last#thread">article discussion</a>, Slackware ships with a version of SDL_Perl that requires SDL::Constants. This is not an issue for the current version of the sample code, which I fixed as mentioned above in the <a href="#General">General</a> issues paragraph.</p>

<h4 id="win32">Win32</h4>

<p>Win32 porting went as did Mac OS X porting. I was quite excited when chromatic pointed me to some old Win32 PPM packages, but sadly they don&rsquo;t include a working version of SDL::OpenGL. Building manually was &ldquo;interesting&rdquo; at best, as I have no access to a Microsoft compiler and precious little experience using <code>gcc</code> under Win32. As with the Mac folks, I appreciate any help from the readers. Please post a comment in this month&rsquo;s article discussion if you have a suggestion or solution for your fellows.</p>

<h3 id="screenshots">Screenshots</h3>

<p>Thankfully, screenshots are much easier to handle than porting issues. I&rsquo;d like the user to be able to take a screenshot whenever desired. The obvious way to accomplish that is to bind the screenshot action to a key; I chose function key <code>F4</code> at random. First I added it to the <code>bind</code> hash:</p>

<pre><code>        bind   =&gt; {
            escape =&gt; 'quit',
            f4     =&gt; 'screenshot',
            left   =&gt; '+yaw_left',
            right  =&gt; '+yaw_right',
            tab    =&gt; '+look_behind',
        }
</code></pre>

<p>The new key must have an action routine, so I altered that lookup hash as well:</p>

<pre><code>    $self-&gt;{lookup}{command_action} = {
          quit         =&gt; \&amp;action_quit,
          screenshot   =&gt; \&amp;action_screenshot,
        '+yaw_left'    =&gt; \&amp;action_move,
        '+yaw_right'   =&gt; \&amp;action_move,
        '+look_behind' =&gt; \&amp;action_move,
    };
</code></pre>

<p>I need to wait until drawing completes for the entire scene before I can take a snapshot, but event processing happens before drawing begins. To work around this, I set a state variable marking that the user has requested a screenshot, rather than perform the screenshot immediately:</p>

<pre><code>sub action_screenshot
{
    my $self = shift;

    $self-&gt;{state}{need_screenshot} = 1;
}
</code></pre>

<p>The code checks this state variable in a new line at the end of <code>end_frame</code>, after the drawing has completed and it has synced the screen with the image written into OpenGL&rsquo;s color buffer:</p>

<pre><code>sub end_frame
{
    my $self = shift;

    $self-&gt;{resource}{sdl_app}-&gt;sync;
    $self-&gt;screenshot if $self-&gt;{state}{need_screenshot};
}
</code></pre>

<p>The <code>screenshot</code> routine is surprisingly short but dense:</p>

<pre><code>sub screenshot
{
    my $self = shift;

    my $file = 'screenshot.bmp';
    my $w    = $self-&gt;{conf}{width};
    my $h    = $self-&gt;{conf}{height};

    glReadBuffer(GL_FRONT);
    my $data = glReadPixels(0, 0, $w, $h, GL_BGR,
                            GL_UNSIGNED_BYTE);
    SDL::OpenGL::SaveBMP($file, $w, $h, 24, $data);

    $self-&gt;{state}{need_screenshot} = 0;
}
</code></pre>

<p>The routine starts by specifying a filename for the screenshot and gathering the width and height of the screen. The real work begins with the call to <code>glReadBuffer</code>. Depending on the OpenGL driver, the hardware, and a number of advanced settings, OpenGL may have provided <em>several</em> color buffers in which to draw and read images. In fact, the default behavior on most systems is to draw onto one buffer, known as the <em>back buffer</em>, and display a separate buffer, known as the <em>front buffer</em>. After completing the drawing for each frame, the <code>SDL::App::sync</code> call moves the image from the back buffer to the front buffer so the user can see it. Behind the scenes, OpenGL generally handles this in one of two different ways, depending on the underlying implementation. Software OpenGL implementations, such as Mesa, copy the data from the back buffer to the front buffer. Hardware-accelerated systems can swap internal pointers so that the back buffer becomes the front buffer and vice versa. As you can imagine, this is much faster.</p>

<p>This extra work brings a great benefit. Without double buffering, as soon as one frame completes, the next frame immediately clears the screen to black and starts drawing again from scratch. Depending on the relative speed difference between the user&rsquo;s monitor and the application, this would probably appear to the user as a flickering, dark, perpetually half-drawn scene. With double buffering, this problem is almost gone. The front buffer shows a solid stable image while all of the drawing is done on the back buffer. Once the drawing completes, it takes at most a few milliseconds to sync up and start displaying the new frame. To the human eye, the animation appears solid, bright, and (hopefully) smooth.</p>

<p>In this case, I want to make sure that I take a screenshot of exactly the same image the user sees, so I tell OpenGL that I want to read the image in the front buffer (<code>GL_FRONT</code>).</p>

<p>At this point, it&rsquo;s safe to read the image data into a Perl buffer in the proper format. The first four arguments to <code>glReadPixels</code> specify the lower-left corner and size of the sub-image to read. The next two arguments together tell OpenGL what format I would like for the data. I specify that I want to read the entire window and that I want the data in the correct format for a BMP file&ndash;one unsigned byte for each of the red, green, and blue color channels for each pixel, but in reverse order.</p>

<p>Once I have the data from OpenGL I use the SDL_Perl utility routine <code>SaveBMP</code> to save the image into a file. The arguments are the filename, image width, image height, color depth (24 bits per pixel), and data buffer. Finally, the routine resets the <code>need_screenshot</code> state flag and returns.</p>

<p>At this point you should be able to take a screenshot each time you press the <code>F4</code> key. Of course, I&rsquo;d like to show several screenshots during this article as the code progresses. The current code overwrites the previous screenshot file every time I request a new one. Because I number each runnable version of the code, I used a quick workaround resulting in a different screenshot filename for each code step. I first load one of the core Perl modules to strip directories from a path:</p>

<pre><code>use File::Basename;
</code></pre>

<p>Then I use the filename of the script itself as part of my screenshot filename:</p>

<pre><code>    my $file = basename($0) . '.bmp';
</code></pre>

<p>This may be all you need for your application, or you may want to add some code to number each file uniquely. This code is enough to fix my problem, so I&rsquo;ve left the more powerful version as an exercise for the reader.</p>

<p>Here then is the first screenshot:</p>

<p><img src="/images/_pub_2005_02_17_3d_engine/step042.png" width="400" height="400" /></p>

<p>The observant reader will notice that this image is not a BMP file; it&rsquo;s a PNG image, which is both much smaller than a BMP and more friendly to web standards. There are many tools available that can perform this conversion. Any good image editor can do it. In this case that&rsquo;s overkill&ndash;I instead used the <code>convert</code> program from the <a href="http://www.imagemagick.org/">ImageMagick</a> suite of utilities:</p>

<pre><code>convert step042.bmp step042.png
</code></pre>

<h3 id="moving-the-viewpoint">Moving the Viewpoint</h3>

<p>That view is more than a tad overplayed. The user can&rsquo;t even move the viewpoint to see the back or sides of the scene. It&rsquo;s time to change that. I started by defining some new key bindings:</p>

<pre><code>        bind   =&gt; {
            escape =&gt; 'quit',
            f4     =&gt; 'screenshot',
            a      =&gt; '+move_left',
            d      =&gt; '+move_right',
            w      =&gt; '+move_forward',
            s      =&gt; '+move_back',
            left   =&gt; '+yaw_left',
            right  =&gt; '+yaw_right',
            tab    =&gt; '+look_behind',
        }
</code></pre>

<p>I then updated the <code>command_action</code> <code>lookup</code> hash to handle these as movement keys:</p>

<pre><code>    $self-&gt;{lookup}{command_action} = {
          quit          =&gt; \&amp;action_quit,
          screenshot    =&gt; \&amp;action_screenshot,
        '+move_left'    =&gt; \&amp;action_move,
        '+move_right'   =&gt; \&amp;action_move,
        '+move_forward' =&gt; \&amp;action_move,
        '+move_back'    =&gt; \&amp;action_move,
        '+yaw_left'     =&gt; \&amp;action_move,
        '+yaw_right'    =&gt; \&amp;action_move,
        '+look_behind'  =&gt; \&amp;action_move,
    };
</code></pre>

<p><code>init_view</code> needs to initialize two more velocity components and matching deltas:</p>

<pre><code>    $self-&gt;{world}{view} = {
        position    =&gt; [6, 2, 10],
        orientation =&gt; [0, 0, 1, 0],
        d_yaw       =&gt; 0,
        v_yaw       =&gt; 0,
        v_forward   =&gt; 0,
        v_right     =&gt; 0,
        dv_yaw      =&gt; 0,
        dv_forward  =&gt; 0,
        dv_right    =&gt; 0,
    };
</code></pre>

<p><code>action_move</code> needs a new movement speed to match the existing yaw speed and some additions to <code>%move_update</code>:</p>

<pre><code>    my $speed_move       = 5;
    my %move_update      = (
        '+yaw_left'     =&gt; [dv_yaw     =&gt;  $speed_yaw ],
        '+yaw_right'    =&gt; [dv_yaw     =&gt; -$speed_yaw ],
        '+move_right'   =&gt; [dv_right   =&gt;  $speed_move],
        '+move_left'    =&gt; [dv_right   =&gt; -$speed_move],
        '+move_forward' =&gt; [dv_forward =&gt;  $speed_move],
        '+move_back'    =&gt; [dv_forward =&gt; -$speed_move],
        '+look_behind'  =&gt; [d_yaw      =&gt;  180        ],
    );
</code></pre>

<p>So far, the changes are mostly hash updates instead of procedural code; that&rsquo;s a good sign that the existing code design has some more life left. When conceptually simple changes require significant code modification, especially special cases or repetitive blocks of code, it&rsquo;s time to look for a refactoring opportunity. Thankfully, these changes are in initialization and configuration rather than special cases.</p>

<p>One routine that requires a good bit of new code is <code>update_view</code>. I added these lines to the end:</p>

<pre><code>    $view-&gt;{v_right}        += $view-&gt;{dv_right};
    $view-&gt;{dv_right}        = 0;
    $view-&gt;{v_forward}      += $view-&gt;{dv_forward};
    $view-&gt;{dv_forward}      = 0;

    my $vx                   =  $view-&gt;{v_right};
    my $vz                   = -$view-&gt;{v_forward};
    $view-&gt;{position}[0]    += $vx * $d_time;
    $view-&gt;{position}[2]    += $vz * $d_time;
</code></pre>

<p>That routine is beginning to look a bit repetitious and has several copies of very similar lines of code, so it goes on the list of places to refactor in the future. There are not yet enough cases to make the best solution obvious, so I&rsquo;ll hold off for a bit.</p>

<p>The new code starts by applying the new velocity deltas in the same way that it updates <code>v_yaw</code> earlier in the routine. It converts the right and forward velocities to velocities along the world axes by noting that the view starts out with &ldquo;forward&rdquo; parallel to the negative Z axis and &ldquo;right&rdquo; parallel to the positive X axis. It then multiplies the X and Z velocities by the time delta to arrive at a position change, which it adds into the current view position.</p>

<p>This version of the code works fine as long as the user doesn&rsquo;t rotate the view. When the view rotates, &ldquo;forward&rdquo; and &ldquo;right&rdquo; don&rsquo;t match the new view directions. They still point down the -Z and +X axes respectively, which can prove very disorienting for high rotations. The solution is a bit of trigonometry. The idea is treat the initial X and Z velocities as components of the total velocity vector, and rotate that vector through the same angle that the user rotated the view:</p>

<pre><code>    my $vx                   =  $view-&gt;{v_right};
    my $vz                   = -$view-&gt;{v_forward};
    my $angle                = $view-&gt;{orientation}[0];
    ($vx, $vz)               = rotate_xz($angle, $vx, $vz);
    $view-&gt;{position}[0]    += $vx * $d_time;
    $view-&gt;{position}[2]    += $vz * $d_time;
</code></pre>

<p>The two middle lines are the new ones. They call <code>rotate_xz</code> to do the vector rotation work and then set <code>$vx</code> and <code>$vz</code> to the returned components of the rotated velocity vector. <code>rotate_xz</code> is:</p>

<pre><code>sub rotate_xz
{
    my ($angle, $x, $z) = @_;

    my $radians = $angle * PI / 180;
    my $cos     = cos($radians);
    my $sin     = sin($radians);
    my $rot_x   =  $cos * $x + $sin * $z;
    my $rot_z   = -$sin * $x + $cos * $z;

    return ($rot_x, $rot_z);
}
</code></pre>

<p>After converting the angle from degrees to radians, the code calculates and saves the sine and cosine of the angle. It then calculates the rotated velocity components given the original unrotated components. Finally, it returns the rotated components to the caller.</p>

<p>I&rsquo;ll skip the derivation here (you&rsquo;re welcome), but if you&rsquo;re curious about how and why this calculation performs a rotation, there are numerous books that explain the wonders of vector mathematics in amazing detail. O&rsquo;Reilly&rsquo;s <a href="http://www.oreilly.com/catalog/physicsgame/">Physics for Game Developers</a>, by David M. Bourg, includes a high-level discussion of rotation. Charles River Media&rsquo;s <a href="http://www.charlesriver.com/titles/lengyelmath2.html">Mathematics for 3D Game Programming &amp; Computer Graphics</a>, by Eric Lengyel, includes a deeper discussion though I, for one, have college math flashbacks every time I read it. Speaking of which, any college textbook on linear algebra should include as much detail as you desire.</p>

<p>This code requires a definition for <code>PI</code>, provided by the following line near the top of the program, right after requesting warnings from Perl:</p>

<pre><code>use constant PI =&gt; 4 * atan2(1, 1);
</code></pre>

<p>The <code>constant</code> module evaluates possibly complex calculations during the compile phase and then converts them into constants at runtime. The above calculation takes advantage of a standard trig identity to derive a value for <code>PI</code> accurate to as many digits as the system can deliver.</p>

<p><code>update_view</code> now does the right thing, no matter what angle the view is facing. It doesn&rsquo;t take long to find a more interesting view:</p>

<p><img src="/images/_pub_2005_02_17_3d_engine/step044.png" width="400" height="400" /></p>

<h3 id="let-there-be-lighting">Let There Be Lighting!</h3>

<p>Okay, so maybe that&rsquo;s not <em>much</em> more interesting, admittedly. This scene needs a little mood lighting instead of the flat colors I&rsquo;ve used so far (especially because they make it hard to see the shape of each object clearly). As a first step, I turned on OpenGL&rsquo;s lighting system with a new line at the end of <code>prep_frame</code>:</p>

<pre><code>    glEnable(GL_LIGHTING);
</code></pre>

<p><img src="/images/_pub_2005_02_17_3d_engine/step045.png" width="400" height="400" /></p>

<p>Far from lighting the scene, the view is now almost black. If you look very carefully and your monitor and room lighting are forgiving, you should be able to just make out the objects, which are very dark gray on the black background. In order to see anything, I must enable both <code>GL_LIGHTING</code> and one or more lights to provide light to the scene. Without a light, the objects are dark gray instead of true black because OpenGL, by default, applies a very small amount of light to the entire scene, known as <em>ambient</em> light. To show the objects more brightly, I turned on the first OpenGL light with another new line at the end of <code>prep_frame</code>:</p>

<pre><code>    glEnable(GL_LIGHT0);
</code></pre>

<p><img src="/images/_pub_2005_02_17_3d_engine/step046.png" width="400" height="400" /></p>

<p>Now the objects are brighter, but they&rsquo;re still just gray. When calculating colors with lighting enabled, OpenGL uses a completely different set of parameters from the colors used when lighting is disabled. Together these new parameters make up a <em>material</em>. Complex interactions between the parameters that make up a material can result in very interesting color effects, but in this case, I&rsquo;m not trying to create a complex effect. I want my objects to have their old colors back without worrying about the full complexity that materials provide. Thankfully, OpenGL provides a way to state that the current material should default to the current color. To do this, I add yet another line to the end of <code>prep_frame</code>:</p>

<pre><code>    glEnable(GL_COLOR_MATERIAL);
</code></pre>

<p><img src="/images/_pub_2005_02_17_3d_engine/step047.png" width="400" height="400" /></p>

<p>At this point, the objects once again have color, but each of the faces is still the same shade rather than appearing to be lit by a single light source somewhere. The problem is that OpenGL does not know whether each face points toward or away from the light and, if so, by how much. The angle between the face and the light determines how much light falls on the surface and, therefore, how bright it should appear. It is possible to calculate the angle of each face in my scene from the location of its vertices, but this is not always the right thing to do (especially when dealing with curved surfaces), so OpenGL does not calculate this internally. Instead, the program needs to do the direction calculations and tell OpenGL the result, known as the <em>normal vector</em>.</p>

<p>Luckily, in <code>draw_cube</code> the faces align with the coordinate axes so that each face points down one of them (positive or negative X, Y, or Z). I don&rsquo;t have to do any calculation here, just tell OpenGL which normal vector to associate with each face:</p>

<pre><code>sub draw_cube
{
    # A simple cube
    my @indices = qw( 4 5 6 7   1 2 6 5   0 1 5 4
                      0 3 2 1   0 4 7 3   2 3 7 6 );
    my @vertices = ([-1, -1, -1], [ 1, -1, -1],
                    [ 1,  1, -1], [-1,  1, -1],
                    [-1, -1,  1], [ 1, -1,  1],
                    [ 1,  1,  1], [-1,  1,  1]);
    my @normals = ([0, 0,  1], [ 1, 0, 0], [0, -1, 0],
                   [0, 0, -1], [-1, 0, 0], [0,  1, 0]);

    glBegin(GL_QUADS);

    foreach my $face (0 .. 5) {
        my $normal = $normals[$face];
        glNormal(@$normal);

        foreach my $vertex (0 .. 3) {
            my $index  = $indices[4 * $face + $vertex];
            my $coords = $vertices[$index];
            glVertex(@$coords);
        }
    }
    glEnd;
}
</code></pre>

<p>The new lines are the definition of the <code>@normals</code> array and the two lines at the top of the <code>$face</code> loop that select the correct normal for each face and pass it to OpenGL using <code>glNormal</code>.</p>

<p>The boxes are now shaded reasonably and it&rsquo;s clear that the light is coming from somewhere behind the viewer; the front faces are brighter than the sides. Unfortunately, the axes are now dark again:</p>

<p><img src="/images/_pub_2005_02_17_3d_engine/step048.png" width="400" height="400" /></p>

<p>I did not specify any normal for the axis lines because the concept doesn&rsquo;t make a whole lot of sense for lines or points. However, with lighting enabled, OpenGL needs a set of normals for every lit object, so it goes back to the current state and uses the most recently defined normal. For the very first frame this is the default normal, which happens to point towards the default first light, but for succeeding frames it will be the last normal set in <code>draw_cube</code>. The latter definitely does not point toward the light, and the axes end up dark.</p>

<p>I&rsquo;d rather the axis lines didn&rsquo;t take part in lighting calculations at all and kept their original bright colors, regardless of any lighting (or lack thereof) in the scene. To do this, I removed the line that enables <code>GL_LIGHTING</code> in <code>prep_frame</code> and inserted two new lines near the top of <code>draw_view</code>:</p>

<pre><code>sub draw_view
{
    glDisable(GL_LIGHTING);

    draw_axes();

    glEnable(GL_LIGHTING);
</code></pre>

<p>Now lighting is off before drawing the axis lines and back on afterward. The axis lines have bright colors again, but rotating the view exposes a new problem. When the view rotates, the direction of the light changes as well:</p>

<p><img src="/images/_pub_2005_02_17_3d_engine/step049.png" width="400" height="400" /></p>

<p>Because of the way that OpenGL calculates light position and direction, any lights defined before the view is set are fixed to the viewer like the light on a miner&rsquo;s helmet. To fix a light relative to the simulated world, define the light instead after setting the view. I removed the line enabling <code>GL_LIGHT0</code> in <code>prep_frame</code> and moved it to the new routine <code>set_world_lights</code>:</p>

<pre><code>sub set_world_lights
{
    glEnable(GL_LIGHT0);
}
</code></pre>

<p>I then updated <code>draw_frame</code> to call the new routine after setting the view:</p>

<pre><code>sub draw_frame
{
    my $self = shift;

    $self-&gt;set_projection_3d;
    $self-&gt;set_view_3d;
    $self-&gt;set_world_lights;
    $self-&gt;draw_view;
}
</code></pre>

<p>Unfortunately, this doesn&rsquo;t work. OpenGL only updates its internal state with the light&rsquo;s position and direction when they change explicitly, not when the light is enabled or disabled. I&rsquo;ve never set the light&rsquo;s parameters explicitly, so the original default still stands. This issue is easy to fix with another line in <code>set_world_lights</code>:</p>

<pre><code>sub set_world_lights
{
    glLight(GL_LIGHT0, GL_POSITION, 0.0, 0.0, 1.0, 0.0);

    glEnable(GL_LIGHT0);
}
</code></pre>

<p>In one of the few OpenGL interface decisions that actively annoys me, the new line sets the <em>direction</em> of the light, not its position. OpenGL defines all lights as one of two types: <em>directional</em> or <em>positional</em>. OpenGL assumes directional lights are very far away so that anywhere in the scene the direction from the light to each object is effectively the same. Positional lights are nearer and OpenGL must calculate the direction from the light to every vertex of every object in the scene independently. As you can imagine, this is much slower, but produces more interesting lighting effects.</p>

<p>The key to choosing between these two types is the last parameter of the <code>glLight</code> call above. If this parameter is <code>0</code>, the light is directional and the other three coordinates specify the direction from which the light comes. In this case, I&rsquo;ve specified that the light should come <em>from</em> the +Z direction. If the last parameter is <code>1</code>, then OpenGL makes the light positional and uses the other three coordinates to set the light&rsquo;s position within the scene. For now, I&rsquo;ll skip the gory details of what happens when a value other than <code>0</code> or <code>1</code> is used, but in short, the light will be positional and extra calculations determine the actual position used. Most of the time it&rsquo;s best to ignore that case.</p>

<p>You may wonder why I explicitly specified <code>0.0</code> and <code>1.0</code> instead of <code>0</code> and <code>1</code>. This is a workaround for a bug in <code>glLight</code> in some versions of SDL_Perl when it is presented with integer arguments instead of floating-point arguments.</p>

<p>With this line added, the light now stays fixed in the world, even when the user moves and rotates the view:</p>

<p><img src="/images/_pub_2005_02_17_3d_engine/step051.png" width="400" height="400" /></p>

<h3 id="a-lantern">A Lantern</h3>

<p>Of course, sometimes a light connected to the viewer is exactly the intention. For example, perhaps the desired effect is for the player to hold a lantern or flashlight to light dark places. Both of these are localized light sources that light nearby objects quite a bit, but distant objects only a little. The primary difference between them is that a flashlight and certain types of lanterns cast light primarily in one direction, often in a cone. Most lanterns, torches, and similar light sources cast light in all directions (barring shadows from handles, fuel tins, and the like).</p>

<p>Non-directed light is a little simpler to implement, so I&rsquo;ll start with lantern light. I wanted the light rooted at the viewer&rsquo;s position, so I defined the light before setting the view:</p>

<pre><code>sub draw_frame
{
    my $self = shift;

    $self-&gt;set_projection_3d;
    $self-&gt;set_eye_lights;
    $self-&gt;set_view_3d;
    $self-&gt;set_world_lights;
    $self-&gt;draw_view;
}
</code></pre>

<p>I refer to viewer-fixed lights as <em>eye lights</em> because OpenGL refers to the coordinate system it uses for lights as <em>eye coordinates</em>, and a light defined this way as maintaining a particular position &ldquo;relative to the eye.&rdquo; Here&rsquo;s <code>set_eye_lights</code>:</p>

<pre><code>sub set_eye_lights
{
    glLight(GL_LIGHT1, GL_POSITION, 0.0, 0.0, 1.0, 0.0);

    glEnable(GL_LIGHT1);
}
</code></pre>

<p>Here I set the second light exactly the same way I set the first. Note that it doesn&rsquo;t matter that I actually define the second light in my program before the first. Each OpenGL light is independently numbered and always keeps the same number, rather than acting like a stack or queue numbered by order of use.</p>

<p>Sadly, the new code doesn&rsquo;t seem to have any effect at all. In reality, there really is a new light shining on the scene&ndash;unlike <code>GL_LIGHT0</code>, which defaults to shining bright white, all of the other lights default to black and provide no new light to the scene. The solution is to set another parameter of the light:</p>

<pre><code>sub set_eye_lights
{
    glLight(GL_LIGHT1, GL_POSITION, 0.0, 0.0, 1.0, 0.0);
    glLight(GL_LIGHT1, GL_DIFFUSE,  1.0, 1.0, 1.0, 1.0);

    glEnable(GL_LIGHT1);
}
</code></pre>

<p>The front faces of each object should appear considerably brighter. Moving around the scene shows that the eye light brightens a surface only dimly lit by the world light:</p>

<p><img src="/images/_pub_2005_02_17_3d_engine/step053.png" width="400" height="400" /></p>

<p>If you watch carefully, however, you&rsquo;ll notice that the lighting varies by the view rotation&ndash;not position. I defined the light as directional with the light coming from behind the viewer, rather than positional, with the light coming from the viewer directly. I hinted at the fix earlier&ndash;changing the <code>GL_POSITION</code> parameter as follows:</p>

<pre><code>    glLight(GL_LIGHT1, GL_POSITION, 0.0, 0.0, 0.0, 1.0);
</code></pre>

<p>The light now comes from <code>(0, 0, 0)</code> in eye coordinates, right at the viewpoint. Moving around and rotating shows that this version has the intended effect.</p>

<p>The simulated lantern still shines as brightly on far-away objects as it does on near ones. A real lantern&rsquo;s light falls off rapidly with distance from the lantern. OpenGL can do this with another setting:</p>

<pre><code>sub set_eye_lights
{
    glLight(GL_LIGHT1, GL_POSITION, 0.0, 0.0, 0.0, 1.0);
    glLight(GL_LIGHT1, GL_DIFFUSE,  1.0, 1.0, 1.0, 1.0);
    glLight(GL_LIGHT1, GL_LINEAR_ATTENUATION, 0.5);

    glEnable(GL_LIGHT1);
}
</code></pre>

<p>This case tells OpenGL to include a dimming term in its equations proportional to the distance between the light and the object. Physics-minded readers will point out that physically accurate dimming is proportional to the square of the distance, and OpenGL does allow this using <code>GL_QUADRATIC_ATTENUATION</code>. However, a host of factors (including the lighting equations that OpenGL uses and the non-linear effects of the graphics hardware, monitor, and human eye) make this more accurate dimming look rather odd. Linear dimming turns out to look better in many cases, so that&rsquo;s what I used here. It is also possible to combine different dimming types, so that the dimming appears linear for nearby objects and quadratic for distant ones, which you may find a better tradeoff. The <code>0.5</code> setting tells OpenGL how strong the linear dimming effect should be for my scene.</p>

<p>Moving around the scene, you should be able to see the relatively subtle dimming effect in action. Don&rsquo;t be afraid to leave it subtle instead of turning the dimming effect way up. Some moods call for striking lighting effects, while others call for lighting effects that the viewer notices only subconsciously. In some visualization applications, lighting subtlety is a great virtue, allowing the human visual system&rsquo;s amazing processing power to come to grips with a complex scene without being overwhelmed.</p>

<h3 id="a-flashlight">A Flashlight</h3>

<p>I really happen to like the way a flashlight casts its cone of light, so I converted the omnidirectional light of the lantern to a directed cone. OpenGL refers to this type of light as a <em>spotlight</em> and includes several light parameters to define them. The first change is a new setting in <code>set_eye_lights</code>:</p>

<pre><code>    glLight(GL_LIGHT1, GL_SPOT_CUTOFF, 15.0);
</code></pre>

<p>This sets the angle between the center of the light beam and the edges of the cone. OpenGL accepts either 180 degrees (omnidirectional) or any value between 0 and 90 degrees (from a laser beam to a hemisphere of light). In this case, I chose a centerline-to-edge angle of 15 degrees, making a nice 30-degree-wide cone of light.</p>

<p>This change indeed limits the cone of light, but also reveals an ugly artifact. Move to a point just in front of the left front corner of the white cube and rotate the view to pan the light across the yellow box. You&rsquo;ll see the light jump nastily from corner to corner, even disappearing entirely in between. Even when a corner is lit, the shape of the light is not very conelike:</p>

<p><img src="/images/_pub_2005_02_17_3d_engine/step056.png" width="400" height="400" /></p>

<p>OpenGL&rsquo;s standard lighting model only performs the lighting calculations at each vertex, interpolating the results in between. For models that have many small faces and a resulting high density of vertices, this works relatively well. It breaks down nastily in scenes containing objects with large faces and few vertices, especially when a positional light is close to an object. Spotlights make the problem even more apparent, as they can easily shine <em>between</em> two vertices without lighting either of them; the polygon then appears uniformly dark.</p>

<h3 id="ode-to-rush">Ode to Rush</h3>

<p>Advanced OpenGL functionality paired with recent hardware can solve this problem with per-pixel lighting calculations. Older hardware can fake it with light maps and similar tricks. Rather than using advanced functionality, I&rsquo;ll use a simpler method for improving the lighting, known as <em>subdivisions</em>. (Those of you scratching your heads over the Rush reference can now breathe a collective sigh of relief.) Subdivisions have their own problems, as I&rsquo;ll show later, but those issues explain a lot about the design of graphics APIs, so they&rsquo;re worth a look.</p>

<p>As the name implies, the basic idea is to subdivide each face into many smaller faces, each with its own set of vertices. For curved objects such as spheres and cylinders, this is essential so that nearby objects appear to curve smoothly. For objects with large flat faces, such as boxes and pyramids, this merely has the side effect of forcing the per-vertex lighting calculations to be done many times across each face.</p>

<p>Before I can use subdivided faces, I need to prepare by refactoring <code>draw_cube</code>:</p>

<pre><code>sub draw_cube
{
    # A simple cube
    my @indices = qw( 4 5 6 7   1 2 6 5   0 1 5 4
                      0 3 2 1   0 4 7 3   2 3 7 6 );
    my @vertices = ([-1, -1, -1], [ 1, -1, -1],
                    [ 1,  1, -1], [-1,  1, -1],
                    [-1, -1,  1], [ 1, -1,  1],
                    [ 1,  1,  1], [-1,  1,  1]);
    my @normals = ([0, 0,  1], [ 1, 0, 0], [0, -1, 0],
                   [0, 0, -1], [-1, 0, 0], [0,  1, 0]);

    foreach my $face (0 .. 5) {
        my $normal = $normals[$face];
        my @corners;

        foreach my $vertex (0 .. 3) {
            my $index  = $indices[4 * $face + $vertex];
            my $coords = $vertices[$index];
            push @corners, $coords;
        }
        draw_quad_face(normal    =&gt; $normal,
                       corners   =&gt; \@corners);
    }
}
</code></pre>

<p>Instead of performing the OpenGL calls directly in <code>draw_cube</code>, it now calls <code>draw_quad_face</code>. For each large face it creates a new <code>@corners</code> array filled with the vertex coordinates of the corners of that face. It then passes that array and the face normal to <code>draw_quad_face</code>, defined as follows:</p>

<pre><code>sub draw_quad_face
{
    my %args    = @_;
    my $normal  = $args{normal};
    my $corners = $args{corners};

    glBegin(GL_QUADS);
    glNormal(@$normal);

    foreach my $coords (@$corners) {
        glVertex(@$coords);
    }
    glEnd;
}
</code></pre>

<p>This function performs exactly the OpenGL operations that <code>draw_cube</code> used to do. I&rsquo;ve also used a different argument-passing style for this routine than I have previously. In this case, I pass named arguments because I know that I will add at least one more argument very soon and that there&rsquo;s a pretty good chance I&rsquo;ll want to add more later. When the arguments to a routine are likely to change over time, and especially when callers might want to specify only a few arguments and allow the rest to take on reasonable defaults, named arguments are usually a better choice. The arguments can either be a hashref or a list stuffed into a hash. This time, I chose the latter method.</p>

<p>After refactoring comes testing, and a quick run showed that everything worked as expected. Safe in that knowledge, I rewrote <code>draw_quad_face</code> to subdivide each face:</p>

<pre><code>sub draw_quad_face
{
    my %args    = @_;
    my $normal  = $args{normal};
    my $corners = $args{corners};
    my $div     = $args{divisions} || 10;
    my ($a, $b, $c, $d) = @$corners;

    # NOTE: ASSUMES FACE IS A PARALLELOGRAM

    my $s_ab = calc_vector_step($a, $b, $div);
    my $s_ad = calc_vector_step($a, $d, $div);

    glNormal(@$normal);
    for my $strip (0 .. $div - 1) {
        my @v = ($a-&gt;[0] + $strip * $s_ab-&gt;[0],
                 $a-&gt;[1] + $strip * $s_ab-&gt;[1],
                 $a-&gt;[2] + $strip * $s_ab-&gt;[2]);

        glBegin(GL_QUAD_STRIP);
        for my $quad (0 .. $div) {
            glVertex(@v);
            glVertex($v[0] + $s_ab-&gt;[0],
                     $v[1] + $s_ab-&gt;[1],
                     $v[2] + $s_ab-&gt;[2]);

            $v[0] += $s_ad-&gt;[0];
            $v[1] += $s_ad-&gt;[1];
            $v[2] += $s_ad-&gt;[2];
        }
        glEnd;
    }
}
</code></pre>

<p>The new routine starts by adding the new optional argument <code>divisions</code>, which defaults to 10. This specifies how many subdivisions the face should have both &ldquo;down&rdquo; and &ldquo;across&rdquo;; the actual number of sub-faces is the square of this number. For the default 10 divisions, that comes to 100 sub-faces for each large face, so each cube has 600 sub-faces.</p>

<p>The next line labels the corners in counterclockwise order. This puts corner A diagonally across from corner C, with B on one side and D on the other.</p>

<p>As the comment on the next line indicates, I&rsquo;ve simplified the math considerably by assuming that the face is at least a parallelogram. With this simplification, I can calculate the steps for one division along sides AB and AD and use these steps to position every sub-face across the entire large face.</p>

<p>I can&rsquo;t just calculate the step as a simple distance to move, because I have no idea which direction each edge is pointing and wouldn&rsquo;t know which way to move for each step. Instead, I calculate the vector difference between the vertices at each end of the edge and divide that by the number of divisions. The code does the same calculation twice, so I&rsquo;ve extracted it into a separate routine:</p>

<pre><code>sub calc_vector_step
{
    my ($v1, $v2, $div) = @_;

    return [($v2-&gt;[0] - $v1-&gt;[0]) / $div,
            ($v2-&gt;[1] - $v1-&gt;[1]) / $div,
            ($v2-&gt;[2] - $v1-&gt;[2]) / $div];
}
</code></pre>

<p>Returning to <code>draw_quad_face</code>, it stores the vector steps in <code>$s_ab</code> (the step along the AB side) and <code>$s_ad</code> (the step along the AD side). Next it sets the current normal, which for a flat face remains the same across its entirety.</p>

<p>Finally, I can begin to define the sub-faces themselves. I&rsquo;ve taken advantage of the OpenGL quad strip primitive to draw the sub-faces as a series of parallel strips extending from the AB edge to the CD edge. For each strip, I first need to calculate the location of its starting vertex. I know this is on the AB edge, so the code starts at A and adds an AB step for each completed strip. For the first strip, this puts the starting vertex at A. For the last strip, the starting vertex will be one step (one strip width) away from B. It initializes the current vertex <code>@v</code> with the starting vertex and will keep it updated as it moves along each strip.</p>

<p>It then begins a strip of quads with <code>glBegin(GL_QUAD_STRIP)</code>. To define the strip, I&rsquo;ve specified the locations of each pair of vertices across from each other along its length. For each pair, it uses the current vertex and a calculated vertex one step further along the AB direction. The code then moves the current vertex one step along the length of the strip (the AD direction). Once the strip is complete, it ends it with <code>glEnd</code> and loops again for the next strip.</p>

<p>All of this complexity makes quite a visual difference:</p>

<p><img src="/images/_pub_2005_02_17_3d_engine/step058.png" width="400" height="400" /></p>

<p>It&rsquo;s clear that the light has a definite shape to it, but the lighting is so jagged that it&rsquo;s distracting. One way to fix this is to increase the number of divisions, making smaller sub-faces. This requires a simple addition to the <code>draw_quad_face</code> call in <code>draw_cube</code>:</p>

<pre><code>        draw_quad_face(normal    =&gt; $normal,
                       corners   =&gt; \@corners,
                       divisions =&gt; 30);
</code></pre>

<p>The result is quite a bit less jagged:</p>

<p><img src="/images/_pub_2005_02_17_3d_engine/step059.png" width="400" height="400" /></p>

<p>Unfortunately, the jaggies are smaller but still obviously there&ndash;and the closer the viewer is to an object the bigger they appear. There are also nine times as many sub-faces to draw (<sup>30</sup>&frasl;<sub>10</sub> squared) and the program now runs considerably slower. If you&rsquo;re lucky enough to have a recent system with fast video hardware and don&rsquo;t notice the slowdown, use 100 or so for the number of divisions. You&rsquo;ll probably see it.</p>

<h3 id="softening-the-edges">Softening the Edges</h3>

<p>Clearly, increasing the number of subdivisions only goes so far to improve the rendering, while simultaneously costing dearly in performance. I&rsquo;ll try a different tack and go back to what I know about a flashlight. Most flashlights cast a beam that is brighter in the center than at the edge. (Some have a dark circle in the very center, but I&rsquo;m ignoring that for now.) I can take advantage of this to create a more accurate image and also soften the large jaggies considerably. First, I backed out my change to the <code>draw_quad_face</code> call:</p>

<pre><code>        draw_quad_face(normal    =&gt; $normal,
                       corners   =&gt; \@corners);
</code></pre>

<p>Then I changed one spotlight parameter for the flashlight in <code>set_eye_lights</code> and added another:</p>

<pre><code>    glLight(GL_LIGHT1, GL_SPOT_CUTOFF,   30.0);
    glLight(GL_LIGHT1, GL_SPOT_EXPONENT, 80.0);
</code></pre>

<p>With the change to <code>GL_SPOT_CUTOFF</code>, I&rsquo;ve widened the beam to twice its original angle. At the same time, I&rsquo;ve told OpenGL to make it quite a bit dimmer at the edges using <code>GL_SPOT_EXPONENT</code>, hopefully hiding any jaggies. The new parameter has a somewhat confusing name that refers to the details of the equation that determines the strength of the off-center dimming effect. In a theme seen throughout the mathematics of computer graphics, the dimming is a function of the cosine of the angle between the center line and the vertex being lit. In fact, the dimming factor is the cosine raised to the exponent specified by <code>GL_SPOT_EXPONENT</code>. Why use the cosine of the angle? It turns out to be cheap to calculate&ndash;cheaper than calculating the angle itself&ndash;and also gives a nice smooth effect.</p>

<p>With luck, the new beam will appear about the same width to the eye as the old one:</p>

<p><img src="/images/_pub_2005_02_17_3d_engine/step060.png" width="400" height="400" /></p>

<p>Good enough. The image looks better without the massive performance strain of high subdivision levels.</p>

<h3 id="refactoring-drawing">Refactoring Drawing</h3>

<p>There&rsquo;s still something not right, but it will take a few more objects in the scene to show it. <code>draw_view</code> is already a repetitive hardcoded mess and it&rsquo;s been on the &ldquo;to be refactored&rdquo; list for a while, so now seems a good time to clean it up before I add to the mess.</p>

<p><code>draw_view</code> performs a series of transformations and state settings for each object drawn. I want to move to a more data-driven design, with each object in the simulated world represented by a data structure specifying the needed transformations and settings. Eventually, these structures may become full-fledged blessed objects, but I&rsquo;ll start simple for now.</p>

<p>I initialized the data structures in <code>init_objects</code>:</p>

<pre><code>sub init_objects
{
    my $self = shift;

    my @objects = (
        {
            draw        =&gt; \&amp;draw_axes,
        },
        {
            lit         =&gt; 1,
            color       =&gt; [ 1, 1,  1],
            position    =&gt; [12, 0, -4],
            scale       =&gt; [ 2, 2,  2],
            draw        =&gt; \&amp;draw_cube,
        },
        {
            lit         =&gt; 1,
            color       =&gt; [ 1, 1, 0],
            position    =&gt; [ 4, 0, 0],
            orientation =&gt; [40, 0, 0, 1],
            scale       =&gt; [.2, 1, 2],
            draw        =&gt; \&amp;draw_cube,
        },
    );

    $self-&gt;{world}{objects} = \@objects;
}
</code></pre>

<p>Each hash includes the arguments to the various transformations to apply to it, along with a reference to the routine that actually draws the object and a flag indicating whether the object should be subject to OpenGL lighting. The object array then becomes a new part of the world hash for easy access later.</p>

<p>I called this routine at the end of <code>init</code> as usual:</p>

<pre><code>    $self-&gt;init_objects;
</code></pre>

<p>I also replaced <code>draw_view</code> with a version that interprets the data into a series of OpenGL calls:</p>

<pre><code>sub draw_view
{
    my $self    = shift;

    my $objects = $self-&gt;{world}{objects};

    foreach my $o (@$objects) {
        $o-&gt;{lit} ? glEnable (GL_LIGHTING)
                  : glDisable(GL_LIGHTING);

        glColor(@{$o-&gt;{color}})        if $o-&gt;{color};

        glPushMatrix;

        glTranslate(@{$o-&gt;{position}}) if $o-&gt;{position};
        glRotate(@{$o-&gt;{orientation}}) if $o-&gt;{orientation};
        glScale(@{$o-&gt;{scale}})        if $o-&gt;{scale};

        $o-&gt;{draw}-&gt;();

        glPopMatrix;
    }
}
</code></pre>

<p>The new routine iterates over the world object array, performing each requested operation. It either skips or defaults any unspecified values. First up is the choice to enable or disable <code>GL_LIGHTING</code>, followed by setting the current color if requested. The code next checks for and applies the usual transformations and finally, calls the object draw routine.</p>

<p>For simplicity and robustness, I&rsquo;ve unconditionally wrapped the transformations and draw routine in a matrix push/pop pair rather than trying to detect whether they need the push and pop. OpenGL implementations tend to be highly optimized with native code, and any detection I did would be Perl. Chances are good that such an &ldquo;optimization&rdquo; would instead slow things down. This way, my code stays cleaner and even a misbehaving draw routine that performed transformations internally without cleaning up afterwards will not affect the next object drawn.</p>

<p>A quick test showed that this refactored version still worked. Now I could add a few more objects to demonstrate the remaining lighting issue. I specified several more boxes programmatically by inserting a new loop before the end of <code>init_objects</code>:</p>

<pre><code>    foreach my $num (1 .. 5) {
        my $scale =   $num * $num / 15;
        my $pos   = - $num * 2;
        push @objects, {
            lit         =&gt; 1,
            color       =&gt; [ 1, 1,  1],
            position    =&gt; [$pos, 2.5, 0],
            orientation =&gt; [30, 1, 0, 0],
            scale       =&gt; [1, 1, $scale],
            draw        =&gt; \&amp;draw_cube,
        };
    }

    $self-&gt;{world}{objects} = \@objects;
}
</code></pre>

<p>For each box, just two parameters vary: position and Z scale. I chose the position to set each box next to the last, progressing along the -X axis. The scale is set so that the height and width of each box remains the same, but the depths vary from very shallow for the first box to fairly deep for the last.</p>

<p>The loop specifies five boxes in total and begins by calculating the X position and Z scaling (depth) for the current box. The next few lines simply create a new hash for the new box and push it onto the object array.</p>

<p>Finally, there was one last change&ndash;the bright world light overwhelms the problematic effect from the flashlight. This is an easy fix; I commented out the line that enables it:</p>

<pre><code>sub set_world_lights
{
    glLight(GL_LIGHT0, GL_POSITION, 0.0, 0.0, 1.0, 0.0);

#     glEnable(GL_LIGHT0);
}
</code></pre>

<p>By panning to the left across the scene until the viewpoint is in front of the new boxes, the problem becomes obvious:</p>

<p><img src="/images/_pub_2005_02_17_3d_engine/step062.png" width="400" height="400" /></p>

<p>The brightness of the lighting varies immensely depending on the depth of the box! This rather unintuitive outcome is an unfortunate side effect of how OpenGL must handle normals. A normal specifies the direction of the surface associated with a vertex. If a rigid object rotates, its surfaces rotate, so all of its normals must rotate as well. OpenGL handles this by transforming normal coordinates as it would vertex coordinates. This runs into trouble with any transformations other than translation and rotation. OpenGL calculations assume that normals are normalized (have unit length). Scaling the normal breaks this assumption and results in the effect seen above.</p>

<p>To fix this, I told OpenGL that normals may not have unit length and that OpenGL must normalize them before other calculations are performed. This is not the default behavior because of the performance cost of normalizing each vector. An application that can ensure normals are always unit length after transformation can keep the default and run a little faster. I want to allow arbitrary scaling of objects, so I enabled automatic normalization with another line at the end of <code>prep_frame</code>:</p>

<pre><code>    glEnable(GL_NORMALIZE);
</code></pre>

<p>That fixed the problem:</p>

<p><img src="/images/_pub_2005_02_17_3d_engine/step063.png" width="400" height="400" /></p>

<p>With that bug killed, I reenabled the world light by uncommenting the <code>glEnable</code> line in <code>set_world_lights</code>:</p>

<pre><code>sub set_world_lights
{
    glLight(GL_LIGHT0, GL_POSITION, 0.0, 0.0, 1.0, 0.0);

    glEnable(GL_LIGHT0);
}
</code></pre>

<h3 id="conclusion">Conclusion</h3>

<p>During this article I&rsquo;ve moved pretty quickly, covering screenshots, movement of the viewpoint, the beginnings of lighting in OpenGL, and subdivided faces for the boxes. Along the way, I took the chance to refactor <code>draw_view</code> into a more data-driven design and made the scene a little more interesting.</p>

<p>Unfortunately, these new changes have slowed things down quite a bit. OpenGL has several features that can improve performance considerably. Next time, I&rsquo;ll talk about one of the most powerful of these: display lists. I&rsquo;ll also introduce basic font handling and run with the performance theme by adding an FPS display to the engine.</p>

<p>Until next time, have fun and keep hacking!</p>

              </article>
              <p><strong>Tags</strong></p>
              <div class="tags">
                <div class="category"><a href="/categories/games">games</a></div>
                
                  <div class="tag"><a href="/tags/opengl-lighting">opengl-lighting</a></div>
                
                  <div class="tag"><a href="/tags/opengl-tutorial">opengl-tutorial</a></div>
                
                  <div class="tag"><a href="/tags/opengl-viewpoint">opengl-viewpoint</a></div>
                
                  <div class="tag"><a href="/tags/perl-3d">perl-3d</a></div>
                
                  <div class="tag"><a href="/tags/perl-game-programming">perl-game-programming</a></div>
                
                  <div class="tag"><a href="/tags/perl-graphics">perl-graphics</a></div>
                
                  <div class="tag"><a href="/tags/perl-opengl">perl-opengl</a></div>
                
                  <div class="tag"><a href="/tags/perl-sdl">perl-sdl</a></div>
                
              </div>
            </div>
            
              
                
<div class="row" id="author-bio-geoff-broadwell">
  <div class="col-sm-2">
    
    <a href="/authors/geoff-broadwell/"><div class="circle-avatar" style="background-image:url(/images/site/avatar.png)"></div></a>
  </div>
  <div class="col-sm-10">
    <a href="/authors/geoff-broadwell/"><h3>Geoff Broadwell</h3></a>
    <p></p>
    <h5><a href="/authors/geoff-broadwell/">Browse their articles</a></h5>
  </div>
</div>

            
            <div class="row">
              <h3>Feedback</h3>
              <p>Something wrong with this article? Help us out by opening an issue or pull request on <a href="https://github.com/tpf/perldotcom/blob/master/content/legacy/_pub_2005_02_17_3d_engine.md">GitHub</a></p>
            </div>
          </div>
          <div class="col-md-3">
            <div class="latest-sidebar">

  <div class="row">
    <div class="col-sm-12 centering">
      <span style="font-size:1.8em" class="antonio txt-blue-major">OUR LATEST ARTICLES</span>
    </div>
  </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/the-perl-admbassador-curtis-poe/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/the-perl-ambassador-curtis-poe/curtis-poe.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>The Perl Ambassador: Curtis &#39;Ovid&#39; Poe</h6>
          <p style="line-height:1"><small>The person behind the news of Perl</small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/a-tour-with-net-ftp/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/a-tour-with-net-ftp/thumb_kidyes.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>A tour with Net::FTP</h6>
          <p style="line-height:1"><small>How to write an FTP client in Perl</small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/shortcode_test/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/author/brian-d-foy.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>shortcode_test</h6>
          <p style="line-height:1"><small></small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/listen-to-larry-wall-s-state-of-the-onion-2000-on-youtube/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/listen-to-larry-wall-s-state-of-the-onion-2000-on-youtube/thumb_larry-wall.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>Listen to Larry Wall&#39;s State of the Onion 2000 on YouTube</h6>
          <p style="line-height:1"><small></small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/announcing-perl-7/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/announcing-perl-7/thumb_seven_on_blue_wall.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>Announcing Perl 7</h6>
          <p style="line-height:1"><small>Perl 5 with modern defaults</small></p>
      </div>
        </a>
    </div>
  
</div>
<div class="row" style="margin-top:20px">
  <div class="col-sm-12 centering">
  <script async src="/widget/toplinks/toplinks.js" type="text/javascript"></script>
    <div id="toplinks"></div>
  </div>
</div>

<div class="row" style="margin-top:20px">
  <div class="col-sm-12 centering">
    <a class="twitter-timeline" data-height="640" data-dnt="true" data-theme="dark" href="https://twitter.com/perlfoundation?ref_src=twsrc%5Etfw">Tweets by perlfoundation</a> <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
  </div>
</div>

<div class="row" style="margin-top:20px">
  <div class="col-sm-12 centering">
    <script src="https://www.reddit.com/r/perl/hot/.embed?limit=10&t=all" type="text/javascript"></script>
  </div>
</div>



          </div>
        </div>
      </div>
    </section>
  </section>
<script>
 
var tables, i;
tables = document.getElementsByTagName('table');
for (i=0;i<tables.length;i++) {
  tables[i].className = 'table table-striped';
}
</script>
<div class="push"></div>
<div class="footer">
  <div class="container">
    <div class="row">
      <div class="col-md-1">
        <h5>Site Map</h5>
        <ul>
        <li><a href="/">Home</a></li>
        <hr>
        <li><a href="/about">About</a></li>
        <hr>
        <li><a href="/authors">Authors</a></li>
        <hr>
        <li><a href="/categories">Categories</a></li>
        <hr>
        <li><a href="/tags">Tags</a></li>
        <hr>
        </ul>
      </div>
      <div class="col-md-3">
        <h5>Contact Us</h5>
        <p>To get in touch, send an email to: perl.com-editor@perl.org</p>
        <p><a href="https://perl.org">
              <img src="/images/site/perl-onion_20.png" alt="Perl Onion"></a>
          <a href="https://twitter.com/intent/follow?screen_name=perlfoundation">
              <img src="/images/site/twitter_20.png" alt="twitter"></a>
          <a href="/index.xml" /><img src="/images/site/rss_20.png" alt="rss"></a>
          <a href="https://github.com/tpf/perldotcom">
              <img src="/images/site/github_light_20.png" alt="GitHub logo"></a></p>
      </div>
      <div class="col-md-2">
          <h5>License</h5>
          <p>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc/3.0/">Creative Commons Attribution-NonCommercial 3.0 Unported License</a>.</p>
          <p><a rel="license" href="https://creativecommons.org/licenses/by-nc/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/3.0/88x31.png" /></a></p>
      </div>
      <div class="col-md-5">
          <h5>Legal</h5>
          <p>Perl.com and the authors make no representations with respect to the accuracy or completeness of the contents of all work on this website and specifically disclaim all warranties, including without limitation warranties of fitness for a particular purpose. The information published on this website may not be suitable for every situation. All work on this website is provided with the understanding that Perl.com and the authors are not engaged in rendering professional services. Neither Perl.com nor the authors shall be liable for damages arising herefrom.</p>
      </div>
    </div>
  </div>
</div>
<script src="/javascript/jquery.min.js"></script>
<script src="/javascript/bootstrap.min.js"></script>
<script data-no-instant>document.write('<script src="/livereload.js?port=1313&mindelay=10"></' + 'script>')</script></body>
</html>

