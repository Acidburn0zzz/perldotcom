<!DOCTYPE html>
<html lang="en-us">
  <head>
  <title> Power Regexps, Part II </title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content=" In the previous article, we looked at some of the more intermediate features of regular expressions, including multiline matching, quoting, and interpolation. This time, we&#39;re going to look at more-advanced features. We&#39;ll also look at some modules that can..."/>
  <meta name="robots" content="index, follow">
  <meta name="google-site-verification" content="TZowffo_LX2mmsw2DbeNNbukCMnIOA8T-6CMJPiYllI" />

<meta property="twitter:card" content="summary">
<meta property="twitter:site" content="@PerlFoundation">
<meta property="og:url" content="http://localhost:1313/pub/2003/07/01/regexps.html/" />
<meta property="og:title" content="Power Regexps, Part II" />
<meta property="og:description" content=" In the previous article, we looked at some of the more intermediate features of regular expressions, including multiline matching, quoting, and interpolation. This time, we&#39;re going to look at more-advanced features. We&#39;ll also look at some modules that can...">
<meta property="og:site_name" content="Perl.com" />

<meta property="og:type" content="article" />
<meta property="og:article:published_time" content="2003-07-07T07:07:07Z" />
<meta property="og:image" content="http://localhost:1313/images/author/simon-cozens.jpg" />
<meta property="og:article:tag" content="regexps-regular-expressions" />


  <link rel="icon" href="/favicon.ico">
  <link href="/article/index.xml" rel="alternate" type="application/rss+xml" title="Perl.com - programming news, code and culture" />
  <link href="/article/index.xml" rel="feed" type="application/rss+xml" title="Perl.com - programming news, code and culture" />
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" type="text/css" href="/css/perldotcom.css"/>


<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-50555-22', 'auto');
ga('create', 'UA-85734801-2', 'auto', 'editor');
ga('send', 'pageview');
ga('editor.send', 'pageview');
</script>

</head>
<body>

<div class="container-fluid full-wdith antonio">
 <div class="row">
  <div class="navbar-inverse" style="border-radius:none !important" role="navigation">
    <div class="container-fluid">
      <ul class="nav navbar-nav pull-right follow">
          <li>MORE:</li>
          <li><a href="https://perl.org">
              <img src="/images/site/perl-onion_20.png" alt="Perl Onion"></a><li>
          <li><a href="https://twitter.com/intent/follow?screen_name=perlfoundation">
              <img src="/images/site/twitter_20.png" alt="twitter"></a><li>
          <li><a href="/article/index.xml" />
              <img src="/images/site/rss_20.png" alt="rss"></a></li>
          <li><a href="https://github.com/tpf/perldotcom" />
              <img src="/images/site/github_light_20.png" alt="GitHub logo"></a></li>
      </ul>
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
          <a class="navbar-nav" href="/">
            <div class="header-logo">Perl.com</div>
          </a>
      </div>
      <div class="navbar-collapse collapse">
        <ul class="nav navbar-nav">
          <li><a href="/about">
              <div class="circle">
                <img src="/images/site/perl-camel.png" alt="" />
              </div>
                  &nbsp;&nbsp;ABOUT</a>
          </li>
          <li><a href="/authors">
              <div class="circle">
                  <span class="glyphicon glyphicon-user txt-blue-major" aria-hidden="true"></span>
              </div>
                  &nbsp;&nbsp;AUTHORS</a>
          </li>
          <li><a href="/categories">
              <div class="circle">
                  <span class="glyphicon glyphicon-folder-open txt-blue-major" aria-hidden="true"></span>
              </div>
                  &nbsp;&nbsp;CATEGORIES</a>
          </li>
          <li><a href="/tags">
              <div class="circle">
                <span class="txt-blue-major" aria-hidden="true"><strong>#</strong></span>
              </div>
                  &nbsp;&nbsp;TAGS</a>
          </li>
          <li>
            <form class="search" name="ddg" action="https://duckduckgo.com/" method="get">
              <input type="text" name ="q" placeholder="SEARCH" />
              <input type="hidden" value="perl.com" name="sites" />
            </form>
          </li>
        </ul>
      </div>
    </div>
  </div>
 </div>
</div>


  <section id="content" role="main">
    <section class="entry-content">
      <div class="container">
        <div class="row">
          <div class="col-md-9">
            <div class="row">
              <article class="fulltext">
              <h1 class="blog-post-title">Power Regexps, Part II</h1>
              <p class="blog-post-meta">Jul 1, 2003 by
              
              
                
                
                <a href="#author-bio-simon-cozens">Simon Cozens</a>
              
              </p>
              <img alt="" src=""/>
                

<p>In the previous article, we looked at some of the more intermediate features of regular expressions, including multiline matching, quoting, and interpolation. This time, we&rsquo;re going to look at more-advanced features. We&rsquo;ll also look at some modules that can help us handle regular expressions.</p>

<h2 id="span-id-look-forward-look-back-look-forward-look-back-span"><span id="look_forward,_look_back">Look Forward, Look Back</span></h2>

<p>Perhaps the most misunderstood facility of regular expressions are the lookahead and lookbehind operators; let&rsquo;s begin with the simplest, the positive lookahead operator.</p>

<p>This operator, spelled <code>(?= )</code>, attempts to match a pattern, and if successful, promptly forgets all about it. As its name implies, it peeks forward into the string to see whether the next part of the string matches the pattern. For instance:</p>

<pre><code>    $a=&quot;13.15    Train to London&quot;; 
    $a=~ /(?=.*London)([\d\.]+)/
</code></pre>

<p>This is perhaps an inefficient way of writing:</p>

<pre><code>    $a =~ /([\d\.]+).*London/;
</code></pre>

<p>and it can be read as &ldquo;See if this string has &lsquo;London&rsquo; in it somewhere, and if so, capture a series of digits or periods.&rdquo;</p>

<p>Here&rsquo;s an example of it in real-life code; I want to turn some file names into names of Perl modules. I&rsquo;ll have a name like <em>/Library/Perl/Mail/Miner/Recogniser/Phone.pm</em> - this is part of my <code>Mail::Miner</code> module, so I can guarantee that the name of the module will start with <code>Mail/Miner</code> - and I want to get <code>Mail::Miner::Recogniser::Phone</code>. Here&rsquo;s the code that does it:</p>

<pre><code>    our @modules = map {
        s/.pm$//;
        s{.*(?=Mail/Miner)}{};
        join &quot;::&quot;, splitdir($_)
    } @files;
</code></pre>

<p>We look at each of our files, and first take off the <code>.pm</code> from the end. Now what we need to do is remove everything before the <code>Mail/Miner</code> portion, stripping off <em>/Library/Perl</em> or whatever our path happens to be. Now we could write this as:</p>

<pre><code>    s{.*Mail/Miner}{Mail/Miner};
</code></pre>

<p>removing everything which appears before <code>Mail/Miner</code> and then the text <code>Mail/Miner</code> itself, and then replacing all that with <code>Mail/Miner</code> again. This is obviously horribly long-winded, and it&rsquo;s much more natural to think of this in turns of &ldquo;get rid of everything but stop when you see <code>Mail/Miner</code>&rdquo;. In most cases, you can think of <code>(?= )</code> as meaning &ldquo;up to&rdquo;.</p>

<p>Similar but subtly different is the negative counterpart <code>(?! )</code>. This again peeks forward into the string, but ensures that it <strong>doesn&rsquo;t</strong> match the pattern. A good way to think of this is &ldquo;so long as you don&rsquo;t see&rdquo;. Damian Conway&rsquo;s <code>Text::Autoformat</code> contains some code for detecting quoted lines of text, such as may be found in an e-mail message:</p>

<pre><code>    % Will all this regular expression scariness go away in 
    % Perl 6?

    Yes, definitely; we're replacing it with a completely different set
    of scariness.
</code></pre>

<p>Here the first two lines are quoted, and the expressions that check for this look like so:</p>

<pre><code>    my $quotechar = qq{[!#%=|:]};
    my $quotechunk = qq{(?:$quotechar(?![a-z])|[a-z]*&gt;+)};
</code></pre>

<p><code>$quotechar</code> contains the characters that we consider signify a quotation, and <code>$quotechunk</code> has two options for what a quotation looks like. The second is most natural: a greater-than sign, possibly preceded by some initials, such as produced by the popular Supercite <code>emacs</code> package:</p>

<pre><code>    SC&gt; You're talking nonsense, you odious little gnome!
</code></pre>

<p>The left-hand side of the alternation in <code>$quotechunk</code> is a little more interesting. We look for one of our quotation characters, such as <code>%</code> as in the example above, but then we make sure that the next character we see is not alphabetic; this may be a quotation:</p>

<pre><code>    % I think that all right-thinking people...
</code></pre>

<p>but this almost certainly isn&rsquo;t</p>

<pre><code>    %options = ( verbose =&gt; 1, debug =&gt; 0 );
</code></pre>

<p>The <code>(?!)</code> acts as a &ldquo;make sure you don&rsquo;t see&rdquo; directive.</p>

<p>The mistake everyone makes at least once with this is to assume you can say:</p>

<pre><code>    /(?!foo)bar/;
</code></pre>

<p>and wonder why it matches against <code>foobar</code>. After all, we&rsquo;ve made sure we didn&rsquo;t see a <code>foo</code> before the <code>bar</code>, right? Well, not exactly. These are lookahead operators, and so can&rsquo;t be used to find things &ldquo;before&rdquo; anything at all; they&rsquo;re only used to determine what we can or can&rsquo;t see after the current position. To understand why this is wrong, imagine what it would mean if it were a positive assertion:</p>

<pre><code>    /(?=foo)bar/;
</code></pre>

<p>This means &ldquo;are the next three characters we see <code>foo</code>? If so, the next three characters we see are <code>bar</code>&rdquo;. This is obviously never going to happen, since a string can&rsquo;t contain both <code>foo</code> and <code>bar</code> at the same position and the same time. (Although I believe Damian has a paper on that.) So the negative version means &ldquo;are the next three characters we see <strong>not</strong> <code>foo</code>? Then match <code>bar</code>&rdquo;. <code>foo</code> is not <code>bar</code>, so this matches any <code>bar</code>. What was probably meant was a lookbehind assertion, which we will look at imminently.</p>

<p>Now we&rsquo;ve seen the two forward-facing assertions, we can turn (ha, ha) to the backward-facing assertions, positive and negative lookbehind. There&rsquo;s one important difference between these and their forward-facing counterparts; while lookahead operators can contain more or less any kind of regular expression pattern, for reasons of implementation the lookbehind operators must have a fixed width computable at compile time. That is, you&rsquo;re not allowed to use any indefinite quantifiers in your subpatterns.</p>

<p>The positive lookbehind assertion is <code>(?&lt;=)</code>, and the only thing you need to know about it is that it&rsquo;s so rare I can&rsquo;t remember the last time I saw it in real code. I don&rsquo;t think I&rsquo;ve ever used it, except possibly in error. If you think you want to use one of these, then you almost certainly need to rethink your strategy. Here&rsquo;s a quick example, though, from <code>IPC::Open3</code>:</p>

<pre><code>    $@ =~ s/(?&lt;=value attempted) at .*//s;
</code></pre>

<p>The context for this is that we&rsquo;ve just done the equivalent of</p>

<pre><code>    eval { $_[0] = ... };
</code></pre>

<p>and if someone maliciously passes a constant value to the subroutine, we want to through the <code>Modification of a read-only value attempted</code> error back in their face. We check we&rsquo;re seeing the error we expect, then strip off the <code>at .../IPC/Open3.pm, line 154</code> part of the message so that it can be fed to <code>croak</code>. The less Tom-Christianseny way to do this would be something like:</p>

<pre><code>    croak &quot;You fed me bogus parameters&quot; if $@ =~ /attempted/;
</code></pre>

<p>The negative lookbehind assertion, on the other hand, is considerably more common; this is the answer to our &ldquo;<code>bar</code> not preceded by <code>foo</code>&rdquo; problem of the previous section.</p>

<pre><code>    /(?!&lt;foo)bar/;
</code></pre>

<p>This will match <code>bar</code>, peeking backward into the string to make sure it doesn&rsquo;t see <code>foo</code> first. To take another example, suppose we&rsquo;re preparing some text for sending over the network, and we want to make sure that all the line feeds (<code>\n</code>) have carriage returns (<code>\r</code>) before them. Here&rsquo;s the truly lazy way to do it:</p>

<pre><code>    # Make sure there's an \r in there somewhere
    s{\n}  {\r\n}g;
    # And then strip out duplicates
    s{\r\r}{\r}  g;

This is fine (if somewhat inefficient) unless it's OK for two carriage
returns to appear without a line feed in the way. Here's the finesse:

    s/(?&lt;!\r)\n/\r\n/g;
</code></pre>

<p>If you see a line feed that is <strong>not</strong> preceded by a carriage return, then stick a carriage return in there &ndash; much cleaner, and much more efficient.</p>

<h2 id="span-id-split-g-and-other-shenanigans-split-g-and-other-shenanigans-span"><span id="split,_//g_and_other_shenanigans"><code>split</code>, <code>//g</code> and other shenanigans</span></h2>

<p>In the previous article, we had a nice piece of multiline, formatted data, such as one might expect to parse with Perl:</p>

<pre><code>    Name: Mark-Jason Dominus
    Occupation: Perl trainer
    Favourite thing: Octopodes

    Name: Simon Cozens
    Occupation: Hacker
    Favourite thing: Sleep
</code></pre>

<p>Now, there&rsquo;s a boring way to parse this. If you&rsquo;re coming from a C or Java background, then you might try:</p>

<pre><code>    my $record = {}
    my @records;
    for (split /\n/, $text {
        chomp;
        if (/([^:]+): (.*)/) {
            $record-&gt;{$1} = $2;
        } elsif ($_ =~ /^\s*$/) {
            # Blank line =&gt; end of current record
            push @records, $record;
            $record = {};
        } else {
            die &quot;Wasn't expecting to see '$_' here&quot;;
        }
    }
</code></pre>

<p>And, of course, this will work. But there&rsquo;s several more Perl-ish solutions that this. When you know the fields provided by your data, it&rsquo;s rather nice to have a regular expression that reflects the data structure:</p>

<pre><code>    while ($data =~ /Name:\s(.*)\n
                     Occupation:\s(.*)\n 
                     Favourite.*:\s(.*)/gx) {
        push @records, { name =&gt; $1, occupation =&gt; $2, favourite =&gt; $3 }
    }
</code></pre>

<p>Here we use the <code>/g</code> modifier, which allows us to resume the match from where it last left off.</p>

<p>If we don&rsquo;t know the fields while we&rsquo;re writing our program, then we&rsquo;ll have to break the process up into two stages. First, we extract individual records: records are delimited by a blank line:</p>

<pre><code>    my @texts = split /\n\s*\n/, $text;
</code></pre>

<p>And then for each record, we can either use the <code>/g</code> trick again, or simply split each record into lines. I prefer the latter, for reasons you&rsquo;ll see in a second:</p>

<pre><code>    for (@texts) {
        my $record = {};
        for (split /\n/, $_) {
            /([^:]+): (.*)/;
            $record-&gt;{$1} = $2;
        }
        push @records, $record;
    }
</code></pre>

<p>This is not dissimilar from the initial solution, but it allows us to make some interesting improvements. For starters, when you see code that transforms data with a <code>for</code> loop, you should wonder whether it could be better written with a <code>map</code> statement. This goes double if you&rsquo;re using <code>push</code> inside the <code>for</code> loop as we are here. So this version is a natural evolution:</p>

<pre><code>    @records = map {
        my $record = {};
        for (split /\n/, $_) { 
            /([^:]+): (.*)/;
            $record-&gt;{$1} = $2;
        }
        $record;
    } split /\n\s*\n/, $text;
</code></pre>

<p>And we can actually do away with the inner <code>for</code> loop too:</p>

<pre><code>    @records = map {
        {
            map { /([^:]+): (.*)/ and ($1 =&gt; $2) } split /\n/, $_
        }
    } split /\n\s*\n/, $text;
</code></pre>

<p>But if we&rsquo;re prepared to be a little lax about trailing whitespace, there&rsquo;s actually an even nicer way to do it, using the one thing that everyone forgets about <code>split</code>: if your <code>split</code> pattern contains parentheses, then the captured text is inserted into the list returned by <code>split</code>. That is, the following code:</p>

<pre><code>    split( /(\W+)/, &quot;perl-5.8.0.tar.gz&quot;)
</code></pre>

<p>will produce the list</p>

<pre><code>    (&quot;perl&quot;, &quot;-&quot;, &quot;5&quot;, &quot;.&quot;, &quot;8&quot;, &quot;.&quot;, &quot;0&quot;, &quot;.&quot;, &quot;tar&quot;, &quot;.&quot;, &quot;gz&quot;)
</code></pre>

<p>So we can actually use the field name, colon and space at the start of each line as the <code>split</code> expression itself:</p>

<pre><code>    split /^([^:]+):\s*/m
</code></pre>

<p>There is a slight problem with this idea - because the first thing in each record is delimeter we&rsquo;re looking for, the first thing returned by <code>split</code> will be an empty string. But we can easily get around this by adding another <code>undef</code> to provide a fake <code>undef =&gt; ''</code> hash element. This allows us to reduce the parser code to:</p>

<pre><code>    @records = map { 
                     { undef, split /^([^:]+):\s*/m, $_ } 
                   } split /\n\s*\n/, $text;
</code></pre>

<p>It may not be pretty, but it&rsquo;s quick and it works.</p>

<p>Of course, you may also use lookahead and lookbehind assertions with <code>split</code>; I sometimes use the following code to break a string into tokens:</p>

<pre><code>    split /(?&lt;=\W)|(?=\W)/, $string;
</code></pre>

<p>This is almost the same as</p>

<pre><code>    split /(\W)/, $string
</code></pre>

<p>but with a subtle difference. Again, as Perl wants to see a nonword character as a delimiter, it will return an empty string between two adjacent nonwords:</p>

<pre><code>    split /(\W)/, '$foo := $bar';
    # '', '$', 'foo', ' ', '', ':', '', '=', '', ' ', '', '$', 'bar'
</code></pre>

<p>Splitting on a word boundary goes too much the other way:</p>

<pre><code>    split /\b/, '$foo := $bar';
    # '$', 'foo', ' := $', 'bar'
</code></pre>

<p>And so it turns out that we want to cleave the string where we&rsquo;ve just seen a nonword character, or if we&rsquo;re about to see one:</p>

<pre><code>    split /(?&lt;=\W)|(?=\W)/, $string;
    # '$', 'foo', ' ', ':', '=', ' ', '$', 'bar'
</code></pre>

<p>And this gives us the sort of tokenisation we want.</p>

<h2 id="span-id-regexp-modules-regexp-modules-span"><span id="regexp_modules">Regexp Modules</span></h2>

<p>Now, though, we are getting into the sort of regular expressions that are not written lightly, and we may need some help constructing and debugging these expressions. Thankfully, there are plenty of modules which make regexp handling much easier for us.</p>

<h3 id="span-id-re-re-span"><span id="re">re</span></h3>

<p>The <code>re</code> module is as invaluable as it is obscure. It&rsquo;s one of those hidden treasures of the Perl core that Casey was talking about last month. As well as turning on two features of the regular expression engine, tainting subexpressions and evaluated assertions, it provides a debugging facility that allows you to watch your expression being compiled and executed.</p>

<p>Here&rsquo;s a relative simple expression:</p>

<pre><code>    $a =~ /([^:]+):\s*(.*)/;
</code></pre>

<p>When this code is run under <code>-Mre=debug</code>, then the following will be printed when the regexp is compiled:</p>

<pre><code>    Compiling REx `([^:]+):\s*(.*)'
    size 25 first at 4
       1: OPEN1(3)
       3:   PLUS(13)
       4:     ANYOF[\0-9;-\377](0)
      13: CLOSE1(15)
      15: EXACT &lt;:&gt;(17)
      17: STAR(19)
      18:   SPACE(0)
      19: OPEN2(21)
      21:   STAR(23)
      22:     REG_ANY(0)
      23: CLOSE2(25)
      25: END(0)
</code></pre>

<p>This tells us the instructions for the little machine that the regular expression compiler creates: it should first open a bracket, then go into a loop (<code>PLUS</code>) finding characters that are <code>ANYOF</code> character zero through to <code>9</code> and <code>;</code> through to character 255 - that is, everything apart from a <code>:</code>. Then we close the bracket, look for a specific character, and so on. The numbers in brackets after each instruction are the line number to jump to on completion; then the <code>PLUS</code> loop exits, it should go on to line 13, <code>CLOSE1</code> and so on.</p>

<p>Next when we try to run this match against some text:</p>

<pre><code>    $a = &quot;Name: Mark-Jason Dominus&quot;;
</code></pre>

<p>It will first tell us something about the optimizations it performs:</p>

<pre><code>    Guessing start of match, REx `([^:]+):\s*(.*)' against `Name: ...'
    Found floating substr `:' at offset 4...
    Does not contradict STCLASS...
    Guessed: match at offset 0
</code></pre>

<p>What this means is that it has found the constant element <code>:</code> in the regular expression, and tries to locate that in the string, and then work backward to find out where it should start the match. Since the <code>:</code> is at position four in our string, it will go on to deduce that the match should start at the beginning and&hellip;</p>

<pre><code>    Matching REx `([^:]+):\s*(.*)' against `Name: Mark-Jason Dominus'
    Setting an EVAL scope, savestack=3
    0 &lt;&gt; &lt;Name: Mark-J&gt;    |  1:  OPEN1
    0 &lt;&gt; &lt;Name: Mark-J&gt;    |  3:  PLUS
    ANYOF[\0-9;-\377] can match 4 times out of 32767...
</code></pre>

<p>The <code>[^:]</code> can match four times, since it knows there are four things that are not colons there.</p>

<p>The <code>re</code> module is absolutely essential for heavy-duty study of how the regular expression engine works, and why it doesn&rsquo;t do what you think it should.</p>

<h3 id="span-id-yape-regex-explain-yape-regex-explain-span"><span id="yape::regex::explain">YAPE::Regex::Explain</span></h3>

<p>The description given by <code>re</code> is a little low-level for some people; well, most people. <code>YAPE::Regex::Explain</code> aims to put the explanation at a much higher level; for instance,</p>

<pre><code>     % perl -MYAPE::Regex::Explain -e 'print 
       YAPE::Regex::Explain-&gt;new(qr/(?&lt;=\W)|(?=\W)/)-&gt;explain'
</code></pre>

<p>will produce quite a verbose explanation of the regular expression like so:</p>

<pre><code>    ----------------------------------------------------------------------
    (?-imsx:                 group, but do not capture (case-sensitive)
                             (with ^ and $ matching normally) (with . not
                             matching \n) (matching whitespace and #
                             normally):
    ----------------------------------------------------------------------
      (?&lt;=                     look behind to see if there is:
    ----------------------------------------------------------------------
        \W                       non-word characters (all but a-z, A-Z,
                                 0-9, _)
    ----------------------------------------------------------------------
    ...
</code></pre>

<h3 id="span-id-graphviz-regex-graphviz-regex-span"><span id="graphviz::regex">GraphViz::Regex</span></h3>

<p>I find that one of the best ways to debug and understand a complex procedure is to draw a picture. <code>GraphViz::Regex</code> uses the <code>graphviz</code> visualization library to draw a state machine diagram for a given regular expression:</p>

<pre><code>    use GraphViz::Regex;

    my $regex = '(([abcd0-9])|(foo))';

    my $graph = GraphViz::Regex-&gt;new($regex);
    print $graph-&gt;as_png;
</code></pre>

<h3 id="span-id-regexp-common-regexp-common-span"><span id="regexp::common">Regexp::Common</span></h3>

<p>So much for explaining complicated regular expressions; what about generating them? The <code>Regexp::Common</code> module aims to be a repository for all kinds of commonly needed regular expressions, such as URIs, balanced texts, domain names and IP addresses. The interface is a little freaky, but it can hugely help to clarify complex regexps:</p>

<pre><code>    my $ts = qr/\d+:\d+:\d+\.\d+/;
    $tcpdump =~ /$ts ($RE{net}{IPv4}) &gt; ($RE{net}{IPv4}) : (tcp|udp) (\d+)/;
</code></pre>

<h3 id="span-id-text-balanced-text-balanced-span"><span id="text::balanced">Text::Balanced</span></h3>

<p>Finally, one particularly common family of things to match for are quoted, parenthesised or tagged text. Damian&rsquo;s <code>Text::Balanced</code> module helps produce both regular expressions and subroutines to match and extract balanced text sequences. For instance, we can create a regular expression for matching double-quoted strings like so:</p>

<pre><code>    use Text::Balanced qw(gen_delimited_pat);
    $pat = gen_delimited_pat(q{&quot;})
    # (?:\&quot;(?:[^\\\&quot;]*(?:\\.[^\\\&quot;]*)*)\&quot;)
</code></pre>

<p>This pattern will match quoted text, but will also be aware of escape sequences like <code>\&quot;</code> and <code>\\</code>, and hence not break off in the middle of</p>

<pre><code>    &quot;\&quot;So\&quot;, he said, \&quot;How about lunch?\&quot;&quot;
</code></pre>

<p><code>Text::Balanced</code> also contains routines for extracting tagged text, finding balanced pairs of parentheses, and much more.</p>

<h2 id="span-id-summary-summary-span"><span id="summary">Summary</span></h2>

<p>We&rsquo;ve looked at some slightly more-complex features of regular expressions, and shown how we can use these to slice and dice text with Perl. As these regexes get more complicated, the need for tools to help us debug them increases; and so we&rsquo;ve looked also at <code>re</code>, <code>YAPE</code> and <code>GraphViz::Regex</code>.</p>

<p>Finally, the <code>Regexp::Common</code> and <code>Text::Balanced</code> modules help us create complex regular expressions of our own.</p>

              </article>
              <p><strong>Tags</strong></p>
              <div class="tags">
                <div class="category"><a href="/categories/regular-expressions">regular-expressions</a></div>
                
                  <div class="tag"><a href="/tags/regexps-regular-expressions">regexps-regular-expressions</a></div>
                
              </div>
            </div>
            
              
                
<div class="row" id="author-bio-simon-cozens">
  <div class="col-sm-2">
    
    <a href="/authors/simon-cozens/"><div class="circle-avatar" style="background-image:url(/images/author/simon-cozens.jpg)"></div></a>
  </div>
  <div class="col-sm-10">
    <a href="/authors/simon-cozens/"><h3>Simon Cozens</h3></a>
    <p></p>
    <h5><a href="/authors/simon-cozens/">Browse their articles</a></h5>
  </div>
</div>

            
            <div class="row">
              <h3>Feedback</h3>
              <p>Something wrong with this article? Help us out by opening an issue or pull request on <a href="https://github.com/tpf/perldotcom/blob/master/content/legacy/_pub_2003_07_01_regexps.md">GitHub</a></p>
            </div>
          </div>
          <div class="col-md-3">
            <div class="latest-sidebar">

  <div class="row">
    <div class="col-sm-12 centering">
      <span style="font-size:1.8em" class="antonio txt-blue-major">OUR LATEST ARTICLES</span>
    </div>
  </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/the-perl-admbassador-curtis-poe/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/the-perl-ambassador-curtis-poe/curtis-poe.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>The Perl Ambassador: Curtis &#39;Ovid&#39; Poe</h6>
          <p style="line-height:1"><small>The person behind the news of Perl</small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/a-tour-with-net-ftp/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/a-tour-with-net-ftp/thumb_kidyes.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>A tour with Net::FTP</h6>
          <p style="line-height:1"><small>How to write an FTP client in Perl</small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/shortcode_test/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/author/brian-d-foy.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>shortcode_test</h6>
          <p style="line-height:1"><small></small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/listen-to-larry-wall-s-state-of-the-onion-2000-on-youtube/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/listen-to-larry-wall-s-state-of-the-onion-2000-on-youtube/thumb_larry-wall.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>Listen to Larry Wall&#39;s State of the Onion 2000 on YouTube</h6>
          <p style="line-height:1"><small></small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/announcing-perl-7/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/announcing-perl-7/thumb_seven_on_blue_wall.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>Announcing Perl 7</h6>
          <p style="line-height:1"><small>Perl 5 with modern defaults</small></p>
      </div>
        </a>
    </div>
  
</div>
<div class="row" style="margin-top:20px">
  <div class="col-sm-12 centering">
  <script async src="/widget/toplinks/toplinks.js" type="text/javascript"></script>
    <div id="toplinks"></div>
  </div>
</div>

<div class="row" style="margin-top:20px">
  <div class="col-sm-12 centering">
    <a class="twitter-timeline" data-height="640" data-dnt="true" data-theme="dark" href="https://twitter.com/perlfoundation?ref_src=twsrc%5Etfw">Tweets by perlfoundation</a> <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
  </div>
</div>

<div class="row" style="margin-top:20px">
  <div class="col-sm-12 centering">
    <script src="https://www.reddit.com/r/perl/hot/.embed?limit=10&t=all" type="text/javascript"></script>
  </div>
</div>



          </div>
        </div>
      </div>
    </section>
  </section>
<script>
 
var tables, i;
tables = document.getElementsByTagName('table');
for (i=0;i<tables.length;i++) {
  tables[i].className = 'table table-striped';
}
</script>
<div class="push"></div>
<div class="footer">
  <div class="container">
    <div class="row">
      <div class="col-md-1">
        <h5>Site Map</h5>
        <ul>
        <li><a href="/">Home</a></li>
        <hr>
        <li><a href="/about">About</a></li>
        <hr>
        <li><a href="/authors">Authors</a></li>
        <hr>
        <li><a href="/categories">Categories</a></li>
        <hr>
        <li><a href="/tags">Tags</a></li>
        <hr>
        </ul>
      </div>
      <div class="col-md-3">
        <h5>Contact Us</h5>
        <p>To get in touch, send an email to: perl.com-editor@perl.org</p>
        <p><a href="https://perl.org">
              <img src="/images/site/perl-onion_20.png" alt="Perl Onion"></a>
          <a href="https://twitter.com/intent/follow?screen_name=perlfoundation">
              <img src="/images/site/twitter_20.png" alt="twitter"></a>
          <a href="/index.xml" /><img src="/images/site/rss_20.png" alt="rss"></a>
          <a href="https://github.com/tpf/perldotcom">
              <img src="/images/site/github_light_20.png" alt="GitHub logo"></a></p>
      </div>
      <div class="col-md-2">
          <h5>License</h5>
          <p>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc/3.0/">Creative Commons Attribution-NonCommercial 3.0 Unported License</a>.</p>
          <p><a rel="license" href="https://creativecommons.org/licenses/by-nc/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/3.0/88x31.png" /></a></p>
      </div>
      <div class="col-md-5">
          <h5>Legal</h5>
          <p>Perl.com and the authors make no representations with respect to the accuracy or completeness of the contents of all work on this website and specifically disclaim all warranties, including without limitation warranties of fitness for a particular purpose. The information published on this website may not be suitable for every situation. All work on this website is provided with the understanding that Perl.com and the authors are not engaged in rendering professional services. Neither Perl.com nor the authors shall be liable for damages arising herefrom.</p>
      </div>
    </div>
  </div>
</div>
<script src="/javascript/jquery.min.js"></script>
<script src="/javascript/bootstrap.min.js"></script>
<script data-no-instant>document.write('<script src="/livereload.js?port=1313&mindelay=10"></' + 'script>')</script></body>
</html>

