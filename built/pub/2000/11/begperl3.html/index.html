<!DOCTYPE html>
<html lang="en-us">
  <head>
  <title> Beginner&#39;s Introduction to Perl - Part 3 </title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="s/// and m// -&gt; Editor&#39;s note: this venerable series is undergoing updates. You might be interested in the newer versions, available at: A Beginner&#39;s Introduction to Perl 5.10 A Beginner&#39;s Introduction to Files and Strings with Perl 5.10 A Beginner&#39;s..."/>
  <meta name="robots" content="index, follow">
  <meta name="google-site-verification" content="TZowffo_LX2mmsw2DbeNNbukCMnIOA8T-6CMJPiYllI" />

<meta property="twitter:card" content="summary">
<meta property="twitter:site" content="@PerlFoundation">
<meta property="og:url" content="http://localhost:1313/pub/2000/11/begperl3.html/" />
<meta property="og:title" content="Beginner&#39;s Introduction to Perl - Part 3" />
<meta property="og:description" content="s/// and m// -&gt; Editor&#39;s note: this venerable series is undergoing updates. You might be interested in the newer versions, available at: A Beginner&#39;s Introduction to Perl 5.10 A Beginner&#39;s Introduction to Files and Strings with Perl 5.10 A Beginner&#39;s...">
<meta property="og:site_name" content="Perl.com" />

<meta property="og:type" content="article" />
<meta property="og:article:published_time" content="2000-11-11T11:11:11Z" />
<meta property="og:image" content="http://localhost:1313/images/author/doug-sheppard.jpg" />


  <link rel="icon" href="/favicon.ico">
  <link href="/article/index.xml" rel="alternate" type="application/rss+xml" title="Perl.com - programming news, code and culture" />
  <link href="/article/index.xml" rel="feed" type="application/rss+xml" title="Perl.com - programming news, code and culture" />
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" type="text/css" href="/css/perldotcom.css"/>


<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-50555-22', 'auto');
ga('create', 'UA-85734801-2', 'auto', 'editor');
ga('send', 'pageview');
ga('editor.send', 'pageview');
</script>

</head>
<body>

<div class="container-fluid full-wdith antonio">
 <div class="row">
  <div class="navbar-inverse" style="border-radius:none !important" role="navigation">
    <div class="container-fluid">
      <ul class="nav navbar-nav pull-right follow">
          <li>MORE:</li>
          <li><a href="https://perl.org">
              <img src="/images/site/perl-onion_20.png" alt="Perl Onion"></a><li>
          <li><a href="https://twitter.com/intent/follow?screen_name=perlfoundation">
              <img src="/images/site/twitter_20.png" alt="twitter"></a><li>
          <li><a href="/article/index.xml" />
              <img src="/images/site/rss_20.png" alt="rss"></a></li>
          <li><a href="https://github.com/tpf/perldotcom" />
              <img src="/images/site/github_light_20.png" alt="GitHub logo"></a></li>
      </ul>
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
          <a class="navbar-nav" href="/">
            <div class="header-logo">Perl.com</div>
          </a>
      </div>
      <div class="navbar-collapse collapse">
        <ul class="nav navbar-nav">
          <li><a href="/about">
              <div class="circle">
                <img src="/images/site/perl-camel.png" alt="" />
              </div>
                  &nbsp;&nbsp;ABOUT</a>
          </li>
          <li><a href="/authors">
              <div class="circle">
                  <span class="glyphicon glyphicon-user txt-blue-major" aria-hidden="true"></span>
              </div>
                  &nbsp;&nbsp;AUTHORS</a>
          </li>
          <li><a href="/categories">
              <div class="circle">
                  <span class="glyphicon glyphicon-folder-open txt-blue-major" aria-hidden="true"></span>
              </div>
                  &nbsp;&nbsp;CATEGORIES</a>
          </li>
          <li><a href="/tags">
              <div class="circle">
                <span class="txt-blue-major" aria-hidden="true"><strong>#</strong></span>
              </div>
                  &nbsp;&nbsp;TAGS</a>
          </li>
          <li>
            <form class="search" name="ddg" action="https://duckduckgo.com/" method="get">
              <input type="text" name ="q" placeholder="SEARCH" />
              <input type="hidden" value="perl.com" name="sites" />
            </form>
          </li>
        </ul>
      </div>
    </div>
  </div>
 </div>
</div>


  <section id="content" role="main">
    <section class="entry-content">
      <div class="container">
        <div class="row">
          <div class="col-md-9">
            <div class="row">
              <article class="fulltext">
              <h1 class="blog-post-title">Beginner&#39;s Introduction to Perl - Part 3</h1>
              <p class="blog-post-meta">Nov 20, 2000 by
              
              
                
                
                <a href="#author-bio-doug-sheppard">Doug Sheppard</a>
              
              </p>
              <img alt="" src=""/>
                

<p><em>Editor&rsquo;s note: this venerable series is undergoing updates. You might be interested in the newer versions, available at:</em></p>

<ul>
<li><a href="/pub/2008/04/23/a-beginners-introduction-to-perl-510.html">A Beginner&rsquo;s Introduction to Perl 5.10</a></li>
<li><a href="/pub/2008/05/07/beginners-introduction-to-perl-510-part-2.html">A Beginner&rsquo;s Introduction to Files and Strings with Perl 5.10</a></li>
<li><a href="http://news.oreilly.com/2008/06/a-beginners-introduction-to-pe.html">A Beginner&rsquo;s Introduction to Regular Expressions with Perl 5.10</a></li>
<li><a href="http://broadcast.oreilly.com/2008/09/a-beginners-introduction-to-pe.html">A Beginner&rsquo;s Introduction to Perl Web Programming</a></li>
</ul>

<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td>Table of Contents</td>
</tr>
<tr class="even">
<td><p>•<strong><a href="/pub/2000/10/begperl1.html">Part 1 of this series</a></strong><br />
•<strong><a href="/pub/2000/11/begperl2.html">Part 2 of this series</a></strong><br />
•<strong><a href="/pub/2000/12/begperl4.html">Part 4 of this series</a></strong><br />
•<strong><a href="/pub/2000/12/begperl5.html">Part 5 of this series</a></strong><br />
•<strong><a href="/pub/2001/01/begperl6.html">Part 6 of this series</a></strong><br />
<br />
•<a href="#simple%20matching">Simple matching</a><br />
•<a href="#metacharacters">Metacharacters</a><br />
•<a href="#character%20classes">Character classes</a><br />
•<a href="#flags">Flags</a><br />
•<a href="#subexpressions">Subexpressions</a><br />
•<a href="#watch%0Aout!">Watch out!</a><br />
•<a href="#search%20and%20replace">Search and replace</a><br />
•<a href="#play%20around!">Play around!</a></p></td>
</tr>
</tbody>
</table>

<p>We&rsquo;ve covered flow control, math and string operations, and files in the first two articles in this series. Now we&rsquo;ll look at Perl&rsquo;s most powerful and interesting way of playing with strings, <em>regular expressions</em>, or <em>regexes</em> for short. (The rule is this: after the 50th time you type ``regular expression,&rdquo; you find you type ``regexp&rdquo; the next 50 times.)</p>

<p>Regular expressions are complex enough that you could write a whole book on them (and, in fact, someone did - <em>Mastering Regular Expressions</em> by Jeffrey Friedl).</p>

<h3 id="span-id-simple-matching-simple-matching-span"><span id="simple matching">Simple matching</span></h3>

<p>The simplest regular expressions are <em>matching</em> expressions. They perform tests using keywords like <code>if</code>, <code>while</code> and <code>unless</code>. Or, if you want to be really clever, tests that you can use with <code>and</code> and <code>or</code>. A matching regexp will return a true value if whatever you try to match occurs inside a string. When you want to use a regular expression to match against a string, you use the special <code>=~</code> operator:</p>

<pre><code> $user_location = &quot;I see thirteen black cats under a ladder.&quot;;
    if ($user_location =~ /thirteen/) {
        print &quot;Eek, bad luck!\n&quot;;
    }
</code></pre>

<p>Notice the syntax of a regular expression: a string within a pair of slashes. The code <code>$user_location =~ /thirteen/</code> asks whether the literal string <code>thirteen</code> occurs anywhere inside <code>$user_location</code>. If it does, then the test evaluates true; otherwise, it evaluates false.</p>

<h3 id="span-id-metacharacters-metacharacters-span"><span id="metacharacters">Metacharacters</span></h3>

<p>A <em>metacharacter</em> is a character or sequence of characters that has special meaning. We&rsquo;ve discussed metacharacters in the context of double-quoted strings, where the sequence <code>\n</code> mean the newline character, not a backslash, and the character <code>n</code> and <code>\t</code> means the tab character.</p>

<p>Regular expressions have a rich vocabulary of metacharacters that let you ask interesting questions such as, ``Does this expression occur at the end of a string?&rdquo; or ``Does this string contain a series of numbers?&rdquo;</p>

<p>The two simplest metacharacters are <code>^</code> and <code>$</code>. These indicate ``beginning of string&rdquo; and ``end of string,&rdquo; respectively. For example, the regexp <code>/^Bob/</code> will match ``Bob was here,&rdquo; ``Bob&rdquo; and ``Bobby.&rdquo; It won&rsquo;t match ``It&rsquo;s Bob and David,&rdquo; because Bob doesn&rsquo;t show up at the beginning of the string. The <code>$</code> character, on the other hand, means that you are matching the end of a string. The regexp <code>/David$/</code> will match ``Bob and David,&rdquo; but not ``David and Bob.&rdquo; Here&rsquo;s a simple routine that will take lines from a file and only print URLs that seem to indicate HTML files:</p>

<pre><code>for $line (&lt;URLLIST&gt;) {
        # &quot;If the line starts with http: and ends with html....&quot;
        if (($line =~ /^http:/) and
            ($line =~ /html$/)) {
            print $line;
        }
    }
</code></pre>

<p>Another useful set of metacharacters is called <em>wildcards</em>. If you&rsquo;ve ever used a Unix shell or the Windows DOS prompt, you&rsquo;re familiar with wildcards characters like <code>*</code> and <code>?</code>. For example when you type <code>ls a*.txt</code>, you see all filenames that begin with the letter <code>a</code> and end with <code>.txt</code>. Perl is a bit more complex, but works on the same general principle.</p>

<p>In Perl, the generic wildcard character is <code>.</code>. A period inside a regular expression will match <em>any</em> character, except a newline. For example, the regexp <code>/a.b/</code> will match anything that contains <code>a</code>, another character that&rsquo;s not a newline, followed by <code>b</code> - ``aab,&rdquo; ``a3b,&rdquo; ``a b,&rdquo; and so forth.</p>

<p>If you want to <em>literally</em> match a metacharacter, you must escape it with a backslash. The regex <code>/Mr./</code> matches anything that contains ``Mr&rdquo; followed by another character. If you only want to match a string that actually contains ``Mr.,&rdquo; you must use <code>/Mr\./</code>.</p>

<p>On its own, the <code>.</code> metacharacter isn&rsquo;t very useful, which is why Perl provides three wildcard <em>quantifiers</em>: <code>+</code>, <code>?</code> and <code>*</code>. Each quantifier means something different.</p>

<p>The <code>+</code> quantifier is the easiest to understand: It means to match the immediately preceding character or metacharacter <em>one or more times</em>. The regular expression <code>/ab+c/</code> will match ``abc,&rdquo; ``abbc,&rdquo; ``abbbc&rdquo; and so on.</p>

<p>The <code>*</code> quantifier matches the immediately preceding character or metacharacter <em>zero or more times</em>. This is different from the <code>+</code> quantifier! <code>/ab*c/</code> will match ``abc,&rdquo; ``abbc,&rdquo; and so on, just like <code>/ab+c/</code> did, but it&rsquo;ll also match ``ac,&rdquo; because there are zero occurences of <code>b</code> in that string.</p>

<p>Finally, the <code>?</code> quantifier will match the preceding character <em>zero or one times</em>. The regex <code>/ab?c/</code> will match ``ac&rdquo; (zero occurences of <code>b</code>) and ``abc&rdquo; (one occurence of <code>b</code>). It won&rsquo;t match ``abbc,&rdquo; ``abbbc&rdquo; and so on.</p>

<p>We can rewrite our URL-matching code to use these metacharacters. This&rsquo;ll make it more concise. Instead of using two separate regular expressions (<code>/^http:/</code> and <code>/html$/</code>), we combine them into one regular expression: <code>/^http:.+html$/</code>. To understand what this does, read from left to right: This regex will match any string that <em>starts with ``http:&rdquo;</em> followed by <em>one or more occurences of any character</em>, and <em>ends with ``html&rdquo;</em>. Now, our routine is:</p>

<pre><code> for $line (&lt;URLLIST&gt;) {
        if ($line =~ /^http:.+html$/) {
           print $line;
        }
    }
</code></pre>

<p>Remember the <code>/^something$/</code> construction - it&rsquo;s very useful!</p>

<h3 id="span-id-character-classes-character-classes-span"><span id="character classes">Character classes</span></h3>

<p>We&rsquo;ve already discussed one special metacharacter, <code>.</code>, that matches any character except a newline. But you&rsquo;ll often want to match only specific types of characters. Perl provides several metacharacters for this. &lt;\d&gt; will match a single digit, <code>\w</code> will match any single ``word&rdquo; character (which, to Perl, means a letter, digit or underscore), and <code>\s</code> matches a whitespace character (space and tab, as well as the <code>\n</code> and <code>\r</code> characters).</p>

<p>These metacharacters work like any other character: You can match against them, or you can use quantifiers like <code>+</code> and <code>*</code>. The regex <code>/^\s+/</code> will match any string that begins with whitespace, and <code>/\w+/</code> will match a string that contains at least one word. (But remember that Perl&rsquo;s definition of ``word&rdquo; characters includes digits and the underscore, so whether or not you think <code>_</code> or <code>25</code> are words, Perl does!)</p>

<p>One good use for <code>\d</code> is testing strings to see whether they contain numbers. For example, you might need to verify that a string contains an American-style phone number, which has the form <code>555-1212</code>. You could use code like this:</p>

<pre><code> unless ($phone =~ /\d\d\d-\d\d\d\d/) {
 print &quot;That's not a phone number!\n&quot;;
    }
</code></pre>

<p>All those <code>\d</code> metacharacters make the regex hard to read. Fortunately, Perl allows us to improve on that. You can use numbers inside curly braces to indicate a <em>quantity</em> you want to match, like this:</p>

<pre><code> unless ($phone =~ /\d{3}-\d{4}/) {
 print &quot;That's not a phone number!\n&quot;;
   }
</code></pre>

<p>The string <code>\d{3}</code> means to match exactly three numbers, and <code>\d{4}</code> matches exactly four digits. If you want to use a range of numbers, you can separate them with a comma; leaving out the second number makes the range open-ended. <code>\d{2,5}</code> will match two to five digits, and &lt;\w{3,}&gt; will match a word that&rsquo;s at least three characters long.</p>

<p>You can also <em>invert</em> the <code>\d</code>, <code>\s</code> and <code>\w</code> metacharacters to refer to anything <em>but</em> that type of character. <code>\D</code> matches nondigits; <code>\W</code> matches any character that <em>isn&rsquo;t</em> a letter, digit or underscore; and <code>\S</code> matches anything that isn&rsquo;t whitespace.</p>

<p>If these metacharacters won&rsquo;t do what you want, you can define your own. You define a character class by enclosing a list of the allowable characters in square brackets. For example, a class containing only the lowercase vowels is <code>[aeiou]</code>. <code>/b[aeiou]g/</code> will match any string that contains ``bag,&rdquo; ``beg,&rdquo; ``big,&rdquo; ``bog&rdquo; or ``bug&rdquo;. You use dashes to indicate a range of characters, like <code>[a-f]</code>. (If Perl didn&rsquo;t give us the <code>\d</code> metacharacter, we could do the same thing with <code>[0-9]</code>.) You can combine character classes with quantifiers:</p>

<pre><code> if ($string =~ /[aeiou]{2}/) {
 print &quot;This string contains at least
        two vowels in a row.\n&quot;;
    }
</code></pre>

<p>You can also invert character classes by beginning them with the <code>^</code> character. An inverted character class will match anything you <em>don&rsquo;t</em> list. <code>[^aeiou]</code> matches every character except the lowercase vowels. (Yes, <code>^</code> can also mean ``beginning of string,&rdquo; so be careful.)</p>

<h3 id="span-id-flags-flags-span"><span id="flags">Flags</span></h3>

<p>By default, regular expression matches are case-sensitive (that is, <code>/bob/</code> doesn&rsquo;t match ``Bob&rdquo;). You can place <em>flags</em> after a regexp to modify their behaviour. The most commonly used flag is <code>i</code>, which makes a match case-insensitive:</p>

<pre><code> $greet = &quot;Hey everybody, it's Bob and David!&quot;;
    if ($greet =~ /bob/i) {
        print &quot;Hi, Bob!\n&quot;;
    }
</code></pre>

<p>We&rsquo;ll talk about more flags later.</p>

<h3 id="span-id-subexpressions-subexpressions-span"><span id="subexpressions">Subexpressions</span></h3>

<p>You might want to check for more than one thing at a time. For example, you&rsquo;re writing a ``mood meter&rdquo; that you use to scan outgoing e-mail for potentially damaging phrases. You can use the pipe character <code>|</code> to separate different things you are looking for:</p>

<pre><code> # In reality, @email_lines would come from your email text, 
   # but here we'll just provide some convenient filler.
   @email_lines = (&quot;Dear idiot:&quot;,
                   &quot;I hate you, you twit.  You're a dope.&quot;,
                   &quot;I bet you mistreat your llama.&quot;,
                   &quot;Signed, Doug&quot;);

   for $check_line (@email_lines) {
       if ($check_line =~ /idiot|dope|twit|llama/) {
           print &quot;Be careful!  This line might
              contain something offensive:\n&quot;,
                 $check_line, &quot;\n&quot;;
       }
   }
</code></pre>

<p>The matching expression <code>/idiot|dope|twit|llama/</code> will be true if ``idiot,&rdquo; ``dope,&rdquo; ``twit&rdquo; or ``llama&rdquo; show up anywhere in the string.</p>

<p>One of the more interesting things you can do with regular expressions is <em>subexpression matching</em>, or grouping. A subexpression is like another, smaller regex buried inside your larger regexp, and is placed inside parentheses. The string that caused the subexpression to match will be stored in the special variable <code>$1</code>. We can use this to make our mood meter more explicit about the problems with your e-mail:</p>

<pre><code> for $check_line (@email_lines) {
       if ($check_line =~ /(idiot|dope|twit|llama)/) {
           print &quot;Be careful!  This line contains the
                  offensive word $1:\n&quot;,
                 $check_line, &quot;\n&quot;;
       }
   }
</code></pre>

<p>Of course, you can put matching expressions in your subexpression. Your mood watch program can be extended to prevent you from sending e-mail that contains more than three exclamation points in a row. We&rsquo;ll use the special <code>{3,}</code> quantifier to make sure we get <em>all</em> the exclamation points.</p>

<pre><code> for $check_line (@email_lines) {
        if ($check_line =~ /(!{3,})/) {
            print &quot;Using punctuation like '$1' 
                   is the sign of a sick mind:\n&quot;,
                  $check_line, &quot;\n&quot;;
        }
    }
</code></pre>

<p>If your regex contains more than one subexpression, the results will be stored in variables named <code>$1</code>, <code>$2</code>, <code>$3</code> and so on. Here&rsquo;s some code that will change names in ``lastname, firstname&rdquo; format back to normal:</p>

<pre><code> $name = &quot;Wall, Larry&quot;;
   $name =~ /(\w+), (\w+)/;
   # $1 contains last name, $2 contains first name

   $name = &quot;$2 $1&quot;;
   # $name now contains &quot;Larry Wall&quot;
</code></pre>

<p>You can even nest subexpressions inside one another - they&rsquo;re ordered as they open, from left to right. Here&rsquo;s an example of how to retrieve the full time, hours, minutes and seconds separately from a string that contains a timestamp in <code>hh:mm:ss</code> format. (Notice that we&rsquo;re using the <code>{1,2}</code> quantifier so that a timestamp like ``9:30:50&rdquo; will be matched.)</p>

<pre><code> $string = &quot;The time is 12:25:30 and I'm hungry.&quot;;
    $string =~ /((\d{1,2}):(\d{2}):(\d{2}))/;
    @time = ($1, $2, $3, $4);
</code></pre>

<p>Here&rsquo;s a hint that you might find useful: You can assign <em>to</em> a list of scalar values whenever you&rsquo;re assigning <em>from</em> a list. If you prefer to have readable variable names instead of an array, try using this line instead:</p>

<pre><code> ($time, $hours, $minutes, $seconds) = ($1, $2, $3, $4);
</code></pre>

<p>Assigning to a list of variables when you&rsquo;re using subexpressions happens often enough that Perl gives you a handy shortcut:</p>

<pre><code> ($time, $hours, $minutes, $seconds) =
         ($string =~ /((\d{1,2}):(\d{2}):(\d{2}))/);
</code></pre>

<h3 id="span-id-watch-out-watch-out-span"><span id="watch out!">Watch out!</span></h3>

<p>Regular expressions have two traps that generate bugs in your Perl programs: They always start at the beginning of the string, and quantifiers always match as much of the string as possible.</p>

<p>Here&rsquo;s some simple code for counting all the numbers in a string and showing them to the user. We&rsquo;ll use <code>while</code> to loop over the string, matching over and over until we&rsquo;ve counted all the numbers.</p>

<pre><code> $number = &quot;Look, 200 5-sided, 4-colored pentagon maps.&quot;;
    while ($number =~ /(\d+)/) {
        print &quot;I found the number $1.\n&quot;;
        $number_count++;
    }
    print &quot;There are $number_count numbers here.\n&quot;;
</code></pre>

<p>This code is actually so simple it doesn&rsquo;t work! When you run it, Perl will print <code>I found the number 200</code> over and over again. Perl always begins matching at the beginning of the string, so it will always find the 200, and never get to the following numbers.</p>

<p>You can avoid this by using the <code>g</code> flag with your regex. This flag will tell Perl to remember where it was in the string when it returns to it. When you insert the <code>g</code> flag, our code looks like this:</p>

<pre><code> $number = &quot;Look, 200 5-sided, 4-colored pentagon maps.&quot;;
    while ($number =~ /(\d+)/g) {
        print &quot;I found the number $1.\n&quot;;
        $number_count++;
    }
    print &quot;There are $number_count numbers here.\n&quot;;
</code></pre>

<p>Now we get the results we expected:</p>

<pre><code> I found the number 200.
    I found the number 5.
    I found the number 4.
    There are 3 numbers here.
</code></pre>

<p>The second trap is that a quantifier will always match as many characters as it can. Look at this example code, but don&rsquo;t run it yet:</p>

<pre><code> $book_pref = &quot;The cat in the hat is where it's at.\n&quot;;
    $book_pref =~ /(cat.*at)/;
    print $1, &quot;\n&quot;;
</code></pre>

<p>Take a guess: What&rsquo;s in <code>$1</code> right now? Now run the code. Does this seem counterintuitive?</p>

<p>The matching expression <code>(cat.*at)</code> is greedy. It contains <code>cat in the hat is where it's at</code> because that&rsquo;s the largest string that matches. Remember, read left to right: ``cat,&rdquo; followed by any number of characters, followed by ``at.&rdquo; If you want to match the string <code>cat in the hat</code>, you have to rewrite your regexp so it isn&rsquo;t as greedy. There are two ways to do this:</p>

<ol>
<li><p>Make the match more precise (try <code>/(cat.*hat)/</code> instead). Of course, this still might not work - try using this regexp against <code>The cat in the hat is who I hate</code>.</p></li>

<li><p>Use a <code>?</code> character after a quantifier to specify nongreedy matching. <code>.*?</code> instead of <code>.*</code> means that Perl will try to match the <em>smallest</em> string possible instead of the largest:</p>

<p># Now we get &ldquo;cat in the hat&rdquo; in $1.
  $book_pref =~ /(cat.*?at)/;</p></li>
</ol>

<h3 id="span-id-search-and-replace-search-and-replace-span"><span id="search and replace">Search and replace</span></h3>

<p>Now that we&rsquo;ve talked about <em>matching</em>, there&rsquo;s one other thing regular expressions can do for you: <em>replacing</em>.</p>

<p>If you&rsquo;ve ever used a text editor or word processor, you&rsquo;re familiar with the search-and-replace function. Perl&rsquo;s regexp facilities include something similar, the <code>s///</code> operator, which has the following syntax: <code>s/regex/replacement string/</code>. If the string you&rsquo;re testing matches <em>regex</em>, then whatever matched is replaced with the contents of <em>replacement string</em>. For instance, this code will change a cat into a dog:</p>

<pre><code> $pet = &quot;I love my cat.\n&quot;;
    $pet =~ s/cat/dog/;
    print $pet;
</code></pre>

<p>You can also use subexpressions in your matching expression, and use the variables <code>$1</code>, <code>$2</code> and so on, that they create. The replacement string will substitute these, or any other variables, as if it were a double-quoted string. Remember our code for changing <code>Wall, Larry</code> into <code>Larry Wall</code>? We can rewrite it as a single <code>s///</code> statement!</p>

<pre><code> $name = &quot;Wall, Larry&quot;;
    $name =~ s/(\w+), (\w+)/$2 $1/;  # &quot;Larry Wall&quot;
</code></pre>

<p><code>s///</code> can take flags, just like matching expressions. The two most important flags are <code>g</code> (global) and <code>i</code> (case-insensitive). Normally, a substitution will only happen <em>once</em>, but specifying the <code>g</code> flag will make it happen as long as the regex matches the string. Try this code, and then remove the <code>g</code> flag and try it again:</p>

<pre><code> $pet = &quot;I love my cat Sylvester, and my other cat Bill.\n&quot;;
   $pet =~ s/cat/dog/g;
   print $pet;
</code></pre>

<p>Notice that without the <code>g</code> flag, Bill doesn&rsquo;t turn into a dog.</p>

<p>The <code>i</code> flag works just as it did when we were only using matching expressions: It forces your matching search to be case-insensitive.</p>

<h3 id="span-id-putting-it-all-together-putting-it-all-together-span"><span id="putting it all together">Putting it all together</span></h3>

<p>Regular expressions have many practical uses. We&rsquo;ll look at a httpd log analyzer for an example. In our last article, one of the play-around items was to write a simple log analyzer. Now, let&rsquo;s make it a bit more interesting: a log analyzer that will break down your log results by file type and give you a list of total requests by hour.</p>

<p>(<a href="/media/_pub_2000_11_begperl3/a3-httpd.pl">Complete source code</a>.)</p>

<p>First, let&rsquo;s look at a sample line from a httpd log:</p>

<pre><code> 127.12.20.59 - - [01/Nov/2000:00:00:37 -0500] 
    &quot;GET /gfx2/page/home.gif HTTP/1.1&quot; 200 2285
</code></pre>

<p>The first thing we want to do is split this into fields. Remember that the <code>split()</code> function takes a regular expression as its first argument. We&rsquo;ll use <code>/\s/</code> to split the line at each whitespace character:</p>

<pre><code> @fields = split(/\s/, $line);
</code></pre>

<p>This gives us 10 fields. The ones we&rsquo;re concerned with are the fourth field (time and date of request), the seventh (the URL), and the ninth and 10th (HTTP status code and size in bytes of the server response).</p>

<p>First, we&rsquo;d like to make sure that we turn any request for a URL that ends in a slash (like <code>/about/</code>) into a request for the index page from that directory (<code>/about/index.html</code>). We&rsquo;ll need to escape out the slashes so that Perl doesn&rsquo;t mistake them for terminators in our <code>s///</code> statement.</p>

<pre><code> $fields[6] =~ s/\/$/\/index.html/;
</code></pre>

<p>This line is difficult to read, because anytime we come across a literal slash character we need to escape it out. This problem is so common, it has acquired a name: <em>leaning-toothpick syndrome</em>. Here&rsquo;s a useful trick for avoiding the leaning-toothpick syndrome: You can replace the slashes that mark regular expressions and <code>s///</code> statements with any other matching pair of characters, like <code>{</code> and <code>}</code>. This allows us to write a more legible regex where we don&rsquo;t need to escape out the slashes:</p>

<pre><code> $fields[6] =~ s{/$}{/index.html};
</code></pre>

<p>(If you want to use this syntax with a matching expression, you&rsquo;ll need to put a <code>m</code> in front of it. <code>/foo/</code> would be rewritten as <code>m{foo}</code>.)</p>

<p>Now, we&rsquo;ll assume that any URL request that returns a status code of 200 (request OK) is a request for the file type of the URL&rsquo;s extension (a request for <code>/gfx/page/home.gif</code> returns a GIF image). Any URL request without an extension returns a plain-text file. Remember that the period is a metacharacter, so we need to escape it out!</p>

<pre><code> if ($fields[8] eq '200') {
           if ($fields[6] =~ /\.([a-z]+)$/i) {
               $type_requests{$1}++;
           } else {
               $type_requests{'txt'}++;
           }
        }
</code></pre>

<p>Next, we want to retrieve the <em>hour</em> each request took place. The hour is the first string in <code>$fields[3]</code> that will be two digits surrounded by colons, so all we need to do is look for that. Remember that Perl will stop when it finds the first match in a string:</p>

<pre><code> # Log the hour of this request
        $fields[3] =~ /:(\d{2}):/;
        $hour_requests{$1}++;
</code></pre>

<p>Finally, let&rsquo;s rewrite our original <code>report()</code> sub. We&rsquo;re doing the same thing over and over (printing a section header and the contents of that section), so we&rsquo;ll break that out into a new sub. We&rsquo;ll call the new sub <code>report_section()</code>:</p>

<pre><code> sub report {
    print ``Total bytes requested: '', $bytes, ``\n''; print &quot;\n&quot;;
    report_section(&quot;URL requests:&quot;, %url_requests);
    report_section(&quot;Status code results:&quot;, %status_requests);
    report_section(&quot;Requests by hour:&quot;, %hour_requests);
    report_section(&quot;Requests by file type:&quot;, %type_requests);
}
</code></pre>

<p>The new <code>report_section()</code> sub is very simple:</p>

<pre><code> sub report_section {
    my ($header, %type) = @_; print $header, &quot;\n&quot;;
    for $i (sort keys %type) {
        print $i, &quot;: &quot;, $type{$i}, &quot;\n&quot;;
    }

    print &quot;\n&quot;;
}
</code></pre>

<p>We use the <code>keys</code> function to return a list of the keys in the <code>%type</code> hash, and the <code>sort</code> function to put it in alphabetic order. We&rsquo;ll play with <code>sort</code> a bit more in the next article.</p>

<h3 id="span-id-play-around-play-around-span"><span id="play around!">Play around!</span></h3>

<p>As usual, here are some sample exercises:</p>

<ol>
<li>A rule of good writing is ``avoid the passive voice.&rdquo; Instead of <em>The report was read by Carl</em>, say <em>Carl read the report</em>. Write a program that reads a file of sentences (one per line), detects and eliminates the passive voice, and prints the result. (Don&rsquo;t worry about irregular verbs or capitalization, though.)</li>
</ol>

<p><a href="/media/_pub_2000_11_begperl3/a3-activate.pl">Sample solution</a>. <a href="/media/_pub_2000_11_begperl3/a3-sentences.txt">Sample test sentences</a>.</p>

<ol>
<li>You have a list of phone numbers. The list is messy, and the only thing you know is that there are either seven or 10 digits in each number (the area code is optional), and if there&rsquo;s an extension, it will show up after an ``x&rdquo; somewhere on the line. ``416 555-1212,&rdquo; ``5551300X40&rdquo; and ``(306) 555.5000 ext 40&rdquo; are all possible. Write a <code>fix_phone()</code> sub that will turn all of these numbers into the standard format ``(123) 555-1234&rdquo; or ``(123) 555-1234 Ext 100,&rdquo; if there is an extension. Assume that the default area code is ``123.&rdquo;</li>
</ol>

<p><a href="/media/_pub_2000_11_begperl3/a3-phone.pl">Sample solution</a>.</p>

              </article>
              <p><strong>Tags</strong></p>
              <div class="tags">
                <div class="category"><a href="/categories/development">development</a></div>
                
              </div>
            </div>
            
              
                
<div class="row" id="author-bio-doug-sheppard">
  <div class="col-sm-2">
    
    <a href="/authors/doug-sheppard/"><div class="circle-avatar" style="background-image:url(/images/author/doug-sheppard.jpg)"></div></a>
  </div>
  <div class="col-sm-10">
    <a href="/authors/doug-sheppard/"><h3>Doug Sheppard</h3></a>
    <p></p>
    <h5><a href="/authors/doug-sheppard/">Browse their articles</a></h5>
  </div>
</div>

            
            <div class="row">
              <h3>Feedback</h3>
              <p>Something wrong with this article? Help us out by opening an issue or pull request on <a href="https://github.com/tpf/perldotcom/blob/master/content/legacy/_pub_2000_11_begperl3.md">GitHub</a></p>
            </div>
          </div>
          <div class="col-md-3">
            <div class="latest-sidebar">

  <div class="row">
    <div class="col-sm-12 centering">
      <span style="font-size:1.8em" class="antonio txt-blue-major">OUR LATEST ARTICLES</span>
    </div>
  </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/the-perl-admbassador-curtis-poe/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/the-perl-ambassador-curtis-poe/curtis-poe.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>The Perl Ambassador: Curtis &#39;Ovid&#39; Poe</h6>
          <p style="line-height:1"><small>The person behind the news of Perl</small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/a-tour-with-net-ftp/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/a-tour-with-net-ftp/thumb_kidyes.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>A tour with Net::FTP</h6>
          <p style="line-height:1"><small>How to write an FTP client in Perl</small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/shortcode_test/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/author/brian-d-foy.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>shortcode_test</h6>
          <p style="line-height:1"><small></small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/listen-to-larry-wall-s-state-of-the-onion-2000-on-youtube/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/listen-to-larry-wall-s-state-of-the-onion-2000-on-youtube/thumb_larry-wall.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>Listen to Larry Wall&#39;s State of the Onion 2000 on YouTube</h6>
          <p style="line-height:1"><small></small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/announcing-perl-7/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/announcing-perl-7/thumb_seven_on_blue_wall.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>Announcing Perl 7</h6>
          <p style="line-height:1"><small>Perl 5 with modern defaults</small></p>
      </div>
        </a>
    </div>
  
</div>
<div class="row" style="margin-top:20px">
  <div class="col-sm-12 centering">
  <script async src="/widget/toplinks/toplinks.js" type="text/javascript"></script>
    <div id="toplinks"></div>
  </div>
</div>

<div class="row" style="margin-top:20px">
  <div class="col-sm-12 centering">
    <a class="twitter-timeline" data-height="640" data-dnt="true" data-theme="dark" href="https://twitter.com/perlfoundation?ref_src=twsrc%5Etfw">Tweets by perlfoundation</a> <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
  </div>
</div>

<div class="row" style="margin-top:20px">
  <div class="col-sm-12 centering">
    <script src="https://www.reddit.com/r/perl/hot/.embed?limit=10&t=all" type="text/javascript"></script>
  </div>
</div>



          </div>
        </div>
      </div>
    </section>
  </section>
<script>
 
var tables, i;
tables = document.getElementsByTagName('table');
for (i=0;i<tables.length;i++) {
  tables[i].className = 'table table-striped';
}
</script>
<div class="push"></div>
<div class="footer">
  <div class="container">
    <div class="row">
      <div class="col-md-1">
        <h5>Site Map</h5>
        <ul>
        <li><a href="/">Home</a></li>
        <hr>
        <li><a href="/about">About</a></li>
        <hr>
        <li><a href="/authors">Authors</a></li>
        <hr>
        <li><a href="/categories">Categories</a></li>
        <hr>
        <li><a href="/tags">Tags</a></li>
        <hr>
        </ul>
      </div>
      <div class="col-md-3">
        <h5>Contact Us</h5>
        <p>To get in touch, send an email to: perl.com-editor@perl.org</p>
        <p><a href="https://perl.org">
              <img src="/images/site/perl-onion_20.png" alt="Perl Onion"></a>
          <a href="https://twitter.com/intent/follow?screen_name=perlfoundation">
              <img src="/images/site/twitter_20.png" alt="twitter"></a>
          <a href="/index.xml" /><img src="/images/site/rss_20.png" alt="rss"></a>
          <a href="https://github.com/tpf/perldotcom">
              <img src="/images/site/github_light_20.png" alt="GitHub logo"></a></p>
      </div>
      <div class="col-md-2">
          <h5>License</h5>
          <p>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc/3.0/">Creative Commons Attribution-NonCommercial 3.0 Unported License</a>.</p>
          <p><a rel="license" href="https://creativecommons.org/licenses/by-nc/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/3.0/88x31.png" /></a></p>
      </div>
      <div class="col-md-5">
          <h5>Legal</h5>
          <p>Perl.com and the authors make no representations with respect to the accuracy or completeness of the contents of all work on this website and specifically disclaim all warranties, including without limitation warranties of fitness for a particular purpose. The information published on this website may not be suitable for every situation. All work on this website is provided with the understanding that Perl.com and the authors are not engaged in rendering professional services. Neither Perl.com nor the authors shall be liable for damages arising herefrom.</p>
      </div>
    </div>
  </div>
</div>
<script src="/javascript/jquery.min.js"></script>
<script src="/javascript/bootstrap.min.js"></script>
<script data-no-instant>document.write('<script src="/livereload.js?port=1313&mindelay=10"></' + 'script>')</script></body>
</html>

