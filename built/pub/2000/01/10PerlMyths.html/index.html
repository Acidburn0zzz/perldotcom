<!DOCTYPE html>
<html lang="en-us">
  <head>
  <title> Ten Perl Myths </title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content=" Beginning Perl : Ten Perl Myths -&gt; Introduction Table of Contents Perl is hard Perl looks like line noise Perl is hard because it has regexps Perl is hard because it has references Perl is just for Unix Perl..."/>
  <meta name="robots" content="index, follow">
  <meta name="google-site-verification" content="TZowffo_LX2mmsw2DbeNNbukCMnIOA8T-6CMJPiYllI" />

<meta property="twitter:card" content="summary">
<meta property="twitter:site" content="@PerlFoundation">
<meta property="og:url" content="http://localhost:1313/pub/2000/01/10PerlMyths.html/" />
<meta property="og:title" content="Ten Perl Myths" />
<meta property="og:description" content=" Beginning Perl : Ten Perl Myths -&gt; Introduction Table of Contents Perl is hard Perl looks like line noise Perl is hard because it has regexps Perl is hard because it has references Perl is just for Unix Perl...">
<meta property="og:site_name" content="Perl.com" />

<meta property="og:type" content="article" />
<meta property="og:article:published_time" content="2000-02-02T02:02:02Z" />
<meta property="og:image" content="http://localhost:1313/images/author/simon-cozens.jpg" />


  <link rel="icon" href="/favicon.ico">
  <link href="/article/index.xml" rel="alternate" type="application/rss+xml" title="Perl.com - programming news, code and culture" />
  <link href="/article/index.xml" rel="feed" type="application/rss+xml" title="Perl.com - programming news, code and culture" />
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" type="text/css" href="/css/perldotcom.css"/>


<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-50555-22', 'auto');
ga('create', 'UA-85734801-2', 'auto', 'editor');
ga('send', 'pageview');
ga('editor.send', 'pageview');
</script>

</head>
<body>

<div class="container-fluid full-wdith antonio">
 <div class="row">
  <div class="navbar-inverse" style="border-radius:none !important" role="navigation">
    <div class="container-fluid">
      <ul class="nav navbar-nav pull-right follow">
          <li>MORE:</li>
          <li><a href="https://perl.org">
              <img src="/images/site/perl-onion_20.png" alt="Perl Onion"></a><li>
          <li><a href="https://twitter.com/intent/follow?screen_name=perlfoundation">
              <img src="/images/site/twitter_20.png" alt="twitter"></a><li>
          <li><a href="/article/index.xml" />
              <img src="/images/site/rss_20.png" alt="rss"></a></li>
          <li><a href="https://github.com/tpf/perldotcom" />
              <img src="/images/site/github_light_20.png" alt="GitHub logo"></a></li>
      </ul>
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
          <a class="navbar-nav" href="/">
            <div class="header-logo">Perl.com</div>
          </a>
      </div>
      <div class="navbar-collapse collapse">
        <ul class="nav navbar-nav">
          <li><a href="/about">
              <div class="circle">
                <img src="/images/site/perl-camel.png" alt="" />
              </div>
                  &nbsp;&nbsp;ABOUT</a>
          </li>
          <li><a href="/authors">
              <div class="circle">
                  <span class="glyphicon glyphicon-user txt-blue-major" aria-hidden="true"></span>
              </div>
                  &nbsp;&nbsp;AUTHORS</a>
          </li>
          <li><a href="/categories">
              <div class="circle">
                  <span class="glyphicon glyphicon-folder-open txt-blue-major" aria-hidden="true"></span>
              </div>
                  &nbsp;&nbsp;CATEGORIES</a>
          </li>
          <li><a href="/tags">
              <div class="circle">
                <span class="txt-blue-major" aria-hidden="true"><strong>#</strong></span>
              </div>
                  &nbsp;&nbsp;TAGS</a>
          </li>
          <li>
            <form class="search" name="ddg" action="https://duckduckgo.com/" method="get">
              <input type="text" name ="q" placeholder="SEARCH" />
              <input type="hidden" value="perl.com" name="sites" />
            </form>
          </li>
        </ul>
      </div>
    </div>
  </div>
 </div>
</div>


  <section id="content" role="main">
    <section class="entry-content">
      <div class="container">
        <div class="row">
          <div class="col-md-9">
            <div class="row">
              <article class="fulltext">
              <h1 class="blog-post-title">Ten Perl Myths</h1>
              <p class="blog-post-meta">Feb 23, 2000 by
              
              
                
                
                <a href="#author-bio-simon-cozens">Simon Cozens</a>
              
              </p>
              <img alt="" src=""/>
                

<h3 id="span-id-introduction-introduction-span"><span id="Introduction">Introduction</span></h3>

<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td>Table of Contents</td>
</tr>
<tr class="even">
<td><p>•<a href="#Perl_is_hard">Perl is hard</a><br />
•<a href="#Perl_looks_like_line_noise">Perl looks like line noise</a><br />
•<a href="#Perl_is_hard_because_it_has_rege">Perl is hard because it has regexps</a><br />
•<a href="#Perl_is_hard_because_it_has_refe">Perl is hard because it has references</a><br />
•<a href="#Perl_is_just_for_Unix">Perl is just for Unix</a><br />
•<a href="#Perl_is_just_for_one_liners_ca">Perl is just for one-liners - can't build `real' programs with it.</a><br />
•<a href="#Perl_is_just_for_CGI">Perl is just for CGI</a><br />
•<a href="#Perl_is_too_slow">Perl is too slow</a><br />
•<a href="#Perl_is_insecure">Perl is insecure</a><br />
•<a href="#Perl_is_not_commercial_so_it_ca">Perl is not commercial, so it can't be any good</a><br />
•<a href="#Conclusion">Conclusion</a><br />
</p></td>
</tr>
</tbody>
</table>

<p>One of the things you might not realize when you&rsquo;re thinking about Perl and hearing about Perl is that there is an awful lot of disinformation out there, and it&rsquo;s really hard for someone who&rsquo;s not very familiar with Perl to separate the wheat from the chaff, and it&rsquo;s very easy to accept some of these things as gospel truth - sometimes without even realising it.</p>

<p>What I&rsquo;m going to do, then, is to pick out the top ten myths that you&rsquo;ll hear bandied around, and give a response to them. I&rsquo;m not going to try to persuade you to use Perl - the only way for you to know if it&rsquo;s for you is to get on and try it - but hopefully I can let you see that not all of what you hear is true.</p>

<p>First, though, let&rsquo;s make sure we understand what Perl is, and what it&rsquo;s for.</p>

<p>Perl is a general-purpose programming language. The answer to the question `Can I do this in Perl?&rsquo; is very probably `yes&rsquo;. It&rsquo;s often used for little system administration tasks and for CGI and other web stuff, but that&rsquo;s not the whole story. We&rsquo;ll see soon that you can use Perl for full-sized projects as well.</p>

<p>Perl is sometimes called a `scripting&rsquo; language, but only by people who don&rsquo;t like it or don&rsquo;t understand it. Firstly, there&rsquo;s no real difference between programming and scripting - it&rsquo;s all just telling the computer what you want it to do. Second, even if there was, Perl&rsquo;s as much of a scripting language as Java or C. I&rsquo;m going to talk about Perl programs here, but you might hear some people call them Perl scripts. The people who call them `programs&rsquo; on the whole write better ones.</p>

<h3 id="span-id-perl-is-hard-perl-is-hard-span"><span id="Perl_is_hard">Perl is hard</span></h3>

<p>The first thing people will tell you is that Perl is hard: hard to learn, hard to use, hard to understand. Since Perl is so powerful, the logic goes, it must be difficult, right?</p>

<p>Wrong. For a start, Perl is built on a number of languages that will be familiar to almost every programmer these days. Know any C? Then you&rsquo;ve got a head start with Perl. Know how to program the Unix shell? Or write an awk or sed program? If so, you&rsquo;ll immediately feel at home with some elements of Perl syntax.</p>

<p>And even if you don&rsquo;t know any of these languages, even if you&rsquo;re totally new to programming, I&rsquo;d still say Perl was one of the easiest languages to begin programming with, for two good reasons.</p>

<p>Perl works the way you do. One of the Perl mottos is `There&rsquo;s more than one way to do it&rsquo;. People approach tasks in very different ways, and sometimes come out with very different solutions to the same problem. Perl is accomodating - it doesn&rsquo;t force any particular style on you, (unless you ask it to) and it allows you to express your programming intentions in a way that reflects how you as a person think about programming. Here&rsquo;s an example: suppose we&rsquo;ve got a file which consists of two columns of data, separated by a colon. What we have to do is to swap around the two. This came up in a discussion the other day, and here&rsquo;s how I thought about doing it: Read a line, swap what&rsquo;s on either side of the colon, then print the line.</p>

<pre><code>        while (&lt;&gt;) {
                s/(.*):(.*)/$2:$1/;
                print;
        }
</code></pre>

<p>It&rsquo;s not a hard problem to understand, so it shouldn&rsquo;t be hard to solve. It only needs a few lines - in fact, if you use some command line options to perl, you can dispense with everything apart from the second line. But let&rsquo;s not get too technical when we can get by without it.</p>

<p>Now, for those of you who don&rsquo;t know that much Perl, that diamond on the first line means `read in a line&rsquo;, and the <code>s</code> on the second means `substitute&rsquo;. The brackets mean `remember&rsquo; and <code>.*</code> means `any amount of anything&rsquo;</p>

<p>So, while we can read a line in, we do some kind of substitution, and then print it out again. What are we substituting? We take something which we remember, followed by a colon, then something else we remember. Then we replace all that with the second thing, a colon, and the first thing. That&rsquo;s one, fairly natural way to think about it.</p>

<p>Someone else, however, chose to do it another way:</p>

<pre><code>        while (&lt;&gt;) {
                chomp;
                ($first, $second) = split /:/;
                print $second, &quot;:&quot;, $first, &quot;\n&quot;;
        }
</code></pre>

<p>Slightly longer, maybe a little easier to understand, (maybe not, I don&rsquo;t know) but the point is, that&rsquo;s how he thought about approaching the problem. It&rsquo;s how he visualised it, and it&rsquo;s how his mind works. Perl hasn&rsquo;t imposed any particular way of thinking about programming on us.</p>

<p>To go through it, quickly: <code>chomp</code> takes off the new-line. Then we split (using the reasonably obviously named <code>split</code> function) the incoming text into two variables, around a colon. Finally, we put it back together in reverse order, the second bit, the colon, the first bit, and last of all putting the new-line back on the end where it belongs.</p>

<p>The second thing which makes Perl easy is that you don&rsquo;t need to understand all of it to get the job done. Sure, we could have written the above program on the command line, like this:</p>

<pre><code>        % perl -p -e 's/(.*):(.*)/$2:$1/'
</code></pre>

<p>(<code>-p</code> makes Perl loop over the incoming data and print it out once you&rsquo;ve finished fiddling with it.)</p>

<p>But we didn&rsquo;t need to know that. You can do a lot with a little knowledge of Perl. Obviously, it&rsquo;s easier if you know more, but it&rsquo;s also easy to get started, and to use what you know to get the job done.</p>

<p>Let&rsquo;s take another example. We want to examine an <em>/etc/passwd</em> file and show some details about the users. Perl has some built-in functions to read entries from the password file, so we could use them. However, even if we didn&rsquo;t know about them, we could do the job with what we <strong>do</strong> know already: we know how to read in and split up a colon-delimited input file, which is all we need. There&rsquo;s more than one way to do it.</p>

<p>So, thanks to its similarity to other languages, the fact that it doesn&rsquo;t force you to think in any particular way, and the fact that a little Perl knowledge goes a long way, we can happily consign the idea that `Perl is hard&rsquo; to mythology.</p>

<h3 id="span-id-perl-looks-like-line-noise-perl-looks-like-line-noise-span"><span id="Perl_looks_like_line_noise">Perl looks like line noise</span></h3>

<p>The next most common thing you&rsquo;ll hear is that Perl is ugly, or untidy, or is a write-only language. Unfortunately for me, there&rsquo;s a large number of Perl programs out there that appear to back this up. But just because you can write ugly programs, this doesn&rsquo;t mean it&rsquo;s an ugly language - there was an Obfuscated C Competition long before there was an Obfuscated Perl one.</p>

<p>Each time I look at a piece of Perl that seems to have been uploaded in EBCDIC over a noisy serial line, I stop and wonder `what possesses someone to write something so ugly?&rsquo; Over time, I&rsquo;ve come to realise that a consequence of Perl being easy to use is that it&rsquo;s easy to abuse as well.</p>

<p>What I think happens goes something like this: you&rsquo;re faced with a data file which you need converted into another format, by yesterday. Perl to the rescue! In five minutes, you&rsquo;ve come up with something that makes sense to you at the time and does the job - it might not look pretty, but it works. You save it away somewhere, just in case the same problem comes up again. Sooner or later, it does - but this time the input format&rsquo;s just a tiny bit different, so you make a quick modification to deal with the change. Eventually, you&rsquo;ve got quite a sophisticated program. You never meant to write a huge translator, but it was just so easy to modify what you already had. Code reuse and rapid development have teamed up to create a monster.</p>

<p>The problem is that people then distribute this, because it works and because it&rsquo;s useful. And other people take one look at it and say, `Man, how could you write something so ugly?&rsquo; And Perl gets a bad reputation.</p>

<p>But you don&rsquo;t have to do it like that. You could realise what&rsquo;s going to happen and spend time re-writing your program, probably from scratch, to make it readable and maintainable. You can sacrifice development speed for readability just as well as the other way around.</p>

<p>You see, it&rsquo;s perfectly possible to write programs in Perl that are absolutely crystal clear, shining examples of the art of programming and show off your clever algorithms in all their beauty. But Perl isn&rsquo;t going to make you. It&rsquo;s up to you.</p>

<p>In short, Perl doesn&rsquo;t write illegible Perl, people do. If you can stop yourself being one of them, we can agree that Perl&rsquo;s reputation for looking like line noise is no more than a myth.</p>

<h3 id="span-id-perl-is-hard-because-it-has-rege-perl-is-hard-because-it-has-regexps-span"><span id="Perl_is_hard_because_it_has_rege">Perl is hard because it has regexps</span></h3>

<p>One of the parts of Perl that have contributed to the myth that Perl is an illegible language is the way matching is specified - regular expressions. As with the whole of Perl, these things are very powerful, and we all know that power corrupts. The basic idea is very simple: what we are doing is looking for certain things in a string. You want to look for the three characters `abc&rsquo;, you write <code>/abc/</code>. So far, so good.</p>

<p>The next thing that comes along is the ability to match not just exact characters, but certain types of characters: a digit can be matched with <code>\d</code>, and so to match a digit then a colon, you say <code>/\d:/</code>. We&rsquo;ve already seen that <code>.</code> matches any character. There&rsquo;s also <code>^</code> and <code>$</code> to specify the beginning and the end of the line respectively. It&rsquo;s still pretty easy to get the hang of, yes? To match two digits at the beginning of the line, followed by any character and then a comma, you specify each of those things in turn: <code>/^\d\d.,/</code></p>

<p>And so it goes on, getting more and more complex as you can express more complicated ideas about what you want to match. The important thing to remember is that the regular expression syntax is just like any other language: to express yourself in it, you need to get into the habit of being able to translate between it and your native language until you can think in the target language. So, even if I don&rsquo;t understand it by sight, I can work out what <code>/^.,\d.$/</code> does because I can read it out. At the beginning of the line, we want to find each of the following items: any character, then a comma, then a digit, then any character, which brings us to the end of the line.</p>

<p>Once we get into not just matching but also substitution, we can produce some really nasty looking stuff. Here&rsquo;s my current favourite example, which is relatively simple as far as regular expressions go. It corrects mispellings of `Teh&rsquo; and `teh&rsquo; to `The&rsquo; and `the&rsquo; respectively:</p>

<pre><code>        s/\b([tT])eh\b/$1he/g
</code></pre>

<p>You could sit down and read it out yourself, but Perl allows us to break up the regular expression, and whitespace and comments, so there&rsquo;s no reason for having incomprehensible regular expressions lying around. Here&rsquo;s a fully documented version. Once you have practise reading and writing regular expressions, you&rsquo;ll be able to do this kind of expansion in your head: (and you&rsquo;ll find it less distracting, too.)</p>

<pre><code>       s/\b   # Start with a word boundary, and
         (    # save away
         [tT] # either a `t' or a `T',
         )    # stop saving,
         eh   # and then the rest of the word
         \b   # ending at a word boundary
       /      # and replace it with
         $1   # the original character we saved, whether `t' or `T'
         he   # and the correct spelling
       /gx;   # globally throughout the string.
</code></pre>

<p>Regular expressions can look difficult at first sight, but once you know the code and you can break them down and build them up as above, you&rsquo;ll soon find that they&rsquo;re as natural a way of expressing finding text as your own language. Saying that they make Perl difficult, then, would be a myth.</p>

<h3 id="span-id-perl-is-hard-because-it-has-refe-perl-is-hard-because-it-has-references-span"><span id="Perl_is_hard_because_it_has_refe">Perl is hard because it has references</span></h3>

<p>The next one is actually two myths in one: first, there&rsquo;s the myth that Perl can&rsquo;t deal with complicated data structures. You&rsquo;ve only got three data types available in Perl: a scalar, which holds numbers and text and look like this: <code>$foo</code>; an array, which holds a list of scalars, and is represented like this: <code>@bar</code>; and a hash, which holds one-to-one correspondances between scalars, which we write like this: <code>%baz</code>. Hashes are usually used for storing `key-value&rsquo; type records: we&rsquo;ll see an example later on.</p>

<p>Not enough, you will be told, to build up the complicated structures you need in `real programming&rsquo;. Well, this one isn&rsquo;t even half true. Since Perl 5 came out, and that&rsquo;s five years ago now, Perl has been able to make complex structures out of references, and we&rsquo;ll see how it&rsquo;s done in a second.</p>

<p>So once you&rsquo;ve got around that one, you&rsquo;ll hear the opposite: references are too complicated, and you end up with a mess of punctuation symbols. Interestingly, the people who find references most complicated are people used to C - references are sort of like pointers, but not quite, leaving C people getting hung up about memory and addresses and all sorts of irrelevant things. You don&rsquo;t have to worry about how memory is laid out in Perl; you&rsquo;ve got more important things to do with your time. As usual, C programmers are confusing themselves by making things more complicated than they need to be.</p>

<p>References are, at their simplest, flat-pack storage for data. They turn any data - hashes, arrays, scalars, even subroutines - into a scalar that represents it. So, let&rsquo;s say we&rsquo;ve got some hashes as follows:</p>

<pre><code>        %billc = (
                name =&gt; &quot;Bill Clinton&quot;,
                job  =&gt; &quot;US President&quot;
        );

        %billg = (
                name =&gt; &quot;Bill Gates&quot;,
                job  =&gt; &quot;Microsoft President&quot;
        );
</code></pre>

<p>Of course, it&rsquo;s a hassle having an individual variable for each person, and there are a lot of Bills in the world - I get about four a month, and that&rsquo;s enough for me. Ideally, we want to put them all together, and we&rsquo;ll store that in an array. Problem! Arrays can only hold scalars, not hashes. No problem - use a reference to flat-pack each hash into a scalar. We do this simply by adding a backslash before the name:</p>

<pre><code>        $billc_r = \%billc;
        $billg_r = \%billg;
</code></pre>

<p>Now we&rsquo;ve got two scalars, which contain all the data in our arrays. To unpack the data back into a hash, you dereference it: just tell Perl you want to make it into a hash. We know hashes start with <code>%</code>, so we prefix the name of our reference with that:</p>

<pre><code>        %billc can now be accessed via %$billc_r
        %billg can now be accessed via %$billg_r
</code></pre>

<p>And now we can store these references into an array:</p>

<pre><code>        @bills = ( $billc_r, $billg_r );
</code></pre>

<p>or</p>

<pre><code>        @bills = ( \%billc, \%billg );
</code></pre>

<p>Hey presto! An array which contains two hashes - a complex data structure.</p>

<p>Of course, there are a couple more tricks: ways of creating references to arrays and hashes directly instead of taking a reference to an already existing variable, and ways of getting to the data in a reference directly instead of dereferencing to a new variable. (See the symmetry?)</p>

<p>But as before, you don&rsquo;t need to know the whole of the language to get things done. Yes, it makes your code clearer and shorter if you don&rsquo;t use temporary variables unnecessarily, but if you don&rsquo;t know how do to that, it doesn&rsquo;t stop you using references.</p>

<p>Granted, you may not understand references in their entirety now. You may not even see why they&rsquo;re useful; in fact, if you&rsquo;re just writing simple programs that throw text around you probably will never need to use them.</p>

<p>But hopefully now you can sail between the Scylla that says you can&rsquo;t handle complicated data, and the Charybdis that says you can but it&rsquo;s hopelessly confusing, and see that, like the rest of the Odyssey, it&rsquo;s just a myth.</p>

<h3 id="span-id-perl-is-just-for-unix-perl-is-just-for-unix-span"><span id="Perl_is_just_for_Unix">Perl is just for Unix</span></h3>

<p>Isn&rsquo;t Perl just for Unix? I hear this, and I&rsquo;m finding it harder to answer it with a straight face. The standard Perl distribution contains support for over 70 operating systems. Separate porting projects exist for Windows and for the Macintosh, and many other systems besides. It&rsquo;s hard to find a computer that Perl doesn&rsquo;t run on these days: Perl now even runs on the Psion organiser and is close to being built on the Palm Pilot.</p>

<p>This means that Perl is one of the most - if not <strong>the</strong> most portable language around. A properly written program will need absolutely no changes to move from Unix to Windows NT and on to the Macintosh, and an improperly written one will probably need three or four lines of change.</p>

<p>Perl is, most definitely, not just for Unix. That one is, purely and simply, a myth.</p>

<h3 id="span-id-perl-is-just-for-one-liners-ca-perl-is-just-for-one-liners-can-t-build-real-programs-with-it-span"><span id="Perl_is_just_for_one_liners_ca">Perl is just for one-liners - can&rsquo;t build `real&rsquo; programs with it.</span></h3>

<p>The same sort of people who say that Perl is `just a scripting language&rsquo; will probably try and tell you that Perl isn&rsquo;t suitable for `serious programming&rsquo;. You wouldn&rsquo;t write an operating system in Perl, so it can&rsquo;t be any good.</p>

<p>Well, maybe you wouldn&rsquo;t write an operating system in it. I know one or two people who are trying, but they&rsquo;re freaks. However, this doesn&rsquo;t mean you can&rsquo;t build large, sophisticated and important programs in Perl. It&rsquo;s just a programming language.</p>

<p>People have written some pretty big stuff in Perl - it manages Slashdot, which shows it can stand up to a fair amount of load, the data from the Human Genome Project, and innumerable network servers and clients. Programs in the hundreds of thousands of lines of Perl are not uncommon.</p>

<p>Furthermore, you can extend Perl to get at any C libraries you have around - anything you can do in C, you can do in Perl, and more besides. Yes, it&rsquo;s a good language for one-liners and short data mangling, but that&rsquo;s not all Perl&rsquo;s about.</p>

<p>To say that Perl isn&rsquo;t suited for `serious programming&rsquo; shows either a misunderstanding of what Perl is, or what `serious programming is&rsquo; and is, at any rate, a myth.</p>

<h3 id="span-id-perl-is-just-for-cgi-perl-is-just-for-cgi-span"><span id="Perl_is_just_for_CGI">Perl is just for CGI</span></h3>

<p>Ah, the great CGI/Perl confusion. Since Perl is the best language for doing dynamic web content in, people have managed to get a little muddled on the differences between Perl and CGI.</p>

<p>CGI is just a protocol - an agreement that a web server and a program are going to talk the same language. You can get Perl to speak that protocol, and that&rsquo;s what a lot of people do. You can get C to speak CGI, if you must. I&rsquo;ve written programs that talk CGI in INTERCAL, but then, I&rsquo;m like that. There&rsquo;s nothing Perl specific about CGI.</p>

<p>There&rsquo;s also nothing CGI specific about Perl. Yes, that might be what most people out there are using Perl for, and yes, that&rsquo;s because it&rsquo;s a task that Perl is particularly well suited to. But as we&rsquo;ve seen, people can do, and are doing, far more with Perl than just messing about on the Web. Heck, Perl was around back when the Web was in nappies.</p>

<p>CGI is Perl? Perl is CGI? It&rsquo;s all a load of myths.</p>

<h3 id="span-id-perl-is-too-slow-perl-is-too-slow-span"><span id="Perl_is_too_slow">Perl is too slow</span></h3>

<p>Maybe you&rsquo;ll hear people say that Perl is too slow to be any use.</p>

<p>In some cases, it might be pretty slow relative to something like C: C can be anything up to 50 times faster than an equivalent Perl program. But it depends on a lot of things.</p>

<p>It depends on how you write your program; if you write in a C-like style, you&rsquo;ll find it runs considerably slower than an equivalent program written with Perl idioms. For instance, you could look at a string character by character, like you would in C. You&rsquo;d be doing a lot of work yourself, though, that you could probably do with a simple regular expression. The less you ask Perl to do, the faster it runs.</p>

<p>Sometimes, though, there are things that C finds hard and Perl breezes; string manipulation is one thing, because Perl allows you to think of things at the string level, instead of forcing you to see them a character at a time.</p>

<p>There are, however, occasions when C is going to win hands down in terms of running time. But if you&rsquo;re writing software yourself, you have to consider another area: development time. The amount of time and emotional energy you have to have to exert in programming is important to you, and, since programmers cost a lot of money these days, whoever pays for you, too.</p>

<p>Let&rsquo;s take a really simple example to show how it works: we&rsquo;ve got a document with a series of numbered points. We&rsquo;ve added another point at line 50, so after that, every number at the beginning of a line after line 50 should be increased by one. I&rsquo;d rather spend a few seconds to cook up a bit of Perl like this:</p>

<pre><code>        % perl -p -e 's/^(\d+)/1+$1/e if $. &gt; 50'
</code></pre>

<p>than a good half hour trying to hack it up in C, with the associated medication fees resulting from me having had to bang my head against a brick wall for that length of time.</p>

<p>Granted, maybe we don&rsquo;t need the speed of C for a simple example like that, but the principle extends to big programs too: You <strong>might</strong> be able to write faster programs in C, but you can <strong>always</strong> write programs faster in Perl.</p>

<h3 id="span-id-perl-is-insecure-perl-is-insecure-span"><span id="Perl_is_insecure">Perl is insecure</span></h3>

<p>What about security? There&rsquo;s got to be some chinks in the armour there. People can read the source code to your programs, so you&rsquo;re vunerable to all sorts of problems!</p>

<p>While it&rsquo;s true that the source must be readable in order for the Perl interpreter to run it, this doesn&rsquo;t mean that Perl is insecure. It might mean that what you&rsquo;ve written is insecure, and you think it would be better hiding away the deficiencies, but these days, very few people and Microsoft actually believe that. Security by obscurity isn&rsquo;t very much security at all.</p>

<p>Just like the readability of your code and the wonderful Y2K bug, you can&rsquo;t blame Perl for what you choose to write with it. Perl isn&rsquo;t going to magically make you write secure programs - sure, if you use the tainting mechanism, it&rsquo;ll try its hardest to stop you writing insecure code, but that&rsquo;s no substitute for knowing how to write properly yourself.</p>

<p>If you really want, you can try and hide the source code; you can use source filters, you can try compiling it with the Perl compiler, but none of these things guarantee that it can&rsquo;t be unencrypted or decompiled - and none of them will fix any problems. Far better just to write secure code.</p>

<p>So, what you write might be insecure, but Perl itself insecure? No, that&rsquo;s another myth.</p>

<h3 id="span-id-perl-is-not-commercial-so-it-ca-perl-is-not-commercial-so-it-can-t-be-any-good-span"><span id="Perl_is_not_commercial_so_it_ca">Perl is not commercial, so it can&rsquo;t be any good</span></h3>

<p>Finally, you&rsquo;ll get those who claim that, since Perl isn&rsquo;t commercial software, it can&rsquo;t be any good. There&rsquo;s no support for it, the documentation is provided by volunteers, and so on.</p>

<p>It amazes me that in a world of Linux and Apache and Samba and many other winning technologies, people can still think like this. But then, it shouldn&rsquo;t amaze me, because commercial vendors want them to think like this and spend a lot of money trying to frighten them into doing so.</p>

<p>I could spend my time saying that because it&rsquo;s supported by volunteers, people are doing it for love instead of for money, and this leads to a better product, but let&rsquo;s not bother fighting on philosophical grounds about the nature of volunteer development. Let&rsquo;s get down to facts.</p>

<p>The standard Perl distribution contains over 70,000 lines of documentation, which should really be enough for anyone. If not, there are innumerable tutorials available on the web. Add to that all the lines of documentation on CPAN modules, and we&rsquo;ve got a pretty substantial base of prose. And that&rsquo;s just the freely available stuff. At last count, there were over 250 books dedicated to Perl, and probably as many again that include it.</p>

<p>Documentation is not something we have a problem with.</p>

<p>What about support? Well, if you&rsquo;ve read through all that documentation and you still have a problem, there are at least five Usenet newsgroups dedicated to Perl, and at least one IRC channel. These are all again staffed by volunteers, so they don&rsquo;t have to be nice to you if you obviously haven&rsquo;t read the FAQs. But that doesn&rsquo;t mean they&rsquo;re not useful, and some of the big names in the Perl world hang around there. You can probably find answers to your questions, if you show enough common sense.</p>

<p>Of course, you may need more than that - thousands of firms offer Perl training, and you can buy real support contracts, shrink-wrapped Perl packages and everything that would make even the most pointy-haired of bosses feel comfortable with it. Just because it&rsquo;s free, doesn&rsquo;t mean it isn&rsquo;t commercial, and the idea that making it free doesn&rsquo;t make it worthwhile is nothing more than a myth.</p>

<h3 id="span-id-conclusion-conclusion-span"><span id="Conclusion">Conclusion</span></h3>

<p>That&rsquo;s not all the myths you&rsquo;ll hear about Perl; I haven&rsquo;t time to list them all, but there&rsquo;s a lot of disinformation out there. If you&rsquo;ve heard any of those things I&rsquo;ve mentioned about, I&rsquo;d ask you to take another look at Perl; it&rsquo;s easier than you think, it&rsquo;s faster than you think, and it&rsquo;s better than you think. Don&rsquo;t listen to the myths - don&rsquo;t even take my word for it. Get out there and try it for yourself.</p>

              </article>
              <p><strong>Tags</strong></p>
              <div class="tags">
                <div class="category"><a href="/categories/community">community</a></div>
                
              </div>
            </div>
            
              
                
<div class="row" id="author-bio-simon-cozens">
  <div class="col-sm-2">
    
    <a href="/authors/simon-cozens/"><div class="circle-avatar" style="background-image:url(/images/author/simon-cozens.jpg)"></div></a>
  </div>
  <div class="col-sm-10">
    <a href="/authors/simon-cozens/"><h3>Simon Cozens</h3></a>
    <p></p>
    <h5><a href="/authors/simon-cozens/">Browse their articles</a></h5>
  </div>
</div>

            
            <div class="row">
              <h3>Feedback</h3>
              <p>Something wrong with this article? Help us out by opening an issue or pull request on <a href="https://github.com/tpf/perldotcom/blob/master/content/legacy/_pub_2000_01_10PerlMyths.md">GitHub</a></p>
            </div>
          </div>
          <div class="col-md-3">
            <div class="latest-sidebar">

  <div class="row">
    <div class="col-sm-12 centering">
      <span style="font-size:1.8em" class="antonio txt-blue-major">OUR LATEST ARTICLES</span>
    </div>
  </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/the-perl-admbassador-curtis-poe/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/the-perl-ambassador-curtis-poe/curtis-poe.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>The Perl Ambassador: Curtis &#39;Ovid&#39; Poe</h6>
          <p style="line-height:1"><small>The person behind the news of Perl</small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/a-tour-with-net-ftp/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/a-tour-with-net-ftp/thumb_kidyes.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>A tour with Net::FTP</h6>
          <p style="line-height:1"><small>How to write an FTP client in Perl</small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/shortcode_test/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/author/brian-d-foy.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>shortcode_test</h6>
          <p style="line-height:1"><small></small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/listen-to-larry-wall-s-state-of-the-onion-2000-on-youtube/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/listen-to-larry-wall-s-state-of-the-onion-2000-on-youtube/thumb_larry-wall.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>Listen to Larry Wall&#39;s State of the Onion 2000 on YouTube</h6>
          <p style="line-height:1"><small></small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/announcing-perl-7/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/announcing-perl-7/thumb_seven_on_blue_wall.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>Announcing Perl 7</h6>
          <p style="line-height:1"><small>Perl 5 with modern defaults</small></p>
      </div>
        </a>
    </div>
  
</div>
<div class="row" style="margin-top:20px">
  <div class="col-sm-12 centering">
  <script async src="/widget/toplinks/toplinks.js" type="text/javascript"></script>
    <div id="toplinks"></div>
  </div>
</div>

<div class="row" style="margin-top:20px">
  <div class="col-sm-12 centering">
    <a class="twitter-timeline" data-height="640" data-dnt="true" data-theme="dark" href="https://twitter.com/perlfoundation?ref_src=twsrc%5Etfw">Tweets by perlfoundation</a> <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
  </div>
</div>

<div class="row" style="margin-top:20px">
  <div class="col-sm-12 centering">
    <script src="https://www.reddit.com/r/perl/hot/.embed?limit=10&t=all" type="text/javascript"></script>
  </div>
</div>



          </div>
        </div>
      </div>
    </section>
  </section>
<script>
 
var tables, i;
tables = document.getElementsByTagName('table');
for (i=0;i<tables.length;i++) {
  tables[i].className = 'table table-striped';
}
</script>
<div class="push"></div>
<div class="footer">
  <div class="container">
    <div class="row">
      <div class="col-md-1">
        <h5>Site Map</h5>
        <ul>
        <li><a href="/">Home</a></li>
        <hr>
        <li><a href="/about">About</a></li>
        <hr>
        <li><a href="/authors">Authors</a></li>
        <hr>
        <li><a href="/categories">Categories</a></li>
        <hr>
        <li><a href="/tags">Tags</a></li>
        <hr>
        </ul>
      </div>
      <div class="col-md-3">
        <h5>Contact Us</h5>
        <p>To get in touch, send an email to: perl.com-editor@perl.org</p>
        <p><a href="https://perl.org">
              <img src="/images/site/perl-onion_20.png" alt="Perl Onion"></a>
          <a href="https://twitter.com/intent/follow?screen_name=perlfoundation">
              <img src="/images/site/twitter_20.png" alt="twitter"></a>
          <a href="/index.xml" /><img src="/images/site/rss_20.png" alt="rss"></a>
          <a href="https://github.com/tpf/perldotcom">
              <img src="/images/site/github_light_20.png" alt="GitHub logo"></a></p>
      </div>
      <div class="col-md-2">
          <h5>License</h5>
          <p>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc/3.0/">Creative Commons Attribution-NonCommercial 3.0 Unported License</a>.</p>
          <p><a rel="license" href="https://creativecommons.org/licenses/by-nc/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/3.0/88x31.png" /></a></p>
      </div>
      <div class="col-md-5">
          <h5>Legal</h5>
          <p>Perl.com and the authors make no representations with respect to the accuracy or completeness of the contents of all work on this website and specifically disclaim all warranties, including without limitation warranties of fitness for a particular purpose. The information published on this website may not be suitable for every situation. All work on this website is provided with the understanding that Perl.com and the authors are not engaged in rendering professional services. Neither Perl.com nor the authors shall be liable for damages arising herefrom.</p>
      </div>
    </div>
  </div>
</div>
<script src="/javascript/jquery.min.js"></script>
<script src="/javascript/bootstrap.min.js"></script>
<script data-no-instant>document.write('<script src="/livereload.js?port=1313&mindelay=10"></' + 'script>')</script></body>
</html>

